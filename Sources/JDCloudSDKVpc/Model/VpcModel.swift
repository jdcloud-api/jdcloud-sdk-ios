/* Copyright 2018 JDCLOUD.COM

   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at

     http:#www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.

   网段
   网段相关接口

   OpenAPI spec version: v1
   Contact: 

   NOTE: This class is auto generated by the jdcloud code generator program.
 */


import Foundation
import JDCloudSDKCharge
///  modifyRouteTableRulesSpec
public class ModifyRouteTableRulesSpec:NSObject,Codable{
    /// 路由表规则信息
    /// Required:true
    var modifyRouteTableRuleSpecs:[ModifyRouteTableRules?]?



    public  init(modifyRouteTableRuleSpecs:[ModifyRouteTableRules?]?){
             self.modifyRouteTableRuleSpecs = modifyRouteTableRuleSpecs
    }

    enum ModifyRouteTableRulesSpecCodingKeys: String, CodingKey {
        case modifyRouteTableRuleSpecs
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: ModifyRouteTableRulesSpecCodingKeys.self)
        self.modifyRouteTableRuleSpecs = try decoderContainer.decode([ModifyRouteTableRules?]?.self, forKey: .modifyRouteTableRuleSpecs)
    }
}
public extension ModifyRouteTableRulesSpec{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: ModifyRouteTableRulesSpecCodingKeys.self)
         try encoderContainer.encode(modifyRouteTableRuleSpecs, forKey: .modifyRouteTableRuleSpecs)
    }
}
///  addRouteTableRulesSpec
public class AddRouteTableRulesSpec:NSObject,Codable{
    /// 安全组规则信息
    /// Required:true
    var routeTableRuleSpecs:[AddRouteTableRules?]?



    public  init(routeTableRuleSpecs:[AddRouteTableRules?]?){
             self.routeTableRuleSpecs = routeTableRuleSpecs
    }

    enum AddRouteTableRulesSpecCodingKeys: String, CodingKey {
        case routeTableRuleSpecs
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: AddRouteTableRulesSpecCodingKeys.self)
        self.routeTableRuleSpecs = try decoderContainer.decode([AddRouteTableRules?]?.self, forKey: .routeTableRuleSpecs)
    }
}
public extension AddRouteTableRulesSpec{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: AddRouteTableRulesSpecCodingKeys.self)
         try encoderContainer.encode(routeTableRuleSpecs, forKey: .routeTableRuleSpecs)
    }
}
///  disassociateRouteTableSpec
public class DisassociateRouteTableSpec:NSObject,Codable{
    /// 路由表要解绑的子网ID，解绑后子网绑定默认路由表
    /// Required:true
    var subnetId:String



    public  init(subnetId:String){
             self.subnetId = subnetId
    }

    enum DisassociateRouteTableSpecCodingKeys: String, CodingKey {
        case subnetId
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: DisassociateRouteTableSpecCodingKeys.self)
        self.subnetId = try decoderContainer.decode(String.self, forKey: .subnetId)
    }
}
public extension DisassociateRouteTableSpec{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: DisassociateRouteTableSpecCodingKeys.self)
         try encoderContainer.encode(subnetId, forKey: .subnetId)
    }
}
///  associateRouteTableSpec
public class AssociateRouteTableSpec:NSObject,Codable{
    /// 路由表要绑定的子网ID列表, subnet已被其他路由表绑定时，自动解绑。
    /// Required:true
    var subnetIds:[String?]?



    public  init(subnetIds:[String?]?){
             self.subnetIds = subnetIds
    }

    enum AssociateRouteTableSpecCodingKeys: String, CodingKey {
        case subnetIds
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: AssociateRouteTableSpecCodingKeys.self)
        self.subnetIds = try decoderContainer.decode([String?]?.self, forKey: .subnetIds)
    }
}
public extension AssociateRouteTableSpec{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: AssociateRouteTableSpecCodingKeys.self)
         try encoderContainer.encode(subnetIds, forKey: .subnetIds)
    }
}
///  modifyRouteTableRules
public class ModifyRouteTableRules:NSObject,Codable{
    /// 路由表规则的ID
    /// Required:true
    var ruleId:String
    /// 规则匹配优先级，取值范围[1,255]。当路由规则子网掩码不同时，路由最长匹配优先；当路由规则子网掩码相同时, 按照优先级匹配转发, 优先级数字越小优先级越高，路由规则子网掩码相同、优先级相同、下一跳不同时，形成等价路由，不同下一跳负载均担。
    var priority:Double?
    /// 下一跳类型, 取值范围:instance:云主机, internet:公网, vpc_peering:vpc对等连接, bgw:边界网关
    var nextHopType:String?
    /// 下一跳id
    var nextHopId:String?
    /// 路由表规则前缀, internet类型路由跟其他类型的路由，addressPrefix不允许重复
    var addressPrefix:String?



    public  init(ruleId:String){
             self.ruleId = ruleId
    }

    enum ModifyRouteTableRulesCodingKeys: String, CodingKey {
        case ruleId
        case priority
        case nextHopType
        case nextHopId
        case addressPrefix
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: ModifyRouteTableRulesCodingKeys.self)
        self.ruleId = try decoderContainer.decode(String.self, forKey: .ruleId)
        if decoderContainer.contains(.priority)
        {
            self.priority = try decoderContainer.decode(Double?.self, forKey: .priority)
        }
        if decoderContainer.contains(.nextHopType)
        {
            self.nextHopType = try decoderContainer.decode(String?.self, forKey: .nextHopType)
        }
        if decoderContainer.contains(.nextHopId)
        {
            self.nextHopId = try decoderContainer.decode(String?.self, forKey: .nextHopId)
        }
        if decoderContainer.contains(.addressPrefix)
        {
            self.addressPrefix = try decoderContainer.decode(String?.self, forKey: .addressPrefix)
        }
    }
}
public extension ModifyRouteTableRules{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: ModifyRouteTableRulesCodingKeys.self)
         try encoderContainer.encode(ruleId, forKey: .ruleId)
         try encoderContainer.encode(priority, forKey: .priority)
         try encoderContainer.encode(nextHopType, forKey: .nextHopType)
         try encoderContainer.encode(nextHopId, forKey: .nextHopId)
         try encoderContainer.encode(addressPrefix, forKey: .addressPrefix)
    }
}
///  routeTableRule
public class RouteTableRule:NSObject,Codable{
    /// 路由表规则ID
    var ruleId:String?
    /// 规则匹配优先级，取值范围[1,255]，默认为100。当路由规则子网掩码不同时，路由最长匹配优先；当路由规则子网掩码相同时, 按照优先级匹配转发, 优先级数字越小优先级越高，路由规则子网掩码相同、优先级相同、下一跳不同时，形成等价路由，不同下一跳负载均担。
    var priority:Double?
    /// 下一跳类型, 取值范围:local:本地, instance:云主机, internet:公网, vpc_peering:vpc对等连接, bgw:边界网关
    var nextHopType:String?
    /// 下一跳id
    var nextHopId:String?
    /// 匹配地址前缀, internet类型路由跟其他类型的路由，addressPrefix不允许重复
    var addressPrefix:String?



    public override init(){
            super.init()
    }

    enum RouteTableRuleCodingKeys: String, CodingKey {
        case ruleId
        case priority
        case nextHopType
        case nextHopId
        case addressPrefix
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: RouteTableRuleCodingKeys.self)
        if decoderContainer.contains(.ruleId)
        {
            self.ruleId = try decoderContainer.decode(String?.self, forKey: .ruleId)
        }
        if decoderContainer.contains(.priority)
        {
            self.priority = try decoderContainer.decode(Double?.self, forKey: .priority)
        }
        if decoderContainer.contains(.nextHopType)
        {
            self.nextHopType = try decoderContainer.decode(String?.self, forKey: .nextHopType)
        }
        if decoderContainer.contains(.nextHopId)
        {
            self.nextHopId = try decoderContainer.decode(String?.self, forKey: .nextHopId)
        }
        if decoderContainer.contains(.addressPrefix)
        {
            self.addressPrefix = try decoderContainer.decode(String?.self, forKey: .addressPrefix)
        }
    }
}
public extension RouteTableRule{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: RouteTableRuleCodingKeys.self)
         try encoderContainer.encode(ruleId, forKey: .ruleId)
         try encoderContainer.encode(priority, forKey: .priority)
         try encoderContainer.encode(nextHopType, forKey: .nextHopType)
         try encoderContainer.encode(nextHopId, forKey: .nextHopId)
         try encoderContainer.encode(addressPrefix, forKey: .addressPrefix)
    }
}
///  routeTableSpec
public class RouteTableSpec:NSObject,Codable{
    /// 路由表所属的私有网络ID
    /// Required:true
    var vpcId:String
    /// 路由表名称，只允许输入中文、数字、大小写字母、英文下划线“_”及中划线“-”，不允许为空且不超过32字符。
    /// Required:true
    var routeTableName:String
    /// 描述,​ 允许输入UTF-8编码下的全部字符，不超过256字符
    var descriptionValue:String?



    public  init(vpcId:String,routeTableName:String){
             self.vpcId = vpcId
             self.routeTableName = routeTableName
    }

    enum RouteTableSpecCodingKeys: String, CodingKey {
        case vpcId
        case routeTableName
        case descriptionValue = "description"
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: RouteTableSpecCodingKeys.self)
        self.vpcId = try decoderContainer.decode(String.self, forKey: .vpcId)
        self.routeTableName = try decoderContainer.decode(String.self, forKey: .routeTableName)
        if decoderContainer.contains(.descriptionValue)
        {
            self.descriptionValue = try decoderContainer.decode(String?.self, forKey: .descriptionValue)
        }
    }
}
public extension RouteTableSpec{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: RouteTableSpecCodingKeys.self)
         try encoderContainer.encode(vpcId, forKey: .vpcId)
         try encoderContainer.encode(routeTableName, forKey: .routeTableName)
         try encoderContainer.encode(descriptionValue, forKey: .descriptionValue)
    }
}
///  addRouteTableRules
public class AddRouteTableRules:NSObject,Codable{
    /// 下一跳类型, 取值范围:instance:云主机, internet:公网, vpc_peering:vpc对等连接, bgw:边界网关
    /// Required:true
    var nextHopType:String
    /// 下一跳id
    /// Required:true
    var nextHopId:String
    /// 匹配地址前缀, internet类型路由跟其他类型的路由，addressPrefix不允许重复
    /// Required:true
    var addressPrefix:String
    /// 规则匹配优先级，取值范围[1,255]，默认为100。当路由规则子网掩码不同时，路由最长匹配优先；当路由规则子网掩码相同时, 按照优先级匹配转发, 优先级数字越小优先级越高，路由规则子网掩码相同、优先级相同、下一跳不同时，形成等价路由，不同下一跳负载均担。
    var priority:Double?



    public  init(nextHopType:String,nextHopId:String,addressPrefix:String){
             self.nextHopType = nextHopType
             self.nextHopId = nextHopId
             self.addressPrefix = addressPrefix
    }

    enum AddRouteTableRulesCodingKeys: String, CodingKey {
        case nextHopType
        case nextHopId
        case addressPrefix
        case priority
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: AddRouteTableRulesCodingKeys.self)
        self.nextHopType = try decoderContainer.decode(String.self, forKey: .nextHopType)
        self.nextHopId = try decoderContainer.decode(String.self, forKey: .nextHopId)
        self.addressPrefix = try decoderContainer.decode(String.self, forKey: .addressPrefix)
        if decoderContainer.contains(.priority)
        {
            self.priority = try decoderContainer.decode(Double?.self, forKey: .priority)
        }
    }
}
public extension AddRouteTableRules{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: AddRouteTableRulesCodingKeys.self)
         try encoderContainer.encode(nextHopType, forKey: .nextHopType)
         try encoderContainer.encode(nextHopId, forKey: .nextHopId)
         try encoderContainer.encode(addressPrefix, forKey: .addressPrefix)
         try encoderContainer.encode(priority, forKey: .priority)
    }
}
///  modifyRouteTableSpec
public class ModifyRouteTableSpec:NSObject,Codable{
    /// 路由表的名字。名称取值范围：1-32个中文、英文大小写的字母、数字和下划线分隔符
    var routeTableName:String?
    /// 路由表的描述，取值范围：0-256个UTF-8编码下的全部字符
    var descriptionValue:String?



    public override init(){
            super.init()
    }

    enum ModifyRouteTableSpecCodingKeys: String, CodingKey {
        case routeTableName
        case descriptionValue = "description"
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: ModifyRouteTableSpecCodingKeys.self)
        if decoderContainer.contains(.routeTableName)
        {
            self.routeTableName = try decoderContainer.decode(String?.self, forKey: .routeTableName)
        }
        if decoderContainer.contains(.descriptionValue)
        {
            self.descriptionValue = try decoderContainer.decode(String?.self, forKey: .descriptionValue)
        }
    }
}
public extension ModifyRouteTableSpec{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: ModifyRouteTableSpecCodingKeys.self)
         try encoderContainer.encode(routeTableName, forKey: .routeTableName)
         try encoderContainer.encode(descriptionValue, forKey: .descriptionValue)
    }
}
///  routeTable
public class RouteTable:NSObject,Codable{
    /// 路由表ID
    var routeTableId:String?
    /// 路由表名称，只允许输入中文、数字、大小写字母、英文下划线“_”及中划线“-”，不允许为空且不超过32字符。
    var routeTableName:String?
    /// 路由表类型，default：默认路由表，custom：自定义路由表
    var routeTableType:String?
    /// 路由表描述信息，允许输入UTF-8编码下的全部字符，不超过256字符。
    var descriptionValue:String?
    /// 私有网络ID
    var vpcId:String?
    /// 路由表规则信息
    var routeTableRules:[RouteTableRule?]?
    /// 路由表绑定的子网列表
    var subnetIds:[String?]?
    /// 路由表创建时间
    var createdTime:String?



    public override init(){
            super.init()
    }

    enum RouteTableCodingKeys: String, CodingKey {
        case routeTableId
        case routeTableName
        case routeTableType
        case descriptionValue = "description"
        case vpcId
        case routeTableRules
        case subnetIds
        case createdTime
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: RouteTableCodingKeys.self)
        if decoderContainer.contains(.routeTableId)
        {
            self.routeTableId = try decoderContainer.decode(String?.self, forKey: .routeTableId)
        }
        if decoderContainer.contains(.routeTableName)
        {
            self.routeTableName = try decoderContainer.decode(String?.self, forKey: .routeTableName)
        }
        if decoderContainer.contains(.routeTableType)
        {
            self.routeTableType = try decoderContainer.decode(String?.self, forKey: .routeTableType)
        }
        if decoderContainer.contains(.descriptionValue)
        {
            self.descriptionValue = try decoderContainer.decode(String?.self, forKey: .descriptionValue)
        }
        if decoderContainer.contains(.vpcId)
        {
            self.vpcId = try decoderContainer.decode(String?.self, forKey: .vpcId)
        }
        if decoderContainer.contains(.routeTableRules)
        {
            self.routeTableRules = try decoderContainer.decode([RouteTableRule?]?.self, forKey: .routeTableRules)
        }
        if decoderContainer.contains(.subnetIds)
        {
            self.subnetIds = try decoderContainer.decode([String?]?.self, forKey: .subnetIds)
        }
        if decoderContainer.contains(.createdTime)
        {
            self.createdTime = try decoderContainer.decode(String?.self, forKey: .createdTime)
        }
    }
}
public extension RouteTable{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: RouteTableCodingKeys.self)
         try encoderContainer.encode(routeTableId, forKey: .routeTableId)
         try encoderContainer.encode(routeTableName, forKey: .routeTableName)
         try encoderContainer.encode(routeTableType, forKey: .routeTableType)
         try encoderContainer.encode(descriptionValue, forKey: .descriptionValue)
         try encoderContainer.encode(vpcId, forKey: .vpcId)
         try encoderContainer.encode(routeTableRules, forKey: .routeTableRules)
         try encoderContainer.encode(subnetIds, forKey: .subnetIds)
         try encoderContainer.encode(createdTime, forKey: .createdTime)
    }
}
///  modifyQuotaSpec
public class ModifyQuotaSpec:NSObject,Codable{
    /// 资源类型，取值范围：vpc、elastic_ip、subnet、security_group、vpcpeering、network_interface（配额只统计辅助网卡）
    /// Required:true
    var type:String
    /// type为vpc、elastic_ip、network_interface不设置, type为subnet、security_group、vpcpeering设置为vpcId
    var parentResourceId:String?
    /// 配额大小
    /// Required:true
    var maxLimit:Int



    public  init(type:String,maxLimit:Int){
             self.type = type
             self.maxLimit = maxLimit
    }

    enum ModifyQuotaSpecCodingKeys: String, CodingKey {
        case type
        case parentResourceId
        case maxLimit
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: ModifyQuotaSpecCodingKeys.self)
        self.type = try decoderContainer.decode(String.self, forKey: .type)
        if decoderContainer.contains(.parentResourceId)
        {
            self.parentResourceId = try decoderContainer.decode(String?.self, forKey: .parentResourceId)
        }
        self.maxLimit = try decoderContainer.decode(Int.self, forKey: .maxLimit)
    }
}
public extension ModifyQuotaSpec{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: ModifyQuotaSpecCodingKeys.self)
         try encoderContainer.encode(type, forKey: .type)
         try encoderContainer.encode(parentResourceId, forKey: .parentResourceId)
         try encoderContainer.encode(maxLimit, forKey: .maxLimit)
    }
}
///  unassignSecondaryIpsSpec
public class UnassignSecondaryIpsSpec:NSObject,Codable{
    /// 指定删除的secondaryIp地址
    var secondaryIps:[String?]?



    public override init(){
            super.init()
    }

    enum UnassignSecondaryIpsSpecCodingKeys: String, CodingKey {
        case secondaryIps
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: UnassignSecondaryIpsSpecCodingKeys.self)
        if decoderContainer.contains(.secondaryIps)
        {
            self.secondaryIps = try decoderContainer.decode([String?]?.self, forKey: .secondaryIps)
        }
    }
}
public extension UnassignSecondaryIpsSpec{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: UnassignSecondaryIpsSpecCodingKeys.self)
         try encoderContainer.encode(secondaryIps, forKey: .secondaryIps)
    }
}
///  networkInterfaceSpec
public class NetworkInterfaceSpec:NSObject,Codable{
    /// 子网ID
    /// Required:true
    var subnetId:String
    /// 可用区，用户的默认可用区
    var az:String?
    /// 网卡名称，只允许输入中文、数字、大小写字母、英文下划线“_”及中划线“-”，不允许为空且不超过32字符。
    var networkInterfaceName:String?
    /// 网卡主IP，如果不指定，会自动从子网中分配
    var primaryIpAddress:String?
    /// SecondaryIp列表
    var secondaryIpAddresses:[String?]?
    /// 自动分配的SecondaryIp数量
    var secondaryIpCount:Int?
    /// 要绑定的安全组ID列表，最多指定5个安全组
    var securityGroups:[String?]?
    /// 源和目标IP地址校验，取值为0或者1,默认为1
    var sanityCheck:Int?
    /// 描述,​ 允许输入UTF-8编码下的全部字符，不超过256字符
    var descriptionValue:String?



    public  init(subnetId:String){
             self.subnetId = subnetId
    }

    enum NetworkInterfaceSpecCodingKeys: String, CodingKey {
        case subnetId
        case az
        case networkInterfaceName
        case primaryIpAddress
        case secondaryIpAddresses
        case secondaryIpCount
        case securityGroups
        case sanityCheck
        case descriptionValue = "description"
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: NetworkInterfaceSpecCodingKeys.self)
        self.subnetId = try decoderContainer.decode(String.self, forKey: .subnetId)
        if decoderContainer.contains(.az)
        {
            self.az = try decoderContainer.decode(String?.self, forKey: .az)
        }
        if decoderContainer.contains(.networkInterfaceName)
        {
            self.networkInterfaceName = try decoderContainer.decode(String?.self, forKey: .networkInterfaceName)
        }
        if decoderContainer.contains(.primaryIpAddress)
        {
            self.primaryIpAddress = try decoderContainer.decode(String?.self, forKey: .primaryIpAddress)
        }
        if decoderContainer.contains(.secondaryIpAddresses)
        {
            self.secondaryIpAddresses = try decoderContainer.decode([String?]?.self, forKey: .secondaryIpAddresses)
        }
        if decoderContainer.contains(.secondaryIpCount)
        {
            self.secondaryIpCount = try decoderContainer.decode(Int?.self, forKey: .secondaryIpCount)
        }
        if decoderContainer.contains(.securityGroups)
        {
            self.securityGroups = try decoderContainer.decode([String?]?.self, forKey: .securityGroups)
        }
        if decoderContainer.contains(.sanityCheck)
        {
            self.sanityCheck = try decoderContainer.decode(Int?.self, forKey: .sanityCheck)
        }
        if decoderContainer.contains(.descriptionValue)
        {
            self.descriptionValue = try decoderContainer.decode(String?.self, forKey: .descriptionValue)
        }
    }
}
public extension NetworkInterfaceSpec{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: NetworkInterfaceSpecCodingKeys.self)
         try encoderContainer.encode(subnetId, forKey: .subnetId)
         try encoderContainer.encode(az, forKey: .az)
         try encoderContainer.encode(networkInterfaceName, forKey: .networkInterfaceName)
         try encoderContainer.encode(primaryIpAddress, forKey: .primaryIpAddress)
         try encoderContainer.encode(secondaryIpAddresses, forKey: .secondaryIpAddresses)
         try encoderContainer.encode(secondaryIpCount, forKey: .secondaryIpCount)
         try encoderContainer.encode(securityGroups, forKey: .securityGroups)
         try encoderContainer.encode(sanityCheck, forKey: .sanityCheck)
         try encoderContainer.encode(descriptionValue, forKey: .descriptionValue)
    }
}
///  modifyNetworkInterfaceSpec
public class ModifyNetworkInterfaceSpec:NSObject,Codable{
    /// 弹性网卡名称,只允许输入中文、数字、大小写字母、英文下划线“_”及中划线“-”，不允许为空且不超过32字符
    var networkInterfaceName:String?
    /// 描述,允许输入UTF-8编码下的全部字符，不超过256字符
    var descriptionValue:String?
    /// 以覆盖原有安全组的方式更新的安全组。如果更新安全组ID列表，最多5个安全组
    var securityGroups:[String?]?



    public override init(){
            super.init()
    }

    enum ModifyNetworkInterfaceSpecCodingKeys: String, CodingKey {
        case networkInterfaceName
        case descriptionValue = "description"
        case securityGroups
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: ModifyNetworkInterfaceSpecCodingKeys.self)
        if decoderContainer.contains(.networkInterfaceName)
        {
            self.networkInterfaceName = try decoderContainer.decode(String?.self, forKey: .networkInterfaceName)
        }
        if decoderContainer.contains(.descriptionValue)
        {
            self.descriptionValue = try decoderContainer.decode(String?.self, forKey: .descriptionValue)
        }
        if decoderContainer.contains(.securityGroups)
        {
            self.securityGroups = try decoderContainer.decode([String?]?.self, forKey: .securityGroups)
        }
    }
}
public extension ModifyNetworkInterfaceSpec{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: ModifyNetworkInterfaceSpecCodingKeys.self)
         try encoderContainer.encode(networkInterfaceName, forKey: .networkInterfaceName)
         try encoderContainer.encode(descriptionValue, forKey: .descriptionValue)
         try encoderContainer.encode(securityGroups, forKey: .securityGroups)
    }
}
///  associateElasticIpSpec
public class AssociateElasticIpSpec:NSObject,Codable{
    /// 绑定的弹性Ip Id
    var elasticIpId:String?
    /// 绑定弹性Ip到指定的privateIp
    var privateIpAddress:String?
    /// 绑定的弹性Ip地址
    var elasticIpAddress:String?



    public override init(){
            super.init()
    }

    enum AssociateElasticIpSpecCodingKeys: String, CodingKey {
        case elasticIpId
        case privateIpAddress
        case elasticIpAddress
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: AssociateElasticIpSpecCodingKeys.self)
        if decoderContainer.contains(.elasticIpId)
        {
            self.elasticIpId = try decoderContainer.decode(String?.self, forKey: .elasticIpId)
        }
        if decoderContainer.contains(.privateIpAddress)
        {
            self.privateIpAddress = try decoderContainer.decode(String?.self, forKey: .privateIpAddress)
        }
        if decoderContainer.contains(.elasticIpAddress)
        {
            self.elasticIpAddress = try decoderContainer.decode(String?.self, forKey: .elasticIpAddress)
        }
    }
}
public extension AssociateElasticIpSpec{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: AssociateElasticIpSpecCodingKeys.self)
         try encoderContainer.encode(elasticIpId, forKey: .elasticIpId)
         try encoderContainer.encode(privateIpAddress, forKey: .privateIpAddress)
         try encoderContainer.encode(elasticIpAddress, forKey: .elasticIpAddress)
    }
}
///  networkInterface
public class NetworkInterface:NSObject,Codable{
    /// 弹性网卡名称
    var networkInterfaceName:String?
    /// 弹性网卡ID
    var networkInterfaceId:String?
    /// 可用区名称
    var az:String?
    /// 网卡角色，取值范围：Primary（主网卡）、Secondary（辅助网卡）
    var role:String?
    /// 以太网地址
    var macAddress:String?
    /// 虚拟网络ID
    var vpcId:String?
    /// 子网ID
    var subnetId:String?
    /// 安全组ID列表
    var networkSecurityGroupIds:[String?]?
    /// 源和目标IP地址校验，取值为0或者1
    var sanityCheck:Int?
    /// 网卡主IP
    var primaryIp:NetworkInterfacePrivateIp?
    /// 网卡附属IP列表
    var secondaryIps:[NetworkInterfacePrivateIp?]?
    /// 关联实例类型，取值范围：vm
    var instanceType:String?
    /// 关联实例ID
    var instanceId:String?
    /// 实例所属的账号
    var instanceOwnerId:String?
    /// 网卡在实例上的设备索引号，取值范围：[0,8]，0：辅助网卡未绑定设备，1：主网卡，2-8：辅助网卡已绑定设备
    var deviceIndex:Int?
    /// 网卡描述信息
    var descriptionValue:String?
    /// 弹性网卡创建时间
    var createdTime:String?



    public override init(){
            super.init()
    }

    enum NetworkInterfaceCodingKeys: String, CodingKey {
        case networkInterfaceName
        case networkInterfaceId
        case az
        case role
        case macAddress
        case vpcId
        case subnetId
        case networkSecurityGroupIds
        case sanityCheck
        case primaryIp
        case secondaryIps
        case instanceType
        case instanceId
        case instanceOwnerId
        case deviceIndex
        case descriptionValue = "description"
        case createdTime
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: NetworkInterfaceCodingKeys.self)
        if decoderContainer.contains(.networkInterfaceName)
        {
            self.networkInterfaceName = try decoderContainer.decode(String?.self, forKey: .networkInterfaceName)
        }
        if decoderContainer.contains(.networkInterfaceId)
        {
            self.networkInterfaceId = try decoderContainer.decode(String?.self, forKey: .networkInterfaceId)
        }
        if decoderContainer.contains(.az)
        {
            self.az = try decoderContainer.decode(String?.self, forKey: .az)
        }
        if decoderContainer.contains(.role)
        {
            self.role = try decoderContainer.decode(String?.self, forKey: .role)
        }
        if decoderContainer.contains(.macAddress)
        {
            self.macAddress = try decoderContainer.decode(String?.self, forKey: .macAddress)
        }
        if decoderContainer.contains(.vpcId)
        {
            self.vpcId = try decoderContainer.decode(String?.self, forKey: .vpcId)
        }
        if decoderContainer.contains(.subnetId)
        {
            self.subnetId = try decoderContainer.decode(String?.self, forKey: .subnetId)
        }
        if decoderContainer.contains(.networkSecurityGroupIds)
        {
            self.networkSecurityGroupIds = try decoderContainer.decode([String?]?.self, forKey: .networkSecurityGroupIds)
        }
        if decoderContainer.contains(.sanityCheck)
        {
            self.sanityCheck = try decoderContainer.decode(Int?.self, forKey: .sanityCheck)
        }
        if decoderContainer.contains(.primaryIp)
        {
            self.primaryIp = try decoderContainer.decode(NetworkInterfacePrivateIp?.self, forKey: .primaryIp)
        }
        if decoderContainer.contains(.secondaryIps)
        {
            self.secondaryIps = try decoderContainer.decode([NetworkInterfacePrivateIp?]?.self, forKey: .secondaryIps)
        }
        if decoderContainer.contains(.instanceType)
        {
            self.instanceType = try decoderContainer.decode(String?.self, forKey: .instanceType)
        }
        if decoderContainer.contains(.instanceId)
        {
            self.instanceId = try decoderContainer.decode(String?.self, forKey: .instanceId)
        }
        if decoderContainer.contains(.instanceOwnerId)
        {
            self.instanceOwnerId = try decoderContainer.decode(String?.self, forKey: .instanceOwnerId)
        }
        if decoderContainer.contains(.deviceIndex)
        {
            self.deviceIndex = try decoderContainer.decode(Int?.self, forKey: .deviceIndex)
        }
        if decoderContainer.contains(.descriptionValue)
        {
            self.descriptionValue = try decoderContainer.decode(String?.self, forKey: .descriptionValue)
        }
        if decoderContainer.contains(.createdTime)
        {
            self.createdTime = try decoderContainer.decode(String?.self, forKey: .createdTime)
        }
    }
}
public extension NetworkInterface{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: NetworkInterfaceCodingKeys.self)
         try encoderContainer.encode(networkInterfaceName, forKey: .networkInterfaceName)
         try encoderContainer.encode(networkInterfaceId, forKey: .networkInterfaceId)
         try encoderContainer.encode(az, forKey: .az)
         try encoderContainer.encode(role, forKey: .role)
         try encoderContainer.encode(macAddress, forKey: .macAddress)
         try encoderContainer.encode(vpcId, forKey: .vpcId)
         try encoderContainer.encode(subnetId, forKey: .subnetId)
         try encoderContainer.encode(networkSecurityGroupIds, forKey: .networkSecurityGroupIds)
         try encoderContainer.encode(sanityCheck, forKey: .sanityCheck)
         try encoderContainer.encode(primaryIp, forKey: .primaryIp)
         try encoderContainer.encode(secondaryIps, forKey: .secondaryIps)
         try encoderContainer.encode(instanceType, forKey: .instanceType)
         try encoderContainer.encode(instanceId, forKey: .instanceId)
         try encoderContainer.encode(instanceOwnerId, forKey: .instanceOwnerId)
         try encoderContainer.encode(deviceIndex, forKey: .deviceIndex)
         try encoderContainer.encode(descriptionValue, forKey: .descriptionValue)
         try encoderContainer.encode(createdTime, forKey: .createdTime)
    }
}
///  disassociateElasticIpSpec
public class DisassociateElasticIpSpec:NSObject,Codable{
    /// 指定解绑的弹性Ip Id
    var elasticIpId:String?
    /// 指定解绑的弹性Ip地址
    var elasticIpAddress:String?



    public override init(){
            super.init()
    }

    enum DisassociateElasticIpSpecCodingKeys: String, CodingKey {
        case elasticIpId
        case elasticIpAddress
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: DisassociateElasticIpSpecCodingKeys.self)
        if decoderContainer.contains(.elasticIpId)
        {
            self.elasticIpId = try decoderContainer.decode(String?.self, forKey: .elasticIpId)
        }
        if decoderContainer.contains(.elasticIpAddress)
        {
            self.elasticIpAddress = try decoderContainer.decode(String?.self, forKey: .elasticIpAddress)
        }
    }
}
public extension DisassociateElasticIpSpec{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: DisassociateElasticIpSpecCodingKeys.self)
         try encoderContainer.encode(elasticIpId, forKey: .elasticIpId)
         try encoderContainer.encode(elasticIpAddress, forKey: .elasticIpAddress)
    }
}
///  networkInterfacePrivateIp
public class NetworkInterfacePrivateIp:NSObject,Codable{
    /// 私有IP的IPV4地址
    var privateIpAddress:String?
    /// 弹性IP实例ID
    var elasticIpId:String?
    /// 弹性IP实例地址
    var elasticIpAddress:String?



    public override init(){
            super.init()
    }

    enum NetworkInterfacePrivateIpCodingKeys: String, CodingKey {
        case privateIpAddress
        case elasticIpId
        case elasticIpAddress
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: NetworkInterfacePrivateIpCodingKeys.self)
        if decoderContainer.contains(.privateIpAddress)
        {
            self.privateIpAddress = try decoderContainer.decode(String?.self, forKey: .privateIpAddress)
        }
        if decoderContainer.contains(.elasticIpId)
        {
            self.elasticIpId = try decoderContainer.decode(String?.self, forKey: .elasticIpId)
        }
        if decoderContainer.contains(.elasticIpAddress)
        {
            self.elasticIpAddress = try decoderContainer.decode(String?.self, forKey: .elasticIpAddress)
        }
    }
}
public extension NetworkInterfacePrivateIp{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: NetworkInterfacePrivateIpCodingKeys.self)
         try encoderContainer.encode(privateIpAddress, forKey: .privateIpAddress)
         try encoderContainer.encode(elasticIpId, forKey: .elasticIpId)
         try encoderContainer.encode(elasticIpAddress, forKey: .elasticIpAddress)
    }
}
///  assignSecondaryIpsSpec
public class AssignSecondaryIpsSpec:NSObject,Codable{
    /// secondary ip被其他接口占用时，是否抢占。false：非抢占重分配，true：抢占重分配，默认抢占重分配。默认值：true
    var force:Bool?
    /// 指定分配的secondaryIp地址
    var secondaryIps:[String?]?
    /// 指定自动分配的secondaryIp个数
    var secondaryIpCount:Double?



    public override init(){
            super.init()
    }

    enum AssignSecondaryIpsSpecCodingKeys: String, CodingKey {
        case force
        case secondaryIps
        case secondaryIpCount
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: AssignSecondaryIpsSpecCodingKeys.self)
        if decoderContainer.contains(.force)
        {
            self.force = try decoderContainer.decode(Bool?.self, forKey: .force)
        }
        if decoderContainer.contains(.secondaryIps)
        {
            self.secondaryIps = try decoderContainer.decode([String?]?.self, forKey: .secondaryIps)
        }
        if decoderContainer.contains(.secondaryIpCount)
        {
            self.secondaryIpCount = try decoderContainer.decode(Double?.self, forKey: .secondaryIpCount)
        }
    }
}
public extension AssignSecondaryIpsSpec{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: AssignSecondaryIpsSpecCodingKeys.self)
         try encoderContainer.encode(force, forKey: .force)
         try encoderContainer.encode(secondaryIps, forKey: .secondaryIps)
         try encoderContainer.encode(secondaryIpCount, forKey: .secondaryIpCount)
    }
}
///  modifySubnetSpec
public class ModifySubnetSpec:NSObject,Codable{
    /// 子网名称,只允许输入中文、数字、大小写字母、英文下划线“_”及中划线“-”，不允许为空且不超过32字符。
    var subnetName:String?
    /// 子网描述信息，允许输入UTF-8编码下的全部字符，不超过256字符。
    var descriptionValue:String?



    public override init(){
            super.init()
    }

    enum ModifySubnetSpecCodingKeys: String, CodingKey {
        case subnetName
        case descriptionValue = "description"
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: ModifySubnetSpecCodingKeys.self)
        if decoderContainer.contains(.subnetName)
        {
            self.subnetName = try decoderContainer.decode(String?.self, forKey: .subnetName)
        }
        if decoderContainer.contains(.descriptionValue)
        {
            self.descriptionValue = try decoderContainer.decode(String?.self, forKey: .descriptionValue)
        }
    }
}
public extension ModifySubnetSpec{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: ModifySubnetSpecCodingKeys.self)
         try encoderContainer.encode(subnetName, forKey: .subnetName)
         try encoderContainer.encode(descriptionValue, forKey: .descriptionValue)
    }
}
///  subnet
public class Subnet:NSObject,Codable{
    /// Subnet的Id
    var subnetId:String?
    /// 子网名称
    var subnetName:String?
    /// 子网所属VPC的Id
    var vpcId:String?
    /// 子网网段，vpc内子网网段不能重叠，cidr的取值范围：10.0.0.0/8、172.16.0.0/12和192.168.0.0/16及它们包含的子网，且子网掩码长度为16-28之间，如果VPC含有Cidr，则必须为VPC所在Cidr的子网
    var addressPrefix:String?
    /// 子网可用ip数量
    var availableIpCount:Double?
    /// 子网描述信息
    var descriptionValue:String?
    /// 子网关联的路由表Id
    var routeTableId:String?
    /// 子网关联的acl Id
    var aclId:String?
    /// 子网的起始地址，子网第1个地位为路由器网关保留，第2个地址为dhcp服务保留
    var startIp:String?
    /// 子网的结束地址，子网第1个地位为路由器网关保留，第2个地址为dhcp服务保留
    var endIp:String?
    /// 子网创建时间
    var createdTime:String?



    public override init(){
            super.init()
    }

    enum SubnetCodingKeys: String, CodingKey {
        case subnetId
        case subnetName
        case vpcId
        case addressPrefix
        case availableIpCount
        case descriptionValue = "description"
        case routeTableId
        case aclId
        case startIp
        case endIp
        case createdTime
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: SubnetCodingKeys.self)
        if decoderContainer.contains(.subnetId)
        {
            self.subnetId = try decoderContainer.decode(String?.self, forKey: .subnetId)
        }
        if decoderContainer.contains(.subnetName)
        {
            self.subnetName = try decoderContainer.decode(String?.self, forKey: .subnetName)
        }
        if decoderContainer.contains(.vpcId)
        {
            self.vpcId = try decoderContainer.decode(String?.self, forKey: .vpcId)
        }
        if decoderContainer.contains(.addressPrefix)
        {
            self.addressPrefix = try decoderContainer.decode(String?.self, forKey: .addressPrefix)
        }
        if decoderContainer.contains(.availableIpCount)
        {
            self.availableIpCount = try decoderContainer.decode(Double?.self, forKey: .availableIpCount)
        }
        if decoderContainer.contains(.descriptionValue)
        {
            self.descriptionValue = try decoderContainer.decode(String?.self, forKey: .descriptionValue)
        }
        if decoderContainer.contains(.routeTableId)
        {
            self.routeTableId = try decoderContainer.decode(String?.self, forKey: .routeTableId)
        }
        if decoderContainer.contains(.aclId)
        {
            self.aclId = try decoderContainer.decode(String?.self, forKey: .aclId)
        }
        if decoderContainer.contains(.startIp)
        {
            self.startIp = try decoderContainer.decode(String?.self, forKey: .startIp)
        }
        if decoderContainer.contains(.endIp)
        {
            self.endIp = try decoderContainer.decode(String?.self, forKey: .endIp)
        }
        if decoderContainer.contains(.createdTime)
        {
            self.createdTime = try decoderContainer.decode(String?.self, forKey: .createdTime)
        }
    }
}
public extension Subnet{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: SubnetCodingKeys.self)
         try encoderContainer.encode(subnetId, forKey: .subnetId)
         try encoderContainer.encode(subnetName, forKey: .subnetName)
         try encoderContainer.encode(vpcId, forKey: .vpcId)
         try encoderContainer.encode(addressPrefix, forKey: .addressPrefix)
         try encoderContainer.encode(availableIpCount, forKey: .availableIpCount)
         try encoderContainer.encode(descriptionValue, forKey: .descriptionValue)
         try encoderContainer.encode(routeTableId, forKey: .routeTableId)
         try encoderContainer.encode(aclId, forKey: .aclId)
         try encoderContainer.encode(startIp, forKey: .startIp)
         try encoderContainer.encode(endIp, forKey: .endIp)
         try encoderContainer.encode(createdTime, forKey: .createdTime)
    }
}
///  subnetSpec
public class SubnetSpec:NSObject,Codable{
    /// 子网所属vpc的Id
    /// Required:true
    var vpcId:String
    /// 子网名称,只允许输入中文、数字、大小写字母、英文下划线“_”及中划线“-”，不允许为空且不超过32字符。
    /// Required:true
    var subnetName:String
    /// 子网网段，vpc内子网网段不能重叠，cidr的取值范围：10.0.0.0/8、172.16.0.0/12和192.168.0.0/16及它们包含的子网，且子网掩码长度为16-28之间，如果vpc含有cidr，则必须为vpc所在cidr的子网
    /// Required:true
    var addressPrefix:String
    /// 子网关联的路由表Id, 默认为vpc的默认路由表
    var routeTableId:String?
    /// 子网描述信息,允许输入UTF-8编码下的全部字符，不超过256字符。
    var descriptionValue:String?



    public  init(vpcId:String,subnetName:String,addressPrefix:String){
             self.vpcId = vpcId
             self.subnetName = subnetName
             self.addressPrefix = addressPrefix
    }

    enum SubnetSpecCodingKeys: String, CodingKey {
        case vpcId
        case subnetName
        case addressPrefix
        case routeTableId
        case descriptionValue = "description"
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: SubnetSpecCodingKeys.self)
        self.vpcId = try decoderContainer.decode(String.self, forKey: .vpcId)
        self.subnetName = try decoderContainer.decode(String.self, forKey: .subnetName)
        self.addressPrefix = try decoderContainer.decode(String.self, forKey: .addressPrefix)
        if decoderContainer.contains(.routeTableId)
        {
            self.routeTableId = try decoderContainer.decode(String?.self, forKey: .routeTableId)
        }
        if decoderContainer.contains(.descriptionValue)
        {
            self.descriptionValue = try decoderContainer.decode(String?.self, forKey: .descriptionValue)
        }
    }
}
public extension SubnetSpec{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: SubnetSpecCodingKeys.self)
         try encoderContainer.encode(vpcId, forKey: .vpcId)
         try encoderContainer.encode(subnetName, forKey: .subnetName)
         try encoderContainer.encode(addressPrefix, forKey: .addressPrefix)
         try encoderContainer.encode(routeTableId, forKey: .routeTableId)
         try encoderContainer.encode(descriptionValue, forKey: .descriptionValue)
    }
}
///  addNetworkSecurityGroupRulesSpec
public class AddNetworkSecurityGroupRulesSpec:NSObject,Codable{
    /// 安全组规则信息
    /// Required:true
    var networkSecurityGroupRuleSpecs:[AddSecurityGroupRules?]?



    public  init(networkSecurityGroupRuleSpecs:[AddSecurityGroupRules?]?){
             self.networkSecurityGroupRuleSpecs = networkSecurityGroupRuleSpecs
    }

    enum AddNetworkSecurityGroupRulesSpecCodingKeys: String, CodingKey {
        case networkSecurityGroupRuleSpecs
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: AddNetworkSecurityGroupRulesSpecCodingKeys.self)
        self.networkSecurityGroupRuleSpecs = try decoderContainer.decode([AddSecurityGroupRules?]?.self, forKey: .networkSecurityGroupRuleSpecs)
    }
}
public extension AddNetworkSecurityGroupRulesSpec{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: AddNetworkSecurityGroupRulesSpecCodingKeys.self)
         try encoderContainer.encode(networkSecurityGroupRuleSpecs, forKey: .networkSecurityGroupRuleSpecs)
    }
}
///  modifySecurityGroupRuleSpec
public class ModifySecurityGroupRuleSpec:NSObject,Codable{
    /// 安全组规则信息
    /// Required:true
    var modifySecurityGroupRuleSpecs:[ModifySecurityGroupRules?]?



    public  init(modifySecurityGroupRuleSpecs:[ModifySecurityGroupRules?]?){
             self.modifySecurityGroupRuleSpecs = modifySecurityGroupRuleSpecs
    }

    enum ModifySecurityGroupRuleSpecCodingKeys: String, CodingKey {
        case modifySecurityGroupRuleSpecs
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: ModifySecurityGroupRuleSpecCodingKeys.self)
        self.modifySecurityGroupRuleSpecs = try decoderContainer.decode([ModifySecurityGroupRules?]?.self, forKey: .modifySecurityGroupRuleSpecs)
    }
}
public extension ModifySecurityGroupRuleSpec{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: ModifySecurityGroupRuleSpecCodingKeys.self)
         try encoderContainer.encode(modifySecurityGroupRuleSpecs, forKey: .modifySecurityGroupRuleSpecs)
    }
}
///  modifySecurityGroupRules
public class ModifySecurityGroupRules:NSObject,Codable{
    /// 安全组规则的ID。
    /// Required:true
    var ruleId:String
    /// 规则限定协议。300:All; 6:TCP; 17:UDP; 1:ICMP
    var protocolValue:Double?
    /// 安全组规则的起始端口。取值范围：1-65535
    var fromPort:Int?
    /// 安全组规则的终端口。取值范围：1-65535
    var toPort:Int?
    /// 安全组规则前缀，取值范围：正确的CIDR
    var addressPrefix:String?
    /// 安全组规则的描述，取值范围：0-256个UTF-8编码下的全部字符
    var descriptionValue:String?



    public  init(ruleId:String){
             self.ruleId = ruleId
    }

    enum ModifySecurityGroupRulesCodingKeys: String, CodingKey {
        case ruleId
        case protocolValue = "protocol"
        case fromPort
        case toPort
        case addressPrefix
        case descriptionValue = "description"
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: ModifySecurityGroupRulesCodingKeys.self)
        self.ruleId = try decoderContainer.decode(String.self, forKey: .ruleId)
        if decoderContainer.contains(.protocolValue)
        {
            self.protocolValue = try decoderContainer.decode(Double?.self, forKey: .protocolValue)
        }
        if decoderContainer.contains(.fromPort)
        {
            self.fromPort = try decoderContainer.decode(Int?.self, forKey: .fromPort)
        }
        if decoderContainer.contains(.toPort)
        {
            self.toPort = try decoderContainer.decode(Int?.self, forKey: .toPort)
        }
        if decoderContainer.contains(.addressPrefix)
        {
            self.addressPrefix = try decoderContainer.decode(String?.self, forKey: .addressPrefix)
        }
        if decoderContainer.contains(.descriptionValue)
        {
            self.descriptionValue = try decoderContainer.decode(String?.self, forKey: .descriptionValue)
        }
    }
}
public extension ModifySecurityGroupRules{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: ModifySecurityGroupRulesCodingKeys.self)
         try encoderContainer.encode(ruleId, forKey: .ruleId)
         try encoderContainer.encode(protocolValue, forKey: .protocolValue)
         try encoderContainer.encode(fromPort, forKey: .fromPort)
         try encoderContainer.encode(toPort, forKey: .toPort)
         try encoderContainer.encode(addressPrefix, forKey: .addressPrefix)
         try encoderContainer.encode(descriptionValue, forKey: .descriptionValue)
    }
}
///  modifyNetworkSecurityGroupSpec
public class ModifyNetworkSecurityGroupSpec:NSObject,Codable{
    /// 安全组的名字。名称取值范围：1-32个中文、英文大小写的字母、数字和下划线分隔符
    var networkSecurityGroupName:String?
    /// 安全组的描述，取值范围：0-256个UTF-8编码下的全部字符
    var descriptionValue:String?



    public override init(){
            super.init()
    }

    enum ModifyNetworkSecurityGroupSpecCodingKeys: String, CodingKey {
        case networkSecurityGroupName
        case descriptionValue = "description"
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: ModifyNetworkSecurityGroupSpecCodingKeys.self)
        if decoderContainer.contains(.networkSecurityGroupName)
        {
            self.networkSecurityGroupName = try decoderContainer.decode(String?.self, forKey: .networkSecurityGroupName)
        }
        if decoderContainer.contains(.descriptionValue)
        {
            self.descriptionValue = try decoderContainer.decode(String?.self, forKey: .descriptionValue)
        }
    }
}
public extension ModifyNetworkSecurityGroupSpec{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: ModifyNetworkSecurityGroupSpecCodingKeys.self)
         try encoderContainer.encode(networkSecurityGroupName, forKey: .networkSecurityGroupName)
         try encoderContainer.encode(descriptionValue, forKey: .descriptionValue)
    }
}
///  networkSecurityGroup
public class NetworkSecurityGroup:NSObject,Codable{
    /// 安全组ID
    var networkSecurityGroupId:String?
    /// 安全组名称
    var networkSecurityGroupName:String?
    /// 安全组描述信息
    var descriptionValue:String?
    /// 安全组所在vpc的Id
    var vpcId:String?
    /// 安全组规则信息
    var securityGroupRules:[SecurityGroupRule?]?
    /// 安全组创建时间
    var createdTime:String?



    public override init(){
            super.init()
    }

    enum NetworkSecurityGroupCodingKeys: String, CodingKey {
        case networkSecurityGroupId
        case networkSecurityGroupName
        case descriptionValue = "description"
        case vpcId
        case securityGroupRules
        case createdTime
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: NetworkSecurityGroupCodingKeys.self)
        if decoderContainer.contains(.networkSecurityGroupId)
        {
            self.networkSecurityGroupId = try decoderContainer.decode(String?.self, forKey: .networkSecurityGroupId)
        }
        if decoderContainer.contains(.networkSecurityGroupName)
        {
            self.networkSecurityGroupName = try decoderContainer.decode(String?.self, forKey: .networkSecurityGroupName)
        }
        if decoderContainer.contains(.descriptionValue)
        {
            self.descriptionValue = try decoderContainer.decode(String?.self, forKey: .descriptionValue)
        }
        if decoderContainer.contains(.vpcId)
        {
            self.vpcId = try decoderContainer.decode(String?.self, forKey: .vpcId)
        }
        if decoderContainer.contains(.securityGroupRules)
        {
            self.securityGroupRules = try decoderContainer.decode([SecurityGroupRule?]?.self, forKey: .securityGroupRules)
        }
        if decoderContainer.contains(.createdTime)
        {
            self.createdTime = try decoderContainer.decode(String?.self, forKey: .createdTime)
        }
    }
}
public extension NetworkSecurityGroup{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: NetworkSecurityGroupCodingKeys.self)
         try encoderContainer.encode(networkSecurityGroupId, forKey: .networkSecurityGroupId)
         try encoderContainer.encode(networkSecurityGroupName, forKey: .networkSecurityGroupName)
         try encoderContainer.encode(descriptionValue, forKey: .descriptionValue)
         try encoderContainer.encode(vpcId, forKey: .vpcId)
         try encoderContainer.encode(securityGroupRules, forKey: .securityGroupRules)
         try encoderContainer.encode(createdTime, forKey: .createdTime)
    }
}
///  addSecurityGroupRules
public class AddSecurityGroupRules:NSObject,Codable{
    /// 规则限定协议。300:All; 6:TCP; 17:UDP; 1:ICMP
    /// Required:true
    var protocolValue:Double
    /// 安全组规则方向。0：入规则; 1：出规则
    /// Required:true
    var direction:Double
    /// 匹配地址前缀
    /// Required:true
    var addressPrefix:String
    /// 规则限定起始传输层端口, 取值范围:1-65535, 若protocol为传输层协议，默认值为1，若protocol不是传输层协议，恒为0。如果规则只限定一个端口号，fromPort和toPort填写同一个值
    var fromPort:Double?
    /// 规则限定终止传输层端口, 取值范围:1-65535, 若protocol为传输层协议，默认值为65535，若protocol不是传输层协议，恒为0。如果规则只限定一个端口号，fromPort和toPort填写同一个值
    var toPort:Double?
    /// 描述,​ 允许输入UTF-8编码下的全部字符，不超过256字符
    var descriptionValue:String?



    public  init(protocolValue:Double,direction:Double,addressPrefix:String){
             self.protocolValue = protocolValue
             self.direction = direction
             self.addressPrefix = addressPrefix
    }

    enum AddSecurityGroupRulesCodingKeys: String, CodingKey {
        case protocolValue = "protocol"
        case direction
        case addressPrefix
        case fromPort
        case toPort
        case descriptionValue = "description"
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: AddSecurityGroupRulesCodingKeys.self)
        self.protocolValue = try decoderContainer.decode(Double.self, forKey: .protocolValue)
        self.direction = try decoderContainer.decode(Double.self, forKey: .direction)
        self.addressPrefix = try decoderContainer.decode(String.self, forKey: .addressPrefix)
        if decoderContainer.contains(.fromPort)
        {
            self.fromPort = try decoderContainer.decode(Double?.self, forKey: .fromPort)
        }
        if decoderContainer.contains(.toPort)
        {
            self.toPort = try decoderContainer.decode(Double?.self, forKey: .toPort)
        }
        if decoderContainer.contains(.descriptionValue)
        {
            self.descriptionValue = try decoderContainer.decode(String?.self, forKey: .descriptionValue)
        }
    }
}
public extension AddSecurityGroupRules{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: AddSecurityGroupRulesCodingKeys.self)
         try encoderContainer.encode(protocolValue, forKey: .protocolValue)
         try encoderContainer.encode(direction, forKey: .direction)
         try encoderContainer.encode(addressPrefix, forKey: .addressPrefix)
         try encoderContainer.encode(fromPort, forKey: .fromPort)
         try encoderContainer.encode(toPort, forKey: .toPort)
         try encoderContainer.encode(descriptionValue, forKey: .descriptionValue)
    }
}
///  securityGroupRule
public class SecurityGroupRule:NSObject,Codable{
    /// 安全组规则ID
    var ruleId:String?
    /// 安全组规则方向。0：入规则; 1：出规则
    var direction:Double?
    /// 规则限定协议。300:All; 6:TCP; 17:UDP; 1:ICMP
    var protocolValue:Double?
    /// 匹配地址前缀
    var addressPrefix:String?
    /// 匹配地址协议版本。4：IPv4
    var ipVersion:Double?
    /// 规则限定起始传输层端口, 默认1 ，若protocal不是传输层协议，恒为0
    var fromPort:Double?
    /// 规则限定终止传输层端口, 默认1 ，若protocal不是传输层协议，恒为0
    var toPort:Double?
    /// 安全组规则创建时间
    var createdTime:String?
    /// 描述,​ 允许输入UTF-8编码下的全部字符，不超过256字符
    var descriptionValue:String?



    public override init(){
            super.init()
    }

    enum SecurityGroupRuleCodingKeys: String, CodingKey {
        case ruleId
        case direction
        case protocolValue = "protocol"
        case addressPrefix
        case ipVersion
        case fromPort
        case toPort
        case createdTime
        case descriptionValue = "description"
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: SecurityGroupRuleCodingKeys.self)
        if decoderContainer.contains(.ruleId)
        {
            self.ruleId = try decoderContainer.decode(String?.self, forKey: .ruleId)
        }
        if decoderContainer.contains(.direction)
        {
            self.direction = try decoderContainer.decode(Double?.self, forKey: .direction)
        }
        if decoderContainer.contains(.protocolValue)
        {
            self.protocolValue = try decoderContainer.decode(Double?.self, forKey: .protocolValue)
        }
        if decoderContainer.contains(.addressPrefix)
        {
            self.addressPrefix = try decoderContainer.decode(String?.self, forKey: .addressPrefix)
        }
        if decoderContainer.contains(.ipVersion)
        {
            self.ipVersion = try decoderContainer.decode(Double?.self, forKey: .ipVersion)
        }
        if decoderContainer.contains(.fromPort)
        {
            self.fromPort = try decoderContainer.decode(Double?.self, forKey: .fromPort)
        }
        if decoderContainer.contains(.toPort)
        {
            self.toPort = try decoderContainer.decode(Double?.self, forKey: .toPort)
        }
        if decoderContainer.contains(.createdTime)
        {
            self.createdTime = try decoderContainer.decode(String?.self, forKey: .createdTime)
        }
        if decoderContainer.contains(.descriptionValue)
        {
            self.descriptionValue = try decoderContainer.decode(String?.self, forKey: .descriptionValue)
        }
    }
}
public extension SecurityGroupRule{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: SecurityGroupRuleCodingKeys.self)
         try encoderContainer.encode(ruleId, forKey: .ruleId)
         try encoderContainer.encode(direction, forKey: .direction)
         try encoderContainer.encode(protocolValue, forKey: .protocolValue)
         try encoderContainer.encode(addressPrefix, forKey: .addressPrefix)
         try encoderContainer.encode(ipVersion, forKey: .ipVersion)
         try encoderContainer.encode(fromPort, forKey: .fromPort)
         try encoderContainer.encode(toPort, forKey: .toPort)
         try encoderContainer.encode(createdTime, forKey: .createdTime)
         try encoderContainer.encode(descriptionValue, forKey: .descriptionValue)
    }
}
///  networkSecurityGroupSpec
public class NetworkSecurityGroupSpec:NSObject,Codable{
    /// 私有网络ID
    /// Required:true
    var vpcId:String
    /// 安全组名称，只允许输入中文、数字、大小写字母、英文下划线“_”及中划线“-”，不允许为空且不超过32字符。
    /// Required:true
    var networkSecurityGroupName:String
    /// 描述,​ 允许输入UTF-8编码下的全部字符，不超过256字符
    var descriptionValue:String?



    public  init(vpcId:String,networkSecurityGroupName:String){
             self.vpcId = vpcId
             self.networkSecurityGroupName = networkSecurityGroupName
    }

    enum NetworkSecurityGroupSpecCodingKeys: String, CodingKey {
        case vpcId
        case networkSecurityGroupName
        case descriptionValue = "description"
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: NetworkSecurityGroupSpecCodingKeys.self)
        self.vpcId = try decoderContainer.decode(String.self, forKey: .vpcId)
        self.networkSecurityGroupName = try decoderContainer.decode(String.self, forKey: .networkSecurityGroupName)
        if decoderContainer.contains(.descriptionValue)
        {
            self.descriptionValue = try decoderContainer.decode(String?.self, forKey: .descriptionValue)
        }
    }
}
public extension NetworkSecurityGroupSpec{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: NetworkSecurityGroupSpecCodingKeys.self)
         try encoderContainer.encode(vpcId, forKey: .vpcId)
         try encoderContainer.encode(networkSecurityGroupName, forKey: .networkSecurityGroupName)
         try encoderContainer.encode(descriptionValue, forKey: .descriptionValue)
    }
}
///  modifyNetworkAclRuleSpec
public class ModifyNetworkAclRuleSpec:NSObject,Codable{
    /// networkAcl规则ID
    /// Required:true
    var ruleId:String
    /// 规则限定协议。取值范围：All,TCP,UDP,ICMP
    var protocolValue:String?
    /// 规则限定起始传输层端口, 取值范围:1-65535, 若protocol为传输层协议，默认值为1，若protocol不是传输层协议，设置无效，恒为0。如果规则只限定一个端口号，fromPort和toPort填写同一个值
    var fromPort:Int?
    /// 规则限定终止传输层端口, 取值范围:1-65535, 若protocol为传输层协议，默认值为65535，若protocol不是传输层协议，设置无效，恒为0。如果规则只限定一个端口号，fromPort和toPort填写同一个值
    var toPort:Int?
    /// 匹配地址前缀
    var addressPrefix:String?
    /// 访问控制策略：allow:允许，deny：拒绝
    var ruleAction:String?
    /// 规则匹配优先级，取值范围为[1,32768]，优先级数字越小优先级越高
    var priority:Int?
    /// 描述,允许输入UTF-8编码下的全部字符，不超过256字符
    var descriptionValue:String?



    public  init(ruleId:String){
             self.ruleId = ruleId
    }

    enum ModifyNetworkAclRuleSpecCodingKeys: String, CodingKey {
        case ruleId
        case protocolValue = "protocol"
        case fromPort
        case toPort
        case addressPrefix
        case ruleAction
        case priority
        case descriptionValue = "description"
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: ModifyNetworkAclRuleSpecCodingKeys.self)
        self.ruleId = try decoderContainer.decode(String.self, forKey: .ruleId)
        if decoderContainer.contains(.protocolValue)
        {
            self.protocolValue = try decoderContainer.decode(String?.self, forKey: .protocolValue)
        }
        if decoderContainer.contains(.fromPort)
        {
            self.fromPort = try decoderContainer.decode(Int?.self, forKey: .fromPort)
        }
        if decoderContainer.contains(.toPort)
        {
            self.toPort = try decoderContainer.decode(Int?.self, forKey: .toPort)
        }
        if decoderContainer.contains(.addressPrefix)
        {
            self.addressPrefix = try decoderContainer.decode(String?.self, forKey: .addressPrefix)
        }
        if decoderContainer.contains(.ruleAction)
        {
            self.ruleAction = try decoderContainer.decode(String?.self, forKey: .ruleAction)
        }
        if decoderContainer.contains(.priority)
        {
            self.priority = try decoderContainer.decode(Int?.self, forKey: .priority)
        }
        if decoderContainer.contains(.descriptionValue)
        {
            self.descriptionValue = try decoderContainer.decode(String?.self, forKey: .descriptionValue)
        }
    }
}
public extension ModifyNetworkAclRuleSpec{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: ModifyNetworkAclRuleSpecCodingKeys.self)
         try encoderContainer.encode(ruleId, forKey: .ruleId)
         try encoderContainer.encode(protocolValue, forKey: .protocolValue)
         try encoderContainer.encode(fromPort, forKey: .fromPort)
         try encoderContainer.encode(toPort, forKey: .toPort)
         try encoderContainer.encode(addressPrefix, forKey: .addressPrefix)
         try encoderContainer.encode(ruleAction, forKey: .ruleAction)
         try encoderContainer.encode(priority, forKey: .priority)
         try encoderContainer.encode(descriptionValue, forKey: .descriptionValue)
    }
}
///  modifyNetworkAclRulesSpec
public class ModifyNetworkAclRulesSpec:NSObject,Codable{
    /// networkAcl规则列表
    /// Required:true
    var modifyNetworkAclRuleSpecs:[ModifyNetworkAclRuleSpec?]?



    public  init(modifyNetworkAclRuleSpecs:[ModifyNetworkAclRuleSpec?]?){
             self.modifyNetworkAclRuleSpecs = modifyNetworkAclRuleSpecs
    }

    enum ModifyNetworkAclRulesSpecCodingKeys: String, CodingKey {
        case modifyNetworkAclRuleSpecs
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: ModifyNetworkAclRulesSpecCodingKeys.self)
        self.modifyNetworkAclRuleSpecs = try decoderContainer.decode([ModifyNetworkAclRuleSpec?]?.self, forKey: .modifyNetworkAclRuleSpecs)
    }
}
public extension ModifyNetworkAclRulesSpec{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: ModifyNetworkAclRulesSpecCodingKeys.self)
         try encoderContainer.encode(modifyNetworkAclRuleSpecs, forKey: .modifyNetworkAclRuleSpecs)
    }
}
///  addNetworkAclRuleSpec
public class AddNetworkAclRuleSpec:NSObject,Codable{
    /// 规则限定协议。取值范围：All,TCP,UDP,ICMP
    /// Required:true
    var protocolValue:String
    /// 规则限定起始传输层端口, 取值范围:1-65535, 若protocol为传输层协议，默认值为1，若protocol不是传输层协议，设置无效，恒为0。如果规则只限定一个端口号，fromPort和toPort填写同一个值
    var fromPort:Int?
    /// 规则限定终止传输层端口, 取值范围:1-65535, 若protocol为传输层协议，默认值为65535，若protocol不是传输层协议，设置无效，恒为0。如果规则只限定一个端口号，fromPort和toPort填写同一个值
    var toPort:Int?
    /// networkAcl规则方向。ingress：入规则; egress：出规则
    /// Required:true
    var direction:String
    /// 匹配地址前缀
    /// Required:true
    var addressPrefix:String
    /// 访问控制策略：allow:允许，deny：拒绝
    /// Required:true
    var ruleAction:String
    /// 规则匹配优先级，取值范围为[1,32768]，优先级数字越小优先级越高
    /// Required:true
    var priority:Int
    /// 描述,允许输入UTF-8编码下的全部字符，不超过256字符
    var descriptionValue:String?



    public  init(protocolValue:String,direction:String,addressPrefix:String,ruleAction:String,priority:Int){
             self.protocolValue = protocolValue
             self.direction = direction
             self.addressPrefix = addressPrefix
             self.ruleAction = ruleAction
             self.priority = priority
    }

    enum AddNetworkAclRuleSpecCodingKeys: String, CodingKey {
        case protocolValue = "protocol"
        case fromPort
        case toPort
        case direction
        case addressPrefix
        case ruleAction
        case priority
        case descriptionValue = "description"
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: AddNetworkAclRuleSpecCodingKeys.self)
        self.protocolValue = try decoderContainer.decode(String.self, forKey: .protocolValue)
        if decoderContainer.contains(.fromPort)
        {
            self.fromPort = try decoderContainer.decode(Int?.self, forKey: .fromPort)
        }
        if decoderContainer.contains(.toPort)
        {
            self.toPort = try decoderContainer.decode(Int?.self, forKey: .toPort)
        }
        self.direction = try decoderContainer.decode(String.self, forKey: .direction)
        self.addressPrefix = try decoderContainer.decode(String.self, forKey: .addressPrefix)
        self.ruleAction = try decoderContainer.decode(String.self, forKey: .ruleAction)
        self.priority = try decoderContainer.decode(Int.self, forKey: .priority)
        if decoderContainer.contains(.descriptionValue)
        {
            self.descriptionValue = try decoderContainer.decode(String?.self, forKey: .descriptionValue)
        }
    }
}
public extension AddNetworkAclRuleSpec{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: AddNetworkAclRuleSpecCodingKeys.self)
         try encoderContainer.encode(protocolValue, forKey: .protocolValue)
         try encoderContainer.encode(fromPort, forKey: .fromPort)
         try encoderContainer.encode(toPort, forKey: .toPort)
         try encoderContainer.encode(direction, forKey: .direction)
         try encoderContainer.encode(addressPrefix, forKey: .addressPrefix)
         try encoderContainer.encode(ruleAction, forKey: .ruleAction)
         try encoderContainer.encode(priority, forKey: .priority)
         try encoderContainer.encode(descriptionValue, forKey: .descriptionValue)
    }
}
///  addNetworkAclRulesSpec
public class AddNetworkAclRulesSpec:NSObject,Codable{
    /// networkAcl规则列表
    /// Required:true
    var networkAclRuleSpecs:[AddNetworkAclRuleSpec?]?



    public  init(networkAclRuleSpecs:[AddNetworkAclRuleSpec?]?){
             self.networkAclRuleSpecs = networkAclRuleSpecs
    }

    enum AddNetworkAclRulesSpecCodingKeys: String, CodingKey {
        case networkAclRuleSpecs
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: AddNetworkAclRulesSpecCodingKeys.self)
        self.networkAclRuleSpecs = try decoderContainer.decode([AddNetworkAclRuleSpec?]?.self, forKey: .networkAclRuleSpecs)
    }
}
public extension AddNetworkAclRulesSpec{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: AddNetworkAclRulesSpecCodingKeys.self)
         try encoderContainer.encode(networkAclRuleSpecs, forKey: .networkAclRuleSpecs)
    }
}
///  networkAclSpec
public class NetworkAclSpec:NSObject,Codable{
    /// 私有网络id
    /// Required:true
    var vpcId:String
    /// networkAcl名称
    /// Required:true
    var networkAclName:String
    /// 描述,允许输入UTF-8编码下的全部字符，不超过256字符
    var descriptionValue:String?



    public  init(vpcId:String,networkAclName:String){
             self.vpcId = vpcId
             self.networkAclName = networkAclName
    }

    enum NetworkAclSpecCodingKeys: String, CodingKey {
        case vpcId
        case networkAclName
        case descriptionValue = "description"
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: NetworkAclSpecCodingKeys.self)
        self.vpcId = try decoderContainer.decode(String.self, forKey: .vpcId)
        self.networkAclName = try decoderContainer.decode(String.self, forKey: .networkAclName)
        if decoderContainer.contains(.descriptionValue)
        {
            self.descriptionValue = try decoderContainer.decode(String?.self, forKey: .descriptionValue)
        }
    }
}
public extension NetworkAclSpec{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: NetworkAclSpecCodingKeys.self)
         try encoderContainer.encode(vpcId, forKey: .vpcId)
         try encoderContainer.encode(networkAclName, forKey: .networkAclName)
         try encoderContainer.encode(descriptionValue, forKey: .descriptionValue)
    }
}
///  networkAclRule
public class NetworkAclRule:NSObject,Codable{
    /// networkAcl规则ID
    var ruleId:String?
    /// 规则限定协议。取值范围：All,TCP,UDP,ICMP
    var protocolValue:String?
    /// 规则限定起始传输层端口, 取值范围:1-65535, 若protocol为传输层协议，默认值为1，若protocol不是传输层协议，设置无效，恒为0。如果规则只限定一个端口号，fromPort和toPort填写同一个值
    var fromPort:Int?
    /// 规则限定终止传输层端口, 取值范围:1-65535, 若protocol为传输层协议，默认值为65535，若protocol不是传输层协议，设置无效，恒为0。如果规则只限定一个端口号，fromPort和toPort填写同一个值
    var toPort:Int?
    /// networkAcl规则方向。ingress：入规则; egress：出规则
    var direction:String?
    /// 匹配地址前缀
    var addressPrefix:String?
    /// 访问控制策略：allow:允许，deny：拒绝
    var ruleAction:String?
    /// 规则匹配优先级，取值范围为[1,32768]，优先级数字越小优先级越高
    var priority:Int?
    /// 描述,允许输入UTF-8编码下的全部字符，不超过256字符
    var descriptionValue:String?
    /// networkAclRule创建时间
    var createdTime:String?



    public override init(){
            super.init()
    }

    enum NetworkAclRuleCodingKeys: String, CodingKey {
        case ruleId
        case protocolValue = "protocol"
        case fromPort
        case toPort
        case direction
        case addressPrefix
        case ruleAction
        case priority
        case descriptionValue = "description"
        case createdTime
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: NetworkAclRuleCodingKeys.self)
        if decoderContainer.contains(.ruleId)
        {
            self.ruleId = try decoderContainer.decode(String?.self, forKey: .ruleId)
        }
        if decoderContainer.contains(.protocolValue)
        {
            self.protocolValue = try decoderContainer.decode(String?.self, forKey: .protocolValue)
        }
        if decoderContainer.contains(.fromPort)
        {
            self.fromPort = try decoderContainer.decode(Int?.self, forKey: .fromPort)
        }
        if decoderContainer.contains(.toPort)
        {
            self.toPort = try decoderContainer.decode(Int?.self, forKey: .toPort)
        }
        if decoderContainer.contains(.direction)
        {
            self.direction = try decoderContainer.decode(String?.self, forKey: .direction)
        }
        if decoderContainer.contains(.addressPrefix)
        {
            self.addressPrefix = try decoderContainer.decode(String?.self, forKey: .addressPrefix)
        }
        if decoderContainer.contains(.ruleAction)
        {
            self.ruleAction = try decoderContainer.decode(String?.self, forKey: .ruleAction)
        }
        if decoderContainer.contains(.priority)
        {
            self.priority = try decoderContainer.decode(Int?.self, forKey: .priority)
        }
        if decoderContainer.contains(.descriptionValue)
        {
            self.descriptionValue = try decoderContainer.decode(String?.self, forKey: .descriptionValue)
        }
        if decoderContainer.contains(.createdTime)
        {
            self.createdTime = try decoderContainer.decode(String?.self, forKey: .createdTime)
        }
    }
}
public extension NetworkAclRule{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: NetworkAclRuleCodingKeys.self)
         try encoderContainer.encode(ruleId, forKey: .ruleId)
         try encoderContainer.encode(protocolValue, forKey: .protocolValue)
         try encoderContainer.encode(fromPort, forKey: .fromPort)
         try encoderContainer.encode(toPort, forKey: .toPort)
         try encoderContainer.encode(direction, forKey: .direction)
         try encoderContainer.encode(addressPrefix, forKey: .addressPrefix)
         try encoderContainer.encode(ruleAction, forKey: .ruleAction)
         try encoderContainer.encode(priority, forKey: .priority)
         try encoderContainer.encode(descriptionValue, forKey: .descriptionValue)
         try encoderContainer.encode(createdTime, forKey: .createdTime)
    }
}
///  modifyNetworkAclSpec
public class ModifyNetworkAclSpec:NSObject,Codable{
    /// networkAcl名称,只允许输入中文、数字、大小写字母、英文下划线“_”及中划线“-”，不允许为空且不超过32字符
    var networkAclName:String?
    /// 描述,允许输入UTF-8编码下的全部字符，不超过256字符
    var descriptionValue:String?



    public override init(){
            super.init()
    }

    enum ModifyNetworkAclSpecCodingKeys: String, CodingKey {
        case networkAclName
        case descriptionValue = "description"
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: ModifyNetworkAclSpecCodingKeys.self)
        if decoderContainer.contains(.networkAclName)
        {
            self.networkAclName = try decoderContainer.decode(String?.self, forKey: .networkAclName)
        }
        if decoderContainer.contains(.descriptionValue)
        {
            self.descriptionValue = try decoderContainer.decode(String?.self, forKey: .descriptionValue)
        }
    }
}
public extension ModifyNetworkAclSpec{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: ModifyNetworkAclSpecCodingKeys.self)
         try encoderContainer.encode(networkAclName, forKey: .networkAclName)
         try encoderContainer.encode(descriptionValue, forKey: .descriptionValue)
    }
}
///  networkAcl
public class NetworkAcl:NSObject,Codable{
    /// networkAcl ID
    var networkAclId:String?
    /// networkAcl名称
    var networkAclName:String?
    /// 私有网络 ID
    var vpcId:String?
    /// networkAcl规则列表
    var networkAclRules:[NetworkAclRule?]?
    /// networkAcl绑定的子网列表
    var subnetIds:[String?]?
    /// 描述,允许输入UTF-8编码下的全部字符，不超过256字符
    var descriptionValue:String?
    /// networkAcl创建时间
    var createdTime:String?



    public override init(){
            super.init()
    }

    enum NetworkAclCodingKeys: String, CodingKey {
        case networkAclId
        case networkAclName
        case vpcId
        case networkAclRules
        case subnetIds
        case descriptionValue = "description"
        case createdTime
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: NetworkAclCodingKeys.self)
        if decoderContainer.contains(.networkAclId)
        {
            self.networkAclId = try decoderContainer.decode(String?.self, forKey: .networkAclId)
        }
        if decoderContainer.contains(.networkAclName)
        {
            self.networkAclName = try decoderContainer.decode(String?.self, forKey: .networkAclName)
        }
        if decoderContainer.contains(.vpcId)
        {
            self.vpcId = try decoderContainer.decode(String?.self, forKey: .vpcId)
        }
        if decoderContainer.contains(.networkAclRules)
        {
            self.networkAclRules = try decoderContainer.decode([NetworkAclRule?]?.self, forKey: .networkAclRules)
        }
        if decoderContainer.contains(.subnetIds)
        {
            self.subnetIds = try decoderContainer.decode([String?]?.self, forKey: .subnetIds)
        }
        if decoderContainer.contains(.descriptionValue)
        {
            self.descriptionValue = try decoderContainer.decode(String?.self, forKey: .descriptionValue)
        }
        if decoderContainer.contains(.createdTime)
        {
            self.createdTime = try decoderContainer.decode(String?.self, forKey: .createdTime)
        }
    }
}
public extension NetworkAcl{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: NetworkAclCodingKeys.self)
         try encoderContainer.encode(networkAclId, forKey: .networkAclId)
         try encoderContainer.encode(networkAclName, forKey: .networkAclName)
         try encoderContainer.encode(vpcId, forKey: .vpcId)
         try encoderContainer.encode(networkAclRules, forKey: .networkAclRules)
         try encoderContainer.encode(subnetIds, forKey: .subnetIds)
         try encoderContainer.encode(descriptionValue, forKey: .descriptionValue)
         try encoderContainer.encode(createdTime, forKey: .createdTime)
    }
}
///  createElasticIpSpec
public class CreateElasticIpSpec:NSObject,Codable{
    /// 购买弹性ip数量；取值范围：[1,100]
    /// Required:true
    var maxCount:Int
    /// 指定弹性ip地址进行创建，当申请创建多个弹性ip时，必须为空
    var elasticIpAddress:String?
    /// 弹性ip规格
    /// Required:true
    var elasticIpSpec:ElasticIpSpec



    public  init(maxCount:Int,elasticIpSpec:ElasticIpSpec){
             self.maxCount = maxCount
             self.elasticIpSpec = elasticIpSpec
    }

    enum CreateElasticIpSpecCodingKeys: String, CodingKey {
        case maxCount
        case elasticIpAddress
        case elasticIpSpec
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: CreateElasticIpSpecCodingKeys.self)
        self.maxCount = try decoderContainer.decode(Int.self, forKey: .maxCount)
        if decoderContainer.contains(.elasticIpAddress)
        {
            self.elasticIpAddress = try decoderContainer.decode(String?.self, forKey: .elasticIpAddress)
        }
        self.elasticIpSpec = try decoderContainer.decode(ElasticIpSpec.self, forKey: .elasticIpSpec)
    }
}
public extension CreateElasticIpSpec{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: CreateElasticIpSpecCodingKeys.self)
         try encoderContainer.encode(maxCount, forKey: .maxCount)
         try encoderContainer.encode(elasticIpAddress, forKey: .elasticIpAddress)
         try encoderContainer.encode(elasticIpSpec, forKey: .elasticIpSpec)
    }
}
///  elasticIpSpec
public class ElasticIpSpec:NSObject,Codable{
    /// 弹性公网IP的限速（单位：Mbps），取值范围为[1-200]
    /// Required:true
    var bandwidthMbps:Int
    /// IP服务商，取值为bgp或no_bgp，cn-north-1：bgp；cn-south-1：[bgp，no_bgp]；cn-east-1：[bgp，no_bgp]；cn-east-2：bgp
    /// Required:true
    var provider:String
    /// 计费配置
    var chargeSpec:ChargeSpec?



    public  init(bandwidthMbps:Int,provider:String){
             self.bandwidthMbps = bandwidthMbps
             self.provider = provider
    }

    enum ElasticIpSpecCodingKeys: String, CodingKey {
        case bandwidthMbps
        case provider
        case chargeSpec
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: ElasticIpSpecCodingKeys.self)
        self.bandwidthMbps = try decoderContainer.decode(Int.self, forKey: .bandwidthMbps)
        self.provider = try decoderContainer.decode(String.self, forKey: .provider)
        if decoderContainer.contains(.chargeSpec)
        {
            self.chargeSpec = try decoderContainer.decode(ChargeSpec?.self, forKey: .chargeSpec)
        }
    }
}
public extension ElasticIpSpec{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: ElasticIpSpecCodingKeys.self)
         try encoderContainer.encode(bandwidthMbps, forKey: .bandwidthMbps)
         try encoderContainer.encode(provider, forKey: .provider)
         try encoderContainer.encode(chargeSpec, forKey: .chargeSpec)
    }
}
///  elasticIp
public class ElasticIp:NSObject,Codable{
    /// 弹性IP的Id
    var elasticIpId:String?
    /// 弹性IP地址
    var elasticIpAddress:String?
    /// 弹性ip的限速（单位：Mbps)
    var bandwidthMbps:Int?
    /// IP服务商，取值为bgp或no_bgp
    var provider:String?
    /// 私有IP的IPV4地址
    var privateIpAddress:String?
    /// 配置弹性网卡Id
    var networkInterfaceId:String?
    /// 实例Id
    var instanceId:String?
    /// 实例类型
    var instanceType:String?
    /// 计费配置
    var charge:Charge?
    /// 弹性ip创建时间
    var createdTime:String?
    /// 弹性ip可用区属性，如果为空，表示全可用区
    var az:String?



    public override init(){
            super.init()
    }

    enum ElasticIpCodingKeys: String, CodingKey {
        case elasticIpId
        case elasticIpAddress
        case bandwidthMbps
        case provider
        case privateIpAddress
        case networkInterfaceId
        case instanceId
        case instanceType
        case charge
        case createdTime
        case az
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: ElasticIpCodingKeys.self)
        if decoderContainer.contains(.elasticIpId)
        {
            self.elasticIpId = try decoderContainer.decode(String?.self, forKey: .elasticIpId)
        }
        if decoderContainer.contains(.elasticIpAddress)
        {
            self.elasticIpAddress = try decoderContainer.decode(String?.self, forKey: .elasticIpAddress)
        }
        if decoderContainer.contains(.bandwidthMbps)
        {
            self.bandwidthMbps = try decoderContainer.decode(Int?.self, forKey: .bandwidthMbps)
        }
        if decoderContainer.contains(.provider)
        {
            self.provider = try decoderContainer.decode(String?.self, forKey: .provider)
        }
        if decoderContainer.contains(.privateIpAddress)
        {
            self.privateIpAddress = try decoderContainer.decode(String?.self, forKey: .privateIpAddress)
        }
        if decoderContainer.contains(.networkInterfaceId)
        {
            self.networkInterfaceId = try decoderContainer.decode(String?.self, forKey: .networkInterfaceId)
        }
        if decoderContainer.contains(.instanceId)
        {
            self.instanceId = try decoderContainer.decode(String?.self, forKey: .instanceId)
        }
        if decoderContainer.contains(.instanceType)
        {
            self.instanceType = try decoderContainer.decode(String?.self, forKey: .instanceType)
        }
        if decoderContainer.contains(.charge)
        {
            self.charge = try decoderContainer.decode(Charge?.self, forKey: .charge)
        }
        if decoderContainer.contains(.createdTime)
        {
            self.createdTime = try decoderContainer.decode(String?.self, forKey: .createdTime)
        }
        if decoderContainer.contains(.az)
        {
            self.az = try decoderContainer.decode(String?.self, forKey: .az)
        }
    }
}
public extension ElasticIp{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: ElasticIpCodingKeys.self)
         try encoderContainer.encode(elasticIpId, forKey: .elasticIpId)
         try encoderContainer.encode(elasticIpAddress, forKey: .elasticIpAddress)
         try encoderContainer.encode(bandwidthMbps, forKey: .bandwidthMbps)
         try encoderContainer.encode(provider, forKey: .provider)
         try encoderContainer.encode(privateIpAddress, forKey: .privateIpAddress)
         try encoderContainer.encode(networkInterfaceId, forKey: .networkInterfaceId)
         try encoderContainer.encode(instanceId, forKey: .instanceId)
         try encoderContainer.encode(instanceType, forKey: .instanceType)
         try encoderContainer.encode(charge, forKey: .charge)
         try encoderContainer.encode(createdTime, forKey: .createdTime)
         try encoderContainer.encode(az, forKey: .az)
    }
}
///  modifyElasticIpSpec
public class ModifyElasticIpSpec:NSObject,Codable{
    /// 弹性公网IP的限速（单位：Mbps），取值范围为[1-200]
    /// Required:true
    var bandwidthMbps:Int



    public  init(bandwidthMbps:Int){
             self.bandwidthMbps = bandwidthMbps
    }

    enum ModifyElasticIpSpecCodingKeys: String, CodingKey {
        case bandwidthMbps
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: ModifyElasticIpSpecCodingKeys.self)
        self.bandwidthMbps = try decoderContainer.decode(Int.self, forKey: .bandwidthMbps)
    }
}
public extension ModifyElasticIpSpec{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: ModifyElasticIpSpecCodingKeys.self)
         try encoderContainer.encode(bandwidthMbps, forKey: .bandwidthMbps)
    }
}
///  modifyVpcPeeringSpec
public class ModifyVpcPeeringSpec:NSObject,Codable{
    /// VpcPeering的名字,不为空。名称取值范围：1-32个中文、英文大小写的字母、数字和下划线分隔符
    var vpcPeeringName:String?
    /// VpcPeering 描述，取值范围：0-256个中文、英文大小写的字母、数字和下划线分隔符
    var descriptionValue:String?



    public override init(){
            super.init()
    }

    enum ModifyVpcPeeringSpecCodingKeys: String, CodingKey {
        case vpcPeeringName
        case descriptionValue = "description"
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: ModifyVpcPeeringSpecCodingKeys.self)
        if decoderContainer.contains(.vpcPeeringName)
        {
            self.vpcPeeringName = try decoderContainer.decode(String?.self, forKey: .vpcPeeringName)
        }
        if decoderContainer.contains(.descriptionValue)
        {
            self.descriptionValue = try decoderContainer.decode(String?.self, forKey: .descriptionValue)
        }
    }
}
public extension ModifyVpcPeeringSpec{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: ModifyVpcPeeringSpecCodingKeys.self)
         try encoderContainer.encode(vpcPeeringName, forKey: .vpcPeeringName)
         try encoderContainer.encode(descriptionValue, forKey: .descriptionValue)
    }
}
///  vpcPeeringVpcInfo
public class VpcPeeringVpcInfo:NSObject,Codable{
    /// 子网所属VPC的Id
    var vpcId:String?
    /// 私有网络名称，取值范围：1-60个中文、英文大小写的字母、数字和下划线分隔符
    var vpcName:String?
    /// 如果为空，则不限制网段，如果不为空，10.0.0.0/8、172.16.0.0/12和192.168.0.0/16及它们包含的子网，且子网掩码长度为16-28之间
    var addressPrefix:[String?]?



    public override init(){
            super.init()
    }

    enum VpcPeeringVpcInfoCodingKeys: String, CodingKey {
        case vpcId
        case vpcName
        case addressPrefix
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: VpcPeeringVpcInfoCodingKeys.self)
        if decoderContainer.contains(.vpcId)
        {
            self.vpcId = try decoderContainer.decode(String?.self, forKey: .vpcId)
        }
        if decoderContainer.contains(.vpcName)
        {
            self.vpcName = try decoderContainer.decode(String?.self, forKey: .vpcName)
        }
        if decoderContainer.contains(.addressPrefix)
        {
            self.addressPrefix = try decoderContainer.decode([String?]?.self, forKey: .addressPrefix)
        }
    }
}
public extension VpcPeeringVpcInfo{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: VpcPeeringVpcInfoCodingKeys.self)
         try encoderContainer.encode(vpcId, forKey: .vpcId)
         try encoderContainer.encode(vpcName, forKey: .vpcName)
         try encoderContainer.encode(addressPrefix, forKey: .addressPrefix)
    }
}
///  createVpcPeeringSpec
public class CreateVpcPeeringSpec:NSObject,Codable{
    /// VpcPeering的名字,不为空。名称取值范围：1-32个中文、英文大小写的字母、数字和下划线分隔符
    /// Required:true
    var vpcPeeringName:String
    /// VpcPeering本端Vpc的Id
    /// Required:true
    var vpcId:String
    /// VpcPeering对端Vpc的Id
    /// Required:true
    var remoteVpcId:String
    /// VpcPeering 描述，取值范围：0-256个中文、英文大小写的字母、数字和下划线分隔符
    var descriptionValue:String?



    public  init(vpcPeeringName:String,vpcId:String,remoteVpcId:String){
             self.vpcPeeringName = vpcPeeringName
             self.vpcId = vpcId
             self.remoteVpcId = remoteVpcId
    }

    enum CreateVpcPeeringSpecCodingKeys: String, CodingKey {
        case vpcPeeringName
        case vpcId
        case remoteVpcId
        case descriptionValue = "description"
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: CreateVpcPeeringSpecCodingKeys.self)
        self.vpcPeeringName = try decoderContainer.decode(String.self, forKey: .vpcPeeringName)
        self.vpcId = try decoderContainer.decode(String.self, forKey: .vpcId)
        self.remoteVpcId = try decoderContainer.decode(String.self, forKey: .remoteVpcId)
        if decoderContainer.contains(.descriptionValue)
        {
            self.descriptionValue = try decoderContainer.decode(String?.self, forKey: .descriptionValue)
        }
    }
}
public extension CreateVpcPeeringSpec{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: CreateVpcPeeringSpecCodingKeys.self)
         try encoderContainer.encode(vpcPeeringName, forKey: .vpcPeeringName)
         try encoderContainer.encode(vpcId, forKey: .vpcId)
         try encoderContainer.encode(remoteVpcId, forKey: .remoteVpcId)
         try encoderContainer.encode(descriptionValue, forKey: .descriptionValue)
    }
}
///  vpcPeering
public class VpcPeering:NSObject,Codable{
    /// VpcPeering的Id
    var vpcPeeringId:String?
    /// VpcPeering名称，同账号下不允许重名，取值范围：1-32个中文、英文大小写的字母、数字和下划线分隔符
    var vpcPeeringName:String?
    /// 状态，取值为Connected，Disconnected，Initiated
    var vpcPeeringState:String?
    /// VpcPeering 描述，可为空值，取值范围：0-256个中文、英文大小写的字母、数字和下划线分隔符
    var descriptionValue:String?
    /// 发起VpcPeering的Vpc信息
    var vpcInfo:VpcPeeringVpcInfo?
    /// 对端的Vpc信息
    var remoteVpcInfo:VpcPeeringVpcInfo?
    /// VpcPeering创建时间
    var createdTime:String?



    public override init(){
            super.init()
    }

    enum VpcPeeringCodingKeys: String, CodingKey {
        case vpcPeeringId
        case vpcPeeringName
        case vpcPeeringState
        case descriptionValue = "description"
        case vpcInfo
        case remoteVpcInfo
        case createdTime
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: VpcPeeringCodingKeys.self)
        if decoderContainer.contains(.vpcPeeringId)
        {
            self.vpcPeeringId = try decoderContainer.decode(String?.self, forKey: .vpcPeeringId)
        }
        if decoderContainer.contains(.vpcPeeringName)
        {
            self.vpcPeeringName = try decoderContainer.decode(String?.self, forKey: .vpcPeeringName)
        }
        if decoderContainer.contains(.vpcPeeringState)
        {
            self.vpcPeeringState = try decoderContainer.decode(String?.self, forKey: .vpcPeeringState)
        }
        if decoderContainer.contains(.descriptionValue)
        {
            self.descriptionValue = try decoderContainer.decode(String?.self, forKey: .descriptionValue)
        }
        if decoderContainer.contains(.vpcInfo)
        {
            self.vpcInfo = try decoderContainer.decode(VpcPeeringVpcInfo?.self, forKey: .vpcInfo)
        }
        if decoderContainer.contains(.remoteVpcInfo)
        {
            self.remoteVpcInfo = try decoderContainer.decode(VpcPeeringVpcInfo?.self, forKey: .remoteVpcInfo)
        }
        if decoderContainer.contains(.createdTime)
        {
            self.createdTime = try decoderContainer.decode(String?.self, forKey: .createdTime)
        }
    }
}
public extension VpcPeering{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: VpcPeeringCodingKeys.self)
         try encoderContainer.encode(vpcPeeringId, forKey: .vpcPeeringId)
         try encoderContainer.encode(vpcPeeringName, forKey: .vpcPeeringName)
         try encoderContainer.encode(vpcPeeringState, forKey: .vpcPeeringState)
         try encoderContainer.encode(descriptionValue, forKey: .descriptionValue)
         try encoderContainer.encode(vpcInfo, forKey: .vpcInfo)
         try encoderContainer.encode(remoteVpcInfo, forKey: .remoteVpcInfo)
         try encoderContainer.encode(createdTime, forKey: .createdTime)
    }
}
///  vpc
public class Vpc:NSObject,Codable{
    /// Vpc的Id
    var vpcId:String?
    /// 如果为空，则不限制网段，如果不为空，10.0.0.0/8、172.16.0.0/12和192.168.0.0/16及它们包含的子网，且子网掩码长度为16-28之间
    var addressPrefix:String?
    /// VPC 描述，取值范围：1~120个字符
    var descriptionValue:String?
    /// 私有网络名称，取值范围：1-60个中文、英文大小写的字母、数字和下划线分隔符
    var vpcName:String?
    /// 同一vpc下的acl id 列表
    var aclIds:[String?]?
    /// RouteTableIds
    var routeTableIds:[String?]?
    /// 私有网络包含的子网列表
    var subnets:[Subnet?]?
    /// vpc创建时间
    var createdTime:String?



    public override init(){
            super.init()
    }

    enum VpcCodingKeys: String, CodingKey {
        case vpcId
        case addressPrefix
        case descriptionValue = "description"
        case vpcName
        case aclIds
        case routeTableIds
        case subnets
        case createdTime
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: VpcCodingKeys.self)
        if decoderContainer.contains(.vpcId)
        {
            self.vpcId = try decoderContainer.decode(String?.self, forKey: .vpcId)
        }
        if decoderContainer.contains(.addressPrefix)
        {
            self.addressPrefix = try decoderContainer.decode(String?.self, forKey: .addressPrefix)
        }
        if decoderContainer.contains(.descriptionValue)
        {
            self.descriptionValue = try decoderContainer.decode(String?.self, forKey: .descriptionValue)
        }
        if decoderContainer.contains(.vpcName)
        {
            self.vpcName = try decoderContainer.decode(String?.self, forKey: .vpcName)
        }
        if decoderContainer.contains(.aclIds)
        {
            self.aclIds = try decoderContainer.decode([String?]?.self, forKey: .aclIds)
        }
        if decoderContainer.contains(.routeTableIds)
        {
            self.routeTableIds = try decoderContainer.decode([String?]?.self, forKey: .routeTableIds)
        }
        if decoderContainer.contains(.subnets)
        {
            self.subnets = try decoderContainer.decode([Subnet?]?.self, forKey: .subnets)
        }
        if decoderContainer.contains(.createdTime)
        {
            self.createdTime = try decoderContainer.decode(String?.self, forKey: .createdTime)
        }
    }
}
public extension Vpc{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: VpcCodingKeys.self)
         try encoderContainer.encode(vpcId, forKey: .vpcId)
         try encoderContainer.encode(addressPrefix, forKey: .addressPrefix)
         try encoderContainer.encode(descriptionValue, forKey: .descriptionValue)
         try encoderContainer.encode(vpcName, forKey: .vpcName)
         try encoderContainer.encode(aclIds, forKey: .aclIds)
         try encoderContainer.encode(routeTableIds, forKey: .routeTableIds)
         try encoderContainer.encode(subnets, forKey: .subnets)
         try encoderContainer.encode(createdTime, forKey: .createdTime)
    }
}
///  vpcSpec
public class VpcSpec:NSObject,Codable{
    /// 私有网络名称,只允许输入中文、数字、大小写字母、英文下划线“_”及中划线“-”，不允许为空且不超过32字符。
    /// Required:true
    var vpcName:String
    /// 如果为空，则不限制网段，如果不为空，10.0.0.0/8、172.16.0.0/12和192.168.0.0/16及它们包含的子网，且子网掩码长度为16-28之间
    var addressPrefix:String?
    /// vpc描述，允许输入UTF-8编码下的全部字符，不超过256字符。
    var descriptionValue:String?



    public  init(vpcName:String){
             self.vpcName = vpcName
    }

    enum VpcSpecCodingKeys: String, CodingKey {
        case vpcName
        case addressPrefix
        case descriptionValue = "description"
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: VpcSpecCodingKeys.self)
        self.vpcName = try decoderContainer.decode(String.self, forKey: .vpcName)
        if decoderContainer.contains(.addressPrefix)
        {
            self.addressPrefix = try decoderContainer.decode(String?.self, forKey: .addressPrefix)
        }
        if decoderContainer.contains(.descriptionValue)
        {
            self.descriptionValue = try decoderContainer.decode(String?.self, forKey: .descriptionValue)
        }
    }
}
public extension VpcSpec{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: VpcSpecCodingKeys.self)
         try encoderContainer.encode(vpcName, forKey: .vpcName)
         try encoderContainer.encode(addressPrefix, forKey: .addressPrefix)
         try encoderContainer.encode(descriptionValue, forKey: .descriptionValue)
    }
}
///  modifyVpcSpec
public class ModifyVpcSpec:NSObject,Codable{
    /// 私有网络名称,只允许输入中文、数字、大小写字母、英文下划线“_”及中划线“-”，不允许为空且不超过32字符。
    var vpcName:String?
    /// vpc描述，允许输入UTF-8编码下的全部字符，不超过256字符。
    var descriptionValue:String?



    public override init(){
            super.init()
    }

    enum ModifyVpcSpecCodingKeys: String, CodingKey {
        case vpcName
        case descriptionValue = "description"
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: ModifyVpcSpecCodingKeys.self)
        if decoderContainer.contains(.vpcName)
        {
            self.vpcName = try decoderContainer.decode(String?.self, forKey: .vpcName)
        }
        if decoderContainer.contains(.descriptionValue)
        {
            self.descriptionValue = try decoderContainer.decode(String?.self, forKey: .descriptionValue)
        }
    }
}
public extension ModifyVpcSpec{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: ModifyVpcSpecCodingKeys.self)
         try encoderContainer.encode(vpcName, forKey: .vpcName)
         try encoderContainer.encode(descriptionValue, forKey: .descriptionValue)
    }
}
///  segment
public class Segment:NSObject,Codable{
    /// 网段的Id
    var segmentId:String?
    /// 网段名称，只允许输入中文、数字、大小写字母、英文下划线“_”及中划线“-”，不允许为空且不超过32字符。
    var segmentName:String?
    /// 网段描述，允许输入UTF-8编码下的全部字符，不超过256字符。
    var descriptionValue:String?
    /// 网络地址段
    var addressPrefix:String?
    /// 网段可用ip数量
    var availableIpCount:Int?
    /// IP服务商，取值为bgp或no_bgp，cn-north-1：bgp；cn-south-1：[bgp，no_bgp]；cn-east-1：[bgp，no_bgp]；cn-east-2：bgp
    var provider:String?
    /// 网段的起始地址
    var startIp:String?
    /// 网段的结束地址
    var endIp:String?



    public override init(){
            super.init()
    }

    enum SegmentCodingKeys: String, CodingKey {
        case segmentId
        case segmentName
        case descriptionValue = "description"
        case addressPrefix
        case availableIpCount
        case provider
        case startIp
        case endIp
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: SegmentCodingKeys.self)
        if decoderContainer.contains(.segmentId)
        {
            self.segmentId = try decoderContainer.decode(String?.self, forKey: .segmentId)
        }
        if decoderContainer.contains(.segmentName)
        {
            self.segmentName = try decoderContainer.decode(String?.self, forKey: .segmentName)
        }
        if decoderContainer.contains(.descriptionValue)
        {
            self.descriptionValue = try decoderContainer.decode(String?.self, forKey: .descriptionValue)
        }
        if decoderContainer.contains(.addressPrefix)
        {
            self.addressPrefix = try decoderContainer.decode(String?.self, forKey: .addressPrefix)
        }
        if decoderContainer.contains(.availableIpCount)
        {
            self.availableIpCount = try decoderContainer.decode(Int?.self, forKey: .availableIpCount)
        }
        if decoderContainer.contains(.provider)
        {
            self.provider = try decoderContainer.decode(String?.self, forKey: .provider)
        }
        if decoderContainer.contains(.startIp)
        {
            self.startIp = try decoderContainer.decode(String?.self, forKey: .startIp)
        }
        if decoderContainer.contains(.endIp)
        {
            self.endIp = try decoderContainer.decode(String?.self, forKey: .endIp)
        }
    }
}
public extension Segment{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: SegmentCodingKeys.self)
         try encoderContainer.encode(segmentId, forKey: .segmentId)
         try encoderContainer.encode(segmentName, forKey: .segmentName)
         try encoderContainer.encode(descriptionValue, forKey: .descriptionValue)
         try encoderContainer.encode(addressPrefix, forKey: .addressPrefix)
         try encoderContainer.encode(availableIpCount, forKey: .availableIpCount)
         try encoderContainer.encode(provider, forKey: .provider)
         try encoderContainer.encode(startIp, forKey: .startIp)
         try encoderContainer.encode(endIp, forKey: .endIp)
    }
}
///  quota
public class Quota:NSObject,Codable{
    /// 资源类型，取值范围：vpc、elastic_ip、subnet、security_group、vpcpeering、network_interface（配额只统计辅助网卡）
    var type:String?
    /// vpc、elastic_ip、network_interface为空, subnet、security_group、vpcpeering为vpcId
    var parentResourceId:String?
    /// 配额大小
    var maxLimit:Double?
    /// 已存在的资源数量
    var count:Double?



    public override init(){
            super.init()
    }

    enum QuotaCodingKeys: String, CodingKey {
        case type
        case parentResourceId
        case maxLimit
        case count
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: QuotaCodingKeys.self)
        if decoderContainer.contains(.type)
        {
            self.type = try decoderContainer.decode(String?.self, forKey: .type)
        }
        if decoderContainer.contains(.parentResourceId)
        {
            self.parentResourceId = try decoderContainer.decode(String?.self, forKey: .parentResourceId)
        }
        if decoderContainer.contains(.maxLimit)
        {
            self.maxLimit = try decoderContainer.decode(Double?.self, forKey: .maxLimit)
        }
        if decoderContainer.contains(.count)
        {
            self.count = try decoderContainer.decode(Double?.self, forKey: .count)
        }
    }
}
public extension Quota{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: QuotaCodingKeys.self)
         try encoderContainer.encode(type, forKey: .type)
         try encoderContainer.encode(parentResourceId, forKey: .parentResourceId)
         try encoderContainer.encode(maxLimit, forKey: .maxLimit)
         try encoderContainer.encode(count, forKey: .count)
    }
}

/* Copyright 2018 JDCLOUD.COM

   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at

     http:#www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.

   Operation Records APIs
   Anti DDoS Protection Package Operation Records APIs

   OpenAPI spec version: v1
   Contact: 

   NOTE: This class is auto generated by the jdcloud code generator program.
 */


import Foundation
///  ipResource
public class IpResource:NSObject,Codable{
    /// 公网 IP 所在区域, cn-north-1: 华北-北京, cn-east-1: 华东-宿迁, cn-east-2: 华东-上海, cn-south-1: 华南-广州
    var region:String?
    /// 公网 IP 类型或绑定资源类型:
      ///   0: 未知类型,
      ///   1: 弹性公网 IP(IP 为弹性公网 IP, 绑定资源类型未知),
      ///   10: 弹性公网 IP(IP 为弹性公网 IP, 但未绑定资源),
      ///   11: 云主机,
      ///   12: 负载均衡,
      ///   13: 原生容器实例,
      ///   14: 原生容器 Pod,
      ///   2: 云物理服务器,
      /// 
    var resourceType:Int?
    /// 公网 IP 地址
    var ip:String?
    /// 带宽上限, 单位 Mbps
    var bandwidth:Int?
    /// 请求流量清洗触发值, 单位 bps/s
    var cleanThresholdBps:Int64?
    /// 报文请求清洗触发值, 单位 pps/s
    var cleanThresholdPps:Int64?
    /// 黑洞阈值
    var balckHoleThreshold:Int64?
    /// 绑定防护包 ID, 为空字符时表示未绑定防护包
    var instanceId:String?
    /// 绑定防护包名称, 为空字符串时表示未绑定防护包
    var instanceName:String?
    /// 安全状态, 0: 安全, 1: 清洗, 2: 黑洞
    var safeStatus:Int?



    public override init(){
            super.init()
    }

    enum IpResourceCodingKeys: String, CodingKey {
        case region
        case resourceType
        case ip
        case bandwidth
        case cleanThresholdBps
        case cleanThresholdPps
        case balckHoleThreshold
        case instanceId
        case instanceName
        case safeStatus
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: IpResourceCodingKeys.self)
        if decoderContainer.contains(.region)
        {
            self.region = try decoderContainer.decode(String?.self, forKey: .region)
        }
        if decoderContainer.contains(.resourceType)
        {
            self.resourceType = try decoderContainer.decode(Int?.self, forKey: .resourceType)
        }
        if decoderContainer.contains(.ip)
        {
            self.ip = try decoderContainer.decode(String?.self, forKey: .ip)
        }
        if decoderContainer.contains(.bandwidth)
        {
            self.bandwidth = try decoderContainer.decode(Int?.self, forKey: .bandwidth)
        }
        if decoderContainer.contains(.cleanThresholdBps)
        {
            self.cleanThresholdBps = try decoderContainer.decode(Int64?.self, forKey: .cleanThresholdBps)
        }
        if decoderContainer.contains(.cleanThresholdPps)
        {
            self.cleanThresholdPps = try decoderContainer.decode(Int64?.self, forKey: .cleanThresholdPps)
        }
        if decoderContainer.contains(.balckHoleThreshold)
        {
            self.balckHoleThreshold = try decoderContainer.decode(Int64?.self, forKey: .balckHoleThreshold)
        }
        if decoderContainer.contains(.instanceId)
        {
            self.instanceId = try decoderContainer.decode(String?.self, forKey: .instanceId)
        }
        if decoderContainer.contains(.instanceName)
        {
            self.instanceName = try decoderContainer.decode(String?.self, forKey: .instanceName)
        }
        if decoderContainer.contains(.safeStatus)
        {
            self.safeStatus = try decoderContainer.decode(Int?.self, forKey: .safeStatus)
        }
    }
}
public extension IpResource{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: IpResourceCodingKeys.self)
         try encoderContainer.encode(region, forKey: .region)
         try encoderContainer.encode(resourceType, forKey: .resourceType)
         try encoderContainer.encode(ip, forKey: .ip)
         try encoderContainer.encode(bandwidth, forKey: .bandwidth)
         try encoderContainer.encode(cleanThresholdBps, forKey: .cleanThresholdBps)
         try encoderContainer.encode(cleanThresholdPps, forKey: .cleanThresholdPps)
         try encoderContainer.encode(balckHoleThreshold, forKey: .balckHoleThreshold)
         try encoderContainer.encode(instanceId, forKey: .instanceId)
         try encoderContainer.encode(instanceName, forKey: .instanceName)
         try encoderContainer.encode(safeStatus, forKey: .safeStatus)
    }
}
///  ipResourceInfo
public class IpResourceInfo:NSObject,Codable{
    /// 公网 IP 地址
    var ip:String?
    /// 安全状态, 0-&gt;安全, 1-&gt;清洗, 2-&gt;黑洞
    var safeStatus:Int?
    /// 地域
    var region:String?
    /// 黑洞阈值, 单位 bps
    var blackHoleThreshold:Int64?
    /// 触发清洗的流量速率, 单位 bps
    var cleanThresholdBps:Int64?
    /// 触发清洗的包速率, 单位 pps
    var cleanThresholdPps:Int64?



    public override init(){
            super.init()
    }

    enum IpResourceInfoCodingKeys: String, CodingKey {
        case ip
        case safeStatus
        case region
        case blackHoleThreshold
        case cleanThresholdBps
        case cleanThresholdPps
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: IpResourceInfoCodingKeys.self)
        if decoderContainer.contains(.ip)
        {
            self.ip = try decoderContainer.decode(String?.self, forKey: .ip)
        }
        if decoderContainer.contains(.safeStatus)
        {
            self.safeStatus = try decoderContainer.decode(Int?.self, forKey: .safeStatus)
        }
        if decoderContainer.contains(.region)
        {
            self.region = try decoderContainer.decode(String?.self, forKey: .region)
        }
        if decoderContainer.contains(.blackHoleThreshold)
        {
            self.blackHoleThreshold = try decoderContainer.decode(Int64?.self, forKey: .blackHoleThreshold)
        }
        if decoderContainer.contains(.cleanThresholdBps)
        {
            self.cleanThresholdBps = try decoderContainer.decode(Int64?.self, forKey: .cleanThresholdBps)
        }
        if decoderContainer.contains(.cleanThresholdPps)
        {
            self.cleanThresholdPps = try decoderContainer.decode(Int64?.self, forKey: .cleanThresholdPps)
        }
    }
}
public extension IpResourceInfo{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: IpResourceInfoCodingKeys.self)
         try encoderContainer.encode(ip, forKey: .ip)
         try encoderContainer.encode(safeStatus, forKey: .safeStatus)
         try encoderContainer.encode(region, forKey: .region)
         try encoderContainer.encode(blackHoleThreshold, forKey: .blackHoleThreshold)
         try encoderContainer.encode(cleanThresholdBps, forKey: .cleanThresholdBps)
         try encoderContainer.encode(cleanThresholdPps, forKey: .cleanThresholdPps)
    }
}
///  ipResourceFlow
public class IpResourceFlow:NSObject,Codable{
    /// 时间, 格式: yyyy-MM-dd&#39;T&#39;HH:mm:ssZ
    var time:[String?]?
    /// 防护后流量
    var postProtect:[Double?]?
    /// 防护前流量
    var preProtect:[Double?]?
    /// 流量单位
    var unit:String?



    public override init(){
            super.init()
    }

    enum IpResourceFlowCodingKeys: String, CodingKey {
        case time
        case postProtect
        case preProtect
        case unit
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: IpResourceFlowCodingKeys.self)
        if decoderContainer.contains(.time)
        {
            self.time = try decoderContainer.decode([String?]?.self, forKey: .time)
        }
        if decoderContainer.contains(.postProtect)
        {
            self.postProtect = try decoderContainer.decode([Double?]?.self, forKey: .postProtect)
        }
        if decoderContainer.contains(.preProtect)
        {
            self.preProtect = try decoderContainer.decode([Double?]?.self, forKey: .preProtect)
        }
        if decoderContainer.contains(.unit)
        {
            self.unit = try decoderContainer.decode(String?.self, forKey: .unit)
        }
    }
}
public extension IpResourceFlow{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: IpResourceFlowCodingKeys.self)
         try encoderContainer.encode(time, forKey: .time)
         try encoderContainer.encode(postProtect, forKey: .postProtect)
         try encoderContainer.encode(preProtect, forKey: .preProtect)
         try encoderContainer.encode(unit, forKey: .unit)
    }
}
///  attackLog
public class AttackLog:NSObject,Codable{
    /// 公网 IP
    var ip:String?
    /// 公网 IP 类型或绑定资源类型:
      ///   0: 未知类型,
      ///   1: 弹性公网 IP(IP 为弹性公网 IP, 绑定资源类型未知),
      ///   10: 弹性公网 IP(IP 为弹性公网 IP, 但未绑定资源),
      ///   11: 云主机,
      ///   12: 负载均衡,
      ///   13: 原生容器实例,
      ///   14: 原生容器 Pod,
      ///   2: 云物理服务器,
      /// 
    var resourceType:Int?
    /// 攻击记录 Id
    var attackLogId:String?
    /// 攻击开始时间
    var startTime:String?
    /// 攻击结束时间
    var endTime:String?
    /// 触发原因:
      /// 0: 未知,
      /// 1: 四层,
      /// 2: 七层,
      /// 3: 四层和七层
      /// 
    var cause:Int?
    /// 状态, 0: 清洗完成, 1: 清洗中, 2: 黑洞中
    var status:Int?
    /// 是否黑洞
    var blackHole:Bool?
    /// 攻击流量峰值
    var peak:Double?
    /// 攻击流量峰值单位
    var unit:String?
    /// 攻击类型
    var attackType:[String?]?



    public override init(){
            super.init()
    }

    enum AttackLogCodingKeys: String, CodingKey {
        case ip
        case resourceType
        case attackLogId
        case startTime
        case endTime
        case cause
        case status
        case blackHole
        case peak
        case unit
        case attackType
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: AttackLogCodingKeys.self)
        if decoderContainer.contains(.ip)
        {
            self.ip = try decoderContainer.decode(String?.self, forKey: .ip)
        }
        if decoderContainer.contains(.resourceType)
        {
            self.resourceType = try decoderContainer.decode(Int?.self, forKey: .resourceType)
        }
        if decoderContainer.contains(.attackLogId)
        {
            self.attackLogId = try decoderContainer.decode(String?.self, forKey: .attackLogId)
        }
        if decoderContainer.contains(.startTime)
        {
            self.startTime = try decoderContainer.decode(String?.self, forKey: .startTime)
        }
        if decoderContainer.contains(.endTime)
        {
            self.endTime = try decoderContainer.decode(String?.self, forKey: .endTime)
        }
        if decoderContainer.contains(.cause)
        {
            self.cause = try decoderContainer.decode(Int?.self, forKey: .cause)
        }
        if decoderContainer.contains(.status)
        {
            self.status = try decoderContainer.decode(Int?.self, forKey: .status)
        }
        if decoderContainer.contains(.blackHole)
        {
            self.blackHole = try decoderContainer.decode(Bool?.self, forKey: .blackHole)
        }
        if decoderContainer.contains(.peak)
        {
            self.peak = try decoderContainer.decode(Double?.self, forKey: .peak)
        }
        if decoderContainer.contains(.unit)
        {
            self.unit = try decoderContainer.decode(String?.self, forKey: .unit)
        }
        if decoderContainer.contains(.attackType)
        {
            self.attackType = try decoderContainer.decode([String?]?.self, forKey: .attackType)
        }
    }
}
public extension AttackLog{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: AttackLogCodingKeys.self)
         try encoderContainer.encode(ip, forKey: .ip)
         try encoderContainer.encode(resourceType, forKey: .resourceType)
         try encoderContainer.encode(attackLogId, forKey: .attackLogId)
         try encoderContainer.encode(startTime, forKey: .startTime)
         try encoderContainer.encode(endTime, forKey: .endTime)
         try encoderContainer.encode(cause, forKey: .cause)
         try encoderContainer.encode(status, forKey: .status)
         try encoderContainer.encode(blackHole, forKey: .blackHole)
         try encoderContainer.encode(peak, forKey: .peak)
         try encoderContainer.encode(unit, forKey: .unit)
         try encoderContainer.encode(attackType, forKey: .attackType)
    }
}
///  attackTypeCount
public class AttackTypeCount:NSObject,Codable{
    /// 攻击类型
    var type:String?
    /// 攻击次数
    var count:Int?



    public override init(){
            super.init()
    }

    enum AttackTypeCountCodingKeys: String, CodingKey {
        case type
        case count
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: AttackTypeCountCodingKeys.self)
        if decoderContainer.contains(.type)
        {
            self.type = try decoderContainer.decode(String?.self, forKey: .type)
        }
        if decoderContainer.contains(.count)
        {
            self.count = try decoderContainer.decode(Int?.self, forKey: .count)
        }
    }
}
public extension AttackTypeCount{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: AttackTypeCountCodingKeys.self)
         try encoderContainer.encode(type, forKey: .type)
         try encoderContainer.encode(count, forKey: .count)
    }
}
///  instance
public class Instance:NSObject,Codable{
    /// 防护包实例 Id
    var id:String?
    /// 防护包实例名称
    var name:String?
    /// 防护包实例地域
    var region:String?
    /// 套餐类型, 1: 独享 IP, 2: 共享 IP
    var type:Int?
    /// 可防护 IP 个数
    var ipCount:Int?
    /// 保底带宽, 单位 Gbps
    var basicBandwidth:Int?
    /// 弹性带宽, 单位 Gbps
    var elasticBandwidth:Int?
    /// 实例过期时间
    var expireTime:String?
    /// 实例创建时间
    var createTime:String?
    /// 防护对象
    var protectedObjects:[ProtectedObject?]?
    /// 是否为试用防护包
    var onTrial:Bool?
    /// 资源 Id
    var resourceId:String?



    public override init(){
            super.init()
    }

    enum InstanceCodingKeys: String, CodingKey {
        case id
        case name
        case region
        case type
        case ipCount
        case basicBandwidth
        case elasticBandwidth
        case expireTime
        case createTime
        case protectedObjects
        case onTrial
        case resourceId
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: InstanceCodingKeys.self)
        if decoderContainer.contains(.id)
        {
            self.id = try decoderContainer.decode(String?.self, forKey: .id)
        }
        if decoderContainer.contains(.name)
        {
            self.name = try decoderContainer.decode(String?.self, forKey: .name)
        }
        if decoderContainer.contains(.region)
        {
            self.region = try decoderContainer.decode(String?.self, forKey: .region)
        }
        if decoderContainer.contains(.type)
        {
            self.type = try decoderContainer.decode(Int?.self, forKey: .type)
        }
        if decoderContainer.contains(.ipCount)
        {
            self.ipCount = try decoderContainer.decode(Int?.self, forKey: .ipCount)
        }
        if decoderContainer.contains(.basicBandwidth)
        {
            self.basicBandwidth = try decoderContainer.decode(Int?.self, forKey: .basicBandwidth)
        }
        if decoderContainer.contains(.elasticBandwidth)
        {
            self.elasticBandwidth = try decoderContainer.decode(Int?.self, forKey: .elasticBandwidth)
        }
        if decoderContainer.contains(.expireTime)
        {
            self.expireTime = try decoderContainer.decode(String?.self, forKey: .expireTime)
        }
        if decoderContainer.contains(.createTime)
        {
            self.createTime = try decoderContainer.decode(String?.self, forKey: .createTime)
        }
        if decoderContainer.contains(.protectedObjects)
        {
            self.protectedObjects = try decoderContainer.decode([ProtectedObject?]?.self, forKey: .protectedObjects)
        }
        if decoderContainer.contains(.onTrial)
        {
            self.onTrial = try decoderContainer.decode(Bool?.self, forKey: .onTrial)
        }
        if decoderContainer.contains(.resourceId)
        {
            self.resourceId = try decoderContainer.decode(String?.self, forKey: .resourceId)
        }
    }
}
public extension Instance{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: InstanceCodingKeys.self)
         try encoderContainer.encode(id, forKey: .id)
         try encoderContainer.encode(name, forKey: .name)
         try encoderContainer.encode(region, forKey: .region)
         try encoderContainer.encode(type, forKey: .type)
         try encoderContainer.encode(ipCount, forKey: .ipCount)
         try encoderContainer.encode(basicBandwidth, forKey: .basicBandwidth)
         try encoderContainer.encode(elasticBandwidth, forKey: .elasticBandwidth)
         try encoderContainer.encode(expireTime, forKey: .expireTime)
         try encoderContainer.encode(createTime, forKey: .createTime)
         try encoderContainer.encode(protectedObjects, forKey: .protectedObjects)
         try encoderContainer.encode(onTrial, forKey: .onTrial)
         try encoderContainer.encode(resourceId, forKey: .resourceId)
    }
}
///  country
public class Country:NSObject,Codable{
    /// 国家或地区名称
    var label:String?
    /// 国家或地区编码
    var value:String?
    /// Children
    var children:[Country?]?



    public override init(){
            super.init()
    }

    enum CountryCodingKeys: String, CodingKey {
        case label
        case value
        case children
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: CountryCodingKeys.self)
        if decoderContainer.contains(.label)
        {
            self.label = try decoderContainer.decode(String?.self, forKey: .label)
        }
        if decoderContainer.contains(.value)
        {
            self.value = try decoderContainer.decode(String?.self, forKey: .value)
        }
        if decoderContainer.contains(.children)
        {
            self.children = try decoderContainer.decode([Country?]?.self, forKey: .children)
        }
    }
}
public extension Country{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: CountryCodingKeys.self)
         try encoderContainer.encode(label, forKey: .label)
         try encoderContainer.encode(value, forKey: .value)
         try encoderContainer.encode(children, forKey: .children)
    }
}
///  protectedObject
public class ProtectedObject:NSObject,Codable{
    /// 防护对象类型: eip: 弹性公网 IP, cps: 云物理服务器
    var type:String?
    /// 已防护 IP 个数
    var count:Int?
    /// 防护 IP 列表
    var ipList:[ProtectedIp?]?



    public override init(){
            super.init()
    }

    enum ProtectedObjectCodingKeys: String, CodingKey {
        case type
        case count
        case ipList
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: ProtectedObjectCodingKeys.self)
        if decoderContainer.contains(.type)
        {
            self.type = try decoderContainer.decode(String?.self, forKey: .type)
        }
        if decoderContainer.contains(.count)
        {
            self.count = try decoderContainer.decode(Int?.self, forKey: .count)
        }
        if decoderContainer.contains(.ipList)
        {
            self.ipList = try decoderContainer.decode([ProtectedIp?]?.self, forKey: .ipList)
        }
    }
}
public extension ProtectedObject{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: ProtectedObjectCodingKeys.self)
         try encoderContainer.encode(type, forKey: .type)
         try encoderContainer.encode(count, forKey: .count)
         try encoderContainer.encode(ipList, forKey: .ipList)
    }
}
///  geoBlack
public class GeoBlack:NSObject,Codable{
    /// geo 拦截地域
    var label:String?
    /// geo 拦截地域编码
    var value:String?



    public override init(){
            super.init()
    }

    enum GeoBlackCodingKeys: String, CodingKey {
        case label
        case value
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: GeoBlackCodingKeys.self)
        if decoderContainer.contains(.label)
        {
            self.label = try decoderContainer.decode(String?.self, forKey: .label)
        }
        if decoderContainer.contains(.value)
        {
            self.value = try decoderContainer.decode(String?.self, forKey: .value)
        }
    }
}
public extension GeoBlack{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: GeoBlackCodingKeys.self)
         try encoderContainer.encode(label, forKey: .label)
         try encoderContainer.encode(value, forKey: .value)
    }
}
///  createInstanceSpec
public class CreateInstanceSpec:NSObject,Codable{
    /// 防护包实例名称, 新购防护包时必传
      /// 长度限制为 1-80 个字符, 只允许包含中文, 字母, 数字, -, ., /, _
      /// 
    /// Required:true
    var name:String
    /// 可防护 IP 数量, 1, 5, 10, 50, 100, 1000(不限)
    /// Required:true
    var ipNum:Int
    /// 保底带宽: 10, 20, 30, 50, 单位: Gbps
    /// Required:true
    var bpGbps:Int
    /// 弹性带宽: 0, 10, 20, 单位: Gbps
    /// Required:true
    var epGbps:Int
    /// 购买防护包时长, 新购防护包时必传
      /// - timeUnit 为 3 时, 可取值 1-9
      /// - timeUnit 为 4 时, 可取值 1-3
      /// 
    /// Required:true
    var timeSpan:Int
    /// 购买时长类型, 新购防护包时必传
      /// - 3: 月
      /// - 4: 年
    /// Required:true
    var timeUnit:Int



    public  init(name:String,ipNum:Int,bpGbps:Int,epGbps:Int,timeSpan:Int,timeUnit:Int){
             self.name = name
             self.ipNum = ipNum
             self.bpGbps = bpGbps
             self.epGbps = epGbps
             self.timeSpan = timeSpan
             self.timeUnit = timeUnit
    }

    enum CreateInstanceSpecCodingKeys: String, CodingKey {
        case name
        case ipNum
        case bpGbps
        case epGbps
        case timeSpan
        case timeUnit
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: CreateInstanceSpecCodingKeys.self)
        self.name = try decoderContainer.decode(String.self, forKey: .name)
        self.ipNum = try decoderContainer.decode(Int.self, forKey: .ipNum)
        self.bpGbps = try decoderContainer.decode(Int.self, forKey: .bpGbps)
        self.epGbps = try decoderContainer.decode(Int.self, forKey: .epGbps)
        self.timeSpan = try decoderContainer.decode(Int.self, forKey: .timeSpan)
        self.timeUnit = try decoderContainer.decode(Int.self, forKey: .timeUnit)
    }
}
public extension CreateInstanceSpec{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: CreateInstanceSpecCodingKeys.self)
         try encoderContainer.encode(name, forKey: .name)
         try encoderContainer.encode(ipNum, forKey: .ipNum)
         try encoderContainer.encode(bpGbps, forKey: .bpGbps)
         try encoderContainer.encode(epGbps, forKey: .epGbps)
         try encoderContainer.encode(timeSpan, forKey: .timeSpan)
         try encoderContainer.encode(timeUnit, forKey: .timeUnit)
    }
}
///  protectedObjectsSpec
public class ProtectedObjectsSpec:NSObject,Codable{
    /// 是否防护弹性公网 IP
    /// Required:true
    var eip:Bool
    /// 是否防护云物理服务器
    /// Required:true
    var cps:Bool



    public  init(eip:Bool,cps:Bool){
             self.eip = eip
             self.cps = cps
    }

    enum ProtectedObjectsSpecCodingKeys: String, CodingKey {
        case eip
        case cps
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: ProtectedObjectsSpecCodingKeys.self)
        self.eip = try decoderContainer.decode(Bool.self, forKey: .eip)
        self.cps = try decoderContainer.decode(Bool.self, forKey: .cps)
    }
}
public extension ProtectedObjectsSpec{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: ProtectedObjectsSpecCodingKeys.self)
         try encoderContainer.encode(eip, forKey: .eip)
         try encoderContainer.encode(cps, forKey: .cps)
    }
}
///  protectionOutline
public class ProtectionOutline:NSObject,Codable{
    /// 已防护天数
    var protectedDay:Int64?
    /// 已防护 IP 数量
    var protectedIpCount:Int64?
    /// 7 日攻击次数
    var weekAttackCount:Int64?
    /// 7 日攻击流量峰值
    var weekAttackPeak:Double?
    /// 7 日攻击流量单位
    var weekAttackUnit:String?
    /// 30 日攻击次数
    var monthAttackCount:Int64?
    /// 30 日攻击流量峰值
    var monthAttackPeak:Double?
    /// 30 日攻击流量单位
    var monthAttackUnit:String?
    /// 当前攻击数量
    var currentAttackCount:Int64?



    public override init(){
            super.init()
    }

    enum ProtectionOutlineCodingKeys: String, CodingKey {
        case protectedDay
        case protectedIpCount
        case weekAttackCount
        case weekAttackPeak
        case weekAttackUnit
        case monthAttackCount
        case monthAttackPeak
        case monthAttackUnit
        case currentAttackCount
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: ProtectionOutlineCodingKeys.self)
        if decoderContainer.contains(.protectedDay)
        {
            self.protectedDay = try decoderContainer.decode(Int64?.self, forKey: .protectedDay)
        }
        if decoderContainer.contains(.protectedIpCount)
        {
            self.protectedIpCount = try decoderContainer.decode(Int64?.self, forKey: .protectedIpCount)
        }
        if decoderContainer.contains(.weekAttackCount)
        {
            self.weekAttackCount = try decoderContainer.decode(Int64?.self, forKey: .weekAttackCount)
        }
        if decoderContainer.contains(.weekAttackPeak)
        {
            self.weekAttackPeak = try decoderContainer.decode(Double?.self, forKey: .weekAttackPeak)
        }
        if decoderContainer.contains(.weekAttackUnit)
        {
            self.weekAttackUnit = try decoderContainer.decode(String?.self, forKey: .weekAttackUnit)
        }
        if decoderContainer.contains(.monthAttackCount)
        {
            self.monthAttackCount = try decoderContainer.decode(Int64?.self, forKey: .monthAttackCount)
        }
        if decoderContainer.contains(.monthAttackPeak)
        {
            self.monthAttackPeak = try decoderContainer.decode(Double?.self, forKey: .monthAttackPeak)
        }
        if decoderContainer.contains(.monthAttackUnit)
        {
            self.monthAttackUnit = try decoderContainer.decode(String?.self, forKey: .monthAttackUnit)
        }
        if decoderContainer.contains(.currentAttackCount)
        {
            self.currentAttackCount = try decoderContainer.decode(Int64?.self, forKey: .currentAttackCount)
        }
    }
}
public extension ProtectionOutline{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: ProtectionOutlineCodingKeys.self)
         try encoderContainer.encode(protectedDay, forKey: .protectedDay)
         try encoderContainer.encode(protectedIpCount, forKey: .protectedIpCount)
         try encoderContainer.encode(weekAttackCount, forKey: .weekAttackCount)
         try encoderContainer.encode(weekAttackPeak, forKey: .weekAttackPeak)
         try encoderContainer.encode(weekAttackUnit, forKey: .weekAttackUnit)
         try encoderContainer.encode(monthAttackCount, forKey: .monthAttackCount)
         try encoderContainer.encode(monthAttackPeak, forKey: .monthAttackPeak)
         try encoderContainer.encode(monthAttackUnit, forKey: .monthAttackUnit)
         try encoderContainer.encode(currentAttackCount, forKey: .currentAttackCount)
    }
}
///  modifyInstanceNameSpec
public class ModifyInstanceNameSpec:NSObject,Codable{
    /// 新的实例名称, 长度限制为 1-80 个字符, 只允许包含中文, 字母, 数字, -, ., /, _
    /// Required:true
    var name:String



    public  init(name:String){
             self.name = name
    }

    enum ModifyInstanceNameSpecCodingKeys: String, CodingKey {
        case name
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: ModifyInstanceNameSpecCodingKeys.self)
        self.name = try decoderContainer.decode(String.self, forKey: .name)
    }
}
public extension ModifyInstanceNameSpec{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: ModifyInstanceNameSpecCodingKeys.self)
         try encoderContainer.encode(name, forKey: .name)
    }
}
///  protectedIpSpec
public class ProtectedIpSpec:NSObject,Codable{
    /// 被防护 IP 列表
    /// Required:true
    var ip:[String?]?



    public  init(ip:[String?]?){
             self.ip = ip
    }

    enum ProtectedIpSpecCodingKeys: String, CodingKey {
        case ip
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: ProtectedIpSpecCodingKeys.self)
        self.ip = try decoderContainer.decode([String?]?.self, forKey: .ip)
    }
}
public extension ProtectedIpSpec{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: ProtectedIpSpecCodingKeys.self)
         try encoderContainer.encode(ip, forKey: .ip)
    }
}
///  protectedIp
public class ProtectedIp:NSObject,Codable{
    /// 被防护 IP
    var ip:String?
    /// 安全状态, 0: 安全, 1: 清洗, 2: 黑洞
    var safeStatus:Int?
    /// 公网 IP 类型或绑定资源类型:
      ///   0: 未知类型,
      ///   1: 弹性公网 IP(IP 为弹性公网 IP, 绑定资源类型未知),
      ///   10: 弹性公网 IP(IP 为弹性公网 IP, 但未绑定资源),
      ///   11: 云主机,
      ///   12: 负载均衡,
      ///   13: 原生容器实例,
      ///   14: 原生容器 Pod,
      ///   2: 云物理服务器,
      /// 
    var resourceType:Int?
    /// 防护规则类型, 0: 默认(防护包的防护规则), 1: IP 自定义规则
    var protectionRuleType:Int?



    public override init(){
            super.init()
    }

    enum ProtectedIpCodingKeys: String, CodingKey {
        case ip
        case safeStatus
        case resourceType
        case protectionRuleType
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: ProtectedIpCodingKeys.self)
        if decoderContainer.contains(.ip)
        {
            self.ip = try decoderContainer.decode(String?.self, forKey: .ip)
        }
        if decoderContainer.contains(.safeStatus)
        {
            self.safeStatus = try decoderContainer.decode(Int?.self, forKey: .safeStatus)
        }
        if decoderContainer.contains(.resourceType)
        {
            self.resourceType = try decoderContainer.decode(Int?.self, forKey: .resourceType)
        }
        if decoderContainer.contains(.protectionRuleType)
        {
            self.protectionRuleType = try decoderContainer.decode(Int?.self, forKey: .protectionRuleType)
        }
    }
}
public extension ProtectedIp{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: ProtectedIpCodingKeys.self)
         try encoderContainer.encode(ip, forKey: .ip)
         try encoderContainer.encode(safeStatus, forKey: .safeStatus)
         try encoderContainer.encode(resourceType, forKey: .resourceType)
         try encoderContainer.encode(protectionRuleType, forKey: .protectionRuleType)
    }
}
///  protectionRuleSpec
public class ProtectionRuleSpec:NSObject,Codable{
    /// 被防护 IP, 缺省时修改防护包实例防护规则
    var ip:String?
    /// 防护规则类型, 修改 ip 防护规则时必传, 0: 设置 ip 使用防护包规则, 1: 设置 IP 使用自定义规则
    var type:Int?
    /// 清洗触发值 bps, 修改实例防护规则或自定义 IP 防护规则时必传
    var cleanThresholdBps:Int64?
    /// 清洗触发值 pps, 修改实例防护规则或自定义 IP 防护规则时必传
    var cleanThresholdPps:Int64?
    /// 虚假源, 0: 关闭, 1: 开启, 修改实例防护规则或自定义 IP 防护规则时必传
    var spoofIpEnable:Int?
    /// 源新建连接限速, 0: 关闭, 1: 开启, 修改实例防护规则或自定义 IP 防护规则时必传
    var srcNewConnLimitEnable:Int?
    /// 源新建连接速率, 修改实例防护规则或自定义 IP 防护规则时必传
    var srcNewConnLimitValue:Int64?
    /// 目的新建连接, 0: 关闭, 1: 开启, 修改实例防护规则或自定义 IP 防护规则时必传
    var dstNewConnLimitEnable:Int?
    /// 目的新建连接速率, 修改实例防护规则或自定义 IP 防护规则时必传
    var dstNewConnLimitValue:Int64?
    /// 报文最小长度, 取值范围 [1, datagramRangeMax)
    var datagramRangeMin:Int64?
    /// 报文最大长度, 取值范围 (datagramRangeMin, 1518]
    var datagramRangeMax:Int64?
    /// geo 拦截地域编码列表. 查询 &lt;a href&#x3D;&quot;http://docs.jdcloud.com/anti-ddos-protection-package/api/describegeoareas&quot;&gt;describeGeoAreas&lt;/a&gt; 接口获取可设置的地域编码列表
      /// 
    var geoBlackList:[String?]?
    /// IP 黑名单列表
    var ipBlackList:[String?]?
    /// IP 白名单列表
    var ipWhiteList:[String?]?



    public override init(){
            super.init()
    }

    enum ProtectionRuleSpecCodingKeys: String, CodingKey {
        case ip
        case type
        case cleanThresholdBps
        case cleanThresholdPps
        case spoofIpEnable
        case srcNewConnLimitEnable
        case srcNewConnLimitValue
        case dstNewConnLimitEnable
        case dstNewConnLimitValue
        case datagramRangeMin
        case datagramRangeMax
        case geoBlackList
        case ipBlackList
        case ipWhiteList
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: ProtectionRuleSpecCodingKeys.self)
        if decoderContainer.contains(.ip)
        {
            self.ip = try decoderContainer.decode(String?.self, forKey: .ip)
        }
        if decoderContainer.contains(.type)
        {
            self.type = try decoderContainer.decode(Int?.self, forKey: .type)
        }
        if decoderContainer.contains(.cleanThresholdBps)
        {
            self.cleanThresholdBps = try decoderContainer.decode(Int64?.self, forKey: .cleanThresholdBps)
        }
        if decoderContainer.contains(.cleanThresholdPps)
        {
            self.cleanThresholdPps = try decoderContainer.decode(Int64?.self, forKey: .cleanThresholdPps)
        }
        if decoderContainer.contains(.spoofIpEnable)
        {
            self.spoofIpEnable = try decoderContainer.decode(Int?.self, forKey: .spoofIpEnable)
        }
        if decoderContainer.contains(.srcNewConnLimitEnable)
        {
            self.srcNewConnLimitEnable = try decoderContainer.decode(Int?.self, forKey: .srcNewConnLimitEnable)
        }
        if decoderContainer.contains(.srcNewConnLimitValue)
        {
            self.srcNewConnLimitValue = try decoderContainer.decode(Int64?.self, forKey: .srcNewConnLimitValue)
        }
        if decoderContainer.contains(.dstNewConnLimitEnable)
        {
            self.dstNewConnLimitEnable = try decoderContainer.decode(Int?.self, forKey: .dstNewConnLimitEnable)
        }
        if decoderContainer.contains(.dstNewConnLimitValue)
        {
            self.dstNewConnLimitValue = try decoderContainer.decode(Int64?.self, forKey: .dstNewConnLimitValue)
        }
        if decoderContainer.contains(.datagramRangeMin)
        {
            self.datagramRangeMin = try decoderContainer.decode(Int64?.self, forKey: .datagramRangeMin)
        }
        if decoderContainer.contains(.datagramRangeMax)
        {
            self.datagramRangeMax = try decoderContainer.decode(Int64?.self, forKey: .datagramRangeMax)
        }
        if decoderContainer.contains(.geoBlackList)
        {
            self.geoBlackList = try decoderContainer.decode([String?]?.self, forKey: .geoBlackList)
        }
        if decoderContainer.contains(.ipBlackList)
        {
            self.ipBlackList = try decoderContainer.decode([String?]?.self, forKey: .ipBlackList)
        }
        if decoderContainer.contains(.ipWhiteList)
        {
            self.ipWhiteList = try decoderContainer.decode([String?]?.self, forKey: .ipWhiteList)
        }
    }
}
public extension ProtectionRuleSpec{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: ProtectionRuleSpecCodingKeys.self)
         try encoderContainer.encode(ip, forKey: .ip)
         try encoderContainer.encode(type, forKey: .type)
         try encoderContainer.encode(cleanThresholdBps, forKey: .cleanThresholdBps)
         try encoderContainer.encode(cleanThresholdPps, forKey: .cleanThresholdPps)
         try encoderContainer.encode(spoofIpEnable, forKey: .spoofIpEnable)
         try encoderContainer.encode(srcNewConnLimitEnable, forKey: .srcNewConnLimitEnable)
         try encoderContainer.encode(srcNewConnLimitValue, forKey: .srcNewConnLimitValue)
         try encoderContainer.encode(dstNewConnLimitEnable, forKey: .dstNewConnLimitEnable)
         try encoderContainer.encode(dstNewConnLimitValue, forKey: .dstNewConnLimitValue)
         try encoderContainer.encode(datagramRangeMin, forKey: .datagramRangeMin)
         try encoderContainer.encode(datagramRangeMax, forKey: .datagramRangeMax)
         try encoderContainer.encode(geoBlackList, forKey: .geoBlackList)
         try encoderContainer.encode(ipBlackList, forKey: .ipBlackList)
         try encoderContainer.encode(ipWhiteList, forKey: .ipWhiteList)
    }
}
///  modifyInstanceSpec
public class ModifyInstanceSpec:NSObject,Codable{
    /// 可防护 IP 数量, 1, 5, 10, 50, 100, 1000(不限), 可升级, 不可降级
    /// Required:true
    var ipNum:Int
    /// 保底带宽: 10, 20, 30, 50, 单位: Gbps, 可升级, 不可降级
    /// Required:true
    var bpGbps:Int
    /// 弹性带宽: 0, 10, 20, 单位: Gbps, 可升级, 可降级
    /// Required:true
    var epGbps:Int



    public  init(ipNum:Int,bpGbps:Int,epGbps:Int){
             self.ipNum = ipNum
             self.bpGbps = bpGbps
             self.epGbps = epGbps
    }

    enum ModifyInstanceSpecCodingKeys: String, CodingKey {
        case ipNum
        case bpGbps
        case epGbps
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: ModifyInstanceSpecCodingKeys.self)
        self.ipNum = try decoderContainer.decode(Int.self, forKey: .ipNum)
        self.bpGbps = try decoderContainer.decode(Int.self, forKey: .bpGbps)
        self.epGbps = try decoderContainer.decode(Int.self, forKey: .epGbps)
    }
}
public extension ModifyInstanceSpec{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: ModifyInstanceSpecCodingKeys.self)
         try encoderContainer.encode(ipNum, forKey: .ipNum)
         try encoderContainer.encode(bpGbps, forKey: .bpGbps)
         try encoderContainer.encode(epGbps, forKey: .epGbps)
    }
}
///  orderSpec
public class OrderSpec:NSObject,Codable{
    /// 操作类型 1: 新购防护包, 3: 升级防护包
    /// Required:true
    var buyType:Int
    /// 防护包实例 Id, 升级防护包实例时必传
    var id:String?
    /// 防护包实例名称, 新购防护包时必传
      /// 长度限制为 1-80 个字符, 只允许包含中文, 字母, 数字, -, ., /, _
      /// 
    var name:String?
    /// 套餐类型, 1: 独享 IP, 2: 共享 IP
    /// Required:true
    var pkgType:Int
    /// 可防护 IP 数量, 5, 10, 50, 100 1000(不限)
    /// Required:true
    var ipNum:Int
    /// 保底带宽: 10, 20, 30, 50, 单位: Gbps
    /// Required:true
    var bp:Int
    /// 弹性带宽: 0, 10, 20, 单位: Gbps
    /// Required:true
    var ep:Int
    /// 购买防护包时长, 新购防护包时必传
      /// - timeUnit 为 3 时, 可取值 1-9
      /// - timeUnit 为 4 时, 可取值 1-3
      /// 
    var timeSpan:Int?
    /// 购买时长类型, 新购防护包时必传
      /// - 3: 月
      /// - 4: 年
      /// 
    var timeUnit:Int?
    /// 回调 url
    /// Required:true
    var returnUrl:String



    public  init(buyType:Int,pkgType:Int,ipNum:Int,bp:Int,ep:Int,returnUrl:String){
             self.buyType = buyType
             self.pkgType = pkgType
             self.ipNum = ipNum
             self.bp = bp
             self.ep = ep
             self.returnUrl = returnUrl
    }

    enum OrderSpecCodingKeys: String, CodingKey {
        case buyType
        case id
        case name
        case pkgType
        case ipNum
        case bp
        case ep
        case timeSpan
        case timeUnit
        case returnUrl
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: OrderSpecCodingKeys.self)
        self.buyType = try decoderContainer.decode(Int.self, forKey: .buyType)
        if decoderContainer.contains(.id)
        {
            self.id = try decoderContainer.decode(String?.self, forKey: .id)
        }
        if decoderContainer.contains(.name)
        {
            self.name = try decoderContainer.decode(String?.self, forKey: .name)
        }
        self.pkgType = try decoderContainer.decode(Int.self, forKey: .pkgType)
        self.ipNum = try decoderContainer.decode(Int.self, forKey: .ipNum)
        self.bp = try decoderContainer.decode(Int.self, forKey: .bp)
        self.ep = try decoderContainer.decode(Int.self, forKey: .ep)
        if decoderContainer.contains(.timeSpan)
        {
            self.timeSpan = try decoderContainer.decode(Int?.self, forKey: .timeSpan)
        }
        if decoderContainer.contains(.timeUnit)
        {
            self.timeUnit = try decoderContainer.decode(Int?.self, forKey: .timeUnit)
        }
        self.returnUrl = try decoderContainer.decode(String.self, forKey: .returnUrl)
    }
}
public extension OrderSpec{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: OrderSpecCodingKeys.self)
         try encoderContainer.encode(buyType, forKey: .buyType)
         try encoderContainer.encode(id, forKey: .id)
         try encoderContainer.encode(name, forKey: .name)
         try encoderContainer.encode(pkgType, forKey: .pkgType)
         try encoderContainer.encode(ipNum, forKey: .ipNum)
         try encoderContainer.encode(bp, forKey: .bp)
         try encoderContainer.encode(ep, forKey: .ep)
         try encoderContainer.encode(timeSpan, forKey: .timeSpan)
         try encoderContainer.encode(timeUnit, forKey: .timeUnit)
         try encoderContainer.encode(returnUrl, forKey: .returnUrl)
    }
}
///  protectionRule
public class ProtectionRule:NSObject,Codable{
    /// 防护规则类型: 0: 默认防护包规则, 1: IP 自定义规则
    var type:Int?
    /// 清洗触发值 bps
    var cleanThresholdBps:Int64?
    /// 清洗触发值 pps
    var cleanThresholdPps:Int64?
    /// 虚假源开启
    var spoofIpEnable:Int?
    /// 源新建连接限速开启
    var srcNewConnLimitEnable:Int?
    /// 源新建连接速率
    var srcNewConnLimitValue:Int64?
    /// 目的新建连接开启
    var dstNewConnLimitEnable:Int?
    /// 目的新建连接速率
    var dstNewConnLimitValue:Int64?
    /// 报文最小长度
    var datagramRangeMin:Int64?
    /// 报文最大长度
    var datagramRangeMax:Int64?
    /// geo 拦截地域列表
    var geoBlackList:[GeoBlack?]?
    /// IP 黑名单列表
    var ipBlackList:[String?]?
    /// IP 白名单列表
    var ipWhiteList:[String?]?



    public override init(){
            super.init()
    }

    enum ProtectionRuleCodingKeys: String, CodingKey {
        case type
        case cleanThresholdBps
        case cleanThresholdPps
        case spoofIpEnable
        case srcNewConnLimitEnable
        case srcNewConnLimitValue
        case dstNewConnLimitEnable
        case dstNewConnLimitValue
        case datagramRangeMin
        case datagramRangeMax
        case geoBlackList
        case ipBlackList
        case ipWhiteList
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: ProtectionRuleCodingKeys.self)
        if decoderContainer.contains(.type)
        {
            self.type = try decoderContainer.decode(Int?.self, forKey: .type)
        }
        if decoderContainer.contains(.cleanThresholdBps)
        {
            self.cleanThresholdBps = try decoderContainer.decode(Int64?.self, forKey: .cleanThresholdBps)
        }
        if decoderContainer.contains(.cleanThresholdPps)
        {
            self.cleanThresholdPps = try decoderContainer.decode(Int64?.self, forKey: .cleanThresholdPps)
        }
        if decoderContainer.contains(.spoofIpEnable)
        {
            self.spoofIpEnable = try decoderContainer.decode(Int?.self, forKey: .spoofIpEnable)
        }
        if decoderContainer.contains(.srcNewConnLimitEnable)
        {
            self.srcNewConnLimitEnable = try decoderContainer.decode(Int?.self, forKey: .srcNewConnLimitEnable)
        }
        if decoderContainer.contains(.srcNewConnLimitValue)
        {
            self.srcNewConnLimitValue = try decoderContainer.decode(Int64?.self, forKey: .srcNewConnLimitValue)
        }
        if decoderContainer.contains(.dstNewConnLimitEnable)
        {
            self.dstNewConnLimitEnable = try decoderContainer.decode(Int?.self, forKey: .dstNewConnLimitEnable)
        }
        if decoderContainer.contains(.dstNewConnLimitValue)
        {
            self.dstNewConnLimitValue = try decoderContainer.decode(Int64?.self, forKey: .dstNewConnLimitValue)
        }
        if decoderContainer.contains(.datagramRangeMin)
        {
            self.datagramRangeMin = try decoderContainer.decode(Int64?.self, forKey: .datagramRangeMin)
        }
        if decoderContainer.contains(.datagramRangeMax)
        {
            self.datagramRangeMax = try decoderContainer.decode(Int64?.self, forKey: .datagramRangeMax)
        }
        if decoderContainer.contains(.geoBlackList)
        {
            self.geoBlackList = try decoderContainer.decode([GeoBlack?]?.self, forKey: .geoBlackList)
        }
        if decoderContainer.contains(.ipBlackList)
        {
            self.ipBlackList = try decoderContainer.decode([String?]?.self, forKey: .ipBlackList)
        }
        if decoderContainer.contains(.ipWhiteList)
        {
            self.ipWhiteList = try decoderContainer.decode([String?]?.self, forKey: .ipWhiteList)
        }
    }
}
public extension ProtectionRule{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: ProtectionRuleCodingKeys.self)
         try encoderContainer.encode(type, forKey: .type)
         try encoderContainer.encode(cleanThresholdBps, forKey: .cleanThresholdBps)
         try encoderContainer.encode(cleanThresholdPps, forKey: .cleanThresholdPps)
         try encoderContainer.encode(spoofIpEnable, forKey: .spoofIpEnable)
         try encoderContainer.encode(srcNewConnLimitEnable, forKey: .srcNewConnLimitEnable)
         try encoderContainer.encode(srcNewConnLimitValue, forKey: .srcNewConnLimitValue)
         try encoderContainer.encode(dstNewConnLimitEnable, forKey: .dstNewConnLimitEnable)
         try encoderContainer.encode(dstNewConnLimitValue, forKey: .dstNewConnLimitValue)
         try encoderContainer.encode(datagramRangeMin, forKey: .datagramRangeMin)
         try encoderContainer.encode(datagramRangeMax, forKey: .datagramRangeMax)
         try encoderContainer.encode(geoBlackList, forKey: .geoBlackList)
         try encoderContainer.encode(ipBlackList, forKey: .ipBlackList)
         try encoderContainer.encode(ipWhiteList, forKey: .ipWhiteList)
    }
}
///  extraOperationSpec
public class ExtraOperationSpec:NSObject,Codable{
    /// 操作类型 1: 购买成功后自动导入 ip, 需要传 ip
    /// Required:true
    var operationType:Int
    /// 支持弹性公网 ip 和云物理机公网 ip
    var ip:String?



    public  init(operationType:Int){
             self.operationType = operationType
    }

    enum ExtraOperationSpecCodingKeys: String, CodingKey {
        case operationType
        case ip
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: ExtraOperationSpecCodingKeys.self)
        self.operationType = try decoderContainer.decode(Int.self, forKey: .operationType)
        if decoderContainer.contains(.ip)
        {
            self.ip = try decoderContainer.decode(String?.self, forKey: .ip)
        }
    }
}
public extension ExtraOperationSpec{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: ExtraOperationSpecCodingKeys.self)
         try encoderContainer.encode(operationType, forKey: .operationType)
         try encoderContainer.encode(ip, forKey: .ip)
    }
}
///  operationRecord
public class OperationRecord:NSObject,Codable{
    /// 操作时间
    var time:String?
    /// 防护包名称
    var name:String?
    /// 操作类型:  1：套餐变更, 2：防护规则变更, 3：防护对象变更, 4：IP 地址变更, 5：防护包名称变更
    var action:Int?
    /// 操作详情
    var info:String?
    /// 操作人
    var operatorValue:String?



    public override init(){
            super.init()
    }

    enum OperationRecordCodingKeys: String, CodingKey {
        case time
        case name
        case action
        case info
        case operatorValue = "operator"
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: OperationRecordCodingKeys.self)
        if decoderContainer.contains(.time)
        {
            self.time = try decoderContainer.decode(String?.self, forKey: .time)
        }
        if decoderContainer.contains(.name)
        {
            self.name = try decoderContainer.decode(String?.self, forKey: .name)
        }
        if decoderContainer.contains(.action)
        {
            self.action = try decoderContainer.decode(Int?.self, forKey: .action)
        }
        if decoderContainer.contains(.info)
        {
            self.info = try decoderContainer.decode(String?.self, forKey: .info)
        }
        if decoderContainer.contains(.operatorValue)
        {
            self.operatorValue = try decoderContainer.decode(String?.self, forKey: .operatorValue)
        }
    }
}
public extension OperationRecord{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: OperationRecordCodingKeys.self)
         try encoderContainer.encode(time, forKey: .time)
         try encoderContainer.encode(name, forKey: .name)
         try encoderContainer.encode(action, forKey: .action)
         try encoderContainer.encode(info, forKey: .info)
         try encoderContainer.encode(operatorValue, forKey: .operatorValue)
    }
}
///  priceSpec
public class PriceSpec:NSObject,Codable{
    /// 操作类型 1: 新购防护包, 3: 升级防护包
    /// Required:true
    var buyType:Int
    /// 防护包实例 Id, 升级防护包查询价格时必传
    var id:Int64?
    /// 计费类型 1: 按配置 2: 按用量 3: 包年包月
    /// Required:true
    var billingType:Int
    /// 套餐类型, 1: 独享 IP, 2: 共享 IP
    /// Required:true
    var pkgType:Int
    /// 可防护 IP 数量, 5, 10, 50, 100, 1000(不限)
    /// Required:true
    var ipNum:Int
    /// 保底带宽: 0, 10, 20, 30, 50, 单位: Gbps
    /// Required:true
    var bp:Int
    /// 弹性带宽: 0, 10, 20, 单位: Gbps
    /// Required:true
    var ep:Int
    /// 购买防护包时长, 新购防护包时必传
      /// - timeUnit 为 3 时, 可取值 1-9
      /// - timeUnit 为 4 时, 可取值 1-3
      /// 
    var timeSpan:Int?
    /// 购买时长类型, 新购防护包时必传
      /// - 3: 月
      /// - 4: 年
    var timeUnit:Int?



    public  init(buyType:Int,billingType:Int,pkgType:Int,ipNum:Int,bp:Int,ep:Int){
             self.buyType = buyType
             self.billingType = billingType
             self.pkgType = pkgType
             self.ipNum = ipNum
             self.bp = bp
             self.ep = ep
    }

    enum PriceSpecCodingKeys: String, CodingKey {
        case buyType
        case id
        case billingType
        case pkgType
        case ipNum
        case bp
        case ep
        case timeSpan
        case timeUnit
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: PriceSpecCodingKeys.self)
        self.buyType = try decoderContainer.decode(Int.self, forKey: .buyType)
        if decoderContainer.contains(.id)
        {
            self.id = try decoderContainer.decode(Int64?.self, forKey: .id)
        }
        self.billingType = try decoderContainer.decode(Int.self, forKey: .billingType)
        self.pkgType = try decoderContainer.decode(Int.self, forKey: .pkgType)
        self.ipNum = try decoderContainer.decode(Int.self, forKey: .ipNum)
        self.bp = try decoderContainer.decode(Int.self, forKey: .bp)
        self.ep = try decoderContainer.decode(Int.self, forKey: .ep)
        if decoderContainer.contains(.timeSpan)
        {
            self.timeSpan = try decoderContainer.decode(Int?.self, forKey: .timeSpan)
        }
        if decoderContainer.contains(.timeUnit)
        {
            self.timeUnit = try decoderContainer.decode(Int?.self, forKey: .timeUnit)
        }
    }
}
public extension PriceSpec{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: PriceSpecCodingKeys.self)
         try encoderContainer.encode(buyType, forKey: .buyType)
         try encoderContainer.encode(id, forKey: .id)
         try encoderContainer.encode(billingType, forKey: .billingType)
         try encoderContainer.encode(pkgType, forKey: .pkgType)
         try encoderContainer.encode(ipNum, forKey: .ipNum)
         try encoderContainer.encode(bp, forKey: .bp)
         try encoderContainer.encode(ep, forKey: .ep)
         try encoderContainer.encode(timeSpan, forKey: .timeSpan)
         try encoderContainer.encode(timeUnit, forKey: .timeUnit)
    }
}

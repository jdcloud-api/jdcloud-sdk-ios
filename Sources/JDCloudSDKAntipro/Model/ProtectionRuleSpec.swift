/* Copyright 2018 JDCLOUD.COM

   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at

     http:#www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.

   
   

   
   Contact: 

   NOTE: This class is auto generated by the jdcloud code generator program.
 */


import Foundation

///  protectionRuleSpec
@objc(ProtectionRuleSpec)
public class ProtectionRuleSpec:NSObject,Codable{
    /// 被防护 IP, 缺省时修改防护包实例防护规则
    var ip:String?
    /// 防护规则类型, 修改 ip 防护规则时必传, 0: 设置 ip 使用防护包规则, 1: 设置 IP 使用自定义规则
    var type:Int?
    /// 清洗触发值 bps, 修改实例防护规则或自定义 IP 防护规则时必传
    var cleanThresholdBps:Int64?
    /// 清洗触发值 pps, 修改实例防护规则或自定义 IP 防护规则时必传
    var cleanThresholdPps:Int64?
    /// 虚假源, 0: 关闭, 1: 开启, 修改实例防护规则或自定义 IP 防护规则时必传
    var spoofIpEnable:Int?
    /// 源新建连接限速, 0: 关闭, 1: 开启, 修改实例防护规则或自定义 IP 防护规则时必传
    var srcNewConnLimitEnable:Int?
    /// 源新建连接速率, 修改实例防护规则或自定义 IP 防护规则时必传
    var srcNewConnLimitValue:Int64?
    /// 目的新建连接, 0: 关闭, 1: 开启, 修改实例防护规则或自定义 IP 防护规则时必传
    var dstNewConnLimitEnable:Int?
    /// 目的新建连接速率, 修改实例防护规则或自定义 IP 防护规则时必传
    var dstNewConnLimitValue:Int64?
    /// 报文最小长度, 取值范围 [1, datagramRangeMax)
    var datagramRangeMin:Int64?
    /// 报文最大长度, 取值范围 (datagramRangeMin, 1518]
    var datagramRangeMax:Int64?
    /// geo 拦截地域编码列表. 查询 &lt;a href&#x3D;&quot;http://docs.jdcloud.com/anti-ddos-protection-package/api/describegeoareas&quot;&gt;describeGeoAreas&lt;/a&gt; 接口获取可设置的地域编码列表
    var geoBlackList:[String?]?



    public override init(){
            super.init()
    }

    enum ProtectionRuleSpecCodingKeys: String, CodingKey {
        case ip
        case type
        case cleanThresholdBps
        case cleanThresholdPps
        case spoofIpEnable
        case srcNewConnLimitEnable
        case srcNewConnLimitValue
        case dstNewConnLimitEnable
        case dstNewConnLimitValue
        case datagramRangeMin
        case datagramRangeMax
        case geoBlackList
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: ProtectionRuleSpecCodingKeys.self)
        if decoderContainer.contains(.ip)
        {
            self.ip = try decoderContainer.decode(String?.self, forKey: .ip)
        }
        if decoderContainer.contains(.type)
        {
            self.type = try decoderContainer.decode(Int?.self, forKey: .type)
        }
        if decoderContainer.contains(.cleanThresholdBps)
        {
            self.cleanThresholdBps = try decoderContainer.decode(Int64?.self, forKey: .cleanThresholdBps)
        }
        if decoderContainer.contains(.cleanThresholdPps)
        {
            self.cleanThresholdPps = try decoderContainer.decode(Int64?.self, forKey: .cleanThresholdPps)
        }
        if decoderContainer.contains(.spoofIpEnable)
        {
            self.spoofIpEnable = try decoderContainer.decode(Int?.self, forKey: .spoofIpEnable)
        }
        if decoderContainer.contains(.srcNewConnLimitEnable)
        {
            self.srcNewConnLimitEnable = try decoderContainer.decode(Int?.self, forKey: .srcNewConnLimitEnable)
        }
        if decoderContainer.contains(.srcNewConnLimitValue)
        {
            self.srcNewConnLimitValue = try decoderContainer.decode(Int64?.self, forKey: .srcNewConnLimitValue)
        }
        if decoderContainer.contains(.dstNewConnLimitEnable)
        {
            self.dstNewConnLimitEnable = try decoderContainer.decode(Int?.self, forKey: .dstNewConnLimitEnable)
        }
        if decoderContainer.contains(.dstNewConnLimitValue)
        {
            self.dstNewConnLimitValue = try decoderContainer.decode(Int64?.self, forKey: .dstNewConnLimitValue)
        }
        if decoderContainer.contains(.datagramRangeMin)
        {
            self.datagramRangeMin = try decoderContainer.decode(Int64?.self, forKey: .datagramRangeMin)
        }
        if decoderContainer.contains(.datagramRangeMax)
        {
            self.datagramRangeMax = try decoderContainer.decode(Int64?.self, forKey: .datagramRangeMax)
        }
        if decoderContainer.contains(.geoBlackList)
        {
            self.geoBlackList = try decoderContainer.decode([String?]?.self, forKey: .geoBlackList)
        }
    }
}
public extension ProtectionRuleSpec{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: ProtectionRuleSpecCodingKeys.self)
         try encoderContainer.encode(ip, forKey: .ip)
         try encoderContainer.encode(type, forKey: .type)
         try encoderContainer.encode(cleanThresholdBps, forKey: .cleanThresholdBps)
         try encoderContainer.encode(cleanThresholdPps, forKey: .cleanThresholdPps)
         try encoderContainer.encode(spoofIpEnable, forKey: .spoofIpEnable)
         try encoderContainer.encode(srcNewConnLimitEnable, forKey: .srcNewConnLimitEnable)
         try encoderContainer.encode(srcNewConnLimitValue, forKey: .srcNewConnLimitValue)
         try encoderContainer.encode(dstNewConnLimitEnable, forKey: .dstNewConnLimitEnable)
         try encoderContainer.encode(dstNewConnLimitValue, forKey: .dstNewConnLimitValue)
         try encoderContainer.encode(datagramRangeMin, forKey: .datagramRangeMin)
         try encoderContainer.encode(datagramRangeMax, forKey: .datagramRangeMax)
         try encoderContainer.encode(geoBlackList, forKey: .geoBlackList)
    }
}

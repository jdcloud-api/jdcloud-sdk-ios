/* Copyright 2018 JDCLOUD.COM

   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at

     http:#www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.

   操作列表
   云解析OpenAPI操作列表接口

   OpenAPI spec version: v1
   Contact: 

   NOTE: This class is auto generated by the jdcloud code generator program.
 */


import Foundation
///  domain
public class Domain:NSObject,Codable{
    /// 域名在云解析里唯一的ID
    var id:Int?
    /// 域名字符串
    var domainName:String?
    /// 域名的创建时间，Unix timestamp格式，时间单位：毫秒
    var createTime:Int64?
    /// 域名的过期时间，Unix timestamp格式，时间单位：毫秒
    var expirationDate:Int64?
    /// 域名的套餐类型，0-&gt;免费 1-&gt;企业版 2-&gt;企业高级版  
      /// 不同套餐的描述，请查阅&lt;a href&#x3D;&quot;https://docs.jdcloud.com/cn/jd-cloud-dns/price-overview&quot;&gt;文档&lt;/a&gt;
      /// 
    var packId:Int?
    /// 域名的锁定状态，0:未锁定， 1:已锁定
      /// 锁定的含义，请查阅&lt;a href&#x3D;&quot;https://docs.jdcloud.com/cn/jd-cloud-dns/lock-domain&quot;&gt;文档&lt;/a&gt;
      /// 
    var lockStatus:Int?



    public override init(){
            super.init()
    }

    enum DomainCodingKeys: String, CodingKey {
        case id
        case domainName
        case createTime
        case expirationDate
        case packId
        case lockStatus
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: DomainCodingKeys.self)
        if decoderContainer.contains(.id)
        {
            self.id = try decoderContainer.decode(Int?.self, forKey: .id)
        }
        if decoderContainer.contains(.domainName)
        {
            self.domainName = try decoderContainer.decode(String?.self, forKey: .domainName)
        }
        if decoderContainer.contains(.createTime)
        {
            self.createTime = try decoderContainer.decode(Int64?.self, forKey: .createTime)
        }
        if decoderContainer.contains(.expirationDate)
        {
            self.expirationDate = try decoderContainer.decode(Int64?.self, forKey: .expirationDate)
        }
        if decoderContainer.contains(.packId)
        {
            self.packId = try decoderContainer.decode(Int?.self, forKey: .packId)
        }
        if decoderContainer.contains(.lockStatus)
        {
            self.lockStatus = try decoderContainer.decode(Int?.self, forKey: .lockStatus)
        }
    }
}
public extension Domain{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: DomainCodingKeys.self)
         try encoderContainer.encode(id, forKey: .id)
         try encoderContainer.encode(domainName, forKey: .domainName)
         try encoderContainer.encode(createTime, forKey: .createTime)
         try encoderContainer.encode(expirationDate, forKey: .expirationDate)
         try encoderContainer.encode(packId, forKey: .packId)
         try encoderContainer.encode(lockStatus, forKey: .lockStatus)
    }
}
///  notice
public class Notice:NSObject,Codable{
    /// 信息ID
    var id:Int?
    /// 信息的标题
    var title:String?
    /// 信息的详细URL
    var url:String?



    public override init(){
            super.init()
    }

    enum NoticeCodingKeys: String, CodingKey {
        case id
        case title
        case url
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: NoticeCodingKeys.self)
        if decoderContainer.contains(.id)
        {
            self.id = try decoderContainer.decode(Int?.self, forKey: .id)
        }
        if decoderContainer.contains(.title)
        {
            self.title = try decoderContainer.decode(String?.self, forKey: .title)
        }
        if decoderContainer.contains(.url)
        {
            self.url = try decoderContainer.decode(String?.self, forKey: .url)
        }
    }
}
public extension Notice{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: NoticeCodingKeys.self)
         try encoderContainer.encode(id, forKey: .id)
         try encoderContainer.encode(title, forKey: .title)
         try encoderContainer.encode(url, forKey: .url)
    }
}
///  domainAdded
public class DomainAdded:NSObject,Codable{
    /// 域名的唯一ID
    var id:Int?
    /// 域名字符串
    var domainName:String?
    /// 创建时间，格式Unix timestamp，时间单位：毫秒
    var createTime:Int64?
    /// 过期时间，格式Unix timestamp，时间单位：毫秒
    var expirationDate:Int64?
    /// 套餐类型，0-&gt;免费 1-&gt;企业版 2-&gt;企业高级版
    var packId:Int?



    public override init(){
            super.init()
    }

    enum DomainAddedCodingKeys: String, CodingKey {
        case id
        case domainName
        case createTime
        case expirationDate
        case packId
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: DomainAddedCodingKeys.self)
        if decoderContainer.contains(.id)
        {
            self.id = try decoderContainer.decode(Int?.self, forKey: .id)
        }
        if decoderContainer.contains(.domainName)
        {
            self.domainName = try decoderContainer.decode(String?.self, forKey: .domainName)
        }
        if decoderContainer.contains(.createTime)
        {
            self.createTime = try decoderContainer.decode(Int64?.self, forKey: .createTime)
        }
        if decoderContainer.contains(.expirationDate)
        {
            self.expirationDate = try decoderContainer.decode(Int64?.self, forKey: .expirationDate)
        }
        if decoderContainer.contains(.packId)
        {
            self.packId = try decoderContainer.decode(Int?.self, forKey: .packId)
        }
    }
}
public extension DomainAdded{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: DomainAddedCodingKeys.self)
         try encoderContainer.encode(id, forKey: .id)
         try encoderContainer.encode(domainName, forKey: .domainName)
         try encoderContainer.encode(createTime, forKey: .createTime)
         try encoderContainer.encode(expirationDate, forKey: .expirationDate)
         try encoderContainer.encode(packId, forKey: .packId)
    }
}
///  domainInfo
public class DomainInfo:NSObject,Codable{
    /// 域名的唯一ID
    var id:Int?
    /// 域名字符串
    var domainName:String?
    /// 创建时间，格式Unix timestamp，时间单位：毫秒
    var createTime:Int64?
    /// 过期时间，格式Unix timestamp，时间单位：毫秒
    var expirationDate:Int64?
    /// 套餐类型，0-&gt;免费 1-&gt;企业版 2-&gt;企业高级版
    var packId:Int?
    /// 套餐的名字
    var packName:String?
    /// 解析的状态
    var resolvingStatus:String?
    /// 创建者
    var creator:String?
    /// 是否是京东云资源
    var jcloudNs:Bool?
    /// 域名的锁定状态，0:未锁定， 1:已锁定
    var lockStatus:Int?



    public override init(){
            super.init()
    }

    enum DomainInfoCodingKeys: String, CodingKey {
        case id
        case domainName
        case createTime
        case expirationDate
        case packId
        case packName
        case resolvingStatus
        case creator
        case jcloudNs
        case lockStatus
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: DomainInfoCodingKeys.self)
        if decoderContainer.contains(.id)
        {
            self.id = try decoderContainer.decode(Int?.self, forKey: .id)
        }
        if decoderContainer.contains(.domainName)
        {
            self.domainName = try decoderContainer.decode(String?.self, forKey: .domainName)
        }
        if decoderContainer.contains(.createTime)
        {
            self.createTime = try decoderContainer.decode(Int64?.self, forKey: .createTime)
        }
        if decoderContainer.contains(.expirationDate)
        {
            self.expirationDate = try decoderContainer.decode(Int64?.self, forKey: .expirationDate)
        }
        if decoderContainer.contains(.packId)
        {
            self.packId = try decoderContainer.decode(Int?.self, forKey: .packId)
        }
        if decoderContainer.contains(.packName)
        {
            self.packName = try decoderContainer.decode(String?.self, forKey: .packName)
        }
        if decoderContainer.contains(.resolvingStatus)
        {
            self.resolvingStatus = try decoderContainer.decode(String?.self, forKey: .resolvingStatus)
        }
        if decoderContainer.contains(.creator)
        {
            self.creator = try decoderContainer.decode(String?.self, forKey: .creator)
        }
        if decoderContainer.contains(.jcloudNs)
        {
            self.jcloudNs = try decoderContainer.decode(Bool?.self, forKey: .jcloudNs)
        }
        if decoderContainer.contains(.lockStatus)
        {
            self.lockStatus = try decoderContainer.decode(Int?.self, forKey: .lockStatus)
        }
    }
}
public extension DomainInfo{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: DomainInfoCodingKeys.self)
         try encoderContainer.encode(id, forKey: .id)
         try encoderContainer.encode(domainName, forKey: .domainName)
         try encoderContainer.encode(createTime, forKey: .createTime)
         try encoderContainer.encode(expirationDate, forKey: .expirationDate)
         try encoderContainer.encode(packId, forKey: .packId)
         try encoderContainer.encode(packName, forKey: .packName)
         try encoderContainer.encode(resolvingStatus, forKey: .resolvingStatus)
         try encoderContainer.encode(creator, forKey: .creator)
         try encoderContainer.encode(jcloudNs, forKey: .jcloudNs)
         try encoderContainer.encode(lockStatus, forKey: .lockStatus)
    }
}
///  monitorAlarmInfo
public class MonitorAlarmInfo:NSObject,Codable{
    /// 域名ID
    var domainId:Int?
    /// 子域名
    var subDomainName:String?
    /// 故障IP/域名
    var host:String?
    /// null
    var id:Int?
    /// 故障开始时间，格式Unix timestamp，时间单位：毫秒
    var startTime:Int64?
    /// 故障结束时间，格式Unix timestamp，时间单位：毫秒
    var endTime:Int64?



    public override init(){
            super.init()
    }

    enum MonitorAlarmInfoCodingKeys: String, CodingKey {
        case domainId
        case subDomainName
        case host
        case id
        case startTime
        case endTime
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: MonitorAlarmInfoCodingKeys.self)
        if decoderContainer.contains(.domainId)
        {
            self.domainId = try decoderContainer.decode(Int?.self, forKey: .domainId)
        }
        if decoderContainer.contains(.subDomainName)
        {
            self.subDomainName = try decoderContainer.decode(String?.self, forKey: .subDomainName)
        }
        if decoderContainer.contains(.host)
        {
            self.host = try decoderContainer.decode(String?.self, forKey: .host)
        }
        if decoderContainer.contains(.id)
        {
            self.id = try decoderContainer.decode(Int?.self, forKey: .id)
        }
        if decoderContainer.contains(.startTime)
        {
            self.startTime = try decoderContainer.decode(Int64?.self, forKey: .startTime)
        }
        if decoderContainer.contains(.endTime)
        {
            self.endTime = try decoderContainer.decode(Int64?.self, forKey: .endTime)
        }
    }
}
public extension MonitorAlarmInfo{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: MonitorAlarmInfoCodingKeys.self)
         try encoderContainer.encode(domainId, forKey: .domainId)
         try encoderContainer.encode(subDomainName, forKey: .subDomainName)
         try encoderContainer.encode(host, forKey: .host)
         try encoderContainer.encode(id, forKey: .id)
         try encoderContainer.encode(startTime, forKey: .startTime)
         try encoderContainer.encode(endTime, forKey: .endTime)
    }
}
///  monitor
public class Monitor:NSObject,Codable{
    /// 连续几次触发报警
    var alarmLimit:Int?
    /// 现在是否可以恢复
    var canRecover:Bool?
    /// 现在是否可以切换
    var canSwitch:Bool?
    /// 机房探测点的集合
    var clusters:String?
    /// 主域名
    var domainName:String?
    /// 主机状态，0正常，1异常
    var hostStatus:Int?
    /// 监控对象
    var hostValue:String?
    /// 监控项ID
    var id:Int?
    /// 备用地址1
    var ipBackup01:String?
    /// 备用地址1的状态，0正常，1异常
    var ipBackup01Status:Int?
    /// 备用地址1的类型，1为ip 2为域名
    var ipBackup01Type:Int?
    /// 备用地址2
    var ipBackup02:String?
    /// 备用地址2的状态，0正常，1异常
    var ipBackup02Status:Int?
    /// 备用地址1的类型，1为ip 2为域名
    var ipBackup02Type:Int?
    /// 手动切换的地址
    var manualBackup:String?
    /// 手动切换的地址的状态，0正常，1异常
    var manualBackupStatus:Int?
    /// 手动切换的地址的类型，1为ip 2为域名
    var manualBackupType:Int?
    /// 监控状况 开启监控 2，暂停监控 4
    var monitorEnable:Int?
    /// 监控频率，单位秒
    var monitorFreq:Int?
    /// 监控端口
    var monitorPort:Int?
    /// 不做任何修改0，强制暂停解析记录1，自动切换到备用地址2
    var monitorRule:Int?
    /// 监控路径
    var monitorUri:String?
    /// 邮箱地址
    var notifyEmail:String?
    /// 不发送邮件0， 发送邮件1
    var notifyEmailEnable:Int?
    /// 不发送通知栏 0， 发送通知栏 1
    var notifyMsgBarEnable:Int?
    /// 手机号码
    var notifySms:String?
    /// 不发送短信 0， 发送短信 1
    var notifySmsEnable:Int?
    /// https 0，https 1
    var protocolValue:Int?
    /// 0自动恢复 1手动恢复
    var stopRecoverRule:Int?
    /// 子域名
    var subDomainName:String?
    /// 0自动恢复至主host 1手动恢复至主host
    var switchRecoverRule:Int?
    /// 1为A记录，2为CNAME
    var type:Int?
    /// 使用记录，host_value 0，ip_backup_01 1，ip_backup_02 2，cname_backup 3
    var usedType:Int?



    public override init(){
            super.init()
    }

    enum MonitorCodingKeys: String, CodingKey {
        case alarmLimit
        case canRecover
        case canSwitch
        case clusters
        case domainName
        case hostStatus
        case hostValue
        case id
        case ipBackup01
        case ipBackup01Status
        case ipBackup01Type
        case ipBackup02
        case ipBackup02Status
        case ipBackup02Type
        case manualBackup
        case manualBackupStatus
        case manualBackupType
        case monitorEnable
        case monitorFreq
        case monitorPort
        case monitorRule
        case monitorUri
        case notifyEmail
        case notifyEmailEnable
        case notifyMsgBarEnable
        case notifySms
        case notifySmsEnable
        case protocolValue = "protocol"
        case stopRecoverRule
        case subDomainName
        case switchRecoverRule
        case type
        case usedType
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: MonitorCodingKeys.self)
        if decoderContainer.contains(.alarmLimit)
        {
            self.alarmLimit = try decoderContainer.decode(Int?.self, forKey: .alarmLimit)
        }
        if decoderContainer.contains(.canRecover)
        {
            self.canRecover = try decoderContainer.decode(Bool?.self, forKey: .canRecover)
        }
        if decoderContainer.contains(.canSwitch)
        {
            self.canSwitch = try decoderContainer.decode(Bool?.self, forKey: .canSwitch)
        }
        if decoderContainer.contains(.clusters)
        {
            self.clusters = try decoderContainer.decode(String?.self, forKey: .clusters)
        }
        if decoderContainer.contains(.domainName)
        {
            self.domainName = try decoderContainer.decode(String?.self, forKey: .domainName)
        }
        if decoderContainer.contains(.hostStatus)
        {
            self.hostStatus = try decoderContainer.decode(Int?.self, forKey: .hostStatus)
        }
        if decoderContainer.contains(.hostValue)
        {
            self.hostValue = try decoderContainer.decode(String?.self, forKey: .hostValue)
        }
        if decoderContainer.contains(.id)
        {
            self.id = try decoderContainer.decode(Int?.self, forKey: .id)
        }
        if decoderContainer.contains(.ipBackup01)
        {
            self.ipBackup01 = try decoderContainer.decode(String?.self, forKey: .ipBackup01)
        }
        if decoderContainer.contains(.ipBackup01Status)
        {
            self.ipBackup01Status = try decoderContainer.decode(Int?.self, forKey: .ipBackup01Status)
        }
        if decoderContainer.contains(.ipBackup01Type)
        {
            self.ipBackup01Type = try decoderContainer.decode(Int?.self, forKey: .ipBackup01Type)
        }
        if decoderContainer.contains(.ipBackup02)
        {
            self.ipBackup02 = try decoderContainer.decode(String?.self, forKey: .ipBackup02)
        }
        if decoderContainer.contains(.ipBackup02Status)
        {
            self.ipBackup02Status = try decoderContainer.decode(Int?.self, forKey: .ipBackup02Status)
        }
        if decoderContainer.contains(.ipBackup02Type)
        {
            self.ipBackup02Type = try decoderContainer.decode(Int?.self, forKey: .ipBackup02Type)
        }
        if decoderContainer.contains(.manualBackup)
        {
            self.manualBackup = try decoderContainer.decode(String?.self, forKey: .manualBackup)
        }
        if decoderContainer.contains(.manualBackupStatus)
        {
            self.manualBackupStatus = try decoderContainer.decode(Int?.self, forKey: .manualBackupStatus)
        }
        if decoderContainer.contains(.manualBackupType)
        {
            self.manualBackupType = try decoderContainer.decode(Int?.self, forKey: .manualBackupType)
        }
        if decoderContainer.contains(.monitorEnable)
        {
            self.monitorEnable = try decoderContainer.decode(Int?.self, forKey: .monitorEnable)
        }
        if decoderContainer.contains(.monitorFreq)
        {
            self.monitorFreq = try decoderContainer.decode(Int?.self, forKey: .monitorFreq)
        }
        if decoderContainer.contains(.monitorPort)
        {
            self.monitorPort = try decoderContainer.decode(Int?.self, forKey: .monitorPort)
        }
        if decoderContainer.contains(.monitorRule)
        {
            self.monitorRule = try decoderContainer.decode(Int?.self, forKey: .monitorRule)
        }
        if decoderContainer.contains(.monitorUri)
        {
            self.monitorUri = try decoderContainer.decode(String?.self, forKey: .monitorUri)
        }
        if decoderContainer.contains(.notifyEmail)
        {
            self.notifyEmail = try decoderContainer.decode(String?.self, forKey: .notifyEmail)
        }
        if decoderContainer.contains(.notifyEmailEnable)
        {
            self.notifyEmailEnable = try decoderContainer.decode(Int?.self, forKey: .notifyEmailEnable)
        }
        if decoderContainer.contains(.notifyMsgBarEnable)
        {
            self.notifyMsgBarEnable = try decoderContainer.decode(Int?.self, forKey: .notifyMsgBarEnable)
        }
        if decoderContainer.contains(.notifySms)
        {
            self.notifySms = try decoderContainer.decode(String?.self, forKey: .notifySms)
        }
        if decoderContainer.contains(.notifySmsEnable)
        {
            self.notifySmsEnable = try decoderContainer.decode(Int?.self, forKey: .notifySmsEnable)
        }
        if decoderContainer.contains(.protocolValue)
        {
            self.protocolValue = try decoderContainer.decode(Int?.self, forKey: .protocolValue)
        }
        if decoderContainer.contains(.stopRecoverRule)
        {
            self.stopRecoverRule = try decoderContainer.decode(Int?.self, forKey: .stopRecoverRule)
        }
        if decoderContainer.contains(.subDomainName)
        {
            self.subDomainName = try decoderContainer.decode(String?.self, forKey: .subDomainName)
        }
        if decoderContainer.contains(.switchRecoverRule)
        {
            self.switchRecoverRule = try decoderContainer.decode(Int?.self, forKey: .switchRecoverRule)
        }
        if decoderContainer.contains(.type)
        {
            self.type = try decoderContainer.decode(Int?.self, forKey: .type)
        }
        if decoderContainer.contains(.usedType)
        {
            self.usedType = try decoderContainer.decode(Int?.self, forKey: .usedType)
        }
    }
}
public extension Monitor{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: MonitorCodingKeys.self)
         try encoderContainer.encode(alarmLimit, forKey: .alarmLimit)
         try encoderContainer.encode(canRecover, forKey: .canRecover)
         try encoderContainer.encode(canSwitch, forKey: .canSwitch)
         try encoderContainer.encode(clusters, forKey: .clusters)
         try encoderContainer.encode(domainName, forKey: .domainName)
         try encoderContainer.encode(hostStatus, forKey: .hostStatus)
         try encoderContainer.encode(hostValue, forKey: .hostValue)
         try encoderContainer.encode(id, forKey: .id)
         try encoderContainer.encode(ipBackup01, forKey: .ipBackup01)
         try encoderContainer.encode(ipBackup01Status, forKey: .ipBackup01Status)
         try encoderContainer.encode(ipBackup01Type, forKey: .ipBackup01Type)
         try encoderContainer.encode(ipBackup02, forKey: .ipBackup02)
         try encoderContainer.encode(ipBackup02Status, forKey: .ipBackup02Status)
         try encoderContainer.encode(ipBackup02Type, forKey: .ipBackup02Type)
         try encoderContainer.encode(manualBackup, forKey: .manualBackup)
         try encoderContainer.encode(manualBackupStatus, forKey: .manualBackupStatus)
         try encoderContainer.encode(manualBackupType, forKey: .manualBackupType)
         try encoderContainer.encode(monitorEnable, forKey: .monitorEnable)
         try encoderContainer.encode(monitorFreq, forKey: .monitorFreq)
         try encoderContainer.encode(monitorPort, forKey: .monitorPort)
         try encoderContainer.encode(monitorRule, forKey: .monitorRule)
         try encoderContainer.encode(monitorUri, forKey: .monitorUri)
         try encoderContainer.encode(notifyEmail, forKey: .notifyEmail)
         try encoderContainer.encode(notifyEmailEnable, forKey: .notifyEmailEnable)
         try encoderContainer.encode(notifyMsgBarEnable, forKey: .notifyMsgBarEnable)
         try encoderContainer.encode(notifySms, forKey: .notifySms)
         try encoderContainer.encode(notifySmsEnable, forKey: .notifySmsEnable)
         try encoderContainer.encode(protocolValue, forKey: .protocolValue)
         try encoderContainer.encode(stopRecoverRule, forKey: .stopRecoverRule)
         try encoderContainer.encode(subDomainName, forKey: .subDomainName)
         try encoderContainer.encode(switchRecoverRule, forKey: .switchRecoverRule)
         try encoderContainer.encode(type, forKey: .type)
         try encoderContainer.encode(usedType, forKey: .usedType)
    }
}
///  updateMonitor
public class UpdateMonitor:NSObject,Codable{
    /// 连续几次触发报警
    /// Required:true
    var alarmLimit:Int
    /// 监控项ID
    /// Required:true
    var id:Int
    /// 备用地址1
    /// Required:true
    var ipBackup01:String
    /// 备用地址2
    /// Required:true
    var ipBackup02:String
    /// 监控状况 开启监控 2，暂停监控 4
    /// Required:true
    var monitorEnable:Int
    /// 监控频率，单位秒
    /// Required:true
    var monitorFreq:Int
    /// 监控端口
    /// Required:true
    var monitorPort:Int
    /// 不做任何修改0，强制暂停解析记录1，自动切换到备用地址2
    /// Required:true
    var monitorRule:Int
    /// 监控路径
    /// Required:true
    var monitorUri:String
    /// 不发送邮件0， 发送邮件1
    /// Required:true
    var notifyEmailEnable:Int
    /// 不发送通知栏 0， 发送通知栏 1
    /// Required:true
    var notifyMsgBarEnable:Int
    /// 不发送短信 0， 发送短信 1
    var notifySmsEnable:Int?
    /// https 0，https 1
    /// Required:true
    var protocolValue:Int
    /// 0自动恢复 1手动恢复
    /// Required:true
    var stopRecoverRule:Int
    /// 0自动恢复至主host 1手动恢复至主host
    /// Required:true
    var switchRecoverRule:Int



    public  init(alarmLimit:Int,id:Int,ipBackup01:String,ipBackup02:String,monitorEnable:Int,monitorFreq:Int,monitorPort:Int,monitorRule:Int,monitorUri:String,notifyEmailEnable:Int,notifyMsgBarEnable:Int,protocolValue:Int,stopRecoverRule:Int,switchRecoverRule:Int){
             self.alarmLimit = alarmLimit
             self.id = id
             self.ipBackup01 = ipBackup01
             self.ipBackup02 = ipBackup02
             self.monitorEnable = monitorEnable
             self.monitorFreq = monitorFreq
             self.monitorPort = monitorPort
             self.monitorRule = monitorRule
             self.monitorUri = monitorUri
             self.notifyEmailEnable = notifyEmailEnable
             self.notifyMsgBarEnable = notifyMsgBarEnable
             self.protocolValue = protocolValue
             self.stopRecoverRule = stopRecoverRule
             self.switchRecoverRule = switchRecoverRule
    }

    enum UpdateMonitorCodingKeys: String, CodingKey {
        case alarmLimit
        case id
        case ipBackup01
        case ipBackup02
        case monitorEnable
        case monitorFreq
        case monitorPort
        case monitorRule
        case monitorUri
        case notifyEmailEnable
        case notifyMsgBarEnable
        case notifySmsEnable
        case protocolValue = "protocol"
        case stopRecoverRule
        case switchRecoverRule
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: UpdateMonitorCodingKeys.self)
        self.alarmLimit = try decoderContainer.decode(Int.self, forKey: .alarmLimit)
        self.id = try decoderContainer.decode(Int.self, forKey: .id)
        self.ipBackup01 = try decoderContainer.decode(String.self, forKey: .ipBackup01)
        self.ipBackup02 = try decoderContainer.decode(String.self, forKey: .ipBackup02)
        self.monitorEnable = try decoderContainer.decode(Int.self, forKey: .monitorEnable)
        self.monitorFreq = try decoderContainer.decode(Int.self, forKey: .monitorFreq)
        self.monitorPort = try decoderContainer.decode(Int.self, forKey: .monitorPort)
        self.monitorRule = try decoderContainer.decode(Int.self, forKey: .monitorRule)
        self.monitorUri = try decoderContainer.decode(String.self, forKey: .monitorUri)
        self.notifyEmailEnable = try decoderContainer.decode(Int.self, forKey: .notifyEmailEnable)
        self.notifyMsgBarEnable = try decoderContainer.decode(Int.self, forKey: .notifyMsgBarEnable)
        if decoderContainer.contains(.notifySmsEnable)
        {
            self.notifySmsEnable = try decoderContainer.decode(Int?.self, forKey: .notifySmsEnable)
        }
        self.protocolValue = try decoderContainer.decode(Int.self, forKey: .protocolValue)
        self.stopRecoverRule = try decoderContainer.decode(Int.self, forKey: .stopRecoverRule)
        self.switchRecoverRule = try decoderContainer.decode(Int.self, forKey: .switchRecoverRule)
    }
}
public extension UpdateMonitor{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: UpdateMonitorCodingKeys.self)
         try encoderContainer.encode(alarmLimit, forKey: .alarmLimit)
         try encoderContainer.encode(id, forKey: .id)
         try encoderContainer.encode(ipBackup01, forKey: .ipBackup01)
         try encoderContainer.encode(ipBackup02, forKey: .ipBackup02)
         try encoderContainer.encode(monitorEnable, forKey: .monitorEnable)
         try encoderContainer.encode(monitorFreq, forKey: .monitorFreq)
         try encoderContainer.encode(monitorPort, forKey: .monitorPort)
         try encoderContainer.encode(monitorRule, forKey: .monitorRule)
         try encoderContainer.encode(monitorUri, forKey: .monitorUri)
         try encoderContainer.encode(notifyEmailEnable, forKey: .notifyEmailEnable)
         try encoderContainer.encode(notifyMsgBarEnable, forKey: .notifyMsgBarEnable)
         try encoderContainer.encode(notifySmsEnable, forKey: .notifySmsEnable)
         try encoderContainer.encode(protocolValue, forKey: .protocolValue)
         try encoderContainer.encode(stopRecoverRule, forKey: .stopRecoverRule)
         try encoderContainer.encode(switchRecoverRule, forKey: .switchRecoverRule)
    }
}
///  a
public class A:NSObject,Codable{
    /// 返回的状态码
    var code:Int?
    /// 状态码相应的说明/错误说明
    var message:String?



    public override init(){
            super.init()
    }

    enum ACodingKeys: String, CodingKey {
        case code
        case message
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: ACodingKeys.self)
        if decoderContainer.contains(.code)
        {
            self.code = try decoderContainer.decode(Int?.self, forKey: .code)
        }
        if decoderContainer.contains(.message)
        {
            self.message = try decoderContainer.decode(String?.self, forKey: .message)
        }
    }
}
public extension A{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: ACodingKeys.self)
         try encoderContainer.encode(code, forKey: .code)
         try encoderContainer.encode(message, forKey: .message)
    }
}
///  result
public class Result:NSObject,Codable{
    /// 返回的状态码
    var code:Int?
    /// 状态码相应的说明/错误说明
    var detail:String?



    public override init(){
            super.init()
    }

    enum ResultCodingKeys: String, CodingKey {
        case code
        case detail
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: ResultCodingKeys.self)
        if decoderContainer.contains(.code)
        {
            self.code = try decoderContainer.decode(Int?.self, forKey: .code)
        }
        if decoderContainer.contains(.detail)
        {
            self.detail = try decoderContainer.decode(String?.self, forKey: .detail)
        }
    }
}
public extension Result{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: ResultCodingKeys.self)
         try encoderContainer.encode(code, forKey: .code)
         try encoderContainer.encode(detail, forKey: .detail)
    }
}
///  nS
public class NS:NSObject,Codable{
    /// 0-&gt;京东NS服务器，1-&gt;非京东服务器
    var tag:Int?
    /// NS记录的值
    var server:String?



    public override init(){
            super.init()
    }

    enum NSCodingKeys: String, CodingKey {
        case tag
        case server
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: NSCodingKeys.self)
        if decoderContainer.contains(.tag)
        {
            self.tag = try decoderContainer.decode(Int?.self, forKey: .tag)
        }
        if decoderContainer.contains(.server)
        {
            self.server = try decoderContainer.decode(String?.self, forKey: .server)
        }
    }
}
public extension NS{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: NSCodingKeys.self)
         try encoderContainer.encode(tag, forKey: .tag)
         try encoderContainer.encode(server, forKey: .server)
    }
}
///  addRR
public class AddRR:NSObject,Codable{
    /// 主机记录
    /// Required:true
    var hostRecord:String
    /// 解析记录的值
    /// Required:true
    var hostValue:String
    /// 是否是京东云资源
    var jcloudRes:Bool?
    /// 优先级，只存在于MX, SRV解析记录类型
    var mxPriority:Int?
    /// 端口，只存在于SRV解析记录类型
    var port:Int?
    /// 解析记录的生存时间
    /// Required:true
    var ttl:Int
    /// 解析的类型，请参考&lt;a href&#x3D;&quot;https://docs.jdcloud.com/cn/jd-cloud-dns/detailed-interpretation-of-parsed-records&quot;&gt;解析记录类型详解&lt;/a&gt;
    /// Required:true
    var type:String
    /// 解析记录的权重，目前支持权重的有：A/AAAA/CNAME/JNAME。
    var weight:Int?
    /// 解析线路的ID，请调用getViewTree接口获取基础解析线路的ID，使用getUserView接口获取自定义线路的ID。
    /// Required:true
    var viewValue:Int



    public  init(hostRecord:String,hostValue:String,ttl:Int,type:String,viewValue:Int){
             self.hostRecord = hostRecord
             self.hostValue = hostValue
             self.ttl = ttl
             self.type = type
             self.viewValue = viewValue
    }

    enum AddRRCodingKeys: String, CodingKey {
        case hostRecord
        case hostValue
        case jcloudRes
        case mxPriority
        case port
        case ttl
        case type
        case weight
        case viewValue
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: AddRRCodingKeys.self)
        self.hostRecord = try decoderContainer.decode(String.self, forKey: .hostRecord)
        self.hostValue = try decoderContainer.decode(String.self, forKey: .hostValue)
        if decoderContainer.contains(.jcloudRes)
        {
            self.jcloudRes = try decoderContainer.decode(Bool?.self, forKey: .jcloudRes)
        }
        if decoderContainer.contains(.mxPriority)
        {
            self.mxPriority = try decoderContainer.decode(Int?.self, forKey: .mxPriority)
        }
        if decoderContainer.contains(.port)
        {
            self.port = try decoderContainer.decode(Int?.self, forKey: .port)
        }
        self.ttl = try decoderContainer.decode(Int.self, forKey: .ttl)
        self.type = try decoderContainer.decode(String.self, forKey: .type)
        if decoderContainer.contains(.weight)
        {
            self.weight = try decoderContainer.decode(Int?.self, forKey: .weight)
        }
        self.viewValue = try decoderContainer.decode(Int.self, forKey: .viewValue)
    }
}
public extension AddRR{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: AddRRCodingKeys.self)
         try encoderContainer.encode(hostRecord, forKey: .hostRecord)
         try encoderContainer.encode(hostValue, forKey: .hostValue)
         try encoderContainer.encode(jcloudRes, forKey: .jcloudRes)
         try encoderContainer.encode(mxPriority, forKey: .mxPriority)
         try encoderContainer.encode(port, forKey: .port)
         try encoderContainer.encode(ttl, forKey: .ttl)
         try encoderContainer.encode(type, forKey: .type)
         try encoderContainer.encode(weight, forKey: .weight)
         try encoderContainer.encode(viewValue, forKey: .viewValue)
    }
}
///  batchSetDNS
public class BatchSetDNS:NSObject,Codable{
    /// 解析记录对应的主域名的ID。一次请求里面应该是相同的domainId。请使用getDomains接口获取。
    /// Required:true
    var domainId:Int
    /// 主机记录
    /// Required:true
    var hostRecord:String
    /// 解析记录的值
    /// Required:true
    var hostValue:String
    /// 解析记录的ID, 如果是新增请填0，如果是更新，请使用searchRR接口查询解析记录ID。
    /// Required:true
    var id:Int
    /// 是否是京东云资源
    var jcloudRes:Bool?
    /// 优先级，只存在于MX, SRV解析记录类型
    var mxPriority:Int?
    /// 端口，只存在于SRV解析记录类型
    var port:Int?
    /// 解析记录的生存时间
    /// Required:true
    var ttl:Int
    /// 解析的类型，请参考&lt;a href&#x3D;&quot;https://docs.jdcloud.com/cn/jd-cloud-dns/detailed-interpretation-of-parsed-records&quot;&gt;解析记录类型详解&lt;/a&gt;
    /// Required:true
    var type:String
    /// 解析记录的权重，目前支持权重的有：A/AAAA/CNAME/JNAME。
    var weight:Int?
    /// 解析线路的ID，请调用getViewTree接口获取基础解析线路的ID，使用getUserView接口获取自定义线路的ID。
    /// Required:true
    var viewValue:Int



    public  init(domainId:Int,hostRecord:String,hostValue:String,id:Int,ttl:Int,type:String,viewValue:Int){
             self.domainId = domainId
             self.hostRecord = hostRecord
             self.hostValue = hostValue
             self.id = id
             self.ttl = ttl
             self.type = type
             self.viewValue = viewValue
    }

    enum BatchSetDNSCodingKeys: String, CodingKey {
        case domainId
        case hostRecord
        case hostValue
        case id
        case jcloudRes
        case mxPriority
        case port
        case ttl
        case type
        case weight
        case viewValue
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: BatchSetDNSCodingKeys.self)
        self.domainId = try decoderContainer.decode(Int.self, forKey: .domainId)
        self.hostRecord = try decoderContainer.decode(String.self, forKey: .hostRecord)
        self.hostValue = try decoderContainer.decode(String.self, forKey: .hostValue)
        self.id = try decoderContainer.decode(Int.self, forKey: .id)
        if decoderContainer.contains(.jcloudRes)
        {
            self.jcloudRes = try decoderContainer.decode(Bool?.self, forKey: .jcloudRes)
        }
        if decoderContainer.contains(.mxPriority)
        {
            self.mxPriority = try decoderContainer.decode(Int?.self, forKey: .mxPriority)
        }
        if decoderContainer.contains(.port)
        {
            self.port = try decoderContainer.decode(Int?.self, forKey: .port)
        }
        self.ttl = try decoderContainer.decode(Int.self, forKey: .ttl)
        self.type = try decoderContainer.decode(String.self, forKey: .type)
        if decoderContainer.contains(.weight)
        {
            self.weight = try decoderContainer.decode(Int?.self, forKey: .weight)
        }
        self.viewValue = try decoderContainer.decode(Int.self, forKey: .viewValue)
    }
}
public extension BatchSetDNS{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: BatchSetDNSCodingKeys.self)
         try encoderContainer.encode(domainId, forKey: .domainId)
         try encoderContainer.encode(hostRecord, forKey: .hostRecord)
         try encoderContainer.encode(hostValue, forKey: .hostValue)
         try encoderContainer.encode(id, forKey: .id)
         try encoderContainer.encode(jcloudRes, forKey: .jcloudRes)
         try encoderContainer.encode(mxPriority, forKey: .mxPriority)
         try encoderContainer.encode(port, forKey: .port)
         try encoderContainer.encode(ttl, forKey: .ttl)
         try encoderContainer.encode(type, forKey: .type)
         try encoderContainer.encode(weight, forKey: .weight)
         try encoderContainer.encode(viewValue, forKey: .viewValue)
    }
}
///  getlb
public class Getlb:NSObject,Codable{
    /// 负载均衡的解析记录的列表中解析记录是否是相同的权重 
      /// true: 均等负载 
      /// false: 按权重分配负载
      /// 
    var balance:Bool?
    /// 主机记录
    var record:String?
    /// 解析的类型
    var type:String?
    /// 解析线路的名称
    var viewName:String?
    /// 解析线路的ID
    var viewValue:Int?
    /// 负载均衡的解析记录的列表
    var items:[HostRRlb?]?



    public override init(){
            super.init()
    }

    enum GetlbCodingKeys: String, CodingKey {
        case balance
        case record
        case type
        case viewName
        case viewValue
        case items
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: GetlbCodingKeys.self)
        if decoderContainer.contains(.balance)
        {
            self.balance = try decoderContainer.decode(Bool?.self, forKey: .balance)
        }
        if decoderContainer.contains(.record)
        {
            self.record = try decoderContainer.decode(String?.self, forKey: .record)
        }
        if decoderContainer.contains(.type)
        {
            self.type = try decoderContainer.decode(String?.self, forKey: .type)
        }
        if decoderContainer.contains(.viewName)
        {
            self.viewName = try decoderContainer.decode(String?.self, forKey: .viewName)
        }
        if decoderContainer.contains(.viewValue)
        {
            self.viewValue = try decoderContainer.decode(Int?.self, forKey: .viewValue)
        }
        if decoderContainer.contains(.items)
        {
            self.items = try decoderContainer.decode([HostRRlb?]?.self, forKey: .items)
        }
    }
}
public extension Getlb{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: GetlbCodingKeys.self)
         try encoderContainer.encode(balance, forKey: .balance)
         try encoderContainer.encode(record, forKey: .record)
         try encoderContainer.encode(type, forKey: .type)
         try encoderContainer.encode(viewName, forKey: .viewName)
         try encoderContainer.encode(viewValue, forKey: .viewValue)
         try encoderContainer.encode(items, forKey: .items)
    }
}
///  setRR
public class SetRR:NSObject,Codable{
    /// 子域名
    /// Required:true
    var domain:String
    /// 要设置的解析记录数组
    /// Required:true
    var data:[SetRecords?]?



    public  init(domain:String,data:[SetRecords?]?){
             self.domain = domain
             self.data = data
    }

    enum SetRRCodingKeys: String, CodingKey {
        case domain
        case data
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: SetRRCodingKeys.self)
        self.domain = try decoderContainer.decode(String.self, forKey: .domain)
        self.data = try decoderContainer.decode([SetRecords?]?.self, forKey: .data)
    }
}
public extension SetRR{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: SetRRCodingKeys.self)
         try encoderContainer.encode(domain, forKey: .domain)
         try encoderContainer.encode(data, forKey: .data)
    }
}
///  setlb
public class Setlb:NSObject,Codable{
    /// 解析记录的ID。在getLB接口中获取。
    /// Required:true
    var id:Int
    /// 此条解析记录的权重。A,AAAA类型的权重范围为：0-100，CNAME, JNAME类型的权重范围为：1-100。
    /// Required:true
    var weight:Int



    public  init(id:Int,weight:Int){
             self.id = id
             self.weight = weight
    }

    enum SetlbCodingKeys: String, CodingKey {
        case id
        case weight
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: SetlbCodingKeys.self)
        self.id = try decoderContainer.decode(Int.self, forKey: .id)
        self.weight = try decoderContainer.decode(Int.self, forKey: .weight)
    }
}
public extension Setlb{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: SetlbCodingKeys.self)
         try encoderContainer.encode(id, forKey: .id)
         try encoderContainer.encode(weight, forKey: .weight)
    }
}
///  importDNS
public class ImportDNS:NSObject,Codable{
    /// 解析记录对应的域名的ID
    /// Required:true
    var domainId:Int
    /// 主机记录
    /// Required:true
    var hostRecord:String
    /// 解析记录的值
    /// Required:true
    var hostValue:String
    /// 解析记录的ID
    var id:Int?
    /// 是否是京东云资源
    var jcloudRes:Bool?
    /// 优先级，只存在于MX, SRV解析记录类型
    var mxPriority:Int?
    /// 端口，只存在于SRV解析记录类型
    var port:Int?
    /// 解析记录的生存时间
    /// Required:true
    var ttl:Int
    /// 解析的类型，请参考&lt;a href&#x3D;&quot;https://docs.jdcloud.com/cn/jd-cloud-dns/detailed-interpretation-of-parsed-records&quot;&gt;解析记录类型详解&lt;/a&gt;
    /// Required:true
    var type:String
    /// 解析记录的权重，目前支持权重的有：A/AAAA/CNAME/JNAME。
    var weight:Int?
    /// 解析线路的ID，请调用getViewTree接口获取基础解析线路的ID，使用getUserView接口获取自定义线路的ID。
    /// Required:true
    var viewValue:Int



    public  init(domainId:Int,hostRecord:String,hostValue:String,ttl:Int,type:String,viewValue:Int){
             self.domainId = domainId
             self.hostRecord = hostRecord
             self.hostValue = hostValue
             self.ttl = ttl
             self.type = type
             self.viewValue = viewValue
    }

    enum ImportDNSCodingKeys: String, CodingKey {
        case domainId
        case hostRecord
        case hostValue
        case id
        case jcloudRes
        case mxPriority
        case port
        case ttl
        case type
        case weight
        case viewValue
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: ImportDNSCodingKeys.self)
        self.domainId = try decoderContainer.decode(Int.self, forKey: .domainId)
        self.hostRecord = try decoderContainer.decode(String.self, forKey: .hostRecord)
        self.hostValue = try decoderContainer.decode(String.self, forKey: .hostValue)
        if decoderContainer.contains(.id)
        {
            self.id = try decoderContainer.decode(Int?.self, forKey: .id)
        }
        if decoderContainer.contains(.jcloudRes)
        {
            self.jcloudRes = try decoderContainer.decode(Bool?.self, forKey: .jcloudRes)
        }
        if decoderContainer.contains(.mxPriority)
        {
            self.mxPriority = try decoderContainer.decode(Int?.self, forKey: .mxPriority)
        }
        if decoderContainer.contains(.port)
        {
            self.port = try decoderContainer.decode(Int?.self, forKey: .port)
        }
        self.ttl = try decoderContainer.decode(Int.self, forKey: .ttl)
        self.type = try decoderContainer.decode(String.self, forKey: .type)
        if decoderContainer.contains(.weight)
        {
            self.weight = try decoderContainer.decode(Int?.self, forKey: .weight)
        }
        self.viewValue = try decoderContainer.decode(Int.self, forKey: .viewValue)
    }
}
public extension ImportDNS{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: ImportDNSCodingKeys.self)
         try encoderContainer.encode(domainId, forKey: .domainId)
         try encoderContainer.encode(hostRecord, forKey: .hostRecord)
         try encoderContainer.encode(hostValue, forKey: .hostValue)
         try encoderContainer.encode(id, forKey: .id)
         try encoderContainer.encode(jcloudRes, forKey: .jcloudRes)
         try encoderContainer.encode(mxPriority, forKey: .mxPriority)
         try encoderContainer.encode(port, forKey: .port)
         try encoderContainer.encode(ttl, forKey: .ttl)
         try encoderContainer.encode(type, forKey: .type)
         try encoderContainer.encode(weight, forKey: .weight)
         try encoderContainer.encode(viewValue, forKey: .viewValue)
    }
}
///  viewTree
public class ViewTree:NSObject,Codable{
    /// 此解析线路是否禁用
    var disabled:Bool?
    /// 解析线路的描述
    var label:String?
    /// 此数据是否是叶子节点
    var leaf:Bool?
    /// 解析线路ID
    var value:Int?
    /// 解析线路的名称，在使用viewName的参数处使用，如果为空表明此解析线路不能直接使用，请使用它的子线路。
    var viewName:String?
    /// Children
    var children:[ViewTree?]?



    public override init(){
            super.init()
    }

    enum ViewTreeCodingKeys: String, CodingKey {
        case disabled
        case label
        case leaf
        case value
        case viewName
        case children
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: ViewTreeCodingKeys.self)
        if decoderContainer.contains(.disabled)
        {
            self.disabled = try decoderContainer.decode(Bool?.self, forKey: .disabled)
        }
        if decoderContainer.contains(.label)
        {
            self.label = try decoderContainer.decode(String?.self, forKey: .label)
        }
        if decoderContainer.contains(.leaf)
        {
            self.leaf = try decoderContainer.decode(Bool?.self, forKey: .leaf)
        }
        if decoderContainer.contains(.value)
        {
            self.value = try decoderContainer.decode(Int?.self, forKey: .value)
        }
        if decoderContainer.contains(.viewName)
        {
            self.viewName = try decoderContainer.decode(String?.self, forKey: .viewName)
        }
        if decoderContainer.contains(.children)
        {
            self.children = try decoderContainer.decode([ViewTree?]?.self, forKey: .children)
        }
    }
}
public extension ViewTree{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: ViewTreeCodingKeys.self)
         try encoderContainer.encode(disabled, forKey: .disabled)
         try encoderContainer.encode(label, forKey: .label)
         try encoderContainer.encode(leaf, forKey: .leaf)
         try encoderContainer.encode(value, forKey: .value)
         try encoderContainer.encode(viewName, forKey: .viewName)
         try encoderContainer.encode(children, forKey: .children)
    }
}
///  hostRRlb
public class HostRRlb:NSObject,Codable{
    /// 解析记录的值
    var hostValue:String?
    /// 解析记录的ID
    var id:Int?
    /// 解析记录的权重
    var weight:Int?
    /// 此条记录在总均衡中的比率的100倍
    var rate:Double?



    public override init(){
            super.init()
    }

    enum HostRRlbCodingKeys: String, CodingKey {
        case hostValue
        case id
        case weight
        case rate
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: HostRRlbCodingKeys.self)
        if decoderContainer.contains(.hostValue)
        {
            self.hostValue = try decoderContainer.decode(String?.self, forKey: .hostValue)
        }
        if decoderContainer.contains(.id)
        {
            self.id = try decoderContainer.decode(Int?.self, forKey: .id)
        }
        if decoderContainer.contains(.weight)
        {
            self.weight = try decoderContainer.decode(Int?.self, forKey: .weight)
        }
        if decoderContainer.contains(.rate)
        {
            self.rate = try decoderContainer.decode(Double?.self, forKey: .rate)
        }
    }
}
public extension HostRRlb{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: HostRRlbCodingKeys.self)
         try encoderContainer.encode(hostValue, forKey: .hostValue)
         try encoderContainer.encode(id, forKey: .id)
         try encoderContainer.encode(weight, forKey: .weight)
         try encoderContainer.encode(rate, forKey: .rate)
    }
}
///  updateRR
public class UpdateRR:NSObject,Codable{
    /// 主域名
    /// Required:true
    var domainName:String
    /// 域名解析的唯一ID
    /// Required:true
    var id:Int
    /// 主机记录
    /// Required:true
    var hostRecord:String
    /// 解析记录的值
    /// Required:true
    var hostValue:String
    /// 是否是京东云资源
    var jcloudRes:Bool?
    /// 优先级，只存在于MX, SRV解析记录类型
    var mxPriority:Int?
    /// 端口，只存在于SRV解析记录类型
    var port:Int?
    /// 解析记录的生存时间
    /// Required:true
    var ttl:Int
    /// 解析的类型，请参考&lt;a href&#x3D;&quot;https://docs.jdcloud.com/cn/jd-cloud-dns/detailed-interpretation-of-parsed-records&quot;&gt;解析记录类型详解&lt;/a&gt;
    /// Required:true
    var type:String
    /// 解析记录的权重，目前支持权重的有：A/AAAA/CNAME/JNAME。
    var weight:Int?
    /// 解析线路的ID，请调用getViewTree接口获取基础解析线路的ID，使用getUserView接口获取自定义线路的ID。
    /// Required:true
    var viewValue:Int



    public  init(domainName:String,id:Int,hostRecord:String,hostValue:String,ttl:Int,type:String,viewValue:Int){
             self.domainName = domainName
             self.id = id
             self.hostRecord = hostRecord
             self.hostValue = hostValue
             self.ttl = ttl
             self.type = type
             self.viewValue = viewValue
    }

    enum UpdateRRCodingKeys: String, CodingKey {
        case domainName
        case id
        case hostRecord
        case hostValue
        case jcloudRes
        case mxPriority
        case port
        case ttl
        case type
        case weight
        case viewValue
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: UpdateRRCodingKeys.self)
        self.domainName = try decoderContainer.decode(String.self, forKey: .domainName)
        self.id = try decoderContainer.decode(Int.self, forKey: .id)
        self.hostRecord = try decoderContainer.decode(String.self, forKey: .hostRecord)
        self.hostValue = try decoderContainer.decode(String.self, forKey: .hostValue)
        if decoderContainer.contains(.jcloudRes)
        {
            self.jcloudRes = try decoderContainer.decode(Bool?.self, forKey: .jcloudRes)
        }
        if decoderContainer.contains(.mxPriority)
        {
            self.mxPriority = try decoderContainer.decode(Int?.self, forKey: .mxPriority)
        }
        if decoderContainer.contains(.port)
        {
            self.port = try decoderContainer.decode(Int?.self, forKey: .port)
        }
        self.ttl = try decoderContainer.decode(Int.self, forKey: .ttl)
        self.type = try decoderContainer.decode(String.self, forKey: .type)
        if decoderContainer.contains(.weight)
        {
            self.weight = try decoderContainer.decode(Int?.self, forKey: .weight)
        }
        self.viewValue = try decoderContainer.decode(Int.self, forKey: .viewValue)
    }
}
public extension UpdateRR{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: UpdateRRCodingKeys.self)
         try encoderContainer.encode(domainName, forKey: .domainName)
         try encoderContainer.encode(id, forKey: .id)
         try encoderContainer.encode(hostRecord, forKey: .hostRecord)
         try encoderContainer.encode(hostValue, forKey: .hostValue)
         try encoderContainer.encode(jcloudRes, forKey: .jcloudRes)
         try encoderContainer.encode(mxPriority, forKey: .mxPriority)
         try encoderContainer.encode(port, forKey: .port)
         try encoderContainer.encode(ttl, forKey: .ttl)
         try encoderContainer.encode(type, forKey: .type)
         try encoderContainer.encode(weight, forKey: .weight)
         try encoderContainer.encode(viewValue, forKey: .viewValue)
    }
}
///  rR
public class RR:NSObject,Codable{
    /// 域名解析的唯一ID
    var id:Int?
    /// 主机记录
    var hostRecord:String?
    /// 解析记录的值
    var hostValue:String?
    /// 是否是京东云资源
    var jcloudRes:Bool?
    /// 优先级，只存在于MX, SRV解析记录类型
    var mxPriority:Int?
    /// 端口，只存在于SRV解析记录类型
    var port:Int?
    /// 解析记录的生存时间
    var ttl:Int?
    /// 解析记录的类型
    var type:String?
    /// 解析记录的权重
    var weight:Int?
    /// 解析线路的ID
    var viewValue:[Int?]?



    public override init(){
            super.init()
    }

    enum RRCodingKeys: String, CodingKey {
        case id
        case hostRecord
        case hostValue
        case jcloudRes
        case mxPriority
        case port
        case ttl
        case type
        case weight
        case viewValue
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: RRCodingKeys.self)
        if decoderContainer.contains(.id)
        {
            self.id = try decoderContainer.decode(Int?.self, forKey: .id)
        }
        if decoderContainer.contains(.hostRecord)
        {
            self.hostRecord = try decoderContainer.decode(String?.self, forKey: .hostRecord)
        }
        if decoderContainer.contains(.hostValue)
        {
            self.hostValue = try decoderContainer.decode(String?.self, forKey: .hostValue)
        }
        if decoderContainer.contains(.jcloudRes)
        {
            self.jcloudRes = try decoderContainer.decode(Bool?.self, forKey: .jcloudRes)
        }
        if decoderContainer.contains(.mxPriority)
        {
            self.mxPriority = try decoderContainer.decode(Int?.self, forKey: .mxPriority)
        }
        if decoderContainer.contains(.port)
        {
            self.port = try decoderContainer.decode(Int?.self, forKey: .port)
        }
        if decoderContainer.contains(.ttl)
        {
            self.ttl = try decoderContainer.decode(Int?.self, forKey: .ttl)
        }
        if decoderContainer.contains(.type)
        {
            self.type = try decoderContainer.decode(String?.self, forKey: .type)
        }
        if decoderContainer.contains(.weight)
        {
            self.weight = try decoderContainer.decode(Int?.self, forKey: .weight)
        }
        if decoderContainer.contains(.viewValue)
        {
            self.viewValue = try decoderContainer.decode([Int?]?.self, forKey: .viewValue)
        }
    }
}
public extension RR{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: RRCodingKeys.self)
         try encoderContainer.encode(id, forKey: .id)
         try encoderContainer.encode(hostRecord, forKey: .hostRecord)
         try encoderContainer.encode(hostValue, forKey: .hostValue)
         try encoderContainer.encode(jcloudRes, forKey: .jcloudRes)
         try encoderContainer.encode(mxPriority, forKey: .mxPriority)
         try encoderContainer.encode(port, forKey: .port)
         try encoderContainer.encode(ttl, forKey: .ttl)
         try encoderContainer.encode(type, forKey: .type)
         try encoderContainer.encode(weight, forKey: .weight)
         try encoderContainer.encode(viewValue, forKey: .viewValue)
    }
}
///  setalb
public class Setalb:NSObject,Codable{
    /// 解析记录的ID。在getALB接口中获取。
    var id:Int?
    /// 此条解析记录的权重。
    var weight:Int?



    public override init(){
            super.init()
    }

    enum SetalbCodingKeys: String, CodingKey {
        case id
        case weight
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: SetalbCodingKeys.self)
        if decoderContainer.contains(.id)
        {
            self.id = try decoderContainer.decode(Int?.self, forKey: .id)
        }
        if decoderContainer.contains(.weight)
        {
            self.weight = try decoderContainer.decode(Int?.self, forKey: .weight)
        }
    }
}
public extension Setalb{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: SetalbCodingKeys.self)
         try encoderContainer.encode(id, forKey: .id)
         try encoderContainer.encode(weight, forKey: .weight)
    }
}
///  getalb
public class Getalb:NSObject,Codable{
    /// 负载均衡的解析记录的列表中解析记录是否是相同的权重 
      /// true: 均等负载 
      /// false: 按权重分配负载
      /// 
    var balance:Bool?
    /// 主机记录
    var record:String?
    /// 解析的类型
    var type:String?
    /// 解析线路的名称
    var viewName:String?
    /// 解析线路的ID
    var viewValue:Int?
    /// 负载均衡的解析记录的列表
    var items:[HostRRlb?]?



    public override init(){
            super.init()
    }

    enum GetalbCodingKeys: String, CodingKey {
        case balance
        case record
        case type
        case viewName
        case viewValue
        case items
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: GetalbCodingKeys.self)
        if decoderContainer.contains(.balance)
        {
            self.balance = try decoderContainer.decode(Bool?.self, forKey: .balance)
        }
        if decoderContainer.contains(.record)
        {
            self.record = try decoderContainer.decode(String?.self, forKey: .record)
        }
        if decoderContainer.contains(.type)
        {
            self.type = try decoderContainer.decode(String?.self, forKey: .type)
        }
        if decoderContainer.contains(.viewName)
        {
            self.viewName = try decoderContainer.decode(String?.self, forKey: .viewName)
        }
        if decoderContainer.contains(.viewValue)
        {
            self.viewValue = try decoderContainer.decode(Int?.self, forKey: .viewValue)
        }
        if decoderContainer.contains(.items)
        {
            self.items = try decoderContainer.decode([HostRRlb?]?.self, forKey: .items)
        }
    }
}
public extension Getalb{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: GetalbCodingKeys.self)
         try encoderContainer.encode(balance, forKey: .balance)
         try encoderContainer.encode(record, forKey: .record)
         try encoderContainer.encode(type, forKey: .type)
         try encoderContainer.encode(viewName, forKey: .viewName)
         try encoderContainer.encode(viewValue, forKey: .viewValue)
         try encoderContainer.encode(items, forKey: .items)
    }
}
///  rRInfo
public class RRInfo:NSObject,Codable{
    /// 创建者
    var creator:String?
    /// 线路名称
    var viewName:String?
    /// 域名解析的唯一ID
    var id:Int?
    /// 主机记录
    var hostRecord:String?
    /// 解析记录的值
    var hostValue:String?
    /// 是否是京东云资源
    var jcloudRes:Bool?
    /// 优先级，只存在于MX, SRV解析记录类型
    var mxPriority:Int?
    /// 端口，只存在于SRV解析记录类型
    var port:Int?
    /// 解析记录的生存时间
    var ttl:Int?
    /// 解析记录的类型
    var type:String?
    /// 解析记录的权重
    var weight:Int?
    /// 解析线路的ID
    var viewValue:[Int?]?
    /// 解析记录的状态
    var resolvingStatus:String?
    /// 解析记录更新的时间
    var updateTime:Int64?



    public override init(){
            super.init()
    }

    enum RRInfoCodingKeys: String, CodingKey {
        case creator
        case viewName
        case id
        case hostRecord
        case hostValue
        case jcloudRes
        case mxPriority
        case port
        case ttl
        case type
        case weight
        case viewValue
        case resolvingStatus
        case updateTime
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: RRInfoCodingKeys.self)
        if decoderContainer.contains(.creator)
        {
            self.creator = try decoderContainer.decode(String?.self, forKey: .creator)
        }
        if decoderContainer.contains(.viewName)
        {
            self.viewName = try decoderContainer.decode(String?.self, forKey: .viewName)
        }
        if decoderContainer.contains(.id)
        {
            self.id = try decoderContainer.decode(Int?.self, forKey: .id)
        }
        if decoderContainer.contains(.hostRecord)
        {
            self.hostRecord = try decoderContainer.decode(String?.self, forKey: .hostRecord)
        }
        if decoderContainer.contains(.hostValue)
        {
            self.hostValue = try decoderContainer.decode(String?.self, forKey: .hostValue)
        }
        if decoderContainer.contains(.jcloudRes)
        {
            self.jcloudRes = try decoderContainer.decode(Bool?.self, forKey: .jcloudRes)
        }
        if decoderContainer.contains(.mxPriority)
        {
            self.mxPriority = try decoderContainer.decode(Int?.self, forKey: .mxPriority)
        }
        if decoderContainer.contains(.port)
        {
            self.port = try decoderContainer.decode(Int?.self, forKey: .port)
        }
        if decoderContainer.contains(.ttl)
        {
            self.ttl = try decoderContainer.decode(Int?.self, forKey: .ttl)
        }
        if decoderContainer.contains(.type)
        {
            self.type = try decoderContainer.decode(String?.self, forKey: .type)
        }
        if decoderContainer.contains(.weight)
        {
            self.weight = try decoderContainer.decode(Int?.self, forKey: .weight)
        }
        if decoderContainer.contains(.viewValue)
        {
            self.viewValue = try decoderContainer.decode([Int?]?.self, forKey: .viewValue)
        }
        if decoderContainer.contains(.resolvingStatus)
        {
            self.resolvingStatus = try decoderContainer.decode(String?.self, forKey: .resolvingStatus)
        }
        if decoderContainer.contains(.updateTime)
        {
            self.updateTime = try decoderContainer.decode(Int64?.self, forKey: .updateTime)
        }
    }
}
public extension RRInfo{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: RRInfoCodingKeys.self)
         try encoderContainer.encode(creator, forKey: .creator)
         try encoderContainer.encode(viewName, forKey: .viewName)
         try encoderContainer.encode(id, forKey: .id)
         try encoderContainer.encode(hostRecord, forKey: .hostRecord)
         try encoderContainer.encode(hostValue, forKey: .hostValue)
         try encoderContainer.encode(jcloudRes, forKey: .jcloudRes)
         try encoderContainer.encode(mxPriority, forKey: .mxPriority)
         try encoderContainer.encode(port, forKey: .port)
         try encoderContainer.encode(ttl, forKey: .ttl)
         try encoderContainer.encode(type, forKey: .type)
         try encoderContainer.encode(weight, forKey: .weight)
         try encoderContainer.encode(viewValue, forKey: .viewValue)
         try encoderContainer.encode(resolvingStatus, forKey: .resolvingStatus)
         try encoderContainer.encode(updateTime, forKey: .updateTime)
    }
}
///  jdvpc
public class Jdvpc:NSObject,Codable{
    /// 京东云IP
    var ip:String?
    /// 是否绑定
    var binded:Bool?



    public override init(){
            super.init()
    }

    enum JdvpcCodingKeys: String, CodingKey {
        case ip
        case binded
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: JdvpcCodingKeys.self)
        if decoderContainer.contains(.ip)
        {
            self.ip = try decoderContainer.decode(String?.self, forKey: .ip)
        }
        if decoderContainer.contains(.binded)
        {
            self.binded = try decoderContainer.decode(Bool?.self, forKey: .binded)
        }
    }
}
public extension Jdvpc{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: JdvpcCodingKeys.self)
         try encoderContainer.encode(ip, forKey: .ip)
         try encoderContainer.encode(binded, forKey: .binded)
    }
}
///  setRecords
public class SetRecords:NSObject,Codable{
    /// 解析记录的值
    /// Required:true
    var records:[String?]?
    /// 解析记录所在的解析线路，请调用getViewTree接口获取。如果不传是默认线路。
    var views:[String?]?
    /// 解析记录的类型，支持A, AAAA, CNAME类型
    /// Required:true
    var type:String



    public  init(records:[String?]?,type:String){
             self.records = records
             self.type = type
    }

    enum SetRecordsCodingKeys: String, CodingKey {
        case records
        case views
        case type
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: SetRecordsCodingKeys.self)
        self.records = try decoderContainer.decode([String?]?.self, forKey: .records)
        if decoderContainer.contains(.views)
        {
            self.views = try decoderContainer.decode([String?]?.self, forKey: .views)
        }
        self.type = try decoderContainer.decode(String.self, forKey: .type)
    }
}
public extension SetRecords{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: SetRecordsCodingKeys.self)
         try encoderContainer.encode(records, forKey: .records)
         try encoderContainer.encode(views, forKey: .views)
         try encoderContainer.encode(type, forKey: .type)
    }
}
///  subDomainExist
public class SubDomainExist:NSObject,Codable{
    /// 子域名
    var domain:String?
    /// 子域名的存在状态，1：存在，2：不存在，3：zone不存在
    var isExist:Int?



    public override init(){
            super.init()
    }

    enum SubDomainExistCodingKeys: String, CodingKey {
        case domain
        case isExist
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: SubDomainExistCodingKeys.self)
        if decoderContainer.contains(.domain)
        {
            self.domain = try decoderContainer.decode(String?.self, forKey: .domain)
        }
        if decoderContainer.contains(.isExist)
        {
            self.isExist = try decoderContainer.decode(Int?.self, forKey: .isExist)
        }
    }
}
public extension SubDomainExist{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: SubDomainExistCodingKeys.self)
         try encoderContainer.encode(domain, forKey: .domain)
         try encoderContainer.encode(isExist, forKey: .isExist)
    }
}
///  userViewInput
public class UserViewInput:NSObject,Codable{
    /// 自定义线路ID
    var viewId:Int?
    /// 自定义线路名称, 最多64个字符
    var viewName:String?
    /// 主域名ID
    var domainId:Int?
    /// 用户输入的IP段
    var ipRanges:[String?]?
    /// 是否删除，0:没有删除，1:已删除
    var isDelete:Int?
    /// 创建者
    var creator:String?
    /// 创建时间，格式Unix timestamp，时间单位：秒
    var createTime:Int?
    /// 更新者
    var updator:String?
    /// 更新时间，格式Unix timestamp，时间单位：秒
    var updateTime:Int?



    public override init(){
            super.init()
    }

    enum UserViewInputCodingKeys: String, CodingKey {
        case viewId
        case viewName
        case domainId
        case ipRanges
        case isDelete
        case creator
        case createTime
        case updator
        case updateTime
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: UserViewInputCodingKeys.self)
        if decoderContainer.contains(.viewId)
        {
            self.viewId = try decoderContainer.decode(Int?.self, forKey: .viewId)
        }
        if decoderContainer.contains(.viewName)
        {
            self.viewName = try decoderContainer.decode(String?.self, forKey: .viewName)
        }
        if decoderContainer.contains(.domainId)
        {
            self.domainId = try decoderContainer.decode(Int?.self, forKey: .domainId)
        }
        if decoderContainer.contains(.ipRanges)
        {
            self.ipRanges = try decoderContainer.decode([String?]?.self, forKey: .ipRanges)
        }
        if decoderContainer.contains(.isDelete)
        {
            self.isDelete = try decoderContainer.decode(Int?.self, forKey: .isDelete)
        }
        if decoderContainer.contains(.creator)
        {
            self.creator = try decoderContainer.decode(String?.self, forKey: .creator)
        }
        if decoderContainer.contains(.createTime)
        {
            self.createTime = try decoderContainer.decode(Int?.self, forKey: .createTime)
        }
        if decoderContainer.contains(.updator)
        {
            self.updator = try decoderContainer.decode(String?.self, forKey: .updator)
        }
        if decoderContainer.contains(.updateTime)
        {
            self.updateTime = try decoderContainer.decode(Int?.self, forKey: .updateTime)
        }
    }
}
public extension UserViewInput{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: UserViewInputCodingKeys.self)
         try encoderContainer.encode(viewId, forKey: .viewId)
         try encoderContainer.encode(viewName, forKey: .viewName)
         try encoderContainer.encode(domainId, forKey: .domainId)
         try encoderContainer.encode(ipRanges, forKey: .ipRanges)
         try encoderContainer.encode(isDelete, forKey: .isDelete)
         try encoderContainer.encode(creator, forKey: .creator)
         try encoderContainer.encode(createTime, forKey: .createTime)
         try encoderContainer.encode(updator, forKey: .updator)
         try encoderContainer.encode(updateTime, forKey: .updateTime)
    }
}
///  delView
public class DelView:NSObject,Codable{
    /// 主域名ID，请使用getDomains接口获取
    /// Required:true
    var domainId:Int
    /// 主域名
    /// Required:true
    var domainName:String
    /// 自定义线路名称, 最多64个字符
    /// Required:true
    var viewName:String
    /// 自定义线路ID
    /// Required:true
    var viewId:Int



    public  init(domainId:Int,domainName:String,viewName:String,viewId:Int){
             self.domainId = domainId
             self.domainName = domainName
             self.viewName = viewName
             self.viewId = viewId
    }

    enum DelViewCodingKeys: String, CodingKey {
        case domainId
        case domainName
        case viewName
        case viewId
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: DelViewCodingKeys.self)
        self.domainId = try decoderContainer.decode(Int.self, forKey: .domainId)
        self.domainName = try decoderContainer.decode(String.self, forKey: .domainName)
        self.viewName = try decoderContainer.decode(String.self, forKey: .viewName)
        self.viewId = try decoderContainer.decode(Int.self, forKey: .viewId)
    }
}
public extension DelView{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: DelViewCodingKeys.self)
         try encoderContainer.encode(domainId, forKey: .domainId)
         try encoderContainer.encode(domainName, forKey: .domainName)
         try encoderContainer.encode(viewName, forKey: .viewName)
         try encoderContainer.encode(viewId, forKey: .viewId)
    }
}
///  delViewIP
public class DelViewIP:NSObject,Codable{
    /// 主域名ID，请使用getDomains接口获取
    /// Required:true
    var domainId:Int
    /// 自定义线路ID
    /// Required:true
    var viewId:Int
    /// 自定义线路名称, 最多64个字符
    /// Required:true
    var viewName:String
    /// 此线路需要删除的ip段。  
      /// IPv4地址段支持1.2.3.4-5.6.7.8和1.2.3.4/16两种格式。    
      /// IPv6地址段支持CIDR格式，例如：11:22:33:44:55::99/64
      /// 
    /// Required:true
    var ipRanges:[String?]?



    public  init(domainId:Int,viewId:Int,viewName:String,ipRanges:[String?]?){
             self.domainId = domainId
             self.viewId = viewId
             self.viewName = viewName
             self.ipRanges = ipRanges
    }

    enum DelViewIPCodingKeys: String, CodingKey {
        case domainId
        case viewId
        case viewName
        case ipRanges
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: DelViewIPCodingKeys.self)
        self.domainId = try decoderContainer.decode(Int.self, forKey: .domainId)
        self.viewId = try decoderContainer.decode(Int.self, forKey: .viewId)
        self.viewName = try decoderContainer.decode(String.self, forKey: .viewName)
        self.ipRanges = try decoderContainer.decode([String?]?.self, forKey: .ipRanges)
    }
}
public extension DelViewIP{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: DelViewIPCodingKeys.self)
         try encoderContainer.encode(domainId, forKey: .domainId)
         try encoderContainer.encode(viewId, forKey: .viewId)
         try encoderContainer.encode(viewName, forKey: .viewName)
         try encoderContainer.encode(ipRanges, forKey: .ipRanges)
    }
}
///  addView
public class AddView:NSObject,Codable{
    /// 主域名ID，请使用getDomains接口获取
    /// Required:true
    var domainId:Int
    /// 主域名
    /// Required:true
    var domainName:String
    /// 自定义线路名称, 最多64个字符
    /// Required:true
    var viewName:String
    /// 用户输入的此线路的ip段。  
      /// IPv4地址段支持1.2.3.4-5.6.7.8和1.2.3.4/16两种格式。    
      /// IPv6地址段支持CIDR格式，例如：11:22:33:44:55::99/64
      /// 
    /// Required:true
    var ipRanges:[String?]?



    public  init(domainId:Int,domainName:String,viewName:String,ipRanges:[String?]?){
             self.domainId = domainId
             self.domainName = domainName
             self.viewName = viewName
             self.ipRanges = ipRanges
    }

    enum AddViewCodingKeys: String, CodingKey {
        case domainId
        case domainName
        case viewName
        case ipRanges
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: AddViewCodingKeys.self)
        self.domainId = try decoderContainer.decode(Int.self, forKey: .domainId)
        self.domainName = try decoderContainer.decode(String.self, forKey: .domainName)
        self.viewName = try decoderContainer.decode(String.self, forKey: .viewName)
        self.ipRanges = try decoderContainer.decode([String?]?.self, forKey: .ipRanges)
    }
}
public extension AddView{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: AddViewCodingKeys.self)
         try encoderContainer.encode(domainId, forKey: .domainId)
         try encoderContainer.encode(domainName, forKey: .domainName)
         try encoderContainer.encode(viewName, forKey: .viewName)
         try encoderContainer.encode(ipRanges, forKey: .ipRanges)
    }
}
///  userview
public class Userview:NSObject,Codable{
    /// 自定义线路ID
    var viewId:Int?
    /// 自定义线路名称, 最多64个字符
    var viewName:String?
    /// 主域名ID
    var domainId:Int?
    /// 域名
    var domainName:String?
    /// 是否删除，0:没有删除，1:已删除
    var isDelete:Int?
    /// 创建者
    var creator:String?
    /// 创建时间，格式Unix timestamp，时间单位：秒
    var createTime:Int?
    /// 更新者
    var updator:String?
    /// 更新时间，格式Unix timestamp，时间单位：秒
    var updateTime:Int?



    public override init(){
            super.init()
    }

    enum UserviewCodingKeys: String, CodingKey {
        case viewId
        case viewName
        case domainId
        case domainName
        case isDelete
        case creator
        case createTime
        case updator
        case updateTime
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: UserviewCodingKeys.self)
        if decoderContainer.contains(.viewId)
        {
            self.viewId = try decoderContainer.decode(Int?.self, forKey: .viewId)
        }
        if decoderContainer.contains(.viewName)
        {
            self.viewName = try decoderContainer.decode(String?.self, forKey: .viewName)
        }
        if decoderContainer.contains(.domainId)
        {
            self.domainId = try decoderContainer.decode(Int?.self, forKey: .domainId)
        }
        if decoderContainer.contains(.domainName)
        {
            self.domainName = try decoderContainer.decode(String?.self, forKey: .domainName)
        }
        if decoderContainer.contains(.isDelete)
        {
            self.isDelete = try decoderContainer.decode(Int?.self, forKey: .isDelete)
        }
        if decoderContainer.contains(.creator)
        {
            self.creator = try decoderContainer.decode(String?.self, forKey: .creator)
        }
        if decoderContainer.contains(.createTime)
        {
            self.createTime = try decoderContainer.decode(Int?.self, forKey: .createTime)
        }
        if decoderContainer.contains(.updator)
        {
            self.updator = try decoderContainer.decode(String?.self, forKey: .updator)
        }
        if decoderContainer.contains(.updateTime)
        {
            self.updateTime = try decoderContainer.decode(Int?.self, forKey: .updateTime)
        }
    }
}
public extension Userview{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: UserviewCodingKeys.self)
         try encoderContainer.encode(viewId, forKey: .viewId)
         try encoderContainer.encode(viewName, forKey: .viewName)
         try encoderContainer.encode(domainId, forKey: .domainId)
         try encoderContainer.encode(domainName, forKey: .domainName)
         try encoderContainer.encode(isDelete, forKey: .isDelete)
         try encoderContainer.encode(creator, forKey: .creator)
         try encoderContainer.encode(createTime, forKey: .createTime)
         try encoderContainer.encode(updator, forKey: .updator)
         try encoderContainer.encode(updateTime, forKey: .updateTime)
    }
}
///  addViewIP
public class AddViewIP:NSObject,Codable{
    /// 主域名ID，请使用getDomains接口获取
    /// Required:true
    var domainId:Int
    /// 自定义线路ID
    /// Required:true
    var viewId:Int
    /// 自定义线路名称, 最多64个字符
    /// Required:true
    var viewName:String
    /// 此线路需要添加的ip段。  
      /// IPv4地址段支持1.2.3.4-5.6.7.8和1.2.3.4/16两种格式。    
      /// IPv6地址段支持CIDR格式，例如：11:22:33:44:55::99/64
      /// 
    /// Required:true
    var ipRanges:[String?]?



    public  init(domainId:Int,viewId:Int,viewName:String,ipRanges:[String?]?){
             self.domainId = domainId
             self.viewId = viewId
             self.viewName = viewName
             self.ipRanges = ipRanges
    }

    enum AddViewIPCodingKeys: String, CodingKey {
        case domainId
        case viewId
        case viewName
        case ipRanges
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: AddViewIPCodingKeys.self)
        self.domainId = try decoderContainer.decode(Int.self, forKey: .domainId)
        self.viewId = try decoderContainer.decode(Int.self, forKey: .viewId)
        self.viewName = try decoderContainer.decode(String.self, forKey: .viewName)
        self.ipRanges = try decoderContainer.decode([String?]?.self, forKey: .ipRanges)
    }
}
public extension AddViewIP{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: AddViewIPCodingKeys.self)
         try encoderContainer.encode(domainId, forKey: .domainId)
         try encoderContainer.encode(viewId, forKey: .viewId)
         try encoderContainer.encode(viewName, forKey: .viewName)
         try encoderContainer.encode(ipRanges, forKey: .ipRanges)
    }
}
///  resourceInfo
public class ResourceInfo:NSObject,Codable{
    /// 实例id
    var resourceId:String?
    /// 实例名称
    var resourceName:String?
    /// 额外描述信息，包括可续费时长，套餐类型
    var remark:String?



    public override init(){
            super.init()
    }

    enum ResourceInfoCodingKeys: String, CodingKey {
        case resourceId
        case resourceName
        case remark
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: ResourceInfoCodingKeys.self)
        if decoderContainer.contains(.resourceId)
        {
            self.resourceId = try decoderContainer.decode(String?.self, forKey: .resourceId)
        }
        if decoderContainer.contains(.resourceName)
        {
            self.resourceName = try decoderContainer.decode(String?.self, forKey: .resourceName)
        }
        if decoderContainer.contains(.remark)
        {
            self.remark = try decoderContainer.decode(String?.self, forKey: .remark)
        }
    }
}
public extension ResourceInfo{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: ResourceInfoCodingKeys.self)
         try encoderContainer.encode(resourceId, forKey: .resourceId)
         try encoderContainer.encode(resourceName, forKey: .resourceName)
         try encoderContainer.encode(remark, forKey: .remark)
    }
}
///  actionlog
public class Actionlog:NSObject,Codable{
    /// 操作记录的ID
    var id:Int?
    /// 用户名
    var userPin:String?
    /// 操作的域名
    var domain:String?
    /// 操作类型：1新增 2修改 3删除
    var type:Int?
    /// 操作的详细情况
    var detail:String?
    /// 操作发生的时间
    var time:Int64?
    /// 操作的结果，成功true, 失败false
    var success:Bool?
    /// 操作失败的原因
    var failReason:String?
    /// 操作者的IP
    var clientIp:String?



    public override init(){
            super.init()
    }

    enum ActionlogCodingKeys: String, CodingKey {
        case id
        case userPin
        case domain
        case type
        case detail
        case time
        case success
        case failReason
        case clientIp
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: ActionlogCodingKeys.self)
        if decoderContainer.contains(.id)
        {
            self.id = try decoderContainer.decode(Int?.self, forKey: .id)
        }
        if decoderContainer.contains(.userPin)
        {
            self.userPin = try decoderContainer.decode(String?.self, forKey: .userPin)
        }
        if decoderContainer.contains(.domain)
        {
            self.domain = try decoderContainer.decode(String?.self, forKey: .domain)
        }
        if decoderContainer.contains(.type)
        {
            self.type = try decoderContainer.decode(Int?.self, forKey: .type)
        }
        if decoderContainer.contains(.detail)
        {
            self.detail = try decoderContainer.decode(String?.self, forKey: .detail)
        }
        if decoderContainer.contains(.time)
        {
            self.time = try decoderContainer.decode(Int64?.self, forKey: .time)
        }
        if decoderContainer.contains(.success)
        {
            self.success = try decoderContainer.decode(Bool?.self, forKey: .success)
        }
        if decoderContainer.contains(.failReason)
        {
            self.failReason = try decoderContainer.decode(String?.self, forKey: .failReason)
        }
        if decoderContainer.contains(.clientIp)
        {
            self.clientIp = try decoderContainer.decode(String?.self, forKey: .clientIp)
        }
    }
}
public extension Actionlog{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: ActionlogCodingKeys.self)
         try encoderContainer.encode(id, forKey: .id)
         try encoderContainer.encode(userPin, forKey: .userPin)
         try encoderContainer.encode(domain, forKey: .domain)
         try encoderContainer.encode(type, forKey: .type)
         try encoderContainer.encode(detail, forKey: .detail)
         try encoderContainer.encode(time, forKey: .time)
         try encoderContainer.encode(success, forKey: .success)
         try encoderContainer.encode(failReason, forKey: .failReason)
         try encoderContainer.encode(clientIp, forKey: .clientIp)
    }
}

/* Copyright 2018 JDCLOUD.COM

   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at

     http:#www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.

   
   

   
   Contact: 

   NOTE: This class is auto generated by the jdcloud code generator program.
 */


import Foundation

///  monitor
@objc(Monitor)
public class Monitor:NSObject,Codable{
    /// 连续几次触发报警
    var alarmLimit:Int?
    /// 现在是否可以恢复
    var canRecover:Bool?
    /// 现在是否可以切换
    var canSwitch:Bool?
    /// 机房探测点的集合
    var clusters:String?
    /// 主域名
    var domainName:String?
    /// 主机状态，0正常，1异常
    var hostStatus:Int?
    /// 监控对象
    var hostValue:String?
    /// 监控项ID
    var id:Int?
    /// 备用地址1
    var ipBackup01:String?
    /// 备用地址1的状态，0正常，1异常
    var ipBackup01Status:Int?
    /// 备用地址1的类型，1为ip 2为域名
    var ipBackup01Type:Int?
    /// 备用地址2
    var ipBackup02:String?
    /// 备用地址2的状态，0正常，1异常
    var ipBackup02Status:Int?
    /// 备用地址1的类型，1为ip 2为域名
    var ipBackup02Type:Int?
    /// 手动切换的地址
    var manualBackup:String?
    /// 手动切换的地址的状态，0正常，1异常
    var manualBackupStatus:Int?
    /// 手动切换的地址的类型，1为ip 2为域名
    var manualBackupType:Int?
    /// 监控状况 开启监控 2，暂停监控 4
    var monitorEnable:Int?
    /// 监控频率，单位秒
    var monitorFreq:Int?
    /// 监控端口
    var monitorPort:Int?
    /// 不做任何修改0，强制暂停解析记录1，自动切换到备用地址2
    var monitorRule:Int?
    /// 监控路径
    var monitorUri:String?
    /// 邮箱地址
    var notifyEmail:String?
    /// 不发送邮件0， 发送邮件1
    var notifyEmailEnable:Int?
    /// 不发送通知栏 0， 发送通知栏 1
    var notifyMsgBarEnable:Int?
    /// 手机号码
    var notifySms:String?
    /// 不发送短信 0， 发送短信 1
    var notifySmsEnable:Int?
    /// https 0，https 1
    var protocolValue:Int?
    /// 0自动恢复 1手动恢复
    var stopRecoverRule:Int?
    /// 子域名
    var subDomainName:String?
    /// 0自动恢复至主host 1手动恢复至主host
    var switchRecoverRule:Int?
    /// 1为A记录，2为CNAME
    var type:Int?
    /// 使用记录，host_value 0，ip_backup_01 1，ip_backup_02 2，cname_backup 3
    var usedType:Int?



    public override init(){
            super.init()
    }

    enum MonitorCodingKeys: String, CodingKey {
        case alarmLimit
        case canRecover
        case canSwitch
        case clusters
        case domainName
        case hostStatus
        case hostValue
        case id
        case ipBackup01
        case ipBackup01Status
        case ipBackup01Type
        case ipBackup02
        case ipBackup02Status
        case ipBackup02Type
        case manualBackup
        case manualBackupStatus
        case manualBackupType
        case monitorEnable
        case monitorFreq
        case monitorPort
        case monitorRule
        case monitorUri
        case notifyEmail
        case notifyEmailEnable
        case notifyMsgBarEnable
        case notifySms
        case notifySmsEnable
        case protocolValue = "protocol"
        case stopRecoverRule
        case subDomainName
        case switchRecoverRule
        case type
        case usedType
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: MonitorCodingKeys.self)
        if decoderContainer.contains(.alarmLimit)
        {
            self.alarmLimit = try decoderContainer.decode(Int?.self, forKey: .alarmLimit)
        }
        if decoderContainer.contains(.canRecover)
        {
            self.canRecover = try decoderContainer.decode(Bool?.self, forKey: .canRecover)
        }
        if decoderContainer.contains(.canSwitch)
        {
            self.canSwitch = try decoderContainer.decode(Bool?.self, forKey: .canSwitch)
        }
        if decoderContainer.contains(.clusters)
        {
            self.clusters = try decoderContainer.decode(String?.self, forKey: .clusters)
        }
        if decoderContainer.contains(.domainName)
        {
            self.domainName = try decoderContainer.decode(String?.self, forKey: .domainName)
        }
        if decoderContainer.contains(.hostStatus)
        {
            self.hostStatus = try decoderContainer.decode(Int?.self, forKey: .hostStatus)
        }
        if decoderContainer.contains(.hostValue)
        {
            self.hostValue = try decoderContainer.decode(String?.self, forKey: .hostValue)
        }
        if decoderContainer.contains(.id)
        {
            self.id = try decoderContainer.decode(Int?.self, forKey: .id)
        }
        if decoderContainer.contains(.ipBackup01)
        {
            self.ipBackup01 = try decoderContainer.decode(String?.self, forKey: .ipBackup01)
        }
        if decoderContainer.contains(.ipBackup01Status)
        {
            self.ipBackup01Status = try decoderContainer.decode(Int?.self, forKey: .ipBackup01Status)
        }
        if decoderContainer.contains(.ipBackup01Type)
        {
            self.ipBackup01Type = try decoderContainer.decode(Int?.self, forKey: .ipBackup01Type)
        }
        if decoderContainer.contains(.ipBackup02)
        {
            self.ipBackup02 = try decoderContainer.decode(String?.self, forKey: .ipBackup02)
        }
        if decoderContainer.contains(.ipBackup02Status)
        {
            self.ipBackup02Status = try decoderContainer.decode(Int?.self, forKey: .ipBackup02Status)
        }
        if decoderContainer.contains(.ipBackup02Type)
        {
            self.ipBackup02Type = try decoderContainer.decode(Int?.self, forKey: .ipBackup02Type)
        }
        if decoderContainer.contains(.manualBackup)
        {
            self.manualBackup = try decoderContainer.decode(String?.self, forKey: .manualBackup)
        }
        if decoderContainer.contains(.manualBackupStatus)
        {
            self.manualBackupStatus = try decoderContainer.decode(Int?.self, forKey: .manualBackupStatus)
        }
        if decoderContainer.contains(.manualBackupType)
        {
            self.manualBackupType = try decoderContainer.decode(Int?.self, forKey: .manualBackupType)
        }
        if decoderContainer.contains(.monitorEnable)
        {
            self.monitorEnable = try decoderContainer.decode(Int?.self, forKey: .monitorEnable)
        }
        if decoderContainer.contains(.monitorFreq)
        {
            self.monitorFreq = try decoderContainer.decode(Int?.self, forKey: .monitorFreq)
        }
        if decoderContainer.contains(.monitorPort)
        {
            self.monitorPort = try decoderContainer.decode(Int?.self, forKey: .monitorPort)
        }
        if decoderContainer.contains(.monitorRule)
        {
            self.monitorRule = try decoderContainer.decode(Int?.self, forKey: .monitorRule)
        }
        if decoderContainer.contains(.monitorUri)
        {
            self.monitorUri = try decoderContainer.decode(String?.self, forKey: .monitorUri)
        }
        if decoderContainer.contains(.notifyEmail)
        {
            self.notifyEmail = try decoderContainer.decode(String?.self, forKey: .notifyEmail)
        }
        if decoderContainer.contains(.notifyEmailEnable)
        {
            self.notifyEmailEnable = try decoderContainer.decode(Int?.self, forKey: .notifyEmailEnable)
        }
        if decoderContainer.contains(.notifyMsgBarEnable)
        {
            self.notifyMsgBarEnable = try decoderContainer.decode(Int?.self, forKey: .notifyMsgBarEnable)
        }
        if decoderContainer.contains(.notifySms)
        {
            self.notifySms = try decoderContainer.decode(String?.self, forKey: .notifySms)
        }
        if decoderContainer.contains(.notifySmsEnable)
        {
            self.notifySmsEnable = try decoderContainer.decode(Int?.self, forKey: .notifySmsEnable)
        }
        if decoderContainer.contains(.protocolValue)
        {
            self.protocolValue = try decoderContainer.decode(Int?.self, forKey: .protocolValue)
        }
        if decoderContainer.contains(.stopRecoverRule)
        {
            self.stopRecoverRule = try decoderContainer.decode(Int?.self, forKey: .stopRecoverRule)
        }
        if decoderContainer.contains(.subDomainName)
        {
            self.subDomainName = try decoderContainer.decode(String?.self, forKey: .subDomainName)
        }
        if decoderContainer.contains(.switchRecoverRule)
        {
            self.switchRecoverRule = try decoderContainer.decode(Int?.self, forKey: .switchRecoverRule)
        }
        if decoderContainer.contains(.type)
        {
            self.type = try decoderContainer.decode(Int?.self, forKey: .type)
        }
        if decoderContainer.contains(.usedType)
        {
            self.usedType = try decoderContainer.decode(Int?.self, forKey: .usedType)
        }
    }
}
public extension Monitor{
    public func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: MonitorCodingKeys.self)
         try encoderContainer.encode(alarmLimit, forKey: .alarmLimit)
         try encoderContainer.encode(canRecover, forKey: .canRecover)
         try encoderContainer.encode(canSwitch, forKey: .canSwitch)
         try encoderContainer.encode(clusters, forKey: .clusters)
         try encoderContainer.encode(domainName, forKey: .domainName)
         try encoderContainer.encode(hostStatus, forKey: .hostStatus)
         try encoderContainer.encode(hostValue, forKey: .hostValue)
         try encoderContainer.encode(id, forKey: .id)
         try encoderContainer.encode(ipBackup01, forKey: .ipBackup01)
         try encoderContainer.encode(ipBackup01Status, forKey: .ipBackup01Status)
         try encoderContainer.encode(ipBackup01Type, forKey: .ipBackup01Type)
         try encoderContainer.encode(ipBackup02, forKey: .ipBackup02)
         try encoderContainer.encode(ipBackup02Status, forKey: .ipBackup02Status)
         try encoderContainer.encode(ipBackup02Type, forKey: .ipBackup02Type)
         try encoderContainer.encode(manualBackup, forKey: .manualBackup)
         try encoderContainer.encode(manualBackupStatus, forKey: .manualBackupStatus)
         try encoderContainer.encode(manualBackupType, forKey: .manualBackupType)
         try encoderContainer.encode(monitorEnable, forKey: .monitorEnable)
         try encoderContainer.encode(monitorFreq, forKey: .monitorFreq)
         try encoderContainer.encode(monitorPort, forKey: .monitorPort)
         try encoderContainer.encode(monitorRule, forKey: .monitorRule)
         try encoderContainer.encode(monitorUri, forKey: .monitorUri)
         try encoderContainer.encode(notifyEmail, forKey: .notifyEmail)
         try encoderContainer.encode(notifyEmailEnable, forKey: .notifyEmailEnable)
         try encoderContainer.encode(notifyMsgBarEnable, forKey: .notifyMsgBarEnable)
         try encoderContainer.encode(notifySms, forKey: .notifySms)
         try encoderContainer.encode(notifySmsEnable, forKey: .notifySmsEnable)
         try encoderContainer.encode(protocolValue, forKey: .protocolValue)
         try encoderContainer.encode(stopRecoverRule, forKey: .stopRecoverRule)
         try encoderContainer.encode(subDomainName, forKey: .subDomainName)
         try encoderContainer.encode(switchRecoverRule, forKey: .switchRecoverRule)
         try encoderContainer.encode(type, forKey: .type)
         try encoderContainer.encode(usedType, forKey: .usedType)
    }
}

/* Copyright 2018 JDCLOUD.COM

   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at

     http:#www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.

   
   

   
   Contact: 

   NOTE: This class is auto generated by the jdcloud code generator program.
 */


import Foundation

///  updateMonitor
@objc(UpdateMonitor)
public class UpdateMonitor:NSObject,Codable{
    /// 连续几次触发报警
    /// Required:true
    var alarmLimit:Int
    /// 监控项ID
    /// Required:true
    var id:Int
    /// 备用地址1
    /// Required:true
    var ipBackup01:String
    /// 备用地址2
    /// Required:true
    var ipBackup02:String
    /// 监控状况 开启监控 2，暂停监控 4
    /// Required:true
    var monitorEnable:Int
    /// 监控频率，单位秒
    /// Required:true
    var monitorFreq:Int
    /// 监控端口
    /// Required:true
    var monitorPort:Int
    /// 不做任何修改0，强制暂停解析记录1，自动切换到备用地址2
    /// Required:true
    var monitorRule:Int
    /// 监控路径
    /// Required:true
    var monitorUri:String
    /// 不发送邮件0， 发送邮件1
    /// Required:true
    var notifyEmailEnable:Int
    /// 不发送通知栏 0， 发送通知栏 1
    /// Required:true
    var notifyMsgBarEnable:Int
    /// 不发送短信 0， 发送短信 1
    var notifySmsEnable:Int?
    /// https 0，https 1
    /// Required:true
    var protocolValue:Int
    /// 0自动恢复 1手动恢复
    /// Required:true
    var stopRecoverRule:Int
    /// 0自动恢复至主host 1手动恢复至主host
    /// Required:true
    var switchRecoverRule:Int



    public  init(alarmLimit:Int,id:Int,ipBackup01:String,ipBackup02:String,monitorEnable:Int,monitorFreq:Int,monitorPort:Int,monitorRule:Int,monitorUri:String,notifyEmailEnable:Int,notifyMsgBarEnable:Int,protocolValue:Int,stopRecoverRule:Int,switchRecoverRule:Int){
             self.alarmLimit = alarmLimit
             self.id = id
             self.ipBackup01 = ipBackup01
             self.ipBackup02 = ipBackup02
             self.monitorEnable = monitorEnable
             self.monitorFreq = monitorFreq
             self.monitorPort = monitorPort
             self.monitorRule = monitorRule
             self.monitorUri = monitorUri
             self.notifyEmailEnable = notifyEmailEnable
             self.notifyMsgBarEnable = notifyMsgBarEnable
             self.protocolValue = protocolValue
             self.stopRecoverRule = stopRecoverRule
             self.switchRecoverRule = switchRecoverRule
    }

    enum UpdateMonitorCodingKeys: String, CodingKey {
        case alarmLimit
        case id
        case ipBackup01
        case ipBackup02
        case monitorEnable
        case monitorFreq
        case monitorPort
        case monitorRule
        case monitorUri
        case notifyEmailEnable
        case notifyMsgBarEnable
        case notifySmsEnable
        case protocolValue = "protocol"
        case stopRecoverRule
        case switchRecoverRule
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: UpdateMonitorCodingKeys.self)
        self.alarmLimit = try decoderContainer.decode(Int.self, forKey: .alarmLimit)
        self.id = try decoderContainer.decode(Int.self, forKey: .id)
        self.ipBackup01 = try decoderContainer.decode(String.self, forKey: .ipBackup01)
        self.ipBackup02 = try decoderContainer.decode(String.self, forKey: .ipBackup02)
        self.monitorEnable = try decoderContainer.decode(Int.self, forKey: .monitorEnable)
        self.monitorFreq = try decoderContainer.decode(Int.self, forKey: .monitorFreq)
        self.monitorPort = try decoderContainer.decode(Int.self, forKey: .monitorPort)
        self.monitorRule = try decoderContainer.decode(Int.self, forKey: .monitorRule)
        self.monitorUri = try decoderContainer.decode(String.self, forKey: .monitorUri)
        self.notifyEmailEnable = try decoderContainer.decode(Int.self, forKey: .notifyEmailEnable)
        self.notifyMsgBarEnable = try decoderContainer.decode(Int.self, forKey: .notifyMsgBarEnable)
        if decoderContainer.contains(.notifySmsEnable)
        {
            self.notifySmsEnable = try decoderContainer.decode(Int?.self, forKey: .notifySmsEnable)
        }
        self.protocolValue = try decoderContainer.decode(Int.self, forKey: .protocolValue)
        self.stopRecoverRule = try decoderContainer.decode(Int.self, forKey: .stopRecoverRule)
        self.switchRecoverRule = try decoderContainer.decode(Int.self, forKey: .switchRecoverRule)
    }
}
public extension UpdateMonitor{
    public func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: UpdateMonitorCodingKeys.self)
         try encoderContainer.encode(alarmLimit, forKey: .alarmLimit)
         try encoderContainer.encode(id, forKey: .id)
         try encoderContainer.encode(ipBackup01, forKey: .ipBackup01)
         try encoderContainer.encode(ipBackup02, forKey: .ipBackup02)
         try encoderContainer.encode(monitorEnable, forKey: .monitorEnable)
         try encoderContainer.encode(monitorFreq, forKey: .monitorFreq)
         try encoderContainer.encode(monitorPort, forKey: .monitorPort)
         try encoderContainer.encode(monitorRule, forKey: .monitorRule)
         try encoderContainer.encode(monitorUri, forKey: .monitorUri)
         try encoderContainer.encode(notifyEmailEnable, forKey: .notifyEmailEnable)
         try encoderContainer.encode(notifyMsgBarEnable, forKey: .notifyMsgBarEnable)
         try encoderContainer.encode(notifySmsEnable, forKey: .notifySmsEnable)
         try encoderContainer.encode(protocolValue, forKey: .protocolValue)
         try encoderContainer.encode(stopRecoverRule, forKey: .stopRecoverRule)
         try encoderContainer.encode(switchRecoverRule, forKey: .switchRecoverRule)
    }
}

/* Copyright 2018 JDCLOUD.COM

   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at

     http:#www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.

   云物理服务器
   云物理服务器地域操作相关的接口

   OpenAPI spec version: v1
   Contact: 

   NOTE: This class is auto generated by the jdcloud code generator program.
 */


import Foundation
import JDCloudSDKCharge
///  route
public class Route:NSObject,Codable{
    /// 目标网段
    var destinationCidr:String?
    /// 下一跳类型
    var nextHopType:String?
    /// 下一跳
    var nextHop:String?



    public override init(){
            super.init()
    }

    enum RouteCodingKeys: String, CodingKey {
        case destinationCidr
        case nextHopType
        case nextHop
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: RouteCodingKeys.self)
        if decoderContainer.contains(.destinationCidr)
        {
            self.destinationCidr = try decoderContainer.decode(String?.self, forKey: .destinationCidr)
        }
        if decoderContainer.contains(.nextHopType)
        {
            self.nextHopType = try decoderContainer.decode(String?.self, forKey: .nextHopType)
        }
        if decoderContainer.contains(.nextHop)
        {
            self.nextHop = try decoderContainer.decode(String?.self, forKey: .nextHop)
        }
    }
}
public extension Route{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: RouteCodingKeys.self)
         try encoderContainer.encode(destinationCidr, forKey: .destinationCidr)
         try encoderContainer.encode(nextHopType, forKey: .nextHopType)
         try encoderContainer.encode(nextHop, forKey: .nextHop)
    }
}
///  routeTable
public class RouteTable:NSObject,Codable{
    /// 路由表ID
    var routeTableId:String?
    /// 地域
    var region:String?
    /// 私有网络ID
    var vpcId:String?
    /// 名称
    var name:String?
    /// 创建时间
    var createTime:String?
    /// 路由规则
    var routes:[Route?]?



    public override init(){
            super.init()
    }

    enum RouteTableCodingKeys: String, CodingKey {
        case routeTableId
        case region
        case vpcId
        case name
        case createTime
        case routes
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: RouteTableCodingKeys.self)
        if decoderContainer.contains(.routeTableId)
        {
            self.routeTableId = try decoderContainer.decode(String?.self, forKey: .routeTableId)
        }
        if decoderContainer.contains(.region)
        {
            self.region = try decoderContainer.decode(String?.self, forKey: .region)
        }
        if decoderContainer.contains(.vpcId)
        {
            self.vpcId = try decoderContainer.decode(String?.self, forKey: .vpcId)
        }
        if decoderContainer.contains(.name)
        {
            self.name = try decoderContainer.decode(String?.self, forKey: .name)
        }
        if decoderContainer.contains(.createTime)
        {
            self.createTime = try decoderContainer.decode(String?.self, forKey: .createTime)
        }
        if decoderContainer.contains(.routes)
        {
            self.routes = try decoderContainer.decode([Route?]?.self, forKey: .routes)
        }
    }
}
public extension RouteTable{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: RouteTableCodingKeys.self)
         try encoderContainer.encode(routeTableId, forKey: .routeTableId)
         try encoderContainer.encode(region, forKey: .region)
         try encoderContainer.encode(vpcId, forKey: .vpcId)
         try encoderContainer.encode(name, forKey: .name)
         try encoderContainer.encode(createTime, forKey: .createTime)
         try encoderContainer.encode(routes, forKey: .routes)
    }
}
///  listenerSpec
public class ListenerSpec:NSObject,Codable{
    /// 负载均衡实例ID
    /// Required:true
    var loadBalancerId:String
    /// 协议, 如TCP
    /// Required:true
    var protocolValue:String
    /// 端口1-65535
    /// Required:true
    var port:Int
    /// 调度算法，取值wrr（加权轮询）|wlc（加权最小连接数）|conhash（源IP）)
    /// Required:true
    var algorithm:String
    /// 是否开启会话保持，取值on|off
    /// Required:true
    var stickySession:String
    /// 是否获取真实ip，取值on|off
    var realIp:String?
    /// 名称
    /// Required:true
    var name:String
    /// 描述
    var descriptionValue:String?
    /// 是否开启健康检查，取值on|off
    /// Required:true
    var healthCheck:String
    /// 健康检查响应的最大超时时间，单位s
    var healthCheckTimeout:Int?
    /// 健康检查响应的最大间隔时间，单位s
    var healthCheckInterval:Int?
    /// 健康检查结果为success的阈值
    var healthyThreshold:Int?
    /// 健康检查结果为fail的阈值
    var unhealthyThreshold:Int?
    /// 服务器组id
    var serverGroupId:String?



    public  init(loadBalancerId:String,protocolValue:String,port:Int,algorithm:String,stickySession:String,name:String,healthCheck:String){
             self.loadBalancerId = loadBalancerId
             self.protocolValue = protocolValue
             self.port = port
             self.algorithm = algorithm
             self.stickySession = stickySession
             self.name = name
             self.healthCheck = healthCheck
    }

    enum ListenerSpecCodingKeys: String, CodingKey {
        case loadBalancerId
        case protocolValue = "protocol"
        case port
        case algorithm
        case stickySession
        case realIp
        case name
        case descriptionValue = "description"
        case healthCheck
        case healthCheckTimeout
        case healthCheckInterval
        case healthyThreshold
        case unhealthyThreshold
        case serverGroupId
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: ListenerSpecCodingKeys.self)
        self.loadBalancerId = try decoderContainer.decode(String.self, forKey: .loadBalancerId)
        self.protocolValue = try decoderContainer.decode(String.self, forKey: .protocolValue)
        self.port = try decoderContainer.decode(Int.self, forKey: .port)
        self.algorithm = try decoderContainer.decode(String.self, forKey: .algorithm)
        self.stickySession = try decoderContainer.decode(String.self, forKey: .stickySession)
        if decoderContainer.contains(.realIp)
        {
            self.realIp = try decoderContainer.decode(String?.self, forKey: .realIp)
        }
        self.name = try decoderContainer.decode(String.self, forKey: .name)
        if decoderContainer.contains(.descriptionValue)
        {
            self.descriptionValue = try decoderContainer.decode(String?.self, forKey: .descriptionValue)
        }
        self.healthCheck = try decoderContainer.decode(String.self, forKey: .healthCheck)
        if decoderContainer.contains(.healthCheckTimeout)
        {
            self.healthCheckTimeout = try decoderContainer.decode(Int?.self, forKey: .healthCheckTimeout)
        }
        if decoderContainer.contains(.healthCheckInterval)
        {
            self.healthCheckInterval = try decoderContainer.decode(Int?.self, forKey: .healthCheckInterval)
        }
        if decoderContainer.contains(.healthyThreshold)
        {
            self.healthyThreshold = try decoderContainer.decode(Int?.self, forKey: .healthyThreshold)
        }
        if decoderContainer.contains(.unhealthyThreshold)
        {
            self.unhealthyThreshold = try decoderContainer.decode(Int?.self, forKey: .unhealthyThreshold)
        }
        if decoderContainer.contains(.serverGroupId)
        {
            self.serverGroupId = try decoderContainer.decode(String?.self, forKey: .serverGroupId)
        }
    }
}
public extension ListenerSpec{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: ListenerSpecCodingKeys.self)
         try encoderContainer.encode(loadBalancerId, forKey: .loadBalancerId)
         try encoderContainer.encode(protocolValue, forKey: .protocolValue)
         try encoderContainer.encode(port, forKey: .port)
         try encoderContainer.encode(algorithm, forKey: .algorithm)
         try encoderContainer.encode(stickySession, forKey: .stickySession)
         try encoderContainer.encode(realIp, forKey: .realIp)
         try encoderContainer.encode(name, forKey: .name)
         try encoderContainer.encode(descriptionValue, forKey: .descriptionValue)
         try encoderContainer.encode(healthCheck, forKey: .healthCheck)
         try encoderContainer.encode(healthCheckTimeout, forKey: .healthCheckTimeout)
         try encoderContainer.encode(healthCheckInterval, forKey: .healthCheckInterval)
         try encoderContainer.encode(healthyThreshold, forKey: .healthyThreshold)
         try encoderContainer.encode(unhealthyThreshold, forKey: .unhealthyThreshold)
         try encoderContainer.encode(serverGroupId, forKey: .serverGroupId)
    }
}
///  listener
public class Listener:NSObject,Codable{
    /// 监听器ID
    var listenerId:String?
    /// 负载均衡ID
    var loadBalancerId:String?
    /// 协议
    var protocolValue:String?
    /// 端口
    var port:Int?
    /// 调度算法
    var algorithm:String?
    /// 会话保持状态，取值on|off
    var stickySession:String?
    /// 获取真实ip
    var realIp:String?
    /// 状态
    var status:String?
    /// 名称
    var name:String?
    /// 描述
    var descriptionValue:String?
    /// 健康检查状态，取值on|off
    var healthCheck:String?
    /// 健康检查响应的最大超时时间，单位s
    var healthCheckTimeout:Int?
    /// 健康检查响应的最大间隔时间，单位s
    var healthCheckInterval:Int?
    /// 健康检查结果为success的阈值
    var healthyThreshold:Int?
    /// 健康检查结果为fail的阈值
    var unhealthyThreshold:Int?
    /// 健康检查ip
    var healthCheckIp:String?
    /// 服务器组id
    var serverGroupId:String?



    public override init(){
            super.init()
    }

    enum ListenerCodingKeys: String, CodingKey {
        case listenerId
        case loadBalancerId
        case protocolValue = "protocol"
        case port
        case algorithm
        case stickySession
        case realIp
        case status
        case name
        case descriptionValue = "description"
        case healthCheck
        case healthCheckTimeout
        case healthCheckInterval
        case healthyThreshold
        case unhealthyThreshold
        case healthCheckIp
        case serverGroupId
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: ListenerCodingKeys.self)
        if decoderContainer.contains(.listenerId)
        {
            self.listenerId = try decoderContainer.decode(String?.self, forKey: .listenerId)
        }
        if decoderContainer.contains(.loadBalancerId)
        {
            self.loadBalancerId = try decoderContainer.decode(String?.self, forKey: .loadBalancerId)
        }
        if decoderContainer.contains(.protocolValue)
        {
            self.protocolValue = try decoderContainer.decode(String?.self, forKey: .protocolValue)
        }
        if decoderContainer.contains(.port)
        {
            self.port = try decoderContainer.decode(Int?.self, forKey: .port)
        }
        if decoderContainer.contains(.algorithm)
        {
            self.algorithm = try decoderContainer.decode(String?.self, forKey: .algorithm)
        }
        if decoderContainer.contains(.stickySession)
        {
            self.stickySession = try decoderContainer.decode(String?.self, forKey: .stickySession)
        }
        if decoderContainer.contains(.realIp)
        {
            self.realIp = try decoderContainer.decode(String?.self, forKey: .realIp)
        }
        if decoderContainer.contains(.status)
        {
            self.status = try decoderContainer.decode(String?.self, forKey: .status)
        }
        if decoderContainer.contains(.name)
        {
            self.name = try decoderContainer.decode(String?.self, forKey: .name)
        }
        if decoderContainer.contains(.descriptionValue)
        {
            self.descriptionValue = try decoderContainer.decode(String?.self, forKey: .descriptionValue)
        }
        if decoderContainer.contains(.healthCheck)
        {
            self.healthCheck = try decoderContainer.decode(String?.self, forKey: .healthCheck)
        }
        if decoderContainer.contains(.healthCheckTimeout)
        {
            self.healthCheckTimeout = try decoderContainer.decode(Int?.self, forKey: .healthCheckTimeout)
        }
        if decoderContainer.contains(.healthCheckInterval)
        {
            self.healthCheckInterval = try decoderContainer.decode(Int?.self, forKey: .healthCheckInterval)
        }
        if decoderContainer.contains(.healthyThreshold)
        {
            self.healthyThreshold = try decoderContainer.decode(Int?.self, forKey: .healthyThreshold)
        }
        if decoderContainer.contains(.unhealthyThreshold)
        {
            self.unhealthyThreshold = try decoderContainer.decode(Int?.self, forKey: .unhealthyThreshold)
        }
        if decoderContainer.contains(.healthCheckIp)
        {
            self.healthCheckIp = try decoderContainer.decode(String?.self, forKey: .healthCheckIp)
        }
        if decoderContainer.contains(.serverGroupId)
        {
            self.serverGroupId = try decoderContainer.decode(String?.self, forKey: .serverGroupId)
        }
    }
}
public extension Listener{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: ListenerCodingKeys.self)
         try encoderContainer.encode(listenerId, forKey: .listenerId)
         try encoderContainer.encode(loadBalancerId, forKey: .loadBalancerId)
         try encoderContainer.encode(protocolValue, forKey: .protocolValue)
         try encoderContainer.encode(port, forKey: .port)
         try encoderContainer.encode(algorithm, forKey: .algorithm)
         try encoderContainer.encode(stickySession, forKey: .stickySession)
         try encoderContainer.encode(realIp, forKey: .realIp)
         try encoderContainer.encode(status, forKey: .status)
         try encoderContainer.encode(name, forKey: .name)
         try encoderContainer.encode(descriptionValue, forKey: .descriptionValue)
         try encoderContainer.encode(healthCheck, forKey: .healthCheck)
         try encoderContainer.encode(healthCheckTimeout, forKey: .healthCheckTimeout)
         try encoderContainer.encode(healthCheckInterval, forKey: .healthCheckInterval)
         try encoderContainer.encode(healthyThreshold, forKey: .healthyThreshold)
         try encoderContainer.encode(unhealthyThreshold, forKey: .unhealthyThreshold)
         try encoderContainer.encode(healthCheckIp, forKey: .healthCheckIp)
         try encoderContainer.encode(serverGroupId, forKey: .serverGroupId)
    }
}
///  serverSpec
public class ServerSpec:NSObject,Codable{
    /// 后端云物理服务器ID
    var instanceId:String?
    /// 端口
    var port:Int?
    /// 后端云物理服务器权重
    var weight:Int?



    public override init(){
            super.init()
    }

    enum ServerSpecCodingKeys: String, CodingKey {
        case instanceId
        case port
        case weight
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: ServerSpecCodingKeys.self)
        if decoderContainer.contains(.instanceId)
        {
            self.instanceId = try decoderContainer.decode(String?.self, forKey: .instanceId)
        }
        if decoderContainer.contains(.port)
        {
            self.port = try decoderContainer.decode(Int?.self, forKey: .port)
        }
        if decoderContainer.contains(.weight)
        {
            self.weight = try decoderContainer.decode(Int?.self, forKey: .weight)
        }
    }
}
public extension ServerSpec{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: ServerSpecCodingKeys.self)
         try encoderContainer.encode(instanceId, forKey: .instanceId)
         try encoderContainer.encode(port, forKey: .port)
         try encoderContainer.encode(weight, forKey: .weight)
    }
}
///  server
public class Server:NSObject,Codable{
    /// 服务器ID
    var serverId:String?
    /// 资源类型
    var instanceType:String?
    /// 实例名称
    var instanceName:String?
    /// 后端云物理服务器ID
    var instanceId:String?
    /// 可用区
    var az:String?
    /// 内网Ip
    var privateIp:String?
    /// 端口
    var port:Int?
    /// 后端云物理服务器权重
    var weight:Int?
    /// 状态
    var status:String?
    /// 健康状态
    var healthyStatus:String?



    public override init(){
            super.init()
    }

    enum ServerCodingKeys: String, CodingKey {
        case serverId
        case instanceType
        case instanceName
        case instanceId
        case az
        case privateIp
        case port
        case weight
        case status
        case healthyStatus
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: ServerCodingKeys.self)
        if decoderContainer.contains(.serverId)
        {
            self.serverId = try decoderContainer.decode(String?.self, forKey: .serverId)
        }
        if decoderContainer.contains(.instanceType)
        {
            self.instanceType = try decoderContainer.decode(String?.self, forKey: .instanceType)
        }
        if decoderContainer.contains(.instanceName)
        {
            self.instanceName = try decoderContainer.decode(String?.self, forKey: .instanceName)
        }
        if decoderContainer.contains(.instanceId)
        {
            self.instanceId = try decoderContainer.decode(String?.self, forKey: .instanceId)
        }
        if decoderContainer.contains(.az)
        {
            self.az = try decoderContainer.decode(String?.self, forKey: .az)
        }
        if decoderContainer.contains(.privateIp)
        {
            self.privateIp = try decoderContainer.decode(String?.self, forKey: .privateIp)
        }
        if decoderContainer.contains(.port)
        {
            self.port = try decoderContainer.decode(Int?.self, forKey: .port)
        }
        if decoderContainer.contains(.weight)
        {
            self.weight = try decoderContainer.decode(Int?.self, forKey: .weight)
        }
        if decoderContainer.contains(.status)
        {
            self.status = try decoderContainer.decode(String?.self, forKey: .status)
        }
        if decoderContainer.contains(.healthyStatus)
        {
            self.healthyStatus = try decoderContainer.decode(String?.self, forKey: .healthyStatus)
        }
    }
}
public extension Server{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: ServerCodingKeys.self)
         try encoderContainer.encode(serverId, forKey: .serverId)
         try encoderContainer.encode(instanceType, forKey: .instanceType)
         try encoderContainer.encode(instanceName, forKey: .instanceName)
         try encoderContainer.encode(instanceId, forKey: .instanceId)
         try encoderContainer.encode(az, forKey: .az)
         try encoderContainer.encode(privateIp, forKey: .privateIp)
         try encoderContainer.encode(port, forKey: .port)
         try encoderContainer.encode(weight, forKey: .weight)
         try encoderContainer.encode(status, forKey: .status)
         try encoderContainer.encode(healthyStatus, forKey: .healthyStatus)
    }
}
///  keypair
public class Keypair:NSObject,Codable{
    /// 密钥对id
    var keypairId:String?
    /// 地域
    var region:String?
    /// 密钥对名称
    var name:String?
    /// 公钥
    var publicKey:String?
    /// 指纹
    var fingerPrint:String?
    /// 创建时间
    var createTime:String?
    /// 更新时间
    var updateTime:String?



    public override init(){
            super.init()
    }

    enum KeypairCodingKeys: String, CodingKey {
        case keypairId
        case region
        case name
        case publicKey
        case fingerPrint
        case createTime
        case updateTime
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: KeypairCodingKeys.self)
        if decoderContainer.contains(.keypairId)
        {
            self.keypairId = try decoderContainer.decode(String?.self, forKey: .keypairId)
        }
        if decoderContainer.contains(.region)
        {
            self.region = try decoderContainer.decode(String?.self, forKey: .region)
        }
        if decoderContainer.contains(.name)
        {
            self.name = try decoderContainer.decode(String?.self, forKey: .name)
        }
        if decoderContainer.contains(.publicKey)
        {
            self.publicKey = try decoderContainer.decode(String?.self, forKey: .publicKey)
        }
        if decoderContainer.contains(.fingerPrint)
        {
            self.fingerPrint = try decoderContainer.decode(String?.self, forKey: .fingerPrint)
        }
        if decoderContainer.contains(.createTime)
        {
            self.createTime = try decoderContainer.decode(String?.self, forKey: .createTime)
        }
        if decoderContainer.contains(.updateTime)
        {
            self.updateTime = try decoderContainer.decode(String?.self, forKey: .updateTime)
        }
    }
}
public extension Keypair{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: KeypairCodingKeys.self)
         try encoderContainer.encode(keypairId, forKey: .keypairId)
         try encoderContainer.encode(region, forKey: .region)
         try encoderContainer.encode(name, forKey: .name)
         try encoderContainer.encode(publicKey, forKey: .publicKey)
         try encoderContainer.encode(fingerPrint, forKey: .fingerPrint)
         try encoderContainer.encode(createTime, forKey: .createTime)
         try encoderContainer.encode(updateTime, forKey: .updateTime)
    }
}
///  subnetSpec
public class SubnetSpec:NSObject,Codable{
    /// 可用区, 如 cn-north-1a
    /// Required:true
    var az:String
    /// 私有网络ID
    /// Required:true
    var vpcId:String
    /// 子网的网络范围
    /// Required:true
    var cidr:String
    /// 名称
    /// Required:true
    var name:String
    /// 描述
    /// Required:true
    var descriptionValue:String



    public  init(az:String,vpcId:String,cidr:String,name:String,descriptionValue:String){
             self.az = az
             self.vpcId = vpcId
             self.cidr = cidr
             self.name = name
             self.descriptionValue = descriptionValue
    }

    enum SubnetSpecCodingKeys: String, CodingKey {
        case az
        case vpcId
        case cidr
        case name
        case descriptionValue = "description"
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: SubnetSpecCodingKeys.self)
        self.az = try decoderContainer.decode(String.self, forKey: .az)
        self.vpcId = try decoderContainer.decode(String.self, forKey: .vpcId)
        self.cidr = try decoderContainer.decode(String.self, forKey: .cidr)
        self.name = try decoderContainer.decode(String.self, forKey: .name)
        self.descriptionValue = try decoderContainer.decode(String.self, forKey: .descriptionValue)
    }
}
public extension SubnetSpec{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: SubnetSpecCodingKeys.self)
         try encoderContainer.encode(az, forKey: .az)
         try encoderContainer.encode(vpcId, forKey: .vpcId)
         try encoderContainer.encode(cidr, forKey: .cidr)
         try encoderContainer.encode(name, forKey: .name)
         try encoderContainer.encode(descriptionValue, forKey: .descriptionValue)
    }
}
///  subnet
public class Subnet:NSObject,Codable{
    /// 地域代码, 如cn-east-1
    var region:String?
    /// 可用区, 如cn-east-1a
    var az:String?
    /// 子网ID
    var subnetId:String?
    /// 子网名称
    var name:String?
    /// 子网CIDR
    var cidr:String?
    /// 私有网络Id
    var vpcId:String?
    /// 私有网络名称
    var vpcName:String?
    /// 可用ip数量
    var availableIpCount:Int?
    /// 总ip数量
    var totalIpCount:Int?
    /// 网络类型
    var networkType:String?
    /// 描述
    var descriptionValue:String?
    /// 创建时间
    var createTime:String?



    public override init(){
            super.init()
    }

    enum SubnetCodingKeys: String, CodingKey {
        case region
        case az
        case subnetId
        case name
        case cidr
        case vpcId
        case vpcName
        case availableIpCount
        case totalIpCount
        case networkType
        case descriptionValue = "description"
        case createTime
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: SubnetCodingKeys.self)
        if decoderContainer.contains(.region)
        {
            self.region = try decoderContainer.decode(String?.self, forKey: .region)
        }
        if decoderContainer.contains(.az)
        {
            self.az = try decoderContainer.decode(String?.self, forKey: .az)
        }
        if decoderContainer.contains(.subnetId)
        {
            self.subnetId = try decoderContainer.decode(String?.self, forKey: .subnetId)
        }
        if decoderContainer.contains(.name)
        {
            self.name = try decoderContainer.decode(String?.self, forKey: .name)
        }
        if decoderContainer.contains(.cidr)
        {
            self.cidr = try decoderContainer.decode(String?.self, forKey: .cidr)
        }
        if decoderContainer.contains(.vpcId)
        {
            self.vpcId = try decoderContainer.decode(String?.self, forKey: .vpcId)
        }
        if decoderContainer.contains(.vpcName)
        {
            self.vpcName = try decoderContainer.decode(String?.self, forKey: .vpcName)
        }
        if decoderContainer.contains(.availableIpCount)
        {
            self.availableIpCount = try decoderContainer.decode(Int?.self, forKey: .availableIpCount)
        }
        if decoderContainer.contains(.totalIpCount)
        {
            self.totalIpCount = try decoderContainer.decode(Int?.self, forKey: .totalIpCount)
        }
        if decoderContainer.contains(.networkType)
        {
            self.networkType = try decoderContainer.decode(String?.self, forKey: .networkType)
        }
        if decoderContainer.contains(.descriptionValue)
        {
            self.descriptionValue = try decoderContainer.decode(String?.self, forKey: .descriptionValue)
        }
        if decoderContainer.contains(.createTime)
        {
            self.createTime = try decoderContainer.decode(String?.self, forKey: .createTime)
        }
    }
}
public extension Subnet{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: SubnetCodingKeys.self)
         try encoderContainer.encode(region, forKey: .region)
         try encoderContainer.encode(az, forKey: .az)
         try encoderContainer.encode(subnetId, forKey: .subnetId)
         try encoderContainer.encode(name, forKey: .name)
         try encoderContainer.encode(cidr, forKey: .cidr)
         try encoderContainer.encode(vpcId, forKey: .vpcId)
         try encoderContainer.encode(vpcName, forKey: .vpcName)
         try encoderContainer.encode(availableIpCount, forKey: .availableIpCount)
         try encoderContainer.encode(totalIpCount, forKey: .totalIpCount)
         try encoderContainer.encode(networkType, forKey: .networkType)
         try encoderContainer.encode(descriptionValue, forKey: .descriptionValue)
         try encoderContainer.encode(createTime, forKey: .createTime)
    }
}
///  elasticIp
public class ElasticIp:NSObject,Codable{
    /// 地域代码, 如cn-north-1
    var region:String?
    /// 弹性公网IPID
    var elasticIpId:String?
    /// 弹性公网IP
    var elasticIpValue:String?
    /// 带宽, 单位Mbps
    var bandwidth:Int?
    /// 链路类型
    var lineType:String?
    /// 状态
    var status:String?
    /// 实例类型
    var instanceType:String?
    /// 实例ID
    var instanceId:String?
    /// 创建时间
    var createTime:String?
    /// 计费信息
    var charge:Charge?



    public override init(){
            super.init()
    }

    enum ElasticIpCodingKeys: String, CodingKey {
        case region
        case elasticIpId
        case elasticIpValue = "elasticIp"
        case bandwidth
        case lineType
        case status
        case instanceType
        case instanceId
        case createTime
        case charge
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: ElasticIpCodingKeys.self)
        if decoderContainer.contains(.region)
        {
            self.region = try decoderContainer.decode(String?.self, forKey: .region)
        }
        if decoderContainer.contains(.elasticIpId)
        {
            self.elasticIpId = try decoderContainer.decode(String?.self, forKey: .elasticIpId)
        }
        if decoderContainer.contains(.elasticIpValue)
        {
            self.elasticIpValue = try decoderContainer.decode(String?.self, forKey: .elasticIpValue)
        }
        if decoderContainer.contains(.bandwidth)
        {
            self.bandwidth = try decoderContainer.decode(Int?.self, forKey: .bandwidth)
        }
        if decoderContainer.contains(.lineType)
        {
            self.lineType = try decoderContainer.decode(String?.self, forKey: .lineType)
        }
        if decoderContainer.contains(.status)
        {
            self.status = try decoderContainer.decode(String?.self, forKey: .status)
        }
        if decoderContainer.contains(.instanceType)
        {
            self.instanceType = try decoderContainer.decode(String?.self, forKey: .instanceType)
        }
        if decoderContainer.contains(.instanceId)
        {
            self.instanceId = try decoderContainer.decode(String?.self, forKey: .instanceId)
        }
        if decoderContainer.contains(.createTime)
        {
            self.createTime = try decoderContainer.decode(String?.self, forKey: .createTime)
        }
        if decoderContainer.contains(.charge)
        {
            self.charge = try decoderContainer.decode(Charge?.self, forKey: .charge)
        }
    }
}
public extension ElasticIp{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: ElasticIpCodingKeys.self)
         try encoderContainer.encode(region, forKey: .region)
         try encoderContainer.encode(elasticIpId, forKey: .elasticIpId)
         try encoderContainer.encode(elasticIpValue, forKey: .elasticIpValue)
         try encoderContainer.encode(bandwidth, forKey: .bandwidth)
         try encoderContainer.encode(lineType, forKey: .lineType)
         try encoderContainer.encode(status, forKey: .status)
         try encoderContainer.encode(instanceType, forKey: .instanceType)
         try encoderContainer.encode(instanceId, forKey: .instanceId)
         try encoderContainer.encode(createTime, forKey: .createTime)
         try encoderContainer.encode(charge, forKey: .charge)
    }
}
///  elasticIpSpec
public class ElasticIpSpec:NSObject,Codable{
    /// 带宽, 范围[1,200] 单位Mbps
    /// Required:true
    var bandwidth:Int
    /// 购买数量
    /// Required:true
    var count:Int
    /// 计费配置
    /// Required:true
    var charge:ChargeSpec



    public  init(bandwidth:Int,count:Int,charge:ChargeSpec){
             self.bandwidth = bandwidth
             self.count = count
             self.charge = charge
    }

    enum ElasticIpSpecCodingKeys: String, CodingKey {
        case bandwidth
        case count
        case charge
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: ElasticIpSpecCodingKeys.self)
        self.bandwidth = try decoderContainer.decode(Int.self, forKey: .bandwidth)
        self.count = try decoderContainer.decode(Int.self, forKey: .count)
        self.charge = try decoderContainer.decode(ChargeSpec.self, forKey: .charge)
    }
}
public extension ElasticIpSpec{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: ElasticIpSpecCodingKeys.self)
         try encoderContainer.encode(bandwidth, forKey: .bandwidth)
         try encoderContainer.encode(count, forKey: .count)
         try encoderContainer.encode(charge, forKey: .charge)
    }
}
///  serverGroup
public class ServerGroup:NSObject,Codable{
    /// 负载均衡ID
    var loadBalancerId:String?
    /// 虚拟服务器组ID
    var serverGroupId:String?
    /// 虚拟服务器组名称
    var name:String?



    public override init(){
            super.init()
    }

    enum ServerGroupCodingKeys: String, CodingKey {
        case loadBalancerId
        case serverGroupId
        case name
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: ServerGroupCodingKeys.self)
        if decoderContainer.contains(.loadBalancerId)
        {
            self.loadBalancerId = try decoderContainer.decode(String?.self, forKey: .loadBalancerId)
        }
        if decoderContainer.contains(.serverGroupId)
        {
            self.serverGroupId = try decoderContainer.decode(String?.self, forKey: .serverGroupId)
        }
        if decoderContainer.contains(.name)
        {
            self.name = try decoderContainer.decode(String?.self, forKey: .name)
        }
    }
}
public extension ServerGroup{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: ServerGroupCodingKeys.self)
         try encoderContainer.encode(loadBalancerId, forKey: .loadBalancerId)
         try encoderContainer.encode(serverGroupId, forKey: .serverGroupId)
         try encoderContainer.encode(name, forKey: .name)
    }
}
///  serverGroupSpec
public class ServerGroupSpec:NSObject,Codable{
    /// 负载均衡ID
    var loadBalancerId:String?
    /// 虚拟服务器组名称
    var name:String?



    public override init(){
            super.init()
    }

    enum ServerGroupSpecCodingKeys: String, CodingKey {
        case loadBalancerId
        case name
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: ServerGroupSpecCodingKeys.self)
        if decoderContainer.contains(.loadBalancerId)
        {
            self.loadBalancerId = try decoderContainer.decode(String?.self, forKey: .loadBalancerId)
        }
        if decoderContainer.contains(.name)
        {
            self.name = try decoderContainer.decode(String?.self, forKey: .name)
        }
    }
}
public extension ServerGroupSpec{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: ServerGroupSpecCodingKeys.self)
         try encoderContainer.encode(loadBalancerId, forKey: .loadBalancerId)
         try encoderContainer.encode(name, forKey: .name)
    }
}
///  renewalResource
public class RenewalResource:NSObject,Codable{
    /// 资源ID
    var resourceId:String?
    /// 资源名称
    var resourceName:String?
    /// 备注
    var remark:String?
    /// 绑定资源列表
    var bind:[RenewalResource?]?



    public override init(){
            super.init()
    }

    enum RenewalResourceCodingKeys: String, CodingKey {
        case resourceId
        case resourceName
        case remark
        case bind
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: RenewalResourceCodingKeys.self)
        if decoderContainer.contains(.resourceId)
        {
            self.resourceId = try decoderContainer.decode(String?.self, forKey: .resourceId)
        }
        if decoderContainer.contains(.resourceName)
        {
            self.resourceName = try decoderContainer.decode(String?.self, forKey: .resourceName)
        }
        if decoderContainer.contains(.remark)
        {
            self.remark = try decoderContainer.decode(String?.self, forKey: .remark)
        }
        if decoderContainer.contains(.bind)
        {
            self.bind = try decoderContainer.decode([RenewalResource?]?.self, forKey: .bind)
        }
    }
}
public extension RenewalResource{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: RenewalResourceCodingKeys.self)
         try encoderContainer.encode(resourceId, forKey: .resourceId)
         try encoderContainer.encode(resourceName, forKey: .resourceName)
         try encoderContainer.encode(remark, forKey: .remark)
         try encoderContainer.encode(bind, forKey: .bind)
    }
}
///  raid
public class Raid:NSObject,Codable{
    /// 磁盘类型, 如 system/data
    var volumeType:String?
    /// 设备详情
    var volumeDetail:String?
    /// RAID类型ID
    var raidTypeId:String?
    /// RAID类型, 如 NORAID, RAID0, RAID1
    var raidType:String?
    /// 云物理服务器类型, 如 cps.c.normal
    var deviceType:String?
    /// RAID类型描述
    var descriptionValue:String?



    public override init(){
            super.init()
    }

    enum RaidCodingKeys: String, CodingKey {
        case volumeType
        case volumeDetail
        case raidTypeId
        case raidType
        case deviceType
        case descriptionValue = "description"
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: RaidCodingKeys.self)
        if decoderContainer.contains(.volumeType)
        {
            self.volumeType = try decoderContainer.decode(String?.self, forKey: .volumeType)
        }
        if decoderContainer.contains(.volumeDetail)
        {
            self.volumeDetail = try decoderContainer.decode(String?.self, forKey: .volumeDetail)
        }
        if decoderContainer.contains(.raidTypeId)
        {
            self.raidTypeId = try decoderContainer.decode(String?.self, forKey: .raidTypeId)
        }
        if decoderContainer.contains(.raidType)
        {
            self.raidType = try decoderContainer.decode(String?.self, forKey: .raidType)
        }
        if decoderContainer.contains(.deviceType)
        {
            self.deviceType = try decoderContainer.decode(String?.self, forKey: .deviceType)
        }
        if decoderContainer.contains(.descriptionValue)
        {
            self.descriptionValue = try decoderContainer.decode(String?.self, forKey: .descriptionValue)
        }
    }
}
public extension Raid{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: RaidCodingKeys.self)
         try encoderContainer.encode(volumeType, forKey: .volumeType)
         try encoderContainer.encode(volumeDetail, forKey: .volumeDetail)
         try encoderContainer.encode(raidTypeId, forKey: .raidTypeId)
         try encoderContainer.encode(raidType, forKey: .raidType)
         try encoderContainer.encode(deviceType, forKey: .deviceType)
         try encoderContainer.encode(descriptionValue, forKey: .descriptionValue)
    }
}
///  metricTag
public class MetricTag:NSObject,Codable{
    /// 监控数据标签
    var tagKey:String?
    /// 监控数据标签数据
    var tagValue:String?



    public override init(){
            super.init()
    }

    enum MetricTagCodingKeys: String, CodingKey {
        case tagKey
        case tagValue
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: MetricTagCodingKeys.self)
        if decoderContainer.contains(.tagKey)
        {
            self.tagKey = try decoderContainer.decode(String?.self, forKey: .tagKey)
        }
        if decoderContainer.contains(.tagValue)
        {
            self.tagValue = try decoderContainer.decode(String?.self, forKey: .tagValue)
        }
    }
}
public extension MetricTag{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: MetricTagCodingKeys.self)
         try encoderContainer.encode(tagKey, forKey: .tagKey)
         try encoderContainer.encode(tagValue, forKey: .tagValue)
    }
}
///  instanceSpec
public class InstanceSpec:NSObject,Codable{
    /// 可用区, 如 cn-east-1
    /// Required:true
    var az:String
    /// 实例类型, 如 cps.c.normal
    /// Required:true
    var deviceType:String
    /// 主机名
    var hostname:String?
    /// 镜像类型, 取值范围：standard
    /// Required:true
    var imageType:String
    /// 操作系统类型ID
    /// Required:true
    var osTypeId:String
    /// 系统盘RAID类型ID
    /// Required:true
    var sysRaidTypeId:String
    /// 数据盘RAID类型ID
    /// Required:true
    var dataRaidTypeId:String
    /// 子网编号
    var subnetId:String?
    /// 是否启用外网，取值范围：yes、no
    var enableInternet:String?
    /// 是否启用IPv6，取值范围：yes、no
    var enableIpv6:String?
    /// 网络类型，取值范围：basic、vpc
    /// Required:true
    var networkType:String
    /// 网络CIDR
    var cidr:String?
    /// 内网IP
    var privateIp:String?
    /// 外网链路类型, 目前只支持bgp
    var lineType:String?
    /// 外网带宽, 范围[1,200] 单位Mbps
    var bandwidth:Int?
    /// 云物理服务器名称
    /// Required:true
    var name:String
    /// 云物理服务器描述
    var descriptionValue:String?
    /// 密码，不传值会随机生成密码
    var password:String?
    /// 购买数量
    /// Required:true
    var count:Int
    /// 可执行脚本Base64编码后的内容，支持shell和python脚本
    var userData:String?
    /// 密钥对id
    var keypairId:String?
    /// 计费配置
    /// Required:true
    var charge:ChargeSpec



    public  init(az:String,deviceType:String,imageType:String,osTypeId:String,sysRaidTypeId:String,dataRaidTypeId:String,networkType:String,name:String,count:Int,charge:ChargeSpec){
             self.az = az
             self.deviceType = deviceType
             self.imageType = imageType
             self.osTypeId = osTypeId
             self.sysRaidTypeId = sysRaidTypeId
             self.dataRaidTypeId = dataRaidTypeId
             self.networkType = networkType
             self.name = name
             self.count = count
             self.charge = charge
    }

    enum InstanceSpecCodingKeys: String, CodingKey {
        case az
        case deviceType
        case hostname
        case imageType
        case osTypeId
        case sysRaidTypeId
        case dataRaidTypeId
        case subnetId
        case enableInternet
        case enableIpv6
        case networkType
        case cidr
        case privateIp
        case lineType
        case bandwidth
        case name
        case descriptionValue = "description"
        case password
        case count
        case userData
        case keypairId
        case charge
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: InstanceSpecCodingKeys.self)
        self.az = try decoderContainer.decode(String.self, forKey: .az)
        self.deviceType = try decoderContainer.decode(String.self, forKey: .deviceType)
        if decoderContainer.contains(.hostname)
        {
            self.hostname = try decoderContainer.decode(String?.self, forKey: .hostname)
        }
        self.imageType = try decoderContainer.decode(String.self, forKey: .imageType)
        self.osTypeId = try decoderContainer.decode(String.self, forKey: .osTypeId)
        self.sysRaidTypeId = try decoderContainer.decode(String.self, forKey: .sysRaidTypeId)
        self.dataRaidTypeId = try decoderContainer.decode(String.self, forKey: .dataRaidTypeId)
        if decoderContainer.contains(.subnetId)
        {
            self.subnetId = try decoderContainer.decode(String?.self, forKey: .subnetId)
        }
        if decoderContainer.contains(.enableInternet)
        {
            self.enableInternet = try decoderContainer.decode(String?.self, forKey: .enableInternet)
        }
        if decoderContainer.contains(.enableIpv6)
        {
            self.enableIpv6 = try decoderContainer.decode(String?.self, forKey: .enableIpv6)
        }
        self.networkType = try decoderContainer.decode(String.self, forKey: .networkType)
        if decoderContainer.contains(.cidr)
        {
            self.cidr = try decoderContainer.decode(String?.self, forKey: .cidr)
        }
        if decoderContainer.contains(.privateIp)
        {
            self.privateIp = try decoderContainer.decode(String?.self, forKey: .privateIp)
        }
        if decoderContainer.contains(.lineType)
        {
            self.lineType = try decoderContainer.decode(String?.self, forKey: .lineType)
        }
        if decoderContainer.contains(.bandwidth)
        {
            self.bandwidth = try decoderContainer.decode(Int?.self, forKey: .bandwidth)
        }
        self.name = try decoderContainer.decode(String.self, forKey: .name)
        if decoderContainer.contains(.descriptionValue)
        {
            self.descriptionValue = try decoderContainer.decode(String?.self, forKey: .descriptionValue)
        }
        if decoderContainer.contains(.password)
        {
            self.password = try decoderContainer.decode(String?.self, forKey: .password)
        }
        self.count = try decoderContainer.decode(Int.self, forKey: .count)
        if decoderContainer.contains(.userData)
        {
            self.userData = try decoderContainer.decode(String?.self, forKey: .userData)
        }
        if decoderContainer.contains(.keypairId)
        {
            self.keypairId = try decoderContainer.decode(String?.self, forKey: .keypairId)
        }
        self.charge = try decoderContainer.decode(ChargeSpec.self, forKey: .charge)
    }
}
public extension InstanceSpec{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: InstanceSpecCodingKeys.self)
         try encoderContainer.encode(az, forKey: .az)
         try encoderContainer.encode(deviceType, forKey: .deviceType)
         try encoderContainer.encode(hostname, forKey: .hostname)
         try encoderContainer.encode(imageType, forKey: .imageType)
         try encoderContainer.encode(osTypeId, forKey: .osTypeId)
         try encoderContainer.encode(sysRaidTypeId, forKey: .sysRaidTypeId)
         try encoderContainer.encode(dataRaidTypeId, forKey: .dataRaidTypeId)
         try encoderContainer.encode(subnetId, forKey: .subnetId)
         try encoderContainer.encode(enableInternet, forKey: .enableInternet)
         try encoderContainer.encode(enableIpv6, forKey: .enableIpv6)
         try encoderContainer.encode(networkType, forKey: .networkType)
         try encoderContainer.encode(cidr, forKey: .cidr)
         try encoderContainer.encode(privateIp, forKey: .privateIp)
         try encoderContainer.encode(lineType, forKey: .lineType)
         try encoderContainer.encode(bandwidth, forKey: .bandwidth)
         try encoderContainer.encode(name, forKey: .name)
         try encoderContainer.encode(descriptionValue, forKey: .descriptionValue)
         try encoderContainer.encode(password, forKey: .password)
         try encoderContainer.encode(count, forKey: .count)
         try encoderContainer.encode(userData, forKey: .userData)
         try encoderContainer.encode(keypairId, forKey: .keypairId)
         try encoderContainer.encode(charge, forKey: .charge)
    }
}
///  reinstallInstanceSpec
public class ReinstallInstanceSpec:NSObject,Codable{
    /// 可用区, 如cn-east-1a
    /// Required:true
    var az:String
    /// 镜像类型, 取值范围：standard、standard_app
    /// Required:true
    var imageType:String
    /// 操作系统类型ID
    /// Required:true
    var osTypeId:String
    /// 系统盘RAID类型ID
    /// Required:true
    var sysRaidTypeId:String
    /// 是否保留数据盘数据, 取值为：yes、no
    /// Required:true
    var keepData:String
    /// 数据盘RAID类型ID
    /// Required:true
    var dataRaidTypeId:String
    /// 密码
    /// Required:true
    var password:String
    /// 主机名
    var hostname:String?
    /// 可执行脚本Base64编码后的内容，支持shell和python脚本
    var userData:String?
    /// 秘钥对id
    var keypairId:String?



    public  init(az:String,imageType:String,osTypeId:String,sysRaidTypeId:String,keepData:String,dataRaidTypeId:String,password:String){
             self.az = az
             self.imageType = imageType
             self.osTypeId = osTypeId
             self.sysRaidTypeId = sysRaidTypeId
             self.keepData = keepData
             self.dataRaidTypeId = dataRaidTypeId
             self.password = password
    }

    enum ReinstallInstanceSpecCodingKeys: String, CodingKey {
        case az
        case imageType
        case osTypeId
        case sysRaidTypeId
        case keepData
        case dataRaidTypeId
        case password
        case hostname
        case userData
        case keypairId
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: ReinstallInstanceSpecCodingKeys.self)
        self.az = try decoderContainer.decode(String.self, forKey: .az)
        self.imageType = try decoderContainer.decode(String.self, forKey: .imageType)
        self.osTypeId = try decoderContainer.decode(String.self, forKey: .osTypeId)
        self.sysRaidTypeId = try decoderContainer.decode(String.self, forKey: .sysRaidTypeId)
        self.keepData = try decoderContainer.decode(String.self, forKey: .keepData)
        self.dataRaidTypeId = try decoderContainer.decode(String.self, forKey: .dataRaidTypeId)
        self.password = try decoderContainer.decode(String.self, forKey: .password)
        if decoderContainer.contains(.hostname)
        {
            self.hostname = try decoderContainer.decode(String?.self, forKey: .hostname)
        }
        if decoderContainer.contains(.userData)
        {
            self.userData = try decoderContainer.decode(String?.self, forKey: .userData)
        }
        if decoderContainer.contains(.keypairId)
        {
            self.keypairId = try decoderContainer.decode(String?.self, forKey: .keypairId)
        }
    }
}
public extension ReinstallInstanceSpec{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: ReinstallInstanceSpecCodingKeys.self)
         try encoderContainer.encode(az, forKey: .az)
         try encoderContainer.encode(imageType, forKey: .imageType)
         try encoderContainer.encode(osTypeId, forKey: .osTypeId)
         try encoderContainer.encode(sysRaidTypeId, forKey: .sysRaidTypeId)
         try encoderContainer.encode(keepData, forKey: .keepData)
         try encoderContainer.encode(dataRaidTypeId, forKey: .dataRaidTypeId)
         try encoderContainer.encode(password, forKey: .password)
         try encoderContainer.encode(hostname, forKey: .hostname)
         try encoderContainer.encode(userData, forKey: .userData)
         try encoderContainer.encode(keypairId, forKey: .keypairId)
    }
}
///  metricValue
public class MetricValue:NSObject,Codable{
    /// 数据采集时间，格式：1562915166551
    var timestamp:Int64?
    /// 采集的数据
    var value:String?



    public override init(){
            super.init()
    }

    enum MetricValueCodingKeys: String, CodingKey {
        case timestamp
        case value
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: MetricValueCodingKeys.self)
        if decoderContainer.contains(.timestamp)
        {
            self.timestamp = try decoderContainer.decode(Int64?.self, forKey: .timestamp)
        }
        if decoderContainer.contains(.value)
        {
            self.value = try decoderContainer.decode(String?.self, forKey: .value)
        }
    }
}
public extension MetricValue{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: MetricValueCodingKeys.self)
         try encoderContainer.encode(timestamp, forKey: .timestamp)
         try encoderContainer.encode(value, forKey: .value)
    }
}
///  metricData
public class MetricData:NSObject,Codable{
    /// 监控指标数据
    var data:[MetricValue?]?
    /// 监控指标标签
    var tags:[MetricTag?]?
    /// 监控指标概览
    var metric:MetricInfo?



    public override init(){
            super.init()
    }

    enum MetricDataCodingKeys: String, CodingKey {
        case data
        case tags
        case metric
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: MetricDataCodingKeys.self)
        if decoderContainer.contains(.data)
        {
            self.data = try decoderContainer.decode([MetricValue?]?.self, forKey: .data)
        }
        if decoderContainer.contains(.tags)
        {
            self.tags = try decoderContainer.decode([MetricTag?]?.self, forKey: .tags)
        }
        if decoderContainer.contains(.metric)
        {
            self.metric = try decoderContainer.decode(MetricInfo?.self, forKey: .metric)
        }
    }
}
public extension MetricData{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: MetricDataCodingKeys.self)
         try encoderContainer.encode(data, forKey: .data)
         try encoderContainer.encode(tags, forKey: .tags)
         try encoderContainer.encode(metric, forKey: .metric)
    }
}
///  metricInfo
public class MetricInfo:NSObject,Codable{
    /// 监控数据统计单位
    var calculateUnit:String?
    /// 监控数据指标
    var metirc:String?
    /// 监控数据指标描述
    var metricName:String?
    /// 监控数据聚合方式
    var aggregator:String?
    /// 监控数据统计周期
    var period:String?



    public override init(){
            super.init()
    }

    enum MetricInfoCodingKeys: String, CodingKey {
        case calculateUnit
        case metirc
        case metricName
        case aggregator
        case period
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: MetricInfoCodingKeys.self)
        if decoderContainer.contains(.calculateUnit)
        {
            self.calculateUnit = try decoderContainer.decode(String?.self, forKey: .calculateUnit)
        }
        if decoderContainer.contains(.metirc)
        {
            self.metirc = try decoderContainer.decode(String?.self, forKey: .metirc)
        }
        if decoderContainer.contains(.metricName)
        {
            self.metricName = try decoderContainer.decode(String?.self, forKey: .metricName)
        }
        if decoderContainer.contains(.aggregator)
        {
            self.aggregator = try decoderContainer.decode(String?.self, forKey: .aggregator)
        }
        if decoderContainer.contains(.period)
        {
            self.period = try decoderContainer.decode(String?.self, forKey: .period)
        }
    }
}
public extension MetricInfo{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: MetricInfoCodingKeys.self)
         try encoderContainer.encode(calculateUnit, forKey: .calculateUnit)
         try encoderContainer.encode(metirc, forKey: .metirc)
         try encoderContainer.encode(metricName, forKey: .metricName)
         try encoderContainer.encode(aggregator, forKey: .aggregator)
         try encoderContainer.encode(period, forKey: .period)
    }
}
///  os
public class Os:NSObject,Codable{
    /// 操作系统系统类型ID
    var osTypeId:String?
    /// 操作系统系统名称, 如 Ubuntu 16.04(x86_64)
    var osName:String?
    /// 操作系统类型, 如 ubuntu/centos
    var osType:String?
    /// 操作系统版本, 如 14.04/16.04
    var osVersion:String?
    /// 实例类型, 如 cps.c.normal
    var deviceType:String?



    public override init(){
            super.init()
    }

    enum OsCodingKeys: String, CodingKey {
        case osTypeId
        case osName
        case osType
        case osVersion
        case deviceType
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: OsCodingKeys.self)
        if decoderContainer.contains(.osTypeId)
        {
            self.osTypeId = try decoderContainer.decode(String?.self, forKey: .osTypeId)
        }
        if decoderContainer.contains(.osName)
        {
            self.osName = try decoderContainer.decode(String?.self, forKey: .osName)
        }
        if decoderContainer.contains(.osType)
        {
            self.osType = try decoderContainer.decode(String?.self, forKey: .osType)
        }
        if decoderContainer.contains(.osVersion)
        {
            self.osVersion = try decoderContainer.decode(String?.self, forKey: .osVersion)
        }
        if decoderContainer.contains(.deviceType)
        {
            self.deviceType = try decoderContainer.decode(String?.self, forKey: .deviceType)
        }
    }
}
public extension Os{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: OsCodingKeys.self)
         try encoderContainer.encode(osTypeId, forKey: .osTypeId)
         try encoderContainer.encode(osName, forKey: .osName)
         try encoderContainer.encode(osType, forKey: .osType)
         try encoderContainer.encode(osVersion, forKey: .osVersion)
         try encoderContainer.encode(deviceType, forKey: .deviceType)
    }
}
///  deviceType
public class DeviceType:NSObject,Codable{
    /// 实例类型, 如 cps.c.normal
    var deviceTypeValue:String?
    /// 实例类型名称, 如 标准计算型
    var name:String?
    /// 实例所属规格系列，如 计算、存储、GPU
    var family:String?
    /// 区域代码, 如 cn-east-1
    var region:String?
    /// CPU概要描述
    var cpuConcise:String?
    /// CPU详细信息
    var cpuDetail:String?
    /// 内存概要信息
    var memConcise:String?
    /// 内存详细信息
    var memDetail:String?
    /// 网口概要信息
    var ifConcise:String?
    /// 网口详细信息
    var ifDetail:String?
    /// GPU概要信息
    var gpuConcise:String?
    /// GPU详细信息
    var gpuDetail:String?
    /// 系统盘数量
    var systemDiskAmount:Int?
    /// 系统盘单盘大小（GB）
    var systemDiskSize:Int?
    /// 系统盘规格
    var systemDiskModel:String?
    /// 数据盘数量
    var dataDiskAmount:Int?
    /// 数据盘单盘大小（GB）
    var dataDiskSize:Int?
    /// 数据盘规格
    var dataDiskModel:String?
    /// 售罄状态
    var isSoldOut:Bool?



    public override init(){
            super.init()
    }

    enum DeviceTypeCodingKeys: String, CodingKey {
        case deviceTypeValue = "deviceType"
        case name
        case family
        case region
        case cpuConcise
        case cpuDetail
        case memConcise
        case memDetail
        case ifConcise
        case ifDetail
        case gpuConcise
        case gpuDetail
        case systemDiskAmount
        case systemDiskSize
        case systemDiskModel
        case dataDiskAmount
        case dataDiskSize
        case dataDiskModel
        case isSoldOut
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: DeviceTypeCodingKeys.self)
        if decoderContainer.contains(.deviceTypeValue)
        {
            self.deviceTypeValue = try decoderContainer.decode(String?.self, forKey: .deviceTypeValue)
        }
        if decoderContainer.contains(.name)
        {
            self.name = try decoderContainer.decode(String?.self, forKey: .name)
        }
        if decoderContainer.contains(.family)
        {
            self.family = try decoderContainer.decode(String?.self, forKey: .family)
        }
        if decoderContainer.contains(.region)
        {
            self.region = try decoderContainer.decode(String?.self, forKey: .region)
        }
        if decoderContainer.contains(.cpuConcise)
        {
            self.cpuConcise = try decoderContainer.decode(String?.self, forKey: .cpuConcise)
        }
        if decoderContainer.contains(.cpuDetail)
        {
            self.cpuDetail = try decoderContainer.decode(String?.self, forKey: .cpuDetail)
        }
        if decoderContainer.contains(.memConcise)
        {
            self.memConcise = try decoderContainer.decode(String?.self, forKey: .memConcise)
        }
        if decoderContainer.contains(.memDetail)
        {
            self.memDetail = try decoderContainer.decode(String?.self, forKey: .memDetail)
        }
        if decoderContainer.contains(.ifConcise)
        {
            self.ifConcise = try decoderContainer.decode(String?.self, forKey: .ifConcise)
        }
        if decoderContainer.contains(.ifDetail)
        {
            self.ifDetail = try decoderContainer.decode(String?.self, forKey: .ifDetail)
        }
        if decoderContainer.contains(.gpuConcise)
        {
            self.gpuConcise = try decoderContainer.decode(String?.self, forKey: .gpuConcise)
        }
        if decoderContainer.contains(.gpuDetail)
        {
            self.gpuDetail = try decoderContainer.decode(String?.self, forKey: .gpuDetail)
        }
        if decoderContainer.contains(.systemDiskAmount)
        {
            self.systemDiskAmount = try decoderContainer.decode(Int?.self, forKey: .systemDiskAmount)
        }
        if decoderContainer.contains(.systemDiskSize)
        {
            self.systemDiskSize = try decoderContainer.decode(Int?.self, forKey: .systemDiskSize)
        }
        if decoderContainer.contains(.systemDiskModel)
        {
            self.systemDiskModel = try decoderContainer.decode(String?.self, forKey: .systemDiskModel)
        }
        if decoderContainer.contains(.dataDiskAmount)
        {
            self.dataDiskAmount = try decoderContainer.decode(Int?.self, forKey: .dataDiskAmount)
        }
        if decoderContainer.contains(.dataDiskSize)
        {
            self.dataDiskSize = try decoderContainer.decode(Int?.self, forKey: .dataDiskSize)
        }
        if decoderContainer.contains(.dataDiskModel)
        {
            self.dataDiskModel = try decoderContainer.decode(String?.self, forKey: .dataDiskModel)
        }
        if decoderContainer.contains(.isSoldOut)
        {
            self.isSoldOut = try decoderContainer.decode(Bool?.self, forKey: .isSoldOut)
        }
    }
}
public extension DeviceType{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: DeviceTypeCodingKeys.self)
         try encoderContainer.encode(deviceTypeValue, forKey: .deviceTypeValue)
         try encoderContainer.encode(name, forKey: .name)
         try encoderContainer.encode(family, forKey: .family)
         try encoderContainer.encode(region, forKey: .region)
         try encoderContainer.encode(cpuConcise, forKey: .cpuConcise)
         try encoderContainer.encode(cpuDetail, forKey: .cpuDetail)
         try encoderContainer.encode(memConcise, forKey: .memConcise)
         try encoderContainer.encode(memDetail, forKey: .memDetail)
         try encoderContainer.encode(ifConcise, forKey: .ifConcise)
         try encoderContainer.encode(ifDetail, forKey: .ifDetail)
         try encoderContainer.encode(gpuConcise, forKey: .gpuConcise)
         try encoderContainer.encode(gpuDetail, forKey: .gpuDetail)
         try encoderContainer.encode(systemDiskAmount, forKey: .systemDiskAmount)
         try encoderContainer.encode(systemDiskSize, forKey: .systemDiskSize)
         try encoderContainer.encode(systemDiskModel, forKey: .systemDiskModel)
         try encoderContainer.encode(dataDiskAmount, forKey: .dataDiskAmount)
         try encoderContainer.encode(dataDiskSize, forKey: .dataDiskSize)
         try encoderContainer.encode(dataDiskModel, forKey: .dataDiskModel)
         try encoderContainer.encode(isSoldOut, forKey: .isSoldOut)
    }
}
///  instance
public class Instance:NSObject,Codable{
    /// 云物理服务器实例ID
    var instanceId:String?
    /// 区域代码, 如 cn-east-1
    var region:String?
    /// 可用区, 如 cn-east-1a
    var az:String?
    /// 实例类型, 如 cps.c.normal
    var deviceType:String?
    /// 云物理服务器名称
    var name:String?
    /// 云物理服务器描述
    var descriptionValue:String?
    /// 云物理服务器生命周期状态
    var status:String?
    /// 是否启用外网, 如 yes/no
    var enableInternet:String?
    /// 是否启用IPv6, 如 yes/no
    var enableIpv6:String?
    /// 带宽, 单位Mbps
    var bandwidth:Int?
    /// 镜像类型, 如 standard
    var imageType:String?
    /// 操作系统类型ID
    var osTypeId:String?
    /// 操作系统名称
    var osName:String?
    /// 操作系统类型, 如 ubuntu/centos
    var osType:String?
    /// 操作系统版本, 如 16.04
    var osVersion:String?
    /// 系统盘RAID类型ID
    var sysRaidTypeId:String?
    /// 系统盘RAID类型, 如 NORAID, RAID0, RAID1
    var sysRaidType:String?
    /// 数据盘RAID类型ID
    var dataRaidTypeId:String?
    /// 数据盘RAID类型, 如 NORAID, RAID0, RAID1
    var dataRaidType:String?
    /// 网络类型, 如 basic, vpc
    var networkType:String?
    /// 私有网络ID
    var vpcId:String?
    /// 私有网络名称
    var vpcName:String?
    /// 子网编号
    var subnetId:String?
    /// 子网名称
    var subnetName:String?
    /// 内网IP
    var privateIp:String?
    /// 外网链路类型, 如 bgp
    var lineType:String?
    /// 弹性公网IPID
    var elasticIpId:String?
    /// 公网IP
    var publicIp:String?
    /// 公网IPv6
    var publicIpv6:String?
    /// 密钥对id
    var keypairId:String?
    /// agent状态
    var agentStatus:String?
    /// 计费信息
    var charge:Charge?



    public override init(){
            super.init()
    }

    enum InstanceCodingKeys: String, CodingKey {
        case instanceId
        case region
        case az
        case deviceType
        case name
        case descriptionValue = "description"
        case status
        case enableInternet
        case enableIpv6
        case bandwidth
        case imageType
        case osTypeId
        case osName
        case osType
        case osVersion
        case sysRaidTypeId
        case sysRaidType
        case dataRaidTypeId
        case dataRaidType
        case networkType
        case vpcId
        case vpcName
        case subnetId
        case subnetName
        case privateIp
        case lineType
        case elasticIpId
        case publicIp
        case publicIpv6
        case keypairId
        case agentStatus
        case charge
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: InstanceCodingKeys.self)
        if decoderContainer.contains(.instanceId)
        {
            self.instanceId = try decoderContainer.decode(String?.self, forKey: .instanceId)
        }
        if decoderContainer.contains(.region)
        {
            self.region = try decoderContainer.decode(String?.self, forKey: .region)
        }
        if decoderContainer.contains(.az)
        {
            self.az = try decoderContainer.decode(String?.self, forKey: .az)
        }
        if decoderContainer.contains(.deviceType)
        {
            self.deviceType = try decoderContainer.decode(String?.self, forKey: .deviceType)
        }
        if decoderContainer.contains(.name)
        {
            self.name = try decoderContainer.decode(String?.self, forKey: .name)
        }
        if decoderContainer.contains(.descriptionValue)
        {
            self.descriptionValue = try decoderContainer.decode(String?.self, forKey: .descriptionValue)
        }
        if decoderContainer.contains(.status)
        {
            self.status = try decoderContainer.decode(String?.self, forKey: .status)
        }
        if decoderContainer.contains(.enableInternet)
        {
            self.enableInternet = try decoderContainer.decode(String?.self, forKey: .enableInternet)
        }
        if decoderContainer.contains(.enableIpv6)
        {
            self.enableIpv6 = try decoderContainer.decode(String?.self, forKey: .enableIpv6)
        }
        if decoderContainer.contains(.bandwidth)
        {
            self.bandwidth = try decoderContainer.decode(Int?.self, forKey: .bandwidth)
        }
        if decoderContainer.contains(.imageType)
        {
            self.imageType = try decoderContainer.decode(String?.self, forKey: .imageType)
        }
        if decoderContainer.contains(.osTypeId)
        {
            self.osTypeId = try decoderContainer.decode(String?.self, forKey: .osTypeId)
        }
        if decoderContainer.contains(.osName)
        {
            self.osName = try decoderContainer.decode(String?.self, forKey: .osName)
        }
        if decoderContainer.contains(.osType)
        {
            self.osType = try decoderContainer.decode(String?.self, forKey: .osType)
        }
        if decoderContainer.contains(.osVersion)
        {
            self.osVersion = try decoderContainer.decode(String?.self, forKey: .osVersion)
        }
        if decoderContainer.contains(.sysRaidTypeId)
        {
            self.sysRaidTypeId = try decoderContainer.decode(String?.self, forKey: .sysRaidTypeId)
        }
        if decoderContainer.contains(.sysRaidType)
        {
            self.sysRaidType = try decoderContainer.decode(String?.self, forKey: .sysRaidType)
        }
        if decoderContainer.contains(.dataRaidTypeId)
        {
            self.dataRaidTypeId = try decoderContainer.decode(String?.self, forKey: .dataRaidTypeId)
        }
        if decoderContainer.contains(.dataRaidType)
        {
            self.dataRaidType = try decoderContainer.decode(String?.self, forKey: .dataRaidType)
        }
        if decoderContainer.contains(.networkType)
        {
            self.networkType = try decoderContainer.decode(String?.self, forKey: .networkType)
        }
        if decoderContainer.contains(.vpcId)
        {
            self.vpcId = try decoderContainer.decode(String?.self, forKey: .vpcId)
        }
        if decoderContainer.contains(.vpcName)
        {
            self.vpcName = try decoderContainer.decode(String?.self, forKey: .vpcName)
        }
        if decoderContainer.contains(.subnetId)
        {
            self.subnetId = try decoderContainer.decode(String?.self, forKey: .subnetId)
        }
        if decoderContainer.contains(.subnetName)
        {
            self.subnetName = try decoderContainer.decode(String?.self, forKey: .subnetName)
        }
        if decoderContainer.contains(.privateIp)
        {
            self.privateIp = try decoderContainer.decode(String?.self, forKey: .privateIp)
        }
        if decoderContainer.contains(.lineType)
        {
            self.lineType = try decoderContainer.decode(String?.self, forKey: .lineType)
        }
        if decoderContainer.contains(.elasticIpId)
        {
            self.elasticIpId = try decoderContainer.decode(String?.self, forKey: .elasticIpId)
        }
        if decoderContainer.contains(.publicIp)
        {
            self.publicIp = try decoderContainer.decode(String?.self, forKey: .publicIp)
        }
        if decoderContainer.contains(.publicIpv6)
        {
            self.publicIpv6 = try decoderContainer.decode(String?.self, forKey: .publicIpv6)
        }
        if decoderContainer.contains(.keypairId)
        {
            self.keypairId = try decoderContainer.decode(String?.self, forKey: .keypairId)
        }
        if decoderContainer.contains(.agentStatus)
        {
            self.agentStatus = try decoderContainer.decode(String?.self, forKey: .agentStatus)
        }
        if decoderContainer.contains(.charge)
        {
            self.charge = try decoderContainer.decode(Charge?.self, forKey: .charge)
        }
    }
}
public extension Instance{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: InstanceCodingKeys.self)
         try encoderContainer.encode(instanceId, forKey: .instanceId)
         try encoderContainer.encode(region, forKey: .region)
         try encoderContainer.encode(az, forKey: .az)
         try encoderContainer.encode(deviceType, forKey: .deviceType)
         try encoderContainer.encode(name, forKey: .name)
         try encoderContainer.encode(descriptionValue, forKey: .descriptionValue)
         try encoderContainer.encode(status, forKey: .status)
         try encoderContainer.encode(enableInternet, forKey: .enableInternet)
         try encoderContainer.encode(enableIpv6, forKey: .enableIpv6)
         try encoderContainer.encode(bandwidth, forKey: .bandwidth)
         try encoderContainer.encode(imageType, forKey: .imageType)
         try encoderContainer.encode(osTypeId, forKey: .osTypeId)
         try encoderContainer.encode(osName, forKey: .osName)
         try encoderContainer.encode(osType, forKey: .osType)
         try encoderContainer.encode(osVersion, forKey: .osVersion)
         try encoderContainer.encode(sysRaidTypeId, forKey: .sysRaidTypeId)
         try encoderContainer.encode(sysRaidType, forKey: .sysRaidType)
         try encoderContainer.encode(dataRaidTypeId, forKey: .dataRaidTypeId)
         try encoderContainer.encode(dataRaidType, forKey: .dataRaidType)
         try encoderContainer.encode(networkType, forKey: .networkType)
         try encoderContainer.encode(vpcId, forKey: .vpcId)
         try encoderContainer.encode(vpcName, forKey: .vpcName)
         try encoderContainer.encode(subnetId, forKey: .subnetId)
         try encoderContainer.encode(subnetName, forKey: .subnetName)
         try encoderContainer.encode(privateIp, forKey: .privateIp)
         try encoderContainer.encode(lineType, forKey: .lineType)
         try encoderContainer.encode(elasticIpId, forKey: .elasticIpId)
         try encoderContainer.encode(publicIp, forKey: .publicIp)
         try encoderContainer.encode(publicIpv6, forKey: .publicIpv6)
         try encoderContainer.encode(keypairId, forKey: .keypairId)
         try encoderContainer.encode(agentStatus, forKey: .agentStatus)
         try encoderContainer.encode(charge, forKey: .charge)
    }
}
///  loadBalancer
public class LoadBalancer:NSObject,Codable{
    /// 负载均衡实例ID
    var loadBalancerId:String?
    /// 地域，如cn-east-1
    var region:String?
    /// IP版本，取值ipv4
    var ipAddressType:String?
    /// 网络类型，取值public
    var netType:String?
    /// 私有网络ID
    var vpcId:String?
    /// 弹性公网IPID
    var elasticIpId:String?
    /// 公网IP
    var publicIp:String?
    /// 带宽
    var bandwidth:Int?
    /// 状态，取值active|inactive
    var status:String?
    /// 名称
    var name:String?
    /// 描述
    var descriptionValue:String?
    /// 创建时间
    var createTime:String?
    /// 计费配置
    var charge:Charge?



    public override init(){
            super.init()
    }

    enum LoadBalancerCodingKeys: String, CodingKey {
        case loadBalancerId
        case region
        case ipAddressType
        case netType
        case vpcId
        case elasticIpId
        case publicIp
        case bandwidth
        case status
        case name
        case descriptionValue = "description"
        case createTime
        case charge
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: LoadBalancerCodingKeys.self)
        if decoderContainer.contains(.loadBalancerId)
        {
            self.loadBalancerId = try decoderContainer.decode(String?.self, forKey: .loadBalancerId)
        }
        if decoderContainer.contains(.region)
        {
            self.region = try decoderContainer.decode(String?.self, forKey: .region)
        }
        if decoderContainer.contains(.ipAddressType)
        {
            self.ipAddressType = try decoderContainer.decode(String?.self, forKey: .ipAddressType)
        }
        if decoderContainer.contains(.netType)
        {
            self.netType = try decoderContainer.decode(String?.self, forKey: .netType)
        }
        if decoderContainer.contains(.vpcId)
        {
            self.vpcId = try decoderContainer.decode(String?.self, forKey: .vpcId)
        }
        if decoderContainer.contains(.elasticIpId)
        {
            self.elasticIpId = try decoderContainer.decode(String?.self, forKey: .elasticIpId)
        }
        if decoderContainer.contains(.publicIp)
        {
            self.publicIp = try decoderContainer.decode(String?.self, forKey: .publicIp)
        }
        if decoderContainer.contains(.bandwidth)
        {
            self.bandwidth = try decoderContainer.decode(Int?.self, forKey: .bandwidth)
        }
        if decoderContainer.contains(.status)
        {
            self.status = try decoderContainer.decode(String?.self, forKey: .status)
        }
        if decoderContainer.contains(.name)
        {
            self.name = try decoderContainer.decode(String?.self, forKey: .name)
        }
        if decoderContainer.contains(.descriptionValue)
        {
            self.descriptionValue = try decoderContainer.decode(String?.self, forKey: .descriptionValue)
        }
        if decoderContainer.contains(.createTime)
        {
            self.createTime = try decoderContainer.decode(String?.self, forKey: .createTime)
        }
        if decoderContainer.contains(.charge)
        {
            self.charge = try decoderContainer.decode(Charge?.self, forKey: .charge)
        }
    }
}
public extension LoadBalancer{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: LoadBalancerCodingKeys.self)
         try encoderContainer.encode(loadBalancerId, forKey: .loadBalancerId)
         try encoderContainer.encode(region, forKey: .region)
         try encoderContainer.encode(ipAddressType, forKey: .ipAddressType)
         try encoderContainer.encode(netType, forKey: .netType)
         try encoderContainer.encode(vpcId, forKey: .vpcId)
         try encoderContainer.encode(elasticIpId, forKey: .elasticIpId)
         try encoderContainer.encode(publicIp, forKey: .publicIp)
         try encoderContainer.encode(bandwidth, forKey: .bandwidth)
         try encoderContainer.encode(status, forKey: .status)
         try encoderContainer.encode(name, forKey: .name)
         try encoderContainer.encode(descriptionValue, forKey: .descriptionValue)
         try encoderContainer.encode(createTime, forKey: .createTime)
         try encoderContainer.encode(charge, forKey: .charge)
    }
}
///  loadBalancerSpec
public class LoadBalancerSpec:NSObject,Codable{
    /// 网络类型，取值public
    /// Required:true
    var netType:String
    /// 负载均衡实例的IP版本，取值ipv4
    /// Required:true
    var ipAddressType:String
    /// 私有网络ID
    /// Required:true
    var vpcId:String
    /// 名称
    /// Required:true
    var name:String
    /// 描述
    var descriptionValue:String?
    /// 是否申请弹性公网Ip
    /// Required:true
    var applyElasticIp:Bool
    /// 带宽
    /// Required:true
    var bandwidth:Int
    /// 计费配置
    /// Required:true
    var charge:ChargeSpec



    public  init(netType:String,ipAddressType:String,vpcId:String,name:String,applyElasticIp:Bool,bandwidth:Int,charge:ChargeSpec){
             self.netType = netType
             self.ipAddressType = ipAddressType
             self.vpcId = vpcId
             self.name = name
             self.applyElasticIp = applyElasticIp
             self.bandwidth = bandwidth
             self.charge = charge
    }

    enum LoadBalancerSpecCodingKeys: String, CodingKey {
        case netType
        case ipAddressType
        case vpcId
        case name
        case descriptionValue = "description"
        case applyElasticIp
        case bandwidth
        case charge
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: LoadBalancerSpecCodingKeys.self)
        self.netType = try decoderContainer.decode(String.self, forKey: .netType)
        self.ipAddressType = try decoderContainer.decode(String.self, forKey: .ipAddressType)
        self.vpcId = try decoderContainer.decode(String.self, forKey: .vpcId)
        self.name = try decoderContainer.decode(String.self, forKey: .name)
        if decoderContainer.contains(.descriptionValue)
        {
            self.descriptionValue = try decoderContainer.decode(String?.self, forKey: .descriptionValue)
        }
        self.applyElasticIp = try decoderContainer.decode(Bool.self, forKey: .applyElasticIp)
        self.bandwidth = try decoderContainer.decode(Int.self, forKey: .bandwidth)
        self.charge = try decoderContainer.decode(ChargeSpec.self, forKey: .charge)
    }
}
public extension LoadBalancerSpec{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: LoadBalancerSpecCodingKeys.self)
         try encoderContainer.encode(netType, forKey: .netType)
         try encoderContainer.encode(ipAddressType, forKey: .ipAddressType)
         try encoderContainer.encode(vpcId, forKey: .vpcId)
         try encoderContainer.encode(name, forKey: .name)
         try encoderContainer.encode(descriptionValue, forKey: .descriptionValue)
         try encoderContainer.encode(applyElasticIp, forKey: .applyElasticIp)
         try encoderContainer.encode(bandwidth, forKey: .bandwidth)
         try encoderContainer.encode(charge, forKey: .charge)
    }
}
///  vpcSpec
public class VpcSpec:NSObject,Codable{
    /// 私有网络范围
    /// Required:true
    var cidr:String
    /// 名称
    /// Required:true
    var name:String
    /// 描述
    /// Required:true
    var descriptionValue:String



    public  init(cidr:String,name:String,descriptionValue:String){
             self.cidr = cidr
             self.name = name
             self.descriptionValue = descriptionValue
    }

    enum VpcSpecCodingKeys: String, CodingKey {
        case cidr
        case name
        case descriptionValue = "description"
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: VpcSpecCodingKeys.self)
        self.cidr = try decoderContainer.decode(String.self, forKey: .cidr)
        self.name = try decoderContainer.decode(String.self, forKey: .name)
        self.descriptionValue = try decoderContainer.decode(String.self, forKey: .descriptionValue)
    }
}
public extension VpcSpec{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: VpcSpecCodingKeys.self)
         try encoderContainer.encode(cidr, forKey: .cidr)
         try encoderContainer.encode(name, forKey: .name)
         try encoderContainer.encode(descriptionValue, forKey: .descriptionValue)
    }
}
///  vpc
public class Vpc:NSObject,Codable{
    /// 地域代码, 如cn-north-1
    var region:String?
    /// 私有网络ID
    var vpcId:String?
    /// 私有网络名称
    var name:String?
    /// 私有网络CIDR
    var cidr:String?
    /// 描述
    var descriptionValue:String?
    /// 创建时间
    var createTime:String?



    public override init(){
            super.init()
    }

    enum VpcCodingKeys: String, CodingKey {
        case region
        case vpcId
        case name
        case cidr
        case descriptionValue = "description"
        case createTime
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: VpcCodingKeys.self)
        if decoderContainer.contains(.region)
        {
            self.region = try decoderContainer.decode(String?.self, forKey: .region)
        }
        if decoderContainer.contains(.vpcId)
        {
            self.vpcId = try decoderContainer.decode(String?.self, forKey: .vpcId)
        }
        if decoderContainer.contains(.name)
        {
            self.name = try decoderContainer.decode(String?.self, forKey: .name)
        }
        if decoderContainer.contains(.cidr)
        {
            self.cidr = try decoderContainer.decode(String?.self, forKey: .cidr)
        }
        if decoderContainer.contains(.descriptionValue)
        {
            self.descriptionValue = try decoderContainer.decode(String?.self, forKey: .descriptionValue)
        }
        if decoderContainer.contains(.createTime)
        {
            self.createTime = try decoderContainer.decode(String?.self, forKey: .createTime)
        }
    }
}
public extension Vpc{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: VpcCodingKeys.self)
         try encoderContainer.encode(region, forKey: .region)
         try encoderContainer.encode(vpcId, forKey: .vpcId)
         try encoderContainer.encode(name, forKey: .name)
         try encoderContainer.encode(cidr, forKey: .cidr)
         try encoderContainer.encode(descriptionValue, forKey: .descriptionValue)
         try encoderContainer.encode(createTime, forKey: .createTime)
    }
}
///  region
public class Region:NSObject,Codable{
    /// 地域代码, 如 cn-east-1
    var regionValue:String?
    /// 地域名称，如 华东一区
    var regionName:String?
    /// 可用区列表
    var azs:[Az?]?



    public override init(){
            super.init()
    }

    enum RegionCodingKeys: String, CodingKey {
        case regionValue = "region"
        case regionName
        case azs
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: RegionCodingKeys.self)
        if decoderContainer.contains(.regionValue)
        {
            self.regionValue = try decoderContainer.decode(String?.self, forKey: .regionValue)
        }
        if decoderContainer.contains(.regionName)
        {
            self.regionName = try decoderContainer.decode(String?.self, forKey: .regionName)
        }
        if decoderContainer.contains(.azs)
        {
            self.azs = try decoderContainer.decode([Az?]?.self, forKey: .azs)
        }
    }
}
public extension Region{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: RegionCodingKeys.self)
         try encoderContainer.encode(regionValue, forKey: .regionValue)
         try encoderContainer.encode(regionName, forKey: .regionName)
         try encoderContainer.encode(azs, forKey: .azs)
    }
}
///  az
public class Az:NSObject,Codable{
    /// 地域代码，如 cn-east-1
    var region:String?
    /// 可用区代码，如 cn-east-1a
    var azValue:String?
    /// 可用区名称
    var azName:String?



    public override init(){
            super.init()
    }

    enum AzCodingKeys: String, CodingKey {
        case region
        case azValue = "az"
        case azName
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: AzCodingKeys.self)
        if decoderContainer.contains(.region)
        {
            self.region = try decoderContainer.decode(String?.self, forKey: .region)
        }
        if decoderContainer.contains(.azValue)
        {
            self.azValue = try decoderContainer.decode(String?.self, forKey: .azValue)
        }
        if decoderContainer.contains(.azName)
        {
            self.azName = try decoderContainer.decode(String?.self, forKey: .azName)
        }
    }
}
public extension Az{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: AzCodingKeys.self)
         try encoderContainer.encode(region, forKey: .region)
         try encoderContainer.encode(azValue, forKey: .azValue)
         try encoderContainer.encode(azName, forKey: .azName)
    }
}

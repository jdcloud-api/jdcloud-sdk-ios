/* Copyright 2018 JDCLOUD.COM

   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at

     http:#www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.

   iotcloudgateway开通接口
   用户开通iotcloudgateway服务相关接口

   OpenAPI spec version: v1
   Contact: 

   NOTE: This class is auto generated by the jdcloud code generator program.
 */


import Foundation
///  ossSpec
public class OssSpec:NSObject,Codable{
    /// OSS AK
    /// Required:true
    var oss_ak:String
    /// OSS SK
    /// Required:true
    var oss_sk:String
    /// OSS region
    /// Required:true
    var oss_region:String
    /// OSS endpoint
    /// Required:true
    var oss_endpoint:String
    /// OSS bucket
    /// Required:true
    var oss_bucket:String



    public  init(oss_ak:String,oss_sk:String,oss_region:String,oss_endpoint:String,oss_bucket:String){
             self.oss_ak = oss_ak
             self.oss_sk = oss_sk
             self.oss_region = oss_region
             self.oss_endpoint = oss_endpoint
             self.oss_bucket = oss_bucket
    }

    enum OssSpecCodingKeys: String, CodingKey {
        case oss_ak
        case oss_sk
        case oss_region
        case oss_endpoint
        case oss_bucket
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: OssSpecCodingKeys.self)
        self.oss_ak = try decoderContainer.decode(String.self, forKey: .oss_ak)
        self.oss_sk = try decoderContainer.decode(String.self, forKey: .oss_sk)
        self.oss_region = try decoderContainer.decode(String.self, forKey: .oss_region)
        self.oss_endpoint = try decoderContainer.decode(String.self, forKey: .oss_endpoint)
        self.oss_bucket = try decoderContainer.decode(String.self, forKey: .oss_bucket)
    }
}
public extension OssSpec{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: OssSpecCodingKeys.self)
         try encoderContainer.encode(oss_ak, forKey: .oss_ak)
         try encoderContainer.encode(oss_sk, forKey: .oss_sk)
         try encoderContainer.encode(oss_region, forKey: .oss_region)
         try encoderContainer.encode(oss_endpoint, forKey: .oss_endpoint)
         try encoderContainer.encode(oss_bucket, forKey: .oss_bucket)
    }
}
///  cloudstorageSpec
public class CloudstorageSpec:NSObject,Codable{
    /// 副本集名称
    /// Required:true
    var rsname:String
    /// 云盘扩容大小
    /// Required:true
    var size:Int



    public  init(rsname:String,size:Int){
             self.rsname = rsname
             self.size = size
    }

    enum CloudstorageSpecCodingKeys: String, CodingKey {
        case rsname
        case size
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: CloudstorageSpecCodingKeys.self)
        self.rsname = try decoderContainer.decode(String.self, forKey: .rsname)
        self.size = try decoderContainer.decode(Int.self, forKey: .size)
    }
}
public extension CloudstorageSpec{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: CloudstorageSpecCodingKeys.self)
         try encoderContainer.encode(rsname, forKey: .rsname)
         try encoderContainer.encode(size, forKey: .size)
    }
}
///  instance
public class Instance:NSObject,Codable{
    /// 实例ID
    var instanceId:String?
    /// 实例名称
    var instanceName:String?
    /// 实例版本
    var instanceVersion:String?
    /// 所在地域
    var instanceRegion:String?
    /// 实例状态，running：运行，error：错误，creating：创建中，changing：变配中
    var instanceStatus:String?
    /// 实例硬件配置规格 例如:2C4G20G
    var instanceFlavor:String?
    /// az信息
    var azId:String?
    /// 所属VPC的ID
    var vpcId:String?
    /// 所属子网的ID
    var subnetId:String?
    /// 下行控制管理域名和设备上行链接的外网域名
    var exposedDomain:String?
    /// 节点个数
    var replica:Int?
    /// 云硬盘大小
    var cloudstorage:Int?
    /// 实例服务配置
    var serviceConfig:String?
    /// 创建时间
    var createTime:String?
    /// 网关设备ID
    var gw_dev_id:String?
    /// 网关子设备数
    var gw_dev_num:Int?
    /// 计费类型
    var chargeType:Int?
    /// 计费过期时间
    var chargeExpired:String?



    public override init(){
            super.init()
    }

    enum InstanceCodingKeys: String, CodingKey {
        case instanceId
        case instanceName
        case instanceVersion
        case instanceRegion
        case instanceStatus
        case instanceFlavor
        case azId
        case vpcId
        case subnetId
        case exposedDomain
        case replica
        case cloudstorage
        case serviceConfig
        case createTime
        case gw_dev_id
        case gw_dev_num
        case chargeType
        case chargeExpired
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: InstanceCodingKeys.self)
        if decoderContainer.contains(.instanceId)
        {
            self.instanceId = try decoderContainer.decode(String?.self, forKey: .instanceId)
        }
        if decoderContainer.contains(.instanceName)
        {
            self.instanceName = try decoderContainer.decode(String?.self, forKey: .instanceName)
        }
        if decoderContainer.contains(.instanceVersion)
        {
            self.instanceVersion = try decoderContainer.decode(String?.self, forKey: .instanceVersion)
        }
        if decoderContainer.contains(.instanceRegion)
        {
            self.instanceRegion = try decoderContainer.decode(String?.self, forKey: .instanceRegion)
        }
        if decoderContainer.contains(.instanceStatus)
        {
            self.instanceStatus = try decoderContainer.decode(String?.self, forKey: .instanceStatus)
        }
        if decoderContainer.contains(.instanceFlavor)
        {
            self.instanceFlavor = try decoderContainer.decode(String?.self, forKey: .instanceFlavor)
        }
        if decoderContainer.contains(.azId)
        {
            self.azId = try decoderContainer.decode(String?.self, forKey: .azId)
        }
        if decoderContainer.contains(.vpcId)
        {
            self.vpcId = try decoderContainer.decode(String?.self, forKey: .vpcId)
        }
        if decoderContainer.contains(.subnetId)
        {
            self.subnetId = try decoderContainer.decode(String?.self, forKey: .subnetId)
        }
        if decoderContainer.contains(.exposedDomain)
        {
            self.exposedDomain = try decoderContainer.decode(String?.self, forKey: .exposedDomain)
        }
        if decoderContainer.contains(.replica)
        {
            self.replica = try decoderContainer.decode(Int?.self, forKey: .replica)
        }
        if decoderContainer.contains(.cloudstorage)
        {
            self.cloudstorage = try decoderContainer.decode(Int?.self, forKey: .cloudstorage)
        }
        if decoderContainer.contains(.serviceConfig)
        {
            self.serviceConfig = try decoderContainer.decode(String?.self, forKey: .serviceConfig)
        }
        if decoderContainer.contains(.createTime)
        {
            self.createTime = try decoderContainer.decode(String?.self, forKey: .createTime)
        }
        if decoderContainer.contains(.gw_dev_id)
        {
            self.gw_dev_id = try decoderContainer.decode(String?.self, forKey: .gw_dev_id)
        }
        if decoderContainer.contains(.gw_dev_num)
        {
            self.gw_dev_num = try decoderContainer.decode(Int?.self, forKey: .gw_dev_num)
        }
        if decoderContainer.contains(.chargeType)
        {
            self.chargeType = try decoderContainer.decode(Int?.self, forKey: .chargeType)
        }
        if decoderContainer.contains(.chargeExpired)
        {
            self.chargeExpired = try decoderContainer.decode(String?.self, forKey: .chargeExpired)
        }
    }
}
public extension Instance{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: InstanceCodingKeys.self)
         try encoderContainer.encode(instanceId, forKey: .instanceId)
         try encoderContainer.encode(instanceName, forKey: .instanceName)
         try encoderContainer.encode(instanceVersion, forKey: .instanceVersion)
         try encoderContainer.encode(instanceRegion, forKey: .instanceRegion)
         try encoderContainer.encode(instanceStatus, forKey: .instanceStatus)
         try encoderContainer.encode(instanceFlavor, forKey: .instanceFlavor)
         try encoderContainer.encode(azId, forKey: .azId)
         try encoderContainer.encode(vpcId, forKey: .vpcId)
         try encoderContainer.encode(subnetId, forKey: .subnetId)
         try encoderContainer.encode(exposedDomain, forKey: .exposedDomain)
         try encoderContainer.encode(replica, forKey: .replica)
         try encoderContainer.encode(cloudstorage, forKey: .cloudstorage)
         try encoderContainer.encode(serviceConfig, forKey: .serviceConfig)
         try encoderContainer.encode(createTime, forKey: .createTime)
         try encoderContainer.encode(gw_dev_id, forKey: .gw_dev_id)
         try encoderContainer.encode(gw_dev_num, forKey: .gw_dev_num)
         try encoderContainer.encode(chargeType, forKey: .chargeType)
         try encoderContainer.encode(chargeExpired, forKey: .chargeExpired)
    }
}
///  instanceConfig
public class InstanceConfig:NSObject,Codable{
    /// 服务id
    /// Required:true
    var serviceId:String
    /// 产品key
    /// Required:true
    var productKey:String
    /// 产品secret
    /// Required:true
    var productSecret:String
    /// 支持协议(jt808,gbt32960)
    /// Required:true
    var protocolValue:String
    /// hub mqtt地址
    /// Required:true
    var mqttAddr:String
    /// hub http地址
    /// Required:true
    var httpAddr:String
    /// redis地址
    /// Required:true
    var redisAddr:String
    /// 本地多媒体存放路径
    /// Required:true
    var mediaStore:String
    /// 网关设备ID
    /// Required:true
    var gwdevId:String
    /// 关联的OSS配置
    var ossSpec:OssSpec?
    /// 关联的DW认证配置
    var dwAuthSpec:DwAuthSpec?



    public  init(serviceId:String,productKey:String,productSecret:String,protocolValue:String,mqttAddr:String,httpAddr:String,redisAddr:String,mediaStore:String,gwdevId:String){
             self.serviceId = serviceId
             self.productKey = productKey
             self.productSecret = productSecret
             self.protocolValue = protocolValue
             self.mqttAddr = mqttAddr
             self.httpAddr = httpAddr
             self.redisAddr = redisAddr
             self.mediaStore = mediaStore
             self.gwdevId = gwdevId
    }

    enum InstanceConfigCodingKeys: String, CodingKey {
        case serviceId
        case productKey
        case productSecret
        case protocolValue = "protocol"
        case mqttAddr
        case httpAddr
        case redisAddr
        case mediaStore
        case gwdevId
        case ossSpec
        case dwAuthSpec
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: InstanceConfigCodingKeys.self)
        self.serviceId = try decoderContainer.decode(String.self, forKey: .serviceId)
        self.productKey = try decoderContainer.decode(String.self, forKey: .productKey)
        self.productSecret = try decoderContainer.decode(String.self, forKey: .productSecret)
        self.protocolValue = try decoderContainer.decode(String.self, forKey: .protocolValue)
        self.mqttAddr = try decoderContainer.decode(String.self, forKey: .mqttAddr)
        self.httpAddr = try decoderContainer.decode(String.self, forKey: .httpAddr)
        self.redisAddr = try decoderContainer.decode(String.self, forKey: .redisAddr)
        self.mediaStore = try decoderContainer.decode(String.self, forKey: .mediaStore)
        self.gwdevId = try decoderContainer.decode(String.self, forKey: .gwdevId)
        if decoderContainer.contains(.ossSpec)
        {
            self.ossSpec = try decoderContainer.decode(OssSpec?.self, forKey: .ossSpec)
        }
        if decoderContainer.contains(.dwAuthSpec)
        {
            self.dwAuthSpec = try decoderContainer.decode(DwAuthSpec?.self, forKey: .dwAuthSpec)
        }
    }
}
public extension InstanceConfig{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: InstanceConfigCodingKeys.self)
         try encoderContainer.encode(serviceId, forKey: .serviceId)
         try encoderContainer.encode(productKey, forKey: .productKey)
         try encoderContainer.encode(productSecret, forKey: .productSecret)
         try encoderContainer.encode(protocolValue, forKey: .protocolValue)
         try encoderContainer.encode(mqttAddr, forKey: .mqttAddr)
         try encoderContainer.encode(httpAddr, forKey: .httpAddr)
         try encoderContainer.encode(redisAddr, forKey: .redisAddr)
         try encoderContainer.encode(mediaStore, forKey: .mediaStore)
         try encoderContainer.encode(gwdevId, forKey: .gwdevId)
         try encoderContainer.encode(ossSpec, forKey: .ossSpec)
         try encoderContainer.encode(dwAuthSpec, forKey: .dwAuthSpec)
    }
}
///  deviceControlSpec
public class DeviceControlSpec:NSObject,Codable{
    /// 请求ID
    /// Required:true
    var request_id:String
    /// 设备列表
    /// Required:true
    var peers:String
    /// 设备指令串base64
    /// Required:true
    var br_msg:String



    public  init(request_id:String,peers:String,br_msg:String){
             self.request_id = request_id
             self.peers = peers
             self.br_msg = br_msg
    }

    enum DeviceControlSpecCodingKeys: String, CodingKey {
        case request_id
        case peers
        case br_msg
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: DeviceControlSpecCodingKeys.self)
        self.request_id = try decoderContainer.decode(String.self, forKey: .request_id)
        self.peers = try decoderContainer.decode(String.self, forKey: .peers)
        self.br_msg = try decoderContainer.decode(String.self, forKey: .br_msg)
    }
}
public extension DeviceControlSpec{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: DeviceControlSpecCodingKeys.self)
         try encoderContainer.encode(request_id, forKey: .request_id)
         try encoderContainer.encode(peers, forKey: .peers)
         try encoderContainer.encode(br_msg, forKey: .br_msg)
    }
}
///  resource
public class Resource:NSObject,Codable{
    /// 资源ID
    var resourceId:String?
    /// 资源名称
    var resourceName:String?



    public override init(){
            super.init()
    }

    enum ResourceCodingKeys: String, CodingKey {
        case resourceId
        case resourceName
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: ResourceCodingKeys.self)
        if decoderContainer.contains(.resourceId)
        {
            self.resourceId = try decoderContainer.decode(String?.self, forKey: .resourceId)
        }
        if decoderContainer.contains(.resourceName)
        {
            self.resourceName = try decoderContainer.decode(String?.self, forKey: .resourceName)
        }
    }
}
public extension Resource{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: ResourceCodingKeys.self)
         try encoderContainer.encode(resourceId, forKey: .resourceId)
         try encoderContainer.encode(resourceName, forKey: .resourceName)
    }
}
///  flavorSpec
public class FlavorSpec:NSObject,Codable{
    /// 副本集名称
    /// Required:true
    var rsname:String
    /// 副本规格
    /// Required:true
    var flavor:String



    public  init(rsname:String,flavor:String){
             self.rsname = rsname
             self.flavor = flavor
    }

    enum FlavorSpecCodingKeys: String, CodingKey {
        case rsname
        case flavor
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: FlavorSpecCodingKeys.self)
        self.rsname = try decoderContainer.decode(String.self, forKey: .rsname)
        self.flavor = try decoderContainer.decode(String.self, forKey: .flavor)
    }
}
public extension FlavorSpec{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: FlavorSpecCodingKeys.self)
         try encoderContainer.encode(rsname, forKey: .rsname)
         try encoderContainer.encode(flavor, forKey: .flavor)
    }
}
///  instanceSpec
public class InstanceSpec:NSObject,Codable{
    /// 实例集群名称
    /// Required:true
    var instanceName:String
    /// iotcloudgateway版本
    /// Required:true
    var instanceVersion:String
    /// 应用服务名称
    /// Required:true
    var serviceName:String
    /// 实例操作
    /// Required:true
    var actionName:String
    /// 私有网络vpcId
    /// Required:true
    var vpcId:String
    /// 子网subnetId
    /// Required:true
    var subnetId:String
    /// 可用区ID， 如果两个可用区一样，也需输入两个azId
    /// Required:true
    var azId:[String?]?
    /// source type
    /// Required:true
    var sourceType:String
    /// AZ1实例硬件规格
    /// Required:true
    var az1flavor:String
    /// AZ1节点个数
    /// Required:true
    var az1replica:Int
    /// AZ1云硬盘大小
    /// Required:true
    var az1storagesize:Int
    /// AZ2实例硬件规格
    /// Required:true
    var az2flavor:String
    /// AZ2节点个数
    /// Required:true
    var az2replica:Int
    /// AZ2云硬盘大小
    /// Required:true
    var az2storagesize:Int



    public  init(instanceName:String,instanceVersion:String,serviceName:String,actionName:String,vpcId:String,subnetId:String,azId:[String?]?,sourceType:String,az1flavor:String,az1replica:Int,az1storagesize:Int,az2flavor:String,az2replica:Int,az2storagesize:Int){
             self.instanceName = instanceName
             self.instanceVersion = instanceVersion
             self.serviceName = serviceName
             self.actionName = actionName
             self.vpcId = vpcId
             self.subnetId = subnetId
             self.azId = azId
             self.sourceType = sourceType
             self.az1flavor = az1flavor
             self.az1replica = az1replica
             self.az1storagesize = az1storagesize
             self.az2flavor = az2flavor
             self.az2replica = az2replica
             self.az2storagesize = az2storagesize
    }

    enum InstanceSpecCodingKeys: String, CodingKey {
        case instanceName
        case instanceVersion
        case serviceName
        case actionName
        case vpcId
        case subnetId
        case azId
        case sourceType
        case az1flavor
        case az1replica
        case az1storagesize
        case az2flavor
        case az2replica
        case az2storagesize
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: InstanceSpecCodingKeys.self)
        self.instanceName = try decoderContainer.decode(String.self, forKey: .instanceName)
        self.instanceVersion = try decoderContainer.decode(String.self, forKey: .instanceVersion)
        self.serviceName = try decoderContainer.decode(String.self, forKey: .serviceName)
        self.actionName = try decoderContainer.decode(String.self, forKey: .actionName)
        self.vpcId = try decoderContainer.decode(String.self, forKey: .vpcId)
        self.subnetId = try decoderContainer.decode(String.self, forKey: .subnetId)
        self.azId = try decoderContainer.decode([String?]?.self, forKey: .azId)
        self.sourceType = try decoderContainer.decode(String.self, forKey: .sourceType)
        self.az1flavor = try decoderContainer.decode(String.self, forKey: .az1flavor)
        self.az1replica = try decoderContainer.decode(Int.self, forKey: .az1replica)
        self.az1storagesize = try decoderContainer.decode(Int.self, forKey: .az1storagesize)
        self.az2flavor = try decoderContainer.decode(String.self, forKey: .az2flavor)
        self.az2replica = try decoderContainer.decode(Int.self, forKey: .az2replica)
        self.az2storagesize = try decoderContainer.decode(Int.self, forKey: .az2storagesize)
    }
}
public extension InstanceSpec{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: InstanceSpecCodingKeys.self)
         try encoderContainer.encode(instanceName, forKey: .instanceName)
         try encoderContainer.encode(instanceVersion, forKey: .instanceVersion)
         try encoderContainer.encode(serviceName, forKey: .serviceName)
         try encoderContainer.encode(actionName, forKey: .actionName)
         try encoderContainer.encode(vpcId, forKey: .vpcId)
         try encoderContainer.encode(subnetId, forKey: .subnetId)
         try encoderContainer.encode(azId, forKey: .azId)
         try encoderContainer.encode(sourceType, forKey: .sourceType)
         try encoderContainer.encode(az1flavor, forKey: .az1flavor)
         try encoderContainer.encode(az1replica, forKey: .az1replica)
         try encoderContainer.encode(az1storagesize, forKey: .az1storagesize)
         try encoderContainer.encode(az2flavor, forKey: .az2flavor)
         try encoderContainer.encode(az2replica, forKey: .az2replica)
         try encoderContainer.encode(az2storagesize, forKey: .az2storagesize)
    }
}
///  erpinstance
public class Erpinstance:NSObject,Codable{
    /// 用户Pin
    var userPin:String?
    /// 实例ID
    var instanceId:String?
    /// 实例名称
    var instanceName:String?
    /// 实例版本
    var instanceVersion:String?
    /// 所在地域
    var instanceRegion:String?
    /// 实例状态，running：运行，error：错误，creating：创建中，changing：变配中
    var instanceStatus:String?
    /// 实例硬件配置规格 例如:2C4G20G
    var instanceFlavor:String?
    /// az信息
    var azId:String?
    /// 所属VPC的ID
    var vpcId:String?
    /// 所属子网的ID
    var subnetId:String?
    /// 下行控制管理域名和设备上行链接的外网域名
    var exposedDomain:String?
    /// 节点个数
    var replica:Int?
    /// 云硬盘大小
    var cloudstorage:Int?
    /// 实例服务配置
    var serviceConfig:String?
    /// 创建时间
    var createTime:String?
    /// 网关设备ID
    var gw_dev_id:String?
    /// 网关子设备数
    var gw_dev_num:Int?
    /// 计费类型
    var chargeType:Int?
    /// 计费过期时间
    var chargeExpired:String?
    /// 是否已经软删除
    var is_deleted:Int?



    public override init(){
            super.init()
    }

    enum ErpinstanceCodingKeys: String, CodingKey {
        case userPin
        case instanceId
        case instanceName
        case instanceVersion
        case instanceRegion
        case instanceStatus
        case instanceFlavor
        case azId
        case vpcId
        case subnetId
        case exposedDomain
        case replica
        case cloudstorage
        case serviceConfig
        case createTime
        case gw_dev_id
        case gw_dev_num
        case chargeType
        case chargeExpired
        case is_deleted
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: ErpinstanceCodingKeys.self)
        if decoderContainer.contains(.userPin)
        {
            self.userPin = try decoderContainer.decode(String?.self, forKey: .userPin)
        }
        if decoderContainer.contains(.instanceId)
        {
            self.instanceId = try decoderContainer.decode(String?.self, forKey: .instanceId)
        }
        if decoderContainer.contains(.instanceName)
        {
            self.instanceName = try decoderContainer.decode(String?.self, forKey: .instanceName)
        }
        if decoderContainer.contains(.instanceVersion)
        {
            self.instanceVersion = try decoderContainer.decode(String?.self, forKey: .instanceVersion)
        }
        if decoderContainer.contains(.instanceRegion)
        {
            self.instanceRegion = try decoderContainer.decode(String?.self, forKey: .instanceRegion)
        }
        if decoderContainer.contains(.instanceStatus)
        {
            self.instanceStatus = try decoderContainer.decode(String?.self, forKey: .instanceStatus)
        }
        if decoderContainer.contains(.instanceFlavor)
        {
            self.instanceFlavor = try decoderContainer.decode(String?.self, forKey: .instanceFlavor)
        }
        if decoderContainer.contains(.azId)
        {
            self.azId = try decoderContainer.decode(String?.self, forKey: .azId)
        }
        if decoderContainer.contains(.vpcId)
        {
            self.vpcId = try decoderContainer.decode(String?.self, forKey: .vpcId)
        }
        if decoderContainer.contains(.subnetId)
        {
            self.subnetId = try decoderContainer.decode(String?.self, forKey: .subnetId)
        }
        if decoderContainer.contains(.exposedDomain)
        {
            self.exposedDomain = try decoderContainer.decode(String?.self, forKey: .exposedDomain)
        }
        if decoderContainer.contains(.replica)
        {
            self.replica = try decoderContainer.decode(Int?.self, forKey: .replica)
        }
        if decoderContainer.contains(.cloudstorage)
        {
            self.cloudstorage = try decoderContainer.decode(Int?.self, forKey: .cloudstorage)
        }
        if decoderContainer.contains(.serviceConfig)
        {
            self.serviceConfig = try decoderContainer.decode(String?.self, forKey: .serviceConfig)
        }
        if decoderContainer.contains(.createTime)
        {
            self.createTime = try decoderContainer.decode(String?.self, forKey: .createTime)
        }
        if decoderContainer.contains(.gw_dev_id)
        {
            self.gw_dev_id = try decoderContainer.decode(String?.self, forKey: .gw_dev_id)
        }
        if decoderContainer.contains(.gw_dev_num)
        {
            self.gw_dev_num = try decoderContainer.decode(Int?.self, forKey: .gw_dev_num)
        }
        if decoderContainer.contains(.chargeType)
        {
            self.chargeType = try decoderContainer.decode(Int?.self, forKey: .chargeType)
        }
        if decoderContainer.contains(.chargeExpired)
        {
            self.chargeExpired = try decoderContainer.decode(String?.self, forKey: .chargeExpired)
        }
        if decoderContainer.contains(.is_deleted)
        {
            self.is_deleted = try decoderContainer.decode(Int?.self, forKey: .is_deleted)
        }
    }
}
public extension Erpinstance{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: ErpinstanceCodingKeys.self)
         try encoderContainer.encode(userPin, forKey: .userPin)
         try encoderContainer.encode(instanceId, forKey: .instanceId)
         try encoderContainer.encode(instanceName, forKey: .instanceName)
         try encoderContainer.encode(instanceVersion, forKey: .instanceVersion)
         try encoderContainer.encode(instanceRegion, forKey: .instanceRegion)
         try encoderContainer.encode(instanceStatus, forKey: .instanceStatus)
         try encoderContainer.encode(instanceFlavor, forKey: .instanceFlavor)
         try encoderContainer.encode(azId, forKey: .azId)
         try encoderContainer.encode(vpcId, forKey: .vpcId)
         try encoderContainer.encode(subnetId, forKey: .subnetId)
         try encoderContainer.encode(exposedDomain, forKey: .exposedDomain)
         try encoderContainer.encode(replica, forKey: .replica)
         try encoderContainer.encode(cloudstorage, forKey: .cloudstorage)
         try encoderContainer.encode(serviceConfig, forKey: .serviceConfig)
         try encoderContainer.encode(createTime, forKey: .createTime)
         try encoderContainer.encode(gw_dev_id, forKey: .gw_dev_id)
         try encoderContainer.encode(gw_dev_num, forKey: .gw_dev_num)
         try encoderContainer.encode(chargeType, forKey: .chargeType)
         try encoderContainer.encode(chargeExpired, forKey: .chargeExpired)
         try encoderContainer.encode(is_deleted, forKey: .is_deleted)
    }
}
///  replicaSpec
public class ReplicaSpec:NSObject,Codable{
    /// 副本集名称
    /// Required:true
    var rsname:String
    /// 副本数
    /// Required:true
    var replica:Int



    public  init(rsname:String,replica:Int){
             self.rsname = rsname
             self.replica = replica
    }

    enum ReplicaSpecCodingKeys: String, CodingKey {
        case rsname
        case replica
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: ReplicaSpecCodingKeys.self)
        self.rsname = try decoderContainer.decode(String.self, forKey: .rsname)
        self.replica = try decoderContainer.decode(Int.self, forKey: .replica)
    }
}
public extension ReplicaSpec{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: ReplicaSpecCodingKeys.self)
         try encoderContainer.encode(rsname, forKey: .rsname)
         try encoderContainer.encode(replica, forKey: .replica)
    }
}
///  newInstanceSpec
public class NewInstanceSpec:NSObject,Codable{
    /// 可用区ID， 如果两个可用区一样，也需输入两个azId
    /// Required:true
    var azId:[String?]?
    /// AZ1实例硬件规格
    /// Required:true
    var az1flavor:String
    /// AZ1节点个数
    /// Required:true
    var az1replica:Int
    /// AZ1云硬盘大小
    /// Required:true
    var az1storagesize:Int
    /// AZ2实例硬件规格
    /// Required:true
    var az2flavor:String
    /// AZ2节点个数
    /// Required:true
    var az2replica:Int
    /// AZ2云硬盘大小
    /// Required:true
    var az2storagesize:Int



    public  init(azId:[String?]?,az1flavor:String,az1replica:Int,az1storagesize:Int,az2flavor:String,az2replica:Int,az2storagesize:Int){
             self.azId = azId
             self.az1flavor = az1flavor
             self.az1replica = az1replica
             self.az1storagesize = az1storagesize
             self.az2flavor = az2flavor
             self.az2replica = az2replica
             self.az2storagesize = az2storagesize
    }

    enum NewInstanceSpecCodingKeys: String, CodingKey {
        case azId
        case az1flavor
        case az1replica
        case az1storagesize
        case az2flavor
        case az2replica
        case az2storagesize
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: NewInstanceSpecCodingKeys.self)
        self.azId = try decoderContainer.decode([String?]?.self, forKey: .azId)
        self.az1flavor = try decoderContainer.decode(String.self, forKey: .az1flavor)
        self.az1replica = try decoderContainer.decode(Int.self, forKey: .az1replica)
        self.az1storagesize = try decoderContainer.decode(Int.self, forKey: .az1storagesize)
        self.az2flavor = try decoderContainer.decode(String.self, forKey: .az2flavor)
        self.az2replica = try decoderContainer.decode(Int.self, forKey: .az2replica)
        self.az2storagesize = try decoderContainer.decode(Int.self, forKey: .az2storagesize)
    }
}
public extension NewInstanceSpec{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: NewInstanceSpecCodingKeys.self)
         try encoderContainer.encode(azId, forKey: .azId)
         try encoderContainer.encode(az1flavor, forKey: .az1flavor)
         try encoderContainer.encode(az1replica, forKey: .az1replica)
         try encoderContainer.encode(az1storagesize, forKey: .az1storagesize)
         try encoderContainer.encode(az2flavor, forKey: .az2flavor)
         try encoderContainer.encode(az2replica, forKey: .az2replica)
         try encoderContainer.encode(az2storagesize, forKey: .az2storagesize)
    }
}
///  dwAuthSpec
public class DwAuthSpec:NSObject,Codable{
    /// 产品key
    /// Required:true
    var productKey:String
    /// 设备IDENT
    /// Required:true
    var deviceIdent:String
    /// 设备密钥
    /// Required:true
    var deviceSecret:String



    public  init(productKey:String,deviceIdent:String,deviceSecret:String){
             self.productKey = productKey
             self.deviceIdent = deviceIdent
             self.deviceSecret = deviceSecret
    }

    enum DwAuthSpecCodingKeys: String, CodingKey {
        case productKey
        case deviceIdent
        case deviceSecret
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: DwAuthSpecCodingKeys.self)
        self.productKey = try decoderContainer.decode(String.self, forKey: .productKey)
        self.deviceIdent = try decoderContainer.decode(String.self, forKey: .deviceIdent)
        self.deviceSecret = try decoderContainer.decode(String.self, forKey: .deviceSecret)
    }
}
public extension DwAuthSpec{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: DwAuthSpecCodingKeys.self)
         try encoderContainer.encode(productKey, forKey: .productKey)
         try encoderContainer.encode(deviceIdent, forKey: .deviceIdent)
         try encoderContainer.encode(deviceSecret, forKey: .deviceSecret)
    }
}

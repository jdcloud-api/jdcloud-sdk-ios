/* Copyright 2018 JDCLOUD.COM

   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at

     http:#www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.

   
   

   
   Contact: 

   NOTE: This class is auto generated by the jdcloud code generator program.
 */


import Foundation

///  probeInfo
@objc(ProbeInfo)
public class ProbeInfo:NSObject,Codable{
    /// 探测源的所在主机名称
    var name:String?
    /// 探测源的内网ip
    var privateIp:String?
    /// 探测结果,缺点返回null,对应前端显示 &quot;--&quot; ,1:探测正常，2：探测失败，3：探测超时
    var probeResult:Int64?
    /// 插件状态，  1：正常，2：异常
    var probeStatus:Int64?
    /// 探测源的公网ip
    var publicIp:String?
    /// 探测目标状态，1：正常，2：异常(探测失败、探测超时)，缺点返回null,对应前端显示 &quot;--&quot;
    var targetStatus:Int64?
    /// 探测源主机的uuid
    var uuid:String?
    /// 云主机状态，对应云主机的状态,当找不到云主机，状态为&quot;unExist&quot;
    var vmStatus:String?



    public override init(){
            super.init()
    }

    enum ProbeInfoCodingKeys: String, CodingKey {
        case name
        case privateIp
        case probeResult
        case probeStatus
        case publicIp
        case targetStatus
        case uuid
        case vmStatus
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: ProbeInfoCodingKeys.self)
        if decoderContainer.contains(.name)
        {
            self.name = try decoderContainer.decode(String?.self, forKey: .name)
        }
        if decoderContainer.contains(.privateIp)
        {
            self.privateIp = try decoderContainer.decode(String?.self, forKey: .privateIp)
        }
        if decoderContainer.contains(.probeResult)
        {
            self.probeResult = try decoderContainer.decode(Int64?.self, forKey: .probeResult)
        }
        if decoderContainer.contains(.probeStatus)
        {
            self.probeStatus = try decoderContainer.decode(Int64?.self, forKey: .probeStatus)
        }
        if decoderContainer.contains(.publicIp)
        {
            self.publicIp = try decoderContainer.decode(String?.self, forKey: .publicIp)
        }
        if decoderContainer.contains(.targetStatus)
        {
            self.targetStatus = try decoderContainer.decode(Int64?.self, forKey: .targetStatus)
        }
        if decoderContainer.contains(.uuid)
        {
            self.uuid = try decoderContainer.decode(String?.self, forKey: .uuid)
        }
        if decoderContainer.contains(.vmStatus)
        {
            self.vmStatus = try decoderContainer.decode(String?.self, forKey: .vmStatus)
        }
    }
}
public extension ProbeInfo{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: ProbeInfoCodingKeys.self)
         try encoderContainer.encode(name, forKey: .name)
         try encoderContainer.encode(privateIp, forKey: .privateIp)
         try encoderContainer.encode(probeResult, forKey: .probeResult)
         try encoderContainer.encode(probeStatus, forKey: .probeStatus)
         try encoderContainer.encode(publicIp, forKey: .publicIp)
         try encoderContainer.encode(targetStatus, forKey: .targetStatus)
         try encoderContainer.encode(uuid, forKey: .uuid)
         try encoderContainer.encode(vmStatus, forKey: .vmStatus)
    }
}

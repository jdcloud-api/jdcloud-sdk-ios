/* Copyright 2018 JDCLOUD.COM

   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at

     http:#www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.

   
   

   
   Contact: 

   NOTE: This class is auto generated by the jdcloud code generator program.
 */


import Foundation

///  Rule
@objc(Rule)
public class Rule:NSObject,Codable{
    /// AutoScalingPolicyID
    var autoScalingPolicyId:String?
    /// calculateUnit
    var calculateUnit:String?
    /// calculation
    var calculation:String?
    /// createTime
    var createTime:String?
    /// dataMeaning
    var dataMeaning:Int64?
    /// 地域
    var datacenter:String?
    /// deleted
    var deleted:Int64?
    /// downSample
    var downSample:String?
    /// enableTime
    var enableTime:String?
    /// enabled
    var enabled:Int64?
    /// uuid
    var id:String?
    /// Idpk
    var idpk:Int64?
    /// isLatest
    var isLatest:Int64?
    /// metric
    var metric:String?
    /// metricId
    var metricId:Int64?
    /// metricName
    var metricName:String?
    /// NoticeLevel
    var noticeLevel:NoticeLevel?
    /// notice_period
    var noticePeriod:Int64?
    /// operation
    var operation:String?
    /// period
    var period:Int64?
    /// pin
    var pin:String?
    /// preVersionId
    var preVersionId:Int64?
    /// region
    var region:String?
    /// 资源 id
    var resourceId:String?
    /// rootRuleID
    var rootRuleId:Int64?
    /// rutye 1:经典监控  5：自定义监控   6：站点监控 7：可用性监控
    var ruleType:Int64?
    /// serviceCode
    var serviceCode:String?
    /// status
    var status:Int64?
    /// statusTime
    var statusTime:String?
    /// tags
    var tags:[String:String?]?
    /// tagsNonGrouping
    var tagsNonGrouping:String?
    /// threshold
    var threshold:Double?
    /// times
    var times:Int64?
    /// updateTime
    var updateTime:String?
    /// version
    var version:Int64?



    public override init(){
            super.init()
    }

    enum RuleCodingKeys: String, CodingKey {
        case autoScalingPolicyId
        case calculateUnit
        case calculation
        case createTime
        case dataMeaning
        case datacenter
        case deleted
        case downSample
        case enableTime
        case enabled
        case id
        case idpk
        case isLatest
        case metric
        case metricId
        case metricName
        case noticeLevel
        case noticePeriod
        case operation
        case period
        case pin
        case preVersionId
        case region
        case resourceId
        case rootRuleId
        case ruleType
        case serviceCode
        case status
        case statusTime
        case tags
        case tagsNonGrouping
        case threshold
        case times
        case updateTime
        case version
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: RuleCodingKeys.self)
        if decoderContainer.contains(.autoScalingPolicyId)
        {
            self.autoScalingPolicyId = try decoderContainer.decode(String?.self, forKey: .autoScalingPolicyId)
        }
        if decoderContainer.contains(.calculateUnit)
        {
            self.calculateUnit = try decoderContainer.decode(String?.self, forKey: .calculateUnit)
        }
        if decoderContainer.contains(.calculation)
        {
            self.calculation = try decoderContainer.decode(String?.self, forKey: .calculation)
        }
        if decoderContainer.contains(.createTime)
        {
            self.createTime = try decoderContainer.decode(String?.self, forKey: .createTime)
        }
        if decoderContainer.contains(.dataMeaning)
        {
            self.dataMeaning = try decoderContainer.decode(Int64?.self, forKey: .dataMeaning)
        }
        if decoderContainer.contains(.datacenter)
        {
            self.datacenter = try decoderContainer.decode(String?.self, forKey: .datacenter)
        }
        if decoderContainer.contains(.deleted)
        {
            self.deleted = try decoderContainer.decode(Int64?.self, forKey: .deleted)
        }
        if decoderContainer.contains(.downSample)
        {
            self.downSample = try decoderContainer.decode(String?.self, forKey: .downSample)
        }
        if decoderContainer.contains(.enableTime)
        {
            self.enableTime = try decoderContainer.decode(String?.self, forKey: .enableTime)
        }
        if decoderContainer.contains(.enabled)
        {
            self.enabled = try decoderContainer.decode(Int64?.self, forKey: .enabled)
        }
        if decoderContainer.contains(.id)
        {
            self.id = try decoderContainer.decode(String?.self, forKey: .id)
        }
        if decoderContainer.contains(.idpk)
        {
            self.idpk = try decoderContainer.decode(Int64?.self, forKey: .idpk)
        }
        if decoderContainer.contains(.isLatest)
        {
            self.isLatest = try decoderContainer.decode(Int64?.self, forKey: .isLatest)
        }
        if decoderContainer.contains(.metric)
        {
            self.metric = try decoderContainer.decode(String?.self, forKey: .metric)
        }
        if decoderContainer.contains(.metricId)
        {
            self.metricId = try decoderContainer.decode(Int64?.self, forKey: .metricId)
        }
        if decoderContainer.contains(.metricName)
        {
            self.metricName = try decoderContainer.decode(String?.self, forKey: .metricName)
        }
        if decoderContainer.contains(.noticeLevel)
        {
            self.noticeLevel = try decoderContainer.decode(NoticeLevel?.self, forKey: .noticeLevel)
        }
        if decoderContainer.contains(.noticePeriod)
        {
            self.noticePeriod = try decoderContainer.decode(Int64?.self, forKey: .noticePeriod)
        }
        if decoderContainer.contains(.operation)
        {
            self.operation = try decoderContainer.decode(String?.self, forKey: .operation)
        }
        if decoderContainer.contains(.period)
        {
            self.period = try decoderContainer.decode(Int64?.self, forKey: .period)
        }
        if decoderContainer.contains(.pin)
        {
            self.pin = try decoderContainer.decode(String?.self, forKey: .pin)
        }
        if decoderContainer.contains(.preVersionId)
        {
            self.preVersionId = try decoderContainer.decode(Int64?.self, forKey: .preVersionId)
        }
        if decoderContainer.contains(.region)
        {
            self.region = try decoderContainer.decode(String?.self, forKey: .region)
        }
        if decoderContainer.contains(.resourceId)
        {
            self.resourceId = try decoderContainer.decode(String?.self, forKey: .resourceId)
        }
        if decoderContainer.contains(.rootRuleId)
        {
            self.rootRuleId = try decoderContainer.decode(Int64?.self, forKey: .rootRuleId)
        }
        if decoderContainer.contains(.ruleType)
        {
            self.ruleType = try decoderContainer.decode(Int64?.self, forKey: .ruleType)
        }
        if decoderContainer.contains(.serviceCode)
        {
            self.serviceCode = try decoderContainer.decode(String?.self, forKey: .serviceCode)
        }
        if decoderContainer.contains(.status)
        {
            self.status = try decoderContainer.decode(Int64?.self, forKey: .status)
        }
        if decoderContainer.contains(.statusTime)
        {
            self.statusTime = try decoderContainer.decode(String?.self, forKey: .statusTime)
        }
        if decoderContainer.contains(.tags)
        {
            self.tags = try decoderContainer.decode([String:String?]?.self, forKey: .tags)
        }
        if decoderContainer.contains(.tagsNonGrouping)
        {
            self.tagsNonGrouping = try decoderContainer.decode(String?.self, forKey: .tagsNonGrouping)
        }
        if decoderContainer.contains(.threshold)
        {
            self.threshold = try decoderContainer.decode(Double?.self, forKey: .threshold)
        }
        if decoderContainer.contains(.times)
        {
            self.times = try decoderContainer.decode(Int64?.self, forKey: .times)
        }
        if decoderContainer.contains(.updateTime)
        {
            self.updateTime = try decoderContainer.decode(String?.self, forKey: .updateTime)
        }
        if decoderContainer.contains(.version)
        {
            self.version = try decoderContainer.decode(Int64?.self, forKey: .version)
        }
    }
}
public extension Rule{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: RuleCodingKeys.self)
         try encoderContainer.encode(autoScalingPolicyId, forKey: .autoScalingPolicyId)
         try encoderContainer.encode(calculateUnit, forKey: .calculateUnit)
         try encoderContainer.encode(calculation, forKey: .calculation)
         try encoderContainer.encode(createTime, forKey: .createTime)
         try encoderContainer.encode(dataMeaning, forKey: .dataMeaning)
         try encoderContainer.encode(datacenter, forKey: .datacenter)
         try encoderContainer.encode(deleted, forKey: .deleted)
         try encoderContainer.encode(downSample, forKey: .downSample)
         try encoderContainer.encode(enableTime, forKey: .enableTime)
         try encoderContainer.encode(enabled, forKey: .enabled)
         try encoderContainer.encode(id, forKey: .id)
         try encoderContainer.encode(idpk, forKey: .idpk)
         try encoderContainer.encode(isLatest, forKey: .isLatest)
         try encoderContainer.encode(metric, forKey: .metric)
         try encoderContainer.encode(metricId, forKey: .metricId)
         try encoderContainer.encode(metricName, forKey: .metricName)
         try encoderContainer.encode(noticeLevel, forKey: .noticeLevel)
         try encoderContainer.encode(noticePeriod, forKey: .noticePeriod)
         try encoderContainer.encode(operation, forKey: .operation)
         try encoderContainer.encode(period, forKey: .period)
         try encoderContainer.encode(pin, forKey: .pin)
         try encoderContainer.encode(preVersionId, forKey: .preVersionId)
         try encoderContainer.encode(region, forKey: .region)
         try encoderContainer.encode(resourceId, forKey: .resourceId)
         try encoderContainer.encode(rootRuleId, forKey: .rootRuleId)
         try encoderContainer.encode(ruleType, forKey: .ruleType)
         try encoderContainer.encode(serviceCode, forKey: .serviceCode)
         try encoderContainer.encode(status, forKey: .status)
         try encoderContainer.encode(statusTime, forKey: .statusTime)
         try encoderContainer.encode(tags, forKey: .tags)
         try encoderContainer.encode(tagsNonGrouping, forKey: .tagsNonGrouping)
         try encoderContainer.encode(threshold, forKey: .threshold)
         try encoderContainer.encode(times, forKey: .times)
         try encoderContainer.encode(updateTime, forKey: .updateTime)
         try encoderContainer.encode(version, forKey: .version)
    }
}

/* Copyright 2018 JDCLOUD.COM

   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at

     http:#www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.

   监控项自定义监控相关接口
   自定义监控项相关接口，提供自定义监控数据上报功能

   OpenAPI spec version: v2
   Contact: 

   NOTE: This class is auto generated by the jdcloud code generator program.
 */


import Foundation
///  templateVoV2
public class TemplateVoV2:NSObject,Codable{
    /// CreateTime
    var createTime:String?
    /// 模板描述
    var descriptionValue:String?
    /// 模板所属资源的GroupCode
    var dimension:String?
    /// dimension的名字
    var dimensionName:String?
    /// 该模板关联策略的数量
    var linkPolicyCount:Int64?
    /// 该模板所关联的策略
    var linkPolicyInfos:[LinkPolicyInfo?]?
    /// 用户
    var pin:String?
    /// 模板所属资源类型
    var product:String?
    /// product的名字
    var productName:String?
    /// 模板内包含的规则数量
    var rulesCount:Int64?
    /// 模板所属ServiceCode
    var serviceCode:String?
    /// 模板id
    var templateId:Int64?
    /// 模板名称
    var templateName:String?
    /// 模板内包含的触发条件
    var templateRules:[TemplateRulesVo?]?
    /// 模板内包含的提供给前端的拼接好的触发条件
    var templateRulesString:[String?]?
    /// 模板类型，区分默认模板和用户自定义模板：1表示默认模板，2表示用户自定义模板
    var templateType:Int64?
    /// UpdateTime
    var updateTime:String?
    /// 模板uuid
    var uuid:String?



    public override init(){
            super.init()
    }

    enum TemplateVoV2CodingKeys: String, CodingKey {
        case createTime
        case descriptionValue = "description"
        case dimension
        case dimensionName
        case linkPolicyCount
        case linkPolicyInfos
        case pin
        case product
        case productName
        case rulesCount
        case serviceCode
        case templateId
        case templateName
        case templateRules
        case templateRulesString
        case templateType
        case updateTime
        case uuid
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: TemplateVoV2CodingKeys.self)
        if decoderContainer.contains(.createTime)
        {
            self.createTime = try decoderContainer.decode(String?.self, forKey: .createTime)
        }
        if decoderContainer.contains(.descriptionValue)
        {
            self.descriptionValue = try decoderContainer.decode(String?.self, forKey: .descriptionValue)
        }
        if decoderContainer.contains(.dimension)
        {
            self.dimension = try decoderContainer.decode(String?.self, forKey: .dimension)
        }
        if decoderContainer.contains(.dimensionName)
        {
            self.dimensionName = try decoderContainer.decode(String?.self, forKey: .dimensionName)
        }
        if decoderContainer.contains(.linkPolicyCount)
        {
            self.linkPolicyCount = try decoderContainer.decode(Int64?.self, forKey: .linkPolicyCount)
        }
        if decoderContainer.contains(.linkPolicyInfos)
        {
            self.linkPolicyInfos = try decoderContainer.decode([LinkPolicyInfo?]?.self, forKey: .linkPolicyInfos)
        }
        if decoderContainer.contains(.pin)
        {
            self.pin = try decoderContainer.decode(String?.self, forKey: .pin)
        }
        if decoderContainer.contains(.product)
        {
            self.product = try decoderContainer.decode(String?.self, forKey: .product)
        }
        if decoderContainer.contains(.productName)
        {
            self.productName = try decoderContainer.decode(String?.self, forKey: .productName)
        }
        if decoderContainer.contains(.rulesCount)
        {
            self.rulesCount = try decoderContainer.decode(Int64?.self, forKey: .rulesCount)
        }
        if decoderContainer.contains(.serviceCode)
        {
            self.serviceCode = try decoderContainer.decode(String?.self, forKey: .serviceCode)
        }
        if decoderContainer.contains(.templateId)
        {
            self.templateId = try decoderContainer.decode(Int64?.self, forKey: .templateId)
        }
        if decoderContainer.contains(.templateName)
        {
            self.templateName = try decoderContainer.decode(String?.self, forKey: .templateName)
        }
        if decoderContainer.contains(.templateRules)
        {
            self.templateRules = try decoderContainer.decode([TemplateRulesVo?]?.self, forKey: .templateRules)
        }
        if decoderContainer.contains(.templateRulesString)
        {
            self.templateRulesString = try decoderContainer.decode([String?]?.self, forKey: .templateRulesString)
        }
        if decoderContainer.contains(.templateType)
        {
            self.templateType = try decoderContainer.decode(Int64?.self, forKey: .templateType)
        }
        if decoderContainer.contains(.updateTime)
        {
            self.updateTime = try decoderContainer.decode(String?.self, forKey: .updateTime)
        }
        if decoderContainer.contains(.uuid)
        {
            self.uuid = try decoderContainer.decode(String?.self, forKey: .uuid)
        }
    }
}
public extension TemplateVoV2{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: TemplateVoV2CodingKeys.self)
         try encoderContainer.encode(createTime, forKey: .createTime)
         try encoderContainer.encode(descriptionValue, forKey: .descriptionValue)
         try encoderContainer.encode(dimension, forKey: .dimension)
         try encoderContainer.encode(dimensionName, forKey: .dimensionName)
         try encoderContainer.encode(linkPolicyCount, forKey: .linkPolicyCount)
         try encoderContainer.encode(linkPolicyInfos, forKey: .linkPolicyInfos)
         try encoderContainer.encode(pin, forKey: .pin)
         try encoderContainer.encode(product, forKey: .product)
         try encoderContainer.encode(productName, forKey: .productName)
         try encoderContainer.encode(rulesCount, forKey: .rulesCount)
         try encoderContainer.encode(serviceCode, forKey: .serviceCode)
         try encoderContainer.encode(templateId, forKey: .templateId)
         try encoderContainer.encode(templateName, forKey: .templateName)
         try encoderContainer.encode(templateRules, forKey: .templateRules)
         try encoderContainer.encode(templateRulesString, forKey: .templateRulesString)
         try encoderContainer.encode(templateType, forKey: .templateType)
         try encoderContainer.encode(updateTime, forKey: .updateTime)
         try encoderContainer.encode(uuid, forKey: .uuid)
    }
}
///  templateRulesVo
public class TemplateRulesVo:NSObject,Codable{
    /// 监控项单位
    var calculateUnit:String?
    /// 统计方法：平均值&#x3D;avg、最大值&#x3D;max、最小值&#x3D;min
    var calculation:String?
    /// CreateTime
    var createTime:String?
    /// 是否删除 1正常，0删除
    var deleted:Int64?
    /// downSample
    var downSample:String?
    /// 触发条件ID
    var id:Int64?
    /// 监控项
    var metric:String?
    /// 监控项ID
    var metricId:Int64?
    /// 监控项名称
    var metricName:String?
    /// NoticeLevel
    var noticeLevel:NoticeLevel?
    /// 通知周期
    var noticePeriod:Int64?
    /// 报警比较符，只能为以下几种lte(&lt;&#x3D;),lt(&lt;),gt(&gt;),gte(&gt;&#x3D;),eq(&#x3D;&#x3D;),ne(!&#x3D;)
    var operation:String?
    /// 统计周期（单位：分钟）
    var period:Int64?
    /// 规则类型
    var ruleType:Int64?
    /// 规则所属资源类型
    var serviceCode:String?
    /// 监控项附属信息
    var tag:String?
    /// 多值标签
    var tags:[String:String?]?
    /// 阈值
    var threshold:Double?
    /// 连续多少次后报警
    var times:Int64?
    /// UpdateTime
    var updateTime:String?
    /// 触发条件UUID
    var uuid:String?



    public override init(){
            super.init()
    }

    enum TemplateRulesVoCodingKeys: String, CodingKey {
        case calculateUnit
        case calculation
        case createTime
        case deleted
        case downSample
        case id
        case metric
        case metricId
        case metricName
        case noticeLevel
        case noticePeriod
        case operation
        case period
        case ruleType
        case serviceCode
        case tag
        case tags
        case threshold
        case times
        case updateTime
        case uuid
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: TemplateRulesVoCodingKeys.self)
        if decoderContainer.contains(.calculateUnit)
        {
            self.calculateUnit = try decoderContainer.decode(String?.self, forKey: .calculateUnit)
        }
        if decoderContainer.contains(.calculation)
        {
            self.calculation = try decoderContainer.decode(String?.self, forKey: .calculation)
        }
        if decoderContainer.contains(.createTime)
        {
            self.createTime = try decoderContainer.decode(String?.self, forKey: .createTime)
        }
        if decoderContainer.contains(.deleted)
        {
            self.deleted = try decoderContainer.decode(Int64?.self, forKey: .deleted)
        }
        if decoderContainer.contains(.downSample)
        {
            self.downSample = try decoderContainer.decode(String?.self, forKey: .downSample)
        }
        if decoderContainer.contains(.id)
        {
            self.id = try decoderContainer.decode(Int64?.self, forKey: .id)
        }
        if decoderContainer.contains(.metric)
        {
            self.metric = try decoderContainer.decode(String?.self, forKey: .metric)
        }
        if decoderContainer.contains(.metricId)
        {
            self.metricId = try decoderContainer.decode(Int64?.self, forKey: .metricId)
        }
        if decoderContainer.contains(.metricName)
        {
            self.metricName = try decoderContainer.decode(String?.self, forKey: .metricName)
        }
        if decoderContainer.contains(.noticeLevel)
        {
            self.noticeLevel = try decoderContainer.decode(NoticeLevel?.self, forKey: .noticeLevel)
        }
        if decoderContainer.contains(.noticePeriod)
        {
            self.noticePeriod = try decoderContainer.decode(Int64?.self, forKey: .noticePeriod)
        }
        if decoderContainer.contains(.operation)
        {
            self.operation = try decoderContainer.decode(String?.self, forKey: .operation)
        }
        if decoderContainer.contains(.period)
        {
            self.period = try decoderContainer.decode(Int64?.self, forKey: .period)
        }
        if decoderContainer.contains(.ruleType)
        {
            self.ruleType = try decoderContainer.decode(Int64?.self, forKey: .ruleType)
        }
        if decoderContainer.contains(.serviceCode)
        {
            self.serviceCode = try decoderContainer.decode(String?.self, forKey: .serviceCode)
        }
        if decoderContainer.contains(.tag)
        {
            self.tag = try decoderContainer.decode(String?.self, forKey: .tag)
        }
        if decoderContainer.contains(.tags)
        {
            self.tags = try decoderContainer.decode([String:String?]?.self, forKey: .tags)
        }
        if decoderContainer.contains(.threshold)
        {
            self.threshold = try decoderContainer.decode(Double?.self, forKey: .threshold)
        }
        if decoderContainer.contains(.times)
        {
            self.times = try decoderContainer.decode(Int64?.self, forKey: .times)
        }
        if decoderContainer.contains(.updateTime)
        {
            self.updateTime = try decoderContainer.decode(String?.self, forKey: .updateTime)
        }
        if decoderContainer.contains(.uuid)
        {
            self.uuid = try decoderContainer.decode(String?.self, forKey: .uuid)
        }
    }
}
public extension TemplateRulesVo{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: TemplateRulesVoCodingKeys.self)
         try encoderContainer.encode(calculateUnit, forKey: .calculateUnit)
         try encoderContainer.encode(calculation, forKey: .calculation)
         try encoderContainer.encode(createTime, forKey: .createTime)
         try encoderContainer.encode(deleted, forKey: .deleted)
         try encoderContainer.encode(downSample, forKey: .downSample)
         try encoderContainer.encode(id, forKey: .id)
         try encoderContainer.encode(metric, forKey: .metric)
         try encoderContainer.encode(metricId, forKey: .metricId)
         try encoderContainer.encode(metricName, forKey: .metricName)
         try encoderContainer.encode(noticeLevel, forKey: .noticeLevel)
         try encoderContainer.encode(noticePeriod, forKey: .noticePeriod)
         try encoderContainer.encode(operation, forKey: .operation)
         try encoderContainer.encode(period, forKey: .period)
         try encoderContainer.encode(ruleType, forKey: .ruleType)
         try encoderContainer.encode(serviceCode, forKey: .serviceCode)
         try encoderContainer.encode(tag, forKey: .tag)
         try encoderContainer.encode(tags, forKey: .tags)
         try encoderContainer.encode(threshold, forKey: .threshold)
         try encoderContainer.encode(times, forKey: .times)
         try encoderContainer.encode(updateTime, forKey: .updateTime)
         try encoderContainer.encode(uuid, forKey: .uuid)
    }
}
///  createTemplateRequestV2
public class CreateTemplateRequestV2:NSObject,Codable{
    /// 幂等性校验参数,最长36位
    /// Required:true
    var clientToken:String
    /// 模板描述
    var descriptionValue:String?
    /// 模板资源类型下的维度，如果该资源分维度,则必须传入此参数
    var dimension:String?
    /// 模板的资源类型
    /// Required:true
    var product:String
    /// 模板名称,长度1-32个字符，只允许中英文、数字、&#39;&#39;-&#39;&#39;和&quot;_&quot;
    /// Required:true
    var templateName:String
    /// 模板内包含的规则
    /// Required:true
    var templateRules:[BasicRule?]?



    public  init(clientToken:String,product:String,templateName:String,templateRules:[BasicRule?]?){
             self.clientToken = clientToken
             self.product = product
             self.templateName = templateName
             self.templateRules = templateRules
    }

    enum CreateTemplateRequestV2CodingKeys: String, CodingKey {
        case clientToken
        case descriptionValue = "description"
        case dimension
        case product
        case templateName
        case templateRules
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: CreateTemplateRequestV2CodingKeys.self)
        self.clientToken = try decoderContainer.decode(String.self, forKey: .clientToken)
        if decoderContainer.contains(.descriptionValue)
        {
            self.descriptionValue = try decoderContainer.decode(String?.self, forKey: .descriptionValue)
        }
        if decoderContainer.contains(.dimension)
        {
            self.dimension = try decoderContainer.decode(String?.self, forKey: .dimension)
        }
        self.product = try decoderContainer.decode(String.self, forKey: .product)
        self.templateName = try decoderContainer.decode(String.self, forKey: .templateName)
        self.templateRules = try decoderContainer.decode([BasicRule?]?.self, forKey: .templateRules)
    }
}
public extension CreateTemplateRequestV2{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: CreateTemplateRequestV2CodingKeys.self)
         try encoderContainer.encode(clientToken, forKey: .clientToken)
         try encoderContainer.encode(descriptionValue, forKey: .descriptionValue)
         try encoderContainer.encode(dimension, forKey: .dimension)
         try encoderContainer.encode(product, forKey: .product)
         try encoderContainer.encode(templateName, forKey: .templateName)
         try encoderContainer.encode(templateRules, forKey: .templateRules)
    }
}
///  linkPolicyInfo
public class LinkPolicyInfo:NSObject,Codable{
    /// 该模板关联策略的名字
    var linkPolicyName:String?
    /// 该模板关联策略的uuid
    var linkPolicyUuid:String?



    public override init(){
            super.init()
    }

    enum LinkPolicyInfoCodingKeys: String, CodingKey {
        case linkPolicyName
        case linkPolicyUuid
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: LinkPolicyInfoCodingKeys.self)
        if decoderContainer.contains(.linkPolicyName)
        {
            self.linkPolicyName = try decoderContainer.decode(String?.self, forKey: .linkPolicyName)
        }
        if decoderContainer.contains(.linkPolicyUuid)
        {
            self.linkPolicyUuid = try decoderContainer.decode(String?.self, forKey: .linkPolicyUuid)
        }
    }
}
public extension LinkPolicyInfo{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: LinkPolicyInfoCodingKeys.self)
         try encoderContainer.encode(linkPolicyName, forKey: .linkPolicyName)
         try encoderContainer.encode(linkPolicyUuid, forKey: .linkPolicyUuid)
    }
}
///  noticeLevel
public class NoticeLevel:NSObject,Codable{
    /// 是否为用户自己定义的级别，自定义(true) or 固定(false)
    /// Required:true
    var custom:Bool
    /// 报警级别以及对应的阈值，是一个map[string]float64对象。key:common(一般)、critical(严重)、 fatal(紧急),value:各报警级别对应的阀值，要符合operation参数对应的递进关系。 eg: &quot;levels&quot;:{&quot;common&quot;:1000,&quot;critical&quot;:10000,&quot;fatal&quot;:15000}
    /// Required:true
    var levels:[String:Double?]?



    public  init(custom:Bool,levels:[String:Double?]?){
             self.custom = custom
             self.levels = levels
    }

    enum NoticeLevelCodingKeys: String, CodingKey {
        case custom
        case levels
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: NoticeLevelCodingKeys.self)
        self.custom = try decoderContainer.decode(Bool.self, forKey: .custom)
        self.levels = try decoderContainer.decode([String:Double?]?.self, forKey: .levels)
    }
}
public extension NoticeLevel{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: NoticeLevelCodingKeys.self)
         try encoderContainer.encode(custom, forKey: .custom)
         try encoderContainer.encode(levels, forKey: .levels)
    }
}
///  规则触发条件
public class BasicRule:NSObject,Codable{
    /// 统计方法，必须与定义的metric一致，可选值列表：avg,sum,max,min
    /// Required:true
    var calculation:String
    /// 降采样函数
    var downSample:String?
    /// 监控项唯一标识，可根据DescribeMetricsForCreateAlarm接口查询各产品线可用的监控项（创建规则时使用Metric字段）。格式：metric:downsample
    /// Required:true
    var metric:String
    /// NoticeLevel
    var noticeLevel:NoticeLevel?
    /// 报警比较符，只能为以下几种lte(&lt;&#x3D;),lt(&lt;),gt(&gt;),gte(&gt;&#x3D;),eq(&#x3D;&#x3D;),ne(!&#x3D;)
    /// Required:true
    var operation:String
    /// 查询指标的周期，单位为分钟,目前支持的取值：1,2，5，10,15，30，60
    /// Required:true
    var period:Int64
    /// 报警阈值，目前只开放数值类型功能
    /// Required:true
    var threshold:Double
    /// 连续探测几次都满足阈值条件时报警，可选值:1,2,3,5,10,15,30,60
    /// Required:true
    var times:Int64



    public  init(calculation:String,metric:String,operation:String,period:Int64,threshold:Double,times:Int64){
             self.calculation = calculation
             self.metric = metric
             self.operation = operation
             self.period = period
             self.threshold = threshold
             self.times = times
    }

    enum BasicRuleCodingKeys: String, CodingKey {
        case calculation
        case downSample
        case metric
        case noticeLevel
        case operation
        case period
        case threshold
        case times
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: BasicRuleCodingKeys.self)
        self.calculation = try decoderContainer.decode(String.self, forKey: .calculation)
        if decoderContainer.contains(.downSample)
        {
            self.downSample = try decoderContainer.decode(String?.self, forKey: .downSample)
        }
        self.metric = try decoderContainer.decode(String.self, forKey: .metric)
        if decoderContainer.contains(.noticeLevel)
        {
            self.noticeLevel = try decoderContainer.decode(NoticeLevel?.self, forKey: .noticeLevel)
        }
        self.operation = try decoderContainer.decode(String.self, forKey: .operation)
        self.period = try decoderContainer.decode(Int64.self, forKey: .period)
        self.threshold = try decoderContainer.decode(Double.self, forKey: .threshold)
        self.times = try decoderContainer.decode(Int64.self, forKey: .times)
    }
}
public extension BasicRule{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: BasicRuleCodingKeys.self)
         try encoderContainer.encode(calculation, forKey: .calculation)
         try encoderContainer.encode(downSample, forKey: .downSample)
         try encoderContainer.encode(metric, forKey: .metric)
         try encoderContainer.encode(noticeLevel, forKey: .noticeLevel)
         try encoderContainer.encode(operation, forKey: .operation)
         try encoderContainer.encode(period, forKey: .period)
         try encoderContainer.encode(threshold, forKey: .threshold)
         try encoderContainer.encode(times, forKey: .times)
    }
}
///  updateTemplateRequestV2
public class UpdateTemplateRequestV2:NSObject,Codable{
    /// 模板描述
    var descriptionValue:String?
    /// 模板资源类型下的维度，如果该资源分维度,则必须传入此参数
    var dimension:String?
    /// 模板的资源类型
    /// Required:true
    var product:String
    /// 模板名称
    /// Required:true
    var templateName:String
    /// 模板内包含的规则
    /// Required:true
    var templateRules:[BasicRule?]?
    /// 模板UUID
    /// Required:true
    var templateUuid:String



    public  init(product:String,templateName:String,templateRules:[BasicRule?]?,templateUuid:String){
             self.product = product
             self.templateName = templateName
             self.templateRules = templateRules
             self.templateUuid = templateUuid
    }

    enum UpdateTemplateRequestV2CodingKeys: String, CodingKey {
        case descriptionValue = "description"
        case dimension
        case product
        case templateName
        case templateRules
        case templateUuid
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: UpdateTemplateRequestV2CodingKeys.self)
        if decoderContainer.contains(.descriptionValue)
        {
            self.descriptionValue = try decoderContainer.decode(String?.self, forKey: .descriptionValue)
        }
        if decoderContainer.contains(.dimension)
        {
            self.dimension = try decoderContainer.decode(String?.self, forKey: .dimension)
        }
        self.product = try decoderContainer.decode(String.self, forKey: .product)
        self.templateName = try decoderContainer.decode(String.self, forKey: .templateName)
        self.templateRules = try decoderContainer.decode([BasicRule?]?.self, forKey: .templateRules)
        self.templateUuid = try decoderContainer.decode(String.self, forKey: .templateUuid)
    }
}
public extension UpdateTemplateRequestV2{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: UpdateTemplateRequestV2CodingKeys.self)
         try encoderContainer.encode(descriptionValue, forKey: .descriptionValue)
         try encoderContainer.encode(dimension, forKey: .dimension)
         try encoderContainer.encode(product, forKey: .product)
         try encoderContainer.encode(templateName, forKey: .templateName)
         try encoderContainer.encode(templateRules, forKey: .templateRules)
         try encoderContainer.encode(templateUuid, forKey: .templateUuid)
    }
}
///  addTagsSpec
public class AddTagsSpec:NSObject,Codable{
    /// 应用码。调用此API前需找云监控提供
    /// Required:true
    var appCode:String
    /// 组id。须确保在一个APP范围内全局唯一
    /// Required:true
    var groupCode:String
    /// 资源列表。总资源不能超过100个
    /// Required:true
    var resourceIds:[String?]?
    /// 资源的产品线
    /// Required:true
    var serviceCode:String
    /// 打标签操作所属产品线的serviceCode
    /// Required:true
    var srcServiceCode:String
    /// 标签名称。调用此API前需要与云监控确认可以使用的标签名称
    /// Required:true
    var tagK:String
    /// 标签值
    /// Required:true
    var tagV:String



    public  init(appCode:String,groupCode:String,resourceIds:[String?]?,serviceCode:String,srcServiceCode:String,tagK:String,tagV:String){
             self.appCode = appCode
             self.groupCode = groupCode
             self.resourceIds = resourceIds
             self.serviceCode = serviceCode
             self.srcServiceCode = srcServiceCode
             self.tagK = tagK
             self.tagV = tagV
    }

    enum AddTagsSpecCodingKeys: String, CodingKey {
        case appCode
        case groupCode
        case resourceIds
        case serviceCode
        case srcServiceCode
        case tagK
        case tagV
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: AddTagsSpecCodingKeys.self)
        self.appCode = try decoderContainer.decode(String.self, forKey: .appCode)
        self.groupCode = try decoderContainer.decode(String.self, forKey: .groupCode)
        self.resourceIds = try decoderContainer.decode([String?]?.self, forKey: .resourceIds)
        self.serviceCode = try decoderContainer.decode(String.self, forKey: .serviceCode)
        self.srcServiceCode = try decoderContainer.decode(String.self, forKey: .srcServiceCode)
        self.tagK = try decoderContainer.decode(String.self, forKey: .tagK)
        self.tagV = try decoderContainer.decode(String.self, forKey: .tagV)
    }
}
public extension AddTagsSpec{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: AddTagsSpecCodingKeys.self)
         try encoderContainer.encode(appCode, forKey: .appCode)
         try encoderContainer.encode(groupCode, forKey: .groupCode)
         try encoderContainer.encode(resourceIds, forKey: .resourceIds)
         try encoderContainer.encode(serviceCode, forKey: .serviceCode)
         try encoderContainer.encode(srcServiceCode, forKey: .srcServiceCode)
         try encoderContainer.encode(tagK, forKey: .tagK)
         try encoderContainer.encode(tagV, forKey: .tagV)
    }
}
///  filter
public class Filter:NSObject,Codable{
    /// Name
    var name:String?
    /// Values
    var values:[String?]?



    public override init(){
            super.init()
    }

    enum FilterCodingKeys: String, CodingKey {
        case name
        case values
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: FilterCodingKeys.self)
        if decoderContainer.contains(.name)
        {
            self.name = try decoderContainer.decode(String?.self, forKey: .name)
        }
        if decoderContainer.contains(.values)
        {
            self.values = try decoderContainer.decode([String?]?.self, forKey: .values)
        }
    }
}
public extension Filter{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: FilterCodingKeys.self)
         try encoderContainer.encode(name, forKey: .name)
         try encoderContainer.encode(values, forKey: .values)
    }
}
///  putBody
public class PutBody:NSObject,Codable{
    /// 目前统一用jcloud
    /// Required:true
    var appCode:String
    /// 资源的类型，取值vm,ip,database,storage,disk,cdn,redis,balance,nat_gw,db_ro,vpn,ddos等,新接入的产品要求与opentapi命名的产品线名称一致
    /// Required:true
    var serviceCode:String
    /// 地域信息，如 cn-north-1 等
    /// Required:true
    var region:String
    /// 资源的唯一表示，一般为uuid
    /// Required:true
    var resourceId:String
    /// 监控数据点
    /// Required:true
    var dataPoints:[DataPointX?]?



    public  init(appCode:String,serviceCode:String,region:String,resourceId:String,dataPoints:[DataPointX?]?){
             self.appCode = appCode
             self.serviceCode = serviceCode
             self.region = region
             self.resourceId = resourceId
             self.dataPoints = dataPoints
    }

    enum PutBodyCodingKeys: String, CodingKey {
        case appCode
        case serviceCode
        case region
        case resourceId
        case dataPoints
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: PutBodyCodingKeys.self)
        self.appCode = try decoderContainer.decode(String.self, forKey: .appCode)
        self.serviceCode = try decoderContainer.decode(String.self, forKey: .serviceCode)
        self.region = try decoderContainer.decode(String.self, forKey: .region)
        self.resourceId = try decoderContainer.decode(String.self, forKey: .resourceId)
        self.dataPoints = try decoderContainer.decode([DataPointX?]?.self, forKey: .dataPoints)
    }
}
public extension PutBody{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: PutBodyCodingKeys.self)
         try encoderContainer.encode(appCode, forKey: .appCode)
         try encoderContainer.encode(serviceCode, forKey: .serviceCode)
         try encoderContainer.encode(region, forKey: .region)
         try encoderContainer.encode(resourceId, forKey: .resourceId)
         try encoderContainer.encode(dataPoints, forKey: .dataPoints)
    }
}
///  dataPointX
public class DataPointX:NSObject,Codable{
    /// 监控指标名称，长度不超过255字节，只允许英文、数字、下划线_、点.,  [0-9][a-z] [A-Z] [. _ ]， 其它会返回err
    /// Required:true
    var metric:String
    /// 数据维度，数据类型为map类型，最多五个标签，尽量不传或少传。总长度不大于255字节，只允许英文、数字、下划线_、点., [0-9][a-z] [A-Z] [. _ ]，  其它会返回err
    var tags:[String:String?]?
    /// 秒级时间戳，早于当前时间30天的不能写入；建议的上报时间戳：上报时间间隔的整数倍，如上报间隔为5s，则建议上报的时间戳为 timestamp &#x3D; current timestamp - (current timestamp % time interval) &#x3D; 1487647187 - （1487647187 % 5） &#x3D; 1487647187 -2 &#x3D; 1487647185
    /// Required:true
    var timestamp:Int64
    /// 监控的值。number or string。最大值为long.MAX_VALUE&#x3D;9223372036854775807&#x3D;263-1。累计类型的指标，累计到最大值后需要翻转为0，重新开始计数。翻转后不影响速率的计算。
    /// Required:true
    var value:AnyObject?



    public  init(metric:String,timestamp:Int64,value:AnyObject?){
             self.metric = metric
             self.timestamp = timestamp
             self.value = value
    }

    enum DataPointXCodingKeys: String, CodingKey {
        case metric
        case tags
        case timestamp
        case value
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: DataPointXCodingKeys.self)
        self.metric = try decoderContainer.decode(String.self, forKey: .metric)
        if decoderContainer.contains(.tags)
        {
            self.tags = try decoderContainer.decode([String:String?]?.self, forKey: .tags)
        }
        self.timestamp = try decoderContainer.decode(Int64.self, forKey: .timestamp)
    }
}
public extension DataPointX{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: DataPointXCodingKeys.self)
         try encoderContainer.encode(metric, forKey: .metric)
         try encoderContainer.encode(tags, forKey: .tags)
         try encoderContainer.encode(timestamp, forKey: .timestamp)
    }
}
///  lastDownsampleRespItem
public class LastDownsampleRespItem:NSObject,Codable{
    /// Metric
    var metric:String?
    /// Name
    var name:String?
    /// Tags
    var tags:[String:String?]?
    /// Value
    var value:AnyObject?



    public override init(){
            super.init()
    }

    enum LastDownsampleRespItemCodingKeys: String, CodingKey {
        case metric
        case name
        case tags
        case value
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: LastDownsampleRespItemCodingKeys.self)
        if decoderContainer.contains(.metric)
        {
            self.metric = try decoderContainer.decode(String?.self, forKey: .metric)
        }
        if decoderContainer.contains(.name)
        {
            self.name = try decoderContainer.decode(String?.self, forKey: .name)
        }
        if decoderContainer.contains(.tags)
        {
            self.tags = try decoderContainer.decode([String:String?]?.self, forKey: .tags)
        }
    }
}
public extension LastDownsampleRespItem{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: LastDownsampleRespItemCodingKeys.self)
         try encoderContainer.encode(metric, forKey: .metric)
         try encoderContainer.encode(name, forKey: .name)
         try encoderContainer.encode(tags, forKey: .tags)
    }
}
///  serviceInfoV2
public class ServiceInfoV2:NSObject,Codable{
    /// 产品线下的分组信息
    var dimensions:[ChartDimension?]?
    /// GroupTree
    var groupTree:GroupTree?
    /// 产品线ServiceCode
    var serviceCode:String?
    /// 产品线名称
    var serviceName:String?



    public override init(){
            super.init()
    }

    enum ServiceInfoV2CodingKeys: String, CodingKey {
        case dimensions
        case groupTree
        case serviceCode
        case serviceName
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: ServiceInfoV2CodingKeys.self)
        if decoderContainer.contains(.dimensions)
        {
            self.dimensions = try decoderContainer.decode([ChartDimension?]?.self, forKey: .dimensions)
        }
        if decoderContainer.contains(.groupTree)
        {
            self.groupTree = try decoderContainer.decode(GroupTree?.self, forKey: .groupTree)
        }
        if decoderContainer.contains(.serviceCode)
        {
            self.serviceCode = try decoderContainer.decode(String?.self, forKey: .serviceCode)
        }
        if decoderContainer.contains(.serviceName)
        {
            self.serviceName = try decoderContainer.decode(String?.self, forKey: .serviceName)
        }
    }
}
public extension ServiceInfoV2{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: ServiceInfoV2CodingKeys.self)
         try encoderContainer.encode(dimensions, forKey: .dimensions)
         try encoderContainer.encode(groupTree, forKey: .groupTree)
         try encoderContainer.encode(serviceCode, forKey: .serviceCode)
         try encoderContainer.encode(serviceName, forKey: .serviceName)
    }
}
///  metricData
public class MetricData:NSObject,Codable{
    /// Data
    var data:[DataPoint?]?
    /// Metric
    var metric:Metric?
    /// Tags
    var tags:[Tag?]?



    public override init(){
            super.init()
    }

    enum MetricDataCodingKeys: String, CodingKey {
        case data
        case metric
        case tags
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: MetricDataCodingKeys.self)
        if decoderContainer.contains(.data)
        {
            self.data = try decoderContainer.decode([DataPoint?]?.self, forKey: .data)
        }
        if decoderContainer.contains(.metric)
        {
            self.metric = try decoderContainer.decode(Metric?.self, forKey: .metric)
        }
        if decoderContainer.contains(.tags)
        {
            self.tags = try decoderContainer.decode([Tag?]?.self, forKey: .tags)
        }
    }
}
public extension MetricData{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: MetricDataCodingKeys.self)
         try encoderContainer.encode(data, forKey: .data)
         try encoderContainer.encode(metric, forKey: .metric)
         try encoderContainer.encode(tags, forKey: .tags)
    }
}
///  chartDimension
public class ChartDimension:NSObject,Codable{
    /// 分组groupCode
    var dimension:String?
    /// 分组名称
    var dimensionName:String?
    /// 分组下metric对应的tags
    var tags:[String:String?]?



    public override init(){
            super.init()
    }

    enum ChartDimensionCodingKeys: String, CodingKey {
        case dimension
        case dimensionName
        case tags
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: ChartDimensionCodingKeys.self)
        if decoderContainer.contains(.dimension)
        {
            self.dimension = try decoderContainer.decode(String?.self, forKey: .dimension)
        }
        if decoderContainer.contains(.dimensionName)
        {
            self.dimensionName = try decoderContainer.decode(String?.self, forKey: .dimensionName)
        }
        if decoderContainer.contains(.tags)
        {
            self.tags = try decoderContainer.decode([String:String?]?.self, forKey: .tags)
        }
    }
}
public extension ChartDimension{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: ChartDimensionCodingKeys.self)
         try encoderContainer.encode(dimension, forKey: .dimension)
         try encoderContainer.encode(dimensionName, forKey: .dimensionName)
         try encoderContainer.encode(tags, forKey: .tags)
    }
}
///  tag
public class Tag:NSObject,Codable{
    /// TagKey
    var tagKey:String?
    /// TagValue
    var tagValue:String?



    public override init(){
            super.init()
    }

    enum TagCodingKeys: String, CodingKey {
        case tagKey
        case tagValue
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: TagCodingKeys.self)
        if decoderContainer.contains(.tagKey)
        {
            self.tagKey = try decoderContainer.decode(String?.self, forKey: .tagKey)
        }
        if decoderContainer.contains(.tagValue)
        {
            self.tagValue = try decoderContainer.decode(String?.self, forKey: .tagValue)
        }
    }
}
public extension Tag{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: TagCodingKeys.self)
         try encoderContainer.encode(tagKey, forKey: .tagKey)
         try encoderContainer.encode(tagValue, forKey: .tagValue)
    }
}
///  chartDimensionDetail
public class ChartDimensionDetail:NSObject,Codable{
    /// 监控图的展示方式
    var charts:[ChartDetail?]?
    /// 维度dimension
    var dimension:String?
    /// 分组名称
    var dimensionName:String?
    /// 产品线
    var serviceCode:String?
    /// 分组名称
    var serviceName:String?
    /// 分组下metric对应的tags
    var tags:[String:String?]?



    public override init(){
            super.init()
    }

    enum ChartDimensionDetailCodingKeys: String, CodingKey {
        case charts
        case dimension
        case dimensionName
        case serviceCode
        case serviceName
        case tags
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: ChartDimensionDetailCodingKeys.self)
        if decoderContainer.contains(.charts)
        {
            self.charts = try decoderContainer.decode([ChartDetail?]?.self, forKey: .charts)
        }
        if decoderContainer.contains(.dimension)
        {
            self.dimension = try decoderContainer.decode(String?.self, forKey: .dimension)
        }
        if decoderContainer.contains(.dimensionName)
        {
            self.dimensionName = try decoderContainer.decode(String?.self, forKey: .dimensionName)
        }
        if decoderContainer.contains(.serviceCode)
        {
            self.serviceCode = try decoderContainer.decode(String?.self, forKey: .serviceCode)
        }
        if decoderContainer.contains(.serviceName)
        {
            self.serviceName = try decoderContainer.decode(String?.self, forKey: .serviceName)
        }
        if decoderContainer.contains(.tags)
        {
            self.tags = try decoderContainer.decode([String:String?]?.self, forKey: .tags)
        }
    }
}
public extension ChartDimensionDetail{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: ChartDimensionDetailCodingKeys.self)
         try encoderContainer.encode(charts, forKey: .charts)
         try encoderContainer.encode(dimension, forKey: .dimension)
         try encoderContainer.encode(dimensionName, forKey: .dimensionName)
         try encoderContainer.encode(serviceCode, forKey: .serviceCode)
         try encoderContainer.encode(serviceName, forKey: .serviceName)
         try encoderContainer.encode(tags, forKey: .tags)
    }
}
///  groupNode
public class GroupNode:NSObject,Codable{
    /// 分组子节点
    var childs:[GroupNode?]?
    /// 分组groupCode
    var groupCode:String?
    /// 分组父节点的groupCode
    var parent:String?



    public override init(){
            super.init()
    }

    enum GroupNodeCodingKeys: String, CodingKey {
        case childs
        case groupCode
        case parent
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: GroupNodeCodingKeys.self)
        if decoderContainer.contains(.childs)
        {
            self.childs = try decoderContainer.decode([GroupNode?]?.self, forKey: .childs)
        }
        if decoderContainer.contains(.groupCode)
        {
            self.groupCode = try decoderContainer.decode(String?.self, forKey: .groupCode)
        }
        if decoderContainer.contains(.parent)
        {
            self.parent = try decoderContainer.decode(String?.self, forKey: .parent)
        }
    }
}
public extension GroupNode{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: GroupNodeCodingKeys.self)
         try encoderContainer.encode(childs, forKey: .childs)
         try encoderContainer.encode(groupCode, forKey: .groupCode)
         try encoderContainer.encode(parent, forKey: .parent)
    }
}
///  chartDetail
public class ChartDetail:NSObject,Codable{
    /// 监控图名称
    var chartName:String?
    /// 监控图单位
    var chartUnit:String?
    /// 监控图包含的指标
    var include:[String?]?



    public override init(){
            super.init()
    }

    enum ChartDetailCodingKeys: String, CodingKey {
        case chartName
        case chartUnit
        case include
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: ChartDetailCodingKeys.self)
        if decoderContainer.contains(.chartName)
        {
            self.chartName = try decoderContainer.decode(String?.self, forKey: .chartName)
        }
        if decoderContainer.contains(.chartUnit)
        {
            self.chartUnit = try decoderContainer.decode(String?.self, forKey: .chartUnit)
        }
        if decoderContainer.contains(.include)
        {
            self.include = try decoderContainer.decode([String?]?.self, forKey: .include)
        }
    }
}
public extension ChartDetail{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: ChartDetailCodingKeys.self)
         try encoderContainer.encode(chartName, forKey: .chartName)
         try encoderContainer.encode(chartUnit, forKey: .chartUnit)
         try encoderContainer.encode(include, forKey: .include)
    }
}
///  dataPoint
public class DataPoint:NSObject,Codable{
    /// Timestamp
    var timestamp:Int64?
    /// Value
    var value:AnyObject?



    public override init(){
            super.init()
    }

    enum DataPointCodingKeys: String, CodingKey {
        case timestamp
        case value
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: DataPointCodingKeys.self)
        if decoderContainer.contains(.timestamp)
        {
            self.timestamp = try decoderContainer.decode(Int64?.self, forKey: .timestamp)
        }
    }
}
public extension DataPoint{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: DataPointCodingKeys.self)
         try encoderContainer.encode(timestamp, forKey: .timestamp)
    }
}
///  groupTree
public class GroupTree:NSObject,Codable{
    /// 分组groupCodes
    var childs:[GroupNode?]?
    /// serviceCode
    var serviceCode:String?



    public override init(){
            super.init()
    }

    enum GroupTreeCodingKeys: String, CodingKey {
        case childs
        case serviceCode
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: GroupTreeCodingKeys.self)
        if decoderContainer.contains(.childs)
        {
            self.childs = try decoderContainer.decode([GroupNode?]?.self, forKey: .childs)
        }
        if decoderContainer.contains(.serviceCode)
        {
            self.serviceCode = try decoderContainer.decode(String?.self, forKey: .serviceCode)
        }
    }
}
public extension GroupTree{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: GroupTreeCodingKeys.self)
         try encoderContainer.encode(childs, forKey: .childs)
         try encoderContainer.encode(serviceCode, forKey: .serviceCode)
    }
}
///  详情
public class MetricDetail:NSObject,Codable{
    /// 指标的计算单位，比如bit/s、%、k等
    var calculateUnit:String?
    /// 维度标识
    var dimension:String?
    /// 取样频次
    var downSample:String?
    /// 监控项英文标识
    var metric:String?
    /// 监控项名称
    var metricName:String?
    /// 产品线标识
    var serviceCode:String?



    public override init(){
            super.init()
    }

    enum MetricDetailCodingKeys: String, CodingKey {
        case calculateUnit
        case dimension
        case downSample
        case metric
        case metricName
        case serviceCode
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: MetricDetailCodingKeys.self)
        if decoderContainer.contains(.calculateUnit)
        {
            self.calculateUnit = try decoderContainer.decode(String?.self, forKey: .calculateUnit)
        }
        if decoderContainer.contains(.dimension)
        {
            self.dimension = try decoderContainer.decode(String?.self, forKey: .dimension)
        }
        if decoderContainer.contains(.downSample)
        {
            self.downSample = try decoderContainer.decode(String?.self, forKey: .downSample)
        }
        if decoderContainer.contains(.metric)
        {
            self.metric = try decoderContainer.decode(String?.self, forKey: .metric)
        }
        if decoderContainer.contains(.metricName)
        {
            self.metricName = try decoderContainer.decode(String?.self, forKey: .metricName)
        }
        if decoderContainer.contains(.serviceCode)
        {
            self.serviceCode = try decoderContainer.decode(String?.self, forKey: .serviceCode)
        }
    }
}
public extension MetricDetail{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: MetricDetailCodingKeys.self)
         try encoderContainer.encode(calculateUnit, forKey: .calculateUnit)
         try encoderContainer.encode(dimension, forKey: .dimension)
         try encoderContainer.encode(downSample, forKey: .downSample)
         try encoderContainer.encode(metric, forKey: .metric)
         try encoderContainer.encode(metricName, forKey: .metricName)
         try encoderContainer.encode(serviceCode, forKey: .serviceCode)
    }
}
///  tagFilter
public class TagFilter:NSObject,Codable{
    /// Tag键
    var key:String?
    /// Tag值
    var values:[String?]?



    public override init(){
            super.init()
    }

    enum TagFilterCodingKeys: String, CodingKey {
        case key
        case values
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: TagFilterCodingKeys.self)
        if decoderContainer.contains(.key)
        {
            self.key = try decoderContainer.decode(String?.self, forKey: .key)
        }
        if decoderContainer.contains(.values)
        {
            self.values = try decoderContainer.decode([String?]?.self, forKey: .values)
        }
    }
}
public extension TagFilter{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: TagFilterCodingKeys.self)
         try encoderContainer.encode(key, forKey: .key)
         try encoderContainer.encode(values, forKey: .values)
    }
}
///  metric
public class Metric:NSObject,Codable{
    /// Aggregator
    var aggregator:String?
    /// CalculateUnit
    var calculateUnit:String?
    /// MetricValue
    var metricValue:String?
    /// MetricName
    var metricName:String?
    /// Period
    var period:String?



    public override init(){
            super.init()
    }

    enum MetricCodingKeys: String, CodingKey {
        case aggregator
        case calculateUnit
        case metricValue = "metric"
        case metricName
        case period
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: MetricCodingKeys.self)
        if decoderContainer.contains(.aggregator)
        {
            self.aggregator = try decoderContainer.decode(String?.self, forKey: .aggregator)
        }
        if decoderContainer.contains(.calculateUnit)
        {
            self.calculateUnit = try decoderContainer.decode(String?.self, forKey: .calculateUnit)
        }
        if decoderContainer.contains(.metricValue)
        {
            self.metricValue = try decoderContainer.decode(String?.self, forKey: .metricValue)
        }
        if decoderContainer.contains(.metricName)
        {
            self.metricName = try decoderContainer.decode(String?.self, forKey: .metricName)
        }
        if decoderContainer.contains(.period)
        {
            self.period = try decoderContainer.decode(String?.self, forKey: .period)
        }
    }
}
public extension Metric{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: MetricCodingKeys.self)
         try encoderContainer.encode(aggregator, forKey: .aggregator)
         try encoderContainer.encode(calculateUnit, forKey: .calculateUnit)
         try encoderContainer.encode(metricValue, forKey: .metricValue)
         try encoderContainer.encode(metricName, forKey: .metricName)
         try encoderContainer.encode(period, forKey: .period)
    }
}
///  basicRuleDetail
public class BasicRuleDetail:NSObject,Codable{
    /// 指标的计算单位，比如bit/s、%、k等
    var calculateUnit:String?
    /// 统计方法，必须与定义的metric一致，可选值列表：avg,sum,max,min
    /// Required:true
    var calculation:String
    /// 降采样函数
    var downSample:String?
    /// 监控项唯一标识，可根据DescribeMetricsForCreateAlarm接口查询各产品线可用的监控项（创建规则时使用Metric字段）。格式：metric:downsample
    /// Required:true
    var metric:String
    /// 监控项名称
    /// Required:true
    var metricName:String
    /// NoticeLevel
    var noticeLevel:NoticeLevel?
    /// 报警比较符，只能为以下几种lte(&lt;&#x3D;),lt(&lt;),gt(&gt;),gte(&gt;&#x3D;),eq(&#x3D;&#x3D;),ne(!&#x3D;)
    /// Required:true
    var operation:String
    /// 查询指标的周期，单位为分钟,目前支持的取值：1,2，5，10,15，30，60
    /// Required:true
    var period:Int64
    /// 报警阈值，目前只开放数值类型功能
    /// Required:true
    var threshold:Double
    /// 连续探测几次都满足阈值条件时报警，可选值:1,2,3,5,10,15,30,60
    /// Required:true
    var times:Int64



    public  init(calculation:String,metric:String,metricName:String,operation:String,period:Int64,threshold:Double,times:Int64){
             self.calculation = calculation
             self.metric = metric
             self.metricName = metricName
             self.operation = operation
             self.period = period
             self.threshold = threshold
             self.times = times
    }

    enum BasicRuleDetailCodingKeys: String, CodingKey {
        case calculateUnit
        case calculation
        case downSample
        case metric
        case metricName
        case noticeLevel
        case operation
        case period
        case threshold
        case times
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: BasicRuleDetailCodingKeys.self)
        if decoderContainer.contains(.calculateUnit)
        {
            self.calculateUnit = try decoderContainer.decode(String?.self, forKey: .calculateUnit)
        }
        self.calculation = try decoderContainer.decode(String.self, forKey: .calculation)
        if decoderContainer.contains(.downSample)
        {
            self.downSample = try decoderContainer.decode(String?.self, forKey: .downSample)
        }
        self.metric = try decoderContainer.decode(String.self, forKey: .metric)
        self.metricName = try decoderContainer.decode(String.self, forKey: .metricName)
        if decoderContainer.contains(.noticeLevel)
        {
            self.noticeLevel = try decoderContainer.decode(NoticeLevel?.self, forKey: .noticeLevel)
        }
        self.operation = try decoderContainer.decode(String.self, forKey: .operation)
        self.period = try decoderContainer.decode(Int64.self, forKey: .period)
        self.threshold = try decoderContainer.decode(Double.self, forKey: .threshold)
        self.times = try decoderContainer.decode(Int64.self, forKey: .times)
    }
}
public extension BasicRuleDetail{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: BasicRuleDetailCodingKeys.self)
         try encoderContainer.encode(calculateUnit, forKey: .calculateUnit)
         try encoderContainer.encode(calculation, forKey: .calculation)
         try encoderContainer.encode(downSample, forKey: .downSample)
         try encoderContainer.encode(metric, forKey: .metric)
         try encoderContainer.encode(metricName, forKey: .metricName)
         try encoderContainer.encode(noticeLevel, forKey: .noticeLevel)
         try encoderContainer.encode(operation, forKey: .operation)
         try encoderContainer.encode(period, forKey: .period)
         try encoderContainer.encode(threshold, forKey: .threshold)
         try encoderContainer.encode(times, forKey: .times)
    }
}
///  ruleState
public class RuleState:NSObject,Codable{
    /// 资源id
    var resourceId:String?
    /// 规则个数
    var ruleCount:Int64?
    /// 资源的规则状态。1：正常、 2：报警、4：数据不足 -1:没有规则 -2:未启用
    var state:Int64?



    public override init(){
            super.init()
    }

    enum RuleStateCodingKeys: String, CodingKey {
        case resourceId
        case ruleCount
        case state
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: RuleStateCodingKeys.self)
        if decoderContainer.contains(.resourceId)
        {
            self.resourceId = try decoderContainer.decode(String?.self, forKey: .resourceId)
        }
        if decoderContainer.contains(.ruleCount)
        {
            self.ruleCount = try decoderContainer.decode(Int64?.self, forKey: .ruleCount)
        }
        if decoderContainer.contains(.state)
        {
            self.state = try decoderContainer.decode(Int64?.self, forKey: .state)
        }
    }
}
public extension RuleState{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: RuleStateCodingKeys.self)
         try encoderContainer.encode(resourceId, forKey: .resourceId)
         try encoderContainer.encode(ruleCount, forKey: .ruleCount)
         try encoderContainer.encode(state, forKey: .state)
    }
}
///  templateOption
public class TemplateOption:NSObject,Codable{
    /// 模板Id
    var templateId:String?
    /// 模板类型.1-默认模板  2-自定义模板
    var templateType:Int64?



    public override init(){
            super.init()
    }

    enum TemplateOptionCodingKeys: String, CodingKey {
        case templateId
        case templateType
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: TemplateOptionCodingKeys.self)
        if decoderContainer.contains(.templateId)
        {
            self.templateId = try decoderContainer.decode(String?.self, forKey: .templateId)
        }
        if decoderContainer.contains(.templateType)
        {
            self.templateType = try decoderContainer.decode(Int64?.self, forKey: .templateType)
        }
    }
}
public extension TemplateOption{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: TemplateOptionCodingKeys.self)
         try encoderContainer.encode(templateId, forKey: .templateId)
         try encoderContainer.encode(templateType, forKey: .templateType)
    }
}
///  resourceItem
public class ResourceItem:NSObject,Codable{
    /// 资源所属的region
    /// Required:true
    var region:String
    /// 资源id
    /// Required:true
    var resourceId:String



    public  init(region:String,resourceId:String){
             self.region = region
             self.resourceId = resourceId
    }

    enum ResourceItemCodingKeys: String, CodingKey {
        case region
        case resourceId
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: ResourceItemCodingKeys.self)
        self.region = try decoderContainer.decode(String.self, forKey: .region)
        self.resourceId = try decoderContainer.decode(String.self, forKey: .resourceId)
    }
}
public extension ResourceItem{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: ResourceItemCodingKeys.self)
         try encoderContainer.encode(region, forKey: .region)
         try encoderContainer.encode(resourceId, forKey: .resourceId)
    }
}
///  describeGroupAlarm
public class DescribeGroupAlarm:NSObject,Codable{
    /// 报警规则ID
    var alarmId:String?
    /// 规则状态，当一个规则下同时存在报警、数据不足、正常的资源时，规则状态按 报警&gt;数据不足&gt;正常的优先级展示
      /// 监控项状态：-1 未启用 1正常，2告警，4数据不足
    var alarmStatus:Int64?
    /// 规则的状态列表,可能同时存在多个：1正常，2告警，4数据不足
    var alarmStatusList:[Int64?]?
    /// 创建时间
    var createTime:String?
    /// 资源维度
    var dimension:String?
    /// 资源维度名称
    var dimensionName:String?
    /// 是否启用, 1表示启用规则，0表示禁用规则，默认为1
    var enabled:Int64?
    /// 资源类型
    /// Required:true
    var product:String
    /// 资源类型名称
    var productName:String?
    /// ResourceOption
    /// Required:true
    var resourceOption:ResourceOption
    /// 规则名称，规则名称，最大长度42个字符，只允许中英文、数字、&#39;&#39;-&#39;&#39;和&quot;_&quot;
    /// Required:true
    var ruleName:String
    /// RuleOption
    /// Required:true
    var ruleOption:RuleOptionDetail
    /// 规则类型, 默认为resourceMonitor
    var ruleType:String?
    /// 规则版本  v1  v2
    var ruleVersion:String?
    /// 资源维度，指定监控数据实例的维度标签,如resourceId&#x3D;id。(请确认资源的监控数据带有该标签，否则规则会报数据不足)
    var tags:[String:String?]?



    public  init(product:String,resourceOption:ResourceOption,ruleName:String,ruleOption:RuleOptionDetail){
             self.product = product
             self.resourceOption = resourceOption
             self.ruleName = ruleName
             self.ruleOption = ruleOption
    }

    enum DescribeGroupAlarmCodingKeys: String, CodingKey {
        case alarmId
        case alarmStatus
        case alarmStatusList
        case createTime
        case dimension
        case dimensionName
        case enabled
        case product
        case productName
        case resourceOption
        case ruleName
        case ruleOption
        case ruleType
        case ruleVersion
        case tags
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: DescribeGroupAlarmCodingKeys.self)
        if decoderContainer.contains(.alarmId)
        {
            self.alarmId = try decoderContainer.decode(String?.self, forKey: .alarmId)
        }
        if decoderContainer.contains(.alarmStatus)
        {
            self.alarmStatus = try decoderContainer.decode(Int64?.self, forKey: .alarmStatus)
        }
        if decoderContainer.contains(.alarmStatusList)
        {
            self.alarmStatusList = try decoderContainer.decode([Int64?]?.self, forKey: .alarmStatusList)
        }
        if decoderContainer.contains(.createTime)
        {
            self.createTime = try decoderContainer.decode(String?.self, forKey: .createTime)
        }
        if decoderContainer.contains(.dimension)
        {
            self.dimension = try decoderContainer.decode(String?.self, forKey: .dimension)
        }
        if decoderContainer.contains(.dimensionName)
        {
            self.dimensionName = try decoderContainer.decode(String?.self, forKey: .dimensionName)
        }
        if decoderContainer.contains(.enabled)
        {
            self.enabled = try decoderContainer.decode(Int64?.self, forKey: .enabled)
        }
        self.product = try decoderContainer.decode(String.self, forKey: .product)
        if decoderContainer.contains(.productName)
        {
            self.productName = try decoderContainer.decode(String?.self, forKey: .productName)
        }
        self.resourceOption = try decoderContainer.decode(ResourceOption.self, forKey: .resourceOption)
        self.ruleName = try decoderContainer.decode(String.self, forKey: .ruleName)
        self.ruleOption = try decoderContainer.decode(RuleOptionDetail.self, forKey: .ruleOption)
        if decoderContainer.contains(.ruleType)
        {
            self.ruleType = try decoderContainer.decode(String?.self, forKey: .ruleType)
        }
        if decoderContainer.contains(.ruleVersion)
        {
            self.ruleVersion = try decoderContainer.decode(String?.self, forKey: .ruleVersion)
        }
        if decoderContainer.contains(.tags)
        {
            self.tags = try decoderContainer.decode([String:String?]?.self, forKey: .tags)
        }
    }
}
public extension DescribeGroupAlarm{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: DescribeGroupAlarmCodingKeys.self)
         try encoderContainer.encode(alarmId, forKey: .alarmId)
         try encoderContainer.encode(alarmStatus, forKey: .alarmStatus)
         try encoderContainer.encode(alarmStatusList, forKey: .alarmStatusList)
         try encoderContainer.encode(createTime, forKey: .createTime)
         try encoderContainer.encode(dimension, forKey: .dimension)
         try encoderContainer.encode(dimensionName, forKey: .dimensionName)
         try encoderContainer.encode(enabled, forKey: .enabled)
         try encoderContainer.encode(product, forKey: .product)
         try encoderContainer.encode(productName, forKey: .productName)
         try encoderContainer.encode(resourceOption, forKey: .resourceOption)
         try encoderContainer.encode(ruleName, forKey: .ruleName)
         try encoderContainer.encode(ruleOption, forKey: .ruleOption)
         try encoderContainer.encode(ruleType, forKey: .ruleType)
         try encoderContainer.encode(ruleVersion, forKey: .ruleVersion)
         try encoderContainer.encode(tags, forKey: .tags)
    }
}
///  noticeOption
public class NoticeOption:NSObject,Codable{
    /// 生效截止时间，默认值:23:59
    var effectiveIntervalEnd:String?
    /// 生效起始时间，默认值:00:00
    var effectiveIntervalStart:String?
    /// 通知条件 1-告警 2-数据不足3-告警恢复
    var noticeCondition:[Int64?]?
    /// 通知沉默周期,单位:分钟，默认值：24小时,目前支持的取值“24小时、12小时、6小时、3小时、1小时、30分钟、15分钟、10分钟、5分钟”
    var noticePeriod:Int64?
    /// 通知方法    1-短信 2-邮件
    var noticeWay:[Int64?]?



    public override init(){
            super.init()
    }

    enum NoticeOptionCodingKeys: String, CodingKey {
        case effectiveIntervalEnd
        case effectiveIntervalStart
        case noticeCondition
        case noticePeriod
        case noticeWay
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: NoticeOptionCodingKeys.self)
        if decoderContainer.contains(.effectiveIntervalEnd)
        {
            self.effectiveIntervalEnd = try decoderContainer.decode(String?.self, forKey: .effectiveIntervalEnd)
        }
        if decoderContainer.contains(.effectiveIntervalStart)
        {
            self.effectiveIntervalStart = try decoderContainer.decode(String?.self, forKey: .effectiveIntervalStart)
        }
        if decoderContainer.contains(.noticeCondition)
        {
            self.noticeCondition = try decoderContainer.decode([Int64?]?.self, forKey: .noticeCondition)
        }
        if decoderContainer.contains(.noticePeriod)
        {
            self.noticePeriod = try decoderContainer.decode(Int64?.self, forKey: .noticePeriod)
        }
        if decoderContainer.contains(.noticeWay)
        {
            self.noticeWay = try decoderContainer.decode([Int64?]?.self, forKey: .noticeWay)
        }
    }
}
public extension NoticeOption{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: NoticeOptionCodingKeys.self)
         try encoderContainer.encode(effectiveIntervalEnd, forKey: .effectiveIntervalEnd)
         try encoderContainer.encode(effectiveIntervalStart, forKey: .effectiveIntervalStart)
         try encoderContainer.encode(noticeCondition, forKey: .noticeCondition)
         try encoderContainer.encode(noticePeriod, forKey: .noticePeriod)
         try encoderContainer.encode(noticeWay, forKey: .noticeWay)
    }
}
///  baseContact
public class BaseContact:NSObject,Codable{
    /// 联系人id。  注：ReferenceType&#x3D;2时，联系人id请填0
    /// Required:true
    var referenceId:Int64
    /// 联系人id类型：0,联系人分组id;1,联系人id，2，pin帐号主联系人
    /// Required:true
    var referenceType:Int64



    public  init(referenceId:Int64,referenceType:Int64){
             self.referenceId = referenceId
             self.referenceType = referenceType
    }

    enum BaseContactCodingKeys: String, CodingKey {
        case referenceId
        case referenceType
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: BaseContactCodingKeys.self)
        self.referenceId = try decoderContainer.decode(Int64.self, forKey: .referenceId)
        self.referenceType = try decoderContainer.decode(Int64.self, forKey: .referenceType)
    }
}
public extension BaseContact{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: BaseContactCodingKeys.self)
         try encoderContainer.encode(referenceId, forKey: .referenceId)
         try encoderContainer.encode(referenceType, forKey: .referenceType)
    }
}
///  dimension
public class Dimension:NSObject,Codable{
    /// 维度
    var dimensionValue:String?
    /// 维度名称
    var dimensionName:String?
    /// 是否是子结点
    var isNode:Bool?
    /// 对应标签服务的serviceCode
    var tagServiceCode:String?
    /// tags
    var tags:[String:String?]?



    public override init(){
            super.init()
    }

    enum DimensionCodingKeys: String, CodingKey {
        case dimensionValue = "dimension"
        case dimensionName
        case isNode
        case tagServiceCode
        case tags
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: DimensionCodingKeys.self)
        if decoderContainer.contains(.dimensionValue)
        {
            self.dimensionValue = try decoderContainer.decode(String?.self, forKey: .dimensionValue)
        }
        if decoderContainer.contains(.dimensionName)
        {
            self.dimensionName = try decoderContainer.decode(String?.self, forKey: .dimensionName)
        }
        if decoderContainer.contains(.isNode)
        {
            self.isNode = try decoderContainer.decode(Bool?.self, forKey: .isNode)
        }
        if decoderContainer.contains(.tagServiceCode)
        {
            self.tagServiceCode = try decoderContainer.decode(String?.self, forKey: .tagServiceCode)
        }
        if decoderContainer.contains(.tags)
        {
            self.tags = try decoderContainer.decode([String:String?]?.self, forKey: .tags)
        }
    }
}
public extension Dimension{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: DimensionCodingKeys.self)
         try encoderContainer.encode(dimensionValue, forKey: .dimensionValue)
         try encoderContainer.encode(dimensionName, forKey: .dimensionName)
         try encoderContainer.encode(isNode, forKey: .isNode)
         try encoderContainer.encode(tagServiceCode, forKey: .tagServiceCode)
         try encoderContainer.encode(tags, forKey: .tags)
    }
}
///  noticeReceiver
public class NoticeReceiver:NSObject,Codable{
    /// Email
    var email:String?
    /// Mobile
    var mobile:String?
    /// PersonId
    var personId:Int64?
    /// Pin
    var pin:String?
    /// UserName
    var userName:String?



    public override init(){
            super.init()
    }

    enum NoticeReceiverCodingKeys: String, CodingKey {
        case email
        case mobile
        case personId
        case pin
        case userName
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: NoticeReceiverCodingKeys.self)
        if decoderContainer.contains(.email)
        {
            self.email = try decoderContainer.decode(String?.self, forKey: .email)
        }
        if decoderContainer.contains(.mobile)
        {
            self.mobile = try decoderContainer.decode(String?.self, forKey: .mobile)
        }
        if decoderContainer.contains(.personId)
        {
            self.personId = try decoderContainer.decode(Int64?.self, forKey: .personId)
        }
        if decoderContainer.contains(.pin)
        {
            self.pin = try decoderContainer.decode(String?.self, forKey: .pin)
        }
        if decoderContainer.contains(.userName)
        {
            self.userName = try decoderContainer.decode(String?.self, forKey: .userName)
        }
    }
}
public extension NoticeReceiver{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: NoticeReceiverCodingKeys.self)
         try encoderContainer.encode(email, forKey: .email)
         try encoderContainer.encode(mobile, forKey: .mobile)
         try encoderContainer.encode(personId, forKey: .personId)
         try encoderContainer.encode(pin, forKey: .pin)
         try encoderContainer.encode(userName, forKey: .userName)
    }
}
///  describedAlarmHistory
public class DescribedAlarmHistory:NSObject,Codable{
    /// 报警规则ID
    var alarmId:String?
    /// 资源维度
    var dimension:String?
    /// 资源维度名称
    var dimensionName:String?
    /// 告警持续次数
    var durationTimes:Int64?
    /// 告警持续时间，单位分钟
    var noticeDurationTime:Int64?
    /// 用于前端显示的‘触发告警级别’。从低到高分别为‘普通’, ‘紧急’, ‘严重’
    var noticeLevel:String?
    /// 触发的告警级别。从低到高分别为‘common’, ‘critical’, ‘fatal’
    var noticeLevelTriggered:String?
    /// 告警时间
    var noticeTime:String?
    /// 资源类型
    var product:String?
    /// 资源类型名称
    var productName:String?
    /// 告警通知人
    var receivers:[NoticeReceiver?]?
    /// 资源Id
    var resourceId:String?
    /// Rule
    var rule:BasicRuleDetail?
    /// 规则类型
    var ruleType:String?
    /// 告警类型  1-告警恢复  2-告警 4-数据不足
    var status:Int64?
    /// 资源tags
    var tags:[String:String?]?
    /// 告警值
    var value:Double?



    public override init(){
            super.init()
    }

    enum DescribedAlarmHistoryCodingKeys: String, CodingKey {
        case alarmId
        case dimension
        case dimensionName
        case durationTimes
        case noticeDurationTime
        case noticeLevel
        case noticeLevelTriggered
        case noticeTime
        case product
        case productName
        case receivers
        case resourceId
        case rule
        case ruleType
        case status
        case tags
        case value
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: DescribedAlarmHistoryCodingKeys.self)
        if decoderContainer.contains(.alarmId)
        {
            self.alarmId = try decoderContainer.decode(String?.self, forKey: .alarmId)
        }
        if decoderContainer.contains(.dimension)
        {
            self.dimension = try decoderContainer.decode(String?.self, forKey: .dimension)
        }
        if decoderContainer.contains(.dimensionName)
        {
            self.dimensionName = try decoderContainer.decode(String?.self, forKey: .dimensionName)
        }
        if decoderContainer.contains(.durationTimes)
        {
            self.durationTimes = try decoderContainer.decode(Int64?.self, forKey: .durationTimes)
        }
        if decoderContainer.contains(.noticeDurationTime)
        {
            self.noticeDurationTime = try decoderContainer.decode(Int64?.self, forKey: .noticeDurationTime)
        }
        if decoderContainer.contains(.noticeLevel)
        {
            self.noticeLevel = try decoderContainer.decode(String?.self, forKey: .noticeLevel)
        }
        if decoderContainer.contains(.noticeLevelTriggered)
        {
            self.noticeLevelTriggered = try decoderContainer.decode(String?.self, forKey: .noticeLevelTriggered)
        }
        if decoderContainer.contains(.noticeTime)
        {
            self.noticeTime = try decoderContainer.decode(String?.self, forKey: .noticeTime)
        }
        if decoderContainer.contains(.product)
        {
            self.product = try decoderContainer.decode(String?.self, forKey: .product)
        }
        if decoderContainer.contains(.productName)
        {
            self.productName = try decoderContainer.decode(String?.self, forKey: .productName)
        }
        if decoderContainer.contains(.receivers)
        {
            self.receivers = try decoderContainer.decode([NoticeReceiver?]?.self, forKey: .receivers)
        }
        if decoderContainer.contains(.resourceId)
        {
            self.resourceId = try decoderContainer.decode(String?.self, forKey: .resourceId)
        }
        if decoderContainer.contains(.rule)
        {
            self.rule = try decoderContainer.decode(BasicRuleDetail?.self, forKey: .rule)
        }
        if decoderContainer.contains(.ruleType)
        {
            self.ruleType = try decoderContainer.decode(String?.self, forKey: .ruleType)
        }
        if decoderContainer.contains(.status)
        {
            self.status = try decoderContainer.decode(Int64?.self, forKey: .status)
        }
        if decoderContainer.contains(.tags)
        {
            self.tags = try decoderContainer.decode([String:String?]?.self, forKey: .tags)
        }
        if decoderContainer.contains(.value)
        {
            self.value = try decoderContainer.decode(Double?.self, forKey: .value)
        }
    }
}
public extension DescribedAlarmHistory{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: DescribedAlarmHistoryCodingKeys.self)
         try encoderContainer.encode(alarmId, forKey: .alarmId)
         try encoderContainer.encode(dimension, forKey: .dimension)
         try encoderContainer.encode(dimensionName, forKey: .dimensionName)
         try encoderContainer.encode(durationTimes, forKey: .durationTimes)
         try encoderContainer.encode(noticeDurationTime, forKey: .noticeDurationTime)
         try encoderContainer.encode(noticeLevel, forKey: .noticeLevel)
         try encoderContainer.encode(noticeLevelTriggered, forKey: .noticeLevelTriggered)
         try encoderContainer.encode(noticeTime, forKey: .noticeTime)
         try encoderContainer.encode(product, forKey: .product)
         try encoderContainer.encode(productName, forKey: .productName)
         try encoderContainer.encode(receivers, forKey: .receivers)
         try encoderContainer.encode(resourceId, forKey: .resourceId)
         try encoderContainer.encode(rule, forKey: .rule)
         try encoderContainer.encode(ruleType, forKey: .ruleType)
         try encoderContainer.encode(status, forKey: .status)
         try encoderContainer.encode(tags, forKey: .tags)
         try encoderContainer.encode(value, forKey: .value)
    }
}
///  NoticeContacts NoticeContacts
public class DescribedNoticeContacts:NSObject,Codable{
    /// 联系人ID
    var referenceId:Int64?
    /// 联系人类型。 0 - 联系人分组id， 1 - 联系人id
    var referenceType:Int64?



    public override init(){
            super.init()
    }

    enum DescribedNoticeContactsCodingKeys: String, CodingKey {
        case referenceId
        case referenceType
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: DescribedNoticeContactsCodingKeys.self)
        if decoderContainer.contains(.referenceId)
        {
            self.referenceId = try decoderContainer.decode(Int64?.self, forKey: .referenceId)
        }
        if decoderContainer.contains(.referenceType)
        {
            self.referenceType = try decoderContainer.decode(Int64?.self, forKey: .referenceType)
        }
    }
}
public extension DescribedNoticeContacts{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: DescribedNoticeContactsCodingKeys.self)
         try encoderContainer.encode(referenceId, forKey: .referenceId)
         try encoderContainer.encode(referenceType, forKey: .referenceType)
    }
}
///  webHookOption
public class WebHookOption:NSObject,Codable{
    /// 回调content 注：仅webHookUrl和webHookProtocol均不为空时，才会创建webHook
    var webHookContent:String?
    /// webHook协议
    var webHookProtocol:String?
    /// 回调secret，用户请求签名，防伪造
    var webHookSecret:String?
    /// 回调url
    var webHookUrl:String?



    public override init(){
            super.init()
    }

    enum WebHookOptionCodingKeys: String, CodingKey {
        case webHookContent
        case webHookProtocol
        case webHookSecret
        case webHookUrl
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: WebHookOptionCodingKeys.self)
        if decoderContainer.contains(.webHookContent)
        {
            self.webHookContent = try decoderContainer.decode(String?.self, forKey: .webHookContent)
        }
        if decoderContainer.contains(.webHookProtocol)
        {
            self.webHookProtocol = try decoderContainer.decode(String?.self, forKey: .webHookProtocol)
        }
        if decoderContainer.contains(.webHookSecret)
        {
            self.webHookSecret = try decoderContainer.decode(String?.self, forKey: .webHookSecret)
        }
        if decoderContainer.contains(.webHookUrl)
        {
            self.webHookUrl = try decoderContainer.decode(String?.self, forKey: .webHookUrl)
        }
    }
}
public extension WebHookOption{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: WebHookOptionCodingKeys.self)
         try encoderContainer.encode(webHookContent, forKey: .webHookContent)
         try encoderContainer.encode(webHookProtocol, forKey: .webHookProtocol)
         try encoderContainer.encode(webHookSecret, forKey: .webHookSecret)
         try encoderContainer.encode(webHookUrl, forKey: .webHookUrl)
    }
}
///  resourceOption
public class ResourceOption:NSObject,Codable{
    /// 指定具体资源ID设置报警规则，每次最多100个。优先resourceItems生效
    var resourceItems:[ResourceItem?]?
    /// TagsOption
    var tagsOption:TagsOption?



    public override init(){
            super.init()
    }

    enum ResourceOptionCodingKeys: String, CodingKey {
        case resourceItems
        case tagsOption
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: ResourceOptionCodingKeys.self)
        if decoderContainer.contains(.resourceItems)
        {
            self.resourceItems = try decoderContainer.decode([ResourceItem?]?.self, forKey: .resourceItems)
        }
        if decoderContainer.contains(.tagsOption)
        {
            self.tagsOption = try decoderContainer.decode(TagsOption?.self, forKey: .tagsOption)
        }
    }
}
public extension ResourceOption{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: ResourceOptionCodingKeys.self)
         try encoderContainer.encode(resourceItems, forKey: .resourceItems)
         try encoderContainer.encode(tagsOption, forKey: .tagsOption)
    }
}
///  ruleOption
public class RuleOption:NSObject,Codable{
    /// 规则触发条件,与模块参数同时指定时，优先使用rules
    var rules:[BasicRule?]?
    /// TemplateOption
    var templateOption:TemplateOption?



    public override init(){
            super.init()
    }

    enum RuleOptionCodingKeys: String, CodingKey {
        case rules
        case templateOption
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: RuleOptionCodingKeys.self)
        if decoderContainer.contains(.rules)
        {
            self.rules = try decoderContainer.decode([BasicRule?]?.self, forKey: .rules)
        }
        if decoderContainer.contains(.templateOption)
        {
            self.templateOption = try decoderContainer.decode(TemplateOption?.self, forKey: .templateOption)
        }
    }
}
public extension RuleOption{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: RuleOptionCodingKeys.self)
         try encoderContainer.encode(rules, forKey: .rules)
         try encoderContainer.encode(templateOption, forKey: .templateOption)
    }
}
///  ruleCounting
public class RuleCounting:NSObject,Codable{
    /// 处于报警状态的规则个数  status:2
    var alarmRuleCount:Int64?
    /// 未启用的规则 数量
    var disableRuleCount:Int64?
    /// 处于正常状态的规则个数  status：1
    var normalRuleCount:Int64?
    /// 产品标识
    var product:String?
    /// 监控规则 总数
    var totalRuleCount:Int64?
    /// 处于数据不足状态的规则 个数  status:4
    var unknownRuleCount:Int64?



    public override init(){
            super.init()
    }

    enum RuleCountingCodingKeys: String, CodingKey {
        case alarmRuleCount
        case disableRuleCount
        case normalRuleCount
        case product
        case totalRuleCount
        case unknownRuleCount
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: RuleCountingCodingKeys.self)
        if decoderContainer.contains(.alarmRuleCount)
        {
            self.alarmRuleCount = try decoderContainer.decode(Int64?.self, forKey: .alarmRuleCount)
        }
        if decoderContainer.contains(.disableRuleCount)
        {
            self.disableRuleCount = try decoderContainer.decode(Int64?.self, forKey: .disableRuleCount)
        }
        if decoderContainer.contains(.normalRuleCount)
        {
            self.normalRuleCount = try decoderContainer.decode(Int64?.self, forKey: .normalRuleCount)
        }
        if decoderContainer.contains(.product)
        {
            self.product = try decoderContainer.decode(String?.self, forKey: .product)
        }
        if decoderContainer.contains(.totalRuleCount)
        {
            self.totalRuleCount = try decoderContainer.decode(Int64?.self, forKey: .totalRuleCount)
        }
        if decoderContainer.contains(.unknownRuleCount)
        {
            self.unknownRuleCount = try decoderContainer.decode(Int64?.self, forKey: .unknownRuleCount)
        }
    }
}
public extension RuleCounting{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: RuleCountingCodingKeys.self)
         try encoderContainer.encode(alarmRuleCount, forKey: .alarmRuleCount)
         try encoderContainer.encode(disableRuleCount, forKey: .disableRuleCount)
         try encoderContainer.encode(normalRuleCount, forKey: .normalRuleCount)
         try encoderContainer.encode(product, forKey: .product)
         try encoderContainer.encode(totalRuleCount, forKey: .totalRuleCount)
         try encoderContainer.encode(unknownRuleCount, forKey: .unknownRuleCount)
    }
}
///  动态标签资源,对指定标签服务的tag下的资源设置报警规则
public class TagsOption:NSObject,Codable{
    /// 操作项(多个tagFilter之间关关系)默认是or
    var operatorValue:String?
    /// 资源标签,对所有符合该标签的资源设置报警规则，对于新加入该标签的资源自动生效
    var tags:[TagFilter?]?



    public override init(){
            super.init()
    }

    enum TagsOptionCodingKeys: String, CodingKey {
        case operatorValue = "operator"
        case tags
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: TagsOptionCodingKeys.self)
        if decoderContainer.contains(.operatorValue)
        {
            self.operatorValue = try decoderContainer.decode(String?.self, forKey: .operatorValue)
        }
        if decoderContainer.contains(.tags)
        {
            self.tags = try decoderContainer.decode([TagFilter?]?.self, forKey: .tags)
        }
    }
}
public extension TagsOption{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: TagsOptionCodingKeys.self)
         try encoderContainer.encode(operatorValue, forKey: .operatorValue)
         try encoderContainer.encode(tags, forKey: .tags)
    }
}
///  ruleResourceInfo
public class RuleResourceInfo:NSObject,Codable{
    /// 维度
    var dimension:String?
    /// 产品类型
    var product:String?
    /// Region
    var region:String?
    /// ResourceId
    var resourceId:String?



    public override init(){
            super.init()
    }

    enum RuleResourceInfoCodingKeys: String, CodingKey {
        case dimension
        case product
        case region
        case resourceId
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: RuleResourceInfoCodingKeys.self)
        if decoderContainer.contains(.dimension)
        {
            self.dimension = try decoderContainer.decode(String?.self, forKey: .dimension)
        }
        if decoderContainer.contains(.product)
        {
            self.product = try decoderContainer.decode(String?.self, forKey: .product)
        }
        if decoderContainer.contains(.region)
        {
            self.region = try decoderContainer.decode(String?.self, forKey: .region)
        }
        if decoderContainer.contains(.resourceId)
        {
            self.resourceId = try decoderContainer.decode(String?.self, forKey: .resourceId)
        }
    }
}
public extension RuleResourceInfo{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: RuleResourceInfoCodingKeys.self)
         try encoderContainer.encode(dimension, forKey: .dimension)
         try encoderContainer.encode(product, forKey: .product)
         try encoderContainer.encode(region, forKey: .region)
         try encoderContainer.encode(resourceId, forKey: .resourceId)
    }
}
///  product
public class Product:NSObject,Codable{
    /// 维度信息
    var dimensions:[Dimension?]?
    /// 产品标识
    var productValue:String?
    /// 产品名称
    var productName:String?
    /// product对应的产品线
    var serviceCode:String?
    /// 对应的标签服务serviceCode
    var tagServiceCode:String?
    /// Tags
    var tags:[String:String?]?



    public override init(){
            super.init()
    }

    enum ProductCodingKeys: String, CodingKey {
        case dimensions
        case productValue = "product"
        case productName
        case serviceCode
        case tagServiceCode
        case tags
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: ProductCodingKeys.self)
        if decoderContainer.contains(.dimensions)
        {
            self.dimensions = try decoderContainer.decode([Dimension?]?.self, forKey: .dimensions)
        }
        if decoderContainer.contains(.productValue)
        {
            self.productValue = try decoderContainer.decode(String?.self, forKey: .productValue)
        }
        if decoderContainer.contains(.productName)
        {
            self.productName = try decoderContainer.decode(String?.self, forKey: .productName)
        }
        if decoderContainer.contains(.serviceCode)
        {
            self.serviceCode = try decoderContainer.decode(String?.self, forKey: .serviceCode)
        }
        if decoderContainer.contains(.tagServiceCode)
        {
            self.tagServiceCode = try decoderContainer.decode(String?.self, forKey: .tagServiceCode)
        }
        if decoderContainer.contains(.tags)
        {
            self.tags = try decoderContainer.decode([String:String?]?.self, forKey: .tags)
        }
    }
}
public extension Product{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: ProductCodingKeys.self)
         try encoderContainer.encode(dimensions, forKey: .dimensions)
         try encoderContainer.encode(productValue, forKey: .productValue)
         try encoderContainer.encode(productName, forKey: .productName)
         try encoderContainer.encode(serviceCode, forKey: .serviceCode)
         try encoderContainer.encode(tagServiceCode, forKey: .tagServiceCode)
         try encoderContainer.encode(tags, forKey: .tags)
    }
}
///  ruleOptionDetail
public class RuleOptionDetail:NSObject,Codable{
    /// 规则触发条件,与模块参数同时指定时，优先使用rules
    var rules:[BasicRuleDetail?]?
    /// TemplateOption
    var templateOption:TemplateOption?



    public override init(){
            super.init()
    }

    enum RuleOptionDetailCodingKeys: String, CodingKey {
        case rules
        case templateOption
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: RuleOptionDetailCodingKeys.self)
        if decoderContainer.contains(.rules)
        {
            self.rules = try decoderContainer.decode([BasicRuleDetail?]?.self, forKey: .rules)
        }
        if decoderContainer.contains(.templateOption)
        {
            self.templateOption = try decoderContainer.decode(TemplateOption?.self, forKey: .templateOption)
        }
    }
}
public extension RuleOptionDetail{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: RuleOptionDetailCodingKeys.self)
         try encoderContainer.encode(rules, forKey: .rules)
         try encoderContainer.encode(templateOption, forKey: .templateOption)
    }
}
///  createAlarmSpec
public class CreateAlarmSpec:NSObject,Codable{
    /// 告警通知联系人
    var baseContact:[BaseContact?]?
    /// 幂等性校验参数,最长36位,若两个请求clientToken相等，则返回第一次创建的规则id，只创建一次规则
    /// Required:true
    var clientToken:String
    /// 资源维度，可用的维度请使用 describeProductsForAlarm接口查询
    var dimension:String?
    /// 是否启用, 1表示启用规则，0表示禁用规则，默认为1
    var enabled:Int64?
    /// 通知策略
    var noticeOption:[NoticeOption?]?
    /// 资源类型, 可用的资源类型列表请使用 describeProductsForAlarm接口查询。
    /// Required:true
    var product:String
    /// ResourceOption
    /// Required:true
    var resourceOption:ResourceOption
    /// 规则名称，规则名称，最大长度42个字符，只允许中英文、数字、&#39;&#39;-&#39;&#39;和&quot;_&quot;
    /// Required:true
    var ruleName:String
    /// RuleOption
    /// Required:true
    var ruleOption:RuleOption
    /// 规则类型, 默认为resourceMonitor
    var ruleType:String?
    /// 资源维度，指定监控数据实例的维度标签,如resourceId&#x3D;id。(请确认资源的监控数据带有该标签，否则规则会报数据不足)
    var tags:[String:String?]?
    /// WebHookOption
    var webHookOption:WebHookOption?



    public  init(clientToken:String,product:String,resourceOption:ResourceOption,ruleName:String,ruleOption:RuleOption){
             self.clientToken = clientToken
             self.product = product
             self.resourceOption = resourceOption
             self.ruleName = ruleName
             self.ruleOption = ruleOption
    }

    enum CreateAlarmSpecCodingKeys: String, CodingKey {
        case baseContact
        case clientToken
        case dimension
        case enabled
        case noticeOption
        case product
        case resourceOption
        case ruleName
        case ruleOption
        case ruleType
        case tags
        case webHookOption
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: CreateAlarmSpecCodingKeys.self)
        if decoderContainer.contains(.baseContact)
        {
            self.baseContact = try decoderContainer.decode([BaseContact?]?.self, forKey: .baseContact)
        }
        self.clientToken = try decoderContainer.decode(String.self, forKey: .clientToken)
        if decoderContainer.contains(.dimension)
        {
            self.dimension = try decoderContainer.decode(String?.self, forKey: .dimension)
        }
        if decoderContainer.contains(.enabled)
        {
            self.enabled = try decoderContainer.decode(Int64?.self, forKey: .enabled)
        }
        if decoderContainer.contains(.noticeOption)
        {
            self.noticeOption = try decoderContainer.decode([NoticeOption?]?.self, forKey: .noticeOption)
        }
        self.product = try decoderContainer.decode(String.self, forKey: .product)
        self.resourceOption = try decoderContainer.decode(ResourceOption.self, forKey: .resourceOption)
        self.ruleName = try decoderContainer.decode(String.self, forKey: .ruleName)
        self.ruleOption = try decoderContainer.decode(RuleOption.self, forKey: .ruleOption)
        if decoderContainer.contains(.ruleType)
        {
            self.ruleType = try decoderContainer.decode(String?.self, forKey: .ruleType)
        }
        if decoderContainer.contains(.tags)
        {
            self.tags = try decoderContainer.decode([String:String?]?.self, forKey: .tags)
        }
        if decoderContainer.contains(.webHookOption)
        {
            self.webHookOption = try decoderContainer.decode(WebHookOption?.self, forKey: .webHookOption)
        }
    }
}
public extension CreateAlarmSpec{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: CreateAlarmSpecCodingKeys.self)
         try encoderContainer.encode(baseContact, forKey: .baseContact)
         try encoderContainer.encode(clientToken, forKey: .clientToken)
         try encoderContainer.encode(dimension, forKey: .dimension)
         try encoderContainer.encode(enabled, forKey: .enabled)
         try encoderContainer.encode(noticeOption, forKey: .noticeOption)
         try encoderContainer.encode(product, forKey: .product)
         try encoderContainer.encode(resourceOption, forKey: .resourceOption)
         try encoderContainer.encode(ruleName, forKey: .ruleName)
         try encoderContainer.encode(ruleOption, forKey: .ruleOption)
         try encoderContainer.encode(ruleType, forKey: .ruleType)
         try encoderContainer.encode(tags, forKey: .tags)
         try encoderContainer.encode(webHookOption, forKey: .webHookOption)
    }
}
///  updateAlarmSpec
public class UpdateAlarmSpec:NSObject,Codable{
    /// 告警通知联系人
    var baseContact:[BaseContact?]?
    /// 资源维度，可用的维度请使用 describeProductsForAlarm接口查询
    var dimension:String?
    /// 是否启用, 1表示启用规则，0表示禁用规则，默认为1
    var enabled:Int64?
    /// 通知策略
    var noticeOption:[NoticeOption?]?
    /// 资源类型, 可用的资源类型列表请使用 describeProductsForAlarm接口查询。
    /// Required:true
    var product:String
    /// ResourceOption
    /// Required:true
    var resourceOption:ResourceOption
    /// 规则名称，规则名称，最大长度42个字符，只允许中英文、数字、&#39;&#39;-&#39;&#39;和&quot;_&quot;
    /// Required:true
    var ruleName:String
    /// RuleOption
    /// Required:true
    var ruleOption:RuleOption
    /// 规则类型, 默认为resourceMonitor
    var ruleType:String?
    /// 资源维度，指定监控数据实例的维度标签,如resourceId&#x3D;id。(请确认资源的监控数据带有该标签，否则规则会报数据不足)
    var tags:[String:String?]?
    /// WebHookOption
    var webHookOption:WebHookOption?



    public  init(product:String,resourceOption:ResourceOption,ruleName:String,ruleOption:RuleOption){
             self.product = product
             self.resourceOption = resourceOption
             self.ruleName = ruleName
             self.ruleOption = ruleOption
    }

    enum UpdateAlarmSpecCodingKeys: String, CodingKey {
        case baseContact
        case dimension
        case enabled
        case noticeOption
        case product
        case resourceOption
        case ruleName
        case ruleOption
        case ruleType
        case tags
        case webHookOption
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: UpdateAlarmSpecCodingKeys.self)
        if decoderContainer.contains(.baseContact)
        {
            self.baseContact = try decoderContainer.decode([BaseContact?]?.self, forKey: .baseContact)
        }
        if decoderContainer.contains(.dimension)
        {
            self.dimension = try decoderContainer.decode(String?.self, forKey: .dimension)
        }
        if decoderContainer.contains(.enabled)
        {
            self.enabled = try decoderContainer.decode(Int64?.self, forKey: .enabled)
        }
        if decoderContainer.contains(.noticeOption)
        {
            self.noticeOption = try decoderContainer.decode([NoticeOption?]?.self, forKey: .noticeOption)
        }
        self.product = try decoderContainer.decode(String.self, forKey: .product)
        self.resourceOption = try decoderContainer.decode(ResourceOption.self, forKey: .resourceOption)
        self.ruleName = try decoderContainer.decode(String.self, forKey: .ruleName)
        self.ruleOption = try decoderContainer.decode(RuleOption.self, forKey: .ruleOption)
        if decoderContainer.contains(.ruleType)
        {
            self.ruleType = try decoderContainer.decode(String?.self, forKey: .ruleType)
        }
        if decoderContainer.contains(.tags)
        {
            self.tags = try decoderContainer.decode([String:String?]?.self, forKey: .tags)
        }
        if decoderContainer.contains(.webHookOption)
        {
            self.webHookOption = try decoderContainer.decode(WebHookOption?.self, forKey: .webHookOption)
        }
    }
}
public extension UpdateAlarmSpec{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: UpdateAlarmSpecCodingKeys.self)
         try encoderContainer.encode(baseContact, forKey: .baseContact)
         try encoderContainer.encode(dimension, forKey: .dimension)
         try encoderContainer.encode(enabled, forKey: .enabled)
         try encoderContainer.encode(noticeOption, forKey: .noticeOption)
         try encoderContainer.encode(product, forKey: .product)
         try encoderContainer.encode(resourceOption, forKey: .resourceOption)
         try encoderContainer.encode(ruleName, forKey: .ruleName)
         try encoderContainer.encode(ruleOption, forKey: .ruleOption)
         try encoderContainer.encode(ruleType, forKey: .ruleType)
         try encoderContainer.encode(tags, forKey: .tags)
         try encoderContainer.encode(webHookOption, forKey: .webHookOption)
    }
}
///  updateWebHookSpec
public class UpdateWebHookSpec:NSObject,Codable{
    /// 是否启用, 1表示启用webHook，0表示禁用webHook，默认为1
    var active:Int64?
    /// webHook content
    var content:String?
    /// webHook 协议,http或者https
    /// Required:true
    var protocolValue:String
    /// webHook secret，用户请求签名，防伪造
    var secret:String?
    /// webHook url
    /// Required:true
    var url:String



    public  init(protocolValue:String,url:String){
             self.protocolValue = protocolValue
             self.url = url
    }

    enum UpdateWebHookSpecCodingKeys: String, CodingKey {
        case active
        case content
        case protocolValue = "protocol"
        case secret
        case url
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: UpdateWebHookSpecCodingKeys.self)
        if decoderContainer.contains(.active)
        {
            self.active = try decoderContainer.decode(Int64?.self, forKey: .active)
        }
        if decoderContainer.contains(.content)
        {
            self.content = try decoderContainer.decode(String?.self, forKey: .content)
        }
        self.protocolValue = try decoderContainer.decode(String.self, forKey: .protocolValue)
        if decoderContainer.contains(.secret)
        {
            self.secret = try decoderContainer.decode(String?.self, forKey: .secret)
        }
        self.url = try decoderContainer.decode(String.self, forKey: .url)
    }
}
public extension UpdateWebHookSpec{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: UpdateWebHookSpecCodingKeys.self)
         try encoderContainer.encode(active, forKey: .active)
         try encoderContainer.encode(content, forKey: .content)
         try encoderContainer.encode(protocolValue, forKey: .protocolValue)
         try encoderContainer.encode(secret, forKey: .secret)
         try encoderContainer.encode(url, forKey: .url)
    }
}
///  updateAlarmResourcesSpec
public class UpdateAlarmResourcesSpec:NSObject,Codable{
    /// 操作类型,默认为1，说明：1-覆盖  2-追加 3-删除
    var operatorType:Int64?
    /// ResourceOption
    /// Required:true
    var resourceOption:ResourceOption



    public  init(resourceOption:ResourceOption){
             self.resourceOption = resourceOption
    }

    enum UpdateAlarmResourcesSpecCodingKeys: String, CodingKey {
        case operatorType
        case resourceOption
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: UpdateAlarmResourcesSpecCodingKeys.self)
        if decoderContainer.contains(.operatorType)
        {
            self.operatorType = try decoderContainer.decode(Int64?.self, forKey: .operatorType)
        }
        self.resourceOption = try decoderContainer.decode(ResourceOption.self, forKey: .resourceOption)
    }
}
public extension UpdateAlarmResourcesSpec{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: UpdateAlarmResourcesSpecCodingKeys.self)
         try encoderContainer.encode(operatorType, forKey: .operatorType)
         try encoderContainer.encode(resourceOption, forKey: .resourceOption)
    }
}
///  详情
public class RuleMetricDetail:NSObject,Codable{
    /// 指标的计算单位，比如bit/s、%、k等
    var calculateUnit:String?
    /// 维度标识
    var dimension:String?
    /// 监控项唯一标识，可根据DescribeMetricsForCreateAlarm接口查询各产品线可用的监控项（创建规则时使用Metric字段）。格式：metric:downsample
    var metric:String?
    /// 监控项名称
    var metricName:String?
    /// 产品标识
    var product:String?
    /// 产品线标识
    var serviceCode:String?



    public override init(){
            super.init()
    }

    enum RuleMetricDetailCodingKeys: String, CodingKey {
        case calculateUnit
        case dimension
        case metric
        case metricName
        case product
        case serviceCode
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: RuleMetricDetailCodingKeys.self)
        if decoderContainer.contains(.calculateUnit)
        {
            self.calculateUnit = try decoderContainer.decode(String?.self, forKey: .calculateUnit)
        }
        if decoderContainer.contains(.dimension)
        {
            self.dimension = try decoderContainer.decode(String?.self, forKey: .dimension)
        }
        if decoderContainer.contains(.metric)
        {
            self.metric = try decoderContainer.decode(String?.self, forKey: .metric)
        }
        if decoderContainer.contains(.metricName)
        {
            self.metricName = try decoderContainer.decode(String?.self, forKey: .metricName)
        }
        if decoderContainer.contains(.product)
        {
            self.product = try decoderContainer.decode(String?.self, forKey: .product)
        }
        if decoderContainer.contains(.serviceCode)
        {
            self.serviceCode = try decoderContainer.decode(String?.self, forKey: .serviceCode)
        }
    }
}
public extension RuleMetricDetail{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: RuleMetricDetailCodingKeys.self)
         try encoderContainer.encode(calculateUnit, forKey: .calculateUnit)
         try encoderContainer.encode(dimension, forKey: .dimension)
         try encoderContainer.encode(metric, forKey: .metric)
         try encoderContainer.encode(metricName, forKey: .metricName)
         try encoderContainer.encode(product, forKey: .product)
         try encoderContainer.encode(serviceCode, forKey: .serviceCode)
    }
}
///  statisticsProductMetric
public class StatisticsProductMetric:NSObject,Codable{
    /// 聚合方式
    var aggregate:String?
    /// 单位
    var calculateUnit:String?
    /// metric
    var metric:String?
    /// metric名称
    var metricShow:String?



    public override init(){
            super.init()
    }

    enum StatisticsProductMetricCodingKeys: String, CodingKey {
        case aggregate
        case calculateUnit
        case metric
        case metricShow
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: StatisticsProductMetricCodingKeys.self)
        if decoderContainer.contains(.aggregate)
        {
            self.aggregate = try decoderContainer.decode(String?.self, forKey: .aggregate)
        }
        if decoderContainer.contains(.calculateUnit)
        {
            self.calculateUnit = try decoderContainer.decode(String?.self, forKey: .calculateUnit)
        }
        if decoderContainer.contains(.metric)
        {
            self.metric = try decoderContainer.decode(String?.self, forKey: .metric)
        }
        if decoderContainer.contains(.metricShow)
        {
            self.metricShow = try decoderContainer.decode(String?.self, forKey: .metricShow)
        }
    }
}
public extension StatisticsProductMetric{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: StatisticsProductMetricCodingKeys.self)
         try encoderContainer.encode(aggregate, forKey: .aggregate)
         try encoderContainer.encode(calculateUnit, forKey: .calculateUnit)
         try encoderContainer.encode(metric, forKey: .metric)
         try encoderContainer.encode(metricShow, forKey: .metricShow)
    }
}
///  statsItem
public class StatsItem:NSObject,Codable{
    /// 聚合方式
    var aggregateFunc:String?
    /// 单位
    var calculateUnit:String?
    /// 数据点
    var dps:[DataPoint?]?
    /// metric
    var metric:String?
    /// metric名称
    var metricName:String?
    /// tags
    var tags:[String:String?]?



    public override init(){
            super.init()
    }

    enum StatsItemCodingKeys: String, CodingKey {
        case aggregateFunc
        case calculateUnit
        case dps
        case metric
        case metricName
        case tags
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: StatsItemCodingKeys.self)
        if decoderContainer.contains(.aggregateFunc)
        {
            self.aggregateFunc = try decoderContainer.decode(String?.self, forKey: .aggregateFunc)
        }
        if decoderContainer.contains(.calculateUnit)
        {
            self.calculateUnit = try decoderContainer.decode(String?.self, forKey: .calculateUnit)
        }
        if decoderContainer.contains(.dps)
        {
            self.dps = try decoderContainer.decode([DataPoint?]?.self, forKey: .dps)
        }
        if decoderContainer.contains(.metric)
        {
            self.metric = try decoderContainer.decode(String?.self, forKey: .metric)
        }
        if decoderContainer.contains(.metricName)
        {
            self.metricName = try decoderContainer.decode(String?.self, forKey: .metricName)
        }
        if decoderContainer.contains(.tags)
        {
            self.tags = try decoderContainer.decode([String:String?]?.self, forKey: .tags)
        }
    }
}
public extension StatsItem{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: StatsItemCodingKeys.self)
         try encoderContainer.encode(aggregateFunc, forKey: .aggregateFunc)
         try encoderContainer.encode(calculateUnit, forKey: .calculateUnit)
         try encoderContainer.encode(dps, forKey: .dps)
         try encoderContainer.encode(metric, forKey: .metric)
         try encoderContainer.encode(metricName, forKey: .metricName)
         try encoderContainer.encode(tags, forKey: .tags)
    }
}
///  数据详情
public class SqlInfo:NSObject,Codable{
    /// 产品标识，目前统一用jcloud
    var appCode:String?
    /// 客户端IP地址
    var client_net_address:String?
    /// 库名
    var database:String?
    /// SQL已执行时间（单位s）
    var execution_time:Int64?
    /// 用户名
    var loginname:String?
    /// 监控项
    var metric:String?
    /// 资源所在的地域
    var region:String?
    /// 资源的uuid
    var resourceId:String?
    /// 资源的类型
    var serviceCode:String?
    /// 会话ID
    var session_id:String?
    /// SQL详细文本
    var sqlstr:String?
    /// SQL开始执行的时间
    var start_time:String?
    /// SQL会话请求状态
    var status:String?
    /// 毫秒级时间戳
    var time:Int64?
    /// 上报的监控值
    var value:Int64?



    public override init(){
            super.init()
    }

    enum SqlInfoCodingKeys: String, CodingKey {
        case appCode
        case client_net_address
        case database
        case execution_time
        case loginname
        case metric
        case region
        case resourceId
        case serviceCode
        case session_id
        case sqlstr
        case start_time
        case status
        case time
        case value
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: SqlInfoCodingKeys.self)
        if decoderContainer.contains(.appCode)
        {
            self.appCode = try decoderContainer.decode(String?.self, forKey: .appCode)
        }
        if decoderContainer.contains(.client_net_address)
        {
            self.client_net_address = try decoderContainer.decode(String?.self, forKey: .client_net_address)
        }
        if decoderContainer.contains(.database)
        {
            self.database = try decoderContainer.decode(String?.self, forKey: .database)
        }
        if decoderContainer.contains(.execution_time)
        {
            self.execution_time = try decoderContainer.decode(Int64?.self, forKey: .execution_time)
        }
        if decoderContainer.contains(.loginname)
        {
            self.loginname = try decoderContainer.decode(String?.self, forKey: .loginname)
        }
        if decoderContainer.contains(.metric)
        {
            self.metric = try decoderContainer.decode(String?.self, forKey: .metric)
        }
        if decoderContainer.contains(.region)
        {
            self.region = try decoderContainer.decode(String?.self, forKey: .region)
        }
        if decoderContainer.contains(.resourceId)
        {
            self.resourceId = try decoderContainer.decode(String?.self, forKey: .resourceId)
        }
        if decoderContainer.contains(.serviceCode)
        {
            self.serviceCode = try decoderContainer.decode(String?.self, forKey: .serviceCode)
        }
        if decoderContainer.contains(.session_id)
        {
            self.session_id = try decoderContainer.decode(String?.self, forKey: .session_id)
        }
        if decoderContainer.contains(.sqlstr)
        {
            self.sqlstr = try decoderContainer.decode(String?.self, forKey: .sqlstr)
        }
        if decoderContainer.contains(.start_time)
        {
            self.start_time = try decoderContainer.decode(String?.self, forKey: .start_time)
        }
        if decoderContainer.contains(.status)
        {
            self.status = try decoderContainer.decode(String?.self, forKey: .status)
        }
        if decoderContainer.contains(.time)
        {
            self.time = try decoderContainer.decode(Int64?.self, forKey: .time)
        }
        if decoderContainer.contains(.value)
        {
            self.value = try decoderContainer.decode(Int64?.self, forKey: .value)
        }
    }
}
public extension SqlInfo{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: SqlInfoCodingKeys.self)
         try encoderContainer.encode(appCode, forKey: .appCode)
         try encoderContainer.encode(client_net_address, forKey: .client_net_address)
         try encoderContainer.encode(database, forKey: .database)
         try encoderContainer.encode(execution_time, forKey: .execution_time)
         try encoderContainer.encode(loginname, forKey: .loginname)
         try encoderContainer.encode(metric, forKey: .metric)
         try encoderContainer.encode(region, forKey: .region)
         try encoderContainer.encode(resourceId, forKey: .resourceId)
         try encoderContainer.encode(serviceCode, forKey: .serviceCode)
         try encoderContainer.encode(session_id, forKey: .session_id)
         try encoderContainer.encode(sqlstr, forKey: .sqlstr)
         try encoderContainer.encode(start_time, forKey: .start_time)
         try encoderContainer.encode(status, forKey: .status)
         try encoderContainer.encode(time, forKey: .time)
         try encoderContainer.encode(value, forKey: .value)
    }
}
///  describeTopNSlowSqlSpec
public class DescribeTopNSlowSqlSpec:NSObject,Codable{
    /// 查询时间范围的结束时间， UTC时间，格式：2016-12-11T00:00:00+0800（为空时，将由startTime与timeInterval计算得出）（注意在url中+要转译为%2B故url中为2016-12-11T00:00:00%2B0800）
      /// in: query
    var endTime:String?
    /// 资源的uuid
    /// Required:true
    var resourceId:String
    /// 资源的类型,sqlserver
    /// Required:true
    var serviceCode:String
    /// 查询时间范围的开始时间， UTC时间，格式：2016-12-11T00:00:00+0800（早于30d时，将被重置为30d）（注意在url中+要转译为%2B故url中为2016-12-11T00:00:00%2B0800）
      /// in: query
    var startTime:String?
    /// 时间间隔：1h，6h，12h，1d，3d，7d，14d，固定时间间隔，timeInterval 与 endTime 至少填一项
      /// in: query
    var timeInterval:String?
    /// topN数量
    /// Required:true
    var topN:Int64



    public  init(resourceId:String,serviceCode:String,topN:Int64){
             self.resourceId = resourceId
             self.serviceCode = serviceCode
             self.topN = topN
    }

    enum DescribeTopNSlowSqlSpecCodingKeys: String, CodingKey {
        case endTime
        case resourceId
        case serviceCode
        case startTime
        case timeInterval
        case topN
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: DescribeTopNSlowSqlSpecCodingKeys.self)
        if decoderContainer.contains(.endTime)
        {
            self.endTime = try decoderContainer.decode(String?.self, forKey: .endTime)
        }
        self.resourceId = try decoderContainer.decode(String.self, forKey: .resourceId)
        self.serviceCode = try decoderContainer.decode(String.self, forKey: .serviceCode)
        if decoderContainer.contains(.startTime)
        {
            self.startTime = try decoderContainer.decode(String?.self, forKey: .startTime)
        }
        if decoderContainer.contains(.timeInterval)
        {
            self.timeInterval = try decoderContainer.decode(String?.self, forKey: .timeInterval)
        }
        self.topN = try decoderContainer.decode(Int64.self, forKey: .topN)
    }
}
public extension DescribeTopNSlowSqlSpec{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: DescribeTopNSlowSqlSpecCodingKeys.self)
         try encoderContainer.encode(endTime, forKey: .endTime)
         try encoderContainer.encode(resourceId, forKey: .resourceId)
         try encoderContainer.encode(serviceCode, forKey: .serviceCode)
         try encoderContainer.encode(startTime, forKey: .startTime)
         try encoderContainer.encode(timeInterval, forKey: .timeInterval)
         try encoderContainer.encode(topN, forKey: .topN)
    }
}
///  创建监控规则
public class CreateCmAlarmParam:NSObject,Codable{
    /// 统计方法，必须与定义的metric一致，可选值列表：avg,max,sum,min
    /// Required:true
    var calculation:String
    /// 报警规则通知的联系组，必须在控制台上已创建，例如&quot; [&#39;联系组1&#39;,&#39;联系组2&#39;]&quot;
    var contactGroups:[String?]?
    /// 报警规则通知的联系人，必须在控制台上已创建，例如 [“联系人1”,”联系人2”]
    var contactPersons:[String?]?
    /// 取样频次
    var downSample:String?
    /// 根据产品线查询可用监控项列表 接口 返回的Metric字段
    /// Required:true
    var metricUID:String
    /// 命名空间
    /// Required:true
    var namespaceUID:String
    /// 通知周期 单位：小时
    var noticePeriod:Int64?
    /// 报警规则对应实例列表，每次最多100个，例如&quot;[&#39;resourceId1&#39;,&#39;resourceId2&#39;]&quot;
    /// Required:true
    var objUIDs:[String?]?
    /// 报警比较符，只能为以下几种&lt;&#x3D;,&lt;,&gt;,&gt;&#x3D;,&#x3D;&#x3D;,!&#x3D;
    /// Required:true
    var operation:String
    /// 查询指标的周期，单位为分钟,目前支持的取值：2，5，15，30，60
    /// Required:true
    var period:Int64
    /// 规则名称，最大长度42个字符，只允许中英文、数字、&#39;&#39;-&#39;&#39;和&quot;_&quot;
    var ruleName:String?
    /// 报警阈值，目前只开放数值类型功能
    /// Required:true
    var threshold:Double
    /// 连续探测几次都满足阈值条件时报警，可选值:1,2,3,5
    /// Required:true
    var times:Int64



    public  init(calculation:String,metricUID:String,namespaceUID:String,objUIDs:[String?]?,operation:String,period:Int64,threshold:Double,times:Int64){
             self.calculation = calculation
             self.metricUID = metricUID
             self.namespaceUID = namespaceUID
             self.objUIDs = objUIDs
             self.operation = operation
             self.period = period
             self.threshold = threshold
             self.times = times
    }

    enum CreateCmAlarmParamCodingKeys: String, CodingKey {
        case calculation
        case contactGroups
        case contactPersons
        case downSample
        case metricUID
        case namespaceUID
        case noticePeriod
        case objUIDs
        case operation
        case period
        case ruleName
        case threshold
        case times
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: CreateCmAlarmParamCodingKeys.self)
        self.calculation = try decoderContainer.decode(String.self, forKey: .calculation)
        if decoderContainer.contains(.contactGroups)
        {
            self.contactGroups = try decoderContainer.decode([String?]?.self, forKey: .contactGroups)
        }
        if decoderContainer.contains(.contactPersons)
        {
            self.contactPersons = try decoderContainer.decode([String?]?.self, forKey: .contactPersons)
        }
        if decoderContainer.contains(.downSample)
        {
            self.downSample = try decoderContainer.decode(String?.self, forKey: .downSample)
        }
        self.metricUID = try decoderContainer.decode(String.self, forKey: .metricUID)
        self.namespaceUID = try decoderContainer.decode(String.self, forKey: .namespaceUID)
        if decoderContainer.contains(.noticePeriod)
        {
            self.noticePeriod = try decoderContainer.decode(Int64?.self, forKey: .noticePeriod)
        }
        self.objUIDs = try decoderContainer.decode([String?]?.self, forKey: .objUIDs)
        self.operation = try decoderContainer.decode(String.self, forKey: .operation)
        self.period = try decoderContainer.decode(Int64.self, forKey: .period)
        if decoderContainer.contains(.ruleName)
        {
            self.ruleName = try decoderContainer.decode(String?.self, forKey: .ruleName)
        }
        self.threshold = try decoderContainer.decode(Double.self, forKey: .threshold)
        self.times = try decoderContainer.decode(Int64.self, forKey: .times)
    }
}
public extension CreateCmAlarmParam{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: CreateCmAlarmParamCodingKeys.self)
         try encoderContainer.encode(calculation, forKey: .calculation)
         try encoderContainer.encode(contactGroups, forKey: .contactGroups)
         try encoderContainer.encode(contactPersons, forKey: .contactPersons)
         try encoderContainer.encode(downSample, forKey: .downSample)
         try encoderContainer.encode(metricUID, forKey: .metricUID)
         try encoderContainer.encode(namespaceUID, forKey: .namespaceUID)
         try encoderContainer.encode(noticePeriod, forKey: .noticePeriod)
         try encoderContainer.encode(objUIDs, forKey: .objUIDs)
         try encoderContainer.encode(operation, forKey: .operation)
         try encoderContainer.encode(period, forKey: .period)
         try encoderContainer.encode(ruleName, forKey: .ruleName)
         try encoderContainer.encode(threshold, forKey: .threshold)
         try encoderContainer.encode(times, forKey: .times)
    }
}
///  objInfo
public class ObjInfo:NSObject,Codable{
    /// metric列表
    var metrics:[String?]?
    /// obj名称
    var objName:String?
    /// obj UID
    var objUid:String?



    public override init(){
            super.init()
    }

    enum ObjInfoCodingKeys: String, CodingKey {
        case metrics
        case objName
        case objUid
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: ObjInfoCodingKeys.self)
        if decoderContainer.contains(.metrics)
        {
            self.metrics = try decoderContainer.decode([String?]?.self, forKey: .metrics)
        }
        if decoderContainer.contains(.objName)
        {
            self.objName = try decoderContainer.decode(String?.self, forKey: .objName)
        }
        if decoderContainer.contains(.objUid)
        {
            self.objUid = try decoderContainer.decode(String?.self, forKey: .objUid)
        }
    }
}
public extension ObjInfo{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: ObjInfoCodingKeys.self)
         try encoderContainer.encode(metrics, forKey: .metrics)
         try encoderContainer.encode(objName, forKey: .objName)
         try encoderContainer.encode(objUid, forKey: .objUid)
    }
}
///  nsInfo
public class NsInfo:NSObject,Codable{
    /// metric个数
    var metricCount:Int64?
    /// 命名空间名称
    var nsName:String?
    /// 命名空间uid
    var nsUid:String?
    /// obj个数
    var objCount:Int64?



    public override init(){
            super.init()
    }

    enum NsInfoCodingKeys: String, CodingKey {
        case metricCount
        case nsName
        case nsUid
        case objCount
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: NsInfoCodingKeys.self)
        if decoderContainer.contains(.metricCount)
        {
            self.metricCount = try decoderContainer.decode(Int64?.self, forKey: .metricCount)
        }
        if decoderContainer.contains(.nsName)
        {
            self.nsName = try decoderContainer.decode(String?.self, forKey: .nsName)
        }
        if decoderContainer.contains(.nsUid)
        {
            self.nsUid = try decoderContainer.decode(String?.self, forKey: .nsUid)
        }
        if decoderContainer.contains(.objCount)
        {
            self.objCount = try decoderContainer.decode(Int64?.self, forKey: .objCount)
        }
    }
}
public extension NsInfo{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: NsInfoCodingKeys.self)
         try encoderContainer.encode(metricCount, forKey: .metricCount)
         try encoderContainer.encode(nsName, forKey: .nsName)
         try encoderContainer.encode(nsUid, forKey: .nsUid)
         try encoderContainer.encode(objCount, forKey: .objCount)
    }
}
///  describeCMMetricsDataSpec
public class DescribeCMMetricsDataSpec:NSObject,Codable{
    /// AggrType
    var aggrType:String?
    /// 查询时间范围的结束时间， UTC时间，格式：2016-12-11T00:00:00+0800（为空时，将由startTime与timeInterval计算得出）（注意在url中+要转译为%2B故url中为2016-12-11T00:00:00%2B0800）
      /// in: query
    var endTime:String?
    /// metric id列表
      /// in: query
    var metricUID:[String?]?
    /// 查询时间范围的开始时间， UTC时间，格式：2016-12-11T00:00:00+0800（早于30d时，将被重置为30d）（注意在url中+要转译为%2B故url中为2016-12-11T00:00:00%2B0800）
      /// in: query
    var startTime:String?
    /// 时间间隔：1h，6h，12h，1d，3d，7d，14d，固定时间间隔，timeInterval 与 endTime 至少填一项
      /// in: query
    var timeInterval:String?



    public override init(){
            super.init()
    }

    enum DescribeCMMetricsDataSpecCodingKeys: String, CodingKey {
        case aggrType
        case endTime
        case metricUID
        case startTime
        case timeInterval
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: DescribeCMMetricsDataSpecCodingKeys.self)
        if decoderContainer.contains(.aggrType)
        {
            self.aggrType = try decoderContainer.decode(String?.self, forKey: .aggrType)
        }
        if decoderContainer.contains(.endTime)
        {
            self.endTime = try decoderContainer.decode(String?.self, forKey: .endTime)
        }
        if decoderContainer.contains(.metricUID)
        {
            self.metricUID = try decoderContainer.decode([String?]?.self, forKey: .metricUID)
        }
        if decoderContainer.contains(.startTime)
        {
            self.startTime = try decoderContainer.decode(String?.self, forKey: .startTime)
        }
        if decoderContainer.contains(.timeInterval)
        {
            self.timeInterval = try decoderContainer.decode(String?.self, forKey: .timeInterval)
        }
    }
}
public extension DescribeCMMetricsDataSpec{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: DescribeCMMetricsDataSpecCodingKeys.self)
         try encoderContainer.encode(aggrType, forKey: .aggrType)
         try encoderContainer.encode(endTime, forKey: .endTime)
         try encoderContainer.encode(metricUID, forKey: .metricUID)
         try encoderContainer.encode(startTime, forKey: .startTime)
         try encoderContainer.encode(timeInterval, forKey: .timeInterval)
    }
}
///  cmAlarm
public class CmAlarm:NSObject,Codable{
    /// 统计方法：平均值&#x3D;avg、最大值&#x3D;max、最小值&#x3D;min
    var calculation:String?
    /// ContactGroups
    var contactGroups:[String?]?
    /// ContactPersons
    var contactPersons:[String?]?
    /// CreateTime
    var createTime:String?
    /// 启用禁用 1启用，0禁用
    var enabled:Int64?
    /// 规则id
    var id:String?
    /// 监控项
    var metric:String?
    /// 规则id监控项名称
    var metricName:String?
    /// 命名空间
    var namespace:String?
    /// 命名空间id
    var namespaceUID:String?
    /// 通知周期 单位：小时
    var noticePeriod:Int64?
    /// NoticeTime
    var noticeTime:String?
    /// 对象
    var obj:String?
    /// 对象id
    var objUID:String?
    /// &gt;&#x3D;、&gt;、&lt;、&lt;&#x3D;、&#x3D;、！&#x3D;
    var operation:String?
    /// 统计周期（单位：分钟）
    var period:Int64?
    /// 地域信息
    var region:String?
    /// 此规则所应用的资源id
    var resourceId:String?
    /// root rule id
    var rootRuleId:Int64?
    /// rule id
    var ruleId:Int64?
    /// 规则名称
    var ruleName:String?
    /// 报警规则对应的产品
    var serviceCode:String?
    /// 监控项状态:1正常，2告警，4数据不足
    var status:Int64?
    /// 监控项附属信息
    var tag:String?
    /// 阈值
    var threshold:Double?
    /// 连续多少次后报警
    var times:Int64?
    /// 报警值
    var value:Double?



    public override init(){
            super.init()
    }

    enum CmAlarmCodingKeys: String, CodingKey {
        case calculation
        case contactGroups
        case contactPersons
        case createTime
        case enabled
        case id
        case metric
        case metricName
        case namespace
        case namespaceUID
        case noticePeriod
        case noticeTime
        case obj
        case objUID
        case operation
        case period
        case region
        case resourceId
        case rootRuleId
        case ruleId
        case ruleName
        case serviceCode
        case status
        case tag
        case threshold
        case times
        case value
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: CmAlarmCodingKeys.self)
        if decoderContainer.contains(.calculation)
        {
            self.calculation = try decoderContainer.decode(String?.self, forKey: .calculation)
        }
        if decoderContainer.contains(.contactGroups)
        {
            self.contactGroups = try decoderContainer.decode([String?]?.self, forKey: .contactGroups)
        }
        if decoderContainer.contains(.contactPersons)
        {
            self.contactPersons = try decoderContainer.decode([String?]?.self, forKey: .contactPersons)
        }
        if decoderContainer.contains(.createTime)
        {
            self.createTime = try decoderContainer.decode(String?.self, forKey: .createTime)
        }
        if decoderContainer.contains(.enabled)
        {
            self.enabled = try decoderContainer.decode(Int64?.self, forKey: .enabled)
        }
        if decoderContainer.contains(.id)
        {
            self.id = try decoderContainer.decode(String?.self, forKey: .id)
        }
        if decoderContainer.contains(.metric)
        {
            self.metric = try decoderContainer.decode(String?.self, forKey: .metric)
        }
        if decoderContainer.contains(.metricName)
        {
            self.metricName = try decoderContainer.decode(String?.self, forKey: .metricName)
        }
        if decoderContainer.contains(.namespace)
        {
            self.namespace = try decoderContainer.decode(String?.self, forKey: .namespace)
        }
        if decoderContainer.contains(.namespaceUID)
        {
            self.namespaceUID = try decoderContainer.decode(String?.self, forKey: .namespaceUID)
        }
        if decoderContainer.contains(.noticePeriod)
        {
            self.noticePeriod = try decoderContainer.decode(Int64?.self, forKey: .noticePeriod)
        }
        if decoderContainer.contains(.noticeTime)
        {
            self.noticeTime = try decoderContainer.decode(String?.self, forKey: .noticeTime)
        }
        if decoderContainer.contains(.obj)
        {
            self.obj = try decoderContainer.decode(String?.self, forKey: .obj)
        }
        if decoderContainer.contains(.objUID)
        {
            self.objUID = try decoderContainer.decode(String?.self, forKey: .objUID)
        }
        if decoderContainer.contains(.operation)
        {
            self.operation = try decoderContainer.decode(String?.self, forKey: .operation)
        }
        if decoderContainer.contains(.period)
        {
            self.period = try decoderContainer.decode(Int64?.self, forKey: .period)
        }
        if decoderContainer.contains(.region)
        {
            self.region = try decoderContainer.decode(String?.self, forKey: .region)
        }
        if decoderContainer.contains(.resourceId)
        {
            self.resourceId = try decoderContainer.decode(String?.self, forKey: .resourceId)
        }
        if decoderContainer.contains(.rootRuleId)
        {
            self.rootRuleId = try decoderContainer.decode(Int64?.self, forKey: .rootRuleId)
        }
        if decoderContainer.contains(.ruleId)
        {
            self.ruleId = try decoderContainer.decode(Int64?.self, forKey: .ruleId)
        }
        if decoderContainer.contains(.ruleName)
        {
            self.ruleName = try decoderContainer.decode(String?.self, forKey: .ruleName)
        }
        if decoderContainer.contains(.serviceCode)
        {
            self.serviceCode = try decoderContainer.decode(String?.self, forKey: .serviceCode)
        }
        if decoderContainer.contains(.status)
        {
            self.status = try decoderContainer.decode(Int64?.self, forKey: .status)
        }
        if decoderContainer.contains(.tag)
        {
            self.tag = try decoderContainer.decode(String?.self, forKey: .tag)
        }
        if decoderContainer.contains(.threshold)
        {
            self.threshold = try decoderContainer.decode(Double?.self, forKey: .threshold)
        }
        if decoderContainer.contains(.times)
        {
            self.times = try decoderContainer.decode(Int64?.self, forKey: .times)
        }
        if decoderContainer.contains(.value)
        {
            self.value = try decoderContainer.decode(Double?.self, forKey: .value)
        }
    }
}
public extension CmAlarm{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: CmAlarmCodingKeys.self)
         try encoderContainer.encode(calculation, forKey: .calculation)
         try encoderContainer.encode(contactGroups, forKey: .contactGroups)
         try encoderContainer.encode(contactPersons, forKey: .contactPersons)
         try encoderContainer.encode(createTime, forKey: .createTime)
         try encoderContainer.encode(enabled, forKey: .enabled)
         try encoderContainer.encode(id, forKey: .id)
         try encoderContainer.encode(metric, forKey: .metric)
         try encoderContainer.encode(metricName, forKey: .metricName)
         try encoderContainer.encode(namespace, forKey: .namespace)
         try encoderContainer.encode(namespaceUID, forKey: .namespaceUID)
         try encoderContainer.encode(noticePeriod, forKey: .noticePeriod)
         try encoderContainer.encode(noticeTime, forKey: .noticeTime)
         try encoderContainer.encode(obj, forKey: .obj)
         try encoderContainer.encode(objUID, forKey: .objUID)
         try encoderContainer.encode(operation, forKey: .operation)
         try encoderContainer.encode(period, forKey: .period)
         try encoderContainer.encode(region, forKey: .region)
         try encoderContainer.encode(resourceId, forKey: .resourceId)
         try encoderContainer.encode(rootRuleId, forKey: .rootRuleId)
         try encoderContainer.encode(ruleId, forKey: .ruleId)
         try encoderContainer.encode(ruleName, forKey: .ruleName)
         try encoderContainer.encode(serviceCode, forKey: .serviceCode)
         try encoderContainer.encode(status, forKey: .status)
         try encoderContainer.encode(tag, forKey: .tag)
         try encoderContainer.encode(threshold, forKey: .threshold)
         try encoderContainer.encode(times, forKey: .times)
         try encoderContainer.encode(value, forKey: .value)
    }
}
///  createCmAlarmSpec
public class CreateCmAlarmSpec:NSObject,Codable{
    /// 幂等性校验参数,最长36位
    /// Required:true
    var clientToken:String
    /// CreateCmAlarmSpecValue
    /// Required:true
    var createCmAlarmSpecValue:CreateCmAlarmParam



    public  init(clientToken:String,createCmAlarmSpecValue:CreateCmAlarmParam){
             self.clientToken = clientToken
             self.createCmAlarmSpecValue = createCmAlarmSpecValue
    }

    enum CreateCmAlarmSpecCodingKeys: String, CodingKey {
        case clientToken
        case createCmAlarmSpecValue = "createCmAlarmSpec"
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: CreateCmAlarmSpecCodingKeys.self)
        self.clientToken = try decoderContainer.decode(String.self, forKey: .clientToken)
        self.createCmAlarmSpecValue = try decoderContainer.decode(CreateCmAlarmParam.self, forKey: .createCmAlarmSpecValue)
    }
}
public extension CreateCmAlarmSpec{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: CreateCmAlarmSpecCodingKeys.self)
         try encoderContainer.encode(clientToken, forKey: .clientToken)
         try encoderContainer.encode(createCmAlarmSpecValue, forKey: .createCmAlarmSpecValue)
    }
}
///  updateCmAlarmSpec
public class UpdateCmAlarmSpec:NSObject,Codable{
    /// 统计方法：平均值&#x3D;avg、最大值&#x3D;max、最小值&#x3D;min、总和&#x3D;sum
    /// Required:true
    var calculation:String
    /// 通知的联系组，如 [“联系组1”,”联系组2”]
    var contactGroups:[String?]?
    /// 通知的联系人，如 [“联系人1”,”联系人2”]
    var contactPersons:[String?]?
    /// 取样频次
    var downSample:String?
    /// 根据产品线查询可用监控项列表 接口 返回的Metric字段
    /// Required:true
    var metric:String
    /// 通知周期 单位：小时
    var noticePeriod:Int64?
    /// &gt;&#x3D;、&gt;、&lt;、&lt;&#x3D;、&#x3D;、！&#x3D;
    /// Required:true
    var operation:String
    /// 统计周期（单位：分钟）目前支持的取值：2，5，15，30，60
    /// Required:true
    var period:Int64
    /// 规则名称，最大长度42个字符，只允许中英文、数字、&#39;&#39;-&#39;&#39;和&quot;_&quot;
    var ruleName:String?
    /// 产品名称
    /// Required:true
    var serviceCode:String
    /// 阈值
    /// Required:true
    var threshold:Double
    /// 连续多少次后报警，可选值:1,2,3,5
    /// Required:true
    var times:Int64



    public  init(calculation:String,metric:String,operation:String,period:Int64,serviceCode:String,threshold:Double,times:Int64){
             self.calculation = calculation
             self.metric = metric
             self.operation = operation
             self.period = period
             self.serviceCode = serviceCode
             self.threshold = threshold
             self.times = times
    }

    enum UpdateCmAlarmSpecCodingKeys: String, CodingKey {
        case calculation
        case contactGroups
        case contactPersons
        case downSample
        case metric
        case noticePeriod
        case operation
        case period
        case ruleName
        case serviceCode
        case threshold
        case times
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: UpdateCmAlarmSpecCodingKeys.self)
        self.calculation = try decoderContainer.decode(String.self, forKey: .calculation)
        if decoderContainer.contains(.contactGroups)
        {
            self.contactGroups = try decoderContainer.decode([String?]?.self, forKey: .contactGroups)
        }
        if decoderContainer.contains(.contactPersons)
        {
            self.contactPersons = try decoderContainer.decode([String?]?.self, forKey: .contactPersons)
        }
        if decoderContainer.contains(.downSample)
        {
            self.downSample = try decoderContainer.decode(String?.self, forKey: .downSample)
        }
        self.metric = try decoderContainer.decode(String.self, forKey: .metric)
        if decoderContainer.contains(.noticePeriod)
        {
            self.noticePeriod = try decoderContainer.decode(Int64?.self, forKey: .noticePeriod)
        }
        self.operation = try decoderContainer.decode(String.self, forKey: .operation)
        self.period = try decoderContainer.decode(Int64.self, forKey: .period)
        if decoderContainer.contains(.ruleName)
        {
            self.ruleName = try decoderContainer.decode(String?.self, forKey: .ruleName)
        }
        self.serviceCode = try decoderContainer.decode(String.self, forKey: .serviceCode)
        self.threshold = try decoderContainer.decode(Double.self, forKey: .threshold)
        self.times = try decoderContainer.decode(Int64.self, forKey: .times)
    }
}
public extension UpdateCmAlarmSpec{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: UpdateCmAlarmSpecCodingKeys.self)
         try encoderContainer.encode(calculation, forKey: .calculation)
         try encoderContainer.encode(contactGroups, forKey: .contactGroups)
         try encoderContainer.encode(contactPersons, forKey: .contactPersons)
         try encoderContainer.encode(downSample, forKey: .downSample)
         try encoderContainer.encode(metric, forKey: .metric)
         try encoderContainer.encode(noticePeriod, forKey: .noticePeriod)
         try encoderContainer.encode(operation, forKey: .operation)
         try encoderContainer.encode(period, forKey: .period)
         try encoderContainer.encode(ruleName, forKey: .ruleName)
         try encoderContainer.encode(serviceCode, forKey: .serviceCode)
         try encoderContainer.encode(threshold, forKey: .threshold)
         try encoderContainer.encode(times, forKey: .times)
    }
}
///  metricDataItemCm
public class MetricDataItemCm:NSObject,Codable{
    /// Data
    var data:[DataPoint?]?
    /// Metric
    var metric:MetricCm?



    public override init(){
            super.init()
    }

    enum MetricDataItemCmCodingKeys: String, CodingKey {
        case data
        case metric
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: MetricDataItemCmCodingKeys.self)
        if decoderContainer.contains(.data)
        {
            self.data = try decoderContainer.decode([DataPoint?]?.self, forKey: .data)
        }
        if decoderContainer.contains(.metric)
        {
            self.metric = try decoderContainer.decode(MetricCm?.self, forKey: .metric)
        }
    }
}
public extension MetricDataItemCm{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: MetricDataItemCmCodingKeys.self)
         try encoderContainer.encode(data, forKey: .data)
         try encoderContainer.encode(metric, forKey: .metric)
    }
}
///  metricInfo
public class MetricInfo:NSObject,Codable{
    /// metric 单位
    var calculateUnit:String?
    /// metric名称
    var metricName:String?
    /// metric uid
    var metricUid:String?



    public override init(){
            super.init()
    }

    enum MetricInfoCodingKeys: String, CodingKey {
        case calculateUnit
        case metricName
        case metricUid
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: MetricInfoCodingKeys.self)
        if decoderContainer.contains(.calculateUnit)
        {
            self.calculateUnit = try decoderContainer.decode(String?.self, forKey: .calculateUnit)
        }
        if decoderContainer.contains(.metricName)
        {
            self.metricName = try decoderContainer.decode(String?.self, forKey: .metricName)
        }
        if decoderContainer.contains(.metricUid)
        {
            self.metricUid = try decoderContainer.decode(String?.self, forKey: .metricUid)
        }
    }
}
public extension MetricInfo{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: MetricInfoCodingKeys.self)
         try encoderContainer.encode(calculateUnit, forKey: .calculateUnit)
         try encoderContainer.encode(metricName, forKey: .metricName)
         try encoderContainer.encode(metricUid, forKey: .metricUid)
    }
}
///  cmAlarmHistory
public class CmAlarmHistory:NSObject,Codable{
    /// 统计方法：平均值&#x3D;avg、最大值&#x3D;max、最小值&#x3D;min
    var calculation:String?
    /// ContactGroups
    var contactGroups:[String?]?
    /// ContactPersons
    var contactPersons:[String?]?
    /// 该规则是否已经被删除，1表示已经被删除，0表示未删除，被删除的规则，在使用查询规则的接口时，将不会被检索到
    var deleted:Int64?
    /// 启用禁用 1启用，0禁用
    var enabled:Int64?
    /// 规则id
    var id:String?
    /// 监控项
    var metric:String?
    /// 规则id监控项名称
    var metricName:String?
    /// 命名空间
    var namespace:String?
    /// 命名空间id
    var namespaceUID:String?
    /// 通知周期 单位：小时
    var noticePeriod:Int64?
    /// NoticeTime
    var noticeTime:String?
    /// 对象
    var obj:String?
    /// 对象id
    var objUID:String?
    /// &gt;&#x3D;、&gt;、&lt;、&lt;&#x3D;、&#x3D;、！&#x3D;
    var operation:String?
    /// 统计周期（单位：分钟）
    var period:Int64?
    /// 地域信息
    var region:String?
    /// 此规则所应用的资源id
    var resourceId:String?
    /// root rule id
    var rootRuleId:Int64?
    /// rule id
    var ruleId:Int64?
    /// 规则名称
    var ruleName:String?
    /// 报警规则对应的产品
    var serviceCode:String?
    /// 监控项附属信息
    var tag:String?
    /// 阈值
    var threshold:Double?
    /// 连续多少次后报警
    var times:Int64?
    /// 报警值
    var value:Double?



    public override init(){
            super.init()
    }

    enum CmAlarmHistoryCodingKeys: String, CodingKey {
        case calculation
        case contactGroups
        case contactPersons
        case deleted
        case enabled
        case id
        case metric
        case metricName
        case namespace
        case namespaceUID
        case noticePeriod
        case noticeTime
        case obj
        case objUID
        case operation
        case period
        case region
        case resourceId
        case rootRuleId
        case ruleId
        case ruleName
        case serviceCode
        case tag
        case threshold
        case times
        case value
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: CmAlarmHistoryCodingKeys.self)
        if decoderContainer.contains(.calculation)
        {
            self.calculation = try decoderContainer.decode(String?.self, forKey: .calculation)
        }
        if decoderContainer.contains(.contactGroups)
        {
            self.contactGroups = try decoderContainer.decode([String?]?.self, forKey: .contactGroups)
        }
        if decoderContainer.contains(.contactPersons)
        {
            self.contactPersons = try decoderContainer.decode([String?]?.self, forKey: .contactPersons)
        }
        if decoderContainer.contains(.deleted)
        {
            self.deleted = try decoderContainer.decode(Int64?.self, forKey: .deleted)
        }
        if decoderContainer.contains(.enabled)
        {
            self.enabled = try decoderContainer.decode(Int64?.self, forKey: .enabled)
        }
        if decoderContainer.contains(.id)
        {
            self.id = try decoderContainer.decode(String?.self, forKey: .id)
        }
        if decoderContainer.contains(.metric)
        {
            self.metric = try decoderContainer.decode(String?.self, forKey: .metric)
        }
        if decoderContainer.contains(.metricName)
        {
            self.metricName = try decoderContainer.decode(String?.self, forKey: .metricName)
        }
        if decoderContainer.contains(.namespace)
        {
            self.namespace = try decoderContainer.decode(String?.self, forKey: .namespace)
        }
        if decoderContainer.contains(.namespaceUID)
        {
            self.namespaceUID = try decoderContainer.decode(String?.self, forKey: .namespaceUID)
        }
        if decoderContainer.contains(.noticePeriod)
        {
            self.noticePeriod = try decoderContainer.decode(Int64?.self, forKey: .noticePeriod)
        }
        if decoderContainer.contains(.noticeTime)
        {
            self.noticeTime = try decoderContainer.decode(String?.self, forKey: .noticeTime)
        }
        if decoderContainer.contains(.obj)
        {
            self.obj = try decoderContainer.decode(String?.self, forKey: .obj)
        }
        if decoderContainer.contains(.objUID)
        {
            self.objUID = try decoderContainer.decode(String?.self, forKey: .objUID)
        }
        if decoderContainer.contains(.operation)
        {
            self.operation = try decoderContainer.decode(String?.self, forKey: .operation)
        }
        if decoderContainer.contains(.period)
        {
            self.period = try decoderContainer.decode(Int64?.self, forKey: .period)
        }
        if decoderContainer.contains(.region)
        {
            self.region = try decoderContainer.decode(String?.self, forKey: .region)
        }
        if decoderContainer.contains(.resourceId)
        {
            self.resourceId = try decoderContainer.decode(String?.self, forKey: .resourceId)
        }
        if decoderContainer.contains(.rootRuleId)
        {
            self.rootRuleId = try decoderContainer.decode(Int64?.self, forKey: .rootRuleId)
        }
        if decoderContainer.contains(.ruleId)
        {
            self.ruleId = try decoderContainer.decode(Int64?.self, forKey: .ruleId)
        }
        if decoderContainer.contains(.ruleName)
        {
            self.ruleName = try decoderContainer.decode(String?.self, forKey: .ruleName)
        }
        if decoderContainer.contains(.serviceCode)
        {
            self.serviceCode = try decoderContainer.decode(String?.self, forKey: .serviceCode)
        }
        if decoderContainer.contains(.tag)
        {
            self.tag = try decoderContainer.decode(String?.self, forKey: .tag)
        }
        if decoderContainer.contains(.threshold)
        {
            self.threshold = try decoderContainer.decode(Double?.self, forKey: .threshold)
        }
        if decoderContainer.contains(.times)
        {
            self.times = try decoderContainer.decode(Int64?.self, forKey: .times)
        }
        if decoderContainer.contains(.value)
        {
            self.value = try decoderContainer.decode(Double?.self, forKey: .value)
        }
    }
}
public extension CmAlarmHistory{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: CmAlarmHistoryCodingKeys.self)
         try encoderContainer.encode(calculation, forKey: .calculation)
         try encoderContainer.encode(contactGroups, forKey: .contactGroups)
         try encoderContainer.encode(contactPersons, forKey: .contactPersons)
         try encoderContainer.encode(deleted, forKey: .deleted)
         try encoderContainer.encode(enabled, forKey: .enabled)
         try encoderContainer.encode(id, forKey: .id)
         try encoderContainer.encode(metric, forKey: .metric)
         try encoderContainer.encode(metricName, forKey: .metricName)
         try encoderContainer.encode(namespace, forKey: .namespace)
         try encoderContainer.encode(namespaceUID, forKey: .namespaceUID)
         try encoderContainer.encode(noticePeriod, forKey: .noticePeriod)
         try encoderContainer.encode(noticeTime, forKey: .noticeTime)
         try encoderContainer.encode(obj, forKey: .obj)
         try encoderContainer.encode(objUID, forKey: .objUID)
         try encoderContainer.encode(operation, forKey: .operation)
         try encoderContainer.encode(period, forKey: .period)
         try encoderContainer.encode(region, forKey: .region)
         try encoderContainer.encode(resourceId, forKey: .resourceId)
         try encoderContainer.encode(rootRuleId, forKey: .rootRuleId)
         try encoderContainer.encode(ruleId, forKey: .ruleId)
         try encoderContainer.encode(ruleName, forKey: .ruleName)
         try encoderContainer.encode(serviceCode, forKey: .serviceCode)
         try encoderContainer.encode(tag, forKey: .tag)
         try encoderContainer.encode(threshold, forKey: .threshold)
         try encoderContainer.encode(times, forKey: .times)
         try encoderContainer.encode(value, forKey: .value)
    }
}
///  metricCm
public class MetricCm:NSObject,Codable{
    /// AggrPeriod
    var aggrPeriod:String?
    /// AggrType
    var aggrType:String?
    /// CalculateUnit
    var calculateUnit:String?
    /// DownSampleType
    var downSampleType:String?
    /// Metric
    var metric:String?
    /// MetricName
    var metricName:String?
    /// MetricUID
    var metricUID:String?
    /// Tags
    var tags:[String:String?]?



    public override init(){
            super.init()
    }

    enum MetricCmCodingKeys: String, CodingKey {
        case aggrPeriod
        case aggrType
        case calculateUnit
        case downSampleType
        case metric
        case metricName
        case metricUID
        case tags
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: MetricCmCodingKeys.self)
        if decoderContainer.contains(.aggrPeriod)
        {
            self.aggrPeriod = try decoderContainer.decode(String?.self, forKey: .aggrPeriod)
        }
        if decoderContainer.contains(.aggrType)
        {
            self.aggrType = try decoderContainer.decode(String?.self, forKey: .aggrType)
        }
        if decoderContainer.contains(.calculateUnit)
        {
            self.calculateUnit = try decoderContainer.decode(String?.self, forKey: .calculateUnit)
        }
        if decoderContainer.contains(.downSampleType)
        {
            self.downSampleType = try decoderContainer.decode(String?.self, forKey: .downSampleType)
        }
        if decoderContainer.contains(.metric)
        {
            self.metric = try decoderContainer.decode(String?.self, forKey: .metric)
        }
        if decoderContainer.contains(.metricName)
        {
            self.metricName = try decoderContainer.decode(String?.self, forKey: .metricName)
        }
        if decoderContainer.contains(.metricUID)
        {
            self.metricUID = try decoderContainer.decode(String?.self, forKey: .metricUID)
        }
        if decoderContainer.contains(.tags)
        {
            self.tags = try decoderContainer.decode([String:String?]?.self, forKey: .tags)
        }
    }
}
public extension MetricCm{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: MetricCmCodingKeys.self)
         try encoderContainer.encode(aggrPeriod, forKey: .aggrPeriod)
         try encoderContainer.encode(aggrType, forKey: .aggrType)
         try encoderContainer.encode(calculateUnit, forKey: .calculateUnit)
         try encoderContainer.encode(downSampleType, forKey: .downSampleType)
         try encoderContainer.encode(metric, forKey: .metric)
         try encoderContainer.encode(metricName, forKey: .metricName)
         try encoderContainer.encode(metricUID, forKey: .metricUID)
         try encoderContainer.encode(tags, forKey: .tags)
    }
}
///  maintainAuxiliaryTags
public class MaintainAuxiliaryTags:NSObject,Codable{
    /// 应用码。调用此API前需找云监控提供
    /// Required:true
    var appCode:String
    /// 详细的过滤条件。
    var filter:[DataTag?]?
    /// 组id。须确保在一个APP范围内全局唯一
    /// Required:true
    var groupCode:String
    /// 资源列表。
    /// Required:true
    var resourceIds:[String?]?
    /// 资源的产品线，要对哪个产品线的资源打标签
    /// Required:true
    var serviceCode:String
    /// 打标签操作所属产品线的serviceCode
    /// Required:true
    var srcServiceCode:String
    /// Tags
    /// Required:true
    var tags:HandleTags



    public  init(appCode:String,groupCode:String,resourceIds:[String?]?,serviceCode:String,srcServiceCode:String,tags:HandleTags){
             self.appCode = appCode
             self.groupCode = groupCode
             self.resourceIds = resourceIds
             self.serviceCode = serviceCode
             self.srcServiceCode = srcServiceCode
             self.tags = tags
    }

    enum MaintainAuxiliaryTagsCodingKeys: String, CodingKey {
        case appCode
        case filter
        case groupCode
        case resourceIds
        case serviceCode
        case srcServiceCode
        case tags
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: MaintainAuxiliaryTagsCodingKeys.self)
        self.appCode = try decoderContainer.decode(String.self, forKey: .appCode)
        if decoderContainer.contains(.filter)
        {
            self.filter = try decoderContainer.decode([DataTag?]?.self, forKey: .filter)
        }
        self.groupCode = try decoderContainer.decode(String.self, forKey: .groupCode)
        self.resourceIds = try decoderContainer.decode([String?]?.self, forKey: .resourceIds)
        self.serviceCode = try decoderContainer.decode(String.self, forKey: .serviceCode)
        self.srcServiceCode = try decoderContainer.decode(String.self, forKey: .srcServiceCode)
        self.tags = try decoderContainer.decode(HandleTags.self, forKey: .tags)
    }
}
public extension MaintainAuxiliaryTags{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: MaintainAuxiliaryTagsCodingKeys.self)
         try encoderContainer.encode(appCode, forKey: .appCode)
         try encoderContainer.encode(filter, forKey: .filter)
         try encoderContainer.encode(groupCode, forKey: .groupCode)
         try encoderContainer.encode(resourceIds, forKey: .resourceIds)
         try encoderContainer.encode(serviceCode, forKey: .serviceCode)
         try encoderContainer.encode(srcServiceCode, forKey: .srcServiceCode)
         try encoderContainer.encode(tags, forKey: .tags)
    }
}
///  dataTag
public class DataTag:NSObject,Codable{
    /// Operation
    var operation:Int64?
    /// TagKey
    var tagKey:String?
    /// TagValue
    var tagValue:String?



    public override init(){
            super.init()
    }

    enum DataTagCodingKeys: String, CodingKey {
        case operation
        case tagKey
        case tagValue
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: DataTagCodingKeys.self)
        if decoderContainer.contains(.operation)
        {
            self.operation = try decoderContainer.decode(Int64?.self, forKey: .operation)
        }
        if decoderContainer.contains(.tagKey)
        {
            self.tagKey = try decoderContainer.decode(String?.self, forKey: .tagKey)
        }
        if decoderContainer.contains(.tagValue)
        {
            self.tagValue = try decoderContainer.decode(String?.self, forKey: .tagValue)
        }
    }
}
public extension DataTag{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: DataTagCodingKeys.self)
         try encoderContainer.encode(operation, forKey: .operation)
         try encoderContainer.encode(tagKey, forKey: .tagKey)
         try encoderContainer.encode(tagValue, forKey: .tagValue)
    }
}
///  handleTags
public class HandleTags:NSObject,Codable{
    /// HandleTagCode
    var handleTagCode:Int64?
    /// PrefixMetric
    var prefixMetric:String?



    public override init(){
            super.init()
    }

    enum HandleTagsCodingKeys: String, CodingKey {
        case handleTagCode
        case prefixMetric
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: HandleTagsCodingKeys.self)
        if decoderContainer.contains(.handleTagCode)
        {
            self.handleTagCode = try decoderContainer.decode(Int64?.self, forKey: .handleTagCode)
        }
        if decoderContainer.contains(.prefixMetric)
        {
            self.prefixMetric = try decoderContainer.decode(String?.self, forKey: .prefixMetric)
        }
    }
}
public extension HandleTags{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: HandleTagsCodingKeys.self)
         try encoderContainer.encode(handleTagCode, forKey: .handleTagCode)
         try encoderContainer.encode(prefixMetric, forKey: .prefixMetric)
    }
}
///  updateWidgetSpec
public class UpdateWidgetSpec:NSObject,Codable{
    /// Aggregated
    var aggregated:String?
    /// CreatedTime
    var createdTime:Int64?
    /// DashboardId
    var dashboardId:String?
    /// Metrics
    var metrics:[WidgetMetric?]?
    /// Name
    var name:String?
    /// Position
    var position:WidgetPosition?
    /// Resources
    var resources:WidgetResources?
    /// ServiceCode
    var serviceCode:String?
    /// TopN
    var topN:Int?
    /// Type
    var type:String?
    /// UpdatedTime
    var updatedTime:Int64?
    /// WidgetId
    var widgetId:String?



    public override init(){
            super.init()
    }

    enum UpdateWidgetSpecCodingKeys: String, CodingKey {
        case aggregated
        case createdTime
        case dashboardId
        case metrics
        case name
        case position
        case resources
        case serviceCode
        case topN
        case type
        case updatedTime
        case widgetId
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: UpdateWidgetSpecCodingKeys.self)
        if decoderContainer.contains(.aggregated)
        {
            self.aggregated = try decoderContainer.decode(String?.self, forKey: .aggregated)
        }
        if decoderContainer.contains(.createdTime)
        {
            self.createdTime = try decoderContainer.decode(Int64?.self, forKey: .createdTime)
        }
        if decoderContainer.contains(.dashboardId)
        {
            self.dashboardId = try decoderContainer.decode(String?.self, forKey: .dashboardId)
        }
        if decoderContainer.contains(.metrics)
        {
            self.metrics = try decoderContainer.decode([WidgetMetric?]?.self, forKey: .metrics)
        }
        if decoderContainer.contains(.name)
        {
            self.name = try decoderContainer.decode(String?.self, forKey: .name)
        }
        if decoderContainer.contains(.position)
        {
            self.position = try decoderContainer.decode(WidgetPosition?.self, forKey: .position)
        }
        if decoderContainer.contains(.resources)
        {
            self.resources = try decoderContainer.decode(WidgetResources?.self, forKey: .resources)
        }
        if decoderContainer.contains(.serviceCode)
        {
            self.serviceCode = try decoderContainer.decode(String?.self, forKey: .serviceCode)
        }
        if decoderContainer.contains(.topN)
        {
            self.topN = try decoderContainer.decode(Int?.self, forKey: .topN)
        }
        if decoderContainer.contains(.type)
        {
            self.type = try decoderContainer.decode(String?.self, forKey: .type)
        }
        if decoderContainer.contains(.updatedTime)
        {
            self.updatedTime = try decoderContainer.decode(Int64?.self, forKey: .updatedTime)
        }
        if decoderContainer.contains(.widgetId)
        {
            self.widgetId = try decoderContainer.decode(String?.self, forKey: .widgetId)
        }
    }
}
public extension UpdateWidgetSpec{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: UpdateWidgetSpecCodingKeys.self)
         try encoderContainer.encode(aggregated, forKey: .aggregated)
         try encoderContainer.encode(createdTime, forKey: .createdTime)
         try encoderContainer.encode(dashboardId, forKey: .dashboardId)
         try encoderContainer.encode(metrics, forKey: .metrics)
         try encoderContainer.encode(name, forKey: .name)
         try encoderContainer.encode(position, forKey: .position)
         try encoderContainer.encode(resources, forKey: .resources)
         try encoderContainer.encode(serviceCode, forKey: .serviceCode)
         try encoderContainer.encode(topN, forKey: .topN)
         try encoderContainer.encode(type, forKey: .type)
         try encoderContainer.encode(updatedTime, forKey: .updatedTime)
         try encoderContainer.encode(widgetId, forKey: .widgetId)
    }
}
///  createWidgetSpec
public class CreateWidgetSpec:NSObject,Codable{
    /// Aggregated
    var aggregated:String?
    /// CreatedTime
    var createdTime:Int64?
    /// DashboardId
    var dashboardId:String?
    /// Metrics
    var metrics:[WidgetMetric?]?
    /// Name
    var name:String?
    /// Position
    var position:WidgetPosition?
    /// Resources
    var resources:WidgetResources?
    /// ServiceCode
    var serviceCode:String?
    /// TopN
    var topN:Int?
    /// Type
    var type:String?
    /// UpdatedTime
    var updatedTime:Int64?
    /// WidgetId
    var widgetId:String?



    public override init(){
            super.init()
    }

    enum CreateWidgetSpecCodingKeys: String, CodingKey {
        case aggregated
        case createdTime
        case dashboardId
        case metrics
        case name
        case position
        case resources
        case serviceCode
        case topN
        case type
        case updatedTime
        case widgetId
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: CreateWidgetSpecCodingKeys.self)
        if decoderContainer.contains(.aggregated)
        {
            self.aggregated = try decoderContainer.decode(String?.self, forKey: .aggregated)
        }
        if decoderContainer.contains(.createdTime)
        {
            self.createdTime = try decoderContainer.decode(Int64?.self, forKey: .createdTime)
        }
        if decoderContainer.contains(.dashboardId)
        {
            self.dashboardId = try decoderContainer.decode(String?.self, forKey: .dashboardId)
        }
        if decoderContainer.contains(.metrics)
        {
            self.metrics = try decoderContainer.decode([WidgetMetric?]?.self, forKey: .metrics)
        }
        if decoderContainer.contains(.name)
        {
            self.name = try decoderContainer.decode(String?.self, forKey: .name)
        }
        if decoderContainer.contains(.position)
        {
            self.position = try decoderContainer.decode(WidgetPosition?.self, forKey: .position)
        }
        if decoderContainer.contains(.resources)
        {
            self.resources = try decoderContainer.decode(WidgetResources?.self, forKey: .resources)
        }
        if decoderContainer.contains(.serviceCode)
        {
            self.serviceCode = try decoderContainer.decode(String?.self, forKey: .serviceCode)
        }
        if decoderContainer.contains(.topN)
        {
            self.topN = try decoderContainer.decode(Int?.self, forKey: .topN)
        }
        if decoderContainer.contains(.type)
        {
            self.type = try decoderContainer.decode(String?.self, forKey: .type)
        }
        if decoderContainer.contains(.updatedTime)
        {
            self.updatedTime = try decoderContainer.decode(Int64?.self, forKey: .updatedTime)
        }
        if decoderContainer.contains(.widgetId)
        {
            self.widgetId = try decoderContainer.decode(String?.self, forKey: .widgetId)
        }
    }
}
public extension CreateWidgetSpec{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: CreateWidgetSpecCodingKeys.self)
         try encoderContainer.encode(aggregated, forKey: .aggregated)
         try encoderContainer.encode(createdTime, forKey: .createdTime)
         try encoderContainer.encode(dashboardId, forKey: .dashboardId)
         try encoderContainer.encode(metrics, forKey: .metrics)
         try encoderContainer.encode(name, forKey: .name)
         try encoderContainer.encode(position, forKey: .position)
         try encoderContainer.encode(resources, forKey: .resources)
         try encoderContainer.encode(serviceCode, forKey: .serviceCode)
         try encoderContainer.encode(topN, forKey: .topN)
         try encoderContainer.encode(type, forKey: .type)
         try encoderContainer.encode(updatedTime, forKey: .updatedTime)
         try encoderContainer.encode(widgetId, forKey: .widgetId)
    }
}
///  getWidgetDataPointsSpec
public class GetWidgetDataPointsSpec:NSObject,Codable{
    /// Aggregated
    var aggregated:String?
    /// CreatedTime
    var createdTime:Int64?
    /// DashboardId
    var dashboardId:String?
    /// EndTime
    var endTime:String?
    /// name为widgetId - 多个图表的id
    var filters:[Filter?]?
    /// Metrics
    var metrics:[WidgetMetric?]?
    /// Name
    var name:String?
    /// Position
    var position:WidgetPosition?
    /// Resources
    var resources:WidgetResources?
    /// ServiceCode
    var serviceCode:String?
    /// StartTime
    var startTime:String?
    /// TopN
    var topN:Int?
    /// Type
    var type:String?
    /// UpdatedTime
    var updatedTime:Int64?
    /// WidgetId
    var widgetId:[String?]?



    public override init(){
            super.init()
    }

    enum GetWidgetDataPointsSpecCodingKeys: String, CodingKey {
        case aggregated
        case createdTime
        case dashboardId
        case endTime
        case filters
        case metrics
        case name
        case position
        case resources
        case serviceCode
        case startTime
        case topN
        case type
        case updatedTime
        case widgetId
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: GetWidgetDataPointsSpecCodingKeys.self)
        if decoderContainer.contains(.aggregated)
        {
            self.aggregated = try decoderContainer.decode(String?.self, forKey: .aggregated)
        }
        if decoderContainer.contains(.createdTime)
        {
            self.createdTime = try decoderContainer.decode(Int64?.self, forKey: .createdTime)
        }
        if decoderContainer.contains(.dashboardId)
        {
            self.dashboardId = try decoderContainer.decode(String?.self, forKey: .dashboardId)
        }
        if decoderContainer.contains(.endTime)
        {
            self.endTime = try decoderContainer.decode(String?.self, forKey: .endTime)
        }
        if decoderContainer.contains(.filters)
        {
            self.filters = try decoderContainer.decode([Filter?]?.self, forKey: .filters)
        }
        if decoderContainer.contains(.metrics)
        {
            self.metrics = try decoderContainer.decode([WidgetMetric?]?.self, forKey: .metrics)
        }
        if decoderContainer.contains(.name)
        {
            self.name = try decoderContainer.decode(String?.self, forKey: .name)
        }
        if decoderContainer.contains(.position)
        {
            self.position = try decoderContainer.decode(WidgetPosition?.self, forKey: .position)
        }
        if decoderContainer.contains(.resources)
        {
            self.resources = try decoderContainer.decode(WidgetResources?.self, forKey: .resources)
        }
        if decoderContainer.contains(.serviceCode)
        {
            self.serviceCode = try decoderContainer.decode(String?.self, forKey: .serviceCode)
        }
        if decoderContainer.contains(.startTime)
        {
            self.startTime = try decoderContainer.decode(String?.self, forKey: .startTime)
        }
        if decoderContainer.contains(.topN)
        {
            self.topN = try decoderContainer.decode(Int?.self, forKey: .topN)
        }
        if decoderContainer.contains(.type)
        {
            self.type = try decoderContainer.decode(String?.self, forKey: .type)
        }
        if decoderContainer.contains(.updatedTime)
        {
            self.updatedTime = try decoderContainer.decode(Int64?.self, forKey: .updatedTime)
        }
        if decoderContainer.contains(.widgetId)
        {
            self.widgetId = try decoderContainer.decode([String?]?.self, forKey: .widgetId)
        }
    }
}
public extension GetWidgetDataPointsSpec{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: GetWidgetDataPointsSpecCodingKeys.self)
         try encoderContainer.encode(aggregated, forKey: .aggregated)
         try encoderContainer.encode(createdTime, forKey: .createdTime)
         try encoderContainer.encode(dashboardId, forKey: .dashboardId)
         try encoderContainer.encode(endTime, forKey: .endTime)
         try encoderContainer.encode(filters, forKey: .filters)
         try encoderContainer.encode(metrics, forKey: .metrics)
         try encoderContainer.encode(name, forKey: .name)
         try encoderContainer.encode(position, forKey: .position)
         try encoderContainer.encode(resources, forKey: .resources)
         try encoderContainer.encode(serviceCode, forKey: .serviceCode)
         try encoderContainer.encode(startTime, forKey: .startTime)
         try encoderContainer.encode(topN, forKey: .topN)
         try encoderContainer.encode(type, forKey: .type)
         try encoderContainer.encode(updatedTime, forKey: .updatedTime)
         try encoderContainer.encode(widgetId, forKey: .widgetId)
    }
}
///  widgetTagResource
public class WidgetTagResource:NSObject,Codable{
    /// Id
    var id:String?
    /// Key
    var key:String?
    /// RegionId
    var regionId:String?
    /// Value
    var value:String?



    public override init(){
            super.init()
    }

    enum WidgetTagResourceCodingKeys: String, CodingKey {
        case id
        case key
        case regionId
        case value
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: WidgetTagResourceCodingKeys.self)
        if decoderContainer.contains(.id)
        {
            self.id = try decoderContainer.decode(String?.self, forKey: .id)
        }
        if decoderContainer.contains(.key)
        {
            self.key = try decoderContainer.decode(String?.self, forKey: .key)
        }
        if decoderContainer.contains(.regionId)
        {
            self.regionId = try decoderContainer.decode(String?.self, forKey: .regionId)
        }
        if decoderContainer.contains(.value)
        {
            self.value = try decoderContainer.decode(String?.self, forKey: .value)
        }
    }
}
public extension WidgetTagResource{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: WidgetTagResourceCodingKeys.self)
         try encoderContainer.encode(id, forKey: .id)
         try encoderContainer.encode(key, forKey: .key)
         try encoderContainer.encode(regionId, forKey: .regionId)
         try encoderContainer.encode(value, forKey: .value)
    }
}
///  updateDashboardSpec
public class UpdateDashboardSpec:NSObject,Codable{
    /// DashboardId
    var dashboardId:String?
    /// Focused
    var focused:String?
    /// Name
    var name:String?



    public override init(){
            super.init()
    }

    enum UpdateDashboardSpecCodingKeys: String, CodingKey {
        case dashboardId
        case focused
        case name
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: UpdateDashboardSpecCodingKeys.self)
        if decoderContainer.contains(.dashboardId)
        {
            self.dashboardId = try decoderContainer.decode(String?.self, forKey: .dashboardId)
        }
        if decoderContainer.contains(.focused)
        {
            self.focused = try decoderContainer.decode(String?.self, forKey: .focused)
        }
        if decoderContainer.contains(.name)
        {
            self.name = try decoderContainer.decode(String?.self, forKey: .name)
        }
    }
}
public extension UpdateDashboardSpec{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: UpdateDashboardSpecCodingKeys.self)
         try encoderContainer.encode(dashboardId, forKey: .dashboardId)
         try encoderContainer.encode(focused, forKey: .focused)
         try encoderContainer.encode(name, forKey: .name)
    }
}
///  dashboard
public class Dashboard:NSObject,Codable{
    /// CreatedTime
    var createdTime:Int64?
    /// DashboardId
    var dashboardId:String?
    /// Focused
    var focused:String?
    /// Name
    var name:String?
    /// Pin
    var pin:String?
    /// UpdatedTime
    var updatedTime:Int64?
    /// WidgetCount
    var widgetCount:Int64?



    public override init(){
            super.init()
    }

    enum DashboardCodingKeys: String, CodingKey {
        case createdTime
        case dashboardId
        case focused
        case name
        case pin
        case updatedTime
        case widgetCount
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: DashboardCodingKeys.self)
        if decoderContainer.contains(.createdTime)
        {
            self.createdTime = try decoderContainer.decode(Int64?.self, forKey: .createdTime)
        }
        if decoderContainer.contains(.dashboardId)
        {
            self.dashboardId = try decoderContainer.decode(String?.self, forKey: .dashboardId)
        }
        if decoderContainer.contains(.focused)
        {
            self.focused = try decoderContainer.decode(String?.self, forKey: .focused)
        }
        if decoderContainer.contains(.name)
        {
            self.name = try decoderContainer.decode(String?.self, forKey: .name)
        }
        if decoderContainer.contains(.pin)
        {
            self.pin = try decoderContainer.decode(String?.self, forKey: .pin)
        }
        if decoderContainer.contains(.updatedTime)
        {
            self.updatedTime = try decoderContainer.decode(Int64?.self, forKey: .updatedTime)
        }
        if decoderContainer.contains(.widgetCount)
        {
            self.widgetCount = try decoderContainer.decode(Int64?.self, forKey: .widgetCount)
        }
    }
}
public extension Dashboard{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: DashboardCodingKeys.self)
         try encoderContainer.encode(createdTime, forKey: .createdTime)
         try encoderContainer.encode(dashboardId, forKey: .dashboardId)
         try encoderContainer.encode(focused, forKey: .focused)
         try encoderContainer.encode(name, forKey: .name)
         try encoderContainer.encode(pin, forKey: .pin)
         try encoderContainer.encode(updatedTime, forKey: .updatedTime)
         try encoderContainer.encode(widgetCount, forKey: .widgetCount)
    }
}
///  widgetResources
public class WidgetResources:NSObject,Codable{
    /// Raw
    var raw:[WidgetRawResource?]?
    /// Tag
    var tag:[WidgetTagResource?]?



    public override init(){
            super.init()
    }

    enum WidgetResourcesCodingKeys: String, CodingKey {
        case raw
        case tag
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: WidgetResourcesCodingKeys.self)
        if decoderContainer.contains(.raw)
        {
            self.raw = try decoderContainer.decode([WidgetRawResource?]?.self, forKey: .raw)
        }
        if decoderContainer.contains(.tag)
        {
            self.tag = try decoderContainer.decode([WidgetTagResource?]?.self, forKey: .tag)
        }
    }
}
public extension WidgetResources{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: WidgetResourcesCodingKeys.self)
         try encoderContainer.encode(raw, forKey: .raw)
         try encoderContainer.encode(tag, forKey: .tag)
    }
}
///  widgetDataPointItem
public class WidgetDataPointItem:NSObject,Codable{
    /// Aggregate
    var aggregate:[StatsItem?]?
    /// Detail
    var detail:[StatsItem?]?
    /// WidgetId
    var widgetId:String?



    public override init(){
            super.init()
    }

    enum WidgetDataPointItemCodingKeys: String, CodingKey {
        case aggregate
        case detail
        case widgetId
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: WidgetDataPointItemCodingKeys.self)
        if decoderContainer.contains(.aggregate)
        {
            self.aggregate = try decoderContainer.decode([StatsItem?]?.self, forKey: .aggregate)
        }
        if decoderContainer.contains(.detail)
        {
            self.detail = try decoderContainer.decode([StatsItem?]?.self, forKey: .detail)
        }
        if decoderContainer.contains(.widgetId)
        {
            self.widgetId = try decoderContainer.decode(String?.self, forKey: .widgetId)
        }
    }
}
public extension WidgetDataPointItem{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: WidgetDataPointItemCodingKeys.self)
         try encoderContainer.encode(aggregate, forKey: .aggregate)
         try encoderContainer.encode(detail, forKey: .detail)
         try encoderContainer.encode(widgetId, forKey: .widgetId)
    }
}
///  batchUpdateWidgetSpec
public class BatchUpdateWidgetSpec:NSObject,Codable{
    /// List
    var list:[Widget?]?



    public override init(){
            super.init()
    }

    enum BatchUpdateWidgetSpecCodingKeys: String, CodingKey {
        case list
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: BatchUpdateWidgetSpecCodingKeys.self)
        if decoderContainer.contains(.list)
        {
            self.list = try decoderContainer.decode([Widget?]?.self, forKey: .list)
        }
    }
}
public extension BatchUpdateWidgetSpec{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: BatchUpdateWidgetSpecCodingKeys.self)
         try encoderContainer.encode(list, forKey: .list)
    }
}
///  batchUpdateWidgetError
public class BatchUpdateWidgetError:NSObject,Codable{
    /// DashboardId
    var dashboardId:String?
    /// Error
    var error:String?
    /// WidgetId
    var widgetId:String?



    public override init(){
            super.init()
    }

    enum BatchUpdateWidgetErrorCodingKeys: String, CodingKey {
        case dashboardId
        case error
        case widgetId
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: BatchUpdateWidgetErrorCodingKeys.self)
        if decoderContainer.contains(.dashboardId)
        {
            self.dashboardId = try decoderContainer.decode(String?.self, forKey: .dashboardId)
        }
        if decoderContainer.contains(.error)
        {
            self.error = try decoderContainer.decode(String?.self, forKey: .error)
        }
        if decoderContainer.contains(.widgetId)
        {
            self.widgetId = try decoderContainer.decode(String?.self, forKey: .widgetId)
        }
    }
}
public extension BatchUpdateWidgetError{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: BatchUpdateWidgetErrorCodingKeys.self)
         try encoderContainer.encode(dashboardId, forKey: .dashboardId)
         try encoderContainer.encode(error, forKey: .error)
         try encoderContainer.encode(widgetId, forKey: .widgetId)
    }
}
///  createDashboardSpec
public class CreateDashboardSpec:NSObject,Codable{
    /// Name
    var name:String?



    public override init(){
            super.init()
    }

    enum CreateDashboardSpecCodingKeys: String, CodingKey {
        case name
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: CreateDashboardSpecCodingKeys.self)
        if decoderContainer.contains(.name)
        {
            self.name = try decoderContainer.decode(String?.self, forKey: .name)
        }
    }
}
public extension CreateDashboardSpec{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: CreateDashboardSpecCodingKeys.self)
         try encoderContainer.encode(name, forKey: .name)
    }
}
///  widgetRawResource
public class WidgetRawResource:NSObject,Codable{
    /// Name
    var name:String?
    /// RegionId
    var regionId:String?
    /// ResourceId
    var resourceId:String?
    /// Tag
    var tag:[String:String?]?



    public override init(){
            super.init()
    }

    enum WidgetRawResourceCodingKeys: String, CodingKey {
        case name
        case regionId
        case resourceId
        case tag
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: WidgetRawResourceCodingKeys.self)
        if decoderContainer.contains(.name)
        {
            self.name = try decoderContainer.decode(String?.self, forKey: .name)
        }
        if decoderContainer.contains(.regionId)
        {
            self.regionId = try decoderContainer.decode(String?.self, forKey: .regionId)
        }
        if decoderContainer.contains(.resourceId)
        {
            self.resourceId = try decoderContainer.decode(String?.self, forKey: .resourceId)
        }
        if decoderContainer.contains(.tag)
        {
            self.tag = try decoderContainer.decode([String:String?]?.self, forKey: .tag)
        }
    }
}
public extension WidgetRawResource{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: WidgetRawResourceCodingKeys.self)
         try encoderContainer.encode(name, forKey: .name)
         try encoderContainer.encode(regionId, forKey: .regionId)
         try encoderContainer.encode(resourceId, forKey: .resourceId)
         try encoderContainer.encode(tag, forKey: .tag)
    }
}
///  widgetMetric
public class WidgetMetric:NSObject,Codable{
    /// Aggregate
    var aggregate:String?
    /// Metric
    var metric:String?
    /// MetricName
    var metricName:String?



    public override init(){
            super.init()
    }

    enum WidgetMetricCodingKeys: String, CodingKey {
        case aggregate
        case metric
        case metricName
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: WidgetMetricCodingKeys.self)
        if decoderContainer.contains(.aggregate)
        {
            self.aggregate = try decoderContainer.decode(String?.self, forKey: .aggregate)
        }
        if decoderContainer.contains(.metric)
        {
            self.metric = try decoderContainer.decode(String?.self, forKey: .metric)
        }
        if decoderContainer.contains(.metricName)
        {
            self.metricName = try decoderContainer.decode(String?.self, forKey: .metricName)
        }
    }
}
public extension WidgetMetric{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: WidgetMetricCodingKeys.self)
         try encoderContainer.encode(aggregate, forKey: .aggregate)
         try encoderContainer.encode(metric, forKey: .metric)
         try encoderContainer.encode(metricName, forKey: .metricName)
    }
}
///  widget
public class Widget:NSObject,Codable{
    /// Aggregated
    var aggregated:String?
    /// CreatedTime
    var createdTime:Int64?
    /// DashboardId
    var dashboardId:String?
    /// Metrics
    var metrics:[WidgetMetric?]?
    /// Name
    var name:String?
    /// Position
    var position:WidgetPosition?
    /// Resources
    var resources:WidgetResources?
    /// ServiceCode
    var serviceCode:String?
    /// TopN
    var topN:Int?
    /// Type
    var type:String?
    /// UpdatedTime
    var updatedTime:Int64?
    /// WidgetId
    var widgetId:String?



    public override init(){
            super.init()
    }

    enum WidgetCodingKeys: String, CodingKey {
        case aggregated
        case createdTime
        case dashboardId
        case metrics
        case name
        case position
        case resources
        case serviceCode
        case topN
        case type
        case updatedTime
        case widgetId
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: WidgetCodingKeys.self)
        if decoderContainer.contains(.aggregated)
        {
            self.aggregated = try decoderContainer.decode(String?.self, forKey: .aggregated)
        }
        if decoderContainer.contains(.createdTime)
        {
            self.createdTime = try decoderContainer.decode(Int64?.self, forKey: .createdTime)
        }
        if decoderContainer.contains(.dashboardId)
        {
            self.dashboardId = try decoderContainer.decode(String?.self, forKey: .dashboardId)
        }
        if decoderContainer.contains(.metrics)
        {
            self.metrics = try decoderContainer.decode([WidgetMetric?]?.self, forKey: .metrics)
        }
        if decoderContainer.contains(.name)
        {
            self.name = try decoderContainer.decode(String?.self, forKey: .name)
        }
        if decoderContainer.contains(.position)
        {
            self.position = try decoderContainer.decode(WidgetPosition?.self, forKey: .position)
        }
        if decoderContainer.contains(.resources)
        {
            self.resources = try decoderContainer.decode(WidgetResources?.self, forKey: .resources)
        }
        if decoderContainer.contains(.serviceCode)
        {
            self.serviceCode = try decoderContainer.decode(String?.self, forKey: .serviceCode)
        }
        if decoderContainer.contains(.topN)
        {
            self.topN = try decoderContainer.decode(Int?.self, forKey: .topN)
        }
        if decoderContainer.contains(.type)
        {
            self.type = try decoderContainer.decode(String?.self, forKey: .type)
        }
        if decoderContainer.contains(.updatedTime)
        {
            self.updatedTime = try decoderContainer.decode(Int64?.self, forKey: .updatedTime)
        }
        if decoderContainer.contains(.widgetId)
        {
            self.widgetId = try decoderContainer.decode(String?.self, forKey: .widgetId)
        }
    }
}
public extension Widget{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: WidgetCodingKeys.self)
         try encoderContainer.encode(aggregated, forKey: .aggregated)
         try encoderContainer.encode(createdTime, forKey: .createdTime)
         try encoderContainer.encode(dashboardId, forKey: .dashboardId)
         try encoderContainer.encode(metrics, forKey: .metrics)
         try encoderContainer.encode(name, forKey: .name)
         try encoderContainer.encode(position, forKey: .position)
         try encoderContainer.encode(resources, forKey: .resources)
         try encoderContainer.encode(serviceCode, forKey: .serviceCode)
         try encoderContainer.encode(topN, forKey: .topN)
         try encoderContainer.encode(type, forKey: .type)
         try encoderContainer.encode(updatedTime, forKey: .updatedTime)
         try encoderContainer.encode(widgetId, forKey: .widgetId)
    }
}
///  widgetSupportedProduct
public class WidgetSupportedProduct:NSObject,Codable{
    /// Name
    var name:String?
    /// ServiceCode
    var serviceCode:String?



    public override init(){
            super.init()
    }

    enum WidgetSupportedProductCodingKeys: String, CodingKey {
        case name
        case serviceCode
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: WidgetSupportedProductCodingKeys.self)
        if decoderContainer.contains(.name)
        {
            self.name = try decoderContainer.decode(String?.self, forKey: .name)
        }
        if decoderContainer.contains(.serviceCode)
        {
            self.serviceCode = try decoderContainer.decode(String?.self, forKey: .serviceCode)
        }
    }
}
public extension WidgetSupportedProduct{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: WidgetSupportedProductCodingKeys.self)
         try encoderContainer.encode(name, forKey: .name)
         try encoderContainer.encode(serviceCode, forKey: .serviceCode)
    }
}
///  widgetPosition
public class WidgetPosition:NSObject,Codable{
    /// Col
    var col:Int?
    /// CreatedTime
    var createdTime:Int64?
    /// Order
    var order:Int?
    /// Row
    var row:Int?
    /// SizeX
    var sizeX:Int?
    /// SizeY
    var sizeY:Int?
    /// UpdatedTime
    var updatedTime:Int64?



    public override init(){
            super.init()
    }

    enum WidgetPositionCodingKeys: String, CodingKey {
        case col
        case createdTime
        case order
        case row
        case sizeX
        case sizeY
        case updatedTime
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: WidgetPositionCodingKeys.self)
        if decoderContainer.contains(.col)
        {
            self.col = try decoderContainer.decode(Int?.self, forKey: .col)
        }
        if decoderContainer.contains(.createdTime)
        {
            self.createdTime = try decoderContainer.decode(Int64?.self, forKey: .createdTime)
        }
        if decoderContainer.contains(.order)
        {
            self.order = try decoderContainer.decode(Int?.self, forKey: .order)
        }
        if decoderContainer.contains(.row)
        {
            self.row = try decoderContainer.decode(Int?.self, forKey: .row)
        }
        if decoderContainer.contains(.sizeX)
        {
            self.sizeX = try decoderContainer.decode(Int?.self, forKey: .sizeX)
        }
        if decoderContainer.contains(.sizeY)
        {
            self.sizeY = try decoderContainer.decode(Int?.self, forKey: .sizeY)
        }
        if decoderContainer.contains(.updatedTime)
        {
            self.updatedTime = try decoderContainer.decode(Int64?.self, forKey: .updatedTime)
        }
    }
}
public extension WidgetPosition{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: WidgetPositionCodingKeys.self)
         try encoderContainer.encode(col, forKey: .col)
         try encoderContainer.encode(createdTime, forKey: .createdTime)
         try encoderContainer.encode(order, forKey: .order)
         try encoderContainer.encode(row, forKey: .row)
         try encoderContainer.encode(sizeX, forKey: .sizeX)
         try encoderContainer.encode(sizeY, forKey: .sizeY)
         try encoderContainer.encode(updatedTime, forKey: .updatedTime)
    }
}
///  sqlDataPoint
public class SqlDataPoint:NSObject,Codable{
    /// 目前统一用jcloud
    /// Required:true
    var appCode:String
    /// 资源的类型，取值sqlserver
    /// Required:true
    var serviceCode:String
    /// 资源所在的地域
    /// Required:true
    var region:String
    /// 资源的uuid
    /// Required:true
    var resourceId:String
    /// 监控指标名称，长度不超过255字节，只允许英文、数字、下划线_、点.,  [0-9][a-z] [A-Z] [. _ ]， 其它会返回err
    /// Required:true
    var metric:String
    /// 毫秒级时间戳，早于当前时间30天的不能写入；建议的上报时间戳：上报时间间隔的整数倍，如上报间隔为5ms，则建议上报的时间戳为 time &#x3D; current timestamp - (current timestamp % time interval) &#x3D; 1487647187007 - （1487647187007 % 5） &#x3D; 1487647187007 -2 &#x3D; 1487647187005
    /// Required:true
    var time:Int64
    /// 上报的监控值，即慢sql语句已经执行的时间(单位s)
    /// Required:true
    var value:Int64
    /// SQL开始执行的时间
    /// Required:true
    var start_time:String
    /// SQL已执行时间(单位s)
    /// Required:true
    var execution_time:Int64
    /// 会话ID
    /// Required:true
    var session_id:String
    /// 数据库库名
    /// Required:true
    var database:String
    /// 客户端IP地址
    /// Required:true
    var client_net_address:String
    /// 用户名
    /// Required:true
    var loginname:String
    /// SQL会话请求状态
    /// Required:true
    var status:String
    /// SQL详细文本
    /// Required:true
    var sqlstr:String



    public  init(appCode:String,serviceCode:String,region:String,resourceId:String,metric:String,time:Int64,value:Int64,start_time:String,execution_time:Int64,session_id:String,database:String,client_net_address:String,loginname:String,status:String,sqlstr:String){
             self.appCode = appCode
             self.serviceCode = serviceCode
             self.region = region
             self.resourceId = resourceId
             self.metric = metric
             self.time = time
             self.value = value
             self.start_time = start_time
             self.execution_time = execution_time
             self.session_id = session_id
             self.database = database
             self.client_net_address = client_net_address
             self.loginname = loginname
             self.status = status
             self.sqlstr = sqlstr
    }

    enum SqlDataPointCodingKeys: String, CodingKey {
        case appCode
        case serviceCode
        case region
        case resourceId
        case metric
        case time
        case value
        case start_time
        case execution_time
        case session_id
        case database
        case client_net_address
        case loginname
        case status
        case sqlstr
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: SqlDataPointCodingKeys.self)
        self.appCode = try decoderContainer.decode(String.self, forKey: .appCode)
        self.serviceCode = try decoderContainer.decode(String.self, forKey: .serviceCode)
        self.region = try decoderContainer.decode(String.self, forKey: .region)
        self.resourceId = try decoderContainer.decode(String.self, forKey: .resourceId)
        self.metric = try decoderContainer.decode(String.self, forKey: .metric)
        self.time = try decoderContainer.decode(Int64.self, forKey: .time)
        self.value = try decoderContainer.decode(Int64.self, forKey: .value)
        self.start_time = try decoderContainer.decode(String.self, forKey: .start_time)
        self.execution_time = try decoderContainer.decode(Int64.self, forKey: .execution_time)
        self.session_id = try decoderContainer.decode(String.self, forKey: .session_id)
        self.database = try decoderContainer.decode(String.self, forKey: .database)
        self.client_net_address = try decoderContainer.decode(String.self, forKey: .client_net_address)
        self.loginname = try decoderContainer.decode(String.self, forKey: .loginname)
        self.status = try decoderContainer.decode(String.self, forKey: .status)
        self.sqlstr = try decoderContainer.decode(String.self, forKey: .sqlstr)
    }
}
public extension SqlDataPoint{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: SqlDataPointCodingKeys.self)
         try encoderContainer.encode(appCode, forKey: .appCode)
         try encoderContainer.encode(serviceCode, forKey: .serviceCode)
         try encoderContainer.encode(region, forKey: .region)
         try encoderContainer.encode(resourceId, forKey: .resourceId)
         try encoderContainer.encode(metric, forKey: .metric)
         try encoderContainer.encode(time, forKey: .time)
         try encoderContainer.encode(value, forKey: .value)
         try encoderContainer.encode(start_time, forKey: .start_time)
         try encoderContainer.encode(execution_time, forKey: .execution_time)
         try encoderContainer.encode(session_id, forKey: .session_id)
         try encoderContainer.encode(database, forKey: .database)
         try encoderContainer.encode(client_net_address, forKey: .client_net_address)
         try encoderContainer.encode(loginname, forKey: .loginname)
         try encoderContainer.encode(status, forKey: .status)
         try encoderContainer.encode(sqlstr, forKey: .sqlstr)
    }
}
///  metricDataCm
public class MetricDataCm:NSObject,Codable{
    /// 命名空间 ，长度不超过255字节，只允许英文、数字、下划线_、点., [0-9][a-z] [A-Z] [. _ ]，  其它会返回err
    /// Required:true
    var namespace:String
    /// 监控指标名称，长度不超过255字节，只允许英文、数字、下划线_、点.,  [0-9][a-z] [A-Z] [. _ ]， 其它会返回err
    /// Required:true
    var metric:String
    /// 数据维度，数据类型为map类型，支持最少一个，最多6个标签，总长度不大于1024字节，只允许英文、数字、下划线_、点., [0-9][a-z] [A-Z] [. _ ]，  其它会返回err。eg:{&quot;host&quot;:&quot;127.0.0.1&quot;,&quot;region&quot;:&quot;cn-north-1&quot;,&quot;role&quot;:&quot;M&quot;}
    /// Required:true
    var dimensions:[String:String?]?
    /// 上报数据点的时间戳,只支持10位，秒级时间戳，不能写入过去30天的时间
    /// Required:true
    var timestamp:Int64
    /// 数据上报类型，1为原始值
    /// Required:true
    var type:Int
    /// 指标值集合，数据类型必须为map类型，key为数据类型，value为数据值，当type&#x3D;1时，key只能为”value”，上报的是原始值，value内容为整型或浮点型数字，最大值为9223372036854775807
    /// Required:true
    var values:[String:String?]?
    /// 数据的单位，长度不超过64字节，只允许英文、数字、下划线_、点., [0-9][a-z] [A-Z] [. _ ]，  其它会返回err
    var unit:String?



    public  init(namespace:String,metric:String,dimensions:[String:String?]?,timestamp:Int64,type:Int,values:[String:String?]?){
             self.namespace = namespace
             self.metric = metric
             self.dimensions = dimensions
             self.timestamp = timestamp
             self.type = type
             self.values = values
    }

    enum MetricDataCmCodingKeys: String, CodingKey {
        case namespace
        case metric
        case dimensions
        case timestamp
        case type
        case values
        case unit
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: MetricDataCmCodingKeys.self)
        self.namespace = try decoderContainer.decode(String.self, forKey: .namespace)
        self.metric = try decoderContainer.decode(String.self, forKey: .metric)
        self.dimensions = try decoderContainer.decode([String:String?]?.self, forKey: .dimensions)
        self.timestamp = try decoderContainer.decode(Int64.self, forKey: .timestamp)
        self.type = try decoderContainer.decode(Int.self, forKey: .type)
        self.values = try decoderContainer.decode([String:String?]?.self, forKey: .values)
        if decoderContainer.contains(.unit)
        {
            self.unit = try decoderContainer.decode(String?.self, forKey: .unit)
        }
    }
}
public extension MetricDataCm{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: MetricDataCmCodingKeys.self)
         try encoderContainer.encode(namespace, forKey: .namespace)
         try encoderContainer.encode(metric, forKey: .metric)
         try encoderContainer.encode(dimensions, forKey: .dimensions)
         try encoderContainer.encode(timestamp, forKey: .timestamp)
         try encoderContainer.encode(type, forKey: .type)
         try encoderContainer.encode(values, forKey: .values)
         try encoderContainer.encode(unit, forKey: .unit)
    }
}
///  metricDataList
public class MetricDataList:NSObject,Codable{
    /// 错误数据
    var errMetricData:String?
    /// 错误数据描述
    var errDetail:String?



    public override init(){
            super.init()
    }

    enum MetricDataListCodingKeys: String, CodingKey {
        case errMetricData
        case errDetail
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: MetricDataListCodingKeys.self)
        if decoderContainer.contains(.errMetricData)
        {
            self.errMetricData = try decoderContainer.decode(String?.self, forKey: .errMetricData)
        }
        if decoderContainer.contains(.errDetail)
        {
            self.errDetail = try decoderContainer.decode(String?.self, forKey: .errDetail)
        }
    }
}
public extension MetricDataList{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: MetricDataListCodingKeys.self)
         try encoderContainer.encode(errMetricData, forKey: .errMetricData)
         try encoderContainer.encode(errDetail, forKey: .errDetail)
    }
}
///  deleteAlarmsSpec
public class DeleteAlarmsSpec:NSObject,Codable{
    /// filter name为&#39;ids&#39;为要删除的告警id
      /// in: query
    /// Required:true
    var filters:[Filter?]?



    public  init(filters:[Filter?]?){
             self.filters = filters
    }

    enum DeleteAlarmsSpecCodingKeys: String, CodingKey {
        case filters
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: DeleteAlarmsSpecCodingKeys.self)
        self.filters = try decoderContainer.decode([Filter?]?.self, forKey: .filters)
    }
}
public extension DeleteAlarmsSpec{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: DeleteAlarmsSpecCodingKeys.self)
         try encoderContainer.encode(filters, forKey: .filters)
    }
}
///  updateTemplateResponseEnd
public class UpdateTemplateResponseEnd:NSObject,Codable{
    /// 是否更新成功
    var success:Bool?
    /// 更新后的模板id
    var templateId:Int64?



    public override init(){
            super.init()
    }

    enum UpdateTemplateResponseEndCodingKeys: String, CodingKey {
        case success
        case templateId
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: UpdateTemplateResponseEndCodingKeys.self)
        if decoderContainer.contains(.success)
        {
            self.success = try decoderContainer.decode(Bool?.self, forKey: .success)
        }
        if decoderContainer.contains(.templateId)
        {
            self.templateId = try decoderContainer.decode(Int64?.self, forKey: .templateId)
        }
    }
}
public extension UpdateTemplateResponseEnd{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: UpdateTemplateResponseEndCodingKeys.self)
         try encoderContainer.encode(success, forKey: .success)
         try encoderContainer.encode(templateId, forKey: .templateId)
    }
}
///  updateWebHookOut
public class UpdateWebHookOut:NSObject,Codable{
    /// Success
    var success:Bool?



    public override init(){
            super.init()
    }

    enum UpdateWebHookOutCodingKeys: String, CodingKey {
        case success
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: UpdateWebHookOutCodingKeys.self)
        if decoderContainer.contains(.success)
        {
            self.success = try decoderContainer.decode(Bool?.self, forKey: .success)
        }
    }
}
public extension UpdateWebHookOut{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: UpdateWebHookOutCodingKeys.self)
         try encoderContainer.encode(success, forKey: .success)
    }
}
///  baseRuleT
public class BaseRuleT:NSObject,Codable{
    /// 弹性伸缩组ID
    var autoScalingPolicyId:String?
    /// 监控项单位
    var calculateUnit:String?
    /// 统计方法，必须与定义的metric一致，可选值列表：avg,sum,max,min
    /// Required:true
    var calculation:String
    /// 降采样函数
    var downSample:String?
    /// 监控项唯一标识，可根据DescribeMetricsForCreateAlarm接口查询各产品线可用的监控项（创建规则时使用Metric字段）。格式：metric:downsample
    /// Required:true
    var metric:String
    /// 监控项ID
    var metricId:Int64?
    /// NoticeLevel
    var noticeLevel:NoticeLevel?
    /// 通知周期，单位：小时
    /// Required:true
    var noticePeriod:Int64
    /// 报警比较符，只能为以下几种lte(&lt;&#x3D;),lt(&lt;),gt(&gt;),gte(&gt;&#x3D;),eq(&#x3D;&#x3D;),ne(!&#x3D;)
    /// Required:true
    var operation:String
    /// 查询指标的周期，单位为分钟,目前支持的取值：1, 2，5，10,15，30，60
    /// Required:true
    var period:Int64
    /// 规则类型, 1表示云监控，2表示弹性伸缩，3表示AG，4表示AutoHeal，5表示自定义监控，6表示hawkeye
    /// Required:true
    var ruleType:Int64
    /// 多值标签
    var tags:[String:String?]?
    /// 报警阈值，目前只开放数值类型功能
    /// Required:true
    var threshold:Double
    /// 连续探测几次都满足阈值条件时报警，可选值:1,2,3,5,10,15,30,60
    /// Required:true
    var times:Int64



    public  init(calculation:String,metric:String,noticePeriod:Int64,operation:String,period:Int64,ruleType:Int64,threshold:Double,times:Int64){
             self.calculation = calculation
             self.metric = metric
             self.noticePeriod = noticePeriod
             self.operation = operation
             self.period = period
             self.ruleType = ruleType
             self.threshold = threshold
             self.times = times
    }

    enum BaseRuleTCodingKeys: String, CodingKey {
        case autoScalingPolicyId
        case calculateUnit
        case calculation
        case downSample
        case metric
        case metricId
        case noticeLevel
        case noticePeriod
        case operation
        case period
        case ruleType
        case tags
        case threshold
        case times
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: BaseRuleTCodingKeys.self)
        if decoderContainer.contains(.autoScalingPolicyId)
        {
            self.autoScalingPolicyId = try decoderContainer.decode(String?.self, forKey: .autoScalingPolicyId)
        }
        if decoderContainer.contains(.calculateUnit)
        {
            self.calculateUnit = try decoderContainer.decode(String?.self, forKey: .calculateUnit)
        }
        self.calculation = try decoderContainer.decode(String.self, forKey: .calculation)
        if decoderContainer.contains(.downSample)
        {
            self.downSample = try decoderContainer.decode(String?.self, forKey: .downSample)
        }
        self.metric = try decoderContainer.decode(String.self, forKey: .metric)
        if decoderContainer.contains(.metricId)
        {
            self.metricId = try decoderContainer.decode(Int64?.self, forKey: .metricId)
        }
        if decoderContainer.contains(.noticeLevel)
        {
            self.noticeLevel = try decoderContainer.decode(NoticeLevel?.self, forKey: .noticeLevel)
        }
        self.noticePeriod = try decoderContainer.decode(Int64.self, forKey: .noticePeriod)
        self.operation = try decoderContainer.decode(String.self, forKey: .operation)
        self.period = try decoderContainer.decode(Int64.self, forKey: .period)
        self.ruleType = try decoderContainer.decode(Int64.self, forKey: .ruleType)
        if decoderContainer.contains(.tags)
        {
            self.tags = try decoderContainer.decode([String:String?]?.self, forKey: .tags)
        }
        self.threshold = try decoderContainer.decode(Double.self, forKey: .threshold)
        self.times = try decoderContainer.decode(Int64.self, forKey: .times)
    }
}
public extension BaseRuleT{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: BaseRuleTCodingKeys.self)
         try encoderContainer.encode(autoScalingPolicyId, forKey: .autoScalingPolicyId)
         try encoderContainer.encode(calculateUnit, forKey: .calculateUnit)
         try encoderContainer.encode(calculation, forKey: .calculation)
         try encoderContainer.encode(downSample, forKey: .downSample)
         try encoderContainer.encode(metric, forKey: .metric)
         try encoderContainer.encode(metricId, forKey: .metricId)
         try encoderContainer.encode(noticeLevel, forKey: .noticeLevel)
         try encoderContainer.encode(noticePeriod, forKey: .noticePeriod)
         try encoderContainer.encode(operation, forKey: .operation)
         try encoderContainer.encode(period, forKey: .period)
         try encoderContainer.encode(ruleType, forKey: .ruleType)
         try encoderContainer.encode(tags, forKey: .tags)
         try encoderContainer.encode(threshold, forKey: .threshold)
         try encoderContainer.encode(times, forKey: .times)
    }
}
///  serviceMetricItem
public class ServiceMetricItem:NSObject,Codable{
    /// Aggregates
    var aggregates:[ServiceMetricAggregateItem?]?
    /// CalculateUnit
    var calculateUnit:String?
    /// Metric
    var metric:String?
    /// Name
    var name:String?
    /// ServiceCode
    var serviceCode:String?



    public override init(){
            super.init()
    }

    enum ServiceMetricItemCodingKeys: String, CodingKey {
        case aggregates
        case calculateUnit
        case metric
        case name
        case serviceCode
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: ServiceMetricItemCodingKeys.self)
        if decoderContainer.contains(.aggregates)
        {
            self.aggregates = try decoderContainer.decode([ServiceMetricAggregateItem?]?.self, forKey: .aggregates)
        }
        if decoderContainer.contains(.calculateUnit)
        {
            self.calculateUnit = try decoderContainer.decode(String?.self, forKey: .calculateUnit)
        }
        if decoderContainer.contains(.metric)
        {
            self.metric = try decoderContainer.decode(String?.self, forKey: .metric)
        }
        if decoderContainer.contains(.name)
        {
            self.name = try decoderContainer.decode(String?.self, forKey: .name)
        }
        if decoderContainer.contains(.serviceCode)
        {
            self.serviceCode = try decoderContainer.decode(String?.self, forKey: .serviceCode)
        }
    }
}
public extension ServiceMetricItem{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: ServiceMetricItemCodingKeys.self)
         try encoderContainer.encode(aggregates, forKey: .aggregates)
         try encoderContainer.encode(calculateUnit, forKey: .calculateUnit)
         try encoderContainer.encode(metric, forKey: .metric)
         try encoderContainer.encode(name, forKey: .name)
         try encoderContainer.encode(serviceCode, forKey: .serviceCode)
    }
}
///  serviceMetricAggregateItem
public class ServiceMetricAggregateItem:NSObject,Codable{
    /// Aggregate
    var aggregate:String?
    /// Name
    var name:String?



    public override init(){
            super.init()
    }

    enum ServiceMetricAggregateItemCodingKeys: String, CodingKey {
        case aggregate
        case name
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: ServiceMetricAggregateItemCodingKeys.self)
        if decoderContainer.contains(.aggregate)
        {
            self.aggregate = try decoderContainer.decode(String?.self, forKey: .aggregate)
        }
        if decoderContainer.contains(.name)
        {
            self.name = try decoderContainer.decode(String?.self, forKey: .name)
        }
    }
}
public extension ServiceMetricAggregateItem{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: ServiceMetricAggregateItemCodingKeys.self)
         try encoderContainer.encode(aggregate, forKey: .aggregate)
         try encoderContainer.encode(name, forKey: .name)
    }
}
///  serviceMetric
public class ServiceMetric:NSObject,Codable{
    /// Metric
    var metric:[ServiceMetricItem?]?
    /// ServiceCode
    var serviceCode:String?



    public override init(){
            super.init()
    }

    enum ServiceMetricCodingKeys: String, CodingKey {
        case metric
        case serviceCode
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: ServiceMetricCodingKeys.self)
        if decoderContainer.contains(.metric)
        {
            self.metric = try decoderContainer.decode([ServiceMetricItem?]?.self, forKey: .metric)
        }
        if decoderContainer.contains(.serviceCode)
        {
            self.serviceCode = try decoderContainer.decode(String?.self, forKey: .serviceCode)
        }
    }
}
public extension ServiceMetric{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: ServiceMetricCodingKeys.self)
         try encoderContainer.encode(metric, forKey: .metric)
         try encoderContainer.encode(serviceCode, forKey: .serviceCode)
    }
}
///  getWidgetMetricOut
public class GetWidgetMetricOut:NSObject,Codable{
    /// List
    var list:[ServiceMetric?]?



    public override init(){
            super.init()
    }

    enum GetWidgetMetricOutCodingKeys: String, CodingKey {
        case list
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: GetWidgetMetricOutCodingKeys.self)
        if decoderContainer.contains(.list)
        {
            self.list = try decoderContainer.decode([ServiceMetric?]?.self, forKey: .list)
        }
    }
}
public extension GetWidgetMetricOut{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: GetWidgetMetricOutCodingKeys.self)
         try encoderContainer.encode(list, forKey: .list)
    }
}
///  keyValue
public class KeyValue:NSObject,Codable{
    /// key
    var key:String?
    /// value
    var value:String?



    public override init(){
            super.init()
    }

    enum KeyValueCodingKeys: String, CodingKey {
        case key
        case value
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: KeyValueCodingKeys.self)
        if decoderContainer.contains(.key)
        {
            self.key = try decoderContainer.decode(String?.self, forKey: .key)
        }
        if decoderContainer.contains(.value)
        {
            self.value = try decoderContainer.decode(String?.self, forKey: .value)
        }
    }
}
public extension KeyValue{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: KeyValueCodingKeys.self)
         try encoderContainer.encode(key, forKey: .key)
         try encoderContainer.encode(value, forKey: .value)
    }
}
///  updateTemplateResponseResultV2
public class UpdateTemplateResponseResultV2:NSObject,Codable{
    /// 是否更新成功
    var success:Bool?
    /// 更新后的模板uuid
    var templateUuid:String?



    public override init(){
            super.init()
    }

    enum UpdateTemplateResponseResultV2CodingKeys: String, CodingKey {
        case success
        case templateUuid
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: UpdateTemplateResponseResultV2CodingKeys.self)
        if decoderContainer.contains(.success)
        {
            self.success = try decoderContainer.decode(Bool?.self, forKey: .success)
        }
        if decoderContainer.contains(.templateUuid)
        {
            self.templateUuid = try decoderContainer.decode(String?.self, forKey: .templateUuid)
        }
    }
}
public extension UpdateTemplateResponseResultV2{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: UpdateTemplateResponseResultV2CodingKeys.self)
         try encoderContainer.encode(success, forKey: .success)
         try encoderContainer.encode(templateUuid, forKey: .templateUuid)
    }
}
///  ruleDetail
public class RuleDetail:NSObject,Codable{
    /// 计算单位
    var calculateUnit:String?
    /// 统计方法，必须与定义的metric一致，可选值列表：avg,sum,max,min
    /// Required:true
    var calculation:String
    /// 降采样函数
    /// Required:true
    var downSample:String
    /// 监控项唯一标识，可根据DescribeMetricsForCreateAlarm接口查询各产品线可用的监控项（创建规则时使用Metric字段）。格式：metric:downsample
    /// Required:true
    var metric:String
    /// 监控项名称
    var metricName:String?
    /// NoticeLevel
    var noticeLevel:NoticeLevel?
    /// 报警比较符，只能为以下几种lte(&lt;&#x3D;),lt(&lt;),gt(&gt;),gte(&gt;&#x3D;),eq(&#x3D;&#x3D;),ne(!&#x3D;)
    /// Required:true
    var operation:String
    /// 查询指标的周期，单位为分钟,目前支持的取值：1,2，5，10,15，30，60
    /// Required:true
    var period:Int64
    /// 报警阈值，目前只开放数值类型功能
    /// Required:true
    var threshold:Double
    /// 连续探测几次都满足阈值条件时报警，可选值:1,2,3,5,10,15,30,60
    /// Required:true
    var times:Int64



    public  init(calculation:String,downSample:String,metric:String,operation:String,period:Int64,threshold:Double,times:Int64){
             self.calculation = calculation
             self.downSample = downSample
             self.metric = metric
             self.operation = operation
             self.period = period
             self.threshold = threshold
             self.times = times
    }

    enum RuleDetailCodingKeys: String, CodingKey {
        case calculateUnit
        case calculation
        case downSample
        case metric
        case metricName
        case noticeLevel
        case operation
        case period
        case threshold
        case times
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: RuleDetailCodingKeys.self)
        if decoderContainer.contains(.calculateUnit)
        {
            self.calculateUnit = try decoderContainer.decode(String?.self, forKey: .calculateUnit)
        }
        self.calculation = try decoderContainer.decode(String.self, forKey: .calculation)
        self.downSample = try decoderContainer.decode(String.self, forKey: .downSample)
        self.metric = try decoderContainer.decode(String.self, forKey: .metric)
        if decoderContainer.contains(.metricName)
        {
            self.metricName = try decoderContainer.decode(String?.self, forKey: .metricName)
        }
        if decoderContainer.contains(.noticeLevel)
        {
            self.noticeLevel = try decoderContainer.decode(NoticeLevel?.self, forKey: .noticeLevel)
        }
        self.operation = try decoderContainer.decode(String.self, forKey: .operation)
        self.period = try decoderContainer.decode(Int64.self, forKey: .period)
        self.threshold = try decoderContainer.decode(Double.self, forKey: .threshold)
        self.times = try decoderContainer.decode(Int64.self, forKey: .times)
    }
}
public extension RuleDetail{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: RuleDetailCodingKeys.self)
         try encoderContainer.encode(calculateUnit, forKey: .calculateUnit)
         try encoderContainer.encode(calculation, forKey: .calculation)
         try encoderContainer.encode(downSample, forKey: .downSample)
         try encoderContainer.encode(metric, forKey: .metric)
         try encoderContainer.encode(metricName, forKey: .metricName)
         try encoderContainer.encode(noticeLevel, forKey: .noticeLevel)
         try encoderContainer.encode(operation, forKey: .operation)
         try encoderContainer.encode(period, forKey: .period)
         try encoderContainer.encode(threshold, forKey: .threshold)
         try encoderContainer.encode(times, forKey: .times)
    }
}
///  alarmVo
public class AlarmVo:NSObject,Codable{
    /// 监控项单位
    var calculateUnit:String?
    /// 统计方法：平均值&#x3D;avg、最大值&#x3D;max、最小值&#x3D;min
    var calculation:String?
    /// 联系人列表
    var contacts:[BaseContact?]?
    /// CreateTime
    var createTime:String?
    /// 是否删除 1正常，0删除
    var deleted:Int64?
    /// downSample
    var downSample:String?
    /// 规则ID
    var id:Int64?
    /// 监控项
    var metric:String?
    /// 监控项ID
    var metricId:Int64?
    /// 监控项名称
    var metricName:String?
    /// NoticeLevel
    var noticeLevel:NoticeLevel?
    /// 通知周期
    var noticePeriod:Int64?
    /// 报警比较符，只能为以下几种lte(&lt;&#x3D;),lt(&lt;),gt(&gt;),gte(&gt;&#x3D;),eq(&#x3D;&#x3D;),ne(!&#x3D;)
    var operation:String?
    /// 统计周期（单位：分钟）
    var period:Int64?
    /// 规则类型
    var ruleType:Int64?
    /// 规则所属资源类型
    var serviceCode:String?
    /// 监控项附属信息
    var tag:String?
    /// 多值标签
    var tags:[String:String?]?
    /// 阈值
    var threshold:Double?
    /// 连续多少次后报警
    var times:Int64?
    /// UpdateTime
    var updateTime:String?



    public override init(){
            super.init()
    }

    enum AlarmVoCodingKeys: String, CodingKey {
        case calculateUnit
        case calculation
        case contacts
        case createTime
        case deleted
        case downSample
        case id
        case metric
        case metricId
        case metricName
        case noticeLevel
        case noticePeriod
        case operation
        case period
        case ruleType
        case serviceCode
        case tag
        case tags
        case threshold
        case times
        case updateTime
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: AlarmVoCodingKeys.self)
        if decoderContainer.contains(.calculateUnit)
        {
            self.calculateUnit = try decoderContainer.decode(String?.self, forKey: .calculateUnit)
        }
        if decoderContainer.contains(.calculation)
        {
            self.calculation = try decoderContainer.decode(String?.self, forKey: .calculation)
        }
        if decoderContainer.contains(.contacts)
        {
            self.contacts = try decoderContainer.decode([BaseContact?]?.self, forKey: .contacts)
        }
        if decoderContainer.contains(.createTime)
        {
            self.createTime = try decoderContainer.decode(String?.self, forKey: .createTime)
        }
        if decoderContainer.contains(.deleted)
        {
            self.deleted = try decoderContainer.decode(Int64?.self, forKey: .deleted)
        }
        if decoderContainer.contains(.downSample)
        {
            self.downSample = try decoderContainer.decode(String?.self, forKey: .downSample)
        }
        if decoderContainer.contains(.id)
        {
            self.id = try decoderContainer.decode(Int64?.self, forKey: .id)
        }
        if decoderContainer.contains(.metric)
        {
            self.metric = try decoderContainer.decode(String?.self, forKey: .metric)
        }
        if decoderContainer.contains(.metricId)
        {
            self.metricId = try decoderContainer.decode(Int64?.self, forKey: .metricId)
        }
        if decoderContainer.contains(.metricName)
        {
            self.metricName = try decoderContainer.decode(String?.self, forKey: .metricName)
        }
        if decoderContainer.contains(.noticeLevel)
        {
            self.noticeLevel = try decoderContainer.decode(NoticeLevel?.self, forKey: .noticeLevel)
        }
        if decoderContainer.contains(.noticePeriod)
        {
            self.noticePeriod = try decoderContainer.decode(Int64?.self, forKey: .noticePeriod)
        }
        if decoderContainer.contains(.operation)
        {
            self.operation = try decoderContainer.decode(String?.self, forKey: .operation)
        }
        if decoderContainer.contains(.period)
        {
            self.period = try decoderContainer.decode(Int64?.self, forKey: .period)
        }
        if decoderContainer.contains(.ruleType)
        {
            self.ruleType = try decoderContainer.decode(Int64?.self, forKey: .ruleType)
        }
        if decoderContainer.contains(.serviceCode)
        {
            self.serviceCode = try decoderContainer.decode(String?.self, forKey: .serviceCode)
        }
        if decoderContainer.contains(.tag)
        {
            self.tag = try decoderContainer.decode(String?.self, forKey: .tag)
        }
        if decoderContainer.contains(.tags)
        {
            self.tags = try decoderContainer.decode([String:String?]?.self, forKey: .tags)
        }
        if decoderContainer.contains(.threshold)
        {
            self.threshold = try decoderContainer.decode(Double?.self, forKey: .threshold)
        }
        if decoderContainer.contains(.times)
        {
            self.times = try decoderContainer.decode(Int64?.self, forKey: .times)
        }
        if decoderContainer.contains(.updateTime)
        {
            self.updateTime = try decoderContainer.decode(String?.self, forKey: .updateTime)
        }
    }
}
public extension AlarmVo{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: AlarmVoCodingKeys.self)
         try encoderContainer.encode(calculateUnit, forKey: .calculateUnit)
         try encoderContainer.encode(calculation, forKey: .calculation)
         try encoderContainer.encode(contacts, forKey: .contacts)
         try encoderContainer.encode(createTime, forKey: .createTime)
         try encoderContainer.encode(deleted, forKey: .deleted)
         try encoderContainer.encode(downSample, forKey: .downSample)
         try encoderContainer.encode(id, forKey: .id)
         try encoderContainer.encode(metric, forKey: .metric)
         try encoderContainer.encode(metricId, forKey: .metricId)
         try encoderContainer.encode(metricName, forKey: .metricName)
         try encoderContainer.encode(noticeLevel, forKey: .noticeLevel)
         try encoderContainer.encode(noticePeriod, forKey: .noticePeriod)
         try encoderContainer.encode(operation, forKey: .operation)
         try encoderContainer.encode(period, forKey: .period)
         try encoderContainer.encode(ruleType, forKey: .ruleType)
         try encoderContainer.encode(serviceCode, forKey: .serviceCode)
         try encoderContainer.encode(tag, forKey: .tag)
         try encoderContainer.encode(tags, forKey: .tags)
         try encoderContainer.encode(threshold, forKey: .threshold)
         try encoderContainer.encode(times, forKey: .times)
         try encoderContainer.encode(updateTime, forKey: .updateTime)
    }
}
///  chart
public class Chart:NSObject,Codable{
    /// 监控图名称
    var chartName:String?
    /// 监控图单位
    var chartUnit:String?
    /// 监控图包含的指标
    var include:[String?]?



    public override init(){
            super.init()
    }

    enum ChartCodingKeys: String, CodingKey {
        case chartName
        case chartUnit
        case include
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: ChartCodingKeys.self)
        if decoderContainer.contains(.chartName)
        {
            self.chartName = try decoderContainer.decode(String?.self, forKey: .chartName)
        }
        if decoderContainer.contains(.chartUnit)
        {
            self.chartUnit = try decoderContainer.decode(String?.self, forKey: .chartUnit)
        }
        if decoderContainer.contains(.include)
        {
            self.include = try decoderContainer.decode([String?]?.self, forKey: .include)
        }
    }
}
public extension Chart{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: ChartCodingKeys.self)
         try encoderContainer.encode(chartName, forKey: .chartName)
         try encoderContainer.encode(chartUnit, forKey: .chartUnit)
         try encoderContainer.encode(include, forKey: .include)
    }
}
///  describeTemplatesByTemplateIDResponseEnd
public class DescribeTemplatesByTemplateIDResponseEnd:NSObject,Codable{
    /// Template
    var template:TemplateVo?



    public override init(){
            super.init()
    }

    enum DescribeTemplatesByTemplateIDResponseEndCodingKeys: String, CodingKey {
        case template
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: DescribeTemplatesByTemplateIDResponseEndCodingKeys.self)
        if decoderContainer.contains(.template)
        {
            self.template = try decoderContainer.decode(TemplateVo?.self, forKey: .template)
        }
    }
}
public extension DescribeTemplatesByTemplateIDResponseEnd{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: DescribeTemplatesByTemplateIDResponseEndCodingKeys.self)
         try encoderContainer.encode(template, forKey: .template)
    }
}
///  templateVo
public class TemplateVo:NSObject,Codable{
    /// CreateTime
    var createTime:String?
    /// 模板描述
    var descriptionValue:String?
    /// 用户
    var pin:String?
    /// 模板内包含的规则数量
    var rulesCount:Int64?
    /// 模板所属资源类型
    var serviceCode:String?
    /// 模板id
    var templateId:Int64?
    /// 模板名称
    var templateName:String?
    /// 模板内包含的规则
    var templateRules:[AlarmVo?]?
    /// 模板内包含的提供给前端的拼接好的规则
    var templateRulesString:[String?]?
    /// 模板类型，区分默认模板和用户自定义模板：1表示默认模板，2表示用户自定义模板
    var templateType:Int64?
    /// UpdateTime
    var updateTime:String?



    public override init(){
            super.init()
    }

    enum TemplateVoCodingKeys: String, CodingKey {
        case createTime
        case descriptionValue = "description"
        case pin
        case rulesCount
        case serviceCode
        case templateId
        case templateName
        case templateRules
        case templateRulesString
        case templateType
        case updateTime
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: TemplateVoCodingKeys.self)
        if decoderContainer.contains(.createTime)
        {
            self.createTime = try decoderContainer.decode(String?.self, forKey: .createTime)
        }
        if decoderContainer.contains(.descriptionValue)
        {
            self.descriptionValue = try decoderContainer.decode(String?.self, forKey: .descriptionValue)
        }
        if decoderContainer.contains(.pin)
        {
            self.pin = try decoderContainer.decode(String?.self, forKey: .pin)
        }
        if decoderContainer.contains(.rulesCount)
        {
            self.rulesCount = try decoderContainer.decode(Int64?.self, forKey: .rulesCount)
        }
        if decoderContainer.contains(.serviceCode)
        {
            self.serviceCode = try decoderContainer.decode(String?.self, forKey: .serviceCode)
        }
        if decoderContainer.contains(.templateId)
        {
            self.templateId = try decoderContainer.decode(Int64?.self, forKey: .templateId)
        }
        if decoderContainer.contains(.templateName)
        {
            self.templateName = try decoderContainer.decode(String?.self, forKey: .templateName)
        }
        if decoderContainer.contains(.templateRules)
        {
            self.templateRules = try decoderContainer.decode([AlarmVo?]?.self, forKey: .templateRules)
        }
        if decoderContainer.contains(.templateRulesString)
        {
            self.templateRulesString = try decoderContainer.decode([String?]?.self, forKey: .templateRulesString)
        }
        if decoderContainer.contains(.templateType)
        {
            self.templateType = try decoderContainer.decode(Int64?.self, forKey: .templateType)
        }
        if decoderContainer.contains(.updateTime)
        {
            self.updateTime = try decoderContainer.decode(String?.self, forKey: .updateTime)
        }
    }
}
public extension TemplateVo{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: TemplateVoCodingKeys.self)
         try encoderContainer.encode(createTime, forKey: .createTime)
         try encoderContainer.encode(descriptionValue, forKey: .descriptionValue)
         try encoderContainer.encode(pin, forKey: .pin)
         try encoderContainer.encode(rulesCount, forKey: .rulesCount)
         try encoderContainer.encode(serviceCode, forKey: .serviceCode)
         try encoderContainer.encode(templateId, forKey: .templateId)
         try encoderContainer.encode(templateName, forKey: .templateName)
         try encoderContainer.encode(templateRules, forKey: .templateRules)
         try encoderContainer.encode(templateRulesString, forKey: .templateRulesString)
         try encoderContainer.encode(templateType, forKey: .templateType)
         try encoderContainer.encode(updateTime, forKey: .updateTime)
    }
}
///  describedAlarm
public class DescribedAlarm:NSObject,Codable{
    /// 计算单位
    var calculateUnit:String?
    /// 统计方法：平均值&#x3D;avg、最大值&#x3D;max、最小值&#x3D;min
    var calculation:String?
    /// 创建时间
    var createTime:String?
    /// 降采样方法
    var downSample:String?
    /// 是否启用
    var enabled:Int64?
    /// 报警规则ID
    var id:String?
    /// 监控项
    var metric:String?
    /// 监控项名称
    var metricName:String?
    /// NoticeLevel
    var noticeLevel:NoticeLevel?
    /// 告警周期
    var noticePeriod:Int64?
    /// gt, gte, lt, lte, eq, ne
    var operation:String?
    /// 统计周期（单位：分钟）
    var period:Int64?
    /// 地域信息
    var region:String?
    /// 资源id
    var resourceId:String?
    /// 规则名称
    var ruleName:String?
    /// 产品线编码
    var serviceCode:String?
    /// 监控项状态：1正常，2告警，4数据不足
    var status:Int64?
    /// 标签
    var tags:[String:String?]?
    /// 告警阈值
    var threshold:Double?
    /// 告警次数
    var times:Int64?
    /// 回调content
    var webHookContent:String?
    /// webHook协议
    var webHookProtocol:String?
    /// 回调secret，用户请求签名，防伪造
    var webHookSecret:String?
    /// 回调url
    var webHookUrl:String?



    public override init(){
            super.init()
    }

    enum DescribedAlarmCodingKeys: String, CodingKey {
        case calculateUnit
        case calculation
        case createTime
        case downSample
        case enabled
        case id
        case metric
        case metricName
        case noticeLevel
        case noticePeriod
        case operation
        case period
        case region
        case resourceId
        case ruleName
        case serviceCode
        case status
        case tags
        case threshold
        case times
        case webHookContent
        case webHookProtocol
        case webHookSecret
        case webHookUrl
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: DescribedAlarmCodingKeys.self)
        if decoderContainer.contains(.calculateUnit)
        {
            self.calculateUnit = try decoderContainer.decode(String?.self, forKey: .calculateUnit)
        }
        if decoderContainer.contains(.calculation)
        {
            self.calculation = try decoderContainer.decode(String?.self, forKey: .calculation)
        }
        if decoderContainer.contains(.createTime)
        {
            self.createTime = try decoderContainer.decode(String?.self, forKey: .createTime)
        }
        if decoderContainer.contains(.downSample)
        {
            self.downSample = try decoderContainer.decode(String?.self, forKey: .downSample)
        }
        if decoderContainer.contains(.enabled)
        {
            self.enabled = try decoderContainer.decode(Int64?.self, forKey: .enabled)
        }
        if decoderContainer.contains(.id)
        {
            self.id = try decoderContainer.decode(String?.self, forKey: .id)
        }
        if decoderContainer.contains(.metric)
        {
            self.metric = try decoderContainer.decode(String?.self, forKey: .metric)
        }
        if decoderContainer.contains(.metricName)
        {
            self.metricName = try decoderContainer.decode(String?.self, forKey: .metricName)
        }
        if decoderContainer.contains(.noticeLevel)
        {
            self.noticeLevel = try decoderContainer.decode(NoticeLevel?.self, forKey: .noticeLevel)
        }
        if decoderContainer.contains(.noticePeriod)
        {
            self.noticePeriod = try decoderContainer.decode(Int64?.self, forKey: .noticePeriod)
        }
        if decoderContainer.contains(.operation)
        {
            self.operation = try decoderContainer.decode(String?.self, forKey: .operation)
        }
        if decoderContainer.contains(.period)
        {
            self.period = try decoderContainer.decode(Int64?.self, forKey: .period)
        }
        if decoderContainer.contains(.region)
        {
            self.region = try decoderContainer.decode(String?.self, forKey: .region)
        }
        if decoderContainer.contains(.resourceId)
        {
            self.resourceId = try decoderContainer.decode(String?.self, forKey: .resourceId)
        }
        if decoderContainer.contains(.ruleName)
        {
            self.ruleName = try decoderContainer.decode(String?.self, forKey: .ruleName)
        }
        if decoderContainer.contains(.serviceCode)
        {
            self.serviceCode = try decoderContainer.decode(String?.self, forKey: .serviceCode)
        }
        if decoderContainer.contains(.status)
        {
            self.status = try decoderContainer.decode(Int64?.self, forKey: .status)
        }
        if decoderContainer.contains(.tags)
        {
            self.tags = try decoderContainer.decode([String:String?]?.self, forKey: .tags)
        }
        if decoderContainer.contains(.threshold)
        {
            self.threshold = try decoderContainer.decode(Double?.self, forKey: .threshold)
        }
        if decoderContainer.contains(.times)
        {
            self.times = try decoderContainer.decode(Int64?.self, forKey: .times)
        }
        if decoderContainer.contains(.webHookContent)
        {
            self.webHookContent = try decoderContainer.decode(String?.self, forKey: .webHookContent)
        }
        if decoderContainer.contains(.webHookProtocol)
        {
            self.webHookProtocol = try decoderContainer.decode(String?.self, forKey: .webHookProtocol)
        }
        if decoderContainer.contains(.webHookSecret)
        {
            self.webHookSecret = try decoderContainer.decode(String?.self, forKey: .webHookSecret)
        }
        if decoderContainer.contains(.webHookUrl)
        {
            self.webHookUrl = try decoderContainer.decode(String?.self, forKey: .webHookUrl)
        }
    }
}
public extension DescribedAlarm{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: DescribedAlarmCodingKeys.self)
         try encoderContainer.encode(calculateUnit, forKey: .calculateUnit)
         try encoderContainer.encode(calculation, forKey: .calculation)
         try encoderContainer.encode(createTime, forKey: .createTime)
         try encoderContainer.encode(downSample, forKey: .downSample)
         try encoderContainer.encode(enabled, forKey: .enabled)
         try encoderContainer.encode(id, forKey: .id)
         try encoderContainer.encode(metric, forKey: .metric)
         try encoderContainer.encode(metricName, forKey: .metricName)
         try encoderContainer.encode(noticeLevel, forKey: .noticeLevel)
         try encoderContainer.encode(noticePeriod, forKey: .noticePeriod)
         try encoderContainer.encode(operation, forKey: .operation)
         try encoderContainer.encode(period, forKey: .period)
         try encoderContainer.encode(region, forKey: .region)
         try encoderContainer.encode(resourceId, forKey: .resourceId)
         try encoderContainer.encode(ruleName, forKey: .ruleName)
         try encoderContainer.encode(serviceCode, forKey: .serviceCode)
         try encoderContainer.encode(status, forKey: .status)
         try encoderContainer.encode(tags, forKey: .tags)
         try encoderContainer.encode(threshold, forKey: .threshold)
         try encoderContainer.encode(times, forKey: .times)
         try encoderContainer.encode(webHookContent, forKey: .webHookContent)
         try encoderContainer.encode(webHookProtocol, forKey: .webHookProtocol)
         try encoderContainer.encode(webHookSecret, forKey: .webHookSecret)
         try encoderContainer.encode(webHookUrl, forKey: .webHookUrl)
    }
}
///  location
public class Location:NSObject,Codable{
    /// Sloc
    var sloc:String?
    /// SlocName
    var slocName:String?



    public override init(){
            super.init()
    }

    enum LocationCodingKeys: String, CodingKey {
        case sloc
        case slocName
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: LocationCodingKeys.self)
        if decoderContainer.contains(.sloc)
        {
            self.sloc = try decoderContainer.decode(String?.self, forKey: .sloc)
        }
        if decoderContainer.contains(.slocName)
        {
            self.slocName = try decoderContainer.decode(String?.self, forKey: .slocName)
        }
    }
}
public extension Location{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: LocationCodingKeys.self)
         try encoderContainer.encode(sloc, forKey: .sloc)
         try encoderContainer.encode(slocName, forKey: .slocName)
    }
}
///  createTemplateResponseEnd
public class CreateTemplateResponseEnd:NSObject,Codable{
    /// 是否创建成功
    var success:Bool?
    /// 创建成功的模板id
    var templateId:Int64?



    public override init(){
            super.init()
    }

    enum CreateTemplateResponseEndCodingKeys: String, CodingKey {
        case success
        case templateId
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: CreateTemplateResponseEndCodingKeys.self)
        if decoderContainer.contains(.success)
        {
            self.success = try decoderContainer.decode(Bool?.self, forKey: .success)
        }
        if decoderContainer.contains(.templateId)
        {
            self.templateId = try decoderContainer.decode(Int64?.self, forKey: .templateId)
        }
    }
}
public extension CreateTemplateResponseEnd{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: CreateTemplateResponseEndCodingKeys.self)
         try encoderContainer.encode(success, forKey: .success)
         try encoderContainer.encode(templateId, forKey: .templateId)
    }
}
///  groupInfo
public class GroupInfo:NSObject,Codable{
    /// 监控图的展示方式
    var charts:[Chart?]?
    /// 分组groupCode
    var groupCode:String?
    /// 分组名称
    var groupName:String?
    /// 分组下metric对应的tags
    var tags:[String:String?]?
    /// 分组的webCode
    var webCode:String?



    public override init(){
            super.init()
    }

    enum GroupInfoCodingKeys: String, CodingKey {
        case charts
        case groupCode
        case groupName
        case tags
        case webCode
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: GroupInfoCodingKeys.self)
        if decoderContainer.contains(.charts)
        {
            self.charts = try decoderContainer.decode([Chart?]?.self, forKey: .charts)
        }
        if decoderContainer.contains(.groupCode)
        {
            self.groupCode = try decoderContainer.decode(String?.self, forKey: .groupCode)
        }
        if decoderContainer.contains(.groupName)
        {
            self.groupName = try decoderContainer.decode(String?.self, forKey: .groupName)
        }
        if decoderContainer.contains(.tags)
        {
            self.tags = try decoderContainer.decode([String:String?]?.self, forKey: .tags)
        }
        if decoderContainer.contains(.webCode)
        {
            self.webCode = try decoderContainer.decode(String?.self, forKey: .webCode)
        }
    }
}
public extension GroupInfo{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: GroupInfoCodingKeys.self)
         try encoderContainer.encode(charts, forKey: .charts)
         try encoderContainer.encode(groupCode, forKey: .groupCode)
         try encoderContainer.encode(groupName, forKey: .groupName)
         try encoderContainer.encode(tags, forKey: .tags)
         try encoderContainer.encode(webCode, forKey: .webCode)
    }
}
///  serviceInfo
public class ServiceInfo:NSObject,Codable{
    /// GroupTree
    var groupTree:GroupTree?
    /// 产品线下的分组信息
    var metricGroup:[GroupInfo?]?
    /// 上报延迟
    var metricsTimeDelay:Int64?
    /// 产品线ServiceCode
    var serviceCode:String?
    /// 产品线名称
    var serviceName:String?
    /// 上报的时间间隔
    var timeInterval:Int64?



    public override init(){
            super.init()
    }

    enum ServiceInfoCodingKeys: String, CodingKey {
        case groupTree
        case metricGroup
        case metricsTimeDelay
        case serviceCode
        case serviceName
        case timeInterval
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: ServiceInfoCodingKeys.self)
        if decoderContainer.contains(.groupTree)
        {
            self.groupTree = try decoderContainer.decode(GroupTree?.self, forKey: .groupTree)
        }
        if decoderContainer.contains(.metricGroup)
        {
            self.metricGroup = try decoderContainer.decode([GroupInfo?]?.self, forKey: .metricGroup)
        }
        if decoderContainer.contains(.metricsTimeDelay)
        {
            self.metricsTimeDelay = try decoderContainer.decode(Int64?.self, forKey: .metricsTimeDelay)
        }
        if decoderContainer.contains(.serviceCode)
        {
            self.serviceCode = try decoderContainer.decode(String?.self, forKey: .serviceCode)
        }
        if decoderContainer.contains(.serviceName)
        {
            self.serviceName = try decoderContainer.decode(String?.self, forKey: .serviceName)
        }
        if decoderContainer.contains(.timeInterval)
        {
            self.timeInterval = try decoderContainer.decode(Int64?.self, forKey: .timeInterval)
        }
    }
}
public extension ServiceInfo{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: ServiceInfoCodingKeys.self)
         try encoderContainer.encode(groupTree, forKey: .groupTree)
         try encoderContainer.encode(metricGroup, forKey: .metricGroup)
         try encoderContainer.encode(metricsTimeDelay, forKey: .metricsTimeDelay)
         try encoderContainer.encode(serviceCode, forKey: .serviceCode)
         try encoderContainer.encode(serviceName, forKey: .serviceName)
         try encoderContainer.encode(timeInterval, forKey: .timeInterval)
    }
}
///  describeTemplatesResponseEnd
public class DescribeTemplatesResponseEnd:NSObject,Codable{
    /// 总页数
    var numberPages:Int64?
    /// 总记录数
    var numberRecords:Int64?
    /// 当前页码
    var pageNumber:Int64?
    /// 分页大小
    var pageSize:Int64?
    /// 当查询用户自定义模板时，表示该用户目前已有的自定义模板总数量;当查询默认模板时，表示该用户目前已有的默认模板总数量
    var templateCount:Int64?
    /// 模板列表
    var templateList:[TemplateVo?]?



    public override init(){
            super.init()
    }

    enum DescribeTemplatesResponseEndCodingKeys: String, CodingKey {
        case numberPages
        case numberRecords
        case pageNumber
        case pageSize
        case templateCount
        case templateList
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: DescribeTemplatesResponseEndCodingKeys.self)
        if decoderContainer.contains(.numberPages)
        {
            self.numberPages = try decoderContainer.decode(Int64?.self, forKey: .numberPages)
        }
        if decoderContainer.contains(.numberRecords)
        {
            self.numberRecords = try decoderContainer.decode(Int64?.self, forKey: .numberRecords)
        }
        if decoderContainer.contains(.pageNumber)
        {
            self.pageNumber = try decoderContainer.decode(Int64?.self, forKey: .pageNumber)
        }
        if decoderContainer.contains(.pageSize)
        {
            self.pageSize = try decoderContainer.decode(Int64?.self, forKey: .pageSize)
        }
        if decoderContainer.contains(.templateCount)
        {
            self.templateCount = try decoderContainer.decode(Int64?.self, forKey: .templateCount)
        }
        if decoderContainer.contains(.templateList)
        {
            self.templateList = try decoderContainer.decode([TemplateVo?]?.self, forKey: .templateList)
        }
    }
}
public extension DescribeTemplatesResponseEnd{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: DescribeTemplatesResponseEndCodingKeys.self)
         try encoderContainer.encode(numberPages, forKey: .numberPages)
         try encoderContainer.encode(numberRecords, forKey: .numberRecords)
         try encoderContainer.encode(pageNumber, forKey: .pageNumber)
         try encoderContainer.encode(pageSize, forKey: .pageSize)
         try encoderContainer.encode(templateCount, forKey: .templateCount)
         try encoderContainer.encode(templateList, forKey: .templateList)
    }
}
///  resource
public class Resource:NSObject,Codable{
    /// Name
    var name:String?
    /// RegionId
    var regionId:String?
    /// ResourceId
    var resourceId:String?



    public override init(){
            super.init()
    }

    enum ResourceCodingKeys: String, CodingKey {
        case name
        case regionId
        case resourceId
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: ResourceCodingKeys.self)
        if decoderContainer.contains(.name)
        {
            self.name = try decoderContainer.decode(String?.self, forKey: .name)
        }
        if decoderContainer.contains(.regionId)
        {
            self.regionId = try decoderContainer.decode(String?.self, forKey: .regionId)
        }
        if decoderContainer.contains(.resourceId)
        {
            self.resourceId = try decoderContainer.decode(String?.self, forKey: .resourceId)
        }
    }
}
public extension Resource{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: ResourceCodingKeys.self)
         try encoderContainer.encode(name, forKey: .name)
         try encoderContainer.encode(regionId, forKey: .regionId)
         try encoderContainer.encode(resourceId, forKey: .resourceId)
    }
}
///  enableAlarmsSpec
public class EnableAlarmsSpec:NSObject,Codable{
    /// 告警规则的ID列表
    /// Required:true
    var ids:[String?]?



    public  init(ids:[String?]?){
             self.ids = ids
    }

    enum EnableAlarmsSpecCodingKeys: String, CodingKey {
        case ids
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: EnableAlarmsSpecCodingKeys.self)
        self.ids = try decoderContainer.decode([String?]?.self, forKey: .ids)
    }
}
public extension EnableAlarmsSpec{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: EnableAlarmsSpecCodingKeys.self)
         try encoderContainer.encode(ids, forKey: .ids)
    }
}
///  deleteTemplateResponseEnd
public class DeleteTemplateResponseEnd:NSObject,Codable{
    /// 是否删除成功
    var success:Bool?



    public override init(){
            super.init()
    }

    enum DeleteTemplateResponseEndCodingKeys: String, CodingKey {
        case success
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: DeleteTemplateResponseEndCodingKeys.self)
        if decoderContainer.contains(.success)
        {
            self.success = try decoderContainer.decode(Bool?.self, forKey: .success)
        }
    }
}
public extension DeleteTemplateResponseEnd{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: DeleteTemplateResponseEndCodingKeys.self)
         try encoderContainer.encode(success, forKey: .success)
    }
}
///  describeAlarmHistoryResponseEnd
public class DescribeAlarmHistoryResponseEnd:NSObject,Codable{
    /// 告警历史列表
    var alarmHistoryList:[DescribedAlarmHistory?]?
    /// 总数
    var total:Int64?



    public override init(){
            super.init()
    }

    enum DescribeAlarmHistoryResponseEndCodingKeys: String, CodingKey {
        case alarmHistoryList
        case total
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: DescribeAlarmHistoryResponseEndCodingKeys.self)
        if decoderContainer.contains(.alarmHistoryList)
        {
            self.alarmHistoryList = try decoderContainer.decode([DescribedAlarmHistory?]?.self, forKey: .alarmHistoryList)
        }
        if decoderContainer.contains(.total)
        {
            self.total = try decoderContainer.decode(Int64?.self, forKey: .total)
        }
    }
}
public extension DescribeAlarmHistoryResponseEnd{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: DescribeAlarmHistoryResponseEndCodingKeys.self)
         try encoderContainer.encode(alarmHistoryList, forKey: .alarmHistoryList)
         try encoderContainer.encode(total, forKey: .total)
    }
}
///  err
public class Err:NSObject,Codable{
    /// Code
    var code:Int64?
    /// Details
    var details:AnyObject?
    /// Message
    var message:String?
    /// Status
    var status:String?



    public override init(){
            super.init()
    }

    enum ErrCodingKeys: String, CodingKey {
        case code
        case details
        case message
        case status
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: ErrCodingKeys.self)
        if decoderContainer.contains(.code)
        {
            self.code = try decoderContainer.decode(Int64?.self, forKey: .code)
        }
        if decoderContainer.contains(.message)
        {
            self.message = try decoderContainer.decode(String?.self, forKey: .message)
        }
        if decoderContainer.contains(.status)
        {
            self.status = try decoderContainer.decode(String?.self, forKey: .status)
        }
    }
}
public extension Err{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: ErrCodingKeys.self)
         try encoderContainer.encode(code, forKey: .code)
         try encoderContainer.encode(message, forKey: .message)
         try encoderContainer.encode(status, forKey: .status)
    }
}
///  describeMetricDataSpec
public class DescribeMetricDataSpec:NSObject,Codable{
    /// 聚合方式，可选值参考:sum、avg、min、max
    var aggrType:String?
    /// 资源的维度。当serviceCode下存在多个维度时，查询数据必须指定相应的维度
    var dimension:String?
    /// 采样方式，可选值参考：sum、avg、last、min、max
    var downSampleType:String?
    /// 查询时间范围的结束时间， UTC时间，格式：2016-12-11T00:00:00+0800（为空时，将由startTime与timeInterval计算得出）（注意在url中+要转译为%2B故url中为2016-12-11T00:00:00%2B0800）
      /// in: query
    var endTime:String?
    /// 是否对查询的tags分组
      /// in: query
    var groupBy:Bool?
    /// 是否求速率
      /// in: query
    var rate:Bool?
    /// 资源的uuid
    /// Required:true
    var resourceId:String
    /// 资源的类型，取值vm, lb, ip, database 等,&lt;a href&#x3D;&quot;https://docs.jdcloud.com/cn/monitoring/api/describeservices?content&#x3D;API&amp;SOP&#x3D;JDCloud&quot;&gt;describeServices&lt;/a&gt;：查询己接入云监控的产品线列表，当产品线下有多个分组时，查询分组对应的监控项，serviceCode请传对应分组的groupCode字段值
    var serviceCode:String?
    /// 查询时间范围的开始时间， UTC时间，格式：2016-12-11T00:00:00+0800（注意在url中+要转译为%2B故url中为2016-12-11T00:00:00%2B0800）
      /// in: query
    var startTime:String?
    /// 监控指标数据的维度信息,根据tags来筛选指标数据不同的维度
      /// in: query
    var tags:[TagFilter?]?
    /// 时间间隔：1h，6h，12h，1d，3d，7d，14d，固定时间间隔，timeInterval默认为1h，当前时间往 前1h
      /// in: query
    var timeInterval:String?



    public  init(resourceId:String){
             self.resourceId = resourceId
    }

    enum DescribeMetricDataSpecCodingKeys: String, CodingKey {
        case aggrType
        case dimension
        case downSampleType
        case endTime
        case groupBy
        case rate
        case resourceId
        case serviceCode
        case startTime
        case tags
        case timeInterval
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: DescribeMetricDataSpecCodingKeys.self)
        if decoderContainer.contains(.aggrType)
        {
            self.aggrType = try decoderContainer.decode(String?.self, forKey: .aggrType)
        }
        if decoderContainer.contains(.dimension)
        {
            self.dimension = try decoderContainer.decode(String?.self, forKey: .dimension)
        }
        if decoderContainer.contains(.downSampleType)
        {
            self.downSampleType = try decoderContainer.decode(String?.self, forKey: .downSampleType)
        }
        if decoderContainer.contains(.endTime)
        {
            self.endTime = try decoderContainer.decode(String?.self, forKey: .endTime)
        }
        if decoderContainer.contains(.groupBy)
        {
            self.groupBy = try decoderContainer.decode(Bool?.self, forKey: .groupBy)
        }
        if decoderContainer.contains(.rate)
        {
            self.rate = try decoderContainer.decode(Bool?.self, forKey: .rate)
        }
        self.resourceId = try decoderContainer.decode(String.self, forKey: .resourceId)
        if decoderContainer.contains(.serviceCode)
        {
            self.serviceCode = try decoderContainer.decode(String?.self, forKey: .serviceCode)
        }
        if decoderContainer.contains(.startTime)
        {
            self.startTime = try decoderContainer.decode(String?.self, forKey: .startTime)
        }
        if decoderContainer.contains(.tags)
        {
            self.tags = try decoderContainer.decode([TagFilter?]?.self, forKey: .tags)
        }
        if decoderContainer.contains(.timeInterval)
        {
            self.timeInterval = try decoderContainer.decode(String?.self, forKey: .timeInterval)
        }
    }
}
public extension DescribeMetricDataSpec{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: DescribeMetricDataSpecCodingKeys.self)
         try encoderContainer.encode(aggrType, forKey: .aggrType)
         try encoderContainer.encode(dimension, forKey: .dimension)
         try encoderContainer.encode(downSampleType, forKey: .downSampleType)
         try encoderContainer.encode(endTime, forKey: .endTime)
         try encoderContainer.encode(groupBy, forKey: .groupBy)
         try encoderContainer.encode(rate, forKey: .rate)
         try encoderContainer.encode(resourceId, forKey: .resourceId)
         try encoderContainer.encode(serviceCode, forKey: .serviceCode)
         try encoderContainer.encode(startTime, forKey: .startTime)
         try encoderContainer.encode(tags, forKey: .tags)
         try encoderContainer.encode(timeInterval, forKey: .timeInterval)
    }
}
///  baseRule
public class BaseRule:NSObject,Codable{
    /// 弹性伸缩组ID
    var autoScalingPolicyId:String?
    /// 单位
    /// Required:true
    var calculateUnit:String
    /// 统计方法，必须与定义的metric一致，可选值列表：avg,sum,max,min
    /// Required:true
    var calculation:String
    /// 降采样函数
    /// Required:true
    var downSample:String
    /// 监控项唯一标识，可根据DescribeMetricsForCreateAlarm接口查询各产品线可用的监控项（创建规则时使用Metric字段）。格式：metric:downsample
    /// Required:true
    var metric:String
    /// NoticeLevel
    var noticeLevel:NoticeLevel?
    /// 通知周期，单位：小时
    /// Required:true
    var noticePeriod:Int64
    /// 报警比较符，只能为以下几种lte(&lt;&#x3D;),lt(&lt;),gt(&gt;),gte(&gt;&#x3D;),eq(&#x3D;&#x3D;),ne(!&#x3D;)
    /// Required:true
    var operation:String
    /// 查询指标的周期，单位为分钟,目前支持的取值：1,2，5，10,15，30，60
    /// Required:true
    var period:Int64
    /// 规则名称，规则名称，最大长度42个字符，只允许中英文、数字、&#39;&#39;-&#39;&#39;和&quot;_&quot;
    var ruleName:String?
    /// 规则类型, 1云监控的规则， 6站点监控。默认为1
    var ruleType:Int64?
    /// 多值标签
    var tags:[String:String?]?
    /// 报警阈值，目前只开放数值类型功能
    /// Required:true
    var threshold:Double
    /// 连续探测几次都满足阈值条件时报警，可选值:1,2,3,5,10,15,30,60
    /// Required:true
    var times:Int64



    public  init(calculateUnit:String,calculation:String,downSample:String,metric:String,noticePeriod:Int64,operation:String,period:Int64,threshold:Double,times:Int64){
             self.calculateUnit = calculateUnit
             self.calculation = calculation
             self.downSample = downSample
             self.metric = metric
             self.noticePeriod = noticePeriod
             self.operation = operation
             self.period = period
             self.threshold = threshold
             self.times = times
    }

    enum BaseRuleCodingKeys: String, CodingKey {
        case autoScalingPolicyId
        case calculateUnit
        case calculation
        case downSample
        case metric
        case noticeLevel
        case noticePeriod
        case operation
        case period
        case ruleName
        case ruleType
        case tags
        case threshold
        case times
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: BaseRuleCodingKeys.self)
        if decoderContainer.contains(.autoScalingPolicyId)
        {
            self.autoScalingPolicyId = try decoderContainer.decode(String?.self, forKey: .autoScalingPolicyId)
        }
        self.calculateUnit = try decoderContainer.decode(String.self, forKey: .calculateUnit)
        self.calculation = try decoderContainer.decode(String.self, forKey: .calculation)
        self.downSample = try decoderContainer.decode(String.self, forKey: .downSample)
        self.metric = try decoderContainer.decode(String.self, forKey: .metric)
        if decoderContainer.contains(.noticeLevel)
        {
            self.noticeLevel = try decoderContainer.decode(NoticeLevel?.self, forKey: .noticeLevel)
        }
        self.noticePeriod = try decoderContainer.decode(Int64.self, forKey: .noticePeriod)
        self.operation = try decoderContainer.decode(String.self, forKey: .operation)
        self.period = try decoderContainer.decode(Int64.self, forKey: .period)
        if decoderContainer.contains(.ruleName)
        {
            self.ruleName = try decoderContainer.decode(String?.self, forKey: .ruleName)
        }
        if decoderContainer.contains(.ruleType)
        {
            self.ruleType = try decoderContainer.decode(Int64?.self, forKey: .ruleType)
        }
        if decoderContainer.contains(.tags)
        {
            self.tags = try decoderContainer.decode([String:String?]?.self, forKey: .tags)
        }
        self.threshold = try decoderContainer.decode(Double.self, forKey: .threshold)
        self.times = try decoderContainer.decode(Int64.self, forKey: .times)
    }
}
public extension BaseRule{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: BaseRuleCodingKeys.self)
         try encoderContainer.encode(autoScalingPolicyId, forKey: .autoScalingPolicyId)
         try encoderContainer.encode(calculateUnit, forKey: .calculateUnit)
         try encoderContainer.encode(calculation, forKey: .calculation)
         try encoderContainer.encode(downSample, forKey: .downSample)
         try encoderContainer.encode(metric, forKey: .metric)
         try encoderContainer.encode(noticeLevel, forKey: .noticeLevel)
         try encoderContainer.encode(noticePeriod, forKey: .noticePeriod)
         try encoderContainer.encode(operation, forKey: .operation)
         try encoderContainer.encode(period, forKey: .period)
         try encoderContainer.encode(ruleName, forKey: .ruleName)
         try encoderContainer.encode(ruleType, forKey: .ruleType)
         try encoderContainer.encode(tags, forKey: .tags)
         try encoderContainer.encode(threshold, forKey: .threshold)
         try encoderContainer.encode(times, forKey: .times)
    }
}
///  describeTemplateByIDSpec
public class DescribeTemplateByIDSpec:NSObject,Codable{
    /// 模板类型，区分默认模板和用户自定义模板：1表示默认模板，2表示用户自定义模板
      /// in: query
    /// Required:true
    var templateType:Int64



    public  init(templateType:Int64){
             self.templateType = templateType
    }

    enum DescribeTemplateByIDSpecCodingKeys: String, CodingKey {
        case templateType
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: DescribeTemplateByIDSpecCodingKeys.self)
        self.templateType = try decoderContainer.decode(Int64.self, forKey: .templateType)
    }
}
public extension DescribeTemplateByIDSpec{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: DescribeTemplateByIDSpecCodingKeys.self)
         try encoderContainer.encode(templateType, forKey: .templateType)
    }
}
///  createTemplateSpec
public class CreateTemplateSpec:NSObject,Codable{
    /// 幂等性校验参数,最长36位
    /// Required:true
    var clientToken:String
    /// 模板描述
    var descriptionValue:String?
    /// 规则的资源类型
    /// Required:true
    var ruleServiceCode:String
    /// 模板的资源类型
    /// Required:true
    var serviceCode:String
    /// 模板名称,长度1-32个字符，只允许中英文、数字、&#39;&#39;-&#39;&#39;和&quot;_&quot;
    /// Required:true
    var templateName:String
    /// 模板内包含的规则
    /// Required:true
    var templateRules:[BaseRuleT?]?



    public  init(clientToken:String,ruleServiceCode:String,serviceCode:String,templateName:String,templateRules:[BaseRuleT?]?){
             self.clientToken = clientToken
             self.ruleServiceCode = ruleServiceCode
             self.serviceCode = serviceCode
             self.templateName = templateName
             self.templateRules = templateRules
    }

    enum CreateTemplateSpecCodingKeys: String, CodingKey {
        case clientToken
        case descriptionValue = "description"
        case ruleServiceCode
        case serviceCode
        case templateName
        case templateRules
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: CreateTemplateSpecCodingKeys.self)
        self.clientToken = try decoderContainer.decode(String.self, forKey: .clientToken)
        if decoderContainer.contains(.descriptionValue)
        {
            self.descriptionValue = try decoderContainer.decode(String?.self, forKey: .descriptionValue)
        }
        self.ruleServiceCode = try decoderContainer.decode(String.self, forKey: .ruleServiceCode)
        self.serviceCode = try decoderContainer.decode(String.self, forKey: .serviceCode)
        self.templateName = try decoderContainer.decode(String.self, forKey: .templateName)
        self.templateRules = try decoderContainer.decode([BaseRuleT?]?.self, forKey: .templateRules)
    }
}
public extension CreateTemplateSpec{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: CreateTemplateSpecCodingKeys.self)
         try encoderContainer.encode(clientToken, forKey: .clientToken)
         try encoderContainer.encode(descriptionValue, forKey: .descriptionValue)
         try encoderContainer.encode(ruleServiceCode, forKey: .ruleServiceCode)
         try encoderContainer.encode(serviceCode, forKey: .serviceCode)
         try encoderContainer.encode(templateName, forKey: .templateName)
         try encoderContainer.encode(templateRules, forKey: .templateRules)
    }
}
///  updateWebHookReq
public class UpdateWebHookReq:NSObject,Codable{
    /// 是否启用, 1表示启用webHook，0表示禁用webHook，默认为1
    var active:Int64?
    /// webHook content
    var content:String?
    /// webHook 协议,http或者https
    /// Required:true
    var protocolValue:String
    /// webHook secret，用户请求签名，防伪造
    var secret:String?
    /// webHook url
    /// Required:true
    var url:String



    public  init(protocolValue:String,url:String){
             self.protocolValue = protocolValue
             self.url = url
    }

    enum UpdateWebHookReqCodingKeys: String, CodingKey {
        case active
        case content
        case protocolValue = "protocol"
        case secret
        case url
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: UpdateWebHookReqCodingKeys.self)
        if decoderContainer.contains(.active)
        {
            self.active = try decoderContainer.decode(Int64?.self, forKey: .active)
        }
        if decoderContainer.contains(.content)
        {
            self.content = try decoderContainer.decode(String?.self, forKey: .content)
        }
        self.protocolValue = try decoderContainer.decode(String.self, forKey: .protocolValue)
        if decoderContainer.contains(.secret)
        {
            self.secret = try decoderContainer.decode(String?.self, forKey: .secret)
        }
        self.url = try decoderContainer.decode(String.self, forKey: .url)
    }
}
public extension UpdateWebHookReq{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: UpdateWebHookReqCodingKeys.self)
         try encoderContainer.encode(active, forKey: .active)
         try encoderContainer.encode(content, forKey: .content)
         try encoderContainer.encode(protocolValue, forKey: .protocolValue)
         try encoderContainer.encode(secret, forKey: .secret)
         try encoderContainer.encode(url, forKey: .url)
    }
}
///  groupAlarm
public class GroupAlarm:NSObject,Codable{
    /// 报警规则ID
    var alarmId:String?
    /// 告警通知联系人
    var baseContact:[BaseContact?]?
    /// 创建时间
    var createTime:String?
    /// 是否启用, 1表示启用规则，0表示禁用规则，默认为1
    var enabled:Int64?
    /// 通知策略
    var noticeOption:[NoticeOption?]?
    /// ResourceOption
    /// Required:true
    var resourceOption:ResourceOption
    /// 规则名称，规则名称，最大长度42个字符，只允许中英文、数字、&#39;&#39;-&#39;&#39;和&quot;_&quot;
    /// Required:true
    var ruleName:String
    /// RuleOption
    /// Required:true
    var ruleOption:RuleOption
    /// 规则类型, 默认为resourceMonitor
    var ruleType:String?
    /// 规则版本  v1  v2
    var ruleVersion:String?
    /// 产品线标识，规则对应的serviceCode
    /// Required:true
    var serviceCode:String
    /// 监控项状态：-1 未启用 1正常，2告警，4数据不足
    var status:Int64?
    /// WebHookOption
    var webHookOption:WebHookOption?



    public  init(resourceOption:ResourceOption,ruleName:String,ruleOption:RuleOption,serviceCode:String){
             self.resourceOption = resourceOption
             self.ruleName = ruleName
             self.ruleOption = ruleOption
             self.serviceCode = serviceCode
    }

    enum GroupAlarmCodingKeys: String, CodingKey {
        case alarmId
        case baseContact
        case createTime
        case enabled
        case noticeOption
        case resourceOption
        case ruleName
        case ruleOption
        case ruleType
        case ruleVersion
        case serviceCode
        case status
        case webHookOption
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: GroupAlarmCodingKeys.self)
        if decoderContainer.contains(.alarmId)
        {
            self.alarmId = try decoderContainer.decode(String?.self, forKey: .alarmId)
        }
        if decoderContainer.contains(.baseContact)
        {
            self.baseContact = try decoderContainer.decode([BaseContact?]?.self, forKey: .baseContact)
        }
        if decoderContainer.contains(.createTime)
        {
            self.createTime = try decoderContainer.decode(String?.self, forKey: .createTime)
        }
        if decoderContainer.contains(.enabled)
        {
            self.enabled = try decoderContainer.decode(Int64?.self, forKey: .enabled)
        }
        if decoderContainer.contains(.noticeOption)
        {
            self.noticeOption = try decoderContainer.decode([NoticeOption?]?.self, forKey: .noticeOption)
        }
        self.resourceOption = try decoderContainer.decode(ResourceOption.self, forKey: .resourceOption)
        self.ruleName = try decoderContainer.decode(String.self, forKey: .ruleName)
        self.ruleOption = try decoderContainer.decode(RuleOption.self, forKey: .ruleOption)
        if decoderContainer.contains(.ruleType)
        {
            self.ruleType = try decoderContainer.decode(String?.self, forKey: .ruleType)
        }
        if decoderContainer.contains(.ruleVersion)
        {
            self.ruleVersion = try decoderContainer.decode(String?.self, forKey: .ruleVersion)
        }
        self.serviceCode = try decoderContainer.decode(String.self, forKey: .serviceCode)
        if decoderContainer.contains(.status)
        {
            self.status = try decoderContainer.decode(Int64?.self, forKey: .status)
        }
        if decoderContainer.contains(.webHookOption)
        {
            self.webHookOption = try decoderContainer.decode(WebHookOption?.self, forKey: .webHookOption)
        }
    }
}
public extension GroupAlarm{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: GroupAlarmCodingKeys.self)
         try encoderContainer.encode(alarmId, forKey: .alarmId)
         try encoderContainer.encode(baseContact, forKey: .baseContact)
         try encoderContainer.encode(createTime, forKey: .createTime)
         try encoderContainer.encode(enabled, forKey: .enabled)
         try encoderContainer.encode(noticeOption, forKey: .noticeOption)
         try encoderContainer.encode(resourceOption, forKey: .resourceOption)
         try encoderContainer.encode(ruleName, forKey: .ruleName)
         try encoderContainer.encode(ruleOption, forKey: .ruleOption)
         try encoderContainer.encode(ruleType, forKey: .ruleType)
         try encoderContainer.encode(ruleVersion, forKey: .ruleVersion)
         try encoderContainer.encode(serviceCode, forKey: .serviceCode)
         try encoderContainer.encode(status, forKey: .status)
         try encoderContainer.encode(webHookOption, forKey: .webHookOption)
    }
}
///  describeMetricsForCreateAlarmEnd
public class DescribeMetricsForCreateAlarmEnd:NSObject,Codable{
    /// ServiceCodeList
    var serviceCodeList:[ServiceCodeMetrics?]?



    public override init(){
            super.init()
    }

    enum DescribeMetricsForCreateAlarmEndCodingKeys: String, CodingKey {
        case serviceCodeList
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: DescribeMetricsForCreateAlarmEndCodingKeys.self)
        if decoderContainer.contains(.serviceCodeList)
        {
            self.serviceCodeList = try decoderContainer.decode([ServiceCodeMetrics?]?.self, forKey: .serviceCodeList)
        }
    }
}
public extension DescribeMetricsForCreateAlarmEnd{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: DescribeMetricsForCreateAlarmEndCodingKeys.self)
         try encoderContainer.encode(serviceCodeList, forKey: .serviceCodeList)
    }
}
///  serviceCodeMetrics
public class ServiceCodeMetrics:NSObject,Codable{
    /// Metrics
    var metrics:[MetricDetail?]?
    /// ServiceCode
    var serviceCode:String?



    public override init(){
            super.init()
    }

    enum ServiceCodeMetricsCodingKeys: String, CodingKey {
        case metrics
        case serviceCode
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: ServiceCodeMetricsCodingKeys.self)
        if decoderContainer.contains(.metrics)
        {
            self.metrics = try decoderContainer.decode([MetricDetail?]?.self, forKey: .metrics)
        }
        if decoderContainer.contains(.serviceCode)
        {
            self.serviceCode = try decoderContainer.decode(String?.self, forKey: .serviceCode)
        }
    }
}
public extension ServiceCodeMetrics{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: ServiceCodeMetricsCodingKeys.self)
         try encoderContainer.encode(metrics, forKey: .metrics)
         try encoderContainer.encode(serviceCode, forKey: .serviceCode)
    }
}
///  templateRulesVoV2
public class TemplateRulesVoV2:NSObject,Codable{
    /// 监控项单位
    var calculateUnit:String?
    /// 统计方法：平均值&#x3D;avg、最大值&#x3D;max、最小值&#x3D;min
    var calculation:String?
    /// CreateTime
    var createTime:String?
    /// 是否删除 1正常，0删除
    var deleted:Int64?
    /// downSample
    var downSample:String?
    /// 触发条件ID
    var id:Int64?
    /// 监控项
    var metric:String?
    /// 监控项ID
    var metricId:Int64?
    /// 监控项名称
    var metricName:String?
    /// NoticeLevel
    var noticeLevel:NoticeLevel?
    /// 通知周期
    var noticePeriod:Int64?
    /// 报警比较符，只能为以下几种lte(&lt;&#x3D;),lt(&lt;),gt(&gt;),gte(&gt;&#x3D;),eq(&#x3D;&#x3D;),ne(!&#x3D;)
    var operation:String?
    /// 统计周期（单位：分钟）
    var period:Int64?
    /// 规则类型
    var ruleType:Int64?
    /// 规则所属资源类型
    var serviceCode:String?
    /// 监控项附属信息
    var tag:String?
    /// 多值标签
    var tags:[String:String?]?
    /// 阈值
    var threshold:Double?
    /// 连续多少次后报警
    var times:Int64?
    /// UpdateTime
    var updateTime:String?
    /// 触发条件UUID
    var uuid:String?



    public override init(){
            super.init()
    }

    enum TemplateRulesVoV2CodingKeys: String, CodingKey {
        case calculateUnit
        case calculation
        case createTime
        case deleted
        case downSample
        case id
        case metric
        case metricId
        case metricName
        case noticeLevel
        case noticePeriod
        case operation
        case period
        case ruleType
        case serviceCode
        case tag
        case tags
        case threshold
        case times
        case updateTime
        case uuid
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: TemplateRulesVoV2CodingKeys.self)
        if decoderContainer.contains(.calculateUnit)
        {
            self.calculateUnit = try decoderContainer.decode(String?.self, forKey: .calculateUnit)
        }
        if decoderContainer.contains(.calculation)
        {
            self.calculation = try decoderContainer.decode(String?.self, forKey: .calculation)
        }
        if decoderContainer.contains(.createTime)
        {
            self.createTime = try decoderContainer.decode(String?.self, forKey: .createTime)
        }
        if decoderContainer.contains(.deleted)
        {
            self.deleted = try decoderContainer.decode(Int64?.self, forKey: .deleted)
        }
        if decoderContainer.contains(.downSample)
        {
            self.downSample = try decoderContainer.decode(String?.self, forKey: .downSample)
        }
        if decoderContainer.contains(.id)
        {
            self.id = try decoderContainer.decode(Int64?.self, forKey: .id)
        }
        if decoderContainer.contains(.metric)
        {
            self.metric = try decoderContainer.decode(String?.self, forKey: .metric)
        }
        if decoderContainer.contains(.metricId)
        {
            self.metricId = try decoderContainer.decode(Int64?.self, forKey: .metricId)
        }
        if decoderContainer.contains(.metricName)
        {
            self.metricName = try decoderContainer.decode(String?.self, forKey: .metricName)
        }
        if decoderContainer.contains(.noticeLevel)
        {
            self.noticeLevel = try decoderContainer.decode(NoticeLevel?.self, forKey: .noticeLevel)
        }
        if decoderContainer.contains(.noticePeriod)
        {
            self.noticePeriod = try decoderContainer.decode(Int64?.self, forKey: .noticePeriod)
        }
        if decoderContainer.contains(.operation)
        {
            self.operation = try decoderContainer.decode(String?.self, forKey: .operation)
        }
        if decoderContainer.contains(.period)
        {
            self.period = try decoderContainer.decode(Int64?.self, forKey: .period)
        }
        if decoderContainer.contains(.ruleType)
        {
            self.ruleType = try decoderContainer.decode(Int64?.self, forKey: .ruleType)
        }
        if decoderContainer.contains(.serviceCode)
        {
            self.serviceCode = try decoderContainer.decode(String?.self, forKey: .serviceCode)
        }
        if decoderContainer.contains(.tag)
        {
            self.tag = try decoderContainer.decode(String?.self, forKey: .tag)
        }
        if decoderContainer.contains(.tags)
        {
            self.tags = try decoderContainer.decode([String:String?]?.self, forKey: .tags)
        }
        if decoderContainer.contains(.threshold)
        {
            self.threshold = try decoderContainer.decode(Double?.self, forKey: .threshold)
        }
        if decoderContainer.contains(.times)
        {
            self.times = try decoderContainer.decode(Int64?.self, forKey: .times)
        }
        if decoderContainer.contains(.updateTime)
        {
            self.updateTime = try decoderContainer.decode(String?.self, forKey: .updateTime)
        }
        if decoderContainer.contains(.uuid)
        {
            self.uuid = try decoderContainer.decode(String?.self, forKey: .uuid)
        }
    }
}
public extension TemplateRulesVoV2{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: TemplateRulesVoV2CodingKeys.self)
         try encoderContainer.encode(calculateUnit, forKey: .calculateUnit)
         try encoderContainer.encode(calculation, forKey: .calculation)
         try encoderContainer.encode(createTime, forKey: .createTime)
         try encoderContainer.encode(deleted, forKey: .deleted)
         try encoderContainer.encode(downSample, forKey: .downSample)
         try encoderContainer.encode(id, forKey: .id)
         try encoderContainer.encode(metric, forKey: .metric)
         try encoderContainer.encode(metricId, forKey: .metricId)
         try encoderContainer.encode(metricName, forKey: .metricName)
         try encoderContainer.encode(noticeLevel, forKey: .noticeLevel)
         try encoderContainer.encode(noticePeriod, forKey: .noticePeriod)
         try encoderContainer.encode(operation, forKey: .operation)
         try encoderContainer.encode(period, forKey: .period)
         try encoderContainer.encode(ruleType, forKey: .ruleType)
         try encoderContainer.encode(serviceCode, forKey: .serviceCode)
         try encoderContainer.encode(tag, forKey: .tag)
         try encoderContainer.encode(tags, forKey: .tags)
         try encoderContainer.encode(threshold, forKey: .threshold)
         try encoderContainer.encode(times, forKey: .times)
         try encoderContainer.encode(updateTime, forKey: .updateTime)
         try encoderContainer.encode(uuid, forKey: .uuid)
    }
}
///  updateTemplateSpec
public class UpdateTemplateSpec:NSObject,Codable{
    /// 模板描述
    var descriptionValue:String?
    /// 规则的资源类型
    /// Required:true
    var ruleServiceCode:String
    /// 模板的资源类型
    /// Required:true
    var serviceCode:String
    /// 模板ID
    /// Required:true
    var templateId:Int64
    /// 模板名称
    /// Required:true
    var templateName:String
    /// 模板内包含的规则
    /// Required:true
    var templateRules:[BaseRuleT?]?



    public  init(ruleServiceCode:String,serviceCode:String,templateId:Int64,templateName:String,templateRules:[BaseRuleT?]?){
             self.ruleServiceCode = ruleServiceCode
             self.serviceCode = serviceCode
             self.templateId = templateId
             self.templateName = templateName
             self.templateRules = templateRules
    }

    enum UpdateTemplateSpecCodingKeys: String, CodingKey {
        case descriptionValue = "description"
        case ruleServiceCode
        case serviceCode
        case templateId
        case templateName
        case templateRules
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: UpdateTemplateSpecCodingKeys.self)
        if decoderContainer.contains(.descriptionValue)
        {
            self.descriptionValue = try decoderContainer.decode(String?.self, forKey: .descriptionValue)
        }
        self.ruleServiceCode = try decoderContainer.decode(String.self, forKey: .ruleServiceCode)
        self.serviceCode = try decoderContainer.decode(String.self, forKey: .serviceCode)
        self.templateId = try decoderContainer.decode(Int64.self, forKey: .templateId)
        self.templateName = try decoderContainer.decode(String.self, forKey: .templateName)
        self.templateRules = try decoderContainer.decode([BaseRuleT?]?.self, forKey: .templateRules)
    }
}
public extension UpdateTemplateSpec{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: UpdateTemplateSpecCodingKeys.self)
         try encoderContainer.encode(descriptionValue, forKey: .descriptionValue)
         try encoderContainer.encode(ruleServiceCode, forKey: .ruleServiceCode)
         try encoderContainer.encode(serviceCode, forKey: .serviceCode)
         try encoderContainer.encode(templateId, forKey: .templateId)
         try encoderContainer.encode(templateName, forKey: .templateName)
         try encoderContainer.encode(templateRules, forKey: .templateRules)
    }
}

/* Copyright 2018 JDCLOUD.COM

   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at

     http:#www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.

   云硬盘相关接口
   云硬盘相关接口，提供批量创建云硬盘，查询云硬盘，删除云硬盘，对云硬盘进行扩容，修改云硬盘信息以及使用快照恢复云硬盘等功能。

   OpenAPI spec version: v1
   Contact: 

   NOTE: This class is auto generated by the jdcloud code generator program.
 */


import Foundation
import JDCloudSDKCharge
///  quota
public class Quota:NSObject,Codable{
    /// 配额
    var limit:Int?
    /// 已使用的数目
    var used:Int?



    public override init(){
            super.init()
    }

    enum QuotaCodingKeys: String, CodingKey {
        case limit
        case used
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: QuotaCodingKeys.self)
        if decoderContainer.contains(.limit)
        {
            self.limit = try decoderContainer.decode(Int?.self, forKey: .limit)
        }
        if decoderContainer.contains(.used)
        {
            self.used = try decoderContainer.decode(Int?.self, forKey: .used)
        }
    }
}
public extension Quota{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: QuotaCodingKeys.self)
         try encoderContainer.encode(limit, forKey: .limit)
         try encoderContainer.encode(used, forKey: .used)
    }
}
///  snapshotSpec
public class SnapshotSpec:NSObject,Codable{
    /// 快照名称
    /// Required:true
    var name:String
    /// 快照描述
    var descriptionValue:String?
    /// 用于创建快照的云盘ID
    /// Required:true
    var diskId:String



    public  init(name:String,diskId:String){
             self.name = name
             self.diskId = diskId
    }

    enum SnapshotSpecCodingKeys: String, CodingKey {
        case name
        case descriptionValue = "description"
        case diskId
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: SnapshotSpecCodingKeys.self)
        self.name = try decoderContainer.decode(String.self, forKey: .name)
        if decoderContainer.contains(.descriptionValue)
        {
            self.descriptionValue = try decoderContainer.decode(String?.self, forKey: .descriptionValue)
        }
        self.diskId = try decoderContainer.decode(String.self, forKey: .diskId)
    }
}
public extension SnapshotSpec{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: SnapshotSpecCodingKeys.self)
         try encoderContainer.encode(name, forKey: .name)
         try encoderContainer.encode(descriptionValue, forKey: .descriptionValue)
         try encoderContainer.encode(diskId, forKey: .diskId)
    }
}
///  快照信息详情
public class Snapshot:NSObject,Codable{
    /// 云硬盘快照ID
    var snapshotId:String?
    /// 快照来源 可以有self，others两种来源
    var snapshotSource:String?
    /// 创建快照的云硬盘ID(snapshotSource为others时不展示)
    var diskId:String?
    /// 快照大小，单位为GiB
    var snapshotSizeGB:Int?
    /// 快照关联的所有镜像ID(snapshotSource为others时不展示)
    var images:[String?]?
    /// 快照名称
    var name:String?
    /// 快照描述
    var descriptionValue:String?
    /// 快照状态，取值为 creating、available、in-use、deleting、error_create、error_delete 之一
    var status:String?
    /// 创建时间
    var createTime:String?
    /// 共享信息
    var sharInfo:[ShareInfo?]?
    /// 快照是否为加密盘的快照
    var encrypted:Bool?



    public override init(){
            super.init()
    }

    enum SnapshotCodingKeys: String, CodingKey {
        case snapshotId
        case snapshotSource
        case diskId
        case snapshotSizeGB
        case images
        case name
        case descriptionValue = "description"
        case status
        case createTime
        case sharInfo
        case encrypted
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: SnapshotCodingKeys.self)
        if decoderContainer.contains(.snapshotId)
        {
            self.snapshotId = try decoderContainer.decode(String?.self, forKey: .snapshotId)
        }
        if decoderContainer.contains(.snapshotSource)
        {
            self.snapshotSource = try decoderContainer.decode(String?.self, forKey: .snapshotSource)
        }
        if decoderContainer.contains(.diskId)
        {
            self.diskId = try decoderContainer.decode(String?.self, forKey: .diskId)
        }
        if decoderContainer.contains(.snapshotSizeGB)
        {
            self.snapshotSizeGB = try decoderContainer.decode(Int?.self, forKey: .snapshotSizeGB)
        }
        if decoderContainer.contains(.images)
        {
            self.images = try decoderContainer.decode([String?]?.self, forKey: .images)
        }
        if decoderContainer.contains(.name)
        {
            self.name = try decoderContainer.decode(String?.self, forKey: .name)
        }
        if decoderContainer.contains(.descriptionValue)
        {
            self.descriptionValue = try decoderContainer.decode(String?.self, forKey: .descriptionValue)
        }
        if decoderContainer.contains(.status)
        {
            self.status = try decoderContainer.decode(String?.self, forKey: .status)
        }
        if decoderContainer.contains(.createTime)
        {
            self.createTime = try decoderContainer.decode(String?.self, forKey: .createTime)
        }
        if decoderContainer.contains(.sharInfo)
        {
            self.sharInfo = try decoderContainer.decode([ShareInfo?]?.self, forKey: .sharInfo)
        }
        if decoderContainer.contains(.encrypted)
        {
            self.encrypted = try decoderContainer.decode(Bool?.self, forKey: .encrypted)
        }
    }
}
public extension Snapshot{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: SnapshotCodingKeys.self)
         try encoderContainer.encode(snapshotId, forKey: .snapshotId)
         try encoderContainer.encode(snapshotSource, forKey: .snapshotSource)
         try encoderContainer.encode(diskId, forKey: .diskId)
         try encoderContainer.encode(snapshotSizeGB, forKey: .snapshotSizeGB)
         try encoderContainer.encode(images, forKey: .images)
         try encoderContainer.encode(name, forKey: .name)
         try encoderContainer.encode(descriptionValue, forKey: .descriptionValue)
         try encoderContainer.encode(status, forKey: .status)
         try encoderContainer.encode(createTime, forKey: .createTime)
         try encoderContainer.encode(sharInfo, forKey: .sharInfo)
         try encoderContainer.encode(encrypted, forKey: .encrypted)
    }
}
///  共享信息
public class ShareInfo:NSObject,Codable{
    /// 被共享快照的用户的pin
    var shareTo:String?
    /// 共享时间
    var shareTime:String?



    public override init(){
            super.init()
    }

    enum ShareInfoCodingKeys: String, CodingKey {
        case shareTo
        case shareTime
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: ShareInfoCodingKeys.self)
        if decoderContainer.contains(.shareTo)
        {
            self.shareTo = try decoderContainer.decode(String?.self, forKey: .shareTo)
        }
        if decoderContainer.contains(.shareTime)
        {
            self.shareTime = try decoderContainer.decode(String?.self, forKey: .shareTime)
        }
    }
}
public extension ShareInfo{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: ShareInfoCodingKeys.self)
         try encoderContainer.encode(shareTo, forKey: .shareTo)
         try encoderContainer.encode(shareTime, forKey: .shareTime)
    }
}
///  云硬盘资源列表
public class Data:NSObject,Codable{
    /// 云硬盘ID
    var resourceId:String?
    /// 云硬盘名称，只允许输入中文、数字、大小写字母、英文下划线“_”及中划线“-”，不允许为空且不超过32字符。
    var resourceName:String?
    /// 绑定资源列表
    var bind:[Bind?]?



    public override init(){
            super.init()
    }

    enum DataCodingKeys: String, CodingKey {
        case resourceId
        case resourceName
        case bind
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: DataCodingKeys.self)
        if decoderContainer.contains(.resourceId)
        {
            self.resourceId = try decoderContainer.decode(String?.self, forKey: .resourceId)
        }
        if decoderContainer.contains(.resourceName)
        {
            self.resourceName = try decoderContainer.decode(String?.self, forKey: .resourceName)
        }
        if decoderContainer.contains(.bind)
        {
            self.bind = try decoderContainer.decode([Bind?]?.self, forKey: .bind)
        }
    }
}
public extension Data{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: DataCodingKeys.self)
         try encoderContainer.encode(resourceId, forKey: .resourceId)
         try encoderContainer.encode(resourceName, forKey: .resourceName)
         try encoderContainer.encode(bind, forKey: .bind)
    }
}
///  云硬盘绑定的资源列表
public class Bind:NSObject,Codable{
    /// 云硬盘绑定的InstanceUuid
    var resourceId:String?



    public override init(){
            super.init()
    }

    enum BindCodingKeys: String, CodingKey {
        case resourceId
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: BindCodingKeys.self)
        if decoderContainer.contains(.resourceId)
        {
            self.resourceId = try decoderContainer.decode(String?.self, forKey: .resourceId)
        }
    }
}
public extension Bind{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: BindCodingKeys.self)
         try encoderContainer.encode(resourceId, forKey: .resourceId)
    }
}
///  soldout
public class Soldout:NSObject,Codable{
    /// 云硬盘所属的可用区
    /// Required:true
    var azName:String
    /// 云硬盘类型，取值为ssd、premium-hdd、ssd.gp1、ssd.io1、hdd.std1之一
    /// Required:true
    var mediaType:String
    /// 是否售罄
    /// Required:true
    var isSoldOut:Bool



    public  init(azName:String,mediaType:String,isSoldOut:Bool){
             self.azName = azName
             self.mediaType = mediaType
             self.isSoldOut = isSoldOut
    }

    enum SoldoutCodingKeys: String, CodingKey {
        case azName
        case mediaType
        case isSoldOut
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: SoldoutCodingKeys.self)
        self.azName = try decoderContainer.decode(String.self, forKey: .azName)
        self.mediaType = try decoderContainer.decode(String.self, forKey: .mediaType)
        self.isSoldOut = try decoderContainer.decode(Bool.self, forKey: .isSoldOut)
    }
}
public extension Soldout{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: SoldoutCodingKeys.self)
         try encoderContainer.encode(azName, forKey: .azName)
         try encoderContainer.encode(mediaType, forKey: .mediaType)
         try encoderContainer.encode(isSoldOut, forKey: .isSoldOut)
    }
}
///  diskSpecification
public class DiskSpecification:NSObject,Codable{
    /// 云硬盘类型
    var diskType:String?
    /// 支持的最小尺寸，单位为 GiB
    var minSizeGB:Int?
    /// 支持的最大尺寸，单位为 GiB
    var maxSizeGB:Int?
    /// 步长尺寸，单位为 GiB
    var stepSizeGB:Int?
    /// 描述信息
    var descriptionValue:String?
    /// 默认的iops数量(基础iops数量)
    var defaultIOPS:Int?
    /// iops步长增量
    var stepIOPS:Double?
    /// 最大iops数量
    var maxIOPS:Int?
    /// 默认的吞吐量
    var defaultThroughput:Int?
    /// 吞吐量步长增量
    var stepThroughput:Double?
    /// 最大吞吐量
    var maxThroughput:Int?
    /// 是否开启IOPS可调整
    var scalableIOPS:Bool?
    /// 最大iops步长
    var maxStepIOPS:Int?



    public override init(){
            super.init()
    }

    enum DiskSpecificationCodingKeys: String, CodingKey {
        case diskType
        case minSizeGB
        case maxSizeGB
        case stepSizeGB
        case descriptionValue = "description"
        case defaultIOPS
        case stepIOPS
        case maxIOPS
        case defaultThroughput
        case stepThroughput
        case maxThroughput
        case scalableIOPS
        case maxStepIOPS
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: DiskSpecificationCodingKeys.self)
        if decoderContainer.contains(.diskType)
        {
            self.diskType = try decoderContainer.decode(String?.self, forKey: .diskType)
        }
        if decoderContainer.contains(.minSizeGB)
        {
            self.minSizeGB = try decoderContainer.decode(Int?.self, forKey: .minSizeGB)
        }
        if decoderContainer.contains(.maxSizeGB)
        {
            self.maxSizeGB = try decoderContainer.decode(Int?.self, forKey: .maxSizeGB)
        }
        if decoderContainer.contains(.stepSizeGB)
        {
            self.stepSizeGB = try decoderContainer.decode(Int?.self, forKey: .stepSizeGB)
        }
        if decoderContainer.contains(.descriptionValue)
        {
            self.descriptionValue = try decoderContainer.decode(String?.self, forKey: .descriptionValue)
        }
        if decoderContainer.contains(.defaultIOPS)
        {
            self.defaultIOPS = try decoderContainer.decode(Int?.self, forKey: .defaultIOPS)
        }
        if decoderContainer.contains(.stepIOPS)
        {
            self.stepIOPS = try decoderContainer.decode(Double?.self, forKey: .stepIOPS)
        }
        if decoderContainer.contains(.maxIOPS)
        {
            self.maxIOPS = try decoderContainer.decode(Int?.self, forKey: .maxIOPS)
        }
        if decoderContainer.contains(.defaultThroughput)
        {
            self.defaultThroughput = try decoderContainer.decode(Int?.self, forKey: .defaultThroughput)
        }
        if decoderContainer.contains(.stepThroughput)
        {
            self.stepThroughput = try decoderContainer.decode(Double?.self, forKey: .stepThroughput)
        }
        if decoderContainer.contains(.maxThroughput)
        {
            self.maxThroughput = try decoderContainer.decode(Int?.self, forKey: .maxThroughput)
        }
        if decoderContainer.contains(.scalableIOPS)
        {
            self.scalableIOPS = try decoderContainer.decode(Bool?.self, forKey: .scalableIOPS)
        }
        if decoderContainer.contains(.maxStepIOPS)
        {
            self.maxStepIOPS = try decoderContainer.decode(Int?.self, forKey: .maxStepIOPS)
        }
    }
}
public extension DiskSpecification{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: DiskSpecificationCodingKeys.self)
         try encoderContainer.encode(diskType, forKey: .diskType)
         try encoderContainer.encode(minSizeGB, forKey: .minSizeGB)
         try encoderContainer.encode(maxSizeGB, forKey: .maxSizeGB)
         try encoderContainer.encode(stepSizeGB, forKey: .stepSizeGB)
         try encoderContainer.encode(descriptionValue, forKey: .descriptionValue)
         try encoderContainer.encode(defaultIOPS, forKey: .defaultIOPS)
         try encoderContainer.encode(stepIOPS, forKey: .stepIOPS)
         try encoderContainer.encode(maxIOPS, forKey: .maxIOPS)
         try encoderContainer.encode(defaultThroughput, forKey: .defaultThroughput)
         try encoderContainer.encode(stepThroughput, forKey: .stepThroughput)
         try encoderContainer.encode(maxThroughput, forKey: .maxThroughput)
         try encoderContainer.encode(scalableIOPS, forKey: .scalableIOPS)
         try encoderContainer.encode(maxStepIOPS, forKey: .maxStepIOPS)
    }
}
///  tag
public class Tag:NSObject,Codable{
    /// Tag键
    var key:String?
    /// Tag值
    var value:String?



    public override init(){
            super.init()
    }

    enum TagCodingKeys: String, CodingKey {
        case key
        case value
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: TagCodingKeys.self)
        if decoderContainer.contains(.key)
        {
            self.key = try decoderContainer.decode(String?.self, forKey: .key)
        }
        if decoderContainer.contains(.value)
        {
            self.value = try decoderContainer.decode(String?.self, forKey: .value)
        }
    }
}
public extension Tag{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: TagCodingKeys.self)
         try encoderContainer.encode(key, forKey: .key)
         try encoderContainer.encode(value, forKey: .value)
    }
}
///  diskSpec
public class DiskSpec:NSObject,Codable{
    /// 云硬盘所属的可用区
    /// Required:true
    var az:String
    /// 云硬盘名称
    /// Required:true
    var name:String
    /// 云硬盘描述
    var descriptionValue:String?
    /// 云硬盘类型，取值为ssd、premium-hdd、ssd.gp1、ssd.io1、hdd.std1之一
    /// Required:true
    var diskType:String
    /// 云硬盘大小，单位为 GiB，ssd 类型取值范围[20,1000]GB，步长为10G，premium-hdd 类型取值范围[20,3000]GB，步长为10G, ssd.gp1, ssd.io1, hdd.std1 类型取值均是范围[20,16000]GB，步长为10G
    /// Required:true
    var diskSizeGB:Int
    /// 云硬盘IOPS的大小，当且仅当云盘类型是ssd.io1型的云盘有效，步长是10.
    var iops:Int?
    /// 用于创建云硬盘的快照ID
    var snapshotId:String?
    /// 计费配置；如不指定，默认计费类型是后付费-按使用时常付费
    var charge:ChargeSpec?
    /// 云硬盘是否支持一盘多主机挂载，默认为false（不支持）
    var multiAttachable:Bool?
    /// 云硬盘是否加密，默认为false（不加密）
    var encrypt:Bool?



    public  init(az:String,name:String,diskType:String,diskSizeGB:Int){
             self.az = az
             self.name = name
             self.diskType = diskType
             self.diskSizeGB = diskSizeGB
    }

    enum DiskSpecCodingKeys: String, CodingKey {
        case az
        case name
        case descriptionValue = "description"
        case diskType
        case diskSizeGB
        case iops
        case snapshotId
        case charge
        case multiAttachable
        case encrypt
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: DiskSpecCodingKeys.self)
        self.az = try decoderContainer.decode(String.self, forKey: .az)
        self.name = try decoderContainer.decode(String.self, forKey: .name)
        if decoderContainer.contains(.descriptionValue)
        {
            self.descriptionValue = try decoderContainer.decode(String?.self, forKey: .descriptionValue)
        }
        self.diskType = try decoderContainer.decode(String.self, forKey: .diskType)
        self.diskSizeGB = try decoderContainer.decode(Int.self, forKey: .diskSizeGB)
        if decoderContainer.contains(.iops)
        {
            self.iops = try decoderContainer.decode(Int?.self, forKey: .iops)
        }
        if decoderContainer.contains(.snapshotId)
        {
            self.snapshotId = try decoderContainer.decode(String?.self, forKey: .snapshotId)
        }
        if decoderContainer.contains(.charge)
        {
            self.charge = try decoderContainer.decode(ChargeSpec?.self, forKey: .charge)
        }
        if decoderContainer.contains(.multiAttachable)
        {
            self.multiAttachable = try decoderContainer.decode(Bool?.self, forKey: .multiAttachable)
        }
        if decoderContainer.contains(.encrypt)
        {
            self.encrypt = try decoderContainer.decode(Bool?.self, forKey: .encrypt)
        }
    }
}
public extension DiskSpec{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: DiskSpecCodingKeys.self)
         try encoderContainer.encode(az, forKey: .az)
         try encoderContainer.encode(name, forKey: .name)
         try encoderContainer.encode(descriptionValue, forKey: .descriptionValue)
         try encoderContainer.encode(diskType, forKey: .diskType)
         try encoderContainer.encode(diskSizeGB, forKey: .diskSizeGB)
         try encoderContainer.encode(iops, forKey: .iops)
         try encoderContainer.encode(snapshotId, forKey: .snapshotId)
         try encoderContainer.encode(charge, forKey: .charge)
         try encoderContainer.encode(multiAttachable, forKey: .multiAttachable)
         try encoderContainer.encode(encrypt, forKey: .encrypt)
    }
}
///  云硬盘信息详情
public class Disk:NSObject,Codable{
    /// 云硬盘ID
    var diskId:String?
    /// 云硬盘所属AZ
    var az:String?
    /// 云硬盘名称，只允许输入中文、数字、大小写字母、英文下划线“_”及中划线“-”，不允许为空且不超过32字符。
    var name:String?
    /// 云硬盘描述，允许输入UTF-8编码下的全部字符，不超过256字符。
    var descriptionValue:String?
    /// 云硬盘类型，取值为 ssd,premium-hdd,ssd.gp1,ssd.io1,hdd.std1
    var diskType:String?
    /// 云硬盘大小，单位为 GiB
    var diskSizeGB:Int?
    /// 该云硬盘实际应用的iops值
    var iops:Int?
    /// 该云硬盘实际应用的吞吐量的数值
    var throughput:Int?
    /// 云硬盘状态，取值为 creating、available、in-use、extending、restoring、deleting、deleted、error_create、error_delete、error_restore、error_extend 之一
    var status:String?
    /// 挂载信息
    var attachments:[DiskAttachment?]?
    /// 创建该云硬盘的快照ID
    var snapshotId:String?
    /// 云盘是否支持多挂载
    var multiAttachable:Bool?
    /// 云盘是否为加密盘
    var encrypted:Bool?
    /// 云盘是否被暂停（IOPS限制为极低）
    var enabled:Bool?
    /// 创建云硬盘时间
    var createTime:String?
    /// 云硬盘计费配置信息
    var charge:Charge?
    /// Tag信息
    var tags:[Tag?]?



    public override init(){
            super.init()
    }

    enum DiskCodingKeys: String, CodingKey {
        case diskId
        case az
        case name
        case descriptionValue = "description"
        case diskType
        case diskSizeGB
        case iops
        case throughput
        case status
        case attachments
        case snapshotId
        case multiAttachable
        case encrypted
        case enabled
        case createTime
        case charge
        case tags
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: DiskCodingKeys.self)
        if decoderContainer.contains(.diskId)
        {
            self.diskId = try decoderContainer.decode(String?.self, forKey: .diskId)
        }
        if decoderContainer.contains(.az)
        {
            self.az = try decoderContainer.decode(String?.self, forKey: .az)
        }
        if decoderContainer.contains(.name)
        {
            self.name = try decoderContainer.decode(String?.self, forKey: .name)
        }
        if decoderContainer.contains(.descriptionValue)
        {
            self.descriptionValue = try decoderContainer.decode(String?.self, forKey: .descriptionValue)
        }
        if decoderContainer.contains(.diskType)
        {
            self.diskType = try decoderContainer.decode(String?.self, forKey: .diskType)
        }
        if decoderContainer.contains(.diskSizeGB)
        {
            self.diskSizeGB = try decoderContainer.decode(Int?.self, forKey: .diskSizeGB)
        }
        if decoderContainer.contains(.iops)
        {
            self.iops = try decoderContainer.decode(Int?.self, forKey: .iops)
        }
        if decoderContainer.contains(.throughput)
        {
            self.throughput = try decoderContainer.decode(Int?.self, forKey: .throughput)
        }
        if decoderContainer.contains(.status)
        {
            self.status = try decoderContainer.decode(String?.self, forKey: .status)
        }
        if decoderContainer.contains(.attachments)
        {
            self.attachments = try decoderContainer.decode([DiskAttachment?]?.self, forKey: .attachments)
        }
        if decoderContainer.contains(.snapshotId)
        {
            self.snapshotId = try decoderContainer.decode(String?.self, forKey: .snapshotId)
        }
        if decoderContainer.contains(.multiAttachable)
        {
            self.multiAttachable = try decoderContainer.decode(Bool?.self, forKey: .multiAttachable)
        }
        if decoderContainer.contains(.encrypted)
        {
            self.encrypted = try decoderContainer.decode(Bool?.self, forKey: .encrypted)
        }
        if decoderContainer.contains(.enabled)
        {
            self.enabled = try decoderContainer.decode(Bool?.self, forKey: .enabled)
        }
        if decoderContainer.contains(.createTime)
        {
            self.createTime = try decoderContainer.decode(String?.self, forKey: .createTime)
        }
        if decoderContainer.contains(.charge)
        {
            self.charge = try decoderContainer.decode(Charge?.self, forKey: .charge)
        }
        if decoderContainer.contains(.tags)
        {
            self.tags = try decoderContainer.decode([Tag?]?.self, forKey: .tags)
        }
    }
}
public extension Disk{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: DiskCodingKeys.self)
         try encoderContainer.encode(diskId, forKey: .diskId)
         try encoderContainer.encode(az, forKey: .az)
         try encoderContainer.encode(name, forKey: .name)
         try encoderContainer.encode(descriptionValue, forKey: .descriptionValue)
         try encoderContainer.encode(diskType, forKey: .diskType)
         try encoderContainer.encode(diskSizeGB, forKey: .diskSizeGB)
         try encoderContainer.encode(iops, forKey: .iops)
         try encoderContainer.encode(throughput, forKey: .throughput)
         try encoderContainer.encode(status, forKey: .status)
         try encoderContainer.encode(attachments, forKey: .attachments)
         try encoderContainer.encode(snapshotId, forKey: .snapshotId)
         try encoderContainer.encode(multiAttachable, forKey: .multiAttachable)
         try encoderContainer.encode(encrypted, forKey: .encrypted)
         try encoderContainer.encode(enabled, forKey: .enabled)
         try encoderContainer.encode(createTime, forKey: .createTime)
         try encoderContainer.encode(charge, forKey: .charge)
         try encoderContainer.encode(tags, forKey: .tags)
    }
}
///  diskAttachment
public class DiskAttachment:NSObject,Codable{
    /// 挂载ID
    var attachmentId:String?
    /// 云硬盘ID
    var diskId:String?
    /// 挂载实例的类型，取值为 vm、nc
    var instanceType:String?
    /// 挂载实例的ID
    var instanceId:String?
    /// 挂载状态，取值为 &quot;attaching&quot;, &quot;attached&quot;, &quot;detaching&quot;, &quot;detached&quot;
    var status:String?
    /// 挂载时间
    var attachTime:String?



    public override init(){
            super.init()
    }

    enum DiskAttachmentCodingKeys: String, CodingKey {
        case attachmentId
        case diskId
        case instanceType
        case instanceId
        case status
        case attachTime
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: DiskAttachmentCodingKeys.self)
        if decoderContainer.contains(.attachmentId)
        {
            self.attachmentId = try decoderContainer.decode(String?.self, forKey: .attachmentId)
        }
        if decoderContainer.contains(.diskId)
        {
            self.diskId = try decoderContainer.decode(String?.self, forKey: .diskId)
        }
        if decoderContainer.contains(.instanceType)
        {
            self.instanceType = try decoderContainer.decode(String?.self, forKey: .instanceType)
        }
        if decoderContainer.contains(.instanceId)
        {
            self.instanceId = try decoderContainer.decode(String?.self, forKey: .instanceId)
        }
        if decoderContainer.contains(.status)
        {
            self.status = try decoderContainer.decode(String?.self, forKey: .status)
        }
        if decoderContainer.contains(.attachTime)
        {
            self.attachTime = try decoderContainer.decode(String?.self, forKey: .attachTime)
        }
    }
}
public extension DiskAttachment{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: DiskAttachmentCodingKeys.self)
         try encoderContainer.encode(attachmentId, forKey: .attachmentId)
         try encoderContainer.encode(diskId, forKey: .diskId)
         try encoderContainer.encode(instanceType, forKey: .instanceType)
         try encoderContainer.encode(instanceId, forKey: .instanceId)
         try encoderContainer.encode(status, forKey: .status)
         try encoderContainer.encode(attachTime, forKey: .attachTime)
    }
}
///  tagFilter
public class TagFilter:NSObject,Codable{
    /// Tag键
    /// Required:true
    var key:String
    /// Tag值
    /// Required:true
    var values:[String?]?



    public  init(key:String,values:[String?]?){
             self.key = key
             self.values = values
    }

    enum TagFilterCodingKeys: String, CodingKey {
        case key
        case values
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: TagFilterCodingKeys.self)
        self.key = try decoderContainer.decode(String.self, forKey: .key)
        self.values = try decoderContainer.decode([String?]?.self, forKey: .values)
    }
}
public extension TagFilter{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: TagFilterCodingKeys.self)
         try encoderContainer.encode(key, forKey: .key)
         try encoderContainer.encode(values, forKey: .values)
    }
}

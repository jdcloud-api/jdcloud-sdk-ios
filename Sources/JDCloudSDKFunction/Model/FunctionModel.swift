/* Copyright 2018 JDCLOUD.COM

   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at

     http:#www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.

   Function OpenAPI
   

   OpenAPI spec version: v1
   Contact: 

   NOTE: This class is auto generated by the jdcloud code generator program.
 */


import Foundation
///  env
public class Env:NSObject,Codable{
    /// Data
    var data:[String:String?]?



    public override init(){
            super.init()
    }

    enum EnvCodingKeys: String, CodingKey {
        case data
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: EnvCodingKeys.self)
        if decoderContainer.contains(.data)
        {
            self.data = try decoderContainer.decode([String:String?]?.self, forKey: .data)
        }
    }
}
public extension Env{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: EnvCodingKeys.self)
         try encoderContainer.encode(data, forKey: .data)
    }
}
///  function
public class Function:NSObject,Codable{
    /// 函数Id
    var functionId:String?
    /// 函数名称
    var name:String?
    /// 函数描述
    var descriptionValue:String?
    /// 函数入口，格式为入口文件.入口函数名
    var entrance:String?
    /// 函数运行最大内存
    var memory:Int32?
    /// 函数运行环境，目前有python3.6
    var runTime:String?
    /// 函数超时时间
    var overTime:Int32?
    /// 函数版本名称
    var version:String?
    /// 函数代码
    var code:Code?
    /// 函数环境变量
    var environment:Env?
    /// 函数指定的日志集id
    var logSetId:String?
    /// 函数指定的日志主题id
    var logTopicId:String?
    /// 代码包校验和
    var codeCheckSum:String?
    /// 代码包大小，单位为字节
    var codeSize:Int32?
    /// 代码包下载的url地址
    var downloadUrl:String?
    /// 函数配置的VPCid
    var vpcId:String?
    /// 函数配置的子网id
    var subnetId:String?
    /// 函数创建时间
    var createTime:String?
    /// 函数最后更新时间
    var updateTime:String?



    public override init(){
            super.init()
    }

    enum FunctionCodingKeys: String, CodingKey {
        case functionId
        case name
        case descriptionValue = "description"
        case entrance
        case memory
        case runTime
        case overTime
        case version
        case code
        case environment
        case logSetId
        case logTopicId
        case codeCheckSum
        case codeSize
        case downloadUrl
        case vpcId
        case subnetId
        case createTime
        case updateTime
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: FunctionCodingKeys.self)
        if decoderContainer.contains(.functionId)
        {
            self.functionId = try decoderContainer.decode(String?.self, forKey: .functionId)
        }
        if decoderContainer.contains(.name)
        {
            self.name = try decoderContainer.decode(String?.self, forKey: .name)
        }
        if decoderContainer.contains(.descriptionValue)
        {
            self.descriptionValue = try decoderContainer.decode(String?.self, forKey: .descriptionValue)
        }
        if decoderContainer.contains(.entrance)
        {
            self.entrance = try decoderContainer.decode(String?.self, forKey: .entrance)
        }
        if decoderContainer.contains(.memory)
        {
            self.memory = try decoderContainer.decode(Int32?.self, forKey: .memory)
        }
        if decoderContainer.contains(.runTime)
        {
            self.runTime = try decoderContainer.decode(String?.self, forKey: .runTime)
        }
        if decoderContainer.contains(.overTime)
        {
            self.overTime = try decoderContainer.decode(Int32?.self, forKey: .overTime)
        }
        if decoderContainer.contains(.version)
        {
            self.version = try decoderContainer.decode(String?.self, forKey: .version)
        }
        if decoderContainer.contains(.code)
        {
            self.code = try decoderContainer.decode(Code?.self, forKey: .code)
        }
        if decoderContainer.contains(.environment)
        {
            self.environment = try decoderContainer.decode(Env?.self, forKey: .environment)
        }
        if decoderContainer.contains(.logSetId)
        {
            self.logSetId = try decoderContainer.decode(String?.self, forKey: .logSetId)
        }
        if decoderContainer.contains(.logTopicId)
        {
            self.logTopicId = try decoderContainer.decode(String?.self, forKey: .logTopicId)
        }
        if decoderContainer.contains(.codeCheckSum)
        {
            self.codeCheckSum = try decoderContainer.decode(String?.self, forKey: .codeCheckSum)
        }
        if decoderContainer.contains(.codeSize)
        {
            self.codeSize = try decoderContainer.decode(Int32?.self, forKey: .codeSize)
        }
        if decoderContainer.contains(.downloadUrl)
        {
            self.downloadUrl = try decoderContainer.decode(String?.self, forKey: .downloadUrl)
        }
        if decoderContainer.contains(.vpcId)
        {
            self.vpcId = try decoderContainer.decode(String?.self, forKey: .vpcId)
        }
        if decoderContainer.contains(.subnetId)
        {
            self.subnetId = try decoderContainer.decode(String?.self, forKey: .subnetId)
        }
        if decoderContainer.contains(.createTime)
        {
            self.createTime = try decoderContainer.decode(String?.self, forKey: .createTime)
        }
        if decoderContainer.contains(.updateTime)
        {
            self.updateTime = try decoderContainer.decode(String?.self, forKey: .updateTime)
        }
    }
}
public extension Function{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: FunctionCodingKeys.self)
         try encoderContainer.encode(functionId, forKey: .functionId)
         try encoderContainer.encode(name, forKey: .name)
         try encoderContainer.encode(descriptionValue, forKey: .descriptionValue)
         try encoderContainer.encode(entrance, forKey: .entrance)
         try encoderContainer.encode(memory, forKey: .memory)
         try encoderContainer.encode(runTime, forKey: .runTime)
         try encoderContainer.encode(overTime, forKey: .overTime)
         try encoderContainer.encode(version, forKey: .version)
         try encoderContainer.encode(code, forKey: .code)
         try encoderContainer.encode(environment, forKey: .environment)
         try encoderContainer.encode(logSetId, forKey: .logSetId)
         try encoderContainer.encode(logTopicId, forKey: .logTopicId)
         try encoderContainer.encode(codeCheckSum, forKey: .codeCheckSum)
         try encoderContainer.encode(codeSize, forKey: .codeSize)
         try encoderContainer.encode(downloadUrl, forKey: .downloadUrl)
         try encoderContainer.encode(vpcId, forKey: .vpcId)
         try encoderContainer.encode(subnetId, forKey: .subnetId)
         try encoderContainer.encode(createTime, forKey: .createTime)
         try encoderContainer.encode(updateTime, forKey: .updateTime)
    }
}
///  functionInvokeResult
public class FunctionInvokeResult:NSObject,Codable{
    /// 函数执行结果
    var result:String?
    /// 代码包校验和
    var codeCheckSum:String?
    /// 函数执行时间
    var invokeTime:Double?
    /// 函数收费时间
    var billingTime:Double?
    /// 函数设置内存大小
    var setupMem:Double?
    /// 函数实际使用内存大小
    var realMem:Double?
    /// 函数执行日志
    var logStr:String?



    public override init(){
            super.init()
    }

    enum FunctionInvokeResultCodingKeys: String, CodingKey {
        case result
        case codeCheckSum
        case invokeTime
        case billingTime
        case setupMem
        case realMem
        case logStr
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: FunctionInvokeResultCodingKeys.self)
        if decoderContainer.contains(.result)
        {
            self.result = try decoderContainer.decode(String?.self, forKey: .result)
        }
        if decoderContainer.contains(.codeCheckSum)
        {
            self.codeCheckSum = try decoderContainer.decode(String?.self, forKey: .codeCheckSum)
        }
        if decoderContainer.contains(.invokeTime)
        {
            self.invokeTime = try decoderContainer.decode(Double?.self, forKey: .invokeTime)
        }
        if decoderContainer.contains(.billingTime)
        {
            self.billingTime = try decoderContainer.decode(Double?.self, forKey: .billingTime)
        }
        if decoderContainer.contains(.setupMem)
        {
            self.setupMem = try decoderContainer.decode(Double?.self, forKey: .setupMem)
        }
        if decoderContainer.contains(.realMem)
        {
            self.realMem = try decoderContainer.decode(Double?.self, forKey: .realMem)
        }
        if decoderContainer.contains(.logStr)
        {
            self.logStr = try decoderContainer.decode(String?.self, forKey: .logStr)
        }
    }
}
public extension FunctionInvokeResult{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: FunctionInvokeResultCodingKeys.self)
         try encoderContainer.encode(result, forKey: .result)
         try encoderContainer.encode(codeCheckSum, forKey: .codeCheckSum)
         try encoderContainer.encode(invokeTime, forKey: .invokeTime)
         try encoderContainer.encode(billingTime, forKey: .billingTime)
         try encoderContainer.encode(setupMem, forKey: .setupMem)
         try encoderContainer.encode(realMem, forKey: .realMem)
         try encoderContainer.encode(logStr, forKey: .logStr)
    }
}
///  code
public class Code:NSObject,Codable{
    /// 代码压缩文件，base64编码
    var zipFile:String?
    /// 在线编辑代码
    var onlineCode:String?
    /// 代码所在对象存储的bucket名称
    var bucketName:String?
    /// 代码所在对象存储的object名称
    var objectName:String?



    public override init(){
            super.init()
    }

    enum CodeCodingKeys: String, CodingKey {
        case zipFile
        case onlineCode
        case bucketName
        case objectName
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: CodeCodingKeys.self)
        if decoderContainer.contains(.zipFile)
        {
            self.zipFile = try decoderContainer.decode(String?.self, forKey: .zipFile)
        }
        if decoderContainer.contains(.onlineCode)
        {
            self.onlineCode = try decoderContainer.decode(String?.self, forKey: .onlineCode)
        }
        if decoderContainer.contains(.bucketName)
        {
            self.bucketName = try decoderContainer.decode(String?.self, forKey: .bucketName)
        }
        if decoderContainer.contains(.objectName)
        {
            self.objectName = try decoderContainer.decode(String?.self, forKey: .objectName)
        }
    }
}
public extension Code{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: CodeCodingKeys.self)
         try encoderContainer.encode(zipFile, forKey: .zipFile)
         try encoderContainer.encode(onlineCode, forKey: .onlineCode)
         try encoderContainer.encode(bucketName, forKey: .bucketName)
         try encoderContainer.encode(objectName, forKey: .objectName)
    }
}
///  functionSpec
public class FunctionSpec:NSObject,Codable{
    /// 函数Id
    var functionId:String?
    /// 函数名称
    var name:String?
    /// 函数描述
    var descriptionValue:String?
    /// 函数运行环境，目前有python3
    var runtime:String?
    /// 函数创建时间
    var createTime:String?
    /// 函数最后更新时间
    var updateTime:String?
    /// 函数版本名称
    var version:String?
    /// 代码包下载的url地址
    var downloadUrl:String?



    public override init(){
            super.init()
    }

    enum FunctionSpecCodingKeys: String, CodingKey {
        case functionId
        case name
        case descriptionValue = "description"
        case runtime
        case createTime
        case updateTime
        case version
        case downloadUrl
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: FunctionSpecCodingKeys.self)
        if decoderContainer.contains(.functionId)
        {
            self.functionId = try decoderContainer.decode(String?.self, forKey: .functionId)
        }
        if decoderContainer.contains(.name)
        {
            self.name = try decoderContainer.decode(String?.self, forKey: .name)
        }
        if decoderContainer.contains(.descriptionValue)
        {
            self.descriptionValue = try decoderContainer.decode(String?.self, forKey: .descriptionValue)
        }
        if decoderContainer.contains(.runtime)
        {
            self.runtime = try decoderContainer.decode(String?.self, forKey: .runtime)
        }
        if decoderContainer.contains(.createTime)
        {
            self.createTime = try decoderContainer.decode(String?.self, forKey: .createTime)
        }
        if decoderContainer.contains(.updateTime)
        {
            self.updateTime = try decoderContainer.decode(String?.self, forKey: .updateTime)
        }
        if decoderContainer.contains(.version)
        {
            self.version = try decoderContainer.decode(String?.self, forKey: .version)
        }
        if decoderContainer.contains(.downloadUrl)
        {
            self.downloadUrl = try decoderContainer.decode(String?.self, forKey: .downloadUrl)
        }
    }
}
public extension FunctionSpec{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: FunctionSpecCodingKeys.self)
         try encoderContainer.encode(functionId, forKey: .functionId)
         try encoderContainer.encode(name, forKey: .name)
         try encoderContainer.encode(descriptionValue, forKey: .descriptionValue)
         try encoderContainer.encode(runtime, forKey: .runtime)
         try encoderContainer.encode(createTime, forKey: .createTime)
         try encoderContainer.encode(updateTime, forKey: .updateTime)
         try encoderContainer.encode(version, forKey: .version)
         try encoderContainer.encode(downloadUrl, forKey: .downloadUrl)
    }
}
///  createFunctionInput
public class CreateFunctionInput:NSObject,Codable{
    /// 函数名称
    var name:String?
    /// 函数描述信息
    var descriptionValue:String?
    /// 函数入口，格式为入口文件.入口函数名
    var entrance:String?
    /// 函数运行最大内存
    var memory:Int?
    /// 函数运行环境
    var runTime:String?
    /// 函数运行超时时间
    var overTime:Int?
    /// 函数版本，默认为LATEST
    var version:String?
    /// 函数代码包
    var code:Code?
    /// 函数运行时环境变量
    var environment:Env?
    /// 函数指定的日志集Id
    var logSetId:String?
    /// 函数指定的日志主题Id
    var logTopicId:String?
    /// 函数配置的VPCId
    var vpcId:String?
    /// 函数配置的子网Id
    var subnetId:String?



    public override init(){
            super.init()
    }

    enum CreateFunctionInputCodingKeys: String, CodingKey {
        case name
        case descriptionValue = "description"
        case entrance
        case memory
        case runTime
        case overTime
        case version
        case code
        case environment
        case logSetId
        case logTopicId
        case vpcId
        case subnetId
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: CreateFunctionInputCodingKeys.self)
        if decoderContainer.contains(.name)
        {
            self.name = try decoderContainer.decode(String?.self, forKey: .name)
        }
        if decoderContainer.contains(.descriptionValue)
        {
            self.descriptionValue = try decoderContainer.decode(String?.self, forKey: .descriptionValue)
        }
        if decoderContainer.contains(.entrance)
        {
            self.entrance = try decoderContainer.decode(String?.self, forKey: .entrance)
        }
        if decoderContainer.contains(.memory)
        {
            self.memory = try decoderContainer.decode(Int?.self, forKey: .memory)
        }
        if decoderContainer.contains(.runTime)
        {
            self.runTime = try decoderContainer.decode(String?.self, forKey: .runTime)
        }
        if decoderContainer.contains(.overTime)
        {
            self.overTime = try decoderContainer.decode(Int?.self, forKey: .overTime)
        }
        if decoderContainer.contains(.version)
        {
            self.version = try decoderContainer.decode(String?.self, forKey: .version)
        }
        if decoderContainer.contains(.code)
        {
            self.code = try decoderContainer.decode(Code?.self, forKey: .code)
        }
        if decoderContainer.contains(.environment)
        {
            self.environment = try decoderContainer.decode(Env?.self, forKey: .environment)
        }
        if decoderContainer.contains(.logSetId)
        {
            self.logSetId = try decoderContainer.decode(String?.self, forKey: .logSetId)
        }
        if decoderContainer.contains(.logTopicId)
        {
            self.logTopicId = try decoderContainer.decode(String?.self, forKey: .logTopicId)
        }
        if decoderContainer.contains(.vpcId)
        {
            self.vpcId = try decoderContainer.decode(String?.self, forKey: .vpcId)
        }
        if decoderContainer.contains(.subnetId)
        {
            self.subnetId = try decoderContainer.decode(String?.self, forKey: .subnetId)
        }
    }
}
public extension CreateFunctionInput{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: CreateFunctionInputCodingKeys.self)
         try encoderContainer.encode(name, forKey: .name)
         try encoderContainer.encode(descriptionValue, forKey: .descriptionValue)
         try encoderContainer.encode(entrance, forKey: .entrance)
         try encoderContainer.encode(memory, forKey: .memory)
         try encoderContainer.encode(runTime, forKey: .runTime)
         try encoderContainer.encode(overTime, forKey: .overTime)
         try encoderContainer.encode(version, forKey: .version)
         try encoderContainer.encode(code, forKey: .code)
         try encoderContainer.encode(environment, forKey: .environment)
         try encoderContainer.encode(logSetId, forKey: .logSetId)
         try encoderContainer.encode(logTopicId, forKey: .logTopicId)
         try encoderContainer.encode(vpcId, forKey: .vpcId)
         try encoderContainer.encode(subnetId, forKey: .subnetId)
    }
}
///  updateFunctionInput
public class UpdateFunctionInput:NSObject,Codable{
    /// 函数描述信息
    var descriptionValue:String?
    /// 函数入口，格式为入口文件.入口函数名
    var entrance:String?
    /// 函数运行最大内存
    var memory:Int?
    /// 函数运行环境
    var runTime:String?
    /// 函数运行超时时间
    var overTime:Int?
    /// 函数版本
    var version:String?
    /// 函数代码包
    var code:Code?
    /// 函数运行时环境变量
    var environment:Env?
    /// 函数指定的日志集Id
    var logSetId:String?
    /// 函数指定的日志主题Id
    var logTopicId:String?
    /// 函数配置的VPCId
    var vpcId:String?
    /// 函数配置的子网Id
    var subnetId:String?



    public override init(){
            super.init()
    }

    enum UpdateFunctionInputCodingKeys: String, CodingKey {
        case descriptionValue = "description"
        case entrance
        case memory
        case runTime
        case overTime
        case version
        case code
        case environment
        case logSetId
        case logTopicId
        case vpcId
        case subnetId
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: UpdateFunctionInputCodingKeys.self)
        if decoderContainer.contains(.descriptionValue)
        {
            self.descriptionValue = try decoderContainer.decode(String?.self, forKey: .descriptionValue)
        }
        if decoderContainer.contains(.entrance)
        {
            self.entrance = try decoderContainer.decode(String?.self, forKey: .entrance)
        }
        if decoderContainer.contains(.memory)
        {
            self.memory = try decoderContainer.decode(Int?.self, forKey: .memory)
        }
        if decoderContainer.contains(.runTime)
        {
            self.runTime = try decoderContainer.decode(String?.self, forKey: .runTime)
        }
        if decoderContainer.contains(.overTime)
        {
            self.overTime = try decoderContainer.decode(Int?.self, forKey: .overTime)
        }
        if decoderContainer.contains(.version)
        {
            self.version = try decoderContainer.decode(String?.self, forKey: .version)
        }
        if decoderContainer.contains(.code)
        {
            self.code = try decoderContainer.decode(Code?.self, forKey: .code)
        }
        if decoderContainer.contains(.environment)
        {
            self.environment = try decoderContainer.decode(Env?.self, forKey: .environment)
        }
        if decoderContainer.contains(.logSetId)
        {
            self.logSetId = try decoderContainer.decode(String?.self, forKey: .logSetId)
        }
        if decoderContainer.contains(.logTopicId)
        {
            self.logTopicId = try decoderContainer.decode(String?.self, forKey: .logTopicId)
        }
        if decoderContainer.contains(.vpcId)
        {
            self.vpcId = try decoderContainer.decode(String?.self, forKey: .vpcId)
        }
        if decoderContainer.contains(.subnetId)
        {
            self.subnetId = try decoderContainer.decode(String?.self, forKey: .subnetId)
        }
    }
}
public extension UpdateFunctionInput{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: UpdateFunctionInputCodingKeys.self)
         try encoderContainer.encode(descriptionValue, forKey: .descriptionValue)
         try encoderContainer.encode(entrance, forKey: .entrance)
         try encoderContainer.encode(memory, forKey: .memory)
         try encoderContainer.encode(runTime, forKey: .runTime)
         try encoderContainer.encode(overTime, forKey: .overTime)
         try encoderContainer.encode(version, forKey: .version)
         try encoderContainer.encode(code, forKey: .code)
         try encoderContainer.encode(environment, forKey: .environment)
         try encoderContainer.encode(logSetId, forKey: .logSetId)
         try encoderContainer.encode(logTopicId, forKey: .logTopicId)
         try encoderContainer.encode(vpcId, forKey: .vpcId)
         try encoderContainer.encode(subnetId, forKey: .subnetId)
    }
}
///  statistics
public class Statistics:NSObject,Codable{
    /// 用户目前已经创建的函数数量
    var currentFunctionNumber:Int?
    /// 用户可创建函数的最大数量
    var maxFunctionNumber:Int?
    /// 用户当前使用的代码存储空间
    var currentCodeSize:Double?
    /// 用户可使用的最大代码存储空间
    var maxCodeSize:Int?



    public override init(){
            super.init()
    }

    enum StatisticsCodingKeys: String, CodingKey {
        case currentFunctionNumber
        case maxFunctionNumber
        case currentCodeSize
        case maxCodeSize
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: StatisticsCodingKeys.self)
        if decoderContainer.contains(.currentFunctionNumber)
        {
            self.currentFunctionNumber = try decoderContainer.decode(Int?.self, forKey: .currentFunctionNumber)
        }
        if decoderContainer.contains(.maxFunctionNumber)
        {
            self.maxFunctionNumber = try decoderContainer.decode(Int?.self, forKey: .maxFunctionNumber)
        }
        if decoderContainer.contains(.currentCodeSize)
        {
            self.currentCodeSize = try decoderContainer.decode(Double?.self, forKey: .currentCodeSize)
        }
        if decoderContainer.contains(.maxCodeSize)
        {
            self.maxCodeSize = try decoderContainer.decode(Int?.self, forKey: .maxCodeSize)
        }
    }
}
public extension Statistics{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: StatisticsCodingKeys.self)
         try encoderContainer.encode(currentFunctionNumber, forKey: .currentFunctionNumber)
         try encoderContainer.encode(maxFunctionNumber, forKey: .maxFunctionNumber)
         try encoderContainer.encode(currentCodeSize, forKey: .currentCodeSize)
         try encoderContainer.encode(maxCodeSize, forKey: .maxCodeSize)
    }
}
///  ossTrigger
public class OssTrigger:NSObject,Codable{
    /// 桶名
    var bucket:String?
    /// oss配置id
    var configId:String?
    /// trigger事件
    var events:[String?]?
    /// 前缀
    var prefix:String?
    /// 后缀
    var suffix:String?



    public override init(){
            super.init()
    }

    enum OssTriggerCodingKeys: String, CodingKey {
        case bucket
        case configId
        case events
        case prefix
        case suffix
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: OssTriggerCodingKeys.self)
        if decoderContainer.contains(.bucket)
        {
            self.bucket = try decoderContainer.decode(String?.self, forKey: .bucket)
        }
        if decoderContainer.contains(.configId)
        {
            self.configId = try decoderContainer.decode(String?.self, forKey: .configId)
        }
        if decoderContainer.contains(.events)
        {
            self.events = try decoderContainer.decode([String?]?.self, forKey: .events)
        }
        if decoderContainer.contains(.prefix)
        {
            self.prefix = try decoderContainer.decode(String?.self, forKey: .prefix)
        }
        if decoderContainer.contains(.suffix)
        {
            self.suffix = try decoderContainer.decode(String?.self, forKey: .suffix)
        }
    }
}
public extension OssTrigger{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: OssTriggerCodingKeys.self)
         try encoderContainer.encode(bucket, forKey: .bucket)
         try encoderContainer.encode(configId, forKey: .configId)
         try encoderContainer.encode(events, forKey: .events)
         try encoderContainer.encode(prefix, forKey: .prefix)
         try encoderContainer.encode(suffix, forKey: .suffix)
    }
}
///  trigger
public class Trigger:NSObject,Codable{
    /// 触发器Id
    var triggerId:String?
    /// 触发器所属的函数名称
    var functionName:String?
    /// 触发器所属的函数版本名称
    var versionName:String?
    /// 触发器对应的事件源类型，目前有oss和apigateway
    var eventSource:String?
    /// 触发器对应的事件源Id
    var eventSourceId:String?
    /// 触发器创建时间
    var createTime:String?
    /// 触发器最后修改时间
    var updateTime:String?



    public override init(){
            super.init()
    }

    enum TriggerCodingKeys: String, CodingKey {
        case triggerId
        case functionName
        case versionName
        case eventSource
        case eventSourceId
        case createTime
        case updateTime
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: TriggerCodingKeys.self)
        if decoderContainer.contains(.triggerId)
        {
            self.triggerId = try decoderContainer.decode(String?.self, forKey: .triggerId)
        }
        if decoderContainer.contains(.functionName)
        {
            self.functionName = try decoderContainer.decode(String?.self, forKey: .functionName)
        }
        if decoderContainer.contains(.versionName)
        {
            self.versionName = try decoderContainer.decode(String?.self, forKey: .versionName)
        }
        if decoderContainer.contains(.eventSource)
        {
            self.eventSource = try decoderContainer.decode(String?.self, forKey: .eventSource)
        }
        if decoderContainer.contains(.eventSourceId)
        {
            self.eventSourceId = try decoderContainer.decode(String?.self, forKey: .eventSourceId)
        }
        if decoderContainer.contains(.createTime)
        {
            self.createTime = try decoderContainer.decode(String?.self, forKey: .createTime)
        }
        if decoderContainer.contains(.updateTime)
        {
            self.updateTime = try decoderContainer.decode(String?.self, forKey: .updateTime)
        }
    }
}
public extension Trigger{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: TriggerCodingKeys.self)
         try encoderContainer.encode(triggerId, forKey: .triggerId)
         try encoderContainer.encode(functionName, forKey: .functionName)
         try encoderContainer.encode(versionName, forKey: .versionName)
         try encoderContainer.encode(eventSource, forKey: .eventSource)
         try encoderContainer.encode(eventSourceId, forKey: .eventSourceId)
         try encoderContainer.encode(createTime, forKey: .createTime)
         try encoderContainer.encode(updateTime, forKey: .updateTime)
    }
}
///  apiTrigger
public class ApiTrigger:NSObject,Codable{
    /// 接口ID
    var apiId:String?
    /// 分组ID
    var apiGroupId:String?
    /// 分组名称
    var groupName:String?
    /// 修订版本号
    var revision:String?
    /// API名称
    var apiName:String?
    /// 请求方式
    var action:String?
    /// 请求路径，同时发布多个环境后会有多个路径
    var path:[String?]?
    /// API描述
    var descriptionValue:String?
    /// 部署状态(1:已部署)
    var deploymentStatus:Int?



    public override init(){
            super.init()
    }

    enum ApiTriggerCodingKeys: String, CodingKey {
        case apiId
        case apiGroupId
        case groupName
        case revision
        case apiName
        case action
        case path
        case descriptionValue = "description"
        case deploymentStatus
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: ApiTriggerCodingKeys.self)
        if decoderContainer.contains(.apiId)
        {
            self.apiId = try decoderContainer.decode(String?.self, forKey: .apiId)
        }
        if decoderContainer.contains(.apiGroupId)
        {
            self.apiGroupId = try decoderContainer.decode(String?.self, forKey: .apiGroupId)
        }
        if decoderContainer.contains(.groupName)
        {
            self.groupName = try decoderContainer.decode(String?.self, forKey: .groupName)
        }
        if decoderContainer.contains(.revision)
        {
            self.revision = try decoderContainer.decode(String?.self, forKey: .revision)
        }
        if decoderContainer.contains(.apiName)
        {
            self.apiName = try decoderContainer.decode(String?.self, forKey: .apiName)
        }
        if decoderContainer.contains(.action)
        {
            self.action = try decoderContainer.decode(String?.self, forKey: .action)
        }
        if decoderContainer.contains(.path)
        {
            self.path = try decoderContainer.decode([String?]?.self, forKey: .path)
        }
        if decoderContainer.contains(.descriptionValue)
        {
            self.descriptionValue = try decoderContainer.decode(String?.self, forKey: .descriptionValue)
        }
        if decoderContainer.contains(.deploymentStatus)
        {
            self.deploymentStatus = try decoderContainer.decode(Int?.self, forKey: .deploymentStatus)
        }
    }
}
public extension ApiTrigger{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: ApiTriggerCodingKeys.self)
         try encoderContainer.encode(apiId, forKey: .apiId)
         try encoderContainer.encode(apiGroupId, forKey: .apiGroupId)
         try encoderContainer.encode(groupName, forKey: .groupName)
         try encoderContainer.encode(revision, forKey: .revision)
         try encoderContainer.encode(apiName, forKey: .apiName)
         try encoderContainer.encode(action, forKey: .action)
         try encoderContainer.encode(path, forKey: .path)
         try encoderContainer.encode(descriptionValue, forKey: .descriptionValue)
         try encoderContainer.encode(deploymentStatus, forKey: .deploymentStatus)
    }
}
///  listTriggerData
public class ListTriggerData:NSObject,Codable{
    /// oss触发器列表
    var ossTriggers:[OssTrigger?]?
    /// apiGateWay触发器列表
    var apiGwTriggers:[ApiTrigger?]?



    public override init(){
            super.init()
    }

    enum ListTriggerDataCodingKeys: String, CodingKey {
        case ossTriggers
        case apiGwTriggers
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: ListTriggerDataCodingKeys.self)
        if decoderContainer.contains(.ossTriggers)
        {
            self.ossTriggers = try decoderContainer.decode([OssTrigger?]?.self, forKey: .ossTriggers)
        }
        if decoderContainer.contains(.apiGwTriggers)
        {
            self.apiGwTriggers = try decoderContainer.decode([ApiTrigger?]?.self, forKey: .apiGwTriggers)
        }
    }
}
public extension ListTriggerData{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: ListTriggerDataCodingKeys.self)
         try encoderContainer.encode(ossTriggers, forKey: .ossTriggers)
         try encoderContainer.encode(apiGwTriggers, forKey: .apiGwTriggers)
    }
}
///  flavor
public class Flavor:NSObject,Codable{
    /// flavor键
    var flavorKey:String?
    /// cpu规格
    var cpu:Int?
    /// 内存规格
    var memory:Int?
    /// 硬盘规格
    var disk:Int?



    public override init(){
            super.init()
    }

    enum FlavorCodingKeys: String, CodingKey {
        case flavorKey
        case cpu
        case memory
        case disk
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: FlavorCodingKeys.self)
        if decoderContainer.contains(.flavorKey)
        {
            self.flavorKey = try decoderContainer.decode(String?.self, forKey: .flavorKey)
        }
        if decoderContainer.contains(.cpu)
        {
            self.cpu = try decoderContainer.decode(Int?.self, forKey: .cpu)
        }
        if decoderContainer.contains(.memory)
        {
            self.memory = try decoderContainer.decode(Int?.self, forKey: .memory)
        }
        if decoderContainer.contains(.disk)
        {
            self.disk = try decoderContainer.decode(Int?.self, forKey: .disk)
        }
    }
}
public extension Flavor{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: FlavorCodingKeys.self)
         try encoderContainer.encode(flavorKey, forKey: .flavorKey)
         try encoderContainer.encode(cpu, forKey: .cpu)
         try encoderContainer.encode(memory, forKey: .memory)
         try encoderContainer.encode(disk, forKey: .disk)
    }
}
///  alias
public class Alias:NSObject,Codable{
    /// 别名Id
    var aliasId:String?
    /// 别名名称
    var aliasName:String?
    /// 别名对应的函数名称
    var functionName:String?
    /// 别名描述信息
    var descriptionValue:String?
    /// 别名对应的版本名称
    var version:String?



    public override init(){
            super.init()
    }

    enum AliasCodingKeys: String, CodingKey {
        case aliasId
        case aliasName
        case functionName
        case descriptionValue = "description"
        case version
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: AliasCodingKeys.self)
        if decoderContainer.contains(.aliasId)
        {
            self.aliasId = try decoderContainer.decode(String?.self, forKey: .aliasId)
        }
        if decoderContainer.contains(.aliasName)
        {
            self.aliasName = try decoderContainer.decode(String?.self, forKey: .aliasName)
        }
        if decoderContainer.contains(.functionName)
        {
            self.functionName = try decoderContainer.decode(String?.self, forKey: .functionName)
        }
        if decoderContainer.contains(.descriptionValue)
        {
            self.descriptionValue = try decoderContainer.decode(String?.self, forKey: .descriptionValue)
        }
        if decoderContainer.contains(.version)
        {
            self.version = try decoderContainer.decode(String?.self, forKey: .version)
        }
    }
}
public extension Alias{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: AliasCodingKeys.self)
         try encoderContainer.encode(aliasId, forKey: .aliasId)
         try encoderContainer.encode(aliasName, forKey: .aliasName)
         try encoderContainer.encode(functionName, forKey: .functionName)
         try encoderContainer.encode(descriptionValue, forKey: .descriptionValue)
         try encoderContainer.encode(version, forKey: .version)
    }
}
///  listFunctionResult
public class ListFunctionResult:NSObject,Codable{
    /// 函数列表
    var functions:[FunctionSpec?]?
    /// 函数总数
    var totalCount:Int?



    public override init(){
            super.init()
    }

    enum ListFunctionResultCodingKeys: String, CodingKey {
        case functions
        case totalCount
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: ListFunctionResultCodingKeys.self)
        if decoderContainer.contains(.functions)
        {
            self.functions = try decoderContainer.decode([FunctionSpec?]?.self, forKey: .functions)
        }
        if decoderContainer.contains(.totalCount)
        {
            self.totalCount = try decoderContainer.decode(Int?.self, forKey: .totalCount)
        }
    }
}
public extension ListFunctionResult{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: ListFunctionResultCodingKeys.self)
         try encoderContainer.encode(functions, forKey: .functions)
         try encoderContainer.encode(totalCount, forKey: .totalCount)
    }
}

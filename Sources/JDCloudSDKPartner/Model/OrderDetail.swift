/* Copyright 2018 JDCLOUD.COM

   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at

     http:#www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.

   
   

   
   Contact: 

   NOTE: This class is auto generated by the jdcloud code generator program.
 */


import Foundation

///  orderDetail
@objc(OrderDetail)
public class OrderDetail:NSObject,Codable{
    /// 订单详情列表
    var orderItemDetails:[OrderItemDetail?]?
    /// 子订单列表
    var childOrderDetailList:[OrderDetail?]?
    /// 订单编号
    var orderNumber:String?
    /// 订单状态:已支付
    var status:String?
    /// 订单类型
    var orderType:String?
    /// 订单计费类型：按配置、包年包月、按用量
    var chargeMode:String?
    /// 产品线
    var appName:String?
    /// 产品名称(产品类型)
    var serviceName:String?
    /// 付费方式
    var payType:String?
    /// 自营类型：1-自营，2-非自营，3-二者并存
    var selfSupportType:String?
    /// 站点类型 0：主站,1：国际站,2：云市场
    var siteType:String?
    /// 下单时间
    var createTime:String?
    /// 支付时间
    var payTime:String?
    /// 应付价格是否被修改过：0-未修改，1-已修改
    var isActualFeeModified:String?
    /// 订单总额（元）
    var totalFee:Double?
    /// 应付总额（元）
    var actualFee:Double?
    /// 优惠总额（元）
    var discountFee:Double?
    /// 已支付总额（元）
    var paidFee:Double?
    /// 代金券金额（元）
    var favorableFee:Double?
    /// 代金券Json
    var favorableFeeJson:String?
    /// 现金支付
    var moneyPay:Double?
    /// 余额支付
    var balancePay:Double?
    /// 支付确认页地址
    var payUrl:String?
    /// 用户pin
    var pin:String?
    /// 备注
    var remark:String?
    /// 自动取消时间
    var expirationTime:String?
    /// 已退款金额
    var refundFee:Double?
    /// 订单类型：新购、续费、升降配
    var orderTypeInfo:Double?
    /// 订单计费类型：按配置、包年包月、按用量actualFee
    var chargeModeInfo:Double?
    /// 订单状态：未支付、已支付、处理中、已取消
    var statusInfo:Double?
    /// 自营类型：1-自营，2-非自营，3-二者并存
    var selfSupportTypeInfo:Int?
    /// 现金支付方式（企业、个人网银、京东支付、微信、线下汇款）
    var paymentChannel:Int?
    /// 修改时间
    var updatedTime:String?
    /// 支付单号
    var paymentNumber:String?
    /// 付款人
    var payer:String?
    /// 申请人
    var proposer:String?
    /// 应用code
    var appCode:String?



    public override init(){
            super.init()
    }

    enum OrderDetailCodingKeys: String, CodingKey {
        case orderItemDetails
        case childOrderDetailList
        case orderNumber
        case status
        case orderType
        case chargeMode
        case appName
        case serviceName
        case payType
        case selfSupportType
        case siteType
        case createTime
        case payTime
        case isActualFeeModified
        case totalFee
        case actualFee
        case discountFee
        case paidFee
        case favorableFee
        case favorableFeeJson
        case moneyPay
        case balancePay
        case payUrl
        case pin
        case remark
        case expirationTime
        case refundFee
        case orderTypeInfo
        case chargeModeInfo
        case statusInfo
        case selfSupportTypeInfo
        case paymentChannel
        case updatedTime
        case paymentNumber
        case payer
        case proposer
        case appCode
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: OrderDetailCodingKeys.self)
        if decoderContainer.contains(.orderItemDetails)
        {
            self.orderItemDetails = try decoderContainer.decode([OrderItemDetail?]?.self, forKey: .orderItemDetails)
        }
        if decoderContainer.contains(.childOrderDetailList)
        {
            self.childOrderDetailList = try decoderContainer.decode([OrderDetail?]?.self, forKey: .childOrderDetailList)
        }
        if decoderContainer.contains(.orderNumber)
        {
            self.orderNumber = try decoderContainer.decode(String?.self, forKey: .orderNumber)
        }
        if decoderContainer.contains(.status)
        {
            self.status = try decoderContainer.decode(String?.self, forKey: .status)
        }
        if decoderContainer.contains(.orderType)
        {
            self.orderType = try decoderContainer.decode(String?.self, forKey: .orderType)
        }
        if decoderContainer.contains(.chargeMode)
        {
            self.chargeMode = try decoderContainer.decode(String?.self, forKey: .chargeMode)
        }
        if decoderContainer.contains(.appName)
        {
            self.appName = try decoderContainer.decode(String?.self, forKey: .appName)
        }
        if decoderContainer.contains(.serviceName)
        {
            self.serviceName = try decoderContainer.decode(String?.self, forKey: .serviceName)
        }
        if decoderContainer.contains(.payType)
        {
            self.payType = try decoderContainer.decode(String?.self, forKey: .payType)
        }
        if decoderContainer.contains(.selfSupportType)
        {
            self.selfSupportType = try decoderContainer.decode(String?.self, forKey: .selfSupportType)
        }
        if decoderContainer.contains(.siteType)
        {
            self.siteType = try decoderContainer.decode(String?.self, forKey: .siteType)
        }
        if decoderContainer.contains(.createTime)
        {
            self.createTime = try decoderContainer.decode(String?.self, forKey: .createTime)
        }
        if decoderContainer.contains(.payTime)
        {
            self.payTime = try decoderContainer.decode(String?.self, forKey: .payTime)
        }
        if decoderContainer.contains(.isActualFeeModified)
        {
            self.isActualFeeModified = try decoderContainer.decode(String?.self, forKey: .isActualFeeModified)
        }
        if decoderContainer.contains(.totalFee)
        {
            self.totalFee = try decoderContainer.decode(Double?.self, forKey: .totalFee)
        }
        if decoderContainer.contains(.actualFee)
        {
            self.actualFee = try decoderContainer.decode(Double?.self, forKey: .actualFee)
        }
        if decoderContainer.contains(.discountFee)
        {
            self.discountFee = try decoderContainer.decode(Double?.self, forKey: .discountFee)
        }
        if decoderContainer.contains(.paidFee)
        {
            self.paidFee = try decoderContainer.decode(Double?.self, forKey: .paidFee)
        }
        if decoderContainer.contains(.favorableFee)
        {
            self.favorableFee = try decoderContainer.decode(Double?.self, forKey: .favorableFee)
        }
        if decoderContainer.contains(.favorableFeeJson)
        {
            self.favorableFeeJson = try decoderContainer.decode(String?.self, forKey: .favorableFeeJson)
        }
        if decoderContainer.contains(.moneyPay)
        {
            self.moneyPay = try decoderContainer.decode(Double?.self, forKey: .moneyPay)
        }
        if decoderContainer.contains(.balancePay)
        {
            self.balancePay = try decoderContainer.decode(Double?.self, forKey: .balancePay)
        }
        if decoderContainer.contains(.payUrl)
        {
            self.payUrl = try decoderContainer.decode(String?.self, forKey: .payUrl)
        }
        if decoderContainer.contains(.pin)
        {
            self.pin = try decoderContainer.decode(String?.self, forKey: .pin)
        }
        if decoderContainer.contains(.remark)
        {
            self.remark = try decoderContainer.decode(String?.self, forKey: .remark)
        }
        if decoderContainer.contains(.expirationTime)
        {
            self.expirationTime = try decoderContainer.decode(String?.self, forKey: .expirationTime)
        }
        if decoderContainer.contains(.refundFee)
        {
            self.refundFee = try decoderContainer.decode(Double?.self, forKey: .refundFee)
        }
        if decoderContainer.contains(.orderTypeInfo)
        {
            self.orderTypeInfo = try decoderContainer.decode(Double?.self, forKey: .orderTypeInfo)
        }
        if decoderContainer.contains(.chargeModeInfo)
        {
            self.chargeModeInfo = try decoderContainer.decode(Double?.self, forKey: .chargeModeInfo)
        }
        if decoderContainer.contains(.statusInfo)
        {
            self.statusInfo = try decoderContainer.decode(Double?.self, forKey: .statusInfo)
        }
        if decoderContainer.contains(.selfSupportTypeInfo)
        {
            self.selfSupportTypeInfo = try decoderContainer.decode(Int?.self, forKey: .selfSupportTypeInfo)
        }
        if decoderContainer.contains(.paymentChannel)
        {
            self.paymentChannel = try decoderContainer.decode(Int?.self, forKey: .paymentChannel)
        }
        if decoderContainer.contains(.updatedTime)
        {
            self.updatedTime = try decoderContainer.decode(String?.self, forKey: .updatedTime)
        }
        if decoderContainer.contains(.paymentNumber)
        {
            self.paymentNumber = try decoderContainer.decode(String?.self, forKey: .paymentNumber)
        }
        if decoderContainer.contains(.payer)
        {
            self.payer = try decoderContainer.decode(String?.self, forKey: .payer)
        }
        if decoderContainer.contains(.proposer)
        {
            self.proposer = try decoderContainer.decode(String?.self, forKey: .proposer)
        }
        if decoderContainer.contains(.appCode)
        {
            self.appCode = try decoderContainer.decode(String?.self, forKey: .appCode)
        }
    }
}
public extension OrderDetail{
    public func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: OrderDetailCodingKeys.self)
         try encoderContainer.encode(orderItemDetails, forKey: .orderItemDetails)
         try encoderContainer.encode(childOrderDetailList, forKey: .childOrderDetailList)
         try encoderContainer.encode(orderNumber, forKey: .orderNumber)
         try encoderContainer.encode(status, forKey: .status)
         try encoderContainer.encode(orderType, forKey: .orderType)
         try encoderContainer.encode(chargeMode, forKey: .chargeMode)
         try encoderContainer.encode(appName, forKey: .appName)
         try encoderContainer.encode(serviceName, forKey: .serviceName)
         try encoderContainer.encode(payType, forKey: .payType)
         try encoderContainer.encode(selfSupportType, forKey: .selfSupportType)
         try encoderContainer.encode(siteType, forKey: .siteType)
         try encoderContainer.encode(createTime, forKey: .createTime)
         try encoderContainer.encode(payTime, forKey: .payTime)
         try encoderContainer.encode(isActualFeeModified, forKey: .isActualFeeModified)
         try encoderContainer.encode(totalFee, forKey: .totalFee)
         try encoderContainer.encode(actualFee, forKey: .actualFee)
         try encoderContainer.encode(discountFee, forKey: .discountFee)
         try encoderContainer.encode(paidFee, forKey: .paidFee)
         try encoderContainer.encode(favorableFee, forKey: .favorableFee)
         try encoderContainer.encode(favorableFeeJson, forKey: .favorableFeeJson)
         try encoderContainer.encode(moneyPay, forKey: .moneyPay)
         try encoderContainer.encode(balancePay, forKey: .balancePay)
         try encoderContainer.encode(payUrl, forKey: .payUrl)
         try encoderContainer.encode(pin, forKey: .pin)
         try encoderContainer.encode(remark, forKey: .remark)
         try encoderContainer.encode(expirationTime, forKey: .expirationTime)
         try encoderContainer.encode(refundFee, forKey: .refundFee)
         try encoderContainer.encode(orderTypeInfo, forKey: .orderTypeInfo)
         try encoderContainer.encode(chargeModeInfo, forKey: .chargeModeInfo)
         try encoderContainer.encode(statusInfo, forKey: .statusInfo)
         try encoderContainer.encode(selfSupportTypeInfo, forKey: .selfSupportTypeInfo)
         try encoderContainer.encode(paymentChannel, forKey: .paymentChannel)
         try encoderContainer.encode(updatedTime, forKey: .updatedTime)
         try encoderContainer.encode(paymentNumber, forKey: .paymentNumber)
         try encoderContainer.encode(payer, forKey: .payer)
         try encoderContainer.encode(proposer, forKey: .proposer)
         try encoderContainer.encode(appCode, forKey: .appCode)
    }
}

/* Copyright 2018 JDCLOUD.COM

   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at

     http:#www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.

   
   

   
   Contact: 

   NOTE: This class is auto generated by the jdcloud code generator program.
 */


import Foundation

///  orderItemDetail
@objc(OrderItemDetail)
public class OrderItemDetail:NSObject,Codable{
    /// 价格快照Json
    var priceSnapshot:String?
    /// 变更前资源配置
    var extraInfoBefore:[ExtraInfo?]?
    /// 变更后资源配置
    var extraInfoAfter:[ExtraInfo?]?
    /// 商品规格参数
    var extraInfo:[ExtraInfo?]?
    /// 应付金额（元）
    var actualFee:Double?
    /// 数量
    var quantity:Int?
    /// 续费前资源到期时间
    var expireDateBefore:String?
    /// 续费后资源到期时间
    var expireDateAfter:String?
    /// 计费时长单位
    var unit:String?
    /// 计费时长（购买时长）
    var chargeDuration:Int?
    /// 计费类型
    var chargeMode:String?
    /// 订单总额（元）
    var totalFee:Double?
    /// 资源类型
    var serviceName:String?
    /// 站点类型 0：主站,1：国际站,2：云市场
    var siteType:String?
    /// 下单时间
    var createTime:String?
    /// 订单商品状态：创建中、成功、失败
    var status:Int?
    /// 资源id
    var itemId:String?
    /// 资源名称
    var itemName:String?
    /// 计算公式（配置细项）
    var formula:String?
    /// 订单编号
    var orderNumber:String?
    /// 实际支付总金额
    var allActualFee:Double?
    /// 备注
    var remark:String?
    /// 现金支付
    var moneyPay:Double?
    /// 余额支付
    var balancePay:Double?
    /// 已退款金额
    var refundFee:Double?
    /// 订单计费类型：按配置、包年包月、按用量actualFee
    var chargeModeInfo:Int?
    /// 退款状态 RefundStatusEnum 0,申请退款 1,退款审核中 2,已退款 3,已取消 4,退款失败 5,财务审批驳回 6,财务审批通过
    var deleteStatus:Int?
    /// 代金券金额
    var favorableFee:Double?
    /// 变配明细
    var resizeFormulaType:Int?



    public override init(){
            super.init()
    }

    enum OrderItemDetailCodingKeys: String, CodingKey {
        case priceSnapshot
        case extraInfoBefore
        case extraInfoAfter
        case extraInfo
        case actualFee
        case quantity
        case expireDateBefore
        case expireDateAfter
        case unit
        case chargeDuration
        case chargeMode
        case totalFee
        case serviceName
        case siteType
        case createTime
        case status
        case itemId
        case itemName
        case formula
        case orderNumber
        case allActualFee
        case remark
        case moneyPay
        case balancePay
        case refundFee
        case chargeModeInfo
        case deleteStatus
        case favorableFee
        case resizeFormulaType
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: OrderItemDetailCodingKeys.self)
        if decoderContainer.contains(.priceSnapshot)
        {
            self.priceSnapshot = try decoderContainer.decode(String?.self, forKey: .priceSnapshot)
        }
        if decoderContainer.contains(.extraInfoBefore)
        {
            self.extraInfoBefore = try decoderContainer.decode([ExtraInfo?]?.self, forKey: .extraInfoBefore)
        }
        if decoderContainer.contains(.extraInfoAfter)
        {
            self.extraInfoAfter = try decoderContainer.decode([ExtraInfo?]?.self, forKey: .extraInfoAfter)
        }
        if decoderContainer.contains(.extraInfo)
        {
            self.extraInfo = try decoderContainer.decode([ExtraInfo?]?.self, forKey: .extraInfo)
        }
        if decoderContainer.contains(.actualFee)
        {
            self.actualFee = try decoderContainer.decode(Double?.self, forKey: .actualFee)
        }
        if decoderContainer.contains(.quantity)
        {
            self.quantity = try decoderContainer.decode(Int?.self, forKey: .quantity)
        }
        if decoderContainer.contains(.expireDateBefore)
        {
            self.expireDateBefore = try decoderContainer.decode(String?.self, forKey: .expireDateBefore)
        }
        if decoderContainer.contains(.expireDateAfter)
        {
            self.expireDateAfter = try decoderContainer.decode(String?.self, forKey: .expireDateAfter)
        }
        if decoderContainer.contains(.unit)
        {
            self.unit = try decoderContainer.decode(String?.self, forKey: .unit)
        }
        if decoderContainer.contains(.chargeDuration)
        {
            self.chargeDuration = try decoderContainer.decode(Int?.self, forKey: .chargeDuration)
        }
        if decoderContainer.contains(.chargeMode)
        {
            self.chargeMode = try decoderContainer.decode(String?.self, forKey: .chargeMode)
        }
        if decoderContainer.contains(.totalFee)
        {
            self.totalFee = try decoderContainer.decode(Double?.self, forKey: .totalFee)
        }
        if decoderContainer.contains(.serviceName)
        {
            self.serviceName = try decoderContainer.decode(String?.self, forKey: .serviceName)
        }
        if decoderContainer.contains(.siteType)
        {
            self.siteType = try decoderContainer.decode(String?.self, forKey: .siteType)
        }
        if decoderContainer.contains(.createTime)
        {
            self.createTime = try decoderContainer.decode(String?.self, forKey: .createTime)
        }
        if decoderContainer.contains(.status)
        {
            self.status = try decoderContainer.decode(Int?.self, forKey: .status)
        }
        if decoderContainer.contains(.itemId)
        {
            self.itemId = try decoderContainer.decode(String?.self, forKey: .itemId)
        }
        if decoderContainer.contains(.itemName)
        {
            self.itemName = try decoderContainer.decode(String?.self, forKey: .itemName)
        }
        if decoderContainer.contains(.formula)
        {
            self.formula = try decoderContainer.decode(String?.self, forKey: .formula)
        }
        if decoderContainer.contains(.orderNumber)
        {
            self.orderNumber = try decoderContainer.decode(String?.self, forKey: .orderNumber)
        }
        if decoderContainer.contains(.allActualFee)
        {
            self.allActualFee = try decoderContainer.decode(Double?.self, forKey: .allActualFee)
        }
        if decoderContainer.contains(.remark)
        {
            self.remark = try decoderContainer.decode(String?.self, forKey: .remark)
        }
        if decoderContainer.contains(.moneyPay)
        {
            self.moneyPay = try decoderContainer.decode(Double?.self, forKey: .moneyPay)
        }
        if decoderContainer.contains(.balancePay)
        {
            self.balancePay = try decoderContainer.decode(Double?.self, forKey: .balancePay)
        }
        if decoderContainer.contains(.refundFee)
        {
            self.refundFee = try decoderContainer.decode(Double?.self, forKey: .refundFee)
        }
        if decoderContainer.contains(.chargeModeInfo)
        {
            self.chargeModeInfo = try decoderContainer.decode(Int?.self, forKey: .chargeModeInfo)
        }
        if decoderContainer.contains(.deleteStatus)
        {
            self.deleteStatus = try decoderContainer.decode(Int?.self, forKey: .deleteStatus)
        }
        if decoderContainer.contains(.favorableFee)
        {
            self.favorableFee = try decoderContainer.decode(Double?.self, forKey: .favorableFee)
        }
        if decoderContainer.contains(.resizeFormulaType)
        {
            self.resizeFormulaType = try decoderContainer.decode(Int?.self, forKey: .resizeFormulaType)
        }
    }
}
public extension OrderItemDetail{
    public func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: OrderItemDetailCodingKeys.self)
         try encoderContainer.encode(priceSnapshot, forKey: .priceSnapshot)
         try encoderContainer.encode(extraInfoBefore, forKey: .extraInfoBefore)
         try encoderContainer.encode(extraInfoAfter, forKey: .extraInfoAfter)
         try encoderContainer.encode(extraInfo, forKey: .extraInfo)
         try encoderContainer.encode(actualFee, forKey: .actualFee)
         try encoderContainer.encode(quantity, forKey: .quantity)
         try encoderContainer.encode(expireDateBefore, forKey: .expireDateBefore)
         try encoderContainer.encode(expireDateAfter, forKey: .expireDateAfter)
         try encoderContainer.encode(unit, forKey: .unit)
         try encoderContainer.encode(chargeDuration, forKey: .chargeDuration)
         try encoderContainer.encode(chargeMode, forKey: .chargeMode)
         try encoderContainer.encode(totalFee, forKey: .totalFee)
         try encoderContainer.encode(serviceName, forKey: .serviceName)
         try encoderContainer.encode(siteType, forKey: .siteType)
         try encoderContainer.encode(createTime, forKey: .createTime)
         try encoderContainer.encode(status, forKey: .status)
         try encoderContainer.encode(itemId, forKey: .itemId)
         try encoderContainer.encode(itemName, forKey: .itemName)
         try encoderContainer.encode(formula, forKey: .formula)
         try encoderContainer.encode(orderNumber, forKey: .orderNumber)
         try encoderContainer.encode(allActualFee, forKey: .allActualFee)
         try encoderContainer.encode(remark, forKey: .remark)
         try encoderContainer.encode(moneyPay, forKey: .moneyPay)
         try encoderContainer.encode(balancePay, forKey: .balancePay)
         try encoderContainer.encode(refundFee, forKey: .refundFee)
         try encoderContainer.encode(chargeModeInfo, forKey: .chargeModeInfo)
         try encoderContainer.encode(deleteStatus, forKey: .deleteStatus)
         try encoderContainer.encode(favorableFee, forKey: .favorableFee)
         try encoderContainer.encode(resizeFormulaType, forKey: .resizeFormulaType)
    }
}

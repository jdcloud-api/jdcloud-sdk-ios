/* Copyright 2018 JDCLOUD.COM

   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at

     http:#www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.

   returnRule
   渠道管理平台返还规则

   OpenAPI spec version: v1
   Contact: 

   NOTE: This class is auto generated by the jdcloud code generator program.
 */


import Foundation
///  dicDetailQuery
public class DicDetailQuery:NSObject,Codable{
    /// ID
    var id:Double?
    /// 字典类型
    var codeType:String?
    /// 字典编码
    var code:String?
    /// 字典编码名称
    var name:String?
    /// 字典编码值
    var value:String?
    /// null
    var useFlag:Bool?
    /// 系统类型
    var systemType:String?
    /// 引用值
    var refValue:String?
    /// 顺序
    var seq:Int?
    /// 字典说明
    var remark:String?
    /// 创建时间
    var createTime:String?
    /// 创建人
    var createUser:String?
    /// 修改时间
    var updateTime:String?
    /// 修改人
    var updateUser:String?
    /// 是否删除0未删除,1已删除
    var yn:Int?
    /// 当前页序号
    var pageIndex:Int?
    /// 每页结果数量
    var pageSize:Int?
    /// Offset
    var offset:Int?



    public override init(){
            super.init()
    }

    enum DicDetailQueryCodingKeys: String, CodingKey {
        case id
        case codeType
        case code
        case name
        case value
        case useFlag
        case systemType
        case refValue
        case seq
        case remark
        case createTime
        case createUser
        case updateTime
        case updateUser
        case yn
        case pageIndex
        case pageSize
        case offset
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: DicDetailQueryCodingKeys.self)
        if decoderContainer.contains(.id)
        {
            self.id = try decoderContainer.decode(Double?.self, forKey: .id)
        }
        if decoderContainer.contains(.codeType)
        {
            self.codeType = try decoderContainer.decode(String?.self, forKey: .codeType)
        }
        if decoderContainer.contains(.code)
        {
            self.code = try decoderContainer.decode(String?.self, forKey: .code)
        }
        if decoderContainer.contains(.name)
        {
            self.name = try decoderContainer.decode(String?.self, forKey: .name)
        }
        if decoderContainer.contains(.value)
        {
            self.value = try decoderContainer.decode(String?.self, forKey: .value)
        }
        if decoderContainer.contains(.useFlag)
        {
            self.useFlag = try decoderContainer.decode(Bool?.self, forKey: .useFlag)
        }
        if decoderContainer.contains(.systemType)
        {
            self.systemType = try decoderContainer.decode(String?.self, forKey: .systemType)
        }
        if decoderContainer.contains(.refValue)
        {
            self.refValue = try decoderContainer.decode(String?.self, forKey: .refValue)
        }
        if decoderContainer.contains(.seq)
        {
            self.seq = try decoderContainer.decode(Int?.self, forKey: .seq)
        }
        if decoderContainer.contains(.remark)
        {
            self.remark = try decoderContainer.decode(String?.self, forKey: .remark)
        }
        if decoderContainer.contains(.createTime)
        {
            self.createTime = try decoderContainer.decode(String?.self, forKey: .createTime)
        }
        if decoderContainer.contains(.createUser)
        {
            self.createUser = try decoderContainer.decode(String?.self, forKey: .createUser)
        }
        if decoderContainer.contains(.updateTime)
        {
            self.updateTime = try decoderContainer.decode(String?.self, forKey: .updateTime)
        }
        if decoderContainer.contains(.updateUser)
        {
            self.updateUser = try decoderContainer.decode(String?.self, forKey: .updateUser)
        }
        if decoderContainer.contains(.yn)
        {
            self.yn = try decoderContainer.decode(Int?.self, forKey: .yn)
        }
        if decoderContainer.contains(.pageIndex)
        {
            self.pageIndex = try decoderContainer.decode(Int?.self, forKey: .pageIndex)
        }
        if decoderContainer.contains(.pageSize)
        {
            self.pageSize = try decoderContainer.decode(Int?.self, forKey: .pageSize)
        }
        if decoderContainer.contains(.offset)
        {
            self.offset = try decoderContainer.decode(Int?.self, forKey: .offset)
        }
    }
}
public extension DicDetailQuery{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: DicDetailQueryCodingKeys.self)
         try encoderContainer.encode(id, forKey: .id)
         try encoderContainer.encode(codeType, forKey: .codeType)
         try encoderContainer.encode(code, forKey: .code)
         try encoderContainer.encode(name, forKey: .name)
         try encoderContainer.encode(value, forKey: .value)
         try encoderContainer.encode(useFlag, forKey: .useFlag)
         try encoderContainer.encode(systemType, forKey: .systemType)
         try encoderContainer.encode(refValue, forKey: .refValue)
         try encoderContainer.encode(seq, forKey: .seq)
         try encoderContainer.encode(remark, forKey: .remark)
         try encoderContainer.encode(createTime, forKey: .createTime)
         try encoderContainer.encode(createUser, forKey: .createUser)
         try encoderContainer.encode(updateTime, forKey: .updateTime)
         try encoderContainer.encode(updateUser, forKey: .updateUser)
         try encoderContainer.encode(yn, forKey: .yn)
         try encoderContainer.encode(pageIndex, forKey: .pageIndex)
         try encoderContainer.encode(pageSize, forKey: .pageSize)
         try encoderContainer.encode(offset, forKey: .offset)
    }
}
///  dicDetail
public class DicDetail:NSObject,Codable{
    /// ID
    var id:Double?
    /// 字典类型
    var codeType:String?
    /// 字典编码
    var code:String?
    /// 字典编码名称
    var name:String?
    /// 字典编码值
    var value:String?
    /// null
    var useFlag:Bool?
    /// 系统类型
    var systemType:String?
    /// 引用值
    var refValue:String?
    /// 顺序
    var seq:Int?
    /// 字典说明
    var remark:String?
    /// 创建时间
    var createTime:String?
    /// 创建人
    var createUser:String?
    /// 修改时间
    var updateTime:String?
    /// 修改人
    var updateUser:String?
    /// 是否删除0未删除,1已删除
    var yn:Int?



    public override init(){
            super.init()
    }

    enum DicDetailCodingKeys: String, CodingKey {
        case id
        case codeType
        case code
        case name
        case value
        case useFlag
        case systemType
        case refValue
        case seq
        case remark
        case createTime
        case createUser
        case updateTime
        case updateUser
        case yn
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: DicDetailCodingKeys.self)
        if decoderContainer.contains(.id)
        {
            self.id = try decoderContainer.decode(Double?.self, forKey: .id)
        }
        if decoderContainer.contains(.codeType)
        {
            self.codeType = try decoderContainer.decode(String?.self, forKey: .codeType)
        }
        if decoderContainer.contains(.code)
        {
            self.code = try decoderContainer.decode(String?.self, forKey: .code)
        }
        if decoderContainer.contains(.name)
        {
            self.name = try decoderContainer.decode(String?.self, forKey: .name)
        }
        if decoderContainer.contains(.value)
        {
            self.value = try decoderContainer.decode(String?.self, forKey: .value)
        }
        if decoderContainer.contains(.useFlag)
        {
            self.useFlag = try decoderContainer.decode(Bool?.self, forKey: .useFlag)
        }
        if decoderContainer.contains(.systemType)
        {
            self.systemType = try decoderContainer.decode(String?.self, forKey: .systemType)
        }
        if decoderContainer.contains(.refValue)
        {
            self.refValue = try decoderContainer.decode(String?.self, forKey: .refValue)
        }
        if decoderContainer.contains(.seq)
        {
            self.seq = try decoderContainer.decode(Int?.self, forKey: .seq)
        }
        if decoderContainer.contains(.remark)
        {
            self.remark = try decoderContainer.decode(String?.self, forKey: .remark)
        }
        if decoderContainer.contains(.createTime)
        {
            self.createTime = try decoderContainer.decode(String?.self, forKey: .createTime)
        }
        if decoderContainer.contains(.createUser)
        {
            self.createUser = try decoderContainer.decode(String?.self, forKey: .createUser)
        }
        if decoderContainer.contains(.updateTime)
        {
            self.updateTime = try decoderContainer.decode(String?.self, forKey: .updateTime)
        }
        if decoderContainer.contains(.updateUser)
        {
            self.updateUser = try decoderContainer.decode(String?.self, forKey: .updateUser)
        }
        if decoderContainer.contains(.yn)
        {
            self.yn = try decoderContainer.decode(Int?.self, forKey: .yn)
        }
    }
}
public extension DicDetail{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: DicDetailCodingKeys.self)
         try encoderContainer.encode(id, forKey: .id)
         try encoderContainer.encode(codeType, forKey: .codeType)
         try encoderContainer.encode(code, forKey: .code)
         try encoderContainer.encode(name, forKey: .name)
         try encoderContainer.encode(value, forKey: .value)
         try encoderContainer.encode(useFlag, forKey: .useFlag)
         try encoderContainer.encode(systemType, forKey: .systemType)
         try encoderContainer.encode(refValue, forKey: .refValue)
         try encoderContainer.encode(seq, forKey: .seq)
         try encoderContainer.encode(remark, forKey: .remark)
         try encoderContainer.encode(createTime, forKey: .createTime)
         try encoderContainer.encode(createUser, forKey: .createUser)
         try encoderContainer.encode(updateTime, forKey: .updateTime)
         try encoderContainer.encode(updateUser, forKey: .updateUser)
         try encoderContainer.encode(yn, forKey: .yn)
    }
}
///  returnBillDetailResult
public class ReturnBillDetailResult:NSObject,Codable{
    /// ID
    var id:Double?
    /// 服务商ID
    var distributorId:String?
    /// 渠道商类型
    var distributorType:Int?
    /// 生成时间
    var generateTime:String?
    /// 返还类型
    var returnType:Int?
    /// 返还项目ID
    var itemId:Double?
    /// 返还项目名称
    var itemName:String?
    /// 周期类型
    var circleType:Int?
    /// 周期名称
    var circleName:Int?
    /// 周期值
    var circleValue:Int?
    /// 周期值名称
    var circleValueName:String?
    /// 开始时间
    var circleBegin:String?
    /// 结束时间
    var circleEnd:String?
    /// 返还金额
    var returnMount:Double?
    /// 业绩金额
    var amount:Double?
    /// 条件值
    var conditionValue:String?
    /// 条件值名称
    var conditionValueName:String?
    /// 是否返还标识
    var returnFlag:Int?
    /// 返还比例
    var returnRatio:Double?
    /// 返还比例名称
    var returnRatioName:String?
    /// 返还单号
    var returnOrderId:String?
    /// 部门ID
    var deptId:Int?
    /// 部门名称
    var deptName:String?
    /// 状态
    var status:Int?
    /// 创建时间
    var createTime:String?
    /// 创建人
    var createUser:String?
    /// 修改时间
    var updateTime:String?
    /// 修改人
    var updateUser:String?
    /// 是否删除0未删除,1已删除
    var yn:Int?



    public override init(){
            super.init()
    }

    enum ReturnBillDetailResultCodingKeys: String, CodingKey {
        case id
        case distributorId
        case distributorType
        case generateTime
        case returnType
        case itemId
        case itemName
        case circleType
        case circleName
        case circleValue
        case circleValueName
        case circleBegin
        case circleEnd
        case returnMount
        case amount
        case conditionValue
        case conditionValueName
        case returnFlag
        case returnRatio
        case returnRatioName
        case returnOrderId
        case deptId
        case deptName
        case status
        case createTime
        case createUser
        case updateTime
        case updateUser
        case yn
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: ReturnBillDetailResultCodingKeys.self)
        if decoderContainer.contains(.id)
        {
            self.id = try decoderContainer.decode(Double?.self, forKey: .id)
        }
        if decoderContainer.contains(.distributorId)
        {
            self.distributorId = try decoderContainer.decode(String?.self, forKey: .distributorId)
        }
        if decoderContainer.contains(.distributorType)
        {
            self.distributorType = try decoderContainer.decode(Int?.self, forKey: .distributorType)
        }
        if decoderContainer.contains(.generateTime)
        {
            self.generateTime = try decoderContainer.decode(String?.self, forKey: .generateTime)
        }
        if decoderContainer.contains(.returnType)
        {
            self.returnType = try decoderContainer.decode(Int?.self, forKey: .returnType)
        }
        if decoderContainer.contains(.itemId)
        {
            self.itemId = try decoderContainer.decode(Double?.self, forKey: .itemId)
        }
        if decoderContainer.contains(.itemName)
        {
            self.itemName = try decoderContainer.decode(String?.self, forKey: .itemName)
        }
        if decoderContainer.contains(.circleType)
        {
            self.circleType = try decoderContainer.decode(Int?.self, forKey: .circleType)
        }
        if decoderContainer.contains(.circleName)
        {
            self.circleName = try decoderContainer.decode(Int?.self, forKey: .circleName)
        }
        if decoderContainer.contains(.circleValue)
        {
            self.circleValue = try decoderContainer.decode(Int?.self, forKey: .circleValue)
        }
        if decoderContainer.contains(.circleValueName)
        {
            self.circleValueName = try decoderContainer.decode(String?.self, forKey: .circleValueName)
        }
        if decoderContainer.contains(.circleBegin)
        {
            self.circleBegin = try decoderContainer.decode(String?.self, forKey: .circleBegin)
        }
        if decoderContainer.contains(.circleEnd)
        {
            self.circleEnd = try decoderContainer.decode(String?.self, forKey: .circleEnd)
        }
        if decoderContainer.contains(.returnMount)
        {
            self.returnMount = try decoderContainer.decode(Double?.self, forKey: .returnMount)
        }
        if decoderContainer.contains(.amount)
        {
            self.amount = try decoderContainer.decode(Double?.self, forKey: .amount)
        }
        if decoderContainer.contains(.conditionValue)
        {
            self.conditionValue = try decoderContainer.decode(String?.self, forKey: .conditionValue)
        }
        if decoderContainer.contains(.conditionValueName)
        {
            self.conditionValueName = try decoderContainer.decode(String?.self, forKey: .conditionValueName)
        }
        if decoderContainer.contains(.returnFlag)
        {
            self.returnFlag = try decoderContainer.decode(Int?.self, forKey: .returnFlag)
        }
        if decoderContainer.contains(.returnRatio)
        {
            self.returnRatio = try decoderContainer.decode(Double?.self, forKey: .returnRatio)
        }
        if decoderContainer.contains(.returnRatioName)
        {
            self.returnRatioName = try decoderContainer.decode(String?.self, forKey: .returnRatioName)
        }
        if decoderContainer.contains(.returnOrderId)
        {
            self.returnOrderId = try decoderContainer.decode(String?.self, forKey: .returnOrderId)
        }
        if decoderContainer.contains(.deptId)
        {
            self.deptId = try decoderContainer.decode(Int?.self, forKey: .deptId)
        }
        if decoderContainer.contains(.deptName)
        {
            self.deptName = try decoderContainer.decode(String?.self, forKey: .deptName)
        }
        if decoderContainer.contains(.status)
        {
            self.status = try decoderContainer.decode(Int?.self, forKey: .status)
        }
        if decoderContainer.contains(.createTime)
        {
            self.createTime = try decoderContainer.decode(String?.self, forKey: .createTime)
        }
        if decoderContainer.contains(.createUser)
        {
            self.createUser = try decoderContainer.decode(String?.self, forKey: .createUser)
        }
        if decoderContainer.contains(.updateTime)
        {
            self.updateTime = try decoderContainer.decode(String?.self, forKey: .updateTime)
        }
        if decoderContainer.contains(.updateUser)
        {
            self.updateUser = try decoderContainer.decode(String?.self, forKey: .updateUser)
        }
        if decoderContainer.contains(.yn)
        {
            self.yn = try decoderContainer.decode(Int?.self, forKey: .yn)
        }
    }
}
public extension ReturnBillDetailResult{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: ReturnBillDetailResultCodingKeys.self)
         try encoderContainer.encode(id, forKey: .id)
         try encoderContainer.encode(distributorId, forKey: .distributorId)
         try encoderContainer.encode(distributorType, forKey: .distributorType)
         try encoderContainer.encode(generateTime, forKey: .generateTime)
         try encoderContainer.encode(returnType, forKey: .returnType)
         try encoderContainer.encode(itemId, forKey: .itemId)
         try encoderContainer.encode(itemName, forKey: .itemName)
         try encoderContainer.encode(circleType, forKey: .circleType)
         try encoderContainer.encode(circleName, forKey: .circleName)
         try encoderContainer.encode(circleValue, forKey: .circleValue)
         try encoderContainer.encode(circleValueName, forKey: .circleValueName)
         try encoderContainer.encode(circleBegin, forKey: .circleBegin)
         try encoderContainer.encode(circleEnd, forKey: .circleEnd)
         try encoderContainer.encode(returnMount, forKey: .returnMount)
         try encoderContainer.encode(amount, forKey: .amount)
         try encoderContainer.encode(conditionValue, forKey: .conditionValue)
         try encoderContainer.encode(conditionValueName, forKey: .conditionValueName)
         try encoderContainer.encode(returnFlag, forKey: .returnFlag)
         try encoderContainer.encode(returnRatio, forKey: .returnRatio)
         try encoderContainer.encode(returnRatioName, forKey: .returnRatioName)
         try encoderContainer.encode(returnOrderId, forKey: .returnOrderId)
         try encoderContainer.encode(deptId, forKey: .deptId)
         try encoderContainer.encode(deptName, forKey: .deptName)
         try encoderContainer.encode(status, forKey: .status)
         try encoderContainer.encode(createTime, forKey: .createTime)
         try encoderContainer.encode(createUser, forKey: .createUser)
         try encoderContainer.encode(updateTime, forKey: .updateTime)
         try encoderContainer.encode(updateUser, forKey: .updateUser)
         try encoderContainer.encode(yn, forKey: .yn)
    }
}
///  returnBillStatusResult
public class ReturnBillStatusResult:NSObject,Codable{
    /// ID
    var id:Double?
    /// 返还单号
    var retrunBillId:String?
    /// 状态
    var status:Int?
    /// 状态名称
    var statusName:String?
    /// 驳回原因
    var operatorValue:String?
    /// 说明
    var remark:String?
    /// 创建时间
    var createTime:String?
    /// 创建人
    var createUser:String?
    /// 修改时间
    var updateTime:String?
    /// 修改人
    var updateUser:String?
    /// 是否删除0未删除,1已删除
    var yn:Int?



    public override init(){
            super.init()
    }

    enum ReturnBillStatusResultCodingKeys: String, CodingKey {
        case id
        case retrunBillId
        case status
        case statusName
        case operatorValue = "operator"
        case remark
        case createTime
        case createUser
        case updateTime
        case updateUser
        case yn
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: ReturnBillStatusResultCodingKeys.self)
        if decoderContainer.contains(.id)
        {
            self.id = try decoderContainer.decode(Double?.self, forKey: .id)
        }
        if decoderContainer.contains(.retrunBillId)
        {
            self.retrunBillId = try decoderContainer.decode(String?.self, forKey: .retrunBillId)
        }
        if decoderContainer.contains(.status)
        {
            self.status = try decoderContainer.decode(Int?.self, forKey: .status)
        }
        if decoderContainer.contains(.statusName)
        {
            self.statusName = try decoderContainer.decode(String?.self, forKey: .statusName)
        }
        if decoderContainer.contains(.operatorValue)
        {
            self.operatorValue = try decoderContainer.decode(String?.self, forKey: .operatorValue)
        }
        if decoderContainer.contains(.remark)
        {
            self.remark = try decoderContainer.decode(String?.self, forKey: .remark)
        }
        if decoderContainer.contains(.createTime)
        {
            self.createTime = try decoderContainer.decode(String?.self, forKey: .createTime)
        }
        if decoderContainer.contains(.createUser)
        {
            self.createUser = try decoderContainer.decode(String?.self, forKey: .createUser)
        }
        if decoderContainer.contains(.updateTime)
        {
            self.updateTime = try decoderContainer.decode(String?.self, forKey: .updateTime)
        }
        if decoderContainer.contains(.updateUser)
        {
            self.updateUser = try decoderContainer.decode(String?.self, forKey: .updateUser)
        }
        if decoderContainer.contains(.yn)
        {
            self.yn = try decoderContainer.decode(Int?.self, forKey: .yn)
        }
    }
}
public extension ReturnBillStatusResult{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: ReturnBillStatusResultCodingKeys.self)
         try encoderContainer.encode(id, forKey: .id)
         try encoderContainer.encode(retrunBillId, forKey: .retrunBillId)
         try encoderContainer.encode(status, forKey: .status)
         try encoderContainer.encode(statusName, forKey: .statusName)
         try encoderContainer.encode(operatorValue, forKey: .operatorValue)
         try encoderContainer.encode(remark, forKey: .remark)
         try encoderContainer.encode(createTime, forKey: .createTime)
         try encoderContainer.encode(createUser, forKey: .createUser)
         try encoderContainer.encode(updateTime, forKey: .updateTime)
         try encoderContainer.encode(updateUser, forKey: .updateUser)
         try encoderContainer.encode(yn, forKey: .yn)
    }
}
///  returnBillResult
public class ReturnBillResult:NSObject,Codable{
    /// ID
    var id:Double?
    /// 返还单号
    var retrunBillId:String?
    /// 服务商ID
    var distributorId:String?
    /// 服务商名称
    var distributorName:String?
    /// 渠道商类型
    var distributorType:Int?
    /// month
    var month:String?
    /// 生成时间
    var generateTime:String?
    /// 开始时间
    var billBegin:String?
    /// 结束时间
    var billEnd:String?
    /// 周期类型
    var circleType:Int?
    /// 返还类型
    var returnType:Int?
    /// 返还类型名称
    var returnTypeName:String?
    /// 返还金额
    var returnMount:Double?
    /// 次数
    var redoQty:Int?
    /// 状态
    var status:Int?
    /// 状态名称
    var statusName:String?
    /// 驳回原因
    var reason:String?
    /// 部门ID
    var deptId:Int?
    /// 部门名称
    var deptName:String?
    /// 创建时间
    var createTime:String?
    /// 创建人
    var createUser:String?
    /// 修改时间
    var updateTime:String?
    /// 修改人
    var updateUser:String?
    /// 是否删除0未删除,1已删除
    var yn:Int?
    /// 返还单明细
    var returnBillDetailList:[ReturnBillDetailResult?]?
    /// 返还单状态
    var returnBillStatusList:[ReturnBillStatusResult?]?



    public override init(){
            super.init()
    }

    enum ReturnBillResultCodingKeys: String, CodingKey {
        case id
        case retrunBillId
        case distributorId
        case distributorName
        case distributorType
        case month
        case generateTime
        case billBegin
        case billEnd
        case circleType
        case returnType
        case returnTypeName
        case returnMount
        case redoQty
        case status
        case statusName
        case reason
        case deptId
        case deptName
        case createTime
        case createUser
        case updateTime
        case updateUser
        case yn
        case returnBillDetailList
        case returnBillStatusList
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: ReturnBillResultCodingKeys.self)
        if decoderContainer.contains(.id)
        {
            self.id = try decoderContainer.decode(Double?.self, forKey: .id)
        }
        if decoderContainer.contains(.retrunBillId)
        {
            self.retrunBillId = try decoderContainer.decode(String?.self, forKey: .retrunBillId)
        }
        if decoderContainer.contains(.distributorId)
        {
            self.distributorId = try decoderContainer.decode(String?.self, forKey: .distributorId)
        }
        if decoderContainer.contains(.distributorName)
        {
            self.distributorName = try decoderContainer.decode(String?.self, forKey: .distributorName)
        }
        if decoderContainer.contains(.distributorType)
        {
            self.distributorType = try decoderContainer.decode(Int?.self, forKey: .distributorType)
        }
        if decoderContainer.contains(.month)
        {
            self.month = try decoderContainer.decode(String?.self, forKey: .month)
        }
        if decoderContainer.contains(.generateTime)
        {
            self.generateTime = try decoderContainer.decode(String?.self, forKey: .generateTime)
        }
        if decoderContainer.contains(.billBegin)
        {
            self.billBegin = try decoderContainer.decode(String?.self, forKey: .billBegin)
        }
        if decoderContainer.contains(.billEnd)
        {
            self.billEnd = try decoderContainer.decode(String?.self, forKey: .billEnd)
        }
        if decoderContainer.contains(.circleType)
        {
            self.circleType = try decoderContainer.decode(Int?.self, forKey: .circleType)
        }
        if decoderContainer.contains(.returnType)
        {
            self.returnType = try decoderContainer.decode(Int?.self, forKey: .returnType)
        }
        if decoderContainer.contains(.returnTypeName)
        {
            self.returnTypeName = try decoderContainer.decode(String?.self, forKey: .returnTypeName)
        }
        if decoderContainer.contains(.returnMount)
        {
            self.returnMount = try decoderContainer.decode(Double?.self, forKey: .returnMount)
        }
        if decoderContainer.contains(.redoQty)
        {
            self.redoQty = try decoderContainer.decode(Int?.self, forKey: .redoQty)
        }
        if decoderContainer.contains(.status)
        {
            self.status = try decoderContainer.decode(Int?.self, forKey: .status)
        }
        if decoderContainer.contains(.statusName)
        {
            self.statusName = try decoderContainer.decode(String?.self, forKey: .statusName)
        }
        if decoderContainer.contains(.reason)
        {
            self.reason = try decoderContainer.decode(String?.self, forKey: .reason)
        }
        if decoderContainer.contains(.deptId)
        {
            self.deptId = try decoderContainer.decode(Int?.self, forKey: .deptId)
        }
        if decoderContainer.contains(.deptName)
        {
            self.deptName = try decoderContainer.decode(String?.self, forKey: .deptName)
        }
        if decoderContainer.contains(.createTime)
        {
            self.createTime = try decoderContainer.decode(String?.self, forKey: .createTime)
        }
        if decoderContainer.contains(.createUser)
        {
            self.createUser = try decoderContainer.decode(String?.self, forKey: .createUser)
        }
        if decoderContainer.contains(.updateTime)
        {
            self.updateTime = try decoderContainer.decode(String?.self, forKey: .updateTime)
        }
        if decoderContainer.contains(.updateUser)
        {
            self.updateUser = try decoderContainer.decode(String?.self, forKey: .updateUser)
        }
        if decoderContainer.contains(.yn)
        {
            self.yn = try decoderContainer.decode(Int?.self, forKey: .yn)
        }
        if decoderContainer.contains(.returnBillDetailList)
        {
            self.returnBillDetailList = try decoderContainer.decode([ReturnBillDetailResult?]?.self, forKey: .returnBillDetailList)
        }
        if decoderContainer.contains(.returnBillStatusList)
        {
            self.returnBillStatusList = try decoderContainer.decode([ReturnBillStatusResult?]?.self, forKey: .returnBillStatusList)
        }
    }
}
public extension ReturnBillResult{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: ReturnBillResultCodingKeys.self)
         try encoderContainer.encode(id, forKey: .id)
         try encoderContainer.encode(retrunBillId, forKey: .retrunBillId)
         try encoderContainer.encode(distributorId, forKey: .distributorId)
         try encoderContainer.encode(distributorName, forKey: .distributorName)
         try encoderContainer.encode(distributorType, forKey: .distributorType)
         try encoderContainer.encode(month, forKey: .month)
         try encoderContainer.encode(generateTime, forKey: .generateTime)
         try encoderContainer.encode(billBegin, forKey: .billBegin)
         try encoderContainer.encode(billEnd, forKey: .billEnd)
         try encoderContainer.encode(circleType, forKey: .circleType)
         try encoderContainer.encode(returnType, forKey: .returnType)
         try encoderContainer.encode(returnTypeName, forKey: .returnTypeName)
         try encoderContainer.encode(returnMount, forKey: .returnMount)
         try encoderContainer.encode(redoQty, forKey: .redoQty)
         try encoderContainer.encode(status, forKey: .status)
         try encoderContainer.encode(statusName, forKey: .statusName)
         try encoderContainer.encode(reason, forKey: .reason)
         try encoderContainer.encode(deptId, forKey: .deptId)
         try encoderContainer.encode(deptName, forKey: .deptName)
         try encoderContainer.encode(createTime, forKey: .createTime)
         try encoderContainer.encode(createUser, forKey: .createUser)
         try encoderContainer.encode(updateTime, forKey: .updateTime)
         try encoderContainer.encode(updateUser, forKey: .updateUser)
         try encoderContainer.encode(yn, forKey: .yn)
         try encoderContainer.encode(returnBillDetailList, forKey: .returnBillDetailList)
         try encoderContainer.encode(returnBillStatusList, forKey: .returnBillStatusList)
    }
}
///  pagination
public class Pagination:NSObject,Codable{
    /// 当前页
    var currPageNo:Int?
    /// 页数
    var numberPages:Int?
    /// 每页记录数
    var numberRecords:Int?
    /// 页面大小
    var pageSize:Int?
    /// 起始页
    var startIndex:Int?



    public override init(){
            super.init()
    }

    enum PaginationCodingKeys: String, CodingKey {
        case currPageNo
        case numberPages
        case numberRecords
        case pageSize
        case startIndex
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: PaginationCodingKeys.self)
        if decoderContainer.contains(.currPageNo)
        {
            self.currPageNo = try decoderContainer.decode(Int?.self, forKey: .currPageNo)
        }
        if decoderContainer.contains(.numberPages)
        {
            self.numberPages = try decoderContainer.decode(Int?.self, forKey: .numberPages)
        }
        if decoderContainer.contains(.numberRecords)
        {
            self.numberRecords = try decoderContainer.decode(Int?.self, forKey: .numberRecords)
        }
        if decoderContainer.contains(.pageSize)
        {
            self.pageSize = try decoderContainer.decode(Int?.self, forKey: .pageSize)
        }
        if decoderContainer.contains(.startIndex)
        {
            self.startIndex = try decoderContainer.decode(Int?.self, forKey: .startIndex)
        }
    }
}
public extension Pagination{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: PaginationCodingKeys.self)
         try encoderContainer.encode(currPageNo, forKey: .currPageNo)
         try encoderContainer.encode(numberPages, forKey: .numberPages)
         try encoderContainer.encode(numberRecords, forKey: .numberRecords)
         try encoderContainer.encode(pageSize, forKey: .pageSize)
         try encoderContainer.encode(startIndex, forKey: .startIndex)
    }
}
///  returnBillQuery
public class ReturnBillQuery:NSObject,Codable{
    /// ID
    var id:Double?
    /// 返还单号
    var retrunBillId:String?
    /// 服务商ID
    var distributorId:String?
    /// pin
    var pin:String?
    /// 部门ID
    var deptId:Int?
    /// 渠道商类型
    var distributorType:Int?
    /// 服务商名称
    var distributorName:String?
    /// month
    var month:String?
    /// 生成时间
    var generateTime:String?
    /// 开始时间
    var billBegin:String?
    /// 结束时间
    var billEnd:String?
    /// 周期类型
    var circleType:Int?
    /// 返还类型
    var returnType:Int?
    /// 返还金额
    var returnMount:Double?
    /// 状态
    var status:Int?
    /// 创建时间
    var createTime:String?
    /// 创建人
    var createUser:String?
    /// 修改时间
    var updateTime:String?
    /// 修改人
    var updateUser:String?
    /// 是否删除0未删除,1已删除
    var yn:Int?
    /// 驳回原因
    var reason:String?
    /// 开始时间
    var beginTime:String?
    /// 结束时间
    var endTime:String?
    /// 当前页序号
    var pageIndex:Int?
    /// 每页结果数量
    var pageSize:Int?
    /// Offset
    var offset:Int?



    public override init(){
            super.init()
    }

    enum ReturnBillQueryCodingKeys: String, CodingKey {
        case id
        case retrunBillId
        case distributorId
        case pin
        case deptId
        case distributorType
        case distributorName
        case month
        case generateTime
        case billBegin
        case billEnd
        case circleType
        case returnType
        case returnMount
        case status
        case createTime
        case createUser
        case updateTime
        case updateUser
        case yn
        case reason
        case beginTime
        case endTime
        case pageIndex
        case pageSize
        case offset
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: ReturnBillQueryCodingKeys.self)
        if decoderContainer.contains(.id)
        {
            self.id = try decoderContainer.decode(Double?.self, forKey: .id)
        }
        if decoderContainer.contains(.retrunBillId)
        {
            self.retrunBillId = try decoderContainer.decode(String?.self, forKey: .retrunBillId)
        }
        if decoderContainer.contains(.distributorId)
        {
            self.distributorId = try decoderContainer.decode(String?.self, forKey: .distributorId)
        }
        if decoderContainer.contains(.pin)
        {
            self.pin = try decoderContainer.decode(String?.self, forKey: .pin)
        }
        if decoderContainer.contains(.deptId)
        {
            self.deptId = try decoderContainer.decode(Int?.self, forKey: .deptId)
        }
        if decoderContainer.contains(.distributorType)
        {
            self.distributorType = try decoderContainer.decode(Int?.self, forKey: .distributorType)
        }
        if decoderContainer.contains(.distributorName)
        {
            self.distributorName = try decoderContainer.decode(String?.self, forKey: .distributorName)
        }
        if decoderContainer.contains(.month)
        {
            self.month = try decoderContainer.decode(String?.self, forKey: .month)
        }
        if decoderContainer.contains(.generateTime)
        {
            self.generateTime = try decoderContainer.decode(String?.self, forKey: .generateTime)
        }
        if decoderContainer.contains(.billBegin)
        {
            self.billBegin = try decoderContainer.decode(String?.self, forKey: .billBegin)
        }
        if decoderContainer.contains(.billEnd)
        {
            self.billEnd = try decoderContainer.decode(String?.self, forKey: .billEnd)
        }
        if decoderContainer.contains(.circleType)
        {
            self.circleType = try decoderContainer.decode(Int?.self, forKey: .circleType)
        }
        if decoderContainer.contains(.returnType)
        {
            self.returnType = try decoderContainer.decode(Int?.self, forKey: .returnType)
        }
        if decoderContainer.contains(.returnMount)
        {
            self.returnMount = try decoderContainer.decode(Double?.self, forKey: .returnMount)
        }
        if decoderContainer.contains(.status)
        {
            self.status = try decoderContainer.decode(Int?.self, forKey: .status)
        }
        if decoderContainer.contains(.createTime)
        {
            self.createTime = try decoderContainer.decode(String?.self, forKey: .createTime)
        }
        if decoderContainer.contains(.createUser)
        {
            self.createUser = try decoderContainer.decode(String?.self, forKey: .createUser)
        }
        if decoderContainer.contains(.updateTime)
        {
            self.updateTime = try decoderContainer.decode(String?.self, forKey: .updateTime)
        }
        if decoderContainer.contains(.updateUser)
        {
            self.updateUser = try decoderContainer.decode(String?.self, forKey: .updateUser)
        }
        if decoderContainer.contains(.yn)
        {
            self.yn = try decoderContainer.decode(Int?.self, forKey: .yn)
        }
        if decoderContainer.contains(.reason)
        {
            self.reason = try decoderContainer.decode(String?.self, forKey: .reason)
        }
        if decoderContainer.contains(.beginTime)
        {
            self.beginTime = try decoderContainer.decode(String?.self, forKey: .beginTime)
        }
        if decoderContainer.contains(.endTime)
        {
            self.endTime = try decoderContainer.decode(String?.self, forKey: .endTime)
        }
        if decoderContainer.contains(.pageIndex)
        {
            self.pageIndex = try decoderContainer.decode(Int?.self, forKey: .pageIndex)
        }
        if decoderContainer.contains(.pageSize)
        {
            self.pageSize = try decoderContainer.decode(Int?.self, forKey: .pageSize)
        }
        if decoderContainer.contains(.offset)
        {
            self.offset = try decoderContainer.decode(Int?.self, forKey: .offset)
        }
    }
}
public extension ReturnBillQuery{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: ReturnBillQueryCodingKeys.self)
         try encoderContainer.encode(id, forKey: .id)
         try encoderContainer.encode(retrunBillId, forKey: .retrunBillId)
         try encoderContainer.encode(distributorId, forKey: .distributorId)
         try encoderContainer.encode(pin, forKey: .pin)
         try encoderContainer.encode(deptId, forKey: .deptId)
         try encoderContainer.encode(distributorType, forKey: .distributorType)
         try encoderContainer.encode(distributorName, forKey: .distributorName)
         try encoderContainer.encode(month, forKey: .month)
         try encoderContainer.encode(generateTime, forKey: .generateTime)
         try encoderContainer.encode(billBegin, forKey: .billBegin)
         try encoderContainer.encode(billEnd, forKey: .billEnd)
         try encoderContainer.encode(circleType, forKey: .circleType)
         try encoderContainer.encode(returnType, forKey: .returnType)
         try encoderContainer.encode(returnMount, forKey: .returnMount)
         try encoderContainer.encode(status, forKey: .status)
         try encoderContainer.encode(createTime, forKey: .createTime)
         try encoderContainer.encode(createUser, forKey: .createUser)
         try encoderContainer.encode(updateTime, forKey: .updateTime)
         try encoderContainer.encode(updateUser, forKey: .updateUser)
         try encoderContainer.encode(yn, forKey: .yn)
         try encoderContainer.encode(reason, forKey: .reason)
         try encoderContainer.encode(beginTime, forKey: .beginTime)
         try encoderContainer.encode(endTime, forKey: .endTime)
         try encoderContainer.encode(pageIndex, forKey: .pageIndex)
         try encoderContainer.encode(pageSize, forKey: .pageSize)
         try encoderContainer.encode(offset, forKey: .offset)
    }
}
///  returnPolicyQuery
public class ReturnPolicyQuery:NSObject,Codable{
    /// ID
    var id:Double?
    /// 部门ID
    var deptId:Int?
    /// 渠道商类型
    var distributorType:Int?
    /// 返还类型
    var returnType:Int?
    /// 项目编码
    var itemId:Double?
    /// 项目名称
    var itemName:String?
    /// 周期类型
    var circleType:Int?
    /// 周期名称
    var circleName:String?
    /// 指定周期标识
    var circleFlag:Int?
    /// 周期值
    var circleValue:Int?
    /// 条件
    var condition:String?
    /// 说明
    var conditionRemark:String?
    /// 返还比例
    var returnRatio:Double?
    /// 状态
    var status:Int?
    /// 创建时间
    var createTime:String?
    /// 创建人
    var createUser:String?
    /// 修改时间
    var updateTime:String?
    /// 修改人
    var updateUser:String?
    /// 是否删除0未删除,1已删除
    var yn:Int?
    /// 项目名称
    var itemNameLike:String?
    /// 当前页序号
    var pageIndex:Int?
    /// 每页结果数量
    var pageSize:Int?
    /// Offset
    var offset:Int?



    public override init(){
            super.init()
    }

    enum ReturnPolicyQueryCodingKeys: String, CodingKey {
        case id
        case deptId
        case distributorType
        case returnType
        case itemId
        case itemName
        case circleType
        case circleName
        case circleFlag
        case circleValue
        case condition
        case conditionRemark
        case returnRatio
        case status
        case createTime
        case createUser
        case updateTime
        case updateUser
        case yn
        case itemNameLike
        case pageIndex
        case pageSize
        case offset
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: ReturnPolicyQueryCodingKeys.self)
        if decoderContainer.contains(.id)
        {
            self.id = try decoderContainer.decode(Double?.self, forKey: .id)
        }
        if decoderContainer.contains(.deptId)
        {
            self.deptId = try decoderContainer.decode(Int?.self, forKey: .deptId)
        }
        if decoderContainer.contains(.distributorType)
        {
            self.distributorType = try decoderContainer.decode(Int?.self, forKey: .distributorType)
        }
        if decoderContainer.contains(.returnType)
        {
            self.returnType = try decoderContainer.decode(Int?.self, forKey: .returnType)
        }
        if decoderContainer.contains(.itemId)
        {
            self.itemId = try decoderContainer.decode(Double?.self, forKey: .itemId)
        }
        if decoderContainer.contains(.itemName)
        {
            self.itemName = try decoderContainer.decode(String?.self, forKey: .itemName)
        }
        if decoderContainer.contains(.circleType)
        {
            self.circleType = try decoderContainer.decode(Int?.self, forKey: .circleType)
        }
        if decoderContainer.contains(.circleName)
        {
            self.circleName = try decoderContainer.decode(String?.self, forKey: .circleName)
        }
        if decoderContainer.contains(.circleFlag)
        {
            self.circleFlag = try decoderContainer.decode(Int?.self, forKey: .circleFlag)
        }
        if decoderContainer.contains(.circleValue)
        {
            self.circleValue = try decoderContainer.decode(Int?.self, forKey: .circleValue)
        }
        if decoderContainer.contains(.condition)
        {
            self.condition = try decoderContainer.decode(String?.self, forKey: .condition)
        }
        if decoderContainer.contains(.conditionRemark)
        {
            self.conditionRemark = try decoderContainer.decode(String?.self, forKey: .conditionRemark)
        }
        if decoderContainer.contains(.returnRatio)
        {
            self.returnRatio = try decoderContainer.decode(Double?.self, forKey: .returnRatio)
        }
        if decoderContainer.contains(.status)
        {
            self.status = try decoderContainer.decode(Int?.self, forKey: .status)
        }
        if decoderContainer.contains(.createTime)
        {
            self.createTime = try decoderContainer.decode(String?.self, forKey: .createTime)
        }
        if decoderContainer.contains(.createUser)
        {
            self.createUser = try decoderContainer.decode(String?.self, forKey: .createUser)
        }
        if decoderContainer.contains(.updateTime)
        {
            self.updateTime = try decoderContainer.decode(String?.self, forKey: .updateTime)
        }
        if decoderContainer.contains(.updateUser)
        {
            self.updateUser = try decoderContainer.decode(String?.self, forKey: .updateUser)
        }
        if decoderContainer.contains(.yn)
        {
            self.yn = try decoderContainer.decode(Int?.self, forKey: .yn)
        }
        if decoderContainer.contains(.itemNameLike)
        {
            self.itemNameLike = try decoderContainer.decode(String?.self, forKey: .itemNameLike)
        }
        if decoderContainer.contains(.pageIndex)
        {
            self.pageIndex = try decoderContainer.decode(Int?.self, forKey: .pageIndex)
        }
        if decoderContainer.contains(.pageSize)
        {
            self.pageSize = try decoderContainer.decode(Int?.self, forKey: .pageSize)
        }
        if decoderContainer.contains(.offset)
        {
            self.offset = try decoderContainer.decode(Int?.self, forKey: .offset)
        }
    }
}
public extension ReturnPolicyQuery{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: ReturnPolicyQueryCodingKeys.self)
         try encoderContainer.encode(id, forKey: .id)
         try encoderContainer.encode(deptId, forKey: .deptId)
         try encoderContainer.encode(distributorType, forKey: .distributorType)
         try encoderContainer.encode(returnType, forKey: .returnType)
         try encoderContainer.encode(itemId, forKey: .itemId)
         try encoderContainer.encode(itemName, forKey: .itemName)
         try encoderContainer.encode(circleType, forKey: .circleType)
         try encoderContainer.encode(circleName, forKey: .circleName)
         try encoderContainer.encode(circleFlag, forKey: .circleFlag)
         try encoderContainer.encode(circleValue, forKey: .circleValue)
         try encoderContainer.encode(condition, forKey: .condition)
         try encoderContainer.encode(conditionRemark, forKey: .conditionRemark)
         try encoderContainer.encode(returnRatio, forKey: .returnRatio)
         try encoderContainer.encode(status, forKey: .status)
         try encoderContainer.encode(createTime, forKey: .createTime)
         try encoderContainer.encode(createUser, forKey: .createUser)
         try encoderContainer.encode(updateTime, forKey: .updateTime)
         try encoderContainer.encode(updateUser, forKey: .updateUser)
         try encoderContainer.encode(yn, forKey: .yn)
         try encoderContainer.encode(itemNameLike, forKey: .itemNameLike)
         try encoderContainer.encode(pageIndex, forKey: .pageIndex)
         try encoderContainer.encode(pageSize, forKey: .pageSize)
         try encoderContainer.encode(offset, forKey: .offset)
    }
}
///  returnConditionOperatorDTO
public class ReturnConditionOperatorDTO:NSObject,Codable{
    /// 条件编码
    var code:Int?
    /// 操作符
    var operatorValue:String?
    /// 条件值
    var value:Double?



    public override init(){
            super.init()
    }

    enum ReturnConditionOperatorDTOCodingKeys: String, CodingKey {
        case code
        case operatorValue = "operator"
        case value
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: ReturnConditionOperatorDTOCodingKeys.self)
        if decoderContainer.contains(.code)
        {
            self.code = try decoderContainer.decode(Int?.self, forKey: .code)
        }
        if decoderContainer.contains(.operatorValue)
        {
            self.operatorValue = try decoderContainer.decode(String?.self, forKey: .operatorValue)
        }
        if decoderContainer.contains(.value)
        {
            self.value = try decoderContainer.decode(Double?.self, forKey: .value)
        }
    }
}
public extension ReturnConditionOperatorDTO{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: ReturnConditionOperatorDTOCodingKeys.self)
         try encoderContainer.encode(code, forKey: .code)
         try encoderContainer.encode(operatorValue, forKey: .operatorValue)
         try encoderContainer.encode(value, forKey: .value)
    }
}
///  returnPolicyDTO
public class ReturnPolicyDTO:NSObject,Codable{
    /// ID
    var id:Double?
    /// 部门ID
    var deptId:Int?
    /// 部门名称
    var deptName:String?
    /// 渠道商类型
    var distributorType:Int?
    /// 返还类型
    var returnType:Int?
    /// 项目编码
    var itemId:Double?
    /// 项目名称
    var itemName:String?
    /// 周期类型
    var circleType:Int?
    /// 周期名称
    var circleName:String?
    /// 指定周期标识
    var circleFlag:Int?
    /// 周期值
    var circleValue:Int?
    /// Condition
    var condition:[ReturnConditionOperatorDTO?]?
    /// 说明
    var conditionRemark:String?
    /// 返还比例
    var returnRatio:Double?
    /// 状态
    var status:Int?
    /// 创建时间
    var createTime:String?
    /// 创建人
    var createUser:String?
    /// 修改时间
    var updateTime:String?
    /// 修改人
    var updateUser:String?
    /// 是否删除0未删除,1已删除
    var yn:Int?



    public override init(){
            super.init()
    }

    enum ReturnPolicyDTOCodingKeys: String, CodingKey {
        case id
        case deptId
        case deptName
        case distributorType
        case returnType
        case itemId
        case itemName
        case circleType
        case circleName
        case circleFlag
        case circleValue
        case condition
        case conditionRemark
        case returnRatio
        case status
        case createTime
        case createUser
        case updateTime
        case updateUser
        case yn
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: ReturnPolicyDTOCodingKeys.self)
        if decoderContainer.contains(.id)
        {
            self.id = try decoderContainer.decode(Double?.self, forKey: .id)
        }
        if decoderContainer.contains(.deptId)
        {
            self.deptId = try decoderContainer.decode(Int?.self, forKey: .deptId)
        }
        if decoderContainer.contains(.deptName)
        {
            self.deptName = try decoderContainer.decode(String?.self, forKey: .deptName)
        }
        if decoderContainer.contains(.distributorType)
        {
            self.distributorType = try decoderContainer.decode(Int?.self, forKey: .distributorType)
        }
        if decoderContainer.contains(.returnType)
        {
            self.returnType = try decoderContainer.decode(Int?.self, forKey: .returnType)
        }
        if decoderContainer.contains(.itemId)
        {
            self.itemId = try decoderContainer.decode(Double?.self, forKey: .itemId)
        }
        if decoderContainer.contains(.itemName)
        {
            self.itemName = try decoderContainer.decode(String?.self, forKey: .itemName)
        }
        if decoderContainer.contains(.circleType)
        {
            self.circleType = try decoderContainer.decode(Int?.self, forKey: .circleType)
        }
        if decoderContainer.contains(.circleName)
        {
            self.circleName = try decoderContainer.decode(String?.self, forKey: .circleName)
        }
        if decoderContainer.contains(.circleFlag)
        {
            self.circleFlag = try decoderContainer.decode(Int?.self, forKey: .circleFlag)
        }
        if decoderContainer.contains(.circleValue)
        {
            self.circleValue = try decoderContainer.decode(Int?.self, forKey: .circleValue)
        }
        if decoderContainer.contains(.condition)
        {
            self.condition = try decoderContainer.decode([ReturnConditionOperatorDTO?]?.self, forKey: .condition)
        }
        if decoderContainer.contains(.conditionRemark)
        {
            self.conditionRemark = try decoderContainer.decode(String?.self, forKey: .conditionRemark)
        }
        if decoderContainer.contains(.returnRatio)
        {
            self.returnRatio = try decoderContainer.decode(Double?.self, forKey: .returnRatio)
        }
        if decoderContainer.contains(.status)
        {
            self.status = try decoderContainer.decode(Int?.self, forKey: .status)
        }
        if decoderContainer.contains(.createTime)
        {
            self.createTime = try decoderContainer.decode(String?.self, forKey: .createTime)
        }
        if decoderContainer.contains(.createUser)
        {
            self.createUser = try decoderContainer.decode(String?.self, forKey: .createUser)
        }
        if decoderContainer.contains(.updateTime)
        {
            self.updateTime = try decoderContainer.decode(String?.self, forKey: .updateTime)
        }
        if decoderContainer.contains(.updateUser)
        {
            self.updateUser = try decoderContainer.decode(String?.self, forKey: .updateUser)
        }
        if decoderContainer.contains(.yn)
        {
            self.yn = try decoderContainer.decode(Int?.self, forKey: .yn)
        }
    }
}
public extension ReturnPolicyDTO{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: ReturnPolicyDTOCodingKeys.self)
         try encoderContainer.encode(id, forKey: .id)
         try encoderContainer.encode(deptId, forKey: .deptId)
         try encoderContainer.encode(deptName, forKey: .deptName)
         try encoderContainer.encode(distributorType, forKey: .distributorType)
         try encoderContainer.encode(returnType, forKey: .returnType)
         try encoderContainer.encode(itemId, forKey: .itemId)
         try encoderContainer.encode(itemName, forKey: .itemName)
         try encoderContainer.encode(circleType, forKey: .circleType)
         try encoderContainer.encode(circleName, forKey: .circleName)
         try encoderContainer.encode(circleFlag, forKey: .circleFlag)
         try encoderContainer.encode(circleValue, forKey: .circleValue)
         try encoderContainer.encode(condition, forKey: .condition)
         try encoderContainer.encode(conditionRemark, forKey: .conditionRemark)
         try encoderContainer.encode(returnRatio, forKey: .returnRatio)
         try encoderContainer.encode(status, forKey: .status)
         try encoderContainer.encode(createTime, forKey: .createTime)
         try encoderContainer.encode(createUser, forKey: .createUser)
         try encoderContainer.encode(updateTime, forKey: .updateTime)
         try encoderContainer.encode(updateUser, forKey: .updateUser)
         try encoderContainer.encode(yn, forKey: .yn)
    }
}
///  returnPolicyResult
public class ReturnPolicyResult:NSObject,Codable{
    /// ID
    var id:Double?
    /// 部门ID
    var deptId:Int?
    /// 部门名称
    var deptName:String?
    /// 渠道商类型
    var distributorType:Int?
    /// 渠道商类型名称
    var distributorTypeName:String?
    /// 返还类型
    var returnType:Int?
    /// 项目编码
    var itemId:Double?
    /// 项目名称
    var itemName:String?
    /// 周期类型
    var circleType:Int?
    /// 周期名称
    var circleName:String?
    /// 指定周期标识
    var circleFlag:Int?
    /// 周期值
    var circleValue:Int?
    /// 返还项目条件
    var condition:String?
    /// 说明
    var conditionRemark:String?
    /// 返还比例
    var returnRatio:Double?
    /// 状态
    var status:Int?
    /// 创建时间
    var createTime:String?
    /// 创建人
    var createUser:String?
    /// 修改时间
    var updateTime:String?
    /// 修改人
    var updateUser:String?
    /// 是否删除0未删除,1已删除
    var yn:Int?



    public override init(){
            super.init()
    }

    enum ReturnPolicyResultCodingKeys: String, CodingKey {
        case id
        case deptId
        case deptName
        case distributorType
        case distributorTypeName
        case returnType
        case itemId
        case itemName
        case circleType
        case circleName
        case circleFlag
        case circleValue
        case condition
        case conditionRemark
        case returnRatio
        case status
        case createTime
        case createUser
        case updateTime
        case updateUser
        case yn
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: ReturnPolicyResultCodingKeys.self)
        if decoderContainer.contains(.id)
        {
            self.id = try decoderContainer.decode(Double?.self, forKey: .id)
        }
        if decoderContainer.contains(.deptId)
        {
            self.deptId = try decoderContainer.decode(Int?.self, forKey: .deptId)
        }
        if decoderContainer.contains(.deptName)
        {
            self.deptName = try decoderContainer.decode(String?.self, forKey: .deptName)
        }
        if decoderContainer.contains(.distributorType)
        {
            self.distributorType = try decoderContainer.decode(Int?.self, forKey: .distributorType)
        }
        if decoderContainer.contains(.distributorTypeName)
        {
            self.distributorTypeName = try decoderContainer.decode(String?.self, forKey: .distributorTypeName)
        }
        if decoderContainer.contains(.returnType)
        {
            self.returnType = try decoderContainer.decode(Int?.self, forKey: .returnType)
        }
        if decoderContainer.contains(.itemId)
        {
            self.itemId = try decoderContainer.decode(Double?.self, forKey: .itemId)
        }
        if decoderContainer.contains(.itemName)
        {
            self.itemName = try decoderContainer.decode(String?.self, forKey: .itemName)
        }
        if decoderContainer.contains(.circleType)
        {
            self.circleType = try decoderContainer.decode(Int?.self, forKey: .circleType)
        }
        if decoderContainer.contains(.circleName)
        {
            self.circleName = try decoderContainer.decode(String?.self, forKey: .circleName)
        }
        if decoderContainer.contains(.circleFlag)
        {
            self.circleFlag = try decoderContainer.decode(Int?.self, forKey: .circleFlag)
        }
        if decoderContainer.contains(.circleValue)
        {
            self.circleValue = try decoderContainer.decode(Int?.self, forKey: .circleValue)
        }
        if decoderContainer.contains(.condition)
        {
            self.condition = try decoderContainer.decode(String?.self, forKey: .condition)
        }
        if decoderContainer.contains(.conditionRemark)
        {
            self.conditionRemark = try decoderContainer.decode(String?.self, forKey: .conditionRemark)
        }
        if decoderContainer.contains(.returnRatio)
        {
            self.returnRatio = try decoderContainer.decode(Double?.self, forKey: .returnRatio)
        }
        if decoderContainer.contains(.status)
        {
            self.status = try decoderContainer.decode(Int?.self, forKey: .status)
        }
        if decoderContainer.contains(.createTime)
        {
            self.createTime = try decoderContainer.decode(String?.self, forKey: .createTime)
        }
        if decoderContainer.contains(.createUser)
        {
            self.createUser = try decoderContainer.decode(String?.self, forKey: .createUser)
        }
        if decoderContainer.contains(.updateTime)
        {
            self.updateTime = try decoderContainer.decode(String?.self, forKey: .updateTime)
        }
        if decoderContainer.contains(.updateUser)
        {
            self.updateUser = try decoderContainer.decode(String?.self, forKey: .updateUser)
        }
        if decoderContainer.contains(.yn)
        {
            self.yn = try decoderContainer.decode(Int?.self, forKey: .yn)
        }
    }
}
public extension ReturnPolicyResult{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: ReturnPolicyResultCodingKeys.self)
         try encoderContainer.encode(id, forKey: .id)
         try encoderContainer.encode(deptId, forKey: .deptId)
         try encoderContainer.encode(deptName, forKey: .deptName)
         try encoderContainer.encode(distributorType, forKey: .distributorType)
         try encoderContainer.encode(distributorTypeName, forKey: .distributorTypeName)
         try encoderContainer.encode(returnType, forKey: .returnType)
         try encoderContainer.encode(itemId, forKey: .itemId)
         try encoderContainer.encode(itemName, forKey: .itemName)
         try encoderContainer.encode(circleType, forKey: .circleType)
         try encoderContainer.encode(circleName, forKey: .circleName)
         try encoderContainer.encode(circleFlag, forKey: .circleFlag)
         try encoderContainer.encode(circleValue, forKey: .circleValue)
         try encoderContainer.encode(condition, forKey: .condition)
         try encoderContainer.encode(conditionRemark, forKey: .conditionRemark)
         try encoderContainer.encode(returnRatio, forKey: .returnRatio)
         try encoderContainer.encode(status, forKey: .status)
         try encoderContainer.encode(createTime, forKey: .createTime)
         try encoderContainer.encode(createUser, forKey: .createUser)
         try encoderContainer.encode(updateTime, forKey: .updateTime)
         try encoderContainer.encode(updateUser, forKey: .updateUser)
         try encoderContainer.encode(yn, forKey: .yn)
    }
}
///  customerVo
public class CustomerVo:NSObject,Codable{
    /// 客户pin
    var pin:String?
    /// 一级渠道商名称
    var distributorLevel1Name:String?
    /// 二级渠道商名称
    var distributorLevel2Name:String?
    /// 关联时间
    var relTime:String?
    /// 来源(0渠道商自身,1京东云客户)
    var source:Int?
    /// 客户昵称
    var aliasName:String?
    /// 客户联系人
    var contracter:String?
    /// 客户电话
    var tel:String?
    /// 客户邮箱
    var email:String?
    /// 客户备注
    var remark:String?
    /// 所属部门(0企业线、1政府线)
    var dept:Int?
    /// 部门名称
    var deptName:String?
    /// 创建时间
    var createTime:String?
    /// 创建人
    var createUser:String?
    /// 修改时间
    var updateTime:String?
    /// 账户类型
    var accountTypeName:String?
    /// 实名标识名称
    var realName:String?
    /// 名称
    var name:String?
    /// 修改人
    var updateUser:String?



    public override init(){
            super.init()
    }

    enum CustomerVoCodingKeys: String, CodingKey {
        case pin
        case distributorLevel1Name
        case distributorLevel2Name
        case relTime
        case source
        case aliasName
        case contracter
        case tel
        case email
        case remark
        case dept
        case deptName
        case createTime
        case createUser
        case updateTime
        case accountTypeName
        case realName
        case name
        case updateUser
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: CustomerVoCodingKeys.self)
        if decoderContainer.contains(.pin)
        {
            self.pin = try decoderContainer.decode(String?.self, forKey: .pin)
        }
        if decoderContainer.contains(.distributorLevel1Name)
        {
            self.distributorLevel1Name = try decoderContainer.decode(String?.self, forKey: .distributorLevel1Name)
        }
        if decoderContainer.contains(.distributorLevel2Name)
        {
            self.distributorLevel2Name = try decoderContainer.decode(String?.self, forKey: .distributorLevel2Name)
        }
        if decoderContainer.contains(.relTime)
        {
            self.relTime = try decoderContainer.decode(String?.self, forKey: .relTime)
        }
        if decoderContainer.contains(.source)
        {
            self.source = try decoderContainer.decode(Int?.self, forKey: .source)
        }
        if decoderContainer.contains(.aliasName)
        {
            self.aliasName = try decoderContainer.decode(String?.self, forKey: .aliasName)
        }
        if decoderContainer.contains(.contracter)
        {
            self.contracter = try decoderContainer.decode(String?.self, forKey: .contracter)
        }
        if decoderContainer.contains(.tel)
        {
            self.tel = try decoderContainer.decode(String?.self, forKey: .tel)
        }
        if decoderContainer.contains(.email)
        {
            self.email = try decoderContainer.decode(String?.self, forKey: .email)
        }
        if decoderContainer.contains(.remark)
        {
            self.remark = try decoderContainer.decode(String?.self, forKey: .remark)
        }
        if decoderContainer.contains(.dept)
        {
            self.dept = try decoderContainer.decode(Int?.self, forKey: .dept)
        }
        if decoderContainer.contains(.deptName)
        {
            self.deptName = try decoderContainer.decode(String?.self, forKey: .deptName)
        }
        if decoderContainer.contains(.createTime)
        {
            self.createTime = try decoderContainer.decode(String?.self, forKey: .createTime)
        }
        if decoderContainer.contains(.createUser)
        {
            self.createUser = try decoderContainer.decode(String?.self, forKey: .createUser)
        }
        if decoderContainer.contains(.updateTime)
        {
            self.updateTime = try decoderContainer.decode(String?.self, forKey: .updateTime)
        }
        if decoderContainer.contains(.accountTypeName)
        {
            self.accountTypeName = try decoderContainer.decode(String?.self, forKey: .accountTypeName)
        }
        if decoderContainer.contains(.realName)
        {
            self.realName = try decoderContainer.decode(String?.self, forKey: .realName)
        }
        if decoderContainer.contains(.name)
        {
            self.name = try decoderContainer.decode(String?.self, forKey: .name)
        }
        if decoderContainer.contains(.updateUser)
        {
            self.updateUser = try decoderContainer.decode(String?.self, forKey: .updateUser)
        }
    }
}
public extension CustomerVo{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: CustomerVoCodingKeys.self)
         try encoderContainer.encode(pin, forKey: .pin)
         try encoderContainer.encode(distributorLevel1Name, forKey: .distributorLevel1Name)
         try encoderContainer.encode(distributorLevel2Name, forKey: .distributorLevel2Name)
         try encoderContainer.encode(relTime, forKey: .relTime)
         try encoderContainer.encode(source, forKey: .source)
         try encoderContainer.encode(aliasName, forKey: .aliasName)
         try encoderContainer.encode(contracter, forKey: .contracter)
         try encoderContainer.encode(tel, forKey: .tel)
         try encoderContainer.encode(email, forKey: .email)
         try encoderContainer.encode(remark, forKey: .remark)
         try encoderContainer.encode(dept, forKey: .dept)
         try encoderContainer.encode(deptName, forKey: .deptName)
         try encoderContainer.encode(createTime, forKey: .createTime)
         try encoderContainer.encode(createUser, forKey: .createUser)
         try encoderContainer.encode(updateTime, forKey: .updateTime)
         try encoderContainer.encode(accountTypeName, forKey: .accountTypeName)
         try encoderContainer.encode(realName, forKey: .realName)
         try encoderContainer.encode(name, forKey: .name)
         try encoderContainer.encode(updateUser, forKey: .updateUser)
    }
}
///  customer
public class Customer:NSObject,Codable{
    /// ID
    var id:Int?
    /// 客户pin
    var pin:String?
    /// 渠道商ID
    var distributorId:String?
    /// 渠道商PIN
    var distributorPin:String?
    /// 渠道商名称
    var distributorName:String?
    /// 渠道商级次
    var distributorLevel:String?
    /// 关联时间
    var relTime:String?
    /// 来源(0渠道商自身,1京东云客户)
    var source:Int?
    /// 客户昵称
    var aliasName:String?
    /// 客户联系人
    var contracter:String?
    /// 客户电话
    var tel:String?
    /// 客户邮箱
    var email:String?
    /// 客户备注
    var remark:String?
    /// 创建时间
    var createTime:String?
    /// 创建人
    var createUser:String?
    /// 修改时间
    var updateTime:String?
    /// 修改人
    var updateUser:String?
    /// 账户类型
    var accountTypeName:String?
    /// 实名标识名称
    var realName:String?
    /// 名称
    var name:String?
    /// 是否删除0未删除,1已删除
    var yn:Int?



    public override init(){
            super.init()
    }

    enum CustomerCodingKeys: String, CodingKey {
        case id
        case pin
        case distributorId
        case distributorPin
        case distributorName
        case distributorLevel
        case relTime
        case source
        case aliasName
        case contracter
        case tel
        case email
        case remark
        case createTime
        case createUser
        case updateTime
        case updateUser
        case accountTypeName
        case realName
        case name
        case yn
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: CustomerCodingKeys.self)
        if decoderContainer.contains(.id)
        {
            self.id = try decoderContainer.decode(Int?.self, forKey: .id)
        }
        if decoderContainer.contains(.pin)
        {
            self.pin = try decoderContainer.decode(String?.self, forKey: .pin)
        }
        if decoderContainer.contains(.distributorId)
        {
            self.distributorId = try decoderContainer.decode(String?.self, forKey: .distributorId)
        }
        if decoderContainer.contains(.distributorPin)
        {
            self.distributorPin = try decoderContainer.decode(String?.self, forKey: .distributorPin)
        }
        if decoderContainer.contains(.distributorName)
        {
            self.distributorName = try decoderContainer.decode(String?.self, forKey: .distributorName)
        }
        if decoderContainer.contains(.distributorLevel)
        {
            self.distributorLevel = try decoderContainer.decode(String?.self, forKey: .distributorLevel)
        }
        if decoderContainer.contains(.relTime)
        {
            self.relTime = try decoderContainer.decode(String?.self, forKey: .relTime)
        }
        if decoderContainer.contains(.source)
        {
            self.source = try decoderContainer.decode(Int?.self, forKey: .source)
        }
        if decoderContainer.contains(.aliasName)
        {
            self.aliasName = try decoderContainer.decode(String?.self, forKey: .aliasName)
        }
        if decoderContainer.contains(.contracter)
        {
            self.contracter = try decoderContainer.decode(String?.self, forKey: .contracter)
        }
        if decoderContainer.contains(.tel)
        {
            self.tel = try decoderContainer.decode(String?.self, forKey: .tel)
        }
        if decoderContainer.contains(.email)
        {
            self.email = try decoderContainer.decode(String?.self, forKey: .email)
        }
        if decoderContainer.contains(.remark)
        {
            self.remark = try decoderContainer.decode(String?.self, forKey: .remark)
        }
        if decoderContainer.contains(.createTime)
        {
            self.createTime = try decoderContainer.decode(String?.self, forKey: .createTime)
        }
        if decoderContainer.contains(.createUser)
        {
            self.createUser = try decoderContainer.decode(String?.self, forKey: .createUser)
        }
        if decoderContainer.contains(.updateTime)
        {
            self.updateTime = try decoderContainer.decode(String?.self, forKey: .updateTime)
        }
        if decoderContainer.contains(.updateUser)
        {
            self.updateUser = try decoderContainer.decode(String?.self, forKey: .updateUser)
        }
        if decoderContainer.contains(.accountTypeName)
        {
            self.accountTypeName = try decoderContainer.decode(String?.self, forKey: .accountTypeName)
        }
        if decoderContainer.contains(.realName)
        {
            self.realName = try decoderContainer.decode(String?.self, forKey: .realName)
        }
        if decoderContainer.contains(.name)
        {
            self.name = try decoderContainer.decode(String?.self, forKey: .name)
        }
        if decoderContainer.contains(.yn)
        {
            self.yn = try decoderContainer.decode(Int?.self, forKey: .yn)
        }
    }
}
public extension Customer{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: CustomerCodingKeys.self)
         try encoderContainer.encode(id, forKey: .id)
         try encoderContainer.encode(pin, forKey: .pin)
         try encoderContainer.encode(distributorId, forKey: .distributorId)
         try encoderContainer.encode(distributorPin, forKey: .distributorPin)
         try encoderContainer.encode(distributorName, forKey: .distributorName)
         try encoderContainer.encode(distributorLevel, forKey: .distributorLevel)
         try encoderContainer.encode(relTime, forKey: .relTime)
         try encoderContainer.encode(source, forKey: .source)
         try encoderContainer.encode(aliasName, forKey: .aliasName)
         try encoderContainer.encode(contracter, forKey: .contracter)
         try encoderContainer.encode(tel, forKey: .tel)
         try encoderContainer.encode(email, forKey: .email)
         try encoderContainer.encode(remark, forKey: .remark)
         try encoderContainer.encode(createTime, forKey: .createTime)
         try encoderContainer.encode(createUser, forKey: .createUser)
         try encoderContainer.encode(updateTime, forKey: .updateTime)
         try encoderContainer.encode(updateUser, forKey: .updateUser)
         try encoderContainer.encode(accountTypeName, forKey: .accountTypeName)
         try encoderContainer.encode(realName, forKey: .realName)
         try encoderContainer.encode(name, forKey: .name)
         try encoderContainer.encode(yn, forKey: .yn)
    }
}
///  extraInfo
public class ExtraInfo:NSObject,Codable{
    /// 名称
    var name:String?
    /// 值
    var value:String?



    public override init(){
            super.init()
    }

    enum ExtraInfoCodingKeys: String, CodingKey {
        case name
        case value
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: ExtraInfoCodingKeys.self)
        if decoderContainer.contains(.name)
        {
            self.name = try decoderContainer.decode(String?.self, forKey: .name)
        }
        if decoderContainer.contains(.value)
        {
            self.value = try decoderContainer.decode(String?.self, forKey: .value)
        }
    }
}
public extension ExtraInfo{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: ExtraInfoCodingKeys.self)
         try encoderContainer.encode(name, forKey: .name)
         try encoderContainer.encode(value, forKey: .value)
    }
}
///  prePaymentAchievement
public class PrePaymentAchievement:NSObject,Codable{
    /// pin
    var pin:String?
    /// 名称
    var name:String?
    /// 真实名称
    var realName:String?
    /// serviceCode
    var serviceCode:String?
    /// serviceCodeName
    var serviceCodeName:String?
    /// 时间
    var consumeDate:String?
    /// 优惠前金额
    var consumeCount:Double?
    /// 现金支付
    var cashPayFeeCount:Double?
    /// 业绩金额
    var achievmentCount:Double?
    /// 付费代金卷金额
    var payCouponFeeCount:Double?
    /// 免费代金卷金额
    var freeCouponFeeCount:Double?
    /// 订单编号
    var orderId:Double?
    /// 类型
    var opType:Int?
    /// 类型名称
    var opTypeName:String?
    /// 创建时间
    var billTime:String?



    public override init(){
            super.init()
    }

    enum PrePaymentAchievementCodingKeys: String, CodingKey {
        case pin
        case name
        case realName
        case serviceCode
        case serviceCodeName
        case consumeDate
        case consumeCount
        case cashPayFeeCount
        case achievmentCount
        case payCouponFeeCount
        case freeCouponFeeCount
        case orderId
        case opType
        case opTypeName
        case billTime
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: PrePaymentAchievementCodingKeys.self)
        if decoderContainer.contains(.pin)
        {
            self.pin = try decoderContainer.decode(String?.self, forKey: .pin)
        }
        if decoderContainer.contains(.name)
        {
            self.name = try decoderContainer.decode(String?.self, forKey: .name)
        }
        if decoderContainer.contains(.realName)
        {
            self.realName = try decoderContainer.decode(String?.self, forKey: .realName)
        }
        if decoderContainer.contains(.serviceCode)
        {
            self.serviceCode = try decoderContainer.decode(String?.self, forKey: .serviceCode)
        }
        if decoderContainer.contains(.serviceCodeName)
        {
            self.serviceCodeName = try decoderContainer.decode(String?.self, forKey: .serviceCodeName)
        }
        if decoderContainer.contains(.consumeDate)
        {
            self.consumeDate = try decoderContainer.decode(String?.self, forKey: .consumeDate)
        }
        if decoderContainer.contains(.consumeCount)
        {
            self.consumeCount = try decoderContainer.decode(Double?.self, forKey: .consumeCount)
        }
        if decoderContainer.contains(.cashPayFeeCount)
        {
            self.cashPayFeeCount = try decoderContainer.decode(Double?.self, forKey: .cashPayFeeCount)
        }
        if decoderContainer.contains(.achievmentCount)
        {
            self.achievmentCount = try decoderContainer.decode(Double?.self, forKey: .achievmentCount)
        }
        if decoderContainer.contains(.payCouponFeeCount)
        {
            self.payCouponFeeCount = try decoderContainer.decode(Double?.self, forKey: .payCouponFeeCount)
        }
        if decoderContainer.contains(.freeCouponFeeCount)
        {
            self.freeCouponFeeCount = try decoderContainer.decode(Double?.self, forKey: .freeCouponFeeCount)
        }
        if decoderContainer.contains(.orderId)
        {
            self.orderId = try decoderContainer.decode(Double?.self, forKey: .orderId)
        }
        if decoderContainer.contains(.opType)
        {
            self.opType = try decoderContainer.decode(Int?.self, forKey: .opType)
        }
        if decoderContainer.contains(.opTypeName)
        {
            self.opTypeName = try decoderContainer.decode(String?.self, forKey: .opTypeName)
        }
        if decoderContainer.contains(.billTime)
        {
            self.billTime = try decoderContainer.decode(String?.self, forKey: .billTime)
        }
    }
}
public extension PrePaymentAchievement{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: PrePaymentAchievementCodingKeys.self)
         try encoderContainer.encode(pin, forKey: .pin)
         try encoderContainer.encode(name, forKey: .name)
         try encoderContainer.encode(realName, forKey: .realName)
         try encoderContainer.encode(serviceCode, forKey: .serviceCode)
         try encoderContainer.encode(serviceCodeName, forKey: .serviceCodeName)
         try encoderContainer.encode(consumeDate, forKey: .consumeDate)
         try encoderContainer.encode(consumeCount, forKey: .consumeCount)
         try encoderContainer.encode(cashPayFeeCount, forKey: .cashPayFeeCount)
         try encoderContainer.encode(achievmentCount, forKey: .achievmentCount)
         try encoderContainer.encode(payCouponFeeCount, forKey: .payCouponFeeCount)
         try encoderContainer.encode(freeCouponFeeCount, forKey: .freeCouponFeeCount)
         try encoderContainer.encode(orderId, forKey: .orderId)
         try encoderContainer.encode(opType, forKey: .opType)
         try encoderContainer.encode(opTypeName, forKey: .opTypeName)
         try encoderContainer.encode(billTime, forKey: .billTime)
    }
}
///  orderDetail
public class OrderDetail:NSObject,Codable{
    /// 订单详情列表
    var orderItemDetails:[OrderItemDetail?]?
    /// 子订单列表
    var childOrderDetailList:[OrderDetail?]?
    /// 订单编号
    var orderNumber:String?
    /// 订单状态:已支付
    var status:String?
    /// 订单类型
    var orderType:String?
    /// 订单计费类型：按配置、包年包月、按用量
    var chargeMode:String?
    /// 产品线
    var appName:String?
    /// 产品名称(产品类型)
    var serviceName:String?
    /// 付费方式
    var payType:String?
    /// 自营类型：1-自营，2-非自营，3-二者并存
    var selfSupportType:String?
    /// 站点类型 0：主站,1：国际站,2：云市场
    var siteType:String?
    /// 下单时间
    var createTime:String?
    /// 支付时间
    var payTime:String?
    /// 应付价格是否被修改过：0-未修改，1-已修改
    var isActualFeeModified:String?
    /// 订单总额（元）
    var totalFee:Double?
    /// 应付总额（元）
    var actualFee:Double?
    /// 优惠总额（元）
    var discountFee:Double?
    /// 已支付总额（元）
    var paidFee:Double?
    /// 代金券金额（元）
    var favorableFee:Double?
    /// 代金券Json
    var favorableFeeJson:String?
    /// 现金支付
    var moneyPay:Double?
    /// 余额支付
    var balancePay:Double?
    /// 支付确认页地址
    var payUrl:String?
    /// 用户pin
    var pin:String?
    /// 备注
    var remark:String?
    /// 自动取消时间
    var expirationTime:String?
    /// 已退款金额
    var refundFee:Double?
    /// 订单类型：新购、续费、升降配
    var orderTypeInfo:Double?
    /// 订单计费类型：按配置、包年包月、按用量actualFee
    var chargeModeInfo:Double?
    /// 订单状态：未支付、已支付、处理中、已取消
    var statusInfo:Double?
    /// 自营类型：1-自营，2-非自营，3-二者并存
    var selfSupportTypeInfo:Int?
    /// 现金支付方式（企业、个人网银、京东支付、微信、线下汇款）
    var paymentChannel:Int?
    /// 修改时间
    var updatedTime:String?
    /// 支付单号
    var paymentNumber:String?
    /// 付款人
    var payer:String?
    /// 申请人
    var proposer:String?
    /// 应用code
    var appCode:String?



    public override init(){
            super.init()
    }

    enum OrderDetailCodingKeys: String, CodingKey {
        case orderItemDetails
        case childOrderDetailList
        case orderNumber
        case status
        case orderType
        case chargeMode
        case appName
        case serviceName
        case payType
        case selfSupportType
        case siteType
        case createTime
        case payTime
        case isActualFeeModified
        case totalFee
        case actualFee
        case discountFee
        case paidFee
        case favorableFee
        case favorableFeeJson
        case moneyPay
        case balancePay
        case payUrl
        case pin
        case remark
        case expirationTime
        case refundFee
        case orderTypeInfo
        case chargeModeInfo
        case statusInfo
        case selfSupportTypeInfo
        case paymentChannel
        case updatedTime
        case paymentNumber
        case payer
        case proposer
        case appCode
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: OrderDetailCodingKeys.self)
        if decoderContainer.contains(.orderItemDetails)
        {
            self.orderItemDetails = try decoderContainer.decode([OrderItemDetail?]?.self, forKey: .orderItemDetails)
        }
        if decoderContainer.contains(.childOrderDetailList)
        {
            self.childOrderDetailList = try decoderContainer.decode([OrderDetail?]?.self, forKey: .childOrderDetailList)
        }
        if decoderContainer.contains(.orderNumber)
        {
            self.orderNumber = try decoderContainer.decode(String?.self, forKey: .orderNumber)
        }
        if decoderContainer.contains(.status)
        {
            self.status = try decoderContainer.decode(String?.self, forKey: .status)
        }
        if decoderContainer.contains(.orderType)
        {
            self.orderType = try decoderContainer.decode(String?.self, forKey: .orderType)
        }
        if decoderContainer.contains(.chargeMode)
        {
            self.chargeMode = try decoderContainer.decode(String?.self, forKey: .chargeMode)
        }
        if decoderContainer.contains(.appName)
        {
            self.appName = try decoderContainer.decode(String?.self, forKey: .appName)
        }
        if decoderContainer.contains(.serviceName)
        {
            self.serviceName = try decoderContainer.decode(String?.self, forKey: .serviceName)
        }
        if decoderContainer.contains(.payType)
        {
            self.payType = try decoderContainer.decode(String?.self, forKey: .payType)
        }
        if decoderContainer.contains(.selfSupportType)
        {
            self.selfSupportType = try decoderContainer.decode(String?.self, forKey: .selfSupportType)
        }
        if decoderContainer.contains(.siteType)
        {
            self.siteType = try decoderContainer.decode(String?.self, forKey: .siteType)
        }
        if decoderContainer.contains(.createTime)
        {
            self.createTime = try decoderContainer.decode(String?.self, forKey: .createTime)
        }
        if decoderContainer.contains(.payTime)
        {
            self.payTime = try decoderContainer.decode(String?.self, forKey: .payTime)
        }
        if decoderContainer.contains(.isActualFeeModified)
        {
            self.isActualFeeModified = try decoderContainer.decode(String?.self, forKey: .isActualFeeModified)
        }
        if decoderContainer.contains(.totalFee)
        {
            self.totalFee = try decoderContainer.decode(Double?.self, forKey: .totalFee)
        }
        if decoderContainer.contains(.actualFee)
        {
            self.actualFee = try decoderContainer.decode(Double?.self, forKey: .actualFee)
        }
        if decoderContainer.contains(.discountFee)
        {
            self.discountFee = try decoderContainer.decode(Double?.self, forKey: .discountFee)
        }
        if decoderContainer.contains(.paidFee)
        {
            self.paidFee = try decoderContainer.decode(Double?.self, forKey: .paidFee)
        }
        if decoderContainer.contains(.favorableFee)
        {
            self.favorableFee = try decoderContainer.decode(Double?.self, forKey: .favorableFee)
        }
        if decoderContainer.contains(.favorableFeeJson)
        {
            self.favorableFeeJson = try decoderContainer.decode(String?.self, forKey: .favorableFeeJson)
        }
        if decoderContainer.contains(.moneyPay)
        {
            self.moneyPay = try decoderContainer.decode(Double?.self, forKey: .moneyPay)
        }
        if decoderContainer.contains(.balancePay)
        {
            self.balancePay = try decoderContainer.decode(Double?.self, forKey: .balancePay)
        }
        if decoderContainer.contains(.payUrl)
        {
            self.payUrl = try decoderContainer.decode(String?.self, forKey: .payUrl)
        }
        if decoderContainer.contains(.pin)
        {
            self.pin = try decoderContainer.decode(String?.self, forKey: .pin)
        }
        if decoderContainer.contains(.remark)
        {
            self.remark = try decoderContainer.decode(String?.self, forKey: .remark)
        }
        if decoderContainer.contains(.expirationTime)
        {
            self.expirationTime = try decoderContainer.decode(String?.self, forKey: .expirationTime)
        }
        if decoderContainer.contains(.refundFee)
        {
            self.refundFee = try decoderContainer.decode(Double?.self, forKey: .refundFee)
        }
        if decoderContainer.contains(.orderTypeInfo)
        {
            self.orderTypeInfo = try decoderContainer.decode(Double?.self, forKey: .orderTypeInfo)
        }
        if decoderContainer.contains(.chargeModeInfo)
        {
            self.chargeModeInfo = try decoderContainer.decode(Double?.self, forKey: .chargeModeInfo)
        }
        if decoderContainer.contains(.statusInfo)
        {
            self.statusInfo = try decoderContainer.decode(Double?.self, forKey: .statusInfo)
        }
        if decoderContainer.contains(.selfSupportTypeInfo)
        {
            self.selfSupportTypeInfo = try decoderContainer.decode(Int?.self, forKey: .selfSupportTypeInfo)
        }
        if decoderContainer.contains(.paymentChannel)
        {
            self.paymentChannel = try decoderContainer.decode(Int?.self, forKey: .paymentChannel)
        }
        if decoderContainer.contains(.updatedTime)
        {
            self.updatedTime = try decoderContainer.decode(String?.self, forKey: .updatedTime)
        }
        if decoderContainer.contains(.paymentNumber)
        {
            self.paymentNumber = try decoderContainer.decode(String?.self, forKey: .paymentNumber)
        }
        if decoderContainer.contains(.payer)
        {
            self.payer = try decoderContainer.decode(String?.self, forKey: .payer)
        }
        if decoderContainer.contains(.proposer)
        {
            self.proposer = try decoderContainer.decode(String?.self, forKey: .proposer)
        }
        if decoderContainer.contains(.appCode)
        {
            self.appCode = try decoderContainer.decode(String?.self, forKey: .appCode)
        }
    }
}
public extension OrderDetail{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: OrderDetailCodingKeys.self)
         try encoderContainer.encode(orderItemDetails, forKey: .orderItemDetails)
         try encoderContainer.encode(childOrderDetailList, forKey: .childOrderDetailList)
         try encoderContainer.encode(orderNumber, forKey: .orderNumber)
         try encoderContainer.encode(status, forKey: .status)
         try encoderContainer.encode(orderType, forKey: .orderType)
         try encoderContainer.encode(chargeMode, forKey: .chargeMode)
         try encoderContainer.encode(appName, forKey: .appName)
         try encoderContainer.encode(serviceName, forKey: .serviceName)
         try encoderContainer.encode(payType, forKey: .payType)
         try encoderContainer.encode(selfSupportType, forKey: .selfSupportType)
         try encoderContainer.encode(siteType, forKey: .siteType)
         try encoderContainer.encode(createTime, forKey: .createTime)
         try encoderContainer.encode(payTime, forKey: .payTime)
         try encoderContainer.encode(isActualFeeModified, forKey: .isActualFeeModified)
         try encoderContainer.encode(totalFee, forKey: .totalFee)
         try encoderContainer.encode(actualFee, forKey: .actualFee)
         try encoderContainer.encode(discountFee, forKey: .discountFee)
         try encoderContainer.encode(paidFee, forKey: .paidFee)
         try encoderContainer.encode(favorableFee, forKey: .favorableFee)
         try encoderContainer.encode(favorableFeeJson, forKey: .favorableFeeJson)
         try encoderContainer.encode(moneyPay, forKey: .moneyPay)
         try encoderContainer.encode(balancePay, forKey: .balancePay)
         try encoderContainer.encode(payUrl, forKey: .payUrl)
         try encoderContainer.encode(pin, forKey: .pin)
         try encoderContainer.encode(remark, forKey: .remark)
         try encoderContainer.encode(expirationTime, forKey: .expirationTime)
         try encoderContainer.encode(refundFee, forKey: .refundFee)
         try encoderContainer.encode(orderTypeInfo, forKey: .orderTypeInfo)
         try encoderContainer.encode(chargeModeInfo, forKey: .chargeModeInfo)
         try encoderContainer.encode(statusInfo, forKey: .statusInfo)
         try encoderContainer.encode(selfSupportTypeInfo, forKey: .selfSupportTypeInfo)
         try encoderContainer.encode(paymentChannel, forKey: .paymentChannel)
         try encoderContainer.encode(updatedTime, forKey: .updatedTime)
         try encoderContainer.encode(paymentNumber, forKey: .paymentNumber)
         try encoderContainer.encode(payer, forKey: .payer)
         try encoderContainer.encode(proposer, forKey: .proposer)
         try encoderContainer.encode(appCode, forKey: .appCode)
    }
}
///  operatorPrePayAchievement
public class OperatorPrePayAchievement:NSObject,Codable{
    /// pin
    var pin:String?
    /// 名称
    var name:String?
    /// 真实名称
    var realName:String?
    /// 部门
    var dept:Int?
    /// 部门名称
    var deptName:String?
    /// 服务商类型
    var distributorType:String?
    /// 服务商类型名称
    var distributorTypeName:String?
    /// 一级服务商名称
    var oneLevelDistributorName:String?
    /// 二级服务商名称
    var secondLevelDistributorName:String?
    /// 上级服务商名称
    var superDistributorName:String?
    /// 上级服务商pin
    var superDistributorPin:String?
    /// serviceCode
    var serviceCode:String?
    /// serviceCodeName
    var serviceCodeName:String?
    /// opType
    var opType:Int?
    /// opTypeName
    var opTypeName:String?
    /// 开始时间
    var billTime:String?
    /// 完成时间
    var consumeDate:String?
    /// 交易单号
    var transactionNo:String?
    /// 优惠前金额
    var consumeCount:Double?
    /// 现金支付
    var cashPayFeeCount:Double?
    /// 业绩金额
    var achievmentCount:Double?
    /// 付费代金卷金额
    var payCouponFeeCount:Double?
    /// 免费代金卷金额
    var freeCouponFeeCount:Double?



    public override init(){
            super.init()
    }

    enum OperatorPrePayAchievementCodingKeys: String, CodingKey {
        case pin
        case name
        case realName
        case dept
        case deptName
        case distributorType
        case distributorTypeName
        case oneLevelDistributorName
        case secondLevelDistributorName
        case superDistributorName
        case superDistributorPin
        case serviceCode
        case serviceCodeName
        case opType
        case opTypeName
        case billTime
        case consumeDate
        case transactionNo
        case consumeCount
        case cashPayFeeCount
        case achievmentCount
        case payCouponFeeCount
        case freeCouponFeeCount
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: OperatorPrePayAchievementCodingKeys.self)
        if decoderContainer.contains(.pin)
        {
            self.pin = try decoderContainer.decode(String?.self, forKey: .pin)
        }
        if decoderContainer.contains(.name)
        {
            self.name = try decoderContainer.decode(String?.self, forKey: .name)
        }
        if decoderContainer.contains(.realName)
        {
            self.realName = try decoderContainer.decode(String?.self, forKey: .realName)
        }
        if decoderContainer.contains(.dept)
        {
            self.dept = try decoderContainer.decode(Int?.self, forKey: .dept)
        }
        if decoderContainer.contains(.deptName)
        {
            self.deptName = try decoderContainer.decode(String?.self, forKey: .deptName)
        }
        if decoderContainer.contains(.distributorType)
        {
            self.distributorType = try decoderContainer.decode(String?.self, forKey: .distributorType)
        }
        if decoderContainer.contains(.distributorTypeName)
        {
            self.distributorTypeName = try decoderContainer.decode(String?.self, forKey: .distributorTypeName)
        }
        if decoderContainer.contains(.oneLevelDistributorName)
        {
            self.oneLevelDistributorName = try decoderContainer.decode(String?.self, forKey: .oneLevelDistributorName)
        }
        if decoderContainer.contains(.secondLevelDistributorName)
        {
            self.secondLevelDistributorName = try decoderContainer.decode(String?.self, forKey: .secondLevelDistributorName)
        }
        if decoderContainer.contains(.superDistributorName)
        {
            self.superDistributorName = try decoderContainer.decode(String?.self, forKey: .superDistributorName)
        }
        if decoderContainer.contains(.superDistributorPin)
        {
            self.superDistributorPin = try decoderContainer.decode(String?.self, forKey: .superDistributorPin)
        }
        if decoderContainer.contains(.serviceCode)
        {
            self.serviceCode = try decoderContainer.decode(String?.self, forKey: .serviceCode)
        }
        if decoderContainer.contains(.serviceCodeName)
        {
            self.serviceCodeName = try decoderContainer.decode(String?.self, forKey: .serviceCodeName)
        }
        if decoderContainer.contains(.opType)
        {
            self.opType = try decoderContainer.decode(Int?.self, forKey: .opType)
        }
        if decoderContainer.contains(.opTypeName)
        {
            self.opTypeName = try decoderContainer.decode(String?.self, forKey: .opTypeName)
        }
        if decoderContainer.contains(.billTime)
        {
            self.billTime = try decoderContainer.decode(String?.self, forKey: .billTime)
        }
        if decoderContainer.contains(.consumeDate)
        {
            self.consumeDate = try decoderContainer.decode(String?.self, forKey: .consumeDate)
        }
        if decoderContainer.contains(.transactionNo)
        {
            self.transactionNo = try decoderContainer.decode(String?.self, forKey: .transactionNo)
        }
        if decoderContainer.contains(.consumeCount)
        {
            self.consumeCount = try decoderContainer.decode(Double?.self, forKey: .consumeCount)
        }
        if decoderContainer.contains(.cashPayFeeCount)
        {
            self.cashPayFeeCount = try decoderContainer.decode(Double?.self, forKey: .cashPayFeeCount)
        }
        if decoderContainer.contains(.achievmentCount)
        {
            self.achievmentCount = try decoderContainer.decode(Double?.self, forKey: .achievmentCount)
        }
        if decoderContainer.contains(.payCouponFeeCount)
        {
            self.payCouponFeeCount = try decoderContainer.decode(Double?.self, forKey: .payCouponFeeCount)
        }
        if decoderContainer.contains(.freeCouponFeeCount)
        {
            self.freeCouponFeeCount = try decoderContainer.decode(Double?.self, forKey: .freeCouponFeeCount)
        }
    }
}
public extension OperatorPrePayAchievement{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: OperatorPrePayAchievementCodingKeys.self)
         try encoderContainer.encode(pin, forKey: .pin)
         try encoderContainer.encode(name, forKey: .name)
         try encoderContainer.encode(realName, forKey: .realName)
         try encoderContainer.encode(dept, forKey: .dept)
         try encoderContainer.encode(deptName, forKey: .deptName)
         try encoderContainer.encode(distributorType, forKey: .distributorType)
         try encoderContainer.encode(distributorTypeName, forKey: .distributorTypeName)
         try encoderContainer.encode(oneLevelDistributorName, forKey: .oneLevelDistributorName)
         try encoderContainer.encode(secondLevelDistributorName, forKey: .secondLevelDistributorName)
         try encoderContainer.encode(superDistributorName, forKey: .superDistributorName)
         try encoderContainer.encode(superDistributorPin, forKey: .superDistributorPin)
         try encoderContainer.encode(serviceCode, forKey: .serviceCode)
         try encoderContainer.encode(serviceCodeName, forKey: .serviceCodeName)
         try encoderContainer.encode(opType, forKey: .opType)
         try encoderContainer.encode(opTypeName, forKey: .opTypeName)
         try encoderContainer.encode(billTime, forKey: .billTime)
         try encoderContainer.encode(consumeDate, forKey: .consumeDate)
         try encoderContainer.encode(transactionNo, forKey: .transactionNo)
         try encoderContainer.encode(consumeCount, forKey: .consumeCount)
         try encoderContainer.encode(cashPayFeeCount, forKey: .cashPayFeeCount)
         try encoderContainer.encode(achievmentCount, forKey: .achievmentCount)
         try encoderContainer.encode(payCouponFeeCount, forKey: .payCouponFeeCount)
         try encoderContainer.encode(freeCouponFeeCount, forKey: .freeCouponFeeCount)
    }
}
///  achievement
public class Achievement:NSObject,Codable{
    /// pin
    var pin:String?
    /// 名称
    var name:String?
    /// 真实名称
    var realName:String?
    /// serviceCode
    var serviceCode:String?
    /// serviceCodeName
    var serviceCodeName:String?
    /// 时间
    var consumeDate:String?
    /// 优惠前金额
    var consumeCount:Double?
    /// 现金支付
    var cashPayFeeCount:Double?
    /// 业绩金额
    var achievmentCount:Double?
    /// 付费代金卷金额
    var payCouponFeeCount:Double?
    /// 免费代金卷金额
    var freeCouponFeeCount:Double?



    public override init(){
            super.init()
    }

    enum AchievementCodingKeys: String, CodingKey {
        case pin
        case name
        case realName
        case serviceCode
        case serviceCodeName
        case consumeDate
        case consumeCount
        case cashPayFeeCount
        case achievmentCount
        case payCouponFeeCount
        case freeCouponFeeCount
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: AchievementCodingKeys.self)
        if decoderContainer.contains(.pin)
        {
            self.pin = try decoderContainer.decode(String?.self, forKey: .pin)
        }
        if decoderContainer.contains(.name)
        {
            self.name = try decoderContainer.decode(String?.self, forKey: .name)
        }
        if decoderContainer.contains(.realName)
        {
            self.realName = try decoderContainer.decode(String?.self, forKey: .realName)
        }
        if decoderContainer.contains(.serviceCode)
        {
            self.serviceCode = try decoderContainer.decode(String?.self, forKey: .serviceCode)
        }
        if decoderContainer.contains(.serviceCodeName)
        {
            self.serviceCodeName = try decoderContainer.decode(String?.self, forKey: .serviceCodeName)
        }
        if decoderContainer.contains(.consumeDate)
        {
            self.consumeDate = try decoderContainer.decode(String?.self, forKey: .consumeDate)
        }
        if decoderContainer.contains(.consumeCount)
        {
            self.consumeCount = try decoderContainer.decode(Double?.self, forKey: .consumeCount)
        }
        if decoderContainer.contains(.cashPayFeeCount)
        {
            self.cashPayFeeCount = try decoderContainer.decode(Double?.self, forKey: .cashPayFeeCount)
        }
        if decoderContainer.contains(.achievmentCount)
        {
            self.achievmentCount = try decoderContainer.decode(Double?.self, forKey: .achievmentCount)
        }
        if decoderContainer.contains(.payCouponFeeCount)
        {
            self.payCouponFeeCount = try decoderContainer.decode(Double?.self, forKey: .payCouponFeeCount)
        }
        if decoderContainer.contains(.freeCouponFeeCount)
        {
            self.freeCouponFeeCount = try decoderContainer.decode(Double?.self, forKey: .freeCouponFeeCount)
        }
    }
}
public extension Achievement{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: AchievementCodingKeys.self)
         try encoderContainer.encode(pin, forKey: .pin)
         try encoderContainer.encode(name, forKey: .name)
         try encoderContainer.encode(realName, forKey: .realName)
         try encoderContainer.encode(serviceCode, forKey: .serviceCode)
         try encoderContainer.encode(serviceCodeName, forKey: .serviceCodeName)
         try encoderContainer.encode(consumeDate, forKey: .consumeDate)
         try encoderContainer.encode(consumeCount, forKey: .consumeCount)
         try encoderContainer.encode(cashPayFeeCount, forKey: .cashPayFeeCount)
         try encoderContainer.encode(achievmentCount, forKey: .achievmentCount)
         try encoderContainer.encode(payCouponFeeCount, forKey: .payCouponFeeCount)
         try encoderContainer.encode(freeCouponFeeCount, forKey: .freeCouponFeeCount)
    }
}
///  operatorAchievement
public class OperatorAchievement:NSObject,Codable{
    /// pin
    var pin:String?
    /// 名称
    var name:String?
    /// 真实名称
    var realName:String?
    /// 一级服务商名称
    var oneLevelDistributorName:String?
    /// 二级服务商名称
    var secondLevelDistributorName:String?
    /// 部门
    var dept:Int?
    /// 部门名称
    var deptName:String?
    /// 服务商类型
    var distributorType:String?
    /// 服务商类型名称
    var distributorTypeName:String?
    /// 上级服务商名称
    var superDistributorName:String?
    /// 上级服务商pin
    var superDistributorPin:String?
    /// serviceCode
    var serviceCode:String?
    /// serviceCodeName
    var serviceCodeName:String?
    /// 时间
    var consumeDate:String?
    /// 优惠前金额
    var consumeCount:Double?
    /// 现金支付
    var cashPayFeeCount:Double?
    /// 业绩金额
    var achievmentCount:Double?
    /// 付费代金卷金额
    var payCouponFeeCount:Double?
    /// 免费代金卷金额
    var freeCouponFeeCount:Double?



    public override init(){
            super.init()
    }

    enum OperatorAchievementCodingKeys: String, CodingKey {
        case pin
        case name
        case realName
        case oneLevelDistributorName
        case secondLevelDistributorName
        case dept
        case deptName
        case distributorType
        case distributorTypeName
        case superDistributorName
        case superDistributorPin
        case serviceCode
        case serviceCodeName
        case consumeDate
        case consumeCount
        case cashPayFeeCount
        case achievmentCount
        case payCouponFeeCount
        case freeCouponFeeCount
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: OperatorAchievementCodingKeys.self)
        if decoderContainer.contains(.pin)
        {
            self.pin = try decoderContainer.decode(String?.self, forKey: .pin)
        }
        if decoderContainer.contains(.name)
        {
            self.name = try decoderContainer.decode(String?.self, forKey: .name)
        }
        if decoderContainer.contains(.realName)
        {
            self.realName = try decoderContainer.decode(String?.self, forKey: .realName)
        }
        if decoderContainer.contains(.oneLevelDistributorName)
        {
            self.oneLevelDistributorName = try decoderContainer.decode(String?.self, forKey: .oneLevelDistributorName)
        }
        if decoderContainer.contains(.secondLevelDistributorName)
        {
            self.secondLevelDistributorName = try decoderContainer.decode(String?.self, forKey: .secondLevelDistributorName)
        }
        if decoderContainer.contains(.dept)
        {
            self.dept = try decoderContainer.decode(Int?.self, forKey: .dept)
        }
        if decoderContainer.contains(.deptName)
        {
            self.deptName = try decoderContainer.decode(String?.self, forKey: .deptName)
        }
        if decoderContainer.contains(.distributorType)
        {
            self.distributorType = try decoderContainer.decode(String?.self, forKey: .distributorType)
        }
        if decoderContainer.contains(.distributorTypeName)
        {
            self.distributorTypeName = try decoderContainer.decode(String?.self, forKey: .distributorTypeName)
        }
        if decoderContainer.contains(.superDistributorName)
        {
            self.superDistributorName = try decoderContainer.decode(String?.self, forKey: .superDistributorName)
        }
        if decoderContainer.contains(.superDistributorPin)
        {
            self.superDistributorPin = try decoderContainer.decode(String?.self, forKey: .superDistributorPin)
        }
        if decoderContainer.contains(.serviceCode)
        {
            self.serviceCode = try decoderContainer.decode(String?.self, forKey: .serviceCode)
        }
        if decoderContainer.contains(.serviceCodeName)
        {
            self.serviceCodeName = try decoderContainer.decode(String?.self, forKey: .serviceCodeName)
        }
        if decoderContainer.contains(.consumeDate)
        {
            self.consumeDate = try decoderContainer.decode(String?.self, forKey: .consumeDate)
        }
        if decoderContainer.contains(.consumeCount)
        {
            self.consumeCount = try decoderContainer.decode(Double?.self, forKey: .consumeCount)
        }
        if decoderContainer.contains(.cashPayFeeCount)
        {
            self.cashPayFeeCount = try decoderContainer.decode(Double?.self, forKey: .cashPayFeeCount)
        }
        if decoderContainer.contains(.achievmentCount)
        {
            self.achievmentCount = try decoderContainer.decode(Double?.self, forKey: .achievmentCount)
        }
        if decoderContainer.contains(.payCouponFeeCount)
        {
            self.payCouponFeeCount = try decoderContainer.decode(Double?.self, forKey: .payCouponFeeCount)
        }
        if decoderContainer.contains(.freeCouponFeeCount)
        {
            self.freeCouponFeeCount = try decoderContainer.decode(Double?.self, forKey: .freeCouponFeeCount)
        }
    }
}
public extension OperatorAchievement{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: OperatorAchievementCodingKeys.self)
         try encoderContainer.encode(pin, forKey: .pin)
         try encoderContainer.encode(name, forKey: .name)
         try encoderContainer.encode(realName, forKey: .realName)
         try encoderContainer.encode(oneLevelDistributorName, forKey: .oneLevelDistributorName)
         try encoderContainer.encode(secondLevelDistributorName, forKey: .secondLevelDistributorName)
         try encoderContainer.encode(dept, forKey: .dept)
         try encoderContainer.encode(deptName, forKey: .deptName)
         try encoderContainer.encode(distributorType, forKey: .distributorType)
         try encoderContainer.encode(distributorTypeName, forKey: .distributorTypeName)
         try encoderContainer.encode(superDistributorName, forKey: .superDistributorName)
         try encoderContainer.encode(superDistributorPin, forKey: .superDistributorPin)
         try encoderContainer.encode(serviceCode, forKey: .serviceCode)
         try encoderContainer.encode(serviceCodeName, forKey: .serviceCodeName)
         try encoderContainer.encode(consumeDate, forKey: .consumeDate)
         try encoderContainer.encode(consumeCount, forKey: .consumeCount)
         try encoderContainer.encode(cashPayFeeCount, forKey: .cashPayFeeCount)
         try encoderContainer.encode(achievmentCount, forKey: .achievmentCount)
         try encoderContainer.encode(payCouponFeeCount, forKey: .payCouponFeeCount)
         try encoderContainer.encode(freeCouponFeeCount, forKey: .freeCouponFeeCount)
    }
}
///  orderItemDetail
public class OrderItemDetail:NSObject,Codable{
    /// 价格快照Json
    var priceSnapshot:String?
    /// 变更前资源配置
    var extraInfoBefore:[ExtraInfo?]?
    /// 变更后资源配置
    var extraInfoAfter:[ExtraInfo?]?
    /// 商品规格参数
    var extraInfo:[ExtraInfo?]?
    /// 应付金额（元）
    var actualFee:Double?
    /// 数量
    var quantity:Int?
    /// 续费前资源到期时间
    var expireDateBefore:String?
    /// 续费后资源到期时间
    var expireDateAfter:String?
    /// 计费时长单位
    var unit:String?
    /// 计费时长（购买时长）
    var chargeDuration:Int?
    /// 计费类型
    var chargeMode:String?
    /// 订单总额（元）
    var totalFee:Double?
    /// 资源类型
    var serviceName:String?
    /// 站点类型 0：主站,1：国际站,2：云市场
    var siteType:String?
    /// 下单时间
    var createTime:String?
    /// 订单商品状态：创建中、成功、失败
    var status:Int?
    /// 资源id
    var itemId:String?
    /// 资源名称
    var itemName:String?
    /// 计算公式（配置细项）
    var formula:String?
    /// 订单编号
    var orderNumber:String?
    /// 实际支付总金额
    var allActualFee:Double?
    /// 备注
    var remark:String?
    /// 现金支付
    var moneyPay:Double?
    /// 余额支付
    var balancePay:Double?
    /// 已退款金额
    var refundFee:Double?
    /// 订单计费类型：按配置、包年包月、按用量actualFee
    var chargeModeInfo:Int?
    /// 退款状态 RefundStatusEnum 0,申请退款 1,退款审核中 2,已退款 3,已取消 4,退款失败 5,财务审批驳回 6,财务审批通过
    var deleteStatus:Int?
    /// 代金券金额
    var favorableFee:Double?
    /// 变配明细
    var resizeFormulaType:Int?



    public override init(){
            super.init()
    }

    enum OrderItemDetailCodingKeys: String, CodingKey {
        case priceSnapshot
        case extraInfoBefore
        case extraInfoAfter
        case extraInfo
        case actualFee
        case quantity
        case expireDateBefore
        case expireDateAfter
        case unit
        case chargeDuration
        case chargeMode
        case totalFee
        case serviceName
        case siteType
        case createTime
        case status
        case itemId
        case itemName
        case formula
        case orderNumber
        case allActualFee
        case remark
        case moneyPay
        case balancePay
        case refundFee
        case chargeModeInfo
        case deleteStatus
        case favorableFee
        case resizeFormulaType
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: OrderItemDetailCodingKeys.self)
        if decoderContainer.contains(.priceSnapshot)
        {
            self.priceSnapshot = try decoderContainer.decode(String?.self, forKey: .priceSnapshot)
        }
        if decoderContainer.contains(.extraInfoBefore)
        {
            self.extraInfoBefore = try decoderContainer.decode([ExtraInfo?]?.self, forKey: .extraInfoBefore)
        }
        if decoderContainer.contains(.extraInfoAfter)
        {
            self.extraInfoAfter = try decoderContainer.decode([ExtraInfo?]?.self, forKey: .extraInfoAfter)
        }
        if decoderContainer.contains(.extraInfo)
        {
            self.extraInfo = try decoderContainer.decode([ExtraInfo?]?.self, forKey: .extraInfo)
        }
        if decoderContainer.contains(.actualFee)
        {
            self.actualFee = try decoderContainer.decode(Double?.self, forKey: .actualFee)
        }
        if decoderContainer.contains(.quantity)
        {
            self.quantity = try decoderContainer.decode(Int?.self, forKey: .quantity)
        }
        if decoderContainer.contains(.expireDateBefore)
        {
            self.expireDateBefore = try decoderContainer.decode(String?.self, forKey: .expireDateBefore)
        }
        if decoderContainer.contains(.expireDateAfter)
        {
            self.expireDateAfter = try decoderContainer.decode(String?.self, forKey: .expireDateAfter)
        }
        if decoderContainer.contains(.unit)
        {
            self.unit = try decoderContainer.decode(String?.self, forKey: .unit)
        }
        if decoderContainer.contains(.chargeDuration)
        {
            self.chargeDuration = try decoderContainer.decode(Int?.self, forKey: .chargeDuration)
        }
        if decoderContainer.contains(.chargeMode)
        {
            self.chargeMode = try decoderContainer.decode(String?.self, forKey: .chargeMode)
        }
        if decoderContainer.contains(.totalFee)
        {
            self.totalFee = try decoderContainer.decode(Double?.self, forKey: .totalFee)
        }
        if decoderContainer.contains(.serviceName)
        {
            self.serviceName = try decoderContainer.decode(String?.self, forKey: .serviceName)
        }
        if decoderContainer.contains(.siteType)
        {
            self.siteType = try decoderContainer.decode(String?.self, forKey: .siteType)
        }
        if decoderContainer.contains(.createTime)
        {
            self.createTime = try decoderContainer.decode(String?.self, forKey: .createTime)
        }
        if decoderContainer.contains(.status)
        {
            self.status = try decoderContainer.decode(Int?.self, forKey: .status)
        }
        if decoderContainer.contains(.itemId)
        {
            self.itemId = try decoderContainer.decode(String?.self, forKey: .itemId)
        }
        if decoderContainer.contains(.itemName)
        {
            self.itemName = try decoderContainer.decode(String?.self, forKey: .itemName)
        }
        if decoderContainer.contains(.formula)
        {
            self.formula = try decoderContainer.decode(String?.self, forKey: .formula)
        }
        if decoderContainer.contains(.orderNumber)
        {
            self.orderNumber = try decoderContainer.decode(String?.self, forKey: .orderNumber)
        }
        if decoderContainer.contains(.allActualFee)
        {
            self.allActualFee = try decoderContainer.decode(Double?.self, forKey: .allActualFee)
        }
        if decoderContainer.contains(.remark)
        {
            self.remark = try decoderContainer.decode(String?.self, forKey: .remark)
        }
        if decoderContainer.contains(.moneyPay)
        {
            self.moneyPay = try decoderContainer.decode(Double?.self, forKey: .moneyPay)
        }
        if decoderContainer.contains(.balancePay)
        {
            self.balancePay = try decoderContainer.decode(Double?.self, forKey: .balancePay)
        }
        if decoderContainer.contains(.refundFee)
        {
            self.refundFee = try decoderContainer.decode(Double?.self, forKey: .refundFee)
        }
        if decoderContainer.contains(.chargeModeInfo)
        {
            self.chargeModeInfo = try decoderContainer.decode(Int?.self, forKey: .chargeModeInfo)
        }
        if decoderContainer.contains(.deleteStatus)
        {
            self.deleteStatus = try decoderContainer.decode(Int?.self, forKey: .deleteStatus)
        }
        if decoderContainer.contains(.favorableFee)
        {
            self.favorableFee = try decoderContainer.decode(Double?.self, forKey: .favorableFee)
        }
        if decoderContainer.contains(.resizeFormulaType)
        {
            self.resizeFormulaType = try decoderContainer.decode(Int?.self, forKey: .resizeFormulaType)
        }
    }
}
public extension OrderItemDetail{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: OrderItemDetailCodingKeys.self)
         try encoderContainer.encode(priceSnapshot, forKey: .priceSnapshot)
         try encoderContainer.encode(extraInfoBefore, forKey: .extraInfoBefore)
         try encoderContainer.encode(extraInfoAfter, forKey: .extraInfoAfter)
         try encoderContainer.encode(extraInfo, forKey: .extraInfo)
         try encoderContainer.encode(actualFee, forKey: .actualFee)
         try encoderContainer.encode(quantity, forKey: .quantity)
         try encoderContainer.encode(expireDateBefore, forKey: .expireDateBefore)
         try encoderContainer.encode(expireDateAfter, forKey: .expireDateAfter)
         try encoderContainer.encode(unit, forKey: .unit)
         try encoderContainer.encode(chargeDuration, forKey: .chargeDuration)
         try encoderContainer.encode(chargeMode, forKey: .chargeMode)
         try encoderContainer.encode(totalFee, forKey: .totalFee)
         try encoderContainer.encode(serviceName, forKey: .serviceName)
         try encoderContainer.encode(siteType, forKey: .siteType)
         try encoderContainer.encode(createTime, forKey: .createTime)
         try encoderContainer.encode(status, forKey: .status)
         try encoderContainer.encode(itemId, forKey: .itemId)
         try encoderContainer.encode(itemName, forKey: .itemName)
         try encoderContainer.encode(formula, forKey: .formula)
         try encoderContainer.encode(orderNumber, forKey: .orderNumber)
         try encoderContainer.encode(allActualFee, forKey: .allActualFee)
         try encoderContainer.encode(remark, forKey: .remark)
         try encoderContainer.encode(moneyPay, forKey: .moneyPay)
         try encoderContainer.encode(balancePay, forKey: .balancePay)
         try encoderContainer.encode(refundFee, forKey: .refundFee)
         try encoderContainer.encode(chargeModeInfo, forKey: .chargeModeInfo)
         try encoderContainer.encode(deleteStatus, forKey: .deleteStatus)
         try encoderContainer.encode(favorableFee, forKey: .favorableFee)
         try encoderContainer.encode(resizeFormulaType, forKey: .resizeFormulaType)
    }
}
///  department
public class Department:NSObject,Codable{
    /// ID
    var id:Int?
    /// 部门编号
    var depId:String?
    /// 部门名称
    var depName:String?
    /// 是否删除0未删除,1已删除
    var isDeleted:Int?



    public override init(){
            super.init()
    }

    enum DepartmentCodingKeys: String, CodingKey {
        case id
        case depId
        case depName
        case isDeleted
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: DepartmentCodingKeys.self)
        if decoderContainer.contains(.id)
        {
            self.id = try decoderContainer.decode(Int?.self, forKey: .id)
        }
        if decoderContainer.contains(.depId)
        {
            self.depId = try decoderContainer.decode(String?.self, forKey: .depId)
        }
        if decoderContainer.contains(.depName)
        {
            self.depName = try decoderContainer.decode(String?.self, forKey: .depName)
        }
        if decoderContainer.contains(.isDeleted)
        {
            self.isDeleted = try decoderContainer.decode(Int?.self, forKey: .isDeleted)
        }
    }
}
public extension Department{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: DepartmentCodingKeys.self)
         try encoderContainer.encode(id, forKey: .id)
         try encoderContainer.encode(depId, forKey: .depId)
         try encoderContainer.encode(depName, forKey: .depName)
         try encoderContainer.encode(isDeleted, forKey: .isDeleted)
    }
}
///  distributorDTO
public class DistributorDTO:NSObject,Codable{
    /// 渠道商ID
    var distributorId:String?
    /// 渠道商名称
    var distributorName:String?
    /// 京东云账户
    var pin:String?
    /// 合同编号
    var contractNo:String?
    /// 营业执照号
    var businessLicense:String?
    /// 法定代表人
    var legalRepresentative:String?
    /// 营业执照图片
    var businessLicensePic:String?
    /// 主营业务描述
    var businessDesc:String?
    /// 办公地址
    var workAddress:String?
    /// 联系人姓名
    var contracter:String?
    /// 联系人电话
    var tel:String?
    /// 邮箱
    var email:String?
    /// 所属地域
    var region:String?
    /// 入驻日期(一级渠道商手工录入、二级渠道商审批通过日期)
    var settleTime:String?
    /// 状态(0 审批中、2驳回、1 已入驻、3已停止合作)
    var status:Int?
    /// 驳回原因
    var reason:String?
    /// 级次(0一级、1 二级)
    var distributorLevel:Int?
    /// 渠道商类型(0合作伙伴、1 渠道代理)
    var distributorType:Int?
    /// 上级渠道商ID
    var parentDistributorId:String?
    /// 银行开户名
    var bankCompanyName:String?
    /// 银行账户
    var bankCardNo:String?
    /// 开户行支行名称
    var bankBranchName:String?
    /// 开户行支行联行号
    var bankBranchNo:String?
    /// 合同主体
    var contractSubject:String?
    /// 所属部门(0企业线、1政府线)
    var dept:Int?
    /// 京东云负责人(京东云人员erp或名称)
    var erp:String?



    public override init(){
            super.init()
    }

    enum DistributorDTOCodingKeys: String, CodingKey {
        case distributorId
        case distributorName
        case pin
        case contractNo
        case businessLicense
        case legalRepresentative
        case businessLicensePic
        case businessDesc
        case workAddress
        case contracter
        case tel
        case email
        case region
        case settleTime
        case status
        case reason
        case distributorLevel
        case distributorType
        case parentDistributorId
        case bankCompanyName
        case bankCardNo
        case bankBranchName
        case bankBranchNo
        case contractSubject
        case dept
        case erp
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: DistributorDTOCodingKeys.self)
        if decoderContainer.contains(.distributorId)
        {
            self.distributorId = try decoderContainer.decode(String?.self, forKey: .distributorId)
        }
        if decoderContainer.contains(.distributorName)
        {
            self.distributorName = try decoderContainer.decode(String?.self, forKey: .distributorName)
        }
        if decoderContainer.contains(.pin)
        {
            self.pin = try decoderContainer.decode(String?.self, forKey: .pin)
        }
        if decoderContainer.contains(.contractNo)
        {
            self.contractNo = try decoderContainer.decode(String?.self, forKey: .contractNo)
        }
        if decoderContainer.contains(.businessLicense)
        {
            self.businessLicense = try decoderContainer.decode(String?.self, forKey: .businessLicense)
        }
        if decoderContainer.contains(.legalRepresentative)
        {
            self.legalRepresentative = try decoderContainer.decode(String?.self, forKey: .legalRepresentative)
        }
        if decoderContainer.contains(.businessLicensePic)
        {
            self.businessLicensePic = try decoderContainer.decode(String?.self, forKey: .businessLicensePic)
        }
        if decoderContainer.contains(.businessDesc)
        {
            self.businessDesc = try decoderContainer.decode(String?.self, forKey: .businessDesc)
        }
        if decoderContainer.contains(.workAddress)
        {
            self.workAddress = try decoderContainer.decode(String?.self, forKey: .workAddress)
        }
        if decoderContainer.contains(.contracter)
        {
            self.contracter = try decoderContainer.decode(String?.self, forKey: .contracter)
        }
        if decoderContainer.contains(.tel)
        {
            self.tel = try decoderContainer.decode(String?.self, forKey: .tel)
        }
        if decoderContainer.contains(.email)
        {
            self.email = try decoderContainer.decode(String?.self, forKey: .email)
        }
        if decoderContainer.contains(.region)
        {
            self.region = try decoderContainer.decode(String?.self, forKey: .region)
        }
        if decoderContainer.contains(.settleTime)
        {
            self.settleTime = try decoderContainer.decode(String?.self, forKey: .settleTime)
        }
        if decoderContainer.contains(.status)
        {
            self.status = try decoderContainer.decode(Int?.self, forKey: .status)
        }
        if decoderContainer.contains(.reason)
        {
            self.reason = try decoderContainer.decode(String?.self, forKey: .reason)
        }
        if decoderContainer.contains(.distributorLevel)
        {
            self.distributorLevel = try decoderContainer.decode(Int?.self, forKey: .distributorLevel)
        }
        if decoderContainer.contains(.distributorType)
        {
            self.distributorType = try decoderContainer.decode(Int?.self, forKey: .distributorType)
        }
        if decoderContainer.contains(.parentDistributorId)
        {
            self.parentDistributorId = try decoderContainer.decode(String?.self, forKey: .parentDistributorId)
        }
        if decoderContainer.contains(.bankCompanyName)
        {
            self.bankCompanyName = try decoderContainer.decode(String?.self, forKey: .bankCompanyName)
        }
        if decoderContainer.contains(.bankCardNo)
        {
            self.bankCardNo = try decoderContainer.decode(String?.self, forKey: .bankCardNo)
        }
        if decoderContainer.contains(.bankBranchName)
        {
            self.bankBranchName = try decoderContainer.decode(String?.self, forKey: .bankBranchName)
        }
        if decoderContainer.contains(.bankBranchNo)
        {
            self.bankBranchNo = try decoderContainer.decode(String?.self, forKey: .bankBranchNo)
        }
        if decoderContainer.contains(.contractSubject)
        {
            self.contractSubject = try decoderContainer.decode(String?.self, forKey: .contractSubject)
        }
        if decoderContainer.contains(.dept)
        {
            self.dept = try decoderContainer.decode(Int?.self, forKey: .dept)
        }
        if decoderContainer.contains(.erp)
        {
            self.erp = try decoderContainer.decode(String?.self, forKey: .erp)
        }
    }
}
public extension DistributorDTO{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: DistributorDTOCodingKeys.self)
         try encoderContainer.encode(distributorId, forKey: .distributorId)
         try encoderContainer.encode(distributorName, forKey: .distributorName)
         try encoderContainer.encode(pin, forKey: .pin)
         try encoderContainer.encode(contractNo, forKey: .contractNo)
         try encoderContainer.encode(businessLicense, forKey: .businessLicense)
         try encoderContainer.encode(legalRepresentative, forKey: .legalRepresentative)
         try encoderContainer.encode(businessLicensePic, forKey: .businessLicensePic)
         try encoderContainer.encode(businessDesc, forKey: .businessDesc)
         try encoderContainer.encode(workAddress, forKey: .workAddress)
         try encoderContainer.encode(contracter, forKey: .contracter)
         try encoderContainer.encode(tel, forKey: .tel)
         try encoderContainer.encode(email, forKey: .email)
         try encoderContainer.encode(region, forKey: .region)
         try encoderContainer.encode(settleTime, forKey: .settleTime)
         try encoderContainer.encode(status, forKey: .status)
         try encoderContainer.encode(reason, forKey: .reason)
         try encoderContainer.encode(distributorLevel, forKey: .distributorLevel)
         try encoderContainer.encode(distributorType, forKey: .distributorType)
         try encoderContainer.encode(parentDistributorId, forKey: .parentDistributorId)
         try encoderContainer.encode(bankCompanyName, forKey: .bankCompanyName)
         try encoderContainer.encode(bankCardNo, forKey: .bankCardNo)
         try encoderContainer.encode(bankBranchName, forKey: .bankBranchName)
         try encoderContainer.encode(bankBranchNo, forKey: .bankBranchNo)
         try encoderContainer.encode(contractSubject, forKey: .contractSubject)
         try encoderContainer.encode(dept, forKey: .dept)
         try encoderContainer.encode(erp, forKey: .erp)
    }
}
///  distributorQuery
public class DistributorQuery:NSObject,Codable{
    /// 渠道商ID
    var distributorId:String?
    /// 渠道商名称
    var distributorName:String?
    /// 京东云账户
    var pin:String?
    /// 合同编号
    var contractNo:String?
    /// 营业执照号
    var businessLicense:String?
    /// 法定代表人
    var legalRepresentative:String?
    /// 营业执照图片
    var businessLicensePic:String?
    /// 主营业务描述
    var businessDesc:String?
    /// 办公地址
    var workAddress:String?
    /// 联系人姓名
    var contracter:String?
    /// 联系人电话
    var tel:String?
    /// 邮箱
    var email:String?
    /// 所属地域
    var region:String?
    /// 入驻日期(一级渠道商手工录入、二级渠道商审批通过日期)
    var settleTime:String?
    /// 状态(0 审批中、2驳回、1 已入驻、3已停止合作)
    var status:Int?
    /// 驳回原因
    var reason:String?
    /// 级次(0一级、1 二级)
    var distributorLevel:Int?
    /// 渠道商类型(0合作伙伴、1 渠道代理)
    var distributorType:Int?
    /// 上级渠道商pin
    var parentPin:String?
    /// 上级渠道商ID
    var parentDistributorId:String?
    /// 上级渠道商名称
    var parentDistributorName:String?
    /// 所属部门(0企业线、1政府线)
    var dept:Int?
    /// 京东云负责人(京东云人员erp或名称)
    var erp:String?
    /// 入驻条件开始日期
    var settleTimeBegin:String?
    /// 入驻条件结束日期
    var settleTimeEnd:String?
    /// 当前页序号
    var pageIndex:Int?
    /// 每页结果数量
    var pageSize:Int?
    /// Offset
    var offset:Int?



    public override init(){
            super.init()
    }

    enum DistributorQueryCodingKeys: String, CodingKey {
        case distributorId
        case distributorName
        case pin
        case contractNo
        case businessLicense
        case legalRepresentative
        case businessLicensePic
        case businessDesc
        case workAddress
        case contracter
        case tel
        case email
        case region
        case settleTime
        case status
        case reason
        case distributorLevel
        case distributorType
        case parentPin
        case parentDistributorId
        case parentDistributorName
        case dept
        case erp
        case settleTimeBegin
        case settleTimeEnd
        case pageIndex
        case pageSize
        case offset
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: DistributorQueryCodingKeys.self)
        if decoderContainer.contains(.distributorId)
        {
            self.distributorId = try decoderContainer.decode(String?.self, forKey: .distributorId)
        }
        if decoderContainer.contains(.distributorName)
        {
            self.distributorName = try decoderContainer.decode(String?.self, forKey: .distributorName)
        }
        if decoderContainer.contains(.pin)
        {
            self.pin = try decoderContainer.decode(String?.self, forKey: .pin)
        }
        if decoderContainer.contains(.contractNo)
        {
            self.contractNo = try decoderContainer.decode(String?.self, forKey: .contractNo)
        }
        if decoderContainer.contains(.businessLicense)
        {
            self.businessLicense = try decoderContainer.decode(String?.self, forKey: .businessLicense)
        }
        if decoderContainer.contains(.legalRepresentative)
        {
            self.legalRepresentative = try decoderContainer.decode(String?.self, forKey: .legalRepresentative)
        }
        if decoderContainer.contains(.businessLicensePic)
        {
            self.businessLicensePic = try decoderContainer.decode(String?.self, forKey: .businessLicensePic)
        }
        if decoderContainer.contains(.businessDesc)
        {
            self.businessDesc = try decoderContainer.decode(String?.self, forKey: .businessDesc)
        }
        if decoderContainer.contains(.workAddress)
        {
            self.workAddress = try decoderContainer.decode(String?.self, forKey: .workAddress)
        }
        if decoderContainer.contains(.contracter)
        {
            self.contracter = try decoderContainer.decode(String?.self, forKey: .contracter)
        }
        if decoderContainer.contains(.tel)
        {
            self.tel = try decoderContainer.decode(String?.self, forKey: .tel)
        }
        if decoderContainer.contains(.email)
        {
            self.email = try decoderContainer.decode(String?.self, forKey: .email)
        }
        if decoderContainer.contains(.region)
        {
            self.region = try decoderContainer.decode(String?.self, forKey: .region)
        }
        if decoderContainer.contains(.settleTime)
        {
            self.settleTime = try decoderContainer.decode(String?.self, forKey: .settleTime)
        }
        if decoderContainer.contains(.status)
        {
            self.status = try decoderContainer.decode(Int?.self, forKey: .status)
        }
        if decoderContainer.contains(.reason)
        {
            self.reason = try decoderContainer.decode(String?.self, forKey: .reason)
        }
        if decoderContainer.contains(.distributorLevel)
        {
            self.distributorLevel = try decoderContainer.decode(Int?.self, forKey: .distributorLevel)
        }
        if decoderContainer.contains(.distributorType)
        {
            self.distributorType = try decoderContainer.decode(Int?.self, forKey: .distributorType)
        }
        if decoderContainer.contains(.parentPin)
        {
            self.parentPin = try decoderContainer.decode(String?.self, forKey: .parentPin)
        }
        if decoderContainer.contains(.parentDistributorId)
        {
            self.parentDistributorId = try decoderContainer.decode(String?.self, forKey: .parentDistributorId)
        }
        if decoderContainer.contains(.parentDistributorName)
        {
            self.parentDistributorName = try decoderContainer.decode(String?.self, forKey: .parentDistributorName)
        }
        if decoderContainer.contains(.dept)
        {
            self.dept = try decoderContainer.decode(Int?.self, forKey: .dept)
        }
        if decoderContainer.contains(.erp)
        {
            self.erp = try decoderContainer.decode(String?.self, forKey: .erp)
        }
        if decoderContainer.contains(.settleTimeBegin)
        {
            self.settleTimeBegin = try decoderContainer.decode(String?.self, forKey: .settleTimeBegin)
        }
        if decoderContainer.contains(.settleTimeEnd)
        {
            self.settleTimeEnd = try decoderContainer.decode(String?.self, forKey: .settleTimeEnd)
        }
        if decoderContainer.contains(.pageIndex)
        {
            self.pageIndex = try decoderContainer.decode(Int?.self, forKey: .pageIndex)
        }
        if decoderContainer.contains(.pageSize)
        {
            self.pageSize = try decoderContainer.decode(Int?.self, forKey: .pageSize)
        }
        if decoderContainer.contains(.offset)
        {
            self.offset = try decoderContainer.decode(Int?.self, forKey: .offset)
        }
    }
}
public extension DistributorQuery{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: DistributorQueryCodingKeys.self)
         try encoderContainer.encode(distributorId, forKey: .distributorId)
         try encoderContainer.encode(distributorName, forKey: .distributorName)
         try encoderContainer.encode(pin, forKey: .pin)
         try encoderContainer.encode(contractNo, forKey: .contractNo)
         try encoderContainer.encode(businessLicense, forKey: .businessLicense)
         try encoderContainer.encode(legalRepresentative, forKey: .legalRepresentative)
         try encoderContainer.encode(businessLicensePic, forKey: .businessLicensePic)
         try encoderContainer.encode(businessDesc, forKey: .businessDesc)
         try encoderContainer.encode(workAddress, forKey: .workAddress)
         try encoderContainer.encode(contracter, forKey: .contracter)
         try encoderContainer.encode(tel, forKey: .tel)
         try encoderContainer.encode(email, forKey: .email)
         try encoderContainer.encode(region, forKey: .region)
         try encoderContainer.encode(settleTime, forKey: .settleTime)
         try encoderContainer.encode(status, forKey: .status)
         try encoderContainer.encode(reason, forKey: .reason)
         try encoderContainer.encode(distributorLevel, forKey: .distributorLevel)
         try encoderContainer.encode(distributorType, forKey: .distributorType)
         try encoderContainer.encode(parentPin, forKey: .parentPin)
         try encoderContainer.encode(parentDistributorId, forKey: .parentDistributorId)
         try encoderContainer.encode(parentDistributorName, forKey: .parentDistributorName)
         try encoderContainer.encode(dept, forKey: .dept)
         try encoderContainer.encode(erp, forKey: .erp)
         try encoderContainer.encode(settleTimeBegin, forKey: .settleTimeBegin)
         try encoderContainer.encode(settleTimeEnd, forKey: .settleTimeEnd)
         try encoderContainer.encode(pageIndex, forKey: .pageIndex)
         try encoderContainer.encode(pageSize, forKey: .pageSize)
         try encoderContainer.encode(offset, forKey: .offset)
    }
}
///  distributorResult
public class DistributorResult:NSObject,Codable{
    /// 渠道商ID
    var distributorId:String?
    /// 渠道商名称
    var distributorName:String?
    /// 京东云账户
    var pin:String?
    /// 合同编号
    var contractNo:String?
    /// 营业执照号
    var businessLicense:String?
    /// 法定代表人
    var legalRepresentative:String?
    /// 营业执照图片
    var businessLicensePic:String?
    /// 主营业务描述
    var businessDesc:String?
    /// 办公地址
    var workAddress:String?
    /// 联系人姓名
    var contracter:String?
    /// 联系人电话
    var tel:String?
    /// 邮箱
    var email:String?
    /// 所属地域
    var region:String?
    /// 入驻日期(一级渠道商手工录入、二级渠道商审批通过日期)
    var settleTime:String?
    /// 状态(0 审批中、2驳回、1 已入驻、3已停止合作)
    var status:Int?
    /// 驳回原因
    var reason:String?
    /// 级次(0一级、1 二级)
    var distributorLevel:Int?
    /// 渠道商类型(0合作伙伴、1 渠道代理)
    var distributorType:Int?
    /// 上级渠道商ID
    var parentDistributorId:String?
    /// 所属部门(0企业线、1政府线)
    var dept:Int?
    /// 部门名称
    var deptName:String?
    /// 京东云负责人(京东云人员erp或名称)
    var erp:String?
    /// CustomerCount
    var customerCount:Int?
    /// 一级渠道商名称
    var parentDistributorName:String?
    /// 入驻时间
    var settleTimeStr:String?
    /// 服务商最大层级
    var level:Int?



    public override init(){
            super.init()
    }

    enum DistributorResultCodingKeys: String, CodingKey {
        case distributorId
        case distributorName
        case pin
        case contractNo
        case businessLicense
        case legalRepresentative
        case businessLicensePic
        case businessDesc
        case workAddress
        case contracter
        case tel
        case email
        case region
        case settleTime
        case status
        case reason
        case distributorLevel
        case distributorType
        case parentDistributorId
        case dept
        case deptName
        case erp
        case customerCount
        case parentDistributorName
        case settleTimeStr
        case level
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: DistributorResultCodingKeys.self)
        if decoderContainer.contains(.distributorId)
        {
            self.distributorId = try decoderContainer.decode(String?.self, forKey: .distributorId)
        }
        if decoderContainer.contains(.distributorName)
        {
            self.distributorName = try decoderContainer.decode(String?.self, forKey: .distributorName)
        }
        if decoderContainer.contains(.pin)
        {
            self.pin = try decoderContainer.decode(String?.self, forKey: .pin)
        }
        if decoderContainer.contains(.contractNo)
        {
            self.contractNo = try decoderContainer.decode(String?.self, forKey: .contractNo)
        }
        if decoderContainer.contains(.businessLicense)
        {
            self.businessLicense = try decoderContainer.decode(String?.self, forKey: .businessLicense)
        }
        if decoderContainer.contains(.legalRepresentative)
        {
            self.legalRepresentative = try decoderContainer.decode(String?.self, forKey: .legalRepresentative)
        }
        if decoderContainer.contains(.businessLicensePic)
        {
            self.businessLicensePic = try decoderContainer.decode(String?.self, forKey: .businessLicensePic)
        }
        if decoderContainer.contains(.businessDesc)
        {
            self.businessDesc = try decoderContainer.decode(String?.self, forKey: .businessDesc)
        }
        if decoderContainer.contains(.workAddress)
        {
            self.workAddress = try decoderContainer.decode(String?.self, forKey: .workAddress)
        }
        if decoderContainer.contains(.contracter)
        {
            self.contracter = try decoderContainer.decode(String?.self, forKey: .contracter)
        }
        if decoderContainer.contains(.tel)
        {
            self.tel = try decoderContainer.decode(String?.self, forKey: .tel)
        }
        if decoderContainer.contains(.email)
        {
            self.email = try decoderContainer.decode(String?.self, forKey: .email)
        }
        if decoderContainer.contains(.region)
        {
            self.region = try decoderContainer.decode(String?.self, forKey: .region)
        }
        if decoderContainer.contains(.settleTime)
        {
            self.settleTime = try decoderContainer.decode(String?.self, forKey: .settleTime)
        }
        if decoderContainer.contains(.status)
        {
            self.status = try decoderContainer.decode(Int?.self, forKey: .status)
        }
        if decoderContainer.contains(.reason)
        {
            self.reason = try decoderContainer.decode(String?.self, forKey: .reason)
        }
        if decoderContainer.contains(.distributorLevel)
        {
            self.distributorLevel = try decoderContainer.decode(Int?.self, forKey: .distributorLevel)
        }
        if decoderContainer.contains(.distributorType)
        {
            self.distributorType = try decoderContainer.decode(Int?.self, forKey: .distributorType)
        }
        if decoderContainer.contains(.parentDistributorId)
        {
            self.parentDistributorId = try decoderContainer.decode(String?.self, forKey: .parentDistributorId)
        }
        if decoderContainer.contains(.dept)
        {
            self.dept = try decoderContainer.decode(Int?.self, forKey: .dept)
        }
        if decoderContainer.contains(.deptName)
        {
            self.deptName = try decoderContainer.decode(String?.self, forKey: .deptName)
        }
        if decoderContainer.contains(.erp)
        {
            self.erp = try decoderContainer.decode(String?.self, forKey: .erp)
        }
        if decoderContainer.contains(.customerCount)
        {
            self.customerCount = try decoderContainer.decode(Int?.self, forKey: .customerCount)
        }
        if decoderContainer.contains(.parentDistributorName)
        {
            self.parentDistributorName = try decoderContainer.decode(String?.self, forKey: .parentDistributorName)
        }
        if decoderContainer.contains(.settleTimeStr)
        {
            self.settleTimeStr = try decoderContainer.decode(String?.self, forKey: .settleTimeStr)
        }
        if decoderContainer.contains(.level)
        {
            self.level = try decoderContainer.decode(Int?.self, forKey: .level)
        }
    }
}
public extension DistributorResult{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: DistributorResultCodingKeys.self)
         try encoderContainer.encode(distributorId, forKey: .distributorId)
         try encoderContainer.encode(distributorName, forKey: .distributorName)
         try encoderContainer.encode(pin, forKey: .pin)
         try encoderContainer.encode(contractNo, forKey: .contractNo)
         try encoderContainer.encode(businessLicense, forKey: .businessLicense)
         try encoderContainer.encode(legalRepresentative, forKey: .legalRepresentative)
         try encoderContainer.encode(businessLicensePic, forKey: .businessLicensePic)
         try encoderContainer.encode(businessDesc, forKey: .businessDesc)
         try encoderContainer.encode(workAddress, forKey: .workAddress)
         try encoderContainer.encode(contracter, forKey: .contracter)
         try encoderContainer.encode(tel, forKey: .tel)
         try encoderContainer.encode(email, forKey: .email)
         try encoderContainer.encode(region, forKey: .region)
         try encoderContainer.encode(settleTime, forKey: .settleTime)
         try encoderContainer.encode(status, forKey: .status)
         try encoderContainer.encode(reason, forKey: .reason)
         try encoderContainer.encode(distributorLevel, forKey: .distributorLevel)
         try encoderContainer.encode(distributorType, forKey: .distributorType)
         try encoderContainer.encode(parentDistributorId, forKey: .parentDistributorId)
         try encoderContainer.encode(dept, forKey: .dept)
         try encoderContainer.encode(deptName, forKey: .deptName)
         try encoderContainer.encode(erp, forKey: .erp)
         try encoderContainer.encode(customerCount, forKey: .customerCount)
         try encoderContainer.encode(parentDistributorName, forKey: .parentDistributorName)
         try encoderContainer.encode(settleTimeStr, forKey: .settleTimeStr)
         try encoderContainer.encode(level, forKey: .level)
    }
}
///  operateAuthority
public class OperateAuthority:NSObject,Codable{
    /// ID
    var id:Double?
    /// 部门ID
    var deptId:Int?
    /// 部门名称
    var deptName:String?
    /// 操作人
    var operatorValue:String?
    /// 修改时间
    var createTime:String?
    /// 创建人
    var createUser:String?
    /// 修改时间
    var updateTime:String?
    /// 修改人
    var updateUser:String?
    /// 是否删除0未删除,1已删除
    var yn:Int?



    public override init(){
            super.init()
    }

    enum OperateAuthorityCodingKeys: String, CodingKey {
        case id
        case deptId
        case deptName
        case operatorValue = "operator"
        case createTime
        case createUser
        case updateTime
        case updateUser
        case yn
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: OperateAuthorityCodingKeys.self)
        if decoderContainer.contains(.id)
        {
            self.id = try decoderContainer.decode(Double?.self, forKey: .id)
        }
        if decoderContainer.contains(.deptId)
        {
            self.deptId = try decoderContainer.decode(Int?.self, forKey: .deptId)
        }
        if decoderContainer.contains(.deptName)
        {
            self.deptName = try decoderContainer.decode(String?.self, forKey: .deptName)
        }
        if decoderContainer.contains(.operatorValue)
        {
            self.operatorValue = try decoderContainer.decode(String?.self, forKey: .operatorValue)
        }
        if decoderContainer.contains(.createTime)
        {
            self.createTime = try decoderContainer.decode(String?.self, forKey: .createTime)
        }
        if decoderContainer.contains(.createUser)
        {
            self.createUser = try decoderContainer.decode(String?.self, forKey: .createUser)
        }
        if decoderContainer.contains(.updateTime)
        {
            self.updateTime = try decoderContainer.decode(String?.self, forKey: .updateTime)
        }
        if decoderContainer.contains(.updateUser)
        {
            self.updateUser = try decoderContainer.decode(String?.self, forKey: .updateUser)
        }
        if decoderContainer.contains(.yn)
        {
            self.yn = try decoderContainer.decode(Int?.self, forKey: .yn)
        }
    }
}
public extension OperateAuthority{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: OperateAuthorityCodingKeys.self)
         try encoderContainer.encode(id, forKey: .id)
         try encoderContainer.encode(deptId, forKey: .deptId)
         try encoderContainer.encode(deptName, forKey: .deptName)
         try encoderContainer.encode(operatorValue, forKey: .operatorValue)
         try encoderContainer.encode(createTime, forKey: .createTime)
         try encoderContainer.encode(createUser, forKey: .createUser)
         try encoderContainer.encode(updateTime, forKey: .updateTime)
         try encoderContainer.encode(updateUser, forKey: .updateUser)
         try encoderContainer.encode(yn, forKey: .yn)
    }
}
///  operateAuthorityDTO
public class OperateAuthorityDTO:NSObject,Codable{
    /// ID
    var id:Double?
    /// 部门ID
    var deptId:Int?
    /// 部门名称
    var deptName:String?
    /// 操作人
    var operatorValue:String?
    /// 修改时间
    var createTime:String?
    /// 创建人
    var createUser:String?
    /// 修改时间
    var updateTime:String?
    /// 修改人
    var updateUser:String?
    /// 是否删除0未删除,1已删除
    var yn:Int?



    public override init(){
            super.init()
    }

    enum OperateAuthorityDTOCodingKeys: String, CodingKey {
        case id
        case deptId
        case deptName
        case operatorValue = "operator"
        case createTime
        case createUser
        case updateTime
        case updateUser
        case yn
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: OperateAuthorityDTOCodingKeys.self)
        if decoderContainer.contains(.id)
        {
            self.id = try decoderContainer.decode(Double?.self, forKey: .id)
        }
        if decoderContainer.contains(.deptId)
        {
            self.deptId = try decoderContainer.decode(Int?.self, forKey: .deptId)
        }
        if decoderContainer.contains(.deptName)
        {
            self.deptName = try decoderContainer.decode(String?.self, forKey: .deptName)
        }
        if decoderContainer.contains(.operatorValue)
        {
            self.operatorValue = try decoderContainer.decode(String?.self, forKey: .operatorValue)
        }
        if decoderContainer.contains(.createTime)
        {
            self.createTime = try decoderContainer.decode(String?.self, forKey: .createTime)
        }
        if decoderContainer.contains(.createUser)
        {
            self.createUser = try decoderContainer.decode(String?.self, forKey: .createUser)
        }
        if decoderContainer.contains(.updateTime)
        {
            self.updateTime = try decoderContainer.decode(String?.self, forKey: .updateTime)
        }
        if decoderContainer.contains(.updateUser)
        {
            self.updateUser = try decoderContainer.decode(String?.self, forKey: .updateUser)
        }
        if decoderContainer.contains(.yn)
        {
            self.yn = try decoderContainer.decode(Int?.self, forKey: .yn)
        }
    }
}
public extension OperateAuthorityDTO{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: OperateAuthorityDTOCodingKeys.self)
         try encoderContainer.encode(id, forKey: .id)
         try encoderContainer.encode(deptId, forKey: .deptId)
         try encoderContainer.encode(deptName, forKey: .deptName)
         try encoderContainer.encode(operatorValue, forKey: .operatorValue)
         try encoderContainer.encode(createTime, forKey: .createTime)
         try encoderContainer.encode(createUser, forKey: .createUser)
         try encoderContainer.encode(updateTime, forKey: .updateTime)
         try encoderContainer.encode(updateUser, forKey: .updateUser)
         try encoderContainer.encode(yn, forKey: .yn)
    }
}
///  operateAuthorityQuery
public class OperateAuthorityQuery:NSObject,Codable{
    /// ID
    var id:Double?
    /// 部门ID
    var deptId:Int?
    /// 部门名称
    var deptName:String?
    /// 操作人
    var operatorValue:String?
    /// 修改时间
    var createTime:String?
    /// 创建人
    var createUser:String?
    /// 修改时间
    var updateTime:String?
    /// 修改人
    var updateUser:String?
    /// 是否删除0未删除,1已删除
    var yn:Int?
    /// 当前页序号
    var pageIndex:Int?
    /// 每页结果数量
    var pageSize:Int?
    /// Offset
    var offset:Int?



    public override init(){
            super.init()
    }

    enum OperateAuthorityQueryCodingKeys: String, CodingKey {
        case id
        case deptId
        case deptName
        case operatorValue = "operator"
        case createTime
        case createUser
        case updateTime
        case updateUser
        case yn
        case pageIndex
        case pageSize
        case offset
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: OperateAuthorityQueryCodingKeys.self)
        if decoderContainer.contains(.id)
        {
            self.id = try decoderContainer.decode(Double?.self, forKey: .id)
        }
        if decoderContainer.contains(.deptId)
        {
            self.deptId = try decoderContainer.decode(Int?.self, forKey: .deptId)
        }
        if decoderContainer.contains(.deptName)
        {
            self.deptName = try decoderContainer.decode(String?.self, forKey: .deptName)
        }
        if decoderContainer.contains(.operatorValue)
        {
            self.operatorValue = try decoderContainer.decode(String?.self, forKey: .operatorValue)
        }
        if decoderContainer.contains(.createTime)
        {
            self.createTime = try decoderContainer.decode(String?.self, forKey: .createTime)
        }
        if decoderContainer.contains(.createUser)
        {
            self.createUser = try decoderContainer.decode(String?.self, forKey: .createUser)
        }
        if decoderContainer.contains(.updateTime)
        {
            self.updateTime = try decoderContainer.decode(String?.self, forKey: .updateTime)
        }
        if decoderContainer.contains(.updateUser)
        {
            self.updateUser = try decoderContainer.decode(String?.self, forKey: .updateUser)
        }
        if decoderContainer.contains(.yn)
        {
            self.yn = try decoderContainer.decode(Int?.self, forKey: .yn)
        }
        if decoderContainer.contains(.pageIndex)
        {
            self.pageIndex = try decoderContainer.decode(Int?.self, forKey: .pageIndex)
        }
        if decoderContainer.contains(.pageSize)
        {
            self.pageSize = try decoderContainer.decode(Int?.self, forKey: .pageSize)
        }
        if decoderContainer.contains(.offset)
        {
            self.offset = try decoderContainer.decode(Int?.self, forKey: .offset)
        }
    }
}
public extension OperateAuthorityQuery{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: OperateAuthorityQueryCodingKeys.self)
         try encoderContainer.encode(id, forKey: .id)
         try encoderContainer.encode(deptId, forKey: .deptId)
         try encoderContainer.encode(deptName, forKey: .deptName)
         try encoderContainer.encode(operatorValue, forKey: .operatorValue)
         try encoderContainer.encode(createTime, forKey: .createTime)
         try encoderContainer.encode(createUser, forKey: .createUser)
         try encoderContainer.encode(updateTime, forKey: .updateTime)
         try encoderContainer.encode(updateUser, forKey: .updateUser)
         try encoderContainer.encode(yn, forKey: .yn)
         try encoderContainer.encode(pageIndex, forKey: .pageIndex)
         try encoderContainer.encode(pageSize, forKey: .pageSize)
         try encoderContainer.encode(offset, forKey: .offset)
    }
}
///  returnItemDTO
public class ReturnItemDTO:NSObject,Codable{
    /// Id
    var id:Double?
    /// 项目编码
    var itemId:Int?
    /// 项目名称
    var itemName:String?
    /// 部门ID
    var deptId:Int?
    /// 部门名称
    var deptName:String?
    /// 渠道商类型
    var distributorType:Int?
    /// 返还类型
    var returnType:Int?
    /// 项目条件
    var conditionItem:String?
    /// 周期类型
    var circleType:Int?
    /// 周期名称
    var circleName:String?
    /// 说明
    var remark:String?
    /// 创建时间
    var createTime:String?
    /// 创建人
    var createUser:String?
    /// 修改时间
    var updateTime:String?
    /// 修改人
    var updateUser:String?
    /// 是否删除0未删除,1已删除
    var yn:Int?
    /// 项目名称
    var itemNameLike:String?



    public override init(){
            super.init()
    }

    enum ReturnItemDTOCodingKeys: String, CodingKey {
        case id
        case itemId
        case itemName
        case deptId
        case deptName
        case distributorType
        case returnType
        case conditionItem
        case circleType
        case circleName
        case remark
        case createTime
        case createUser
        case updateTime
        case updateUser
        case yn
        case itemNameLike
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: ReturnItemDTOCodingKeys.self)
        if decoderContainer.contains(.id)
        {
            self.id = try decoderContainer.decode(Double?.self, forKey: .id)
        }
        if decoderContainer.contains(.itemId)
        {
            self.itemId = try decoderContainer.decode(Int?.self, forKey: .itemId)
        }
        if decoderContainer.contains(.itemName)
        {
            self.itemName = try decoderContainer.decode(String?.self, forKey: .itemName)
        }
        if decoderContainer.contains(.deptId)
        {
            self.deptId = try decoderContainer.decode(Int?.self, forKey: .deptId)
        }
        if decoderContainer.contains(.deptName)
        {
            self.deptName = try decoderContainer.decode(String?.self, forKey: .deptName)
        }
        if decoderContainer.contains(.distributorType)
        {
            self.distributorType = try decoderContainer.decode(Int?.self, forKey: .distributorType)
        }
        if decoderContainer.contains(.returnType)
        {
            self.returnType = try decoderContainer.decode(Int?.self, forKey: .returnType)
        }
        if decoderContainer.contains(.conditionItem)
        {
            self.conditionItem = try decoderContainer.decode(String?.self, forKey: .conditionItem)
        }
        if decoderContainer.contains(.circleType)
        {
            self.circleType = try decoderContainer.decode(Int?.self, forKey: .circleType)
        }
        if decoderContainer.contains(.circleName)
        {
            self.circleName = try decoderContainer.decode(String?.self, forKey: .circleName)
        }
        if decoderContainer.contains(.remark)
        {
            self.remark = try decoderContainer.decode(String?.self, forKey: .remark)
        }
        if decoderContainer.contains(.createTime)
        {
            self.createTime = try decoderContainer.decode(String?.self, forKey: .createTime)
        }
        if decoderContainer.contains(.createUser)
        {
            self.createUser = try decoderContainer.decode(String?.self, forKey: .createUser)
        }
        if decoderContainer.contains(.updateTime)
        {
            self.updateTime = try decoderContainer.decode(String?.self, forKey: .updateTime)
        }
        if decoderContainer.contains(.updateUser)
        {
            self.updateUser = try decoderContainer.decode(String?.self, forKey: .updateUser)
        }
        if decoderContainer.contains(.yn)
        {
            self.yn = try decoderContainer.decode(Int?.self, forKey: .yn)
        }
        if decoderContainer.contains(.itemNameLike)
        {
            self.itemNameLike = try decoderContainer.decode(String?.self, forKey: .itemNameLike)
        }
    }
}
public extension ReturnItemDTO{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: ReturnItemDTOCodingKeys.self)
         try encoderContainer.encode(id, forKey: .id)
         try encoderContainer.encode(itemId, forKey: .itemId)
         try encoderContainer.encode(itemName, forKey: .itemName)
         try encoderContainer.encode(deptId, forKey: .deptId)
         try encoderContainer.encode(deptName, forKey: .deptName)
         try encoderContainer.encode(distributorType, forKey: .distributorType)
         try encoderContainer.encode(returnType, forKey: .returnType)
         try encoderContainer.encode(conditionItem, forKey: .conditionItem)
         try encoderContainer.encode(circleType, forKey: .circleType)
         try encoderContainer.encode(circleName, forKey: .circleName)
         try encoderContainer.encode(remark, forKey: .remark)
         try encoderContainer.encode(createTime, forKey: .createTime)
         try encoderContainer.encode(createUser, forKey: .createUser)
         try encoderContainer.encode(updateTime, forKey: .updateTime)
         try encoderContainer.encode(updateUser, forKey: .updateUser)
         try encoderContainer.encode(yn, forKey: .yn)
         try encoderContainer.encode(itemNameLike, forKey: .itemNameLike)
    }
}
///  returnItemQuery
public class ReturnItemQuery:NSObject,Codable{
    /// ID
    var id:Double?
    /// 项目编码
    var itemId:Int?
    /// 项目名称
    var itemName:String?
    /// 部门ID
    var deptId:Int?
    /// 部门名称
    var deptName:String?
    /// 渠道商类型
    var distributorType:Int?
    /// 返还类型
    var returnType:Int?
    /// 项目条件
    var conditionItem:String?
    /// 周期类型
    var circleType:Int?
    /// 周期名称
    var circleName:String?
    /// 说明
    var remark:String?
    /// 创建时间
    var createTime:String?
    /// 创建人
    var createUser:String?
    /// 修改时间
    var updateTime:String?
    /// 修改人
    var updateUser:String?
    /// 是否删除0未删除,1已删除
    var yn:Int?
    /// 项目名称
    var itemNameLike:String?
    /// 当前页序号
    var pageIndex:Int?
    /// 每页结果数量
    var pageSize:Int?
    /// Offset
    var offset:Int?



    public override init(){
            super.init()
    }

    enum ReturnItemQueryCodingKeys: String, CodingKey {
        case id
        case itemId
        case itemName
        case deptId
        case deptName
        case distributorType
        case returnType
        case conditionItem
        case circleType
        case circleName
        case remark
        case createTime
        case createUser
        case updateTime
        case updateUser
        case yn
        case itemNameLike
        case pageIndex
        case pageSize
        case offset
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: ReturnItemQueryCodingKeys.self)
        if decoderContainer.contains(.id)
        {
            self.id = try decoderContainer.decode(Double?.self, forKey: .id)
        }
        if decoderContainer.contains(.itemId)
        {
            self.itemId = try decoderContainer.decode(Int?.self, forKey: .itemId)
        }
        if decoderContainer.contains(.itemName)
        {
            self.itemName = try decoderContainer.decode(String?.self, forKey: .itemName)
        }
        if decoderContainer.contains(.deptId)
        {
            self.deptId = try decoderContainer.decode(Int?.self, forKey: .deptId)
        }
        if decoderContainer.contains(.deptName)
        {
            self.deptName = try decoderContainer.decode(String?.self, forKey: .deptName)
        }
        if decoderContainer.contains(.distributorType)
        {
            self.distributorType = try decoderContainer.decode(Int?.self, forKey: .distributorType)
        }
        if decoderContainer.contains(.returnType)
        {
            self.returnType = try decoderContainer.decode(Int?.self, forKey: .returnType)
        }
        if decoderContainer.contains(.conditionItem)
        {
            self.conditionItem = try decoderContainer.decode(String?.self, forKey: .conditionItem)
        }
        if decoderContainer.contains(.circleType)
        {
            self.circleType = try decoderContainer.decode(Int?.self, forKey: .circleType)
        }
        if decoderContainer.contains(.circleName)
        {
            self.circleName = try decoderContainer.decode(String?.self, forKey: .circleName)
        }
        if decoderContainer.contains(.remark)
        {
            self.remark = try decoderContainer.decode(String?.self, forKey: .remark)
        }
        if decoderContainer.contains(.createTime)
        {
            self.createTime = try decoderContainer.decode(String?.self, forKey: .createTime)
        }
        if decoderContainer.contains(.createUser)
        {
            self.createUser = try decoderContainer.decode(String?.self, forKey: .createUser)
        }
        if decoderContainer.contains(.updateTime)
        {
            self.updateTime = try decoderContainer.decode(String?.self, forKey: .updateTime)
        }
        if decoderContainer.contains(.updateUser)
        {
            self.updateUser = try decoderContainer.decode(String?.self, forKey: .updateUser)
        }
        if decoderContainer.contains(.yn)
        {
            self.yn = try decoderContainer.decode(Int?.self, forKey: .yn)
        }
        if decoderContainer.contains(.itemNameLike)
        {
            self.itemNameLike = try decoderContainer.decode(String?.self, forKey: .itemNameLike)
        }
        if decoderContainer.contains(.pageIndex)
        {
            self.pageIndex = try decoderContainer.decode(Int?.self, forKey: .pageIndex)
        }
        if decoderContainer.contains(.pageSize)
        {
            self.pageSize = try decoderContainer.decode(Int?.self, forKey: .pageSize)
        }
        if decoderContainer.contains(.offset)
        {
            self.offset = try decoderContainer.decode(Int?.self, forKey: .offset)
        }
    }
}
public extension ReturnItemQuery{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: ReturnItemQueryCodingKeys.self)
         try encoderContainer.encode(id, forKey: .id)
         try encoderContainer.encode(itemId, forKey: .itemId)
         try encoderContainer.encode(itemName, forKey: .itemName)
         try encoderContainer.encode(deptId, forKey: .deptId)
         try encoderContainer.encode(deptName, forKey: .deptName)
         try encoderContainer.encode(distributorType, forKey: .distributorType)
         try encoderContainer.encode(returnType, forKey: .returnType)
         try encoderContainer.encode(conditionItem, forKey: .conditionItem)
         try encoderContainer.encode(circleType, forKey: .circleType)
         try encoderContainer.encode(circleName, forKey: .circleName)
         try encoderContainer.encode(remark, forKey: .remark)
         try encoderContainer.encode(createTime, forKey: .createTime)
         try encoderContainer.encode(createUser, forKey: .createUser)
         try encoderContainer.encode(updateTime, forKey: .updateTime)
         try encoderContainer.encode(updateUser, forKey: .updateUser)
         try encoderContainer.encode(yn, forKey: .yn)
         try encoderContainer.encode(itemNameLike, forKey: .itemNameLike)
         try encoderContainer.encode(pageIndex, forKey: .pageIndex)
         try encoderContainer.encode(pageSize, forKey: .pageSize)
         try encoderContainer.encode(offset, forKey: .offset)
    }
}
///  returnItemResult
public class ReturnItemResult:NSObject,Codable{
    /// ID
    var id:Double?
    /// 项目编码
    var itemId:Int?
    /// 项目名称
    var itemName:String?
    /// 部门ID
    var deptId:Int?
    /// 部门名称
    var deptName:String?
    /// 渠道商类型
    var distributorType:Int?
    /// 渠道商类型名称
    var distributorTypeName:String?
    /// 返还类型
    var returnType:Int?
    /// 项目条件
    var conditionItem:String?
    /// 项目条件名称
    var conditionItemName:String?
    /// 周期类型
    var circleType:Int?
    /// 周期名称
    var circleName:String?
    /// 说明
    var remark:String?
    /// 使用标识（1在用，0未使用）
    var useFlag:String?
    /// 创建时间
    var createTime:String?
    /// 创建人
    var createUser:String?
    /// 修改时间
    var updateTime:String?
    /// 修改人
    var updateUser:String?
    /// 是否删除0未删除,1已删除
    var yn:Int?



    public override init(){
            super.init()
    }

    enum ReturnItemResultCodingKeys: String, CodingKey {
        case id
        case itemId
        case itemName
        case deptId
        case deptName
        case distributorType
        case distributorTypeName
        case returnType
        case conditionItem
        case conditionItemName
        case circleType
        case circleName
        case remark
        case useFlag
        case createTime
        case createUser
        case updateTime
        case updateUser
        case yn
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: ReturnItemResultCodingKeys.self)
        if decoderContainer.contains(.id)
        {
            self.id = try decoderContainer.decode(Double?.self, forKey: .id)
        }
        if decoderContainer.contains(.itemId)
        {
            self.itemId = try decoderContainer.decode(Int?.self, forKey: .itemId)
        }
        if decoderContainer.contains(.itemName)
        {
            self.itemName = try decoderContainer.decode(String?.self, forKey: .itemName)
        }
        if decoderContainer.contains(.deptId)
        {
            self.deptId = try decoderContainer.decode(Int?.self, forKey: .deptId)
        }
        if decoderContainer.contains(.deptName)
        {
            self.deptName = try decoderContainer.decode(String?.self, forKey: .deptName)
        }
        if decoderContainer.contains(.distributorType)
        {
            self.distributorType = try decoderContainer.decode(Int?.self, forKey: .distributorType)
        }
        if decoderContainer.contains(.distributorTypeName)
        {
            self.distributorTypeName = try decoderContainer.decode(String?.self, forKey: .distributorTypeName)
        }
        if decoderContainer.contains(.returnType)
        {
            self.returnType = try decoderContainer.decode(Int?.self, forKey: .returnType)
        }
        if decoderContainer.contains(.conditionItem)
        {
            self.conditionItem = try decoderContainer.decode(String?.self, forKey: .conditionItem)
        }
        if decoderContainer.contains(.conditionItemName)
        {
            self.conditionItemName = try decoderContainer.decode(String?.self, forKey: .conditionItemName)
        }
        if decoderContainer.contains(.circleType)
        {
            self.circleType = try decoderContainer.decode(Int?.self, forKey: .circleType)
        }
        if decoderContainer.contains(.circleName)
        {
            self.circleName = try decoderContainer.decode(String?.self, forKey: .circleName)
        }
        if decoderContainer.contains(.remark)
        {
            self.remark = try decoderContainer.decode(String?.self, forKey: .remark)
        }
        if decoderContainer.contains(.useFlag)
        {
            self.useFlag = try decoderContainer.decode(String?.self, forKey: .useFlag)
        }
        if decoderContainer.contains(.createTime)
        {
            self.createTime = try decoderContainer.decode(String?.self, forKey: .createTime)
        }
        if decoderContainer.contains(.createUser)
        {
            self.createUser = try decoderContainer.decode(String?.self, forKey: .createUser)
        }
        if decoderContainer.contains(.updateTime)
        {
            self.updateTime = try decoderContainer.decode(String?.self, forKey: .updateTime)
        }
        if decoderContainer.contains(.updateUser)
        {
            self.updateUser = try decoderContainer.decode(String?.self, forKey: .updateUser)
        }
        if decoderContainer.contains(.yn)
        {
            self.yn = try decoderContainer.decode(Int?.self, forKey: .yn)
        }
    }
}
public extension ReturnItemResult{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: ReturnItemResultCodingKeys.self)
         try encoderContainer.encode(id, forKey: .id)
         try encoderContainer.encode(itemId, forKey: .itemId)
         try encoderContainer.encode(itemName, forKey: .itemName)
         try encoderContainer.encode(deptId, forKey: .deptId)
         try encoderContainer.encode(deptName, forKey: .deptName)
         try encoderContainer.encode(distributorType, forKey: .distributorType)
         try encoderContainer.encode(distributorTypeName, forKey: .distributorTypeName)
         try encoderContainer.encode(returnType, forKey: .returnType)
         try encoderContainer.encode(conditionItem, forKey: .conditionItem)
         try encoderContainer.encode(conditionItemName, forKey: .conditionItemName)
         try encoderContainer.encode(circleType, forKey: .circleType)
         try encoderContainer.encode(circleName, forKey: .circleName)
         try encoderContainer.encode(remark, forKey: .remark)
         try encoderContainer.encode(useFlag, forKey: .useFlag)
         try encoderContainer.encode(createTime, forKey: .createTime)
         try encoderContainer.encode(createUser, forKey: .createUser)
         try encoderContainer.encode(updateTime, forKey: .updateTime)
         try encoderContainer.encode(updateUser, forKey: .updateUser)
         try encoderContainer.encode(yn, forKey: .yn)
    }
}
///  returnRuleQuery
public class ReturnRuleQuery:NSObject,Codable{
    /// ID
    var id:Double?
    /// 部门ID
    var deptId:Int?
    /// 部门名称
    var deptName:String?
    /// 渠道商类型
    var distributorType:Int?
    /// 是否返还标志
    var isReturn:Int?
    /// 周期类型
    var circleType:Int?
    /// 周期名称
    var circleName:String?
    /// 创建时间
    var createTime:String?
    /// 创建人
    var createUser:String?
    /// 修改时间
    var updateTime:String?
    /// 修改人
    var updateUser:String?
    /// 是否删除0未删除,1已删除
    var yn:Int?
    /// 当前页序号
    var pageIndex:Int?
    /// 每页结果数量
    var pageSize:Int?
    /// Offset
    var offset:Int?



    public override init(){
            super.init()
    }

    enum ReturnRuleQueryCodingKeys: String, CodingKey {
        case id
        case deptId
        case deptName
        case distributorType
        case isReturn
        case circleType
        case circleName
        case createTime
        case createUser
        case updateTime
        case updateUser
        case yn
        case pageIndex
        case pageSize
        case offset
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: ReturnRuleQueryCodingKeys.self)
        if decoderContainer.contains(.id)
        {
            self.id = try decoderContainer.decode(Double?.self, forKey: .id)
        }
        if decoderContainer.contains(.deptId)
        {
            self.deptId = try decoderContainer.decode(Int?.self, forKey: .deptId)
        }
        if decoderContainer.contains(.deptName)
        {
            self.deptName = try decoderContainer.decode(String?.self, forKey: .deptName)
        }
        if decoderContainer.contains(.distributorType)
        {
            self.distributorType = try decoderContainer.decode(Int?.self, forKey: .distributorType)
        }
        if decoderContainer.contains(.isReturn)
        {
            self.isReturn = try decoderContainer.decode(Int?.self, forKey: .isReturn)
        }
        if decoderContainer.contains(.circleType)
        {
            self.circleType = try decoderContainer.decode(Int?.self, forKey: .circleType)
        }
        if decoderContainer.contains(.circleName)
        {
            self.circleName = try decoderContainer.decode(String?.self, forKey: .circleName)
        }
        if decoderContainer.contains(.createTime)
        {
            self.createTime = try decoderContainer.decode(String?.self, forKey: .createTime)
        }
        if decoderContainer.contains(.createUser)
        {
            self.createUser = try decoderContainer.decode(String?.self, forKey: .createUser)
        }
        if decoderContainer.contains(.updateTime)
        {
            self.updateTime = try decoderContainer.decode(String?.self, forKey: .updateTime)
        }
        if decoderContainer.contains(.updateUser)
        {
            self.updateUser = try decoderContainer.decode(String?.self, forKey: .updateUser)
        }
        if decoderContainer.contains(.yn)
        {
            self.yn = try decoderContainer.decode(Int?.self, forKey: .yn)
        }
        if decoderContainer.contains(.pageIndex)
        {
            self.pageIndex = try decoderContainer.decode(Int?.self, forKey: .pageIndex)
        }
        if decoderContainer.contains(.pageSize)
        {
            self.pageSize = try decoderContainer.decode(Int?.self, forKey: .pageSize)
        }
        if decoderContainer.contains(.offset)
        {
            self.offset = try decoderContainer.decode(Int?.self, forKey: .offset)
        }
    }
}
public extension ReturnRuleQuery{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: ReturnRuleQueryCodingKeys.self)
         try encoderContainer.encode(id, forKey: .id)
         try encoderContainer.encode(deptId, forKey: .deptId)
         try encoderContainer.encode(deptName, forKey: .deptName)
         try encoderContainer.encode(distributorType, forKey: .distributorType)
         try encoderContainer.encode(isReturn, forKey: .isReturn)
         try encoderContainer.encode(circleType, forKey: .circleType)
         try encoderContainer.encode(circleName, forKey: .circleName)
         try encoderContainer.encode(createTime, forKey: .createTime)
         try encoderContainer.encode(createUser, forKey: .createUser)
         try encoderContainer.encode(updateTime, forKey: .updateTime)
         try encoderContainer.encode(updateUser, forKey: .updateUser)
         try encoderContainer.encode(yn, forKey: .yn)
         try encoderContainer.encode(pageIndex, forKey: .pageIndex)
         try encoderContainer.encode(pageSize, forKey: .pageSize)
         try encoderContainer.encode(offset, forKey: .offset)
    }
}
///  returnRuleDTO
public class ReturnRuleDTO:NSObject,Codable{
    /// ID
    var id:Double?
    /// 部门ID
    var deptId:Int?
    /// 部门名称
    var deptName:String?
    /// 渠道商类型
    var distributorType:Int?
    /// 是否返还标志
    var isReturn:Int?
    /// 周期类型
    var circleType:Int?
    /// 周期名称
    var circleName:String?
    /// 创建时间
    var createTime:String?
    /// 创建人
    var createUser:String?
    /// 修改时间
    var updateTime:String?
    /// 修改人
    var updateUser:String?
    /// 是否删除0未删除,1已删除
    var yn:Int?



    public override init(){
            super.init()
    }

    enum ReturnRuleDTOCodingKeys: String, CodingKey {
        case id
        case deptId
        case deptName
        case distributorType
        case isReturn
        case circleType
        case circleName
        case createTime
        case createUser
        case updateTime
        case updateUser
        case yn
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: ReturnRuleDTOCodingKeys.self)
        if decoderContainer.contains(.id)
        {
            self.id = try decoderContainer.decode(Double?.self, forKey: .id)
        }
        if decoderContainer.contains(.deptId)
        {
            self.deptId = try decoderContainer.decode(Int?.self, forKey: .deptId)
        }
        if decoderContainer.contains(.deptName)
        {
            self.deptName = try decoderContainer.decode(String?.self, forKey: .deptName)
        }
        if decoderContainer.contains(.distributorType)
        {
            self.distributorType = try decoderContainer.decode(Int?.self, forKey: .distributorType)
        }
        if decoderContainer.contains(.isReturn)
        {
            self.isReturn = try decoderContainer.decode(Int?.self, forKey: .isReturn)
        }
        if decoderContainer.contains(.circleType)
        {
            self.circleType = try decoderContainer.decode(Int?.self, forKey: .circleType)
        }
        if decoderContainer.contains(.circleName)
        {
            self.circleName = try decoderContainer.decode(String?.self, forKey: .circleName)
        }
        if decoderContainer.contains(.createTime)
        {
            self.createTime = try decoderContainer.decode(String?.self, forKey: .createTime)
        }
        if decoderContainer.contains(.createUser)
        {
            self.createUser = try decoderContainer.decode(String?.self, forKey: .createUser)
        }
        if decoderContainer.contains(.updateTime)
        {
            self.updateTime = try decoderContainer.decode(String?.self, forKey: .updateTime)
        }
        if decoderContainer.contains(.updateUser)
        {
            self.updateUser = try decoderContainer.decode(String?.self, forKey: .updateUser)
        }
        if decoderContainer.contains(.yn)
        {
            self.yn = try decoderContainer.decode(Int?.self, forKey: .yn)
        }
    }
}
public extension ReturnRuleDTO{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: ReturnRuleDTOCodingKeys.self)
         try encoderContainer.encode(id, forKey: .id)
         try encoderContainer.encode(deptId, forKey: .deptId)
         try encoderContainer.encode(deptName, forKey: .deptName)
         try encoderContainer.encode(distributorType, forKey: .distributorType)
         try encoderContainer.encode(isReturn, forKey: .isReturn)
         try encoderContainer.encode(circleType, forKey: .circleType)
         try encoderContainer.encode(circleName, forKey: .circleName)
         try encoderContainer.encode(createTime, forKey: .createTime)
         try encoderContainer.encode(createUser, forKey: .createUser)
         try encoderContainer.encode(updateTime, forKey: .updateTime)
         try encoderContainer.encode(updateUser, forKey: .updateUser)
         try encoderContainer.encode(yn, forKey: .yn)
    }
}
///  returnRuleResult
public class ReturnRuleResult:NSObject,Codable{
    /// ID
    var id:Double?
    /// 部门ID
    var deptId:Int?
    /// 部门名称
    var deptName:String?
    /// 渠道商类型
    var distributorType:Int?
    /// 渠道商类型名称
    var distributorTypeName:String?
    /// 是否返还标志
    var isReturn:Int?
    /// 周期类型
    var circleType:Int?
    /// 周期名称
    var circleName:String?
    /// 创建时间
    var createTime:String?
    /// 创建人
    var createUser:String?
    /// 修改时间
    var updateTime:String?
    /// 修改人
    var updateUser:String?
    /// 是否删除0未删除,1已删除
    var yn:Int?



    public override init(){
            super.init()
    }

    enum ReturnRuleResultCodingKeys: String, CodingKey {
        case id
        case deptId
        case deptName
        case distributorType
        case distributorTypeName
        case isReturn
        case circleType
        case circleName
        case createTime
        case createUser
        case updateTime
        case updateUser
        case yn
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: ReturnRuleResultCodingKeys.self)
        if decoderContainer.contains(.id)
        {
            self.id = try decoderContainer.decode(Double?.self, forKey: .id)
        }
        if decoderContainer.contains(.deptId)
        {
            self.deptId = try decoderContainer.decode(Int?.self, forKey: .deptId)
        }
        if decoderContainer.contains(.deptName)
        {
            self.deptName = try decoderContainer.decode(String?.self, forKey: .deptName)
        }
        if decoderContainer.contains(.distributorType)
        {
            self.distributorType = try decoderContainer.decode(Int?.self, forKey: .distributorType)
        }
        if decoderContainer.contains(.distributorTypeName)
        {
            self.distributorTypeName = try decoderContainer.decode(String?.self, forKey: .distributorTypeName)
        }
        if decoderContainer.contains(.isReturn)
        {
            self.isReturn = try decoderContainer.decode(Int?.self, forKey: .isReturn)
        }
        if decoderContainer.contains(.circleType)
        {
            self.circleType = try decoderContainer.decode(Int?.self, forKey: .circleType)
        }
        if decoderContainer.contains(.circleName)
        {
            self.circleName = try decoderContainer.decode(String?.self, forKey: .circleName)
        }
        if decoderContainer.contains(.createTime)
        {
            self.createTime = try decoderContainer.decode(String?.self, forKey: .createTime)
        }
        if decoderContainer.contains(.createUser)
        {
            self.createUser = try decoderContainer.decode(String?.self, forKey: .createUser)
        }
        if decoderContainer.contains(.updateTime)
        {
            self.updateTime = try decoderContainer.decode(String?.self, forKey: .updateTime)
        }
        if decoderContainer.contains(.updateUser)
        {
            self.updateUser = try decoderContainer.decode(String?.self, forKey: .updateUser)
        }
        if decoderContainer.contains(.yn)
        {
            self.yn = try decoderContainer.decode(Int?.self, forKey: .yn)
        }
    }
}
public extension ReturnRuleResult{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: ReturnRuleResultCodingKeys.self)
         try encoderContainer.encode(id, forKey: .id)
         try encoderContainer.encode(deptId, forKey: .deptId)
         try encoderContainer.encode(deptName, forKey: .deptName)
         try encoderContainer.encode(distributorType, forKey: .distributorType)
         try encoderContainer.encode(distributorTypeName, forKey: .distributorTypeName)
         try encoderContainer.encode(isReturn, forKey: .isReturn)
         try encoderContainer.encode(circleType, forKey: .circleType)
         try encoderContainer.encode(circleName, forKey: .circleName)
         try encoderContainer.encode(createTime, forKey: .createTime)
         try encoderContainer.encode(createUser, forKey: .createUser)
         try encoderContainer.encode(updateTime, forKey: .updateTime)
         try encoderContainer.encode(updateUser, forKey: .updateUser)
         try encoderContainer.encode(yn, forKey: .yn)
    }
}
///  distributor
public class Distributor:NSObject,Codable{
    /// 渠道商ID
    var distributorId:String?
    /// 渠道商名称
    var distributorName:String?
    /// 京东云账户
    var pin:String?
    /// 合同编号
    var contractNo:String?
    /// 营业执照号
    var businessLicense:String?
    /// 法定代表人
    var legalRepresentative:String?
    /// 营业执照图片
    var businessLicensePic:String?
    /// 主营业务描述
    var businessDesc:String?
    /// 办公地址
    var workAddress:String?
    /// 联系人姓名
    var contracter:String?
    /// 联系人电话
    var tel:String?
    /// 邮箱
    var email:String?
    /// 所属地域
    var region:String?
    /// 入驻日期(一级渠道商手工录入、二级渠道商审批通过日期)
    var settleTime:String?
    /// 状态(0 审批中、2驳回、1 已入驻、3已停止合作)
    var status:Int?
    /// 驳回原因
    var reason:String?
    /// 级次(0一级、1 二级)
    var distributorLevel:Int?
    /// 渠道商类型(0合作伙伴、1 渠道代理)
    var distributorType:Int?
    /// 上级渠道商ID
    var parentDistributorId:String?
    /// 所属部门(0企业线、1政府线)
    var dept:Int?
    /// 京东云负责人(京东云人员erp或名称)
    var erp:String?



    public override init(){
            super.init()
    }

    enum DistributorCodingKeys: String, CodingKey {
        case distributorId
        case distributorName
        case pin
        case contractNo
        case businessLicense
        case legalRepresentative
        case businessLicensePic
        case businessDesc
        case workAddress
        case contracter
        case tel
        case email
        case region
        case settleTime
        case status
        case reason
        case distributorLevel
        case distributorType
        case parentDistributorId
        case dept
        case erp
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: DistributorCodingKeys.self)
        if decoderContainer.contains(.distributorId)
        {
            self.distributorId = try decoderContainer.decode(String?.self, forKey: .distributorId)
        }
        if decoderContainer.contains(.distributorName)
        {
            self.distributorName = try decoderContainer.decode(String?.self, forKey: .distributorName)
        }
        if decoderContainer.contains(.pin)
        {
            self.pin = try decoderContainer.decode(String?.self, forKey: .pin)
        }
        if decoderContainer.contains(.contractNo)
        {
            self.contractNo = try decoderContainer.decode(String?.self, forKey: .contractNo)
        }
        if decoderContainer.contains(.businessLicense)
        {
            self.businessLicense = try decoderContainer.decode(String?.self, forKey: .businessLicense)
        }
        if decoderContainer.contains(.legalRepresentative)
        {
            self.legalRepresentative = try decoderContainer.decode(String?.self, forKey: .legalRepresentative)
        }
        if decoderContainer.contains(.businessLicensePic)
        {
            self.businessLicensePic = try decoderContainer.decode(String?.self, forKey: .businessLicensePic)
        }
        if decoderContainer.contains(.businessDesc)
        {
            self.businessDesc = try decoderContainer.decode(String?.self, forKey: .businessDesc)
        }
        if decoderContainer.contains(.workAddress)
        {
            self.workAddress = try decoderContainer.decode(String?.self, forKey: .workAddress)
        }
        if decoderContainer.contains(.contracter)
        {
            self.contracter = try decoderContainer.decode(String?.self, forKey: .contracter)
        }
        if decoderContainer.contains(.tel)
        {
            self.tel = try decoderContainer.decode(String?.self, forKey: .tel)
        }
        if decoderContainer.contains(.email)
        {
            self.email = try decoderContainer.decode(String?.self, forKey: .email)
        }
        if decoderContainer.contains(.region)
        {
            self.region = try decoderContainer.decode(String?.self, forKey: .region)
        }
        if decoderContainer.contains(.settleTime)
        {
            self.settleTime = try decoderContainer.decode(String?.self, forKey: .settleTime)
        }
        if decoderContainer.contains(.status)
        {
            self.status = try decoderContainer.decode(Int?.self, forKey: .status)
        }
        if decoderContainer.contains(.reason)
        {
            self.reason = try decoderContainer.decode(String?.self, forKey: .reason)
        }
        if decoderContainer.contains(.distributorLevel)
        {
            self.distributorLevel = try decoderContainer.decode(Int?.self, forKey: .distributorLevel)
        }
        if decoderContainer.contains(.distributorType)
        {
            self.distributorType = try decoderContainer.decode(Int?.self, forKey: .distributorType)
        }
        if decoderContainer.contains(.parentDistributorId)
        {
            self.parentDistributorId = try decoderContainer.decode(String?.self, forKey: .parentDistributorId)
        }
        if decoderContainer.contains(.dept)
        {
            self.dept = try decoderContainer.decode(Int?.self, forKey: .dept)
        }
        if decoderContainer.contains(.erp)
        {
            self.erp = try decoderContainer.decode(String?.self, forKey: .erp)
        }
    }
}
public extension Distributor{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: DistributorCodingKeys.self)
         try encoderContainer.encode(distributorId, forKey: .distributorId)
         try encoderContainer.encode(distributorName, forKey: .distributorName)
         try encoderContainer.encode(pin, forKey: .pin)
         try encoderContainer.encode(contractNo, forKey: .contractNo)
         try encoderContainer.encode(businessLicense, forKey: .businessLicense)
         try encoderContainer.encode(legalRepresentative, forKey: .legalRepresentative)
         try encoderContainer.encode(businessLicensePic, forKey: .businessLicensePic)
         try encoderContainer.encode(businessDesc, forKey: .businessDesc)
         try encoderContainer.encode(workAddress, forKey: .workAddress)
         try encoderContainer.encode(contracter, forKey: .contracter)
         try encoderContainer.encode(tel, forKey: .tel)
         try encoderContainer.encode(email, forKey: .email)
         try encoderContainer.encode(region, forKey: .region)
         try encoderContainer.encode(settleTime, forKey: .settleTime)
         try encoderContainer.encode(status, forKey: .status)
         try encoderContainer.encode(reason, forKey: .reason)
         try encoderContainer.encode(distributorLevel, forKey: .distributorLevel)
         try encoderContainer.encode(distributorType, forKey: .distributorType)
         try encoderContainer.encode(parentDistributorId, forKey: .parentDistributorId)
         try encoderContainer.encode(dept, forKey: .dept)
         try encoderContainer.encode(erp, forKey: .erp)
    }
}

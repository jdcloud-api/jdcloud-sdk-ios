/* Copyright 2018 JDCLOUD.COM

   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at

     http:#www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.

   统计查询类接口
   Openapi For JCLOUD cdn

   OpenAPI spec version: v1
   Contact: pid-cdn@jd.com

   NOTE: This class is auto generated by the jdcloud code generator program.
 */


import Foundation
///  domainlogModel
public class DomainlogModel:NSObject,Codable{
    /// 日志下载url地址
    var logUrl:String?
    /// 日志大小，单位：Byte（字节）
    var logSize:Int64?
    /// 日志开始时间，格式：yyyy-MM-dd HH:ss，如：2019-04-12 00:00
    var startTime:String?
    /// 日志结束时间，格式：yyyy-MM-dd HH:ss 如：2019-04-12 00:05
    var endTime:String?
    /// MD5值
    var md5:String?



    public override init(){
            super.init()
    }

    enum DomainlogModelCodingKeys: String, CodingKey {
        case logUrl
        case logSize
        case startTime
        case endTime
        case md5
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: DomainlogModelCodingKeys.self)
        if decoderContainer.contains(.logUrl)
        {
            self.logUrl = try decoderContainer.decode(String?.self, forKey: .logUrl)
        }
        if decoderContainer.contains(.logSize)
        {
            self.logSize = try decoderContainer.decode(Int64?.self, forKey: .logSize)
        }
        if decoderContainer.contains(.startTime)
        {
            self.startTime = try decoderContainer.decode(String?.self, forKey: .startTime)
        }
        if decoderContainer.contains(.endTime)
        {
            self.endTime = try decoderContainer.decode(String?.self, forKey: .endTime)
        }
        if decoderContainer.contains(.md5)
        {
            self.md5 = try decoderContainer.decode(String?.self, forKey: .md5)
        }
    }
}
public extension DomainlogModel{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: DomainlogModelCodingKeys.self)
         try encoderContainer.encode(logUrl, forKey: .logUrl)
         try encoderContainer.encode(logSize, forKey: .logSize)
         try encoderContainer.encode(startTime, forKey: .startTime)
         try encoderContainer.encode(endTime, forKey: .endTime)
         try encoderContainer.encode(md5, forKey: .md5)
    }
}
///  accessUserlogModel
public class AccessUserlogModel:NSObject,Codable{
    /// 域名
    var domain:String?
    /// 日志对象
    var urls:[DomainlogModel?]?



    public override init(){
            super.init()
    }

    enum AccessUserlogModelCodingKeys: String, CodingKey {
        case domain
        case urls
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: AccessUserlogModelCodingKeys.self)
        if decoderContainer.contains(.domain)
        {
            self.domain = try decoderContainer.decode(String?.self, forKey: .domain)
        }
        if decoderContainer.contains(.urls)
        {
            self.urls = try decoderContainer.decode([DomainlogModel?]?.self, forKey: .urls)
        }
    }
}
public extension AccessUserlogModel{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: AccessUserlogModelCodingKeys.self)
         try encoderContainer.encode(domain, forKey: .domain)
         try encoderContainer.encode(urls, forKey: .urls)
    }
}
///  userLogInfoModel
public class UserLogInfoModel:NSObject,Codable{
    /// 日志上传域名，如：www.a.com
    var domain:String?
    /// 日志上传全路径，如：cdnuserlog/www.a.com/20190412/2019041200-01.gz
    var logFileFullPath:String?
    /// 日志粒度：fiveMin(五分钟粒度),hour(一小时粒度),day(一天粒度)
    var interval:String?
    /// 日志类型：gz,log,zip
    var logType:String?
    /// 日志大小，单位：Byte（字节）
    var logSize:Int64?
    /// MD5值
    var logMD5:String?
    /// 日志开始时间，格式：yyyy-MM-dd HH:ss，如：2019-04-12 00:00
    var startTime:String?
    /// 日志结束时间，格式：yyyy-MM-dd HH:ss 如：2019-04-12 00:05
    var endTime:String?



    public override init(){
            super.init()
    }

    enum UserLogInfoModelCodingKeys: String, CodingKey {
        case domain
        case logFileFullPath
        case interval
        case logType
        case logSize
        case logMD5
        case startTime
        case endTime
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: UserLogInfoModelCodingKeys.self)
        if decoderContainer.contains(.domain)
        {
            self.domain = try decoderContainer.decode(String?.self, forKey: .domain)
        }
        if decoderContainer.contains(.logFileFullPath)
        {
            self.logFileFullPath = try decoderContainer.decode(String?.self, forKey: .logFileFullPath)
        }
        if decoderContainer.contains(.interval)
        {
            self.interval = try decoderContainer.decode(String?.self, forKey: .interval)
        }
        if decoderContainer.contains(.logType)
        {
            self.logType = try decoderContainer.decode(String?.self, forKey: .logType)
        }
        if decoderContainer.contains(.logSize)
        {
            self.logSize = try decoderContainer.decode(Int64?.self, forKey: .logSize)
        }
        if decoderContainer.contains(.logMD5)
        {
            self.logMD5 = try decoderContainer.decode(String?.self, forKey: .logMD5)
        }
        if decoderContainer.contains(.startTime)
        {
            self.startTime = try decoderContainer.decode(String?.self, forKey: .startTime)
        }
        if decoderContainer.contains(.endTime)
        {
            self.endTime = try decoderContainer.decode(String?.self, forKey: .endTime)
        }
    }
}
public extension UserLogInfoModel{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: UserLogInfoModelCodingKeys.self)
         try encoderContainer.encode(domain, forKey: .domain)
         try encoderContainer.encode(logFileFullPath, forKey: .logFileFullPath)
         try encoderContainer.encode(interval, forKey: .interval)
         try encoderContainer.encode(logType, forKey: .logType)
         try encoderContainer.encode(logSize, forKey: .logSize)
         try encoderContainer.encode(logMD5, forKey: .logMD5)
         try encoderContainer.encode(startTime, forKey: .startTime)
         try encoderContainer.encode(endTime, forKey: .endTime)
    }
}
///  deleteStream
public class DeleteStream:NSObject,Codable{
    /// 禁播流
    var stream:String?
    /// 封禁推流的app
    var app:String?
    /// PublishIp
    var publishIp:String?



    public override init(){
            super.init()
    }

    enum DeleteStreamCodingKeys: String, CodingKey {
        case stream
        case app
        case publishIp
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: DeleteStreamCodingKeys.self)
        if decoderContainer.contains(.stream)
        {
            self.stream = try decoderContainer.decode(String?.self, forKey: .stream)
        }
        if decoderContainer.contains(.app)
        {
            self.app = try decoderContainer.decode(String?.self, forKey: .app)
        }
        if decoderContainer.contains(.publishIp)
        {
            self.publishIp = try decoderContainer.decode(String?.self, forKey: .publishIp)
        }
    }
}
public extension DeleteStream{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: DeleteStreamCodingKeys.self)
         try encoderContainer.encode(stream, forKey: .stream)
         try encoderContainer.encode(app, forKey: .app)
         try encoderContainer.encode(publishIp, forKey: .publishIp)
    }
}
///  forbiddenStream
public class ForbiddenStream:NSObject,Codable{
    /// 禁播流
    var stream:String?
    /// 封禁推流的app
    var app:String?
    /// 禁播Ip
    var publishIp:String?
    /// 禁播类型:forever永不禁播limit限时禁播stop剔流
    var forbiddenType:String?
    /// 禁播时长
    var ttl:Int64?
    /// 禁播类型说明
    var forbiddenTypeDesc:String?
    /// 开始禁播时间
    var startTime:String?
    /// 结束禁播时间
    var endTime:String?



    public override init(){
            super.init()
    }

    enum ForbiddenStreamCodingKeys: String, CodingKey {
        case stream
        case app
        case publishIp
        case forbiddenType
        case ttl
        case forbiddenTypeDesc
        case startTime
        case endTime
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: ForbiddenStreamCodingKeys.self)
        if decoderContainer.contains(.stream)
        {
            self.stream = try decoderContainer.decode(String?.self, forKey: .stream)
        }
        if decoderContainer.contains(.app)
        {
            self.app = try decoderContainer.decode(String?.self, forKey: .app)
        }
        if decoderContainer.contains(.publishIp)
        {
            self.publishIp = try decoderContainer.decode(String?.self, forKey: .publishIp)
        }
        if decoderContainer.contains(.forbiddenType)
        {
            self.forbiddenType = try decoderContainer.decode(String?.self, forKey: .forbiddenType)
        }
        if decoderContainer.contains(.ttl)
        {
            self.ttl = try decoderContainer.decode(Int64?.self, forKey: .ttl)
        }
        if decoderContainer.contains(.forbiddenTypeDesc)
        {
            self.forbiddenTypeDesc = try decoderContainer.decode(String?.self, forKey: .forbiddenTypeDesc)
        }
        if decoderContainer.contains(.startTime)
        {
            self.startTime = try decoderContainer.decode(String?.self, forKey: .startTime)
        }
        if decoderContainer.contains(.endTime)
        {
            self.endTime = try decoderContainer.decode(String?.self, forKey: .endTime)
        }
    }
}
public extension ForbiddenStream{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: ForbiddenStreamCodingKeys.self)
         try encoderContainer.encode(stream, forKey: .stream)
         try encoderContainer.encode(app, forKey: .app)
         try encoderContainer.encode(publishIp, forKey: .publishIp)
         try encoderContainer.encode(forbiddenType, forKey: .forbiddenType)
         try encoderContainer.encode(ttl, forKey: .ttl)
         try encoderContainer.encode(forbiddenTypeDesc, forKey: .forbiddenTypeDesc)
         try encoderContainer.encode(startTime, forKey: .startTime)
         try encoderContainer.encode(endTime, forKey: .endTime)
    }
}
///  domainSourceInfo
public class DomainSourceInfo:NSObject,Codable{
    /// 优先级（1-10）
    var priority:Int?
    /// 回源host
    var sourceHost:String?
    /// 回源域名
    var domain:String?



    public override init(){
            super.init()
    }

    enum DomainSourceInfoCodingKeys: String, CodingKey {
        case priority
        case sourceHost
        case domain
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: DomainSourceInfoCodingKeys.self)
        if decoderContainer.contains(.priority)
        {
            self.priority = try decoderContainer.decode(Int?.self, forKey: .priority)
        }
        if decoderContainer.contains(.sourceHost)
        {
            self.sourceHost = try decoderContainer.decode(String?.self, forKey: .sourceHost)
        }
        if decoderContainer.contains(.domain)
        {
            self.domain = try decoderContainer.decode(String?.self, forKey: .domain)
        }
    }
}
public extension DomainSourceInfo{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: DomainSourceInfoCodingKeys.self)
         try encoderContainer.encode(priority, forKey: .priority)
         try encoderContainer.encode(sourceHost, forKey: .sourceHost)
         try encoderContainer.encode(domain, forKey: .domain)
    }
}
///  forbiddenStreamHistoryItem
public class ForbiddenStreamHistoryItem:NSObject,Codable{
    /// 禁播流
    var stream:String?
    /// 封禁推流的app
    var app:String?
    /// 封禁的IP
    var publishIp:String?
    /// 禁播类型:forever永不禁播limit限时禁播
    var forbiddenType:String?
    /// 禁播时长
    var ttl:Int64?
    /// 开始禁播时间
    var startTime:String?
    /// 结束禁播时间
    var endTime:String?
    /// 禁播类型说明
    var forbiddenTypeDesc:String?



    public override init(){
            super.init()
    }

    enum ForbiddenStreamHistoryItemCodingKeys: String, CodingKey {
        case stream
        case app
        case publishIp
        case forbiddenType
        case ttl
        case startTime
        case endTime
        case forbiddenTypeDesc
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: ForbiddenStreamHistoryItemCodingKeys.self)
        if decoderContainer.contains(.stream)
        {
            self.stream = try decoderContainer.decode(String?.self, forKey: .stream)
        }
        if decoderContainer.contains(.app)
        {
            self.app = try decoderContainer.decode(String?.self, forKey: .app)
        }
        if decoderContainer.contains(.publishIp)
        {
            self.publishIp = try decoderContainer.decode(String?.self, forKey: .publishIp)
        }
        if decoderContainer.contains(.forbiddenType)
        {
            self.forbiddenType = try decoderContainer.decode(String?.self, forKey: .forbiddenType)
        }
        if decoderContainer.contains(.ttl)
        {
            self.ttl = try decoderContainer.decode(Int64?.self, forKey: .ttl)
        }
        if decoderContainer.contains(.startTime)
        {
            self.startTime = try decoderContainer.decode(String?.self, forKey: .startTime)
        }
        if decoderContainer.contains(.endTime)
        {
            self.endTime = try decoderContainer.decode(String?.self, forKey: .endTime)
        }
        if decoderContainer.contains(.forbiddenTypeDesc)
        {
            self.forbiddenTypeDesc = try decoderContainer.decode(String?.self, forKey: .forbiddenTypeDesc)
        }
    }
}
public extension ForbiddenStreamHistoryItem{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: ForbiddenStreamHistoryItemCodingKeys.self)
         try encoderContainer.encode(stream, forKey: .stream)
         try encoderContainer.encode(app, forKey: .app)
         try encoderContainer.encode(publishIp, forKey: .publishIp)
         try encoderContainer.encode(forbiddenType, forKey: .forbiddenType)
         try encoderContainer.encode(ttl, forKey: .ttl)
         try encoderContainer.encode(startTime, forKey: .startTime)
         try encoderContainer.encode(endTime, forKey: .endTime)
         try encoderContainer.encode(forbiddenTypeDesc, forKey: .forbiddenTypeDesc)
    }
}
///  pushStreamInfoItem
public class PushStreamInfoItem:NSObject,Codable{
    /// App
    var app:String?
    /// Stream
    var stream:String?
    /// ClientIp
    var clientIp:String?
    /// NodeIp
    var nodeIp:String?
    /// 任务创建时间,UTC时间
    var startTime:String?
    /// 任务创建时间,UTC时间
    var endTime:String?
    /// Duration
    var duration:Int64?



    public override init(){
            super.init()
    }

    enum PushStreamInfoItemCodingKeys: String, CodingKey {
        case app
        case stream
        case clientIp
        case nodeIp
        case startTime
        case endTime
        case duration
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: PushStreamInfoItemCodingKeys.self)
        if decoderContainer.contains(.app)
        {
            self.app = try decoderContainer.decode(String?.self, forKey: .app)
        }
        if decoderContainer.contains(.stream)
        {
            self.stream = try decoderContainer.decode(String?.self, forKey: .stream)
        }
        if decoderContainer.contains(.clientIp)
        {
            self.clientIp = try decoderContainer.decode(String?.self, forKey: .clientIp)
        }
        if decoderContainer.contains(.nodeIp)
        {
            self.nodeIp = try decoderContainer.decode(String?.self, forKey: .nodeIp)
        }
        if decoderContainer.contains(.startTime)
        {
            self.startTime = try decoderContainer.decode(String?.self, forKey: .startTime)
        }
        if decoderContainer.contains(.endTime)
        {
            self.endTime = try decoderContainer.decode(String?.self, forKey: .endTime)
        }
        if decoderContainer.contains(.duration)
        {
            self.duration = try decoderContainer.decode(Int64?.self, forKey: .duration)
        }
    }
}
public extension PushStreamInfoItem{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: PushStreamInfoItemCodingKeys.self)
         try encoderContainer.encode(app, forKey: .app)
         try encoderContainer.encode(stream, forKey: .stream)
         try encoderContainer.encode(clientIp, forKey: .clientIp)
         try encoderContainer.encode(nodeIp, forKey: .nodeIp)
         try encoderContainer.encode(startTime, forKey: .startTime)
         try encoderContainer.encode(endTime, forKey: .endTime)
         try encoderContainer.encode(duration, forKey: .duration)
    }
}
///  protocolConvert
public class ProtocolConvert:NSObject,Codable{
    /// 源协议,目前只能为rtmp
    var sourceProtocol:String?
    /// 目标协议
    var targetProtocol:String?



    public override init(){
            super.init()
    }

    enum ProtocolConvertCodingKeys: String, CodingKey {
        case sourceProtocol
        case targetProtocol
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: ProtocolConvertCodingKeys.self)
        if decoderContainer.contains(.sourceProtocol)
        {
            self.sourceProtocol = try decoderContainer.decode(String?.self, forKey: .sourceProtocol)
        }
        if decoderContainer.contains(.targetProtocol)
        {
            self.targetProtocol = try decoderContainer.decode(String?.self, forKey: .targetProtocol)
        }
    }
}
public extension ProtocolConvert{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: ProtocolConvertCodingKeys.self)
         try encoderContainer.encode(sourceProtocol, forKey: .sourceProtocol)
         try encoderContainer.encode(targetProtocol, forKey: .targetProtocol)
    }
}
///  onlineStreamInfo
public class OnlineStreamInfo:NSObject,Codable{
    /// App
    var app:String?
    /// Stream
    var stream:String?
    /// ClientIp
    var clientIp:String?
    /// ServerIp
    var serverIp:String?
    /// FrameRate
    var frameRate:Double?
    /// FrameLossRate
    var frameLossRate:Double?
    /// LastActive
    var lastActive:Int64?
    /// RealFps
    var realFps:Double?
    /// UploadSpeed
    var uploadSpeed:Int64?
    /// VideoCodecId
    var videoCodecId:Int64?
    /// VideoDataRate
    var videoDataRate:Int64?
    /// AudioCodecId
    var audioCodecId:Int64?



    public override init(){
            super.init()
    }

    enum OnlineStreamInfoCodingKeys: String, CodingKey {
        case app
        case stream
        case clientIp
        case serverIp
        case frameRate
        case frameLossRate
        case lastActive
        case realFps
        case uploadSpeed
        case videoCodecId
        case videoDataRate
        case audioCodecId
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: OnlineStreamInfoCodingKeys.self)
        if decoderContainer.contains(.app)
        {
            self.app = try decoderContainer.decode(String?.self, forKey: .app)
        }
        if decoderContainer.contains(.stream)
        {
            self.stream = try decoderContainer.decode(String?.self, forKey: .stream)
        }
        if decoderContainer.contains(.clientIp)
        {
            self.clientIp = try decoderContainer.decode(String?.self, forKey: .clientIp)
        }
        if decoderContainer.contains(.serverIp)
        {
            self.serverIp = try decoderContainer.decode(String?.self, forKey: .serverIp)
        }
        if decoderContainer.contains(.frameRate)
        {
            self.frameRate = try decoderContainer.decode(Double?.self, forKey: .frameRate)
        }
        if decoderContainer.contains(.frameLossRate)
        {
            self.frameLossRate = try decoderContainer.decode(Double?.self, forKey: .frameLossRate)
        }
        if decoderContainer.contains(.lastActive)
        {
            self.lastActive = try decoderContainer.decode(Int64?.self, forKey: .lastActive)
        }
        if decoderContainer.contains(.realFps)
        {
            self.realFps = try decoderContainer.decode(Double?.self, forKey: .realFps)
        }
        if decoderContainer.contains(.uploadSpeed)
        {
            self.uploadSpeed = try decoderContainer.decode(Int64?.self, forKey: .uploadSpeed)
        }
        if decoderContainer.contains(.videoCodecId)
        {
            self.videoCodecId = try decoderContainer.decode(Int64?.self, forKey: .videoCodecId)
        }
        if decoderContainer.contains(.videoDataRate)
        {
            self.videoDataRate = try decoderContainer.decode(Int64?.self, forKey: .videoDataRate)
        }
        if decoderContainer.contains(.audioCodecId)
        {
            self.audioCodecId = try decoderContainer.decode(Int64?.self, forKey: .audioCodecId)
        }
    }
}
public extension OnlineStreamInfo{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: OnlineStreamInfoCodingKeys.self)
         try encoderContainer.encode(app, forKey: .app)
         try encoderContainer.encode(stream, forKey: .stream)
         try encoderContainer.encode(clientIp, forKey: .clientIp)
         try encoderContainer.encode(serverIp, forKey: .serverIp)
         try encoderContainer.encode(frameRate, forKey: .frameRate)
         try encoderContainer.encode(frameLossRate, forKey: .frameLossRate)
         try encoderContainer.encode(lastActive, forKey: .lastActive)
         try encoderContainer.encode(realFps, forKey: .realFps)
         try encoderContainer.encode(uploadSpeed, forKey: .uploadSpeed)
         try encoderContainer.encode(videoCodecId, forKey: .videoCodecId)
         try encoderContainer.encode(videoDataRate, forKey: .videoDataRate)
         try encoderContainer.encode(audioCodecId, forKey: .audioCodecId)
    }
}
///  ipSourceInfo
public class IpSourceInfo:NSObject,Codable{
    /// 1：主；2：备
    var master:Int?
    /// 回源IP
    var ip:String?
    /// 占比
    var ratio:Double?



    public override init(){
            super.init()
    }

    enum IpSourceInfoCodingKeys: String, CodingKey {
        case master
        case ip
        case ratio
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: IpSourceInfoCodingKeys.self)
        if decoderContainer.contains(.master)
        {
            self.master = try decoderContainer.decode(Int?.self, forKey: .master)
        }
        if decoderContainer.contains(.ip)
        {
            self.ip = try decoderContainer.decode(String?.self, forKey: .ip)
        }
        if decoderContainer.contains(.ratio)
        {
            self.ratio = try decoderContainer.decode(Double?.self, forKey: .ratio)
        }
    }
}
public extension IpSourceInfo{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: IpSourceInfoCodingKeys.self)
         try encoderContainer.encode(master, forKey: .master)
         try encoderContainer.encode(ip, forKey: .ip)
         try encoderContainer.encode(ratio, forKey: .ratio)
    }
}
///  snowLeopardIpSourceInfo
public class SnowLeopardIpSourceInfo:NSObject,Codable{
    /// 1：主；2：备
    var master:Int?
    /// 回源IP
    var ip:String?
    /// 占比
    var ratio:Double?
    /// 运营商
    var isp:String?



    public override init(){
            super.init()
    }

    enum SnowLeopardIpSourceInfoCodingKeys: String, CodingKey {
        case master
        case ip
        case ratio
        case isp
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: SnowLeopardIpSourceInfoCodingKeys.self)
        if decoderContainer.contains(.master)
        {
            self.master = try decoderContainer.decode(Int?.self, forKey: .master)
        }
        if decoderContainer.contains(.ip)
        {
            self.ip = try decoderContainer.decode(String?.self, forKey: .ip)
        }
        if decoderContainer.contains(.ratio)
        {
            self.ratio = try decoderContainer.decode(Double?.self, forKey: .ratio)
        }
        if decoderContainer.contains(.isp)
        {
            self.isp = try decoderContainer.decode(String?.self, forKey: .isp)
        }
    }
}
public extension SnowLeopardIpSourceInfo{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: SnowLeopardIpSourceInfoCodingKeys.self)
         try encoderContainer.encode(master, forKey: .master)
         try encoderContainer.encode(ip, forKey: .ip)
         try encoderContainer.encode(ratio, forKey: .ratio)
         try encoderContainer.encode(isp, forKey: .isp)
    }
}
///  relatedDomains
public class RelatedDomains:NSObject,Codable{
    /// 域名
    var domainName:String?
    /// （关联域名类型）publish或play
    var domainType:String?
    /// 该相关域名的rtmp格式
    var rtmpUrls:[String?]?
    /// 该相关域名的flv格式
    var flvUrls:[String?]?
    /// 该相关域名的hls格式
    var hlsUrls:[String?]?



    public override init(){
            super.init()
    }

    enum RelatedDomainsCodingKeys: String, CodingKey {
        case domainName
        case domainType
        case rtmpUrls
        case flvUrls
        case hlsUrls
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: RelatedDomainsCodingKeys.self)
        if decoderContainer.contains(.domainName)
        {
            self.domainName = try decoderContainer.decode(String?.self, forKey: .domainName)
        }
        if decoderContainer.contains(.domainType)
        {
            self.domainType = try decoderContainer.decode(String?.self, forKey: .domainType)
        }
        if decoderContainer.contains(.rtmpUrls)
        {
            self.rtmpUrls = try decoderContainer.decode([String?]?.self, forKey: .rtmpUrls)
        }
        if decoderContainer.contains(.flvUrls)
        {
            self.flvUrls = try decoderContainer.decode([String?]?.self, forKey: .flvUrls)
        }
        if decoderContainer.contains(.hlsUrls)
        {
            self.hlsUrls = try decoderContainer.decode([String?]?.self, forKey: .hlsUrls)
        }
    }
}
public extension RelatedDomains{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: RelatedDomainsCodingKeys.self)
         try encoderContainer.encode(domainName, forKey: .domainName)
         try encoderContainer.encode(domainType, forKey: .domainType)
         try encoderContainer.encode(rtmpUrls, forKey: .rtmpUrls)
         try encoderContainer.encode(flvUrls, forKey: .flvUrls)
         try encoderContainer.encode(hlsUrls, forKey: .hlsUrls)
    }
}
///  backSourceInfo
public class BackSourceInfo:NSObject,Codable{
    /// Ips
    var ips:[IpSourceInfo?]?
    /// Domain
    var domain:[DomainSourceInfo?]?
    /// OssSource
    var ossSource:String?



    public override init(){
            super.init()
    }

    enum BackSourceInfoCodingKeys: String, CodingKey {
        case ips
        case domain
        case ossSource
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: BackSourceInfoCodingKeys.self)
        if decoderContainer.contains(.ips)
        {
            self.ips = try decoderContainer.decode([IpSourceInfo?]?.self, forKey: .ips)
        }
        if decoderContainer.contains(.domain)
        {
            self.domain = try decoderContainer.decode([DomainSourceInfo?]?.self, forKey: .domain)
        }
        if decoderContainer.contains(.ossSource)
        {
            self.ossSource = try decoderContainer.decode(String?.self, forKey: .ossSource)
        }
    }
}
public extension BackSourceInfo{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: BackSourceInfoCodingKeys.self)
         try encoderContainer.encode(ips, forKey: .ips)
         try encoderContainer.encode(domain, forKey: .domain)
         try encoderContainer.encode(ossSource, forKey: .ossSource)
    }
}
///  snowLeopardDomainSourceInfo
public class SnowLeopardDomainSourceInfo:NSObject,Codable{
    /// 优先级（1-10）
    var priority:Int?
    /// 回源host
    var sourceHost:String?
    /// 回源域名
    var domain:String?



    public override init(){
            super.init()
    }

    enum SnowLeopardDomainSourceInfoCodingKeys: String, CodingKey {
        case priority
        case sourceHost
        case domain
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: SnowLeopardDomainSourceInfoCodingKeys.self)
        if decoderContainer.contains(.priority)
        {
            self.priority = try decoderContainer.decode(Int?.self, forKey: .priority)
        }
        if decoderContainer.contains(.sourceHost)
        {
            self.sourceHost = try decoderContainer.decode(String?.self, forKey: .sourceHost)
        }
        if decoderContainer.contains(.domain)
        {
            self.domain = try decoderContainer.decode(String?.self, forKey: .domain)
        }
    }
}
public extension SnowLeopardDomainSourceInfo{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: SnowLeopardDomainSourceInfoCodingKeys.self)
         try encoderContainer.encode(priority, forKey: .priority)
         try encoderContainer.encode(sourceHost, forKey: .sourceHost)
         try encoderContainer.encode(domain, forKey: .domain)
    }
}
///  snowLeopardBackSourceInfo
public class SnowLeopardBackSourceInfo:NSObject,Codable{
    /// Ips
    var ips:[SnowLeopardIpSourceInfo?]?
    /// Domain
    var domain:[SnowLeopardDomainSourceInfo?]?
    /// OssSource
    var ossSource:String?



    public override init(){
            super.init()
    }

    enum SnowLeopardBackSourceInfoCodingKeys: String, CodingKey {
        case ips
        case domain
        case ossSource
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: SnowLeopardBackSourceInfoCodingKeys.self)
        if decoderContainer.contains(.ips)
        {
            self.ips = try decoderContainer.decode([SnowLeopardIpSourceInfo?]?.self, forKey: .ips)
        }
        if decoderContainer.contains(.domain)
        {
            self.domain = try decoderContainer.decode([SnowLeopardDomainSourceInfo?]?.self, forKey: .domain)
        }
        if decoderContainer.contains(.ossSource)
        {
            self.ossSource = try decoderContainer.decode(String?.self, forKey: .ossSource)
        }
    }
}
public extension SnowLeopardBackSourceInfo{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: SnowLeopardBackSourceInfoCodingKeys.self)
         try encoderContainer.encode(ips, forKey: .ips)
         try encoderContainer.encode(domain, forKey: .domain)
         try encoderContainer.encode(ossSource, forKey: .ossSource)
    }
}
///  tag
public class Tag:NSObject,Codable{
    /// Key
    var key:String?
    /// Value
    var value:String?



    public override init(){
            super.init()
    }

    enum TagCodingKeys: String, CodingKey {
        case key
        case value
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: TagCodingKeys.self)
        if decoderContainer.contains(.key)
        {
            self.key = try decoderContainer.decode(String?.self, forKey: .key)
        }
        if decoderContainer.contains(.value)
        {
            self.value = try decoderContainer.decode(String?.self, forKey: .value)
        }
    }
}
public extension Tag{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: TagCodingKeys.self)
         try encoderContainer.encode(key, forKey: .key)
         try encoderContainer.encode(value, forKey: .value)
    }
}
///  listDomainItemByFilter
public class ListDomainItemByFilter:NSObject,Codable{
    /// Cname
    var cname:String?
    /// Description
    var descriptionValue:String?
    /// Domain
    var domain:String?
    /// Created
    var created:String?
    /// Modified
    var modified:String?
    /// Status
    var status:String?
    /// WafStatus
    var wafStatus:String?
    /// Type
    var type:String?
    /// AuditStatus
    var auditStatus:String?
    /// AccelerateRegion
    var accelerateRegion:String?
    /// Tags
    var tags:[Tag?]?



    public override init(){
            super.init()
    }

    enum ListDomainItemByFilterCodingKeys: String, CodingKey {
        case cname
        case descriptionValue = "description"
        case domain
        case created
        case modified
        case status
        case wafStatus
        case type
        case auditStatus
        case accelerateRegion
        case tags
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: ListDomainItemByFilterCodingKeys.self)
        if decoderContainer.contains(.cname)
        {
            self.cname = try decoderContainer.decode(String?.self, forKey: .cname)
        }
        if decoderContainer.contains(.descriptionValue)
        {
            self.descriptionValue = try decoderContainer.decode(String?.self, forKey: .descriptionValue)
        }
        if decoderContainer.contains(.domain)
        {
            self.domain = try decoderContainer.decode(String?.self, forKey: .domain)
        }
        if decoderContainer.contains(.created)
        {
            self.created = try decoderContainer.decode(String?.self, forKey: .created)
        }
        if decoderContainer.contains(.modified)
        {
            self.modified = try decoderContainer.decode(String?.self, forKey: .modified)
        }
        if decoderContainer.contains(.status)
        {
            self.status = try decoderContainer.decode(String?.self, forKey: .status)
        }
        if decoderContainer.contains(.wafStatus)
        {
            self.wafStatus = try decoderContainer.decode(String?.self, forKey: .wafStatus)
        }
        if decoderContainer.contains(.type)
        {
            self.type = try decoderContainer.decode(String?.self, forKey: .type)
        }
        if decoderContainer.contains(.auditStatus)
        {
            self.auditStatus = try decoderContainer.decode(String?.self, forKey: .auditStatus)
        }
        if decoderContainer.contains(.accelerateRegion)
        {
            self.accelerateRegion = try decoderContainer.decode(String?.self, forKey: .accelerateRegion)
        }
        if decoderContainer.contains(.tags)
        {
            self.tags = try decoderContainer.decode([Tag?]?.self, forKey: .tags)
        }
    }
}
public extension ListDomainItemByFilter{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: ListDomainItemByFilterCodingKeys.self)
         try encoderContainer.encode(cname, forKey: .cname)
         try encoderContainer.encode(descriptionValue, forKey: .descriptionValue)
         try encoderContainer.encode(domain, forKey: .domain)
         try encoderContainer.encode(created, forKey: .created)
         try encoderContainer.encode(modified, forKey: .modified)
         try encoderContainer.encode(status, forKey: .status)
         try encoderContainer.encode(wafStatus, forKey: .wafStatus)
         try encoderContainer.encode(type, forKey: .type)
         try encoderContainer.encode(auditStatus, forKey: .auditStatus)
         try encoderContainer.encode(accelerateRegion, forKey: .accelerateRegion)
         try encoderContainer.encode(tags, forKey: .tags)
    }
}
///  domain
public class Domain:NSObject,Codable{
    /// DomainValue
    var domainValue:String?
    /// Status
    var status:String?



    public override init(){
            super.init()
    }

    enum DomainCodingKeys: String, CodingKey {
        case domainValue = "domain"
        case status
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: DomainCodingKeys.self)
        if decoderContainer.contains(.domainValue)
        {
            self.domainValue = try decoderContainer.decode(String?.self, forKey: .domainValue)
        }
        if decoderContainer.contains(.status)
        {
            self.status = try decoderContainer.decode(String?.self, forKey: .status)
        }
    }
}
public extension Domain{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: DomainCodingKeys.self)
         try encoderContainer.encode(domainValue, forKey: .domainValue)
         try encoderContainer.encode(status, forKey: .status)
    }
}
///  listDomainItem
public class ListDomainItem:NSObject,Codable{
    /// Cname
    var cname:String?
    /// Description
    var descriptionValue:String?
    /// Domain
    var domain:String?
    /// Created
    var created:String?
    /// Modified
    var modified:String?
    /// Status
    var status:String?
    /// WafStatus
    var wafStatus:String?
    /// Type
    var type:String?
    /// AuditStatus
    var auditStatus:String?
    /// AccelerateRegion
    var accelerateRegion:String?



    public override init(){
            super.init()
    }

    enum ListDomainItemCodingKeys: String, CodingKey {
        case cname
        case descriptionValue = "description"
        case domain
        case created
        case modified
        case status
        case wafStatus
        case type
        case auditStatus
        case accelerateRegion
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: ListDomainItemCodingKeys.self)
        if decoderContainer.contains(.cname)
        {
            self.cname = try decoderContainer.decode(String?.self, forKey: .cname)
        }
        if decoderContainer.contains(.descriptionValue)
        {
            self.descriptionValue = try decoderContainer.decode(String?.self, forKey: .descriptionValue)
        }
        if decoderContainer.contains(.domain)
        {
            self.domain = try decoderContainer.decode(String?.self, forKey: .domain)
        }
        if decoderContainer.contains(.created)
        {
            self.created = try decoderContainer.decode(String?.self, forKey: .created)
        }
        if decoderContainer.contains(.modified)
        {
            self.modified = try decoderContainer.decode(String?.self, forKey: .modified)
        }
        if decoderContainer.contains(.status)
        {
            self.status = try decoderContainer.decode(String?.self, forKey: .status)
        }
        if decoderContainer.contains(.wafStatus)
        {
            self.wafStatus = try decoderContainer.decode(String?.self, forKey: .wafStatus)
        }
        if decoderContainer.contains(.type)
        {
            self.type = try decoderContainer.decode(String?.self, forKey: .type)
        }
        if decoderContainer.contains(.auditStatus)
        {
            self.auditStatus = try decoderContainer.decode(String?.self, forKey: .auditStatus)
        }
        if decoderContainer.contains(.accelerateRegion)
        {
            self.accelerateRegion = try decoderContainer.decode(String?.self, forKey: .accelerateRegion)
        }
    }
}
public extension ListDomainItem{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: ListDomainItemCodingKeys.self)
         try encoderContainer.encode(cname, forKey: .cname)
         try encoderContainer.encode(descriptionValue, forKey: .descriptionValue)
         try encoderContainer.encode(domain, forKey: .domain)
         try encoderContainer.encode(created, forKey: .created)
         try encoderContainer.encode(modified, forKey: .modified)
         try encoderContainer.encode(status, forKey: .status)
         try encoderContainer.encode(wafStatus, forKey: .wafStatus)
         try encoderContainer.encode(type, forKey: .type)
         try encoderContainer.encode(auditStatus, forKey: .auditStatus)
         try encoderContainer.encode(accelerateRegion, forKey: .accelerateRegion)
    }
}
///  tagFilter
public class TagFilter:NSObject,Codable{
    /// Key
    var key:String?
    /// Values
    var values:[String?]?



    public override init(){
            super.init()
    }

    enum TagFilterCodingKeys: String, CodingKey {
        case key
        case values
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: TagFilterCodingKeys.self)
        if decoderContainer.contains(.key)
        {
            self.key = try decoderContainer.decode(String?.self, forKey: .key)
        }
        if decoderContainer.contains(.values)
        {
            self.values = try decoderContainer.decode([String?]?.self, forKey: .values)
        }
    }
}
public extension TagFilter{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: TagFilterCodingKeys.self)
         try encoderContainer.encode(key, forKey: .key)
         try encoderContainer.encode(values, forKey: .values)
    }
}
///  cacheRule
public class CacheRule:NSObject,Codable{
    /// Weight
    var weight:Int32?
    /// Ttl
    var ttl:Int64?
    /// Contents
    var contents:String?
    /// CreateTime
    var createTime:String?
    /// UpdateTime
    var updateTime:String?
    /// CacheType
    var cacheType:String?



    public override init(){
            super.init()
    }

    enum CacheRuleCodingKeys: String, CodingKey {
        case weight
        case ttl
        case contents
        case createTime
        case updateTime
        case cacheType
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: CacheRuleCodingKeys.self)
        if decoderContainer.contains(.weight)
        {
            self.weight = try decoderContainer.decode(Int32?.self, forKey: .weight)
        }
        if decoderContainer.contains(.ttl)
        {
            self.ttl = try decoderContainer.decode(Int64?.self, forKey: .ttl)
        }
        if decoderContainer.contains(.contents)
        {
            self.contents = try decoderContainer.decode(String?.self, forKey: .contents)
        }
        if decoderContainer.contains(.createTime)
        {
            self.createTime = try decoderContainer.decode(String?.self, forKey: .createTime)
        }
        if decoderContainer.contains(.updateTime)
        {
            self.updateTime = try decoderContainer.decode(String?.self, forKey: .updateTime)
        }
        if decoderContainer.contains(.cacheType)
        {
            self.cacheType = try decoderContainer.decode(String?.self, forKey: .cacheType)
        }
    }
}
public extension CacheRule{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: CacheRuleCodingKeys.self)
         try encoderContainer.encode(weight, forKey: .weight)
         try encoderContainer.encode(ttl, forKey: .ttl)
         try encoderContainer.encode(contents, forKey: .contents)
         try encoderContainer.encode(createTime, forKey: .createTime)
         try encoderContainer.encode(updateTime, forKey: .updateTime)
         try encoderContainer.encode(cacheType, forKey: .cacheType)
    }
}
///  sslCertModel
public class SslCertModel:NSObject,Codable{
    /// 证书Id
    var sslCertId:String?
    /// 证书名称
    var certName:String?
    /// 绑定域名
    var commonName:String?
    /// 证书类型
    var certType:String?
    /// 开始时间
    var sslCertStartTime:String?
    /// 结束时间
    var sslCertEndTime:String?
    /// 是否允许被删除,1允许,0不允许
    var deletable:Int?
    /// 对私钥文件使用sha256算法计算的摘要信息
    var digest:String?
    /// 绑定的域名
    var relatedDomains:[String?]?



    public override init(){
            super.init()
    }

    enum SslCertModelCodingKeys: String, CodingKey {
        case sslCertId
        case certName
        case commonName
        case certType
        case sslCertStartTime
        case sslCertEndTime
        case deletable
        case digest
        case relatedDomains
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: SslCertModelCodingKeys.self)
        if decoderContainer.contains(.sslCertId)
        {
            self.sslCertId = try decoderContainer.decode(String?.self, forKey: .sslCertId)
        }
        if decoderContainer.contains(.certName)
        {
            self.certName = try decoderContainer.decode(String?.self, forKey: .certName)
        }
        if decoderContainer.contains(.commonName)
        {
            self.commonName = try decoderContainer.decode(String?.self, forKey: .commonName)
        }
        if decoderContainer.contains(.certType)
        {
            self.certType = try decoderContainer.decode(String?.self, forKey: .certType)
        }
        if decoderContainer.contains(.sslCertStartTime)
        {
            self.sslCertStartTime = try decoderContainer.decode(String?.self, forKey: .sslCertStartTime)
        }
        if decoderContainer.contains(.sslCertEndTime)
        {
            self.sslCertEndTime = try decoderContainer.decode(String?.self, forKey: .sslCertEndTime)
        }
        if decoderContainer.contains(.deletable)
        {
            self.deletable = try decoderContainer.decode(Int?.self, forKey: .deletable)
        }
        if decoderContainer.contains(.digest)
        {
            self.digest = try decoderContainer.decode(String?.self, forKey: .digest)
        }
        if decoderContainer.contains(.relatedDomains)
        {
            self.relatedDomains = try decoderContainer.decode([String?]?.self, forKey: .relatedDomains)
        }
    }
}
public extension SslCertModel{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: SslCertModelCodingKeys.self)
         try encoderContainer.encode(sslCertId, forKey: .sslCertId)
         try encoderContainer.encode(certName, forKey: .certName)
         try encoderContainer.encode(commonName, forKey: .commonName)
         try encoderContainer.encode(certType, forKey: .certType)
         try encoderContainer.encode(sslCertStartTime, forKey: .sslCertStartTime)
         try encoderContainer.encode(sslCertEndTime, forKey: .sslCertEndTime)
         try encoderContainer.encode(deletable, forKey: .deletable)
         try encoderContainer.encode(digest, forKey: .digest)
         try encoderContainer.encode(relatedDomains, forKey: .relatedDomains)
    }
}
///  urlItemV2
public class UrlItemV2:NSObject,Codable{
    /// 任务url
    var url:String?
    /// 回报任务的id
    var urlId:String?
    /// 回报的地址
    var callbackUrl:String?



    public override init(){
            super.init()
    }

    enum UrlItemV2CodingKeys: String, CodingKey {
        case url
        case urlId
        case callbackUrl
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: UrlItemV2CodingKeys.self)
        if decoderContainer.contains(.url)
        {
            self.url = try decoderContainer.decode(String?.self, forKey: .url)
        }
        if decoderContainer.contains(.urlId)
        {
            self.urlId = try decoderContainer.decode(String?.self, forKey: .urlId)
        }
        if decoderContainer.contains(.callbackUrl)
        {
            self.callbackUrl = try decoderContainer.decode(String?.self, forKey: .callbackUrl)
        }
    }
}
public extension UrlItemV2{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: UrlItemV2CodingKeys.self)
         try encoderContainer.encode(url, forKey: .url)
         try encoderContainer.encode(urlId, forKey: .urlId)
         try encoderContainer.encode(callbackUrl, forKey: .callbackUrl)
    }
}
///  urlTask
public class UrlTask:NSObject,Codable{
    /// 刷新预热类型,(url:url刷新,dir:目录刷新,prefetch:预热)
    var taskType:String?
    /// 刷新预热的url
    var url:String?
    /// 任务状态(running:执行中,success:成功,failed:失败)
    var status:String?



    public override init(){
            super.init()
    }

    enum UrlTaskCodingKeys: String, CodingKey {
        case taskType
        case url
        case status
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: UrlTaskCodingKeys.self)
        if decoderContainer.contains(.taskType)
        {
            self.taskType = try decoderContainer.decode(String?.self, forKey: .taskType)
        }
        if decoderContainer.contains(.url)
        {
            self.url = try decoderContainer.decode(String?.self, forKey: .url)
        }
        if decoderContainer.contains(.status)
        {
            self.status = try decoderContainer.decode(String?.self, forKey: .status)
        }
    }
}
public extension UrlTask{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: UrlTaskCodingKeys.self)
         try encoderContainer.encode(taskType, forKey: .taskType)
         try encoderContainer.encode(url, forKey: .url)
         try encoderContainer.encode(status, forKey: .status)
    }
}
///  urlItem
public class UrlItem:NSObject,Codable{
    /// 任务url
    var url:String?
    /// 回报任务的id
    var urlId:Int64?



    public override init(){
            super.init()
    }

    enum UrlItemCodingKeys: String, CodingKey {
        case url
        case urlId
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: UrlItemCodingKeys.self)
        if decoderContainer.contains(.url)
        {
            self.url = try decoderContainer.decode(String?.self, forKey: .url)
        }
        if decoderContainer.contains(.urlId)
        {
            self.urlId = try decoderContainer.decode(Int64?.self, forKey: .urlId)
        }
    }
}
public extension UrlItem{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: UrlItemCodingKeys.self)
         try encoderContainer.encode(url, forKey: .url)
         try encoderContainer.encode(urlId, forKey: .urlId)
    }
}
///  refreshTask
public class RefreshTask:NSObject,Codable{
    /// 任务创建时间,UTC时间
    var createDate:String?
    /// 任务失败率
    var failed:Double?
    /// 任务成功率
    var success:Double?
    /// 刷新预热的任务id
    var taskId:String?
    /// 数据库表id
    var id:Int64?
    /// 重试状态(unretry:不重试,retry:重试)
    var retryStatus:String?
    /// 任务状态(running:执行中,success:成功,failed:失败)
    var taskStatus:String?
    /// 刷新预热类型,(url:url刷新,dir:目录刷新,prefetch:预热)
    var taskType:String?
    /// 详细的任务
    var urlTasks:[UrlTask?]?



    public override init(){
            super.init()
    }

    enum RefreshTaskCodingKeys: String, CodingKey {
        case createDate
        case failed
        case success
        case taskId
        case id
        case retryStatus
        case taskStatus
        case taskType
        case urlTasks
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: RefreshTaskCodingKeys.self)
        if decoderContainer.contains(.createDate)
        {
            self.createDate = try decoderContainer.decode(String?.self, forKey: .createDate)
        }
        if decoderContainer.contains(.failed)
        {
            self.failed = try decoderContainer.decode(Double?.self, forKey: .failed)
        }
        if decoderContainer.contains(.success)
        {
            self.success = try decoderContainer.decode(Double?.self, forKey: .success)
        }
        if decoderContainer.contains(.taskId)
        {
            self.taskId = try decoderContainer.decode(String?.self, forKey: .taskId)
        }
        if decoderContainer.contains(.id)
        {
            self.id = try decoderContainer.decode(Int64?.self, forKey: .id)
        }
        if decoderContainer.contains(.retryStatus)
        {
            self.retryStatus = try decoderContainer.decode(String?.self, forKey: .retryStatus)
        }
        if decoderContainer.contains(.taskStatus)
        {
            self.taskStatus = try decoderContainer.decode(String?.self, forKey: .taskStatus)
        }
        if decoderContainer.contains(.taskType)
        {
            self.taskType = try decoderContainer.decode(String?.self, forKey: .taskType)
        }
        if decoderContainer.contains(.urlTasks)
        {
            self.urlTasks = try decoderContainer.decode([UrlTask?]?.self, forKey: .urlTasks)
        }
    }
}
public extension RefreshTask{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: RefreshTaskCodingKeys.self)
         try encoderContainer.encode(createDate, forKey: .createDate)
         try encoderContainer.encode(failed, forKey: .failed)
         try encoderContainer.encode(success, forKey: .success)
         try encoderContainer.encode(taskId, forKey: .taskId)
         try encoderContainer.encode(id, forKey: .id)
         try encoderContainer.encode(retryStatus, forKey: .retryStatus)
         try encoderContainer.encode(taskStatus, forKey: .taskStatus)
         try encoderContainer.encode(taskType, forKey: .taskType)
         try encoderContainer.encode(urlTasks, forKey: .urlTasks)
    }
}
///  simpleGroupItem
public class SimpleGroupItem:NSObject,Codable{
    /// Name
    var name:String?
    /// Id
    var id:Int64?



    public override init(){
            super.init()
    }

    enum SimpleGroupItemCodingKeys: String, CodingKey {
        case name
        case id
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: SimpleGroupItemCodingKeys.self)
        if decoderContainer.contains(.name)
        {
            self.name = try decoderContainer.decode(String?.self, forKey: .name)
        }
        if decoderContainer.contains(.id)
        {
            self.id = try decoderContainer.decode(Int64?.self, forKey: .id)
        }
    }
}
public extension SimpleGroupItem{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: SimpleGroupItemCodingKeys.self)
         try encoderContainer.encode(name, forKey: .name)
         try encoderContainer.encode(id, forKey: .id)
    }
}
///  domainGroupItem
public class DomainGroupItem:NSObject,Codable{
    /// 域名组成员
    var domains:[String?]?
    /// 主域名
    var primaryDomain:String?
    /// 是否共享缓存
    var shareCache:String?
    /// 域名组名称
    var domainGroupName:String?



    public override init(){
            super.init()
    }

    enum DomainGroupItemCodingKeys: String, CodingKey {
        case domains
        case primaryDomain
        case shareCache
        case domainGroupName
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: DomainGroupItemCodingKeys.self)
        if decoderContainer.contains(.domains)
        {
            self.domains = try decoderContainer.decode([String?]?.self, forKey: .domains)
        }
        if decoderContainer.contains(.primaryDomain)
        {
            self.primaryDomain = try decoderContainer.decode(String?.self, forKey: .primaryDomain)
        }
        if decoderContainer.contains(.shareCache)
        {
            self.shareCache = try decoderContainer.decode(String?.self, forKey: .shareCache)
        }
        if decoderContainer.contains(.domainGroupName)
        {
            self.domainGroupName = try decoderContainer.decode(String?.self, forKey: .domainGroupName)
        }
    }
}
public extension DomainGroupItem{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: DomainGroupItemCodingKeys.self)
         try encoderContainer.encode(domains, forKey: .domains)
         try encoderContainer.encode(primaryDomain, forKey: .primaryDomain)
         try encoderContainer.encode(shareCache, forKey: .shareCache)
         try encoderContainer.encode(domainGroupName, forKey: .domainGroupName)
    }
}
///  queryHttpHeaderResp
public class QueryHttpHeaderResp:NSObject,Codable{
    /// HeaderType
    var headerType:String?
    /// HeaderName
    var headerName:String?
    /// HeaderValue
    var headerValue:String?
    /// HeaderOp
    var headerOp:String?



    public override init(){
            super.init()
    }

    enum QueryHttpHeaderRespCodingKeys: String, CodingKey {
        case headerType
        case headerName
        case headerValue
        case headerOp
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: QueryHttpHeaderRespCodingKeys.self)
        if decoderContainer.contains(.headerType)
        {
            self.headerType = try decoderContainer.decode(String?.self, forKey: .headerType)
        }
        if decoderContainer.contains(.headerName)
        {
            self.headerName = try decoderContainer.decode(String?.self, forKey: .headerName)
        }
        if decoderContainer.contains(.headerValue)
        {
            self.headerValue = try decoderContainer.decode(String?.self, forKey: .headerValue)
        }
        if decoderContainer.contains(.headerOp)
        {
            self.headerOp = try decoderContainer.decode(String?.self, forKey: .headerOp)
        }
    }
}
public extension QueryHttpHeaderResp{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: QueryHttpHeaderRespCodingKeys.self)
         try encoderContainer.encode(headerType, forKey: .headerType)
         try encoderContainer.encode(headerName, forKey: .headerName)
         try encoderContainer.encode(headerValue, forKey: .headerValue)
         try encoderContainer.encode(headerOp, forKey: .headerOp)
    }
}
///  attackLogRecord
public class AttackLogRecord:NSObject,Codable{
    /// 攻击峰值
    var attackTraffic:Double?
    /// 攻击类型
    var attackType:[String?]?
    /// 黑洞封禁 0-&gt;未封禁 1-&gt;封禁
    var blackHole:Int32?
    /// 攻击结束时间 utc时间
    var endTime:String?
    /// 用户pin
    var pin:String?
    /// 攻击开始时间 utc时间
    var startTime:String?
    /// 攻击峰值单位 流量单位
    var unit:String?



    public override init(){
            super.init()
    }

    enum AttackLogRecordCodingKeys: String, CodingKey {
        case attackTraffic
        case attackType
        case blackHole
        case endTime
        case pin
        case startTime
        case unit
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: AttackLogRecordCodingKeys.self)
        if decoderContainer.contains(.attackTraffic)
        {
            self.attackTraffic = try decoderContainer.decode(Double?.self, forKey: .attackTraffic)
        }
        if decoderContainer.contains(.attackType)
        {
            self.attackType = try decoderContainer.decode([String?]?.self, forKey: .attackType)
        }
        if decoderContainer.contains(.blackHole)
        {
            self.blackHole = try decoderContainer.decode(Int32?.self, forKey: .blackHole)
        }
        if decoderContainer.contains(.endTime)
        {
            self.endTime = try decoderContainer.decode(String?.self, forKey: .endTime)
        }
        if decoderContainer.contains(.pin)
        {
            self.pin = try decoderContainer.decode(String?.self, forKey: .pin)
        }
        if decoderContainer.contains(.startTime)
        {
            self.startTime = try decoderContainer.decode(String?.self, forKey: .startTime)
        }
        if decoderContainer.contains(.unit)
        {
            self.unit = try decoderContainer.decode(String?.self, forKey: .unit)
        }
    }
}
public extension AttackLogRecord{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: AttackLogRecordCodingKeys.self)
         try encoderContainer.encode(attackTraffic, forKey: .attackTraffic)
         try encoderContainer.encode(attackType, forKey: .attackType)
         try encoderContainer.encode(blackHole, forKey: .blackHole)
         try encoderContainer.encode(endTime, forKey: .endTime)
         try encoderContainer.encode(pin, forKey: .pin)
         try encoderContainer.encode(startTime, forKey: .startTime)
         try encoderContainer.encode(unit, forKey: .unit)
    }
}
///  geoArea
public class GeoArea:NSObject,Codable{
    /// Label
    var label:String?
    /// Value
    var value:String?
    /// Children
    var children:[GeoArea?]?



    public override init(){
            super.init()
    }

    enum GeoAreaCodingKeys: String, CodingKey {
        case label
        case value
        case children
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: GeoAreaCodingKeys.self)
        if decoderContainer.contains(.label)
        {
            self.label = try decoderContainer.decode(String?.self, forKey: .label)
        }
        if decoderContainer.contains(.value)
        {
            self.value = try decoderContainer.decode(String?.self, forKey: .value)
        }
        if decoderContainer.contains(.children)
        {
            self.children = try decoderContainer.decode([GeoArea?]?.self, forKey: .children)
        }
    }
}
public extension GeoArea{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: GeoAreaCodingKeys.self)
         try encoderContainer.encode(label, forKey: .label)
         try encoderContainer.encode(value, forKey: .value)
         try encoderContainer.encode(children, forKey: .children)
    }
}
///  protectData
public class ProtectData:NSObject,Codable{
    /// 防护后流量序
    var postProtect:Double?
    /// 防护前流量序
    var preProtect:Double?
    /// 时间戳,到秒
    var timeStamp:Int64?
    /// UTC时间
    var timeUtc:String?



    public override init(){
            super.init()
    }

    enum ProtectDataCodingKeys: String, CodingKey {
        case postProtect
        case preProtect
        case timeStamp
        case timeUtc
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: ProtectDataCodingKeys.self)
        if decoderContainer.contains(.postProtect)
        {
            self.postProtect = try decoderContainer.decode(Double?.self, forKey: .postProtect)
        }
        if decoderContainer.contains(.preProtect)
        {
            self.preProtect = try decoderContainer.decode(Double?.self, forKey: .preProtect)
        }
        if decoderContainer.contains(.timeStamp)
        {
            self.timeStamp = try decoderContainer.decode(Int64?.self, forKey: .timeStamp)
        }
        if decoderContainer.contains(.timeUtc)
        {
            self.timeUtc = try decoderContainer.decode(String?.self, forKey: .timeUtc)
        }
    }
}
public extension ProtectData{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: ProtectDataCodingKeys.self)
         try encoderContainer.encode(postProtect, forKey: .postProtect)
         try encoderContainer.encode(preProtect, forKey: .preProtect)
         try encoderContainer.encode(timeStamp, forKey: .timeStamp)
         try encoderContainer.encode(timeUtc, forKey: .timeUtc)
    }
}
///  attackTypeCount
public class AttackTypeCount:NSObject,Codable{
    /// AttackCount
    var attackCount:Int64?
    /// AttackType
    var attackType:String?



    public override init(){
            super.init()
    }

    enum AttackTypeCountCodingKeys: String, CodingKey {
        case attackCount
        case attackType
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: AttackTypeCountCodingKeys.self)
        if decoderContainer.contains(.attackCount)
        {
            self.attackCount = try decoderContainer.decode(Int64?.self, forKey: .attackCount)
        }
        if decoderContainer.contains(.attackType)
        {
            self.attackType = try decoderContainer.decode(String?.self, forKey: .attackType)
        }
    }
}
public extension AttackTypeCount{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: AttackTypeCountCodingKeys.self)
         try encoderContainer.encode(attackCount, forKey: .attackCount)
         try encoderContainer.encode(attackType, forKey: .attackType)
    }
}
///  feeDomain
public class FeeDomain:NSObject,Codable{
    /// Domain
    var domain:String?
    /// FeeType
    var feeType:Int32?



    public override init(){
            super.init()
    }

    enum FeeDomainCodingKeys: String, CodingKey {
        case domain
        case feeType
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: FeeDomainCodingKeys.self)
        if decoderContainer.contains(.domain)
        {
            self.domain = try decoderContainer.decode(String?.self, forKey: .domain)
        }
        if decoderContainer.contains(.feeType)
        {
            self.feeType = try decoderContainer.decode(Int32?.self, forKey: .feeType)
        }
    }
}
public extension FeeDomain{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: FeeDomainCodingKeys.self)
         try encoderContainer.encode(domain, forKey: .domain)
         try encoderContainer.encode(feeType, forKey: .feeType)
    }
}
///  statisticsDataItem
public class StatisticsDataItem:NSObject,Codable{
    /// UTC时间，格式为:yyyy-MM-dd&#39;T&#39;HH:mm:ss&#39;Z&#39;，示例:2018-10-21T10:00:00Z
    var startTime:String?
    /// UTC时间，格式为:yyyy-MM-dd&#39;T&#39;HH:mm:ss&#39;Z&#39;，示例:2018-10-21T10:00:00Z
    var endTime:String?
    /// 查询结果,类型为HashMap&lt;String, Object&gt;
    var data:[String:String?]?



    public override init(){
            super.init()
    }

    enum StatisticsDataItemCodingKeys: String, CodingKey {
        case startTime
        case endTime
        case data
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: StatisticsDataItemCodingKeys.self)
        if decoderContainer.contains(.startTime)
        {
            self.startTime = try decoderContainer.decode(String?.self, forKey: .startTime)
        }
        if decoderContainer.contains(.endTime)
        {
            self.endTime = try decoderContainer.decode(String?.self, forKey: .endTime)
        }
        if decoderContainer.contains(.data)
        {
            self.data = try decoderContainer.decode([String:String?]?.self, forKey: .data)
        }
    }
}
public extension StatisticsDataItem{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: StatisticsDataItemCodingKeys.self)
         try encoderContainer.encode(startTime, forKey: .startTime)
         try encoderContainer.encode(endTime, forKey: .endTime)
         try encoderContainer.encode(data, forKey: .data)
    }
}
///  statisticsWithAreaGroupDetail
public class StatisticsWithAreaGroupDetail:NSObject,Codable{
    /// UTC时间，格式为:yyyy-MM-dd&#39;T&#39;HH:mm:ss&#39;Z&#39;，示例:2018-10-21T10:00:00Z
    var startTime:String?
    /// UTC时间，格式为:yyyy-MM-dd&#39;T&#39;HH:mm:ss&#39;Z&#39;，示例:2018-10-21T10:00:00Z
    var endTime:String?
    /// null
    var data:[StatisticsWithAreaGroupDetailItem?]?



    public override init(){
            super.init()
    }

    enum StatisticsWithAreaGroupDetailCodingKeys: String, CodingKey {
        case startTime
        case endTime
        case data
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: StatisticsWithAreaGroupDetailCodingKeys.self)
        if decoderContainer.contains(.startTime)
        {
            self.startTime = try decoderContainer.decode(String?.self, forKey: .startTime)
        }
        if decoderContainer.contains(.endTime)
        {
            self.endTime = try decoderContainer.decode(String?.self, forKey: .endTime)
        }
        if decoderContainer.contains(.data)
        {
            self.data = try decoderContainer.decode([StatisticsWithAreaGroupDetailItem?]?.self, forKey: .data)
        }
    }
}
public extension StatisticsWithAreaGroupDetail{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: StatisticsWithAreaGroupDetailCodingKeys.self)
         try encoderContainer.encode(startTime, forKey: .startTime)
         try encoderContainer.encode(endTime, forKey: .endTime)
         try encoderContainer.encode(data, forKey: .data)
    }
}
///  statisticsTopIpItem
public class StatisticsTopIpItem:NSObject,Codable{
    /// Ip
    var ip:String?
    /// Rank
    var rank:Int?
    /// Value
    var value:Int?
    /// 查询结果,类型为HashMap&lt;String, Object&gt;
    var fullValue:[String:String?]?



    public override init(){
            super.init()
    }

    enum StatisticsTopIpItemCodingKeys: String, CodingKey {
        case ip
        case rank
        case value
        case fullValue
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: StatisticsTopIpItemCodingKeys.self)
        if decoderContainer.contains(.ip)
        {
            self.ip = try decoderContainer.decode(String?.self, forKey: .ip)
        }
        if decoderContainer.contains(.rank)
        {
            self.rank = try decoderContainer.decode(Int?.self, forKey: .rank)
        }
        if decoderContainer.contains(.value)
        {
            self.value = try decoderContainer.decode(Int?.self, forKey: .value)
        }
        if decoderContainer.contains(.fullValue)
        {
            self.fullValue = try decoderContainer.decode([String:String?]?.self, forKey: .fullValue)
        }
    }
}
public extension StatisticsTopIpItem{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: StatisticsTopIpItemCodingKeys.self)
         try encoderContainer.encode(ip, forKey: .ip)
         try encoderContainer.encode(rank, forKey: .rank)
         try encoderContainer.encode(value, forKey: .value)
         try encoderContainer.encode(fullValue, forKey: .fullValue)
    }
}
///  statisticsTopUrlData
public class StatisticsTopUrlData:NSObject,Codable{
    /// Count
    var count:Int?
    /// Urls
    var urls:[StatisticsTopUrlItem?]?



    public override init(){
            super.init()
    }

    enum StatisticsTopUrlDataCodingKeys: String, CodingKey {
        case count
        case urls
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: StatisticsTopUrlDataCodingKeys.self)
        if decoderContainer.contains(.count)
        {
            self.count = try decoderContainer.decode(Int?.self, forKey: .count)
        }
        if decoderContainer.contains(.urls)
        {
            self.urls = try decoderContainer.decode([StatisticsTopUrlItem?]?.self, forKey: .urls)
        }
    }
}
public extension StatisticsTopUrlData{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: StatisticsTopUrlDataCodingKeys.self)
         try encoderContainer.encode(count, forKey: .count)
         try encoderContainer.encode(urls, forKey: .urls)
    }
}
///  domainLog
public class DomainLog:NSObject,Codable{
    /// 下载链接
    var url:String?
    /// md5值
    var md5:String?
    /// 文件名
    var fileName:String?
    /// 文件大小
    var size:Int64?
    /// 日志开始时间，UTC时间
    var startTime:String?
    /// 日志结束时间，UTC时间
    var endTime:String?



    public override init(){
            super.init()
    }

    enum DomainLogCodingKeys: String, CodingKey {
        case url
        case md5
        case fileName
        case size
        case startTime
        case endTime
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: DomainLogCodingKeys.self)
        if decoderContainer.contains(.url)
        {
            self.url = try decoderContainer.decode(String?.self, forKey: .url)
        }
        if decoderContainer.contains(.md5)
        {
            self.md5 = try decoderContainer.decode(String?.self, forKey: .md5)
        }
        if decoderContainer.contains(.fileName)
        {
            self.fileName = try decoderContainer.decode(String?.self, forKey: .fileName)
        }
        if decoderContainer.contains(.size)
        {
            self.size = try decoderContainer.decode(Int64?.self, forKey: .size)
        }
        if decoderContainer.contains(.startTime)
        {
            self.startTime = try decoderContainer.decode(String?.self, forKey: .startTime)
        }
        if decoderContainer.contains(.endTime)
        {
            self.endTime = try decoderContainer.decode(String?.self, forKey: .endTime)
        }
    }
}
public extension DomainLog{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: DomainLogCodingKeys.self)
         try encoderContainer.encode(url, forKey: .url)
         try encoderContainer.encode(md5, forKey: .md5)
         try encoderContainer.encode(fileName, forKey: .fileName)
         try encoderContainer.encode(size, forKey: .size)
         try encoderContainer.encode(startTime, forKey: .startTime)
         try encoderContainer.encode(endTime, forKey: .endTime)
    }
}
///  domainsLog
public class DomainsLog:NSObject,Codable{
    /// 域名
    var domain:String?
    /// DomainLogs
    var domainLogs:[DomainLog?]?



    public override init(){
            super.init()
    }

    enum DomainsLogCodingKeys: String, CodingKey {
        case domain
        case domainLogs
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: DomainsLogCodingKeys.self)
        if decoderContainer.contains(.domain)
        {
            self.domain = try decoderContainer.decode(String?.self, forKey: .domain)
        }
        if decoderContainer.contains(.domainLogs)
        {
            self.domainLogs = try decoderContainer.decode([DomainLog?]?.self, forKey: .domainLogs)
        }
    }
}
public extension DomainsLog{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: DomainsLogCodingKeys.self)
         try encoderContainer.encode(domain, forKey: .domain)
         try encoderContainer.encode(domainLogs, forKey: .domainLogs)
    }
}
///  statisticsWithAreaGroupDetailItem
public class StatisticsWithAreaGroupDetailItem:NSObject,Codable{
    /// Area
    var area:String?
    /// IspStat
    var ispStat:[[String:String?]?]?



    public override init(){
            super.init()
    }

    enum StatisticsWithAreaGroupDetailItemCodingKeys: String, CodingKey {
        case area
        case ispStat
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: StatisticsWithAreaGroupDetailItemCodingKeys.self)
        if decoderContainer.contains(.area)
        {
            self.area = try decoderContainer.decode(String?.self, forKey: .area)
        }
        if decoderContainer.contains(.ispStat)
        {
            self.ispStat = try decoderContainer.decode([[String:String?]?]?.self, forKey: .ispStat)
        }
    }
}
public extension StatisticsWithAreaGroupDetailItem{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: StatisticsWithAreaGroupDetailItemCodingKeys.self)
         try encoderContainer.encode(area, forKey: .area)
         try encoderContainer.encode(ispStat, forKey: .ispStat)
    }
}
///  statisticsTopIpData
public class StatisticsTopIpData:NSObject,Codable{
    /// Count
    var count:Int?
    /// Ips
    var ips:[StatisticsTopIpItem?]?



    public override init(){
            super.init()
    }

    enum StatisticsTopIpDataCodingKeys: String, CodingKey {
        case count
        case ips
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: StatisticsTopIpDataCodingKeys.self)
        if decoderContainer.contains(.count)
        {
            self.count = try decoderContainer.decode(Int?.self, forKey: .count)
        }
        if decoderContainer.contains(.ips)
        {
            self.ips = try decoderContainer.decode([StatisticsTopIpItem?]?.self, forKey: .ips)
        }
    }
}
public extension StatisticsTopIpData{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: StatisticsTopIpDataCodingKeys.self)
         try encoderContainer.encode(count, forKey: .count)
         try encoderContainer.encode(ips, forKey: .ips)
    }
}
///  statisticsTopUrlItem
public class StatisticsTopUrlItem:NSObject,Codable{
    /// Url
    var url:String?
    /// Rank
    var rank:Int?
    /// Value
    var value:Int?
    /// 查询结果,类型为HashMap&lt;String, Object&gt;
    var fullValue:[String:String?]?



    public override init(){
            super.init()
    }

    enum StatisticsTopUrlItemCodingKeys: String, CodingKey {
        case url
        case rank
        case value
        case fullValue
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: StatisticsTopUrlItemCodingKeys.self)
        if decoderContainer.contains(.url)
        {
            self.url = try decoderContainer.decode(String?.self, forKey: .url)
        }
        if decoderContainer.contains(.rank)
        {
            self.rank = try decoderContainer.decode(Int?.self, forKey: .rank)
        }
        if decoderContainer.contains(.value)
        {
            self.value = try decoderContainer.decode(Int?.self, forKey: .value)
        }
        if decoderContainer.contains(.fullValue)
        {
            self.fullValue = try decoderContainer.decode([String:String?]?.self, forKey: .fullValue)
        }
    }
}
public extension StatisticsTopUrlItem{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: StatisticsTopUrlItemCodingKeys.self)
         try encoderContainer.encode(url, forKey: .url)
         try encoderContainer.encode(rank, forKey: .rank)
         try encoderContainer.encode(value, forKey: .value)
         try encoderContainer.encode(fullValue, forKey: .fullValue)
    }
}
///  statisticsGroupSumDataItem
public class StatisticsGroupSumDataItem:NSObject,Codable{
    /// UTC时间，格式为:yyyy-MM-dd&#39;T&#39;HH:mm:ss&#39;Z&#39;，示例:2018-10-21T10:00:00Z
    var startTime:String?
    /// UTC时间，格式为:yyyy-MM-dd&#39;T&#39;HH:mm:ss&#39;Z&#39;，示例:2018-10-21T10:00:00Z
    var endTime:String?
    /// 查询结果,类型为HashMap&lt;String, Object&gt;
    var data:[String:String?]?



    public override init(){
            super.init()
    }

    enum StatisticsGroupSumDataItemCodingKeys: String, CodingKey {
        case startTime
        case endTime
        case data
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: StatisticsGroupSumDataItemCodingKeys.self)
        if decoderContainer.contains(.startTime)
        {
            self.startTime = try decoderContainer.decode(String?.self, forKey: .startTime)
        }
        if decoderContainer.contains(.endTime)
        {
            self.endTime = try decoderContainer.decode(String?.self, forKey: .endTime)
        }
        if decoderContainer.contains(.data)
        {
            self.data = try decoderContainer.decode([String:String?]?.self, forKey: .data)
        }
    }
}
public extension StatisticsGroupSumDataItem{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: StatisticsGroupSumDataItemCodingKeys.self)
         try encoderContainer.encode(startTime, forKey: .startTime)
         try encoderContainer.encode(endTime, forKey: .endTime)
         try encoderContainer.encode(data, forKey: .data)
    }
}
///  wafCCProtectRuleModel
public class WafCCProtectRuleModel:NSObject,Codable{
    /// Total
    var total:Int32?
    /// Data
    var data:[AnyObject?]?



    public override init(){
            super.init()
    }

    enum WafCCProtectRuleModelCodingKeys: String, CodingKey {
        case total
        case data
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: WafCCProtectRuleModelCodingKeys.self)
        if decoderContainer.contains(.total)
        {
            self.total = try decoderContainer.decode(Int32?.self, forKey: .total)
        }
    }
}
public extension WafCCProtectRuleModel{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: WafCCProtectRuleModelCodingKeys.self)
         try encoderContainer.encode(total, forKey: .total)
    }
}
///  wafWhiteRuleModel
public class WafWhiteRuleModel:NSObject,Codable{
    /// 白名单规则id
    var id:String?
    /// 匹配模式,uri类型有效，0&#x3D;完全匹配  1&#x3D;前缀匹配 2&#x3D;包含 3&#x3D;正则 4&#x3D;大于 5&#x3D;后缀
    var matchOp:Int32?
    /// 匹配值
    var val:String?
    /// 匹配值的中文名
    var valZh:String?
    /// 是否启用, true为启用,false为未启用
    var enable:Bool?
    /// 后续处理 &quot;waf&quot; &quot;cc&quot; &quot;deny&quot; &quot;ratelimit&quot; 自由组合，空表示跳过后续所有阶段
    var actions:[String?]?
    /// 白名单的修改时间,UTC时间
    var updateTime:String?



    public override init(){
            super.init()
    }

    enum WafWhiteRuleModelCodingKeys: String, CodingKey {
        case id
        case matchOp
        case val
        case valZh
        case enable
        case actions
        case updateTime
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: WafWhiteRuleModelCodingKeys.self)
        if decoderContainer.contains(.id)
        {
            self.id = try decoderContainer.decode(String?.self, forKey: .id)
        }
        if decoderContainer.contains(.matchOp)
        {
            self.matchOp = try decoderContainer.decode(Int32?.self, forKey: .matchOp)
        }
        if decoderContainer.contains(.val)
        {
            self.val = try decoderContainer.decode(String?.self, forKey: .val)
        }
        if decoderContainer.contains(.valZh)
        {
            self.valZh = try decoderContainer.decode(String?.self, forKey: .valZh)
        }
        if decoderContainer.contains(.enable)
        {
            self.enable = try decoderContainer.decode(Bool?.self, forKey: .enable)
        }
        if decoderContainer.contains(.actions)
        {
            self.actions = try decoderContainer.decode([String?]?.self, forKey: .actions)
        }
        if decoderContainer.contains(.updateTime)
        {
            self.updateTime = try decoderContainer.decode(String?.self, forKey: .updateTime)
        }
    }
}
public extension WafWhiteRuleModel{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: WafWhiteRuleModelCodingKeys.self)
         try encoderContainer.encode(id, forKey: .id)
         try encoderContainer.encode(matchOp, forKey: .matchOp)
         try encoderContainer.encode(val, forKey: .val)
         try encoderContainer.encode(valZh, forKey: .valZh)
         try encoderContainer.encode(enable, forKey: .enable)
         try encoderContainer.encode(actions, forKey: .actions)
         try encoderContainer.encode(updateTime, forKey: .updateTime)
    }
}
///  wafBlackRuleModel
public class WafBlackRuleModel:NSObject,Codable{
    /// 黑名单规则id
    var id:String?
    /// 匹配模式,uri类型有效，0&#x3D;完全匹配  1&#x3D;前缀匹配 2&#x3D;包含 3&#x3D;正则 4&#x3D;大于 5&#x3D;后缀
    var matchOp:Int32?
    /// 匹配值
    var val:String?
    /// 匹配值的中文名
    var valZh:String?
    /// 是否启用, true为启用,false为未启用
    var enable:Bool?
    /// null
    var action:Action?
    /// 黑名单的修改时间,UTC时间
    var updateTime:String?



    public override init(){
            super.init()
    }

    enum WafBlackRuleModelCodingKeys: String, CodingKey {
        case id
        case matchOp
        case val
        case valZh
        case enable
        case action
        case updateTime
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: WafBlackRuleModelCodingKeys.self)
        if decoderContainer.contains(.id)
        {
            self.id = try decoderContainer.decode(String?.self, forKey: .id)
        }
        if decoderContainer.contains(.matchOp)
        {
            self.matchOp = try decoderContainer.decode(Int32?.self, forKey: .matchOp)
        }
        if decoderContainer.contains(.val)
        {
            self.val = try decoderContainer.decode(String?.self, forKey: .val)
        }
        if decoderContainer.contains(.valZh)
        {
            self.valZh = try decoderContainer.decode(String?.self, forKey: .valZh)
        }
        if decoderContainer.contains(.enable)
        {
            self.enable = try decoderContainer.decode(Bool?.self, forKey: .enable)
        }
        if decoderContainer.contains(.action)
        {
            self.action = try decoderContainer.decode(Action?.self, forKey: .action)
        }
        if decoderContainer.contains(.updateTime)
        {
            self.updateTime = try decoderContainer.decode(String?.self, forKey: .updateTime)
        }
    }
}
public extension WafBlackRuleModel{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: WafBlackRuleModelCodingKeys.self)
         try encoderContainer.encode(id, forKey: .id)
         try encoderContainer.encode(matchOp, forKey: .matchOp)
         try encoderContainer.encode(val, forKey: .val)
         try encoderContainer.encode(valZh, forKey: .valZh)
         try encoderContainer.encode(enable, forKey: .enable)
         try encoderContainer.encode(action, forKey: .action)
         try encoderContainer.encode(updateTime, forKey: .updateTime)
    }
}
///  wafRegionsModel
public class WafRegionsModel:NSObject,Codable{
    /// 省份英文名
    var value:String?
    /// 省份中文名
    var label:String?



    public override init(){
            super.init()
    }

    enum WafRegionsModelCodingKeys: String, CodingKey {
        case value
        case label
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: WafRegionsModelCodingKeys.self)
        if decoderContainer.contains(.value)
        {
            self.value = try decoderContainer.decode(String?.self, forKey: .value)
        }
        if decoderContainer.contains(.label)
        {
            self.label = try decoderContainer.decode(String?.self, forKey: .label)
        }
    }
}
public extension WafRegionsModel{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: WafRegionsModelCodingKeys.self)
         try encoderContainer.encode(value, forKey: .value)
         try encoderContainer.encode(label, forKey: .label)
    }
}
///  oriflowTopItem
public class OriflowTopItem:NSObject,Codable{
    /// Name
    var name:String?
    /// Oriflow
    var oriflow:Double?
    /// Hitflow
    var hitflow:Double?
    /// Flow
    var flow:Double?
    /// FlowPercent
    var flowPercent:String?



    public override init(){
            super.init()
    }

    enum OriflowTopItemCodingKeys: String, CodingKey {
        case name
        case oriflow
        case hitflow
        case flow
        case flowPercent
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: OriflowTopItemCodingKeys.self)
        if decoderContainer.contains(.name)
        {
            self.name = try decoderContainer.decode(String?.self, forKey: .name)
        }
        if decoderContainer.contains(.oriflow)
        {
            self.oriflow = try decoderContainer.decode(Double?.self, forKey: .oriflow)
        }
        if decoderContainer.contains(.hitflow)
        {
            self.hitflow = try decoderContainer.decode(Double?.self, forKey: .hitflow)
        }
        if decoderContainer.contains(.flow)
        {
            self.flow = try decoderContainer.decode(Double?.self, forKey: .flow)
        }
        if decoderContainer.contains(.flowPercent)
        {
            self.flowPercent = try decoderContainer.decode(String?.self, forKey: .flowPercent)
        }
    }
}
public extension OriflowTopItem{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: OriflowTopItemCodingKeys.self)
         try encoderContainer.encode(name, forKey: .name)
         try encoderContainer.encode(oriflow, forKey: .oriflow)
         try encoderContainer.encode(hitflow, forKey: .hitflow)
         try encoderContainer.encode(flow, forKey: .flow)
         try encoderContainer.encode(flowPercent, forKey: .flowPercent)
    }
}
///  streamTableItem
public class StreamTableItem:NSObject,Codable{
    /// TopTimeStamp
    var topTimeStamp:Int64?
    /// Avgbandwidth
    var avgbandwidth:Double?
    /// Flow
    var flow:Double?
    /// Pv
    var pv:Int64?
    /// StreamName
    var streamName:String?



    public override init(){
            super.init()
    }

    enum StreamTableItemCodingKeys: String, CodingKey {
        case topTimeStamp
        case avgbandwidth
        case flow
        case pv
        case streamName
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: StreamTableItemCodingKeys.self)
        if decoderContainer.contains(.topTimeStamp)
        {
            self.topTimeStamp = try decoderContainer.decode(Int64?.self, forKey: .topTimeStamp)
        }
        if decoderContainer.contains(.avgbandwidth)
        {
            self.avgbandwidth = try decoderContainer.decode(Double?.self, forKey: .avgbandwidth)
        }
        if decoderContainer.contains(.flow)
        {
            self.flow = try decoderContainer.decode(Double?.self, forKey: .flow)
        }
        if decoderContainer.contains(.pv)
        {
            self.pv = try decoderContainer.decode(Int64?.self, forKey: .pv)
        }
        if decoderContainer.contains(.streamName)
        {
            self.streamName = try decoderContainer.decode(String?.self, forKey: .streamName)
        }
    }
}
public extension StreamTableItem{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: StreamTableItemCodingKeys.self)
         try encoderContainer.encode(topTimeStamp, forKey: .topTimeStamp)
         try encoderContainer.encode(avgbandwidth, forKey: .avgbandwidth)
         try encoderContainer.encode(flow, forKey: .flow)
         try encoderContainer.encode(pv, forKey: .pv)
         try encoderContainer.encode(streamName, forKey: .streamName)
    }
}
///  topNRespItem
public class TopNRespItem:NSObject,Codable{
    /// TopKey
    var topKey:String?
    /// TopValue
    var topValue:AnyObject?
    /// TopDataValue
    var topDataValue:Double?
    /// TopDataPercent
    var topDataPercent:String?
    /// Details
    var details:[TopNRespItemDetail?]?



    public override init(){
            super.init()
    }

    enum TopNRespItemCodingKeys: String, CodingKey {
        case topKey
        case topValue
        case topDataValue
        case topDataPercent
        case details
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: TopNRespItemCodingKeys.self)
        if decoderContainer.contains(.topKey)
        {
            self.topKey = try decoderContainer.decode(String?.self, forKey: .topKey)
        }
        if decoderContainer.contains(.topDataValue)
        {
            self.topDataValue = try decoderContainer.decode(Double?.self, forKey: .topDataValue)
        }
        if decoderContainer.contains(.topDataPercent)
        {
            self.topDataPercent = try decoderContainer.decode(String?.self, forKey: .topDataPercent)
        }
        if decoderContainer.contains(.details)
        {
            self.details = try decoderContainer.decode([TopNRespItemDetail?]?.self, forKey: .details)
        }
    }
}
public extension TopNRespItem{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: TopNRespItemCodingKeys.self)
         try encoderContainer.encode(topKey, forKey: .topKey)
         try encoderContainer.encode(topDataValue, forKey: .topDataValue)
         try encoderContainer.encode(topDataPercent, forKey: .topDataPercent)
         try encoderContainer.encode(details, forKey: .details)
    }
}
///  topUrlItem
public class TopUrlItem:NSObject,Codable{
    /// Url
    var url:String?
    /// Rank
    var rank:Int?
    /// Flow
    var flow:Double?
    /// FlowUnit
    var flowUnit:String?
    /// FlowPercent
    var flowPercent:String?
    /// Pv
    var pv:Int64?
    /// PvUnit
    var pvUnit:String?
    /// PvPercent
    var pvPercent:String?
    /// Uv
    var uv:Int64?
    /// UvUnit
    var uvUnit:String?
    /// UvPercent
    var uvPercent:String?



    public override init(){
            super.init()
    }

    enum TopUrlItemCodingKeys: String, CodingKey {
        case url
        case rank
        case flow
        case flowUnit
        case flowPercent
        case pv
        case pvUnit
        case pvPercent
        case uv
        case uvUnit
        case uvPercent
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: TopUrlItemCodingKeys.self)
        if decoderContainer.contains(.url)
        {
            self.url = try decoderContainer.decode(String?.self, forKey: .url)
        }
        if decoderContainer.contains(.rank)
        {
            self.rank = try decoderContainer.decode(Int?.self, forKey: .rank)
        }
        if decoderContainer.contains(.flow)
        {
            self.flow = try decoderContainer.decode(Double?.self, forKey: .flow)
        }
        if decoderContainer.contains(.flowUnit)
        {
            self.flowUnit = try decoderContainer.decode(String?.self, forKey: .flowUnit)
        }
        if decoderContainer.contains(.flowPercent)
        {
            self.flowPercent = try decoderContainer.decode(String?.self, forKey: .flowPercent)
        }
        if decoderContainer.contains(.pv)
        {
            self.pv = try decoderContainer.decode(Int64?.self, forKey: .pv)
        }
        if decoderContainer.contains(.pvUnit)
        {
            self.pvUnit = try decoderContainer.decode(String?.self, forKey: .pvUnit)
        }
        if decoderContainer.contains(.pvPercent)
        {
            self.pvPercent = try decoderContainer.decode(String?.self, forKey: .pvPercent)
        }
        if decoderContainer.contains(.uv)
        {
            self.uv = try decoderContainer.decode(Int64?.self, forKey: .uv)
        }
        if decoderContainer.contains(.uvUnit)
        {
            self.uvUnit = try decoderContainer.decode(String?.self, forKey: .uvUnit)
        }
        if decoderContainer.contains(.uvPercent)
        {
            self.uvPercent = try decoderContainer.decode(String?.self, forKey: .uvPercent)
        }
    }
}
public extension TopUrlItem{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: TopUrlItemCodingKeys.self)
         try encoderContainer.encode(url, forKey: .url)
         try encoderContainer.encode(rank, forKey: .rank)
         try encoderContainer.encode(flow, forKey: .flow)
         try encoderContainer.encode(flowUnit, forKey: .flowUnit)
         try encoderContainer.encode(flowPercent, forKey: .flowPercent)
         try encoderContainer.encode(pv, forKey: .pv)
         try encoderContainer.encode(pvUnit, forKey: .pvUnit)
         try encoderContainer.encode(pvPercent, forKey: .pvPercent)
         try encoderContainer.encode(uv, forKey: .uv)
         try encoderContainer.encode(uvUnit, forKey: .uvUnit)
         try encoderContainer.encode(uvPercent, forKey: .uvPercent)
    }
}
///  topNRespItemDetail
public class TopNRespItemDetail:NSObject,Codable{
    /// TimeStamp
    var timeStamp:Int64?
    /// Data
    var data:Double?



    public override init(){
            super.init()
    }

    enum TopNRespItemDetailCodingKeys: String, CodingKey {
        case timeStamp
        case data
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: TopNRespItemDetailCodingKeys.self)
        if decoderContainer.contains(.timeStamp)
        {
            self.timeStamp = try decoderContainer.decode(Int64?.self, forKey: .timeStamp)
        }
        if decoderContainer.contains(.data)
        {
            self.data = try decoderContainer.decode(Double?.self, forKey: .data)
        }
    }
}
public extension TopNRespItemDetail{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: TopNRespItemDetailCodingKeys.self)
         try encoderContainer.encode(timeStamp, forKey: .timeStamp)
         try encoderContainer.encode(data, forKey: .data)
    }
}
///  codeTypeItem
public class CodeTypeItem:NSObject,Codable{
    /// Code
    var code:String?
    /// Count
    var count:Int64?
    /// Rank
    var rank:Int?
    /// Percent
    var percent:String?
    /// Details
    var details:[CodeTypeDetailItem?]?



    public override init(){
            super.init()
    }

    enum CodeTypeItemCodingKeys: String, CodingKey {
        case code
        case count
        case rank
        case percent
        case details
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: CodeTypeItemCodingKeys.self)
        if decoderContainer.contains(.code)
        {
            self.code = try decoderContainer.decode(String?.self, forKey: .code)
        }
        if decoderContainer.contains(.count)
        {
            self.count = try decoderContainer.decode(Int64?.self, forKey: .count)
        }
        if decoderContainer.contains(.rank)
        {
            self.rank = try decoderContainer.decode(Int?.self, forKey: .rank)
        }
        if decoderContainer.contains(.percent)
        {
            self.percent = try decoderContainer.decode(String?.self, forKey: .percent)
        }
        if decoderContainer.contains(.details)
        {
            self.details = try decoderContainer.decode([CodeTypeDetailItem?]?.self, forKey: .details)
        }
    }
}
public extension CodeTypeItem{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: CodeTypeItemCodingKeys.self)
         try encoderContainer.encode(code, forKey: .code)
         try encoderContainer.encode(count, forKey: .count)
         try encoderContainer.encode(rank, forKey: .rank)
         try encoderContainer.encode(percent, forKey: .percent)
         try encoderContainer.encode(details, forKey: .details)
    }
}
///  avgspeedItem
public class AvgspeedItem:NSObject,Codable{
    /// Area
    var area:String?
    /// Avgspeed
    var avgspeed:Double?
    /// AvgspeedUnit
    var avgspeedUnit:String?
    /// Firstpkgtime
    var firstpkgtime:Double?
    /// FirstpkgtimeUnit
    var firstpkgtimeUnit:String?
    /// ErrorRatio
    var errorRatio:Double?
    /// Flow
    var flow:Double?
    /// FlowUnit
    var flowUnit:String?
    /// FlowPercent
    var flowPercent:Double?
    /// Pv
    var pv:Int64?
    /// HitRatio
    var hitRatio:Double?



    public override init(){
            super.init()
    }

    enum AvgspeedItemCodingKeys: String, CodingKey {
        case area
        case avgspeed
        case avgspeedUnit
        case firstpkgtime
        case firstpkgtimeUnit
        case errorRatio
        case flow
        case flowUnit
        case flowPercent
        case pv
        case hitRatio
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: AvgspeedItemCodingKeys.self)
        if decoderContainer.contains(.area)
        {
            self.area = try decoderContainer.decode(String?.self, forKey: .area)
        }
        if decoderContainer.contains(.avgspeed)
        {
            self.avgspeed = try decoderContainer.decode(Double?.self, forKey: .avgspeed)
        }
        if decoderContainer.contains(.avgspeedUnit)
        {
            self.avgspeedUnit = try decoderContainer.decode(String?.self, forKey: .avgspeedUnit)
        }
        if decoderContainer.contains(.firstpkgtime)
        {
            self.firstpkgtime = try decoderContainer.decode(Double?.self, forKey: .firstpkgtime)
        }
        if decoderContainer.contains(.firstpkgtimeUnit)
        {
            self.firstpkgtimeUnit = try decoderContainer.decode(String?.self, forKey: .firstpkgtimeUnit)
        }
        if decoderContainer.contains(.errorRatio)
        {
            self.errorRatio = try decoderContainer.decode(Double?.self, forKey: .errorRatio)
        }
        if decoderContainer.contains(.flow)
        {
            self.flow = try decoderContainer.decode(Double?.self, forKey: .flow)
        }
        if decoderContainer.contains(.flowUnit)
        {
            self.flowUnit = try decoderContainer.decode(String?.self, forKey: .flowUnit)
        }
        if decoderContainer.contains(.flowPercent)
        {
            self.flowPercent = try decoderContainer.decode(Double?.self, forKey: .flowPercent)
        }
        if decoderContainer.contains(.pv)
        {
            self.pv = try decoderContainer.decode(Int64?.self, forKey: .pv)
        }
        if decoderContainer.contains(.hitRatio)
        {
            self.hitRatio = try decoderContainer.decode(Double?.self, forKey: .hitRatio)
        }
    }
}
public extension AvgspeedItem{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: AvgspeedItemCodingKeys.self)
         try encoderContainer.encode(area, forKey: .area)
         try encoderContainer.encode(avgspeed, forKey: .avgspeed)
         try encoderContainer.encode(avgspeedUnit, forKey: .avgspeedUnit)
         try encoderContainer.encode(firstpkgtime, forKey: .firstpkgtime)
         try encoderContainer.encode(firstpkgtimeUnit, forKey: .firstpkgtimeUnit)
         try encoderContainer.encode(errorRatio, forKey: .errorRatio)
         try encoderContainer.encode(flow, forKey: .flow)
         try encoderContainer.encode(flowUnit, forKey: .flowUnit)
         try encoderContainer.encode(flowPercent, forKey: .flowPercent)
         try encoderContainer.encode(pv, forKey: .pv)
         try encoderContainer.encode(hitRatio, forKey: .hitRatio)
    }
}
///  hitRatioDiagramItem
public class HitRatioDiagramItem:NSObject,Codable{
    /// FlowRatio
    var flowRatio:Double?
    /// ReqRatio
    var reqRatio:Double?
    /// TimeStamp
    var timeStamp:Int64?



    public override init(){
            super.init()
    }

    enum HitRatioDiagramItemCodingKeys: String, CodingKey {
        case flowRatio
        case reqRatio
        case timeStamp
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: HitRatioDiagramItemCodingKeys.self)
        if decoderContainer.contains(.flowRatio)
        {
            self.flowRatio = try decoderContainer.decode(Double?.self, forKey: .flowRatio)
        }
        if decoderContainer.contains(.reqRatio)
        {
            self.reqRatio = try decoderContainer.decode(Double?.self, forKey: .reqRatio)
        }
        if decoderContainer.contains(.timeStamp)
        {
            self.timeStamp = try decoderContainer.decode(Int64?.self, forKey: .timeStamp)
        }
    }
}
public extension HitRatioDiagramItem{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: HitRatioDiagramItemCodingKeys.self)
         try encoderContainer.encode(flowRatio, forKey: .flowRatio)
         try encoderContainer.encode(reqRatio, forKey: .reqRatio)
         try encoderContainer.encode(timeStamp, forKey: .timeStamp)
    }
}
///  areaIspbdwItem
public class AreaIspbdwItem:NSObject,Codable{
    /// Area
    var area:String?
    /// Isp
    var isp:String?
    /// Name
    var name:String?
    /// FlowPercent
    var flowPercent:String?
    /// PvPercent
    var pvPercent:String?
    /// Avgbandwidth
    var avgbandwidth:Double?
    /// Flow
    var flow:Double?
    /// Pv
    var pv:Int64?
    /// TopTimeStamp
    var topTimeStamp:Int64?



    public override init(){
            super.init()
    }

    enum AreaIspbdwItemCodingKeys: String, CodingKey {
        case area
        case isp
        case name
        case flowPercent
        case pvPercent
        case avgbandwidth
        case flow
        case pv
        case topTimeStamp
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: AreaIspbdwItemCodingKeys.self)
        if decoderContainer.contains(.area)
        {
            self.area = try decoderContainer.decode(String?.self, forKey: .area)
        }
        if decoderContainer.contains(.isp)
        {
            self.isp = try decoderContainer.decode(String?.self, forKey: .isp)
        }
        if decoderContainer.contains(.name)
        {
            self.name = try decoderContainer.decode(String?.self, forKey: .name)
        }
        if decoderContainer.contains(.flowPercent)
        {
            self.flowPercent = try decoderContainer.decode(String?.self, forKey: .flowPercent)
        }
        if decoderContainer.contains(.pvPercent)
        {
            self.pvPercent = try decoderContainer.decode(String?.self, forKey: .pvPercent)
        }
        if decoderContainer.contains(.avgbandwidth)
        {
            self.avgbandwidth = try decoderContainer.decode(Double?.self, forKey: .avgbandwidth)
        }
        if decoderContainer.contains(.flow)
        {
            self.flow = try decoderContainer.decode(Double?.self, forKey: .flow)
        }
        if decoderContainer.contains(.pv)
        {
            self.pv = try decoderContainer.decode(Int64?.self, forKey: .pv)
        }
        if decoderContainer.contains(.topTimeStamp)
        {
            self.topTimeStamp = try decoderContainer.decode(Int64?.self, forKey: .topTimeStamp)
        }
    }
}
public extension AreaIspbdwItem{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: AreaIspbdwItemCodingKeys.self)
         try encoderContainer.encode(area, forKey: .area)
         try encoderContainer.encode(isp, forKey: .isp)
         try encoderContainer.encode(name, forKey: .name)
         try encoderContainer.encode(flowPercent, forKey: .flowPercent)
         try encoderContainer.encode(pvPercent, forKey: .pvPercent)
         try encoderContainer.encode(avgbandwidth, forKey: .avgbandwidth)
         try encoderContainer.encode(flow, forKey: .flow)
         try encoderContainer.encode(pv, forKey: .pv)
         try encoderContainer.encode(topTimeStamp, forKey: .topTimeStamp)
    }
}
///  overviewTrafficTotal
public class OverviewTrafficTotal:NSObject,Codable{
    /// Avgbandwidth
    var avgbandwidth:Double?
    /// Flow
    var flow:Double?
    /// Pv
    var pv:Int64?
    /// TopTimeStamp
    var topTimeStamp:Int64?



    public override init(){
            super.init()
    }

    enum OverviewTrafficTotalCodingKeys: String, CodingKey {
        case avgbandwidth
        case flow
        case pv
        case topTimeStamp
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: OverviewTrafficTotalCodingKeys.self)
        if decoderContainer.contains(.avgbandwidth)
        {
            self.avgbandwidth = try decoderContainer.decode(Double?.self, forKey: .avgbandwidth)
        }
        if decoderContainer.contains(.flow)
        {
            self.flow = try decoderContainer.decode(Double?.self, forKey: .flow)
        }
        if decoderContainer.contains(.pv)
        {
            self.pv = try decoderContainer.decode(Int64?.self, forKey: .pv)
        }
        if decoderContainer.contains(.topTimeStamp)
        {
            self.topTimeStamp = try decoderContainer.decode(Int64?.self, forKey: .topTimeStamp)
        }
    }
}
public extension OverviewTrafficTotal{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: OverviewTrafficTotalCodingKeys.self)
         try encoderContainer.encode(avgbandwidth, forKey: .avgbandwidth)
         try encoderContainer.encode(flow, forKey: .flow)
         try encoderContainer.encode(pv, forKey: .pv)
         try encoderContainer.encode(topTimeStamp, forKey: .topTimeStamp)
    }
}
///  oridbwTableItem
public class OridbwTableItem:NSObject,Codable{
    /// GroupByname
    var groupByname:String?
    /// DomainTyep
    var domainTyep:String?
    /// OriflowPercent
    var oriflowPercent:String?
    /// OripvPercent
    var oripvPercent:String?
    /// Avgbandwidth
    var avgbandwidth:Double?
    /// Avgoribandwidth
    var avgoribandwidth:Double?
    /// OriTopTimeStamp
    var oriTopTimeStamp:Int64?
    /// Pv
    var pv:Int64?
    /// Oripv
    var oripv:Int64?
    /// Flow
    var flow:Double?
    /// Oriflow
    var oriflow:Double?



    public override init(){
            super.init()
    }

    enum OridbwTableItemCodingKeys: String, CodingKey {
        case groupByname
        case domainTyep
        case oriflowPercent
        case oripvPercent
        case avgbandwidth
        case avgoribandwidth
        case oriTopTimeStamp
        case pv
        case oripv
        case flow
        case oriflow
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: OridbwTableItemCodingKeys.self)
        if decoderContainer.contains(.groupByname)
        {
            self.groupByname = try decoderContainer.decode(String?.self, forKey: .groupByname)
        }
        if decoderContainer.contains(.domainTyep)
        {
            self.domainTyep = try decoderContainer.decode(String?.self, forKey: .domainTyep)
        }
        if decoderContainer.contains(.oriflowPercent)
        {
            self.oriflowPercent = try decoderContainer.decode(String?.self, forKey: .oriflowPercent)
        }
        if decoderContainer.contains(.oripvPercent)
        {
            self.oripvPercent = try decoderContainer.decode(String?.self, forKey: .oripvPercent)
        }
        if decoderContainer.contains(.avgbandwidth)
        {
            self.avgbandwidth = try decoderContainer.decode(Double?.self, forKey: .avgbandwidth)
        }
        if decoderContainer.contains(.avgoribandwidth)
        {
            self.avgoribandwidth = try decoderContainer.decode(Double?.self, forKey: .avgoribandwidth)
        }
        if decoderContainer.contains(.oriTopTimeStamp)
        {
            self.oriTopTimeStamp = try decoderContainer.decode(Int64?.self, forKey: .oriTopTimeStamp)
        }
        if decoderContainer.contains(.pv)
        {
            self.pv = try decoderContainer.decode(Int64?.self, forKey: .pv)
        }
        if decoderContainer.contains(.oripv)
        {
            self.oripv = try decoderContainer.decode(Int64?.self, forKey: .oripv)
        }
        if decoderContainer.contains(.flow)
        {
            self.flow = try decoderContainer.decode(Double?.self, forKey: .flow)
        }
        if decoderContainer.contains(.oriflow)
        {
            self.oriflow = try decoderContainer.decode(Double?.self, forKey: .oriflow)
        }
    }
}
public extension OridbwTableItem{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: OridbwTableItemCodingKeys.self)
         try encoderContainer.encode(groupByname, forKey: .groupByname)
         try encoderContainer.encode(domainTyep, forKey: .domainTyep)
         try encoderContainer.encode(oriflowPercent, forKey: .oriflowPercent)
         try encoderContainer.encode(oripvPercent, forKey: .oripvPercent)
         try encoderContainer.encode(avgbandwidth, forKey: .avgbandwidth)
         try encoderContainer.encode(avgoribandwidth, forKey: .avgoribandwidth)
         try encoderContainer.encode(oriTopTimeStamp, forKey: .oriTopTimeStamp)
         try encoderContainer.encode(pv, forKey: .pv)
         try encoderContainer.encode(oripv, forKey: .oripv)
         try encoderContainer.encode(flow, forKey: .flow)
         try encoderContainer.encode(oriflow, forKey: .oriflow)
    }
}
///  overviewTrafficItem
public class OverviewTrafficItem:NSObject,Codable{
    /// Avgbandwidth
    var avgbandwidth:Int64?
    /// Flow
    var flow:Int64?
    /// Pv
    var pv:Int64?
    /// Maxavgbandwidthtime
    var maxavgbandwidthtime:String?
    /// Details
    var details:[OverviewTrafficDetailItem?]?



    public override init(){
            super.init()
    }

    enum OverviewTrafficItemCodingKeys: String, CodingKey {
        case avgbandwidth
        case flow
        case pv
        case maxavgbandwidthtime
        case details
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: OverviewTrafficItemCodingKeys.self)
        if decoderContainer.contains(.avgbandwidth)
        {
            self.avgbandwidth = try decoderContainer.decode(Int64?.self, forKey: .avgbandwidth)
        }
        if decoderContainer.contains(.flow)
        {
            self.flow = try decoderContainer.decode(Int64?.self, forKey: .flow)
        }
        if decoderContainer.contains(.pv)
        {
            self.pv = try decoderContainer.decode(Int64?.self, forKey: .pv)
        }
        if decoderContainer.contains(.maxavgbandwidthtime)
        {
            self.maxavgbandwidthtime = try decoderContainer.decode(String?.self, forKey: .maxavgbandwidthtime)
        }
        if decoderContainer.contains(.details)
        {
            self.details = try decoderContainer.decode([OverviewTrafficDetailItem?]?.self, forKey: .details)
        }
    }
}
public extension OverviewTrafficItem{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: OverviewTrafficItemCodingKeys.self)
         try encoderContainer.encode(avgbandwidth, forKey: .avgbandwidth)
         try encoderContainer.encode(flow, forKey: .flow)
         try encoderContainer.encode(pv, forKey: .pv)
         try encoderContainer.encode(maxavgbandwidthtime, forKey: .maxavgbandwidthtime)
         try encoderContainer.encode(details, forKey: .details)
    }
}
///  domainbdwItem
public class DomainbdwItem:NSObject,Codable{
    /// Domain
    var domain:String?
    /// DomainType
    var domainType:String?
    /// TopTimeStamp
    var topTimeStamp:Int64?
    /// Pv
    var pv:Int64?
    /// Flow
    var flow:Double?
    /// Avgbandwidth
    var avgbandwidth:Double?



    public override init(){
            super.init()
    }

    enum DomainbdwItemCodingKeys: String, CodingKey {
        case domain
        case domainType
        case topTimeStamp
        case pv
        case flow
        case avgbandwidth
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: DomainbdwItemCodingKeys.self)
        if decoderContainer.contains(.domain)
        {
            self.domain = try decoderContainer.decode(String?.self, forKey: .domain)
        }
        if decoderContainer.contains(.domainType)
        {
            self.domainType = try decoderContainer.decode(String?.self, forKey: .domainType)
        }
        if decoderContainer.contains(.topTimeStamp)
        {
            self.topTimeStamp = try decoderContainer.decode(Int64?.self, forKey: .topTimeStamp)
        }
        if decoderContainer.contains(.pv)
        {
            self.pv = try decoderContainer.decode(Int64?.self, forKey: .pv)
        }
        if decoderContainer.contains(.flow)
        {
            self.flow = try decoderContainer.decode(Double?.self, forKey: .flow)
        }
        if decoderContainer.contains(.avgbandwidth)
        {
            self.avgbandwidth = try decoderContainer.decode(Double?.self, forKey: .avgbandwidth)
        }
    }
}
public extension DomainbdwItem{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: DomainbdwItemCodingKeys.self)
         try encoderContainer.encode(domain, forKey: .domain)
         try encoderContainer.encode(domainType, forKey: .domainType)
         try encoderContainer.encode(topTimeStamp, forKey: .topTimeStamp)
         try encoderContainer.encode(pv, forKey: .pv)
         try encoderContainer.encode(flow, forKey: .flow)
         try encoderContainer.encode(avgbandwidth, forKey: .avgbandwidth)
    }
}
///  streamDiagramItem
public class StreamDiagramItem:NSObject,Codable{
    /// TimeStamp
    var timeStamp:Int64?
    /// Data
    var data:AnyObject?



    public override init(){
            super.init()
    }

    enum StreamDiagramItemCodingKeys: String, CodingKey {
        case timeStamp
        case data
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: StreamDiagramItemCodingKeys.self)
        if decoderContainer.contains(.timeStamp)
        {
            self.timeStamp = try decoderContainer.decode(Int64?.self, forKey: .timeStamp)
        }
    }
}
public extension StreamDiagramItem{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: StreamDiagramItemCodingKeys.self)
         try encoderContainer.encode(timeStamp, forKey: .timeStamp)
    }
}
///  codeTypeDetailItem
public class CodeTypeDetailItem:NSObject,Codable{
    /// Code
    var code:String?
    /// Count
    var count:Int64?
    /// Rank
    var rank:Int?
    /// Percent
    var percent:String?



    public override init(){
            super.init()
    }

    enum CodeTypeDetailItemCodingKeys: String, CodingKey {
        case code
        case count
        case rank
        case percent
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: CodeTypeDetailItemCodingKeys.self)
        if decoderContainer.contains(.code)
        {
            self.code = try decoderContainer.decode(String?.self, forKey: .code)
        }
        if decoderContainer.contains(.count)
        {
            self.count = try decoderContainer.decode(Int64?.self, forKey: .count)
        }
        if decoderContainer.contains(.rank)
        {
            self.rank = try decoderContainer.decode(Int?.self, forKey: .rank)
        }
        if decoderContainer.contains(.percent)
        {
            self.percent = try decoderContainer.decode(String?.self, forKey: .percent)
        }
    }
}
public extension CodeTypeDetailItem{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: CodeTypeDetailItemCodingKeys.self)
         try encoderContainer.encode(code, forKey: .code)
         try encoderContainer.encode(count, forKey: .count)
         try encoderContainer.encode(rank, forKey: .rank)
         try encoderContainer.encode(percent, forKey: .percent)
    }
}
///  codeDetailItem
public class CodeDetailItem:NSObject,Codable{
    /// TimeStamp
    var timeStamp:Int64?
    /// Ok
    var ok:Double?
    /// BadGateway
    var badGateway:Double?
    /// BadRequest
    var badRequest:Double?
    /// Forbidden
    var forbidden:Double?
    /// Found
    var found:Double?
    /// GatewayTimeout
    var gatewayTimeout:Double?
    /// InternalServerError
    var internalServerError:Double?
    /// MovedPermanently
    var movedPermanently:Double?
    /// NotFound
    var notFound:Double?
    /// NotModified
    var notModified:Double?
    /// PartialContent
    var partialContent:Double?
    /// RequestedRangeNotSuitable
    var requestedRangeNotSuitable:Double?
    /// Other
    var other:Double?
    /// ServiceUnavailable
    var serviceUnavailable:Double?



    public override init(){
            super.init()
    }

    enum CodeDetailItemCodingKeys: String, CodingKey {
        case timeStamp
        case ok
        case badGateway
        case badRequest
        case forbidden
        case found
        case gatewayTimeout
        case internalServerError
        case movedPermanently
        case notFound
        case notModified
        case partialContent
        case requestedRangeNotSuitable
        case other
        case serviceUnavailable
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: CodeDetailItemCodingKeys.self)
        if decoderContainer.contains(.timeStamp)
        {
            self.timeStamp = try decoderContainer.decode(Int64?.self, forKey: .timeStamp)
        }
        if decoderContainer.contains(.ok)
        {
            self.ok = try decoderContainer.decode(Double?.self, forKey: .ok)
        }
        if decoderContainer.contains(.badGateway)
        {
            self.badGateway = try decoderContainer.decode(Double?.self, forKey: .badGateway)
        }
        if decoderContainer.contains(.badRequest)
        {
            self.badRequest = try decoderContainer.decode(Double?.self, forKey: .badRequest)
        }
        if decoderContainer.contains(.forbidden)
        {
            self.forbidden = try decoderContainer.decode(Double?.self, forKey: .forbidden)
        }
        if decoderContainer.contains(.found)
        {
            self.found = try decoderContainer.decode(Double?.self, forKey: .found)
        }
        if decoderContainer.contains(.gatewayTimeout)
        {
            self.gatewayTimeout = try decoderContainer.decode(Double?.self, forKey: .gatewayTimeout)
        }
        if decoderContainer.contains(.internalServerError)
        {
            self.internalServerError = try decoderContainer.decode(Double?.self, forKey: .internalServerError)
        }
        if decoderContainer.contains(.movedPermanently)
        {
            self.movedPermanently = try decoderContainer.decode(Double?.self, forKey: .movedPermanently)
        }
        if decoderContainer.contains(.notFound)
        {
            self.notFound = try decoderContainer.decode(Double?.self, forKey: .notFound)
        }
        if decoderContainer.contains(.notModified)
        {
            self.notModified = try decoderContainer.decode(Double?.self, forKey: .notModified)
        }
        if decoderContainer.contains(.partialContent)
        {
            self.partialContent = try decoderContainer.decode(Double?.self, forKey: .partialContent)
        }
        if decoderContainer.contains(.requestedRangeNotSuitable)
        {
            self.requestedRangeNotSuitable = try decoderContainer.decode(Double?.self, forKey: .requestedRangeNotSuitable)
        }
        if decoderContainer.contains(.other)
        {
            self.other = try decoderContainer.decode(Double?.self, forKey: .other)
        }
        if decoderContainer.contains(.serviceUnavailable)
        {
            self.serviceUnavailable = try decoderContainer.decode(Double?.self, forKey: .serviceUnavailable)
        }
    }
}
public extension CodeDetailItem{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: CodeDetailItemCodingKeys.self)
         try encoderContainer.encode(timeStamp, forKey: .timeStamp)
         try encoderContainer.encode(ok, forKey: .ok)
         try encoderContainer.encode(badGateway, forKey: .badGateway)
         try encoderContainer.encode(badRequest, forKey: .badRequest)
         try encoderContainer.encode(forbidden, forKey: .forbidden)
         try encoderContainer.encode(found, forKey: .found)
         try encoderContainer.encode(gatewayTimeout, forKey: .gatewayTimeout)
         try encoderContainer.encode(internalServerError, forKey: .internalServerError)
         try encoderContainer.encode(movedPermanently, forKey: .movedPermanently)
         try encoderContainer.encode(notFound, forKey: .notFound)
         try encoderContainer.encode(notModified, forKey: .notModified)
         try encoderContainer.encode(partialContent, forKey: .partialContent)
         try encoderContainer.encode(requestedRangeNotSuitable, forKey: .requestedRangeNotSuitable)
         try encoderContainer.encode(other, forKey: .other)
         try encoderContainer.encode(serviceUnavailable, forKey: .serviceUnavailable)
    }
}
///  oripvTopItem
public class OripvTopItem:NSObject,Codable{
    /// Name
    var name:String?
    /// Hitpv
    var hitpv:Int64?
    /// Pv
    var pv:Int64?
    /// Oripv
    var oripv:Int64?
    /// OripvPercent
    var oripvPercent:String?



    public override init(){
            super.init()
    }

    enum OripvTopItemCodingKeys: String, CodingKey {
        case name
        case hitpv
        case pv
        case oripv
        case oripvPercent
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: OripvTopItemCodingKeys.self)
        if decoderContainer.contains(.name)
        {
            self.name = try decoderContainer.decode(String?.self, forKey: .name)
        }
        if decoderContainer.contains(.hitpv)
        {
            self.hitpv = try decoderContainer.decode(Int64?.self, forKey: .hitpv)
        }
        if decoderContainer.contains(.pv)
        {
            self.pv = try decoderContainer.decode(Int64?.self, forKey: .pv)
        }
        if decoderContainer.contains(.oripv)
        {
            self.oripv = try decoderContainer.decode(Int64?.self, forKey: .oripv)
        }
        if decoderContainer.contains(.oripvPercent)
        {
            self.oripvPercent = try decoderContainer.decode(String?.self, forKey: .oripvPercent)
        }
    }
}
public extension OripvTopItem{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: OripvTopItemCodingKeys.self)
         try encoderContainer.encode(name, forKey: .name)
         try encoderContainer.encode(hitpv, forKey: .hitpv)
         try encoderContainer.encode(pv, forKey: .pv)
         try encoderContainer.encode(oripv, forKey: .oripv)
         try encoderContainer.encode(oripvPercent, forKey: .oripvPercent)
    }
}
///  hitrationTableItem
public class HitrationTableItem:NSObject,Codable{
    /// Domain
    var domain:String?
    /// DomainType
    var domainType:String?
    /// Pv
    var pv:Int64?
    /// HitPv
    var hitPv:Int64?
    /// OriPV
    var oriPV:Int64?
    /// HitRatio
    var hitRatio:String?



    public override init(){
            super.init()
    }

    enum HitrationTableItemCodingKeys: String, CodingKey {
        case domain
        case domainType
        case pv
        case hitPv
        case oriPV
        case hitRatio
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: HitrationTableItemCodingKeys.self)
        if decoderContainer.contains(.domain)
        {
            self.domain = try decoderContainer.decode(String?.self, forKey: .domain)
        }
        if decoderContainer.contains(.domainType)
        {
            self.domainType = try decoderContainer.decode(String?.self, forKey: .domainType)
        }
        if decoderContainer.contains(.pv)
        {
            self.pv = try decoderContainer.decode(Int64?.self, forKey: .pv)
        }
        if decoderContainer.contains(.hitPv)
        {
            self.hitPv = try decoderContainer.decode(Int64?.self, forKey: .hitPv)
        }
        if decoderContainer.contains(.oriPV)
        {
            self.oriPV = try decoderContainer.decode(Int64?.self, forKey: .oriPV)
        }
        if decoderContainer.contains(.hitRatio)
        {
            self.hitRatio = try decoderContainer.decode(String?.self, forKey: .hitRatio)
        }
    }
}
public extension HitrationTableItem{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: HitrationTableItemCodingKeys.self)
         try encoderContainer.encode(domain, forKey: .domain)
         try encoderContainer.encode(domainType, forKey: .domainType)
         try encoderContainer.encode(pv, forKey: .pv)
         try encoderContainer.encode(hitPv, forKey: .hitPv)
         try encoderContainer.encode(oriPV, forKey: .oriPV)
         try encoderContainer.encode(hitRatio, forKey: .hitRatio)
    }
}
///  oriBandwithDetailItem
public class OriBandwithDetailItem:NSObject,Codable{
    /// TimeStamp
    var timeStamp:Int64?
    /// Avgoribandwidth
    var avgoribandwidth:Double?



    public override init(){
            super.init()
    }

    enum OriBandwithDetailItemCodingKeys: String, CodingKey {
        case timeStamp
        case avgoribandwidth
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: OriBandwithDetailItemCodingKeys.self)
        if decoderContainer.contains(.timeStamp)
        {
            self.timeStamp = try decoderContainer.decode(Int64?.self, forKey: .timeStamp)
        }
        if decoderContainer.contains(.avgoribandwidth)
        {
            self.avgoribandwidth = try decoderContainer.decode(Double?.self, forKey: .avgoribandwidth)
        }
    }
}
public extension OriBandwithDetailItem{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: OriBandwithDetailItemCodingKeys.self)
         try encoderContainer.encode(timeStamp, forKey: .timeStamp)
         try encoderContainer.encode(avgoribandwidth, forKey: .avgoribandwidth)
    }
}
///  totalDetalItem
public class TotalDetalItem:NSObject,Codable{
    /// Data
    var data:AnyObject?
    /// OriData
    var oriData:AnyObject?
    /// TimeStamp
    var timeStamp:Int64?



    public override init(){
            super.init()
    }

    enum TotalDetalItemCodingKeys: String, CodingKey {
        case data
        case oriData
        case timeStamp
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: TotalDetalItemCodingKeys.self)
        if decoderContainer.contains(.timeStamp)
        {
            self.timeStamp = try decoderContainer.decode(Int64?.self, forKey: .timeStamp)
        }
    }
}
public extension TotalDetalItem{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: TotalDetalItemCodingKeys.self)
         try encoderContainer.encode(timeStamp, forKey: .timeStamp)
    }
}
///  oriDiagramItem
public class OriDiagramItem:NSObject,Codable{
    /// OriRatio
    var oriRatio:String?
    /// Avgbandwidth
    var avgbandwidth:Double?
    /// Avgoribandwidth
    var avgoribandwidth:Double?
    /// TimeStamp
    var timeStamp:Int64?



    public override init(){
            super.init()
    }

    enum OriDiagramItemCodingKeys: String, CodingKey {
        case oriRatio
        case avgbandwidth
        case avgoribandwidth
        case timeStamp
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: OriDiagramItemCodingKeys.self)
        if decoderContainer.contains(.oriRatio)
        {
            self.oriRatio = try decoderContainer.decode(String?.self, forKey: .oriRatio)
        }
        if decoderContainer.contains(.avgbandwidth)
        {
            self.avgbandwidth = try decoderContainer.decode(Double?.self, forKey: .avgbandwidth)
        }
        if decoderContainer.contains(.avgoribandwidth)
        {
            self.avgoribandwidth = try decoderContainer.decode(Double?.self, forKey: .avgoribandwidth)
        }
        if decoderContainer.contains(.timeStamp)
        {
            self.timeStamp = try decoderContainer.decode(Int64?.self, forKey: .timeStamp)
        }
    }
}
public extension OriDiagramItem{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: OriDiagramItemCodingKeys.self)
         try encoderContainer.encode(oriRatio, forKey: .oriRatio)
         try encoderContainer.encode(avgbandwidth, forKey: .avgbandwidth)
         try encoderContainer.encode(avgoribandwidth, forKey: .avgoribandwidth)
         try encoderContainer.encode(timeStamp, forKey: .timeStamp)
    }
}
///  overviewTrafficDetailItem
public class OverviewTrafficDetailItem:NSObject,Codable{
    /// Data
    var data:Int64?
    /// TimeStamp
    var timeStamp:String?



    public override init(){
            super.init()
    }

    enum OverviewTrafficDetailItemCodingKeys: String, CodingKey {
        case data
        case timeStamp
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: OverviewTrafficDetailItemCodingKeys.self)
        if decoderContainer.contains(.data)
        {
            self.data = try decoderContainer.decode(Int64?.self, forKey: .data)
        }
        if decoderContainer.contains(.timeStamp)
        {
            self.timeStamp = try decoderContainer.decode(String?.self, forKey: .timeStamp)
        }
    }
}
public extension OverviewTrafficDetailItem{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: OverviewTrafficDetailItemCodingKeys.self)
         try encoderContainer.encode(data, forKey: .data)
         try encoderContainer.encode(timeStamp, forKey: .timeStamp)
    }
}
///  oribandwidthTopItem
public class OribandwidthTopItem:NSObject,Codable{
    /// Name
    var name:String?
    /// Total
    var total:Double?
    /// Details
    var details:[OriBandwithDetailItem?]?



    public override init(){
            super.init()
    }

    enum OribandwidthTopItemCodingKeys: String, CodingKey {
        case name
        case total
        case details
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: OribandwidthTopItemCodingKeys.self)
        if decoderContainer.contains(.name)
        {
            self.name = try decoderContainer.decode(String?.self, forKey: .name)
        }
        if decoderContainer.contains(.total)
        {
            self.total = try decoderContainer.decode(Double?.self, forKey: .total)
        }
        if decoderContainer.contains(.details)
        {
            self.details = try decoderContainer.decode([OriBandwithDetailItem?]?.self, forKey: .details)
        }
    }
}
public extension OribandwidthTopItem{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: OribandwidthTopItemCodingKeys.self)
         try encoderContainer.encode(name, forKey: .name)
         try encoderContainer.encode(total, forKey: .total)
         try encoderContainer.encode(details, forKey: .details)
    }
}
///  areaIspbdwDetailItem
public class AreaIspbdwDetailItem:NSObject,Codable{
    /// Area
    var area:String?
    /// Isp
    var isp:String?
    /// FlowPercent
    var flowPercent:String?
    /// PvPercent
    var pvPercent:String?
    /// Avgbandwidth
    var avgbandwidth:Double?
    /// Flow
    var flow:Double?
    /// Pv
    var pv:Int64?
    /// TopTimeStamp
    var topTimeStamp:Int64?



    public override init(){
            super.init()
    }

    enum AreaIspbdwDetailItemCodingKeys: String, CodingKey {
        case area
        case isp
        case flowPercent
        case pvPercent
        case avgbandwidth
        case flow
        case pv
        case topTimeStamp
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: AreaIspbdwDetailItemCodingKeys.self)
        if decoderContainer.contains(.area)
        {
            self.area = try decoderContainer.decode(String?.self, forKey: .area)
        }
        if decoderContainer.contains(.isp)
        {
            self.isp = try decoderContainer.decode(String?.self, forKey: .isp)
        }
        if decoderContainer.contains(.flowPercent)
        {
            self.flowPercent = try decoderContainer.decode(String?.self, forKey: .flowPercent)
        }
        if decoderContainer.contains(.pvPercent)
        {
            self.pvPercent = try decoderContainer.decode(String?.self, forKey: .pvPercent)
        }
        if decoderContainer.contains(.avgbandwidth)
        {
            self.avgbandwidth = try decoderContainer.decode(Double?.self, forKey: .avgbandwidth)
        }
        if decoderContainer.contains(.flow)
        {
            self.flow = try decoderContainer.decode(Double?.self, forKey: .flow)
        }
        if decoderContainer.contains(.pv)
        {
            self.pv = try decoderContainer.decode(Int64?.self, forKey: .pv)
        }
        if decoderContainer.contains(.topTimeStamp)
        {
            self.topTimeStamp = try decoderContainer.decode(Int64?.self, forKey: .topTimeStamp)
        }
    }
}
public extension AreaIspbdwDetailItem{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: AreaIspbdwDetailItemCodingKeys.self)
         try encoderContainer.encode(area, forKey: .area)
         try encoderContainer.encode(isp, forKey: .isp)
         try encoderContainer.encode(flowPercent, forKey: .flowPercent)
         try encoderContainer.encode(pvPercent, forKey: .pvPercent)
         try encoderContainer.encode(avgbandwidth, forKey: .avgbandwidth)
         try encoderContainer.encode(flow, forKey: .flow)
         try encoderContainer.encode(pv, forKey: .pv)
         try encoderContainer.encode(topTimeStamp, forKey: .topTimeStamp)
    }
}
///  areaIspItem
public class AreaIspItem:NSObject,Codable{
    /// Description
    var descriptionValue:String?
    /// Code
    var code:String?



    public override init(){
            super.init()
    }

    enum AreaIspItemCodingKeys: String, CodingKey {
        case descriptionValue = "description"
        case code
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: AreaIspItemCodingKeys.self)
        if decoderContainer.contains(.descriptionValue)
        {
            self.descriptionValue = try decoderContainer.decode(String?.self, forKey: .descriptionValue)
        }
        if decoderContainer.contains(.code)
        {
            self.code = try decoderContainer.decode(String?.self, forKey: .code)
        }
    }
}
public extension AreaIspItem{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: AreaIspItemCodingKeys.self)
         try encoderContainer.encode(descriptionValue, forKey: .descriptionValue)
         try encoderContainer.encode(code, forKey: .code)
    }
}
///  attackDetail
public class AttackDetail:NSObject,Codable{
    /// 请求id
    var requestId:String?
    /// 攻击来源ip
    var ip:String?
    /// 攻击来源地域
    var area:String?
    /// 攻击流量(MB)
    var flow:String?
    /// 攻击时间
    var timeUtc:String?
    /// 攻击方法（post，get等）
    var method:String?
    /// 攻击url
    var url:String?
    /// 攻击类型
    var attackType:String?
    /// 针对该攻击做出的动作
    var action:String?



    public override init(){
            super.init()
    }

    enum AttackDetailCodingKeys: String, CodingKey {
        case requestId
        case ip
        case area
        case flow
        case timeUtc
        case method
        case url
        case attackType
        case action
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: AttackDetailCodingKeys.self)
        if decoderContainer.contains(.requestId)
        {
            self.requestId = try decoderContainer.decode(String?.self, forKey: .requestId)
        }
        if decoderContainer.contains(.ip)
        {
            self.ip = try decoderContainer.decode(String?.self, forKey: .ip)
        }
        if decoderContainer.contains(.area)
        {
            self.area = try decoderContainer.decode(String?.self, forKey: .area)
        }
        if decoderContainer.contains(.flow)
        {
            self.flow = try decoderContainer.decode(String?.self, forKey: .flow)
        }
        if decoderContainer.contains(.timeUtc)
        {
            self.timeUtc = try decoderContainer.decode(String?.self, forKey: .timeUtc)
        }
        if decoderContainer.contains(.method)
        {
            self.method = try decoderContainer.decode(String?.self, forKey: .method)
        }
        if decoderContainer.contains(.url)
        {
            self.url = try decoderContainer.decode(String?.self, forKey: .url)
        }
        if decoderContainer.contains(.attackType)
        {
            self.attackType = try decoderContainer.decode(String?.self, forKey: .attackType)
        }
        if decoderContainer.contains(.action)
        {
            self.action = try decoderContainer.decode(String?.self, forKey: .action)
        }
    }
}
public extension AttackDetail{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: AttackDetailCodingKeys.self)
         try encoderContainer.encode(requestId, forKey: .requestId)
         try encoderContainer.encode(ip, forKey: .ip)
         try encoderContainer.encode(area, forKey: .area)
         try encoderContainer.encode(flow, forKey: .flow)
         try encoderContainer.encode(timeUtc, forKey: .timeUtc)
         try encoderContainer.encode(method, forKey: .method)
         try encoderContainer.encode(url, forKey: .url)
         try encoderContainer.encode(attackType, forKey: .attackType)
         try encoderContainer.encode(action, forKey: .action)
    }
}
///  ipData
public class IpData:NSObject,Codable{
    /// ip地址
    var ip:String?
    /// 该ip的全部攻击pv
    var pv:Int?



    public override init(){
            super.init()
    }

    enum IpDataCodingKeys: String, CodingKey {
        case ip
        case pv
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: IpDataCodingKeys.self)
        if decoderContainer.contains(.ip)
        {
            self.ip = try decoderContainer.decode(String?.self, forKey: .ip)
        }
        if decoderContainer.contains(.pv)
        {
            self.pv = try decoderContainer.decode(Int?.self, forKey: .pv)
        }
    }
}
public extension IpData{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: IpDataCodingKeys.self)
         try encoderContainer.encode(ip, forKey: .ip)
         try encoderContainer.encode(pv, forKey: .pv)
    }
}
///  areaData
public class AreaData:NSObject,Codable{
    /// 省份信息（中文）
    var area:String?
    /// 该省份的全部攻击pv
    var totalPv:Int?
    /// 该省份省会的经纬度
    var location:[String?]?
    /// 分ip的pv统计结果
    var ipDatas:[IpData?]?



    public override init(){
            super.init()
    }

    enum AreaDataCodingKeys: String, CodingKey {
        case area
        case totalPv
        case location
        case ipDatas
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: AreaDataCodingKeys.self)
        if decoderContainer.contains(.area)
        {
            self.area = try decoderContainer.decode(String?.self, forKey: .area)
        }
        if decoderContainer.contains(.totalPv)
        {
            self.totalPv = try decoderContainer.decode(Int?.self, forKey: .totalPv)
        }
        if decoderContainer.contains(.location)
        {
            self.location = try decoderContainer.decode([String?]?.self, forKey: .location)
        }
        if decoderContainer.contains(.ipDatas)
        {
            self.ipDatas = try decoderContainer.decode([IpData?]?.self, forKey: .ipDatas)
        }
    }
}
public extension AreaData{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: AreaDataCodingKeys.self)
         try encoderContainer.encode(area, forKey: .area)
         try encoderContainer.encode(totalPv, forKey: .totalPv)
         try encoderContainer.encode(location, forKey: .location)
         try encoderContainer.encode(ipDatas, forKey: .ipDatas)
    }
}
///  pvItem
public class PvItem:NSObject,Codable{
    /// UTC时间，格式为:yyyy-MM-dd&#39;T&#39;HH:mm:ss&#39;Z&#39;，示例:2018-10-21T10:00:00Z
    var timeUtc:String?
    /// 总请求量
    var totalPv:Int?
    /// 攻击请求量
    var attackPv:Int?



    public override init(){
            super.init()
    }

    enum PvItemCodingKeys: String, CodingKey {
        case timeUtc
        case totalPv
        case attackPv
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: PvItemCodingKeys.self)
        if decoderContainer.contains(.timeUtc)
        {
            self.timeUtc = try decoderContainer.decode(String?.self, forKey: .timeUtc)
        }
        if decoderContainer.contains(.totalPv)
        {
            self.totalPv = try decoderContainer.decode(Int?.self, forKey: .totalPv)
        }
        if decoderContainer.contains(.attackPv)
        {
            self.attackPv = try decoderContainer.decode(Int?.self, forKey: .attackPv)
        }
    }
}
public extension PvItem{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: PvItemCodingKeys.self)
         try encoderContainer.encode(timeUtc, forKey: .timeUtc)
         try encoderContainer.encode(totalPv, forKey: .totalPv)
         try encoderContainer.encode(attackPv, forKey: .attackPv)
    }
}
///  checkWhetherIpBelongToJCloudItem
public class CheckWhetherIpBelongToJCloudItem:NSObject,Codable{
    /// Ip
    var ip:String?
    /// BelongToJCloud
    var belongToJCloud:Bool?
    /// Country
    var country:String?
    /// Province
    var province:String?
    /// Isp
    var isp:String?



    public override init(){
            super.init()
    }

    enum CheckWhetherIpBelongToJCloudItemCodingKeys: String, CodingKey {
        case ip
        case belongToJCloud
        case country
        case province
        case isp
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: CheckWhetherIpBelongToJCloudItemCodingKeys.self)
        if decoderContainer.contains(.ip)
        {
            self.ip = try decoderContainer.decode(String?.self, forKey: .ip)
        }
        if decoderContainer.contains(.belongToJCloud)
        {
            self.belongToJCloud = try decoderContainer.decode(Bool?.self, forKey: .belongToJCloud)
        }
        if decoderContainer.contains(.country)
        {
            self.country = try decoderContainer.decode(String?.self, forKey: .country)
        }
        if decoderContainer.contains(.province)
        {
            self.province = try decoderContainer.decode(String?.self, forKey: .province)
        }
        if decoderContainer.contains(.isp)
        {
            self.isp = try decoderContainer.decode(String?.self, forKey: .isp)
        }
    }
}
public extension CheckWhetherIpBelongToJCloudItem{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: CheckWhetherIpBelongToJCloudItemCodingKeys.self)
         try encoderContainer.encode(ip, forKey: .ip)
         try encoderContainer.encode(belongToJCloud, forKey: .belongToJCloud)
         try encoderContainer.encode(country, forKey: .country)
         try encoderContainer.encode(province, forKey: .province)
         try encoderContainer.encode(isp, forKey: .isp)
    }
}
///  queryLivePrefetchItem
public class QueryLivePrefetchItem:NSObject,Codable{
    /// Stream
    var stream:String?
    /// Code
    var code:Int?
    /// Message
    var message:String?



    public override init(){
            super.init()
    }

    enum QueryLivePrefetchItemCodingKeys: String, CodingKey {
        case stream
        case code
        case message
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: QueryLivePrefetchItemCodingKeys.self)
        if decoderContainer.contains(.stream)
        {
            self.stream = try decoderContainer.decode(String?.self, forKey: .stream)
        }
        if decoderContainer.contains(.code)
        {
            self.code = try decoderContainer.decode(Int?.self, forKey: .code)
        }
        if decoderContainer.contains(.message)
        {
            self.message = try decoderContainer.decode(String?.self, forKey: .message)
        }
    }
}
public extension QueryLivePrefetchItem{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: QueryLivePrefetchItemCodingKeys.self)
         try encoderContainer.encode(stream, forKey: .stream)
         try encoderContainer.encode(code, forKey: .code)
         try encoderContainer.encode(message, forKey: .message)
    }
}
///  streamHistoryInfoForYY
public class StreamHistoryInfoForYY:NSObject,Codable{
    /// UTC时间，格式为:yyyy-MM-dd&#39;T&#39;HH:mm:ss&#39;Z&#39;，示例:2018-10-21T10:00:00Z
    var startTime:String?
    /// UTC时间，格式为:yyyy-MM-dd&#39;T&#39;HH:mm:ss&#39;Z&#39;，示例:2018-10-21T10:00:00Z
    var endTime:String?
    /// Avgupspeed
    var avgupspeed:Int64?
    /// Avgupframerate
    var avgupframerate:Int64?
    /// PushEdgeNodeIps
    var pushEdgeNodeIps:[String?]?
    /// AnchorIps
    var anchorIps:[String?]?
    /// FlvBandWidth
    var flvBandWidth:Int64?
    /// FlvPlayerCount
    var flvPlayerCount:Int64?
    /// HlsBandWidth
    var hlsBandWidth:Int64?
    /// HlsPlayerCount
    var hlsPlayerCount:Int64?



    public override init(){
            super.init()
    }

    enum StreamHistoryInfoForYYCodingKeys: String, CodingKey {
        case startTime
        case endTime
        case avgupspeed
        case avgupframerate
        case pushEdgeNodeIps
        case anchorIps
        case flvBandWidth
        case flvPlayerCount
        case hlsBandWidth
        case hlsPlayerCount
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: StreamHistoryInfoForYYCodingKeys.self)
        if decoderContainer.contains(.startTime)
        {
            self.startTime = try decoderContainer.decode(String?.self, forKey: .startTime)
        }
        if decoderContainer.contains(.endTime)
        {
            self.endTime = try decoderContainer.decode(String?.self, forKey: .endTime)
        }
        if decoderContainer.contains(.avgupspeed)
        {
            self.avgupspeed = try decoderContainer.decode(Int64?.self, forKey: .avgupspeed)
        }
        if decoderContainer.contains(.avgupframerate)
        {
            self.avgupframerate = try decoderContainer.decode(Int64?.self, forKey: .avgupframerate)
        }
        if decoderContainer.contains(.pushEdgeNodeIps)
        {
            self.pushEdgeNodeIps = try decoderContainer.decode([String?]?.self, forKey: .pushEdgeNodeIps)
        }
        if decoderContainer.contains(.anchorIps)
        {
            self.anchorIps = try decoderContainer.decode([String?]?.self, forKey: .anchorIps)
        }
        if decoderContainer.contains(.flvBandWidth)
        {
            self.flvBandWidth = try decoderContainer.decode(Int64?.self, forKey: .flvBandWidth)
        }
        if decoderContainer.contains(.flvPlayerCount)
        {
            self.flvPlayerCount = try decoderContainer.decode(Int64?.self, forKey: .flvPlayerCount)
        }
        if decoderContainer.contains(.hlsBandWidth)
        {
            self.hlsBandWidth = try decoderContainer.decode(Int64?.self, forKey: .hlsBandWidth)
        }
        if decoderContainer.contains(.hlsPlayerCount)
        {
            self.hlsPlayerCount = try decoderContainer.decode(Int64?.self, forKey: .hlsPlayerCount)
        }
    }
}
public extension StreamHistoryInfoForYY{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: StreamHistoryInfoForYYCodingKeys.self)
         try encoderContainer.encode(startTime, forKey: .startTime)
         try encoderContainer.encode(endTime, forKey: .endTime)
         try encoderContainer.encode(avgupspeed, forKey: .avgupspeed)
         try encoderContainer.encode(avgupframerate, forKey: .avgupframerate)
         try encoderContainer.encode(pushEdgeNodeIps, forKey: .pushEdgeNodeIps)
         try encoderContainer.encode(anchorIps, forKey: .anchorIps)
         try encoderContainer.encode(flvBandWidth, forKey: .flvBandWidth)
         try encoderContainer.encode(flvPlayerCount, forKey: .flvPlayerCount)
         try encoderContainer.encode(hlsBandWidth, forKey: .hlsBandWidth)
         try encoderContainer.encode(hlsPlayerCount, forKey: .hlsPlayerCount)
    }
}
///  streamRankingForYY
public class StreamRankingForYY:NSObject,Codable{
    /// StreamName
    var streamName:String?
    /// Ranking
    var ranking:Int?
    /// PlayerCount
    var playerCount:Int64?



    public override init(){
            super.init()
    }

    enum StreamRankingForYYCodingKeys: String, CodingKey {
        case streamName
        case ranking
        case playerCount
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: StreamRankingForYYCodingKeys.self)
        if decoderContainer.contains(.streamName)
        {
            self.streamName = try decoderContainer.decode(String?.self, forKey: .streamName)
        }
        if decoderContainer.contains(.ranking)
        {
            self.ranking = try decoderContainer.decode(Int?.self, forKey: .ranking)
        }
        if decoderContainer.contains(.playerCount)
        {
            self.playerCount = try decoderContainer.decode(Int64?.self, forKey: .playerCount)
        }
    }
}
public extension StreamRankingForYY{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: StreamRankingForYYCodingKeys.self)
         try encoderContainer.encode(streamName, forKey: .streamName)
         try encoderContainer.encode(ranking, forKey: .ranking)
         try encoderContainer.encode(playerCount, forKey: .playerCount)
    }
}
///  bandTrafficWithAreaDataItem
public class BandTrafficWithAreaDataItem:NSObject,Codable{
    /// 域名
    var domain:String?
    /// Data
    var data:[DomainBandAreaTrafficDataItem?]?



    public override init(){
            super.init()
    }

    enum BandTrafficWithAreaDataItemCodingKeys: String, CodingKey {
        case domain
        case data
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: BandTrafficWithAreaDataItemCodingKeys.self)
        if decoderContainer.contains(.domain)
        {
            self.domain = try decoderContainer.decode(String?.self, forKey: .domain)
        }
        if decoderContainer.contains(.data)
        {
            self.data = try decoderContainer.decode([DomainBandAreaTrafficDataItem?]?.self, forKey: .data)
        }
    }
}
public extension BandTrafficWithAreaDataItem{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: BandTrafficWithAreaDataItemCodingKeys.self)
         try encoderContainer.encode(domain, forKey: .domain)
         try encoderContainer.encode(data, forKey: .data)
    }
}
///  domainBandTrafficDataItem
public class DomainBandTrafficDataItem:NSObject,Codable{
    /// 开始时间戳
    var startTimeStamp:String?
    /// 开始时间戳
    var endTimeStamp:String?
    /// 带宽单位Mbps
    var avgbandwidth:Double?
    /// 流量单位MB
    var flow:Double?
    /// 请求量
    var pv:Int64?



    public override init(){
            super.init()
    }

    enum DomainBandTrafficDataItemCodingKeys: String, CodingKey {
        case startTimeStamp
        case endTimeStamp
        case avgbandwidth
        case flow
        case pv
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: DomainBandTrafficDataItemCodingKeys.self)
        if decoderContainer.contains(.startTimeStamp)
        {
            self.startTimeStamp = try decoderContainer.decode(String?.self, forKey: .startTimeStamp)
        }
        if decoderContainer.contains(.endTimeStamp)
        {
            self.endTimeStamp = try decoderContainer.decode(String?.self, forKey: .endTimeStamp)
        }
        if decoderContainer.contains(.avgbandwidth)
        {
            self.avgbandwidth = try decoderContainer.decode(Double?.self, forKey: .avgbandwidth)
        }
        if decoderContainer.contains(.flow)
        {
            self.flow = try decoderContainer.decode(Double?.self, forKey: .flow)
        }
        if decoderContainer.contains(.pv)
        {
            self.pv = try decoderContainer.decode(Int64?.self, forKey: .pv)
        }
    }
}
public extension DomainBandTrafficDataItem{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: DomainBandTrafficDataItemCodingKeys.self)
         try encoderContainer.encode(startTimeStamp, forKey: .startTimeStamp)
         try encoderContainer.encode(endTimeStamp, forKey: .endTimeStamp)
         try encoderContainer.encode(avgbandwidth, forKey: .avgbandwidth)
         try encoderContainer.encode(flow, forKey: .flow)
         try encoderContainer.encode(pv, forKey: .pv)
    }
}
///  domainBandAreaTrafficDataItem
public class DomainBandAreaTrafficDataItem:NSObject,Codable{
    /// 开始时间戳
    var startTimeStamp:String?
    /// 开始时间戳
    var endTimeStamp:String?
    /// 带宽单位Mbps
    var avgbandwidth:Double?
    /// 流量单位MB
    var flow:Double?
    /// 请求量
    var pv:Int64?
    /// 地域
    var area:String?
    /// 运营商
    var isp:String?



    public override init(){
            super.init()
    }

    enum DomainBandAreaTrafficDataItemCodingKeys: String, CodingKey {
        case startTimeStamp
        case endTimeStamp
        case avgbandwidth
        case flow
        case pv
        case area
        case isp
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: DomainBandAreaTrafficDataItemCodingKeys.self)
        if decoderContainer.contains(.startTimeStamp)
        {
            self.startTimeStamp = try decoderContainer.decode(String?.self, forKey: .startTimeStamp)
        }
        if decoderContainer.contains(.endTimeStamp)
        {
            self.endTimeStamp = try decoderContainer.decode(String?.self, forKey: .endTimeStamp)
        }
        if decoderContainer.contains(.avgbandwidth)
        {
            self.avgbandwidth = try decoderContainer.decode(Double?.self, forKey: .avgbandwidth)
        }
        if decoderContainer.contains(.flow)
        {
            self.flow = try decoderContainer.decode(Double?.self, forKey: .flow)
        }
        if decoderContainer.contains(.pv)
        {
            self.pv = try decoderContainer.decode(Int64?.self, forKey: .pv)
        }
        if decoderContainer.contains(.area)
        {
            self.area = try decoderContainer.decode(String?.self, forKey: .area)
        }
        if decoderContainer.contains(.isp)
        {
            self.isp = try decoderContainer.decode(String?.self, forKey: .isp)
        }
    }
}
public extension DomainBandAreaTrafficDataItem{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: DomainBandAreaTrafficDataItemCodingKeys.self)
         try encoderContainer.encode(startTimeStamp, forKey: .startTimeStamp)
         try encoderContainer.encode(endTimeStamp, forKey: .endTimeStamp)
         try encoderContainer.encode(avgbandwidth, forKey: .avgbandwidth)
         try encoderContainer.encode(flow, forKey: .flow)
         try encoderContainer.encode(pv, forKey: .pv)
         try encoderContainer.encode(area, forKey: .area)
         try encoderContainer.encode(isp, forKey: .isp)
    }
}
///  bandTrafficDataItem
public class BandTrafficDataItem:NSObject,Codable{
    /// 域名
    var domain:String?
    /// Data
    var data:[DomainBandTrafficDataItem?]?



    public override init(){
            super.init()
    }

    enum BandTrafficDataItemCodingKeys: String, CodingKey {
        case domain
        case data
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: BandTrafficDataItemCodingKeys.self)
        if decoderContainer.contains(.domain)
        {
            self.domain = try decoderContainer.decode(String?.self, forKey: .domain)
        }
        if decoderContainer.contains(.data)
        {
            self.data = try decoderContainer.decode([DomainBandTrafficDataItem?]?.self, forKey: .data)
        }
    }
}
public extension BandTrafficDataItem{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: BandTrafficDataItemCodingKeys.self)
         try encoderContainer.encode(domain, forKey: .domain)
         try encoderContainer.encode(data, forKey: .data)
    }
}
///  null
public class Action:NSObject,Codable{
    /// 1：forbidden，493封禁并返回自定义页面 2：redirect，302跳转 3： verify@captcha 4： verify@jscookie
    var atOp:Int32?
    /// action为1时为自定义页面名称,缺省为默认页面，2时为跳转url，其他时无效
    var atVal:String?



    public override init(){
            super.init()
    }

    enum ActionCodingKeys: String, CodingKey {
        case atOp
        case atVal
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: ActionCodingKeys.self)
        if decoderContainer.contains(.atOp)
        {
            self.atOp = try decoderContainer.decode(Int32?.self, forKey: .atOp)
        }
        if decoderContainer.contains(.atVal)
        {
            self.atVal = try decoderContainer.decode(String?.self, forKey: .atVal)
        }
    }
}
public extension Action{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: ActionCodingKeys.self)
         try encoderContainer.encode(atOp, forKey: .atOp)
         try encoderContainer.encode(atVal, forKey: .atVal)
    }
}
///  extraCacheTime
public class ExtraCacheTime:NSObject,Codable{
    /// http状态码
    var httpCode:String?
    /// 缓存时间
    var cacheTime:Int64?



    public override init(){
            super.init()
    }

    enum ExtraCacheTimeCodingKeys: String, CodingKey {
        case httpCode
        case cacheTime
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: ExtraCacheTimeCodingKeys.self)
        if decoderContainer.contains(.httpCode)
        {
            self.httpCode = try decoderContainer.decode(String?.self, forKey: .httpCode)
        }
        if decoderContainer.contains(.cacheTime)
        {
            self.cacheTime = try decoderContainer.decode(Int64?.self, forKey: .cacheTime)
        }
    }
}
public extension ExtraCacheTime{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: ExtraCacheTimeCodingKeys.self)
         try encoderContainer.encode(httpCode, forKey: .httpCode)
         try encoderContainer.encode(cacheTime, forKey: .cacheTime)
    }
}
///  setSourceBody
public class SetSourceBody:NSObject,Codable{
    /// 回源类型只能是[ips,domain,oss]中的一种
    var sourceType:String?
    /// 回源类型，目前只能为rtmp
    var backSourceType:String?
    /// IpSource
    var ipSource:[IpSourceInfo?]?
    /// DomainSource
    var domainSource:[DomainSourceInfo?]?
    /// OssSource
    var ossSource:String?
    /// DefaultSourceHost
    var defaultSourceHost:String?



    public override init(){
            super.init()
    }

    enum SetSourceBodyCodingKeys: String, CodingKey {
        case sourceType
        case backSourceType
        case ipSource
        case domainSource
        case ossSource
        case defaultSourceHost
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: SetSourceBodyCodingKeys.self)
        if decoderContainer.contains(.sourceType)
        {
            self.sourceType = try decoderContainer.decode(String?.self, forKey: .sourceType)
        }
        if decoderContainer.contains(.backSourceType)
        {
            self.backSourceType = try decoderContainer.decode(String?.self, forKey: .backSourceType)
        }
        if decoderContainer.contains(.ipSource)
        {
            self.ipSource = try decoderContainer.decode([IpSourceInfo?]?.self, forKey: .ipSource)
        }
        if decoderContainer.contains(.domainSource)
        {
            self.domainSource = try decoderContainer.decode([DomainSourceInfo?]?.self, forKey: .domainSource)
        }
        if decoderContainer.contains(.ossSource)
        {
            self.ossSource = try decoderContainer.decode(String?.self, forKey: .ossSource)
        }
        if decoderContainer.contains(.defaultSourceHost)
        {
            self.defaultSourceHost = try decoderContainer.decode(String?.self, forKey: .defaultSourceHost)
        }
    }
}
public extension SetSourceBody{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: SetSourceBodyCodingKeys.self)
         try encoderContainer.encode(sourceType, forKey: .sourceType)
         try encoderContainer.encode(backSourceType, forKey: .backSourceType)
         try encoderContainer.encode(ipSource, forKey: .ipSource)
         try encoderContainer.encode(domainSource, forKey: .domainSource)
         try encoderContainer.encode(ossSource, forKey: .ossSource)
         try encoderContainer.encode(defaultSourceHost, forKey: .defaultSourceHost)
    }
}
///  statisticsData
public class StatisticsData:NSObject,Codable{
    /// UTC时间，格式为:yyyy-MM-dd&#39;T&#39;HH:mm:ss&#39;Z&#39;，示例:2018-10-21T10:00:00Z
    var startTime:String?
    /// UTC时间，格式为:yyyy-MM-dd&#39;T&#39;HH:mm:ss&#39;Z&#39;，示例:2018-10-21T10:00:00Z
    var endTime:String?
    /// Domain
    var domain:String?
    /// DataItemList
    var dataItemList:[StatisticsDataItem?]?



    public override init(){
            super.init()
    }

    enum StatisticsDataCodingKeys: String, CodingKey {
        case startTime
        case endTime
        case domain
        case dataItemList
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: StatisticsDataCodingKeys.self)
        if decoderContainer.contains(.startTime)
        {
            self.startTime = try decoderContainer.decode(String?.self, forKey: .startTime)
        }
        if decoderContainer.contains(.endTime)
        {
            self.endTime = try decoderContainer.decode(String?.self, forKey: .endTime)
        }
        if decoderContainer.contains(.domain)
        {
            self.domain = try decoderContainer.decode(String?.self, forKey: .domain)
        }
        if decoderContainer.contains(.dataItemList)
        {
            self.dataItemList = try decoderContainer.decode([StatisticsDataItem?]?.self, forKey: .dataItemList)
        }
    }
}
public extension StatisticsData{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: StatisticsDataCodingKeys.self)
         try encoderContainer.encode(startTime, forKey: .startTime)
         try encoderContainer.encode(endTime, forKey: .endTime)
         try encoderContainer.encode(domain, forKey: .domain)
         try encoderContainer.encode(dataItemList, forKey: .dataItemList)
    }
}

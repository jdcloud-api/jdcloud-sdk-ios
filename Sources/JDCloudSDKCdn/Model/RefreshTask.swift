/* Copyright 2018 JDCLOUD.COM

   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at

     http:#www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.

   
   

   
   Contact: 

   NOTE: This class is auto generated by the jdcloud code generator program.
 */


import Foundation

///  refreshTask
@objc(RefreshTask)
public class RefreshTask:NSObject,Codable{
    /// 任务创建时间,UTC时间
    var createDate:String?
    /// 任务失败率
    var failed:Double?
    /// 任务成功率
    var success:Double?
    /// 刷新预热的任务id
    var taskId:String?
    /// 数据库表id
    var id:Int64?
    /// 重试状态(unretry:不重试,retry:重试)
    var retryStatus:String?
    /// 任务状态(running:执行中,success:成功,failed:失败)
    var taskStatus:String?
    /// 刷新预热类型,(url:url刷新,dir:目录刷新,prefetch:预热)
    var taskType:String?
    /// 详细的任务
    var urlTasks:[UrlTask?]?



    public override init(){
            super.init()
    }

    enum RefreshTaskCodingKeys: String, CodingKey {
        case createDate
        case failed
        case success
        case taskId
        case id
        case retryStatus
        case taskStatus
        case taskType
        case urlTasks
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: RefreshTaskCodingKeys.self)
        if decoderContainer.contains(.createDate)
        {
            self.createDate = try decoderContainer.decode(String?.self, forKey: .createDate)
        }
        if decoderContainer.contains(.failed)
        {
            self.failed = try decoderContainer.decode(Double?.self, forKey: .failed)
        }
        if decoderContainer.contains(.success)
        {
            self.success = try decoderContainer.decode(Double?.self, forKey: .success)
        }
        if decoderContainer.contains(.taskId)
        {
            self.taskId = try decoderContainer.decode(String?.self, forKey: .taskId)
        }
        if decoderContainer.contains(.id)
        {
            self.id = try decoderContainer.decode(Int64?.self, forKey: .id)
        }
        if decoderContainer.contains(.retryStatus)
        {
            self.retryStatus = try decoderContainer.decode(String?.self, forKey: .retryStatus)
        }
        if decoderContainer.contains(.taskStatus)
        {
            self.taskStatus = try decoderContainer.decode(String?.self, forKey: .taskStatus)
        }
        if decoderContainer.contains(.taskType)
        {
            self.taskType = try decoderContainer.decode(String?.self, forKey: .taskType)
        }
        if decoderContainer.contains(.urlTasks)
        {
            self.urlTasks = try decoderContainer.decode([UrlTask?]?.self, forKey: .urlTasks)
        }
    }
}
public extension RefreshTask{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: RefreshTaskCodingKeys.self)
         try encoderContainer.encode(createDate, forKey: .createDate)
         try encoderContainer.encode(failed, forKey: .failed)
         try encoderContainer.encode(success, forKey: .success)
         try encoderContainer.encode(taskId, forKey: .taskId)
         try encoderContainer.encode(id, forKey: .id)
         try encoderContainer.encode(retryStatus, forKey: .retryStatus)
         try encoderContainer.encode(taskStatus, forKey: .taskStatus)
         try encoderContainer.encode(taskType, forKey: .taskType)
         try encoderContainer.encode(urlTasks, forKey: .urlTasks)
    }
}

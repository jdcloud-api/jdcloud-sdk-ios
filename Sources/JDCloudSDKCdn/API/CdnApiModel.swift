/* Copyright 2018 JDCLOUD.COM

   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at

     http:#www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.

   统计查询类接口
   Openapi For JCLOUD cdn

   OpenAPI spec version: v1
   Contact: pid-cdn@jd.com

   NOTE: This class is auto generated by the jdcloud code generator program.
 */


import Foundation
import JDCloudSDKCore

public class QueryPushDomainORAppOrStreamResponse:NSObject,Codable
{
    var requestId:String?;

    var error:ServiceError?;

    var result:QueryPushDomainORAppOrStreamResult?;

    enum QueryPushDomainORAppOrStreamResponseCodingKeys: String, CodingKey {
        case requestId
        case error
        case result
    }

    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: QueryPushDomainORAppOrStreamResponseCodingKeys.self)
        self.requestId = try decoderContainer.decodeIfPresent(String?.self, forKey: .requestId) ?? nil
        self.error = try decoderContainer.decodeIfPresent(ServiceError?.self, forKey: .error) ?? nil
        self.result = try decoderContainer.decodeIfPresent(QueryPushDomainORAppOrStreamResult?.self, forKey: .result) ?? nil
    }
}

public extension QueryPushDomainORAppOrStreamResponse{
        func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: QueryPushDomainORAppOrStreamResponseCodingKeys.self)
        try encoderContainer.encode(requestId, forKey: .requestId)
        try encoderContainer.encode(error, forKey: .error)
        try encoderContainer.encode(result, forKey: .result)
    }
}    
/// 设置推流中断超时时间 
public class SetPublishNormalTimeoutResult:NSObject,JdCloudResult
{
    /// 是否忽略参数
    var ignoreQueryString:String?

    /// 推流IP白名单（用逗号分隔）
    var pushIpWhiteList:String?

    /// 推流超时时间
    var publishNormalTimeout:Int?

    /// 推断流时，通知客户系统的URL
    var notifyCustomUrl:String?

    /// 通知客户系统的鉴权key
    var notifyCustomAuthKey:String?

    /// 转推鉴权类型（0：不鉴权，1：参数鉴权，2：URL鉴权）
    var forwardAccessKeyType:Int?

    /// 转推的鉴权key
    var forwardPrivateKey:String?

    /// 回源鉴权类型（0：不鉴权，1：参数鉴权，2：URL鉴权）
    var originAccessKeyType:Int?

    /// 回源的鉴权key
    var originPrivateKey:String?



    public override init(){
        super.init()
    }

    enum SetPublishNormalTimeoutResultCodingKeys: String, CodingKey {
        case ignoreQueryString
        case pushIpWhiteList
        case publishNormalTimeout
        case notifyCustomUrl
        case notifyCustomAuthKey
        case forwardAccessKeyType
        case forwardPrivateKey
        case originAccessKeyType
        case originPrivateKey
    }

    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: SetPublishNormalTimeoutResultCodingKeys.self)
        if decoderContainer.contains(.ignoreQueryString)
        {
            self.ignoreQueryString = try decoderContainer.decode(String?.self, forKey: .ignoreQueryString)
        }
        if decoderContainer.contains(.pushIpWhiteList)
        {
            self.pushIpWhiteList = try decoderContainer.decode(String?.self, forKey: .pushIpWhiteList)
        }
        if decoderContainer.contains(.publishNormalTimeout)
        {
            self.publishNormalTimeout = try decoderContainer.decode(Int?.self, forKey: .publishNormalTimeout)
        }
        if decoderContainer.contains(.notifyCustomUrl)
        {
            self.notifyCustomUrl = try decoderContainer.decode(String?.self, forKey: .notifyCustomUrl)
        }
        if decoderContainer.contains(.notifyCustomAuthKey)
        {
            self.notifyCustomAuthKey = try decoderContainer.decode(String?.self, forKey: .notifyCustomAuthKey)
        }
        if decoderContainer.contains(.forwardAccessKeyType)
        {
            self.forwardAccessKeyType = try decoderContainer.decode(Int?.self, forKey: .forwardAccessKeyType)
        }
        if decoderContainer.contains(.forwardPrivateKey)
        {
            self.forwardPrivateKey = try decoderContainer.decode(String?.self, forKey: .forwardPrivateKey)
        }
        if decoderContainer.contains(.originAccessKeyType)
        {
            self.originAccessKeyType = try decoderContainer.decode(Int?.self, forKey: .originAccessKeyType)
        }
        if decoderContainer.contains(.originPrivateKey)
        {
            self.originPrivateKey = try decoderContainer.decode(String?.self, forKey: .originPrivateKey)
        }
    }
}
public extension SetPublishNormalTimeoutResult{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: SetPublishNormalTimeoutResultCodingKeys.self)
        try encoderContainer.encode(ignoreQueryString, forKey: .ignoreQueryString)
        try encoderContainer.encode(pushIpWhiteList, forKey: .pushIpWhiteList)
        try encoderContainer.encode(publishNormalTimeout, forKey: .publishNormalTimeout)
        try encoderContainer.encode(notifyCustomUrl, forKey: .notifyCustomUrl)
        try encoderContainer.encode(notifyCustomAuthKey, forKey: .notifyCustomAuthKey)
        try encoderContainer.encode(forwardAccessKeyType, forKey: .forwardAccessKeyType)
        try encoderContainer.encode(forwardPrivateKey, forKey: .forwardPrivateKey)
        try encoderContainer.encode(originAccessKeyType, forKey: .originAccessKeyType)
        try encoderContainer.encode(originPrivateKey, forKey: .originPrivateKey)
    }
}

///  删除禁播流
public class DeleteForbiddenStreamRequest:JdCloudRequest
{
    /// 要删除的禁播流
    var deleteStreams:[DeleteStream?]?

    /// 用户域名
    var domain:String


    public init(regionId: String,domain:String){
        self.domain = domain
        super.init(regionId: regionId)
    }


    enum DeleteForbiddenStreamRequestRequestCodingKeys: String, CodingKey {
        case deleteStreams
        case domain
    }

    public override func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: DeleteForbiddenStreamRequestRequestCodingKeys.self)
        try encoderContainer.encode(deleteStreams, forKey: .deleteStreams)
        try encoderContainer.encode(domain, forKey: .domain)

    }
}

public class SetPushIpWhiteListResponse:NSObject,Codable
{
    var requestId:String?;

    var error:ServiceError?;

    var result:SetPushIpWhiteListResult?;

    enum SetPushIpWhiteListResponseCodingKeys: String, CodingKey {
        case requestId
        case error
        case result
    }

    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: SetPushIpWhiteListResponseCodingKeys.self)
        self.requestId = try decoderContainer.decodeIfPresent(String?.self, forKey: .requestId) ?? nil
        self.error = try decoderContainer.decodeIfPresent(ServiceError?.self, forKey: .error) ?? nil
        self.result = try decoderContainer.decodeIfPresent(SetPushIpWhiteListResult?.self, forKey: .result) ?? nil
    }
}

public extension SetPushIpWhiteListResponse{
        func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: SetPushIpWhiteListResponseCodingKeys.self)
        try encoderContainer.encode(requestId, forKey: .requestId)
        try encoderContainer.encode(error, forKey: .error)
        try encoderContainer.encode(result, forKey: .result)
    }
}    
/// 设置转推鉴权信息 
public class SetForwardAuthenticationResult:NSObject,JdCloudResult
{
    /// 是否忽略参数
    var ignoreQueryString:String?

    /// 推流IP白名单（用逗号分隔）
    var pushIpWhiteList:String?

    /// 推流超时时间
    var publishNormalTimeout:Int?

    /// 推断流时，通知客户系统的URL
    var notifyCustomUrl:String?

    /// 通知客户系统的鉴权key
    var notifyCustomAuthKey:String?

    /// 转推鉴权类型（0：不鉴权，1：参数鉴权，2：URL鉴权）
    var forwardAccessKeyType:Int?

    /// 转推的鉴权key
    var forwardPrivateKey:String?

    /// 回源鉴权类型（0：不鉴权，1：参数鉴权，2：URL鉴权）
    var originAccessKeyType:Int?

    /// 回源的鉴权key
    var originPrivateKey:String?



    public override init(){
        super.init()
    }

    enum SetForwardAuthenticationResultCodingKeys: String, CodingKey {
        case ignoreQueryString
        case pushIpWhiteList
        case publishNormalTimeout
        case notifyCustomUrl
        case notifyCustomAuthKey
        case forwardAccessKeyType
        case forwardPrivateKey
        case originAccessKeyType
        case originPrivateKey
    }

    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: SetForwardAuthenticationResultCodingKeys.self)
        if decoderContainer.contains(.ignoreQueryString)
        {
            self.ignoreQueryString = try decoderContainer.decode(String?.self, forKey: .ignoreQueryString)
        }
        if decoderContainer.contains(.pushIpWhiteList)
        {
            self.pushIpWhiteList = try decoderContainer.decode(String?.self, forKey: .pushIpWhiteList)
        }
        if decoderContainer.contains(.publishNormalTimeout)
        {
            self.publishNormalTimeout = try decoderContainer.decode(Int?.self, forKey: .publishNormalTimeout)
        }
        if decoderContainer.contains(.notifyCustomUrl)
        {
            self.notifyCustomUrl = try decoderContainer.decode(String?.self, forKey: .notifyCustomUrl)
        }
        if decoderContainer.contains(.notifyCustomAuthKey)
        {
            self.notifyCustomAuthKey = try decoderContainer.decode(String?.self, forKey: .notifyCustomAuthKey)
        }
        if decoderContainer.contains(.forwardAccessKeyType)
        {
            self.forwardAccessKeyType = try decoderContainer.decode(Int?.self, forKey: .forwardAccessKeyType)
        }
        if decoderContainer.contains(.forwardPrivateKey)
        {
            self.forwardPrivateKey = try decoderContainer.decode(String?.self, forKey: .forwardPrivateKey)
        }
        if decoderContainer.contains(.originAccessKeyType)
        {
            self.originAccessKeyType = try decoderContainer.decode(Int?.self, forKey: .originAccessKeyType)
        }
        if decoderContainer.contains(.originPrivateKey)
        {
            self.originPrivateKey = try decoderContainer.decode(String?.self, forKey: .originPrivateKey)
        }
    }
}
public extension SetForwardAuthenticationResult{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: SetForwardAuthenticationResultCodingKeys.self)
        try encoderContainer.encode(ignoreQueryString, forKey: .ignoreQueryString)
        try encoderContainer.encode(pushIpWhiteList, forKey: .pushIpWhiteList)
        try encoderContainer.encode(publishNormalTimeout, forKey: .publishNormalTimeout)
        try encoderContainer.encode(notifyCustomUrl, forKey: .notifyCustomUrl)
        try encoderContainer.encode(notifyCustomAuthKey, forKey: .notifyCustomAuthKey)
        try encoderContainer.encode(forwardAccessKeyType, forKey: .forwardAccessKeyType)
        try encoderContainer.encode(forwardPrivateKey, forKey: .forwardPrivateKey)
        try encoderContainer.encode(originAccessKeyType, forKey: .originAccessKeyType)
        try encoderContainer.encode(originPrivateKey, forKey: .originPrivateKey)
    }
}
public class SetForwardAuthenticationResponse:NSObject,Codable
{
    var requestId:String?;

    var error:ServiceError?;

    var result:SetForwardAuthenticationResult?;

    enum SetForwardAuthenticationResponseCodingKeys: String, CodingKey {
        case requestId
        case error
        case result
    }

    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: SetForwardAuthenticationResponseCodingKeys.self)
        self.requestId = try decoderContainer.decodeIfPresent(String?.self, forKey: .requestId) ?? nil
        self.error = try decoderContainer.decodeIfPresent(ServiceError?.self, forKey: .error) ?? nil
        self.result = try decoderContainer.decodeIfPresent(SetForwardAuthenticationResult?.self, forKey: .result) ?? nil
    }
}

public extension SetForwardAuthenticationResponse{
        func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: SetForwardAuthenticationResponseCodingKeys.self)
        try encoderContainer.encode(requestId, forKey: .requestId)
        try encoderContainer.encode(error, forKey: .error)
        try encoderContainer.encode(result, forKey: .result)
    }
}    
/// 查询用户推流域名app名/流名 
public class QueryPushDomainORAppOrStreamResult:NSObject,JdCloudResult
{
    /// Streams
    var streams:[String?]?



    public override init(){
        super.init()
    }

    enum QueryPushDomainORAppOrStreamResultCodingKeys: String, CodingKey {
        case streams
    }

    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: QueryPushDomainORAppOrStreamResultCodingKeys.self)
        if decoderContainer.contains(.streams)
        {
            self.streams = try decoderContainer.decode([String?]?.self, forKey: .streams)
        }
    }
}
public extension QueryPushDomainORAppOrStreamResult{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: QueryPushDomainORAppOrStreamResultCodingKeys.self)
        try encoderContainer.encode(streams, forKey: .streams)
    }
}

///  设置转推鉴权信息
public class SetForwardAuthenticationRequest:JdCloudRequest
{
    /// 鉴权类型，0表示无鉴权，1表示参数鉴权，2表示路径鉴权
    var accesskeyType:Int?

    /// 密码，长度为8到32
    var accesskeyKey:String?

    /// 用户域名
    var domain:String


    public init(regionId: String,domain:String){
        self.domain = domain
        super.init(regionId: regionId)
    }


    enum SetForwardAuthenticationRequestRequestCodingKeys: String, CodingKey {
        case accesskeyType
        case accesskeyKey
        case domain
    }

    public override func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: SetForwardAuthenticationRequestRequestCodingKeys.self)
        try encoderContainer.encode(accesskeyType, forKey: .accesskeyType)
        try encoderContainer.encode(accesskeyKey, forKey: .accesskeyKey)
        try encoderContainer.encode(domain, forKey: .domain)

    }
}


///  设置回源鉴权信息
public class SetOriginAuthenticationRequest:JdCloudRequest
{
    /// 鉴权类型，0表示无鉴权，1表示参数鉴权，2表示路径鉴权
    var accesskeyType:Int?

    /// 密码，长度为8到32
    var accesskeyKey:String?

    /// 用户域名
    var domain:String


    public init(regionId: String,domain:String){
        self.domain = domain
        super.init(regionId: regionId)
    }


    enum SetOriginAuthenticationRequestRequestCodingKeys: String, CodingKey {
        case accesskeyType
        case accesskeyKey
        case domain
    }

    public override func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: SetOriginAuthenticationRequestRequestCodingKeys.self)
        try encoderContainer.encode(accesskeyType, forKey: .accesskeyType)
        try encoderContainer.encode(accesskeyKey, forKey: .accesskeyKey)
        try encoderContainer.encode(domain, forKey: .domain)

    }
}

/// 设置转协议 
public class SetProtocolConvertResult:NSObject,JdCloudResult
{
}

///  设置IP白名单
public class SetPushIpWhiteListRequest:JdCloudRequest
{
    /// IpList
    var ipList:[String?]?

    /// 用户域名
    var domain:String


    public init(regionId: String,domain:String){
        self.domain = domain
        super.init(regionId: regionId)
    }


    enum SetPushIpWhiteListRequestRequestCodingKeys: String, CodingKey {
        case ipList
        case domain
    }

    public override func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: SetPushIpWhiteListRequestRequestCodingKeys.self)
        try encoderContainer.encode(ipList, forKey: .ipList)
        try encoderContainer.encode(domain, forKey: .domain)

    }
}


///  设置URL鉴权
public class SetLiveDomainAccessKeyRequest:JdCloudRequest
{
    /// url鉴权开启1关闭0
    var accesskeyType:Int?

    /// url鉴权开启时必传
    var accesskeyKey:String?

    /// 开启时默认值为300s,关闭时为0
    var authLifeTime:Int?

    /// 用户域名
    var domain:String


    public init(regionId: String,domain:String){
        self.domain = domain
        super.init(regionId: regionId)
    }


    enum SetLiveDomainAccessKeyRequestRequestCodingKeys: String, CodingKey {
        case accesskeyType
        case accesskeyKey
        case authLifeTime
        case domain
    }

    public override func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: SetLiveDomainAccessKeyRequestRequestCodingKeys.self)
        try encoderContainer.encode(accesskeyType, forKey: .accesskeyType)
        try encoderContainer.encode(accesskeyKey, forKey: .accesskeyKey)
        try encoderContainer.encode(authLifeTime, forKey: .authLifeTime)
        try encoderContainer.encode(domain, forKey: .domain)

    }
}


///  设置推流中断通知方式
public class SetStreamNotifyInfoRequest:JdCloudRequest
{
    /// 通知的目标URL
    var notifyUrl:String?

    /// 通知时需携带的鉴权key
    var notifyAuthKey:String?

    /// 用户域名
    var domain:String


    public init(regionId: String,domain:String){
        self.domain = domain
        super.init(regionId: regionId)
    }


    enum SetStreamNotifyInfoRequestRequestCodingKeys: String, CodingKey {
        case notifyUrl
        case notifyAuthKey
        case domain
    }

    public override func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: SetStreamNotifyInfoRequestRequestCodingKeys.self)
        try encoderContainer.encode(notifyUrl, forKey: .notifyUrl)
        try encoderContainer.encode(notifyAuthKey, forKey: .notifyAuthKey)
        try encoderContainer.encode(domain, forKey: .domain)

    }
}


///  设置推流中断超时时间
public class SetPublishNormalTimeoutRequest:JdCloudRequest
{
    /// 超时时间应介于0s到3600s之间
    var timeout:Int?

    /// 用户域名
    var domain:String


    public init(regionId: String,domain:String){
        self.domain = domain
        super.init(regionId: regionId)
    }


    enum SetPublishNormalTimeoutRequestRequestCodingKeys: String, CodingKey {
        case timeout
        case domain
    }

    public override func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: SetPublishNormalTimeoutRequestRequestCodingKeys.self)
        try encoderContainer.encode(timeout, forKey: .timeout)
        try encoderContainer.encode(domain, forKey: .domain)

    }
}

/// 设置推流中断通知方式 
public class SetStreamNotifyInfoResult:NSObject,JdCloudResult
{
    /// 是否忽略参数
    var ignoreQueryString:String?

    /// 推流IP白名单（用逗号分隔）
    var pushIpWhiteList:String?

    /// 推流超时时间
    var publishNormalTimeout:Int?

    /// 推断流时，通知客户系统的URL
    var notifyCustomUrl:String?

    /// 通知客户系统的鉴权key
    var notifyCustomAuthKey:String?

    /// 转推鉴权类型（0：不鉴权，1：参数鉴权，2：URL鉴权）
    var forwardAccessKeyType:Int?

    /// 转推的鉴权key
    var forwardPrivateKey:String?

    /// 回源鉴权类型（0：不鉴权，1：参数鉴权，2：URL鉴权）
    var originAccessKeyType:Int?

    /// 回源的鉴权key
    var originPrivateKey:String?



    public override init(){
        super.init()
    }

    enum SetStreamNotifyInfoResultCodingKeys: String, CodingKey {
        case ignoreQueryString
        case pushIpWhiteList
        case publishNormalTimeout
        case notifyCustomUrl
        case notifyCustomAuthKey
        case forwardAccessKeyType
        case forwardPrivateKey
        case originAccessKeyType
        case originPrivateKey
    }

    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: SetStreamNotifyInfoResultCodingKeys.self)
        if decoderContainer.contains(.ignoreQueryString)
        {
            self.ignoreQueryString = try decoderContainer.decode(String?.self, forKey: .ignoreQueryString)
        }
        if decoderContainer.contains(.pushIpWhiteList)
        {
            self.pushIpWhiteList = try decoderContainer.decode(String?.self, forKey: .pushIpWhiteList)
        }
        if decoderContainer.contains(.publishNormalTimeout)
        {
            self.publishNormalTimeout = try decoderContainer.decode(Int?.self, forKey: .publishNormalTimeout)
        }
        if decoderContainer.contains(.notifyCustomUrl)
        {
            self.notifyCustomUrl = try decoderContainer.decode(String?.self, forKey: .notifyCustomUrl)
        }
        if decoderContainer.contains(.notifyCustomAuthKey)
        {
            self.notifyCustomAuthKey = try decoderContainer.decode(String?.self, forKey: .notifyCustomAuthKey)
        }
        if decoderContainer.contains(.forwardAccessKeyType)
        {
            self.forwardAccessKeyType = try decoderContainer.decode(Int?.self, forKey: .forwardAccessKeyType)
        }
        if decoderContainer.contains(.forwardPrivateKey)
        {
            self.forwardPrivateKey = try decoderContainer.decode(String?.self, forKey: .forwardPrivateKey)
        }
        if decoderContainer.contains(.originAccessKeyType)
        {
            self.originAccessKeyType = try decoderContainer.decode(Int?.self, forKey: .originAccessKeyType)
        }
        if decoderContainer.contains(.originPrivateKey)
        {
            self.originPrivateKey = try decoderContainer.decode(String?.self, forKey: .originPrivateKey)
        }
    }
}
public extension SetStreamNotifyInfoResult{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: SetStreamNotifyInfoResultCodingKeys.self)
        try encoderContainer.encode(ignoreQueryString, forKey: .ignoreQueryString)
        try encoderContainer.encode(pushIpWhiteList, forKey: .pushIpWhiteList)
        try encoderContainer.encode(publishNormalTimeout, forKey: .publishNormalTimeout)
        try encoderContainer.encode(notifyCustomUrl, forKey: .notifyCustomUrl)
        try encoderContainer.encode(notifyCustomAuthKey, forKey: .notifyCustomAuthKey)
        try encoderContainer.encode(forwardAccessKeyType, forKey: .forwardAccessKeyType)
        try encoderContainer.encode(forwardPrivateKey, forKey: .forwardPrivateKey)
        try encoderContainer.encode(originAccessKeyType, forKey: .originAccessKeyType)
        try encoderContainer.encode(originPrivateKey, forKey: .originPrivateKey)
    }
}

///  设置直播域名回源信息
public class SetLiveDomainBackSourceRequest:JdCloudRequest
{
    /// 回源类型只能为[ips,domain]中的一种
    var sourceType:String?

    /// BackSourceType
    var backSourceType:String?

    /// 默认回源host
    var defaultSourceHost:String?

    /// DomainSource
    var domainSource:[DomainSourceInfo?]?

    /// IpSource
    var ipSource:[IpSourceInfo?]?

    /// 用户域名
    var domain:String


    public init(regionId: String,domain:String){
        self.domain = domain
        super.init(regionId: regionId)
    }


    enum SetLiveDomainBackSourceRequestRequestCodingKeys: String, CodingKey {
        case sourceType
        case backSourceType
        case defaultSourceHost
        case domainSource
        case ipSource
        case domain
    }

    public override func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: SetLiveDomainBackSourceRequestRequestCodingKeys.self)
        try encoderContainer.encode(sourceType, forKey: .sourceType)
        try encoderContainer.encode(backSourceType, forKey: .backSourceType)
        try encoderContainer.encode(defaultSourceHost, forKey: .defaultSourceHost)
        try encoderContainer.encode(domainSource, forKey: .domainSource)
        try encoderContainer.encode(ipSource, forKey: .ipSource)
        try encoderContainer.encode(domain, forKey: .domain)

    }
}

public class SetPublishNormalTimeoutResponse:NSObject,Codable
{
    var requestId:String?;

    var error:ServiceError?;

    var result:SetPublishNormalTimeoutResult?;

    enum SetPublishNormalTimeoutResponseCodingKeys: String, CodingKey {
        case requestId
        case error
        case result
    }

    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: SetPublishNormalTimeoutResponseCodingKeys.self)
        self.requestId = try decoderContainer.decodeIfPresent(String?.self, forKey: .requestId) ?? nil
        self.error = try decoderContainer.decodeIfPresent(ServiceError?.self, forKey: .error) ?? nil
        self.result = try decoderContainer.decodeIfPresent(SetPublishNormalTimeoutResult?.self, forKey: .result) ?? nil
    }
}

public extension SetPublishNormalTimeoutResponse{
        func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: SetPublishNormalTimeoutResponseCodingKeys.self)
        try encoderContainer.encode(requestId, forKey: .requestId)
        try encoderContainer.encode(error, forKey: .error)
        try encoderContainer.encode(result, forKey: .result)
    }
}    

///  设置直播域名回源host
public class SetLiveDomainBackSourceHostRequest:JdCloudRequest
{
    /// 默认回源host
    var sourceHost:String?

    /// 用户域名
    var domain:String


    public init(regionId: String,domain:String){
        self.domain = domain
        super.init(regionId: regionId)
    }


    enum SetLiveDomainBackSourceHostRequestRequestCodingKeys: String, CodingKey {
        case sourceHost
        case domain
    }

    public override func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: SetLiveDomainBackSourceHostRequestRequestCodingKeys.self)
        try encoderContainer.encode(sourceHost, forKey: .sourceHost)
        try encoderContainer.encode(domain, forKey: .domain)

    }
}

/// 设置URL鉴权 
public class SetLiveDomainAccessKeyResult:NSObject,JdCloudResult
{
}
public class OperateLiveDomainIpBlackListResponse:NSObject,Codable
{
    var requestId:String?;

    var error:ServiceError?;

    var result:OperateLiveDomainIpBlackListResult?;

    enum OperateLiveDomainIpBlackListResponseCodingKeys: String, CodingKey {
        case requestId
        case error
        case result
    }

    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: OperateLiveDomainIpBlackListResponseCodingKeys.self)
        self.requestId = try decoderContainer.decodeIfPresent(String?.self, forKey: .requestId) ?? nil
        self.error = try decoderContainer.decodeIfPresent(ServiceError?.self, forKey: .error) ?? nil
        self.result = try decoderContainer.decodeIfPresent(OperateLiveDomainIpBlackListResult?.self, forKey: .result) ?? nil
    }
}

public extension OperateLiveDomainIpBlackListResponse{
        func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: OperateLiveDomainIpBlackListResponseCodingKeys.self)
        try encoderContainer.encode(requestId, forKey: .requestId)
        try encoderContainer.encode(error, forKey: .error)
        try encoderContainer.encode(result, forKey: .result)
    }
}    
/// 设置回源鉴权信息 
public class SetOriginAuthenticationResult:NSObject,JdCloudResult
{
    /// 是否忽略参数
    var ignoreQueryString:String?

    /// 推流IP白名单（用逗号分隔）
    var pushIpWhiteList:String?

    /// 推流超时时间
    var publishNormalTimeout:Int?

    /// 推断流时，通知客户系统的URL
    var notifyCustomUrl:String?

    /// 通知客户系统的鉴权key
    var notifyCustomAuthKey:String?

    /// 转推鉴权类型（0：不鉴权，1：参数鉴权，2：URL鉴权）
    var forwardAccessKeyType:Int?

    /// 转推的鉴权key
    var forwardPrivateKey:String?

    /// 回源鉴权类型（0：不鉴权，1：参数鉴权，2：URL鉴权）
    var originAccessKeyType:Int?

    /// 回源的鉴权key
    var originPrivateKey:String?



    public override init(){
        super.init()
    }

    enum SetOriginAuthenticationResultCodingKeys: String, CodingKey {
        case ignoreQueryString
        case pushIpWhiteList
        case publishNormalTimeout
        case notifyCustomUrl
        case notifyCustomAuthKey
        case forwardAccessKeyType
        case forwardPrivateKey
        case originAccessKeyType
        case originPrivateKey
    }

    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: SetOriginAuthenticationResultCodingKeys.self)
        if decoderContainer.contains(.ignoreQueryString)
        {
            self.ignoreQueryString = try decoderContainer.decode(String?.self, forKey: .ignoreQueryString)
        }
        if decoderContainer.contains(.pushIpWhiteList)
        {
            self.pushIpWhiteList = try decoderContainer.decode(String?.self, forKey: .pushIpWhiteList)
        }
        if decoderContainer.contains(.publishNormalTimeout)
        {
            self.publishNormalTimeout = try decoderContainer.decode(Int?.self, forKey: .publishNormalTimeout)
        }
        if decoderContainer.contains(.notifyCustomUrl)
        {
            self.notifyCustomUrl = try decoderContainer.decode(String?.self, forKey: .notifyCustomUrl)
        }
        if decoderContainer.contains(.notifyCustomAuthKey)
        {
            self.notifyCustomAuthKey = try decoderContainer.decode(String?.self, forKey: .notifyCustomAuthKey)
        }
        if decoderContainer.contains(.forwardAccessKeyType)
        {
            self.forwardAccessKeyType = try decoderContainer.decode(Int?.self, forKey: .forwardAccessKeyType)
        }
        if decoderContainer.contains(.forwardPrivateKey)
        {
            self.forwardPrivateKey = try decoderContainer.decode(String?.self, forKey: .forwardPrivateKey)
        }
        if decoderContainer.contains(.originAccessKeyType)
        {
            self.originAccessKeyType = try decoderContainer.decode(Int?.self, forKey: .originAccessKeyType)
        }
        if decoderContainer.contains(.originPrivateKey)
        {
            self.originPrivateKey = try decoderContainer.decode(String?.self, forKey: .originPrivateKey)
        }
    }
}
public extension SetOriginAuthenticationResult{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: SetOriginAuthenticationResultCodingKeys.self)
        try encoderContainer.encode(ignoreQueryString, forKey: .ignoreQueryString)
        try encoderContainer.encode(pushIpWhiteList, forKey: .pushIpWhiteList)
        try encoderContainer.encode(publishNormalTimeout, forKey: .publishNormalTimeout)
        try encoderContainer.encode(notifyCustomUrl, forKey: .notifyCustomUrl)
        try encoderContainer.encode(notifyCustomAuthKey, forKey: .notifyCustomAuthKey)
        try encoderContainer.encode(forwardAccessKeyType, forKey: .forwardAccessKeyType)
        try encoderContainer.encode(forwardPrivateKey, forKey: .forwardPrivateKey)
        try encoderContainer.encode(originAccessKeyType, forKey: .originAccessKeyType)
        try encoderContainer.encode(originPrivateKey, forKey: .originPrivateKey)
    }
}
public class SetProtocolConvertResponse:NSObject,Codable
{
    var requestId:String?;

    var error:ServiceError?;

    var result:SetProtocolConvertResult?;

    enum SetProtocolConvertResponseCodingKeys: String, CodingKey {
        case requestId
        case error
        case result
    }

    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: SetProtocolConvertResponseCodingKeys.self)
        self.requestId = try decoderContainer.decodeIfPresent(String?.self, forKey: .requestId) ?? nil
        self.error = try decoderContainer.decodeIfPresent(ServiceError?.self, forKey: .error) ?? nil
        self.result = try decoderContainer.decodeIfPresent(SetProtocolConvertResult?.self, forKey: .result) ?? nil
    }
}

public extension SetProtocolConvertResponse{
        func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: SetProtocolConvertResponseCodingKeys.self)
        try encoderContainer.encode(requestId, forKey: .requestId)
        try encoderContainer.encode(error, forKey: .error)
        try encoderContainer.encode(result, forKey: .result)
    }
}    

///  设置直播域名ip黑名单
public class SetLiveDomainIpBlackListRequest:JdCloudRequest
{
    /// Ips
    var ips:[String?]?

    /// 用户域名
    var domain:String


    public init(regionId: String,domain:String){
        self.domain = domain
        super.init(regionId: regionId)
    }


    enum SetLiveDomainIpBlackListRequestRequestCodingKeys: String, CodingKey {
        case ips
        case domain
    }

    public override func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: SetLiveDomainIpBlackListRequestRequestCodingKeys.self)
        try encoderContainer.encode(ips, forKey: .ips)
        try encoderContainer.encode(domain, forKey: .domain)

    }
}

public class SetStreamNotifyInfoResponse:NSObject,Codable
{
    var requestId:String?;

    var error:ServiceError?;

    var result:SetStreamNotifyInfoResult?;

    enum SetStreamNotifyInfoResponseCodingKeys: String, CodingKey {
        case requestId
        case error
        case result
    }

    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: SetStreamNotifyInfoResponseCodingKeys.self)
        self.requestId = try decoderContainer.decodeIfPresent(String?.self, forKey: .requestId) ?? nil
        self.error = try decoderContainer.decodeIfPresent(ServiceError?.self, forKey: .error) ?? nil
        self.result = try decoderContainer.decodeIfPresent(SetStreamNotifyInfoResult?.self, forKey: .result) ?? nil
    }
}

public extension SetStreamNotifyInfoResponse{
        func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: SetStreamNotifyInfoResponseCodingKeys.self)
        try encoderContainer.encode(requestId, forKey: .requestId)
        try encoderContainer.encode(error, forKey: .error)
        try encoderContainer.encode(result, forKey: .result)
    }
}    
/// 设置直播域名ip黑名单 
public class SetLiveDomainIpBlackListResult:NSObject,JdCloudResult
{
}
/// 设置直播域名回源信息 
public class SetLiveDomainBackSourceResult:NSObject,JdCloudResult
{
}
public class SetLiveDomainBackSourceResponse:NSObject,Codable
{
    var requestId:String?;

    var error:ServiceError?;

    var result:SetLiveDomainBackSourceResult?;

    enum SetLiveDomainBackSourceResponseCodingKeys: String, CodingKey {
        case requestId
        case error
        case result
    }

    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: SetLiveDomainBackSourceResponseCodingKeys.self)
        self.requestId = try decoderContainer.decodeIfPresent(String?.self, forKey: .requestId) ?? nil
        self.error = try decoderContainer.decodeIfPresent(ServiceError?.self, forKey: .error) ?? nil
        self.result = try decoderContainer.decodeIfPresent(SetLiveDomainBackSourceResult?.self, forKey: .result) ?? nil
    }
}

public extension SetLiveDomainBackSourceResponse{
        func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: SetLiveDomainBackSourceResponseCodingKeys.self)
        try encoderContainer.encode(requestId, forKey: .requestId)
        try encoderContainer.encode(error, forKey: .error)
        try encoderContainer.encode(result, forKey: .result)
    }
}    

///  设置转协议
public class SetProtocolConvertRequest:JdCloudRequest
{
    /// https证书,转https格式时必传
    var certificate:String?

    /// https私钥，转https格式时必传
    var rsaKey:String?

    /// 证书来源有两种类型：default,ssl
    var certFrom:String?

    /// ssl证书id
    var sslCertId:String?

    /// 是否同步到ssl,boolean值，取值true或者false
    var syncToSsl:Bool?

    /// syncToSsl是true时，certName是必填项
    var certName:String?

    /// ProtocolConverts
    var protocolConverts:[ProtocolConvert?]?

    /// 用户域名
    var domain:String


    public init(regionId: String,domain:String){
        self.domain = domain
        super.init(regionId: regionId)
    }


    enum SetProtocolConvertRequestRequestCodingKeys: String, CodingKey {
        case certificate
        case rsaKey
        case certFrom
        case sslCertId
        case syncToSsl
        case certName
        case protocolConverts
        case domain
    }

    public override func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: SetProtocolConvertRequestRequestCodingKeys.self)
        try encoderContainer.encode(certificate, forKey: .certificate)
        try encoderContainer.encode(rsaKey, forKey: .rsaKey)
        try encoderContainer.encode(certFrom, forKey: .certFrom)
        try encoderContainer.encode(sslCertId, forKey: .sslCertId)
        try encoderContainer.encode(syncToSsl, forKey: .syncToSsl)
        try encoderContainer.encode(certName, forKey: .certName)
        try encoderContainer.encode(protocolConverts, forKey: .protocolConverts)
        try encoderContainer.encode(domain, forKey: .domain)

    }
}

public class DeleteForbiddenStreamResponse:NSObject,Codable
{
    var requestId:String?;

    var error:ServiceError?;

    var result:DeleteForbiddenStreamResult?;

    enum DeleteForbiddenStreamResponseCodingKeys: String, CodingKey {
        case requestId
        case error
        case result
    }

    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: DeleteForbiddenStreamResponseCodingKeys.self)
        self.requestId = try decoderContainer.decodeIfPresent(String?.self, forKey: .requestId) ?? nil
        self.error = try decoderContainer.decodeIfPresent(ServiceError?.self, forKey: .error) ?? nil
        self.result = try decoderContainer.decodeIfPresent(DeleteForbiddenStreamResult?.self, forKey: .result) ?? nil
    }
}

public extension DeleteForbiddenStreamResponse{
        func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: DeleteForbiddenStreamResponseCodingKeys.self)
        try encoderContainer.encode(requestId, forKey: .requestId)
        try encoderContainer.encode(error, forKey: .error)
        try encoderContainer.encode(result, forKey: .result)
    }
}    
/// 设置IP白名单 
public class SetPushIpWhiteListResult:NSObject,JdCloudResult
{
    /// 是否忽略参数
    var ignoreQueryString:String?

    /// 推流IP白名单（用逗号分隔）
    var pushIpWhiteList:String?

    /// 推流超时时间
    var publishNormalTimeout:Int?

    /// 推断流时，通知客户系统的URL
    var notifyCustomUrl:String?

    /// 通知客户系统的鉴权key
    var notifyCustomAuthKey:String?

    /// 转推鉴权类型（0：不鉴权，1：参数鉴权，2：URL鉴权）
    var forwardAccessKeyType:Int?

    /// 转推的鉴权key
    var forwardPrivateKey:String?

    /// 回源鉴权类型（0：不鉴权，1：参数鉴权，2：URL鉴权）
    var originAccessKeyType:Int?

    /// 回源的鉴权key
    var originPrivateKey:String?



    public override init(){
        super.init()
    }

    enum SetPushIpWhiteListResultCodingKeys: String, CodingKey {
        case ignoreQueryString
        case pushIpWhiteList
        case publishNormalTimeout
        case notifyCustomUrl
        case notifyCustomAuthKey
        case forwardAccessKeyType
        case forwardPrivateKey
        case originAccessKeyType
        case originPrivateKey
    }

    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: SetPushIpWhiteListResultCodingKeys.self)
        if decoderContainer.contains(.ignoreQueryString)
        {
            self.ignoreQueryString = try decoderContainer.decode(String?.self, forKey: .ignoreQueryString)
        }
        if decoderContainer.contains(.pushIpWhiteList)
        {
            self.pushIpWhiteList = try decoderContainer.decode(String?.self, forKey: .pushIpWhiteList)
        }
        if decoderContainer.contains(.publishNormalTimeout)
        {
            self.publishNormalTimeout = try decoderContainer.decode(Int?.self, forKey: .publishNormalTimeout)
        }
        if decoderContainer.contains(.notifyCustomUrl)
        {
            self.notifyCustomUrl = try decoderContainer.decode(String?.self, forKey: .notifyCustomUrl)
        }
        if decoderContainer.contains(.notifyCustomAuthKey)
        {
            self.notifyCustomAuthKey = try decoderContainer.decode(String?.self, forKey: .notifyCustomAuthKey)
        }
        if decoderContainer.contains(.forwardAccessKeyType)
        {
            self.forwardAccessKeyType = try decoderContainer.decode(Int?.self, forKey: .forwardAccessKeyType)
        }
        if decoderContainer.contains(.forwardPrivateKey)
        {
            self.forwardPrivateKey = try decoderContainer.decode(String?.self, forKey: .forwardPrivateKey)
        }
        if decoderContainer.contains(.originAccessKeyType)
        {
            self.originAccessKeyType = try decoderContainer.decode(Int?.self, forKey: .originAccessKeyType)
        }
        if decoderContainer.contains(.originPrivateKey)
        {
            self.originPrivateKey = try decoderContainer.decode(String?.self, forKey: .originPrivateKey)
        }
    }
}
public extension SetPushIpWhiteListResult{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: SetPushIpWhiteListResultCodingKeys.self)
        try encoderContainer.encode(ignoreQueryString, forKey: .ignoreQueryString)
        try encoderContainer.encode(pushIpWhiteList, forKey: .pushIpWhiteList)
        try encoderContainer.encode(publishNormalTimeout, forKey: .publishNormalTimeout)
        try encoderContainer.encode(notifyCustomUrl, forKey: .notifyCustomUrl)
        try encoderContainer.encode(notifyCustomAuthKey, forKey: .notifyCustomAuthKey)
        try encoderContainer.encode(forwardAccessKeyType, forKey: .forwardAccessKeyType)
        try encoderContainer.encode(forwardPrivateKey, forKey: .forwardPrivateKey)
        try encoderContainer.encode(originAccessKeyType, forKey: .originAccessKeyType)
        try encoderContainer.encode(originPrivateKey, forKey: .originPrivateKey)
    }
}
/// 开启或关闭ip黑名单 
public class OperateLiveDomainIpBlackListResult:NSObject,JdCloudResult
{
}
public class SetOriginAuthenticationResponse:NSObject,Codable
{
    var requestId:String?;

    var error:ServiceError?;

    var result:SetOriginAuthenticationResult?;

    enum SetOriginAuthenticationResponseCodingKeys: String, CodingKey {
        case requestId
        case error
        case result
    }

    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: SetOriginAuthenticationResponseCodingKeys.self)
        self.requestId = try decoderContainer.decodeIfPresent(String?.self, forKey: .requestId) ?? nil
        self.error = try decoderContainer.decodeIfPresent(ServiceError?.self, forKey: .error) ?? nil
        self.result = try decoderContainer.decodeIfPresent(SetOriginAuthenticationResult?.self, forKey: .result) ?? nil
    }
}

public extension SetOriginAuthenticationResponse{
        func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: SetOriginAuthenticationResponseCodingKeys.self)
        try encoderContainer.encode(requestId, forKey: .requestId)
        try encoderContainer.encode(error, forKey: .error)
        try encoderContainer.encode(result, forKey: .result)
    }
}    
public class SetLiveDomainIpBlackListResponse:NSObject,Codable
{
    var requestId:String?;

    var error:ServiceError?;

    var result:SetLiveDomainIpBlackListResult?;

    enum SetLiveDomainIpBlackListResponseCodingKeys: String, CodingKey {
        case requestId
        case error
        case result
    }

    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: SetLiveDomainIpBlackListResponseCodingKeys.self)
        self.requestId = try decoderContainer.decodeIfPresent(String?.self, forKey: .requestId) ?? nil
        self.error = try decoderContainer.decodeIfPresent(ServiceError?.self, forKey: .error) ?? nil
        self.result = try decoderContainer.decodeIfPresent(SetLiveDomainIpBlackListResult?.self, forKey: .result) ?? nil
    }
}

public extension SetLiveDomainIpBlackListResponse{
        func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: SetLiveDomainIpBlackListResponseCodingKeys.self)
        try encoderContainer.encode(requestId, forKey: .requestId)
        try encoderContainer.encode(error, forKey: .error)
        try encoderContainer.encode(result, forKey: .result)
    }
}    
public class SetLiveDomainReferResponse:NSObject,Codable
{
    var requestId:String?;

    var error:ServiceError?;

    var result:SetLiveDomainReferResult?;

    enum SetLiveDomainReferResponseCodingKeys: String, CodingKey {
        case requestId
        case error
        case result
    }

    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: SetLiveDomainReferResponseCodingKeys.self)
        self.requestId = try decoderContainer.decodeIfPresent(String?.self, forKey: .requestId) ?? nil
        self.error = try decoderContainer.decodeIfPresent(ServiceError?.self, forKey: .error) ?? nil
        self.result = try decoderContainer.decodeIfPresent(SetLiveDomainReferResult?.self, forKey: .result) ?? nil
    }
}

public extension SetLiveDomainReferResponse{
        func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: SetLiveDomainReferResponseCodingKeys.self)
        try encoderContainer.encode(requestId, forKey: .requestId)
        try encoderContainer.encode(error, forKey: .error)
        try encoderContainer.encode(result, forKey: .result)
    }
}    

///  设置是否开启过滤参数
public class OperateLiveDomainIgnoreQueryStringRequest:JdCloudRequest
{
    /// 开启on，关闭off
    var status:String?

    /// 用户域名
    var domain:String


    public init(regionId: String,domain:String){
        self.domain = domain
        super.init(regionId: regionId)
    }


    enum OperateLiveDomainIgnoreQueryStringRequestRequestCodingKeys: String, CodingKey {
        case status
        case domain
    }

    public override func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: OperateLiveDomainIgnoreQueryStringRequestRequestCodingKeys.self)
        try encoderContainer.encode(status, forKey: .status)
        try encoderContainer.encode(domain, forKey: .domain)

    }
}

public class SetLiveDomainBackSourceHostResponse:NSObject,Codable
{
    var requestId:String?;

    var error:ServiceError?;

    var result:SetLiveDomainBackSourceHostResult?;

    enum SetLiveDomainBackSourceHostResponseCodingKeys: String, CodingKey {
        case requestId
        case error
        case result
    }

    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: SetLiveDomainBackSourceHostResponseCodingKeys.self)
        self.requestId = try decoderContainer.decodeIfPresent(String?.self, forKey: .requestId) ?? nil
        self.error = try decoderContainer.decodeIfPresent(ServiceError?.self, forKey: .error) ?? nil
        self.result = try decoderContainer.decodeIfPresent(SetLiveDomainBackSourceHostResult?.self, forKey: .result) ?? nil
    }
}

public extension SetLiveDomainBackSourceHostResponse{
        func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: SetLiveDomainBackSourceHostResponseCodingKeys.self)
        try encoderContainer.encode(requestId, forKey: .requestId)
        try encoderContainer.encode(error, forKey: .error)
        try encoderContainer.encode(result, forKey: .result)
    }
}    
/// 设置直播域名回源host 
public class SetLiveDomainBackSourceHostResult:NSObject,JdCloudResult
{
}
/// 设置域名refer防盗链 
public class SetLiveDomainReferResult:NSObject,JdCloudResult
{
}

///  查询用户推流域名app名/流名
public class QueryPushDomainORAppOrStreamRequest:JdCloudRequest
{
    /// app名，传appName查询流名列表
    var app:String?

    /// 流名模糊查询
    var stream:String?

    /// 指定app/流名列表大小，默认50
    var limit:Int64?

    /// 用户域名
    var domain:String


    public init(regionId: String,domain:String){
        self.domain = domain
        super.init(regionId: regionId)
    }


    enum QueryPushDomainORAppOrStreamRequestRequestCodingKeys: String, CodingKey {
        case app
        case stream
        case limit
        case domain
    }

    public override func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: QueryPushDomainORAppOrStreamRequestRequestCodingKeys.self)
        try encoderContainer.encode(app, forKey: .app)
        try encoderContainer.encode(stream, forKey: .stream)
        try encoderContainer.encode(limit, forKey: .limit)
        try encoderContainer.encode(domain, forKey: .domain)

    }
}


///  开启或关闭ip黑名单
public class OperateLiveDomainIpBlackListRequest:JdCloudRequest
{
    /// BlackIpsEnable
    var blackIpsEnable:String?

    /// 用户域名
    var domain:String


    public init(regionId: String,domain:String){
        self.domain = domain
        super.init(regionId: regionId)
    }


    enum OperateLiveDomainIpBlackListRequestRequestCodingKeys: String, CodingKey {
        case blackIpsEnable
        case domain
    }

    public override func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: OperateLiveDomainIpBlackListRequestRequestCodingKeys.self)
        try encoderContainer.encode(blackIpsEnable, forKey: .blackIpsEnable)
        try encoderContainer.encode(domain, forKey: .domain)

    }
}

/// 删除禁播流 
public class DeleteForbiddenStreamResult:NSObject,JdCloudResult
{
}

///  设置域名refer防盗链
public class SetLiveDomainReferRequest:JdCloudRequest
{
    /// refer类型，取值：block（黑名单），allow（白名单）默认为block
    var referType:String?

    /// 逗号隔开的域名列表，如果referList传空则为删除
    var referList:[String?]?

    /// 是否允许空refer访问，默认为“on”
    var allowNoReferHeader:String?

    /// 是否允许无ua访问，默认为“on”
    var allowNullReferHeader:String?

    /// 用户域名
    var domain:String


    public init(regionId: String,domain:String){
        self.domain = domain
        super.init(regionId: regionId)
    }


    enum SetLiveDomainReferRequestRequestCodingKeys: String, CodingKey {
        case referType
        case referList
        case allowNoReferHeader
        case allowNullReferHeader
        case domain
    }

    public override func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: SetLiveDomainReferRequestRequestCodingKeys.self)
        try encoderContainer.encode(referType, forKey: .referType)
        try encoderContainer.encode(referList, forKey: .referList)
        try encoderContainer.encode(allowNoReferHeader, forKey: .allowNoReferHeader)
        try encoderContainer.encode(allowNullReferHeader, forKey: .allowNullReferHeader)
        try encoderContainer.encode(domain, forKey: .domain)

    }
}

public class SetLiveDomainAccessKeyResponse:NSObject,Codable
{
    var requestId:String?;

    var error:ServiceError?;

    var result:SetLiveDomainAccessKeyResult?;

    enum SetLiveDomainAccessKeyResponseCodingKeys: String, CodingKey {
        case requestId
        case error
        case result
    }

    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: SetLiveDomainAccessKeyResponseCodingKeys.self)
        self.requestId = try decoderContainer.decodeIfPresent(String?.self, forKey: .requestId) ?? nil
        self.error = try decoderContainer.decodeIfPresent(ServiceError?.self, forKey: .error) ?? nil
        self.result = try decoderContainer.decodeIfPresent(SetLiveDomainAccessKeyResult?.self, forKey: .result) ?? nil
    }
}

public extension SetLiveDomainAccessKeyResponse{
        func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: SetLiveDomainAccessKeyResponseCodingKeys.self)
        try encoderContainer.encode(requestId, forKey: .requestId)
        try encoderContainer.encode(error, forKey: .error)
        try encoderContainer.encode(result, forKey: .result)
    }
}    
public class OperateLiveDomainIgnoreQueryStringResponse:NSObject,Codable
{
    var requestId:String?;

    var error:ServiceError?;

    var result:OperateLiveDomainIgnoreQueryStringResult?;

    enum OperateLiveDomainIgnoreQueryStringResponseCodingKeys: String, CodingKey {
        case requestId
        case error
        case result
    }

    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: OperateLiveDomainIgnoreQueryStringResponseCodingKeys.self)
        self.requestId = try decoderContainer.decodeIfPresent(String?.self, forKey: .requestId) ?? nil
        self.error = try decoderContainer.decodeIfPresent(ServiceError?.self, forKey: .error) ?? nil
        self.result = try decoderContainer.decodeIfPresent(OperateLiveDomainIgnoreQueryStringResult?.self, forKey: .result) ?? nil
    }
}

public extension OperateLiveDomainIgnoreQueryStringResponse{
        func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: OperateLiveDomainIgnoreQueryStringResponseCodingKeys.self)
        try encoderContainer.encode(requestId, forKey: .requestId)
        try encoderContainer.encode(error, forKey: .error)
        try encoderContainer.encode(result, forKey: .result)
    }
}    
/// 设置是否开启过滤参数 
public class OperateLiveDomainIgnoreQueryStringResult:NSObject,JdCloudResult
{
}
public class BindPublishDomainResponse:NSObject,Codable
{
    var requestId:String?;

    var error:ServiceError?;

    var result:BindPublishDomainResult?;

    enum BindPublishDomainResponseCodingKeys: String, CodingKey {
        case requestId
        case error
        case result
    }

    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: BindPublishDomainResponseCodingKeys.self)
        self.requestId = try decoderContainer.decodeIfPresent(String?.self, forKey: .requestId) ?? nil
        self.error = try decoderContainer.decodeIfPresent(ServiceError?.self, forKey: .error) ?? nil
        self.result = try decoderContainer.decodeIfPresent(BindPublishDomainResult?.self, forKey: .result) ?? nil
    }
}

public extension BindPublishDomainResponse{
        func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: BindPublishDomainResponseCodingKeys.self)
        try encoderContainer.encode(requestId, forKey: .requestId)
        try encoderContainer.encode(error, forKey: .error)
        try encoderContainer.encode(result, forKey: .result)
    }
}    
/// 创建直播域名 
public class BatchCreateLiveDomainResult:NSObject,JdCloudResult
{
}
public class QueryLiveDomainAppsResponse:NSObject,Codable
{
    var requestId:String?;

    var error:ServiceError?;

    var result:QueryLiveDomainAppsResult?;

    enum QueryLiveDomainAppsResponseCodingKeys: String, CodingKey {
        case requestId
        case error
        case result
    }

    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: QueryLiveDomainAppsResponseCodingKeys.self)
        self.requestId = try decoderContainer.decodeIfPresent(String?.self, forKey: .requestId) ?? nil
        self.error = try decoderContainer.decodeIfPresent(ServiceError?.self, forKey: .error) ?? nil
        self.result = try decoderContainer.decodeIfPresent(QueryLiveDomainAppsResult?.self, forKey: .result) ?? nil
    }
}

public extension QueryLiveDomainAppsResponse{
        func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: QueryLiveDomainAppsResponseCodingKeys.self)
        try encoderContainer.encode(requestId, forKey: .requestId)
        try encoderContainer.encode(error, forKey: .error)
        try encoderContainer.encode(result, forKey: .result)
    }
}    
public class CreateLiveDomainResponse:NSObject,Codable
{
    var requestId:String?;

    var error:ServiceError?;

    var result:CreateLiveDomainResult?;

    enum CreateLiveDomainResponseCodingKeys: String, CodingKey {
        case requestId
        case error
        case result
    }

    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: CreateLiveDomainResponseCodingKeys.self)
        self.requestId = try decoderContainer.decodeIfPresent(String?.self, forKey: .requestId) ?? nil
        self.error = try decoderContainer.decodeIfPresent(ServiceError?.self, forKey: .error) ?? nil
        self.result = try decoderContainer.decodeIfPresent(CreateLiveDomainResult?.self, forKey: .result) ?? nil
    }
}

public extension CreateLiveDomainResponse{
        func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: CreateLiveDomainResponseCodingKeys.self)
        try encoderContainer.encode(requestId, forKey: .requestId)
        try encoderContainer.encode(error, forKey: .error)
        try encoderContainer.encode(result, forKey: .result)
    }
}    
/// 查询直播域名详情v2 
public class QueryLiveDomainDetailV2Result:NSObject,JdCloudResult
{
    /// 域名id
    var id:Int?

    /// 域名
    var domain:String?

    /// 域名类型,（publish为推流域名；play为播放域名）
    var domainType:String?

    /// 推流域名
    var publishDomain:String?

    /// 创建时间
    var createTime:String?

    /// 域名对应的cname
    var cname:String?

    /// 域名所属模式：1,推流push，2,拉流pull，3,混合mix
    var siteType:String?

    /// 域名所属协议（rtmp,hls,hdl）
    var playProtocol:[String?]?

    /// 域名状态
    var status:String?

    /// 回源信息
    var source:SnowLeopardBackSourceInfo?

    /// 域名回源类型
    var sourceType:String?

    /// 回源协议:rtmp,http-flv,https-flv,http-hls,https-hls
    var backSourceType:String?

    /// 视频格式 H.264
    var videoType:String?

    /// 音频格式AAC
    var audioType:String?

    /// 域名类型(live)
    var type:String?

    /// 默认回源host
    var defaultSourceHost:String?

    /// ICP备案号
    var archiveNo:String?

    /// 转推地址
    var forwardCustomVhost:String?

    /// flv格式路径
    var flvUrls:[String?]?

    /// hls格式路径
    var hlsUrls:[String?]?

    /// rtmp格式路径
    var rtmpUrls:[String?]?

    /// 转协议信息
    var protocolConverts:[ProtocolConvert?]?

    /// https证书
    var certificate:String?

    /// https私钥
    var rsaKey:String?

    /// url鉴权开关（1：on；2：off）
    var accesskeyType:Int?

    /// url鉴权key
    var accesskeyKey:String?

    /// playAuthLifeTime，默认为0
    var playAuthLifeTime:Int?

    /// authLifeTime，默认为0
    var authLifeTime:Int?

    /// 转推鉴权开关（1：on；0：off）
    var forwardAccessKeyType:Int?

    /// 转推鉴权key
    var forwardPrivateKey:String?

    /// 回源鉴权开关（1：on；0：off）
    var originAccessKeyType:Int?

    /// 回源鉴权key
    var originPrivateKey:String?

    /// 允许的app列表
    var allowApps:[String?]?

    /// ip黑名单列表
    var ips:[String?]?

    /// 是否开启ip黑名单（on；off）
    var blackIpsEnable:String?

    /// 是否忽略参数（on，off）
    var ignoreQueryString:String?

    /// refer类型
    var referType:String?

    /// refer列表
    var referList:[String?]?

    /// 允许refer为不规则内容
    var allowNoReferHeader:String?

    /// 允许不带referer头访问url资源
    var allowNullReferHeader:String?

    /// 推流中断超时时间(单位秒)
    var publishNormalTimeout:Int?

    /// 推断流通知Url
    var notifyCustomUrl:String?

    /// 推断流通知key
    var notifyCustomAuthKey:String?

    /// 证书来源有两种类型：default,ssl
    var certFrom:String?

    /// ssl证书id
    var sslCertId:String?

    /// 证书名称
    var certName:String?

    /// 证书类型
    var certType:String?

    /// 开始时间
    var sslCertStartTime:String?

    /// 结束时间
    var sslCertEndTime:String?

    /// 对私钥文件使用sha256算法计算的摘要信息
    var digest:String?

    /// 加速区域
    var accelerateRegion:String?



    public override init(){
        super.init()
    }

    enum QueryLiveDomainDetailV2ResultCodingKeys: String, CodingKey {
        case id
        case domain
        case domainType
        case publishDomain
        case createTime
        case cname
        case siteType
        case playProtocol
        case status
        case source
        case sourceType
        case backSourceType
        case videoType
        case audioType
        case type
        case defaultSourceHost
        case archiveNo
        case forwardCustomVhost
        case flvUrls
        case hlsUrls
        case rtmpUrls
        case protocolConverts
        case certificate
        case rsaKey
        case accesskeyType
        case accesskeyKey
        case playAuthLifeTime
        case authLifeTime
        case forwardAccessKeyType
        case forwardPrivateKey
        case originAccessKeyType
        case originPrivateKey
        case allowApps
        case ips
        case blackIpsEnable
        case ignoreQueryString
        case referType
        case referList
        case allowNoReferHeader
        case allowNullReferHeader
        case publishNormalTimeout
        case notifyCustomUrl
        case notifyCustomAuthKey
        case certFrom
        case sslCertId
        case certName
        case certType
        case sslCertStartTime
        case sslCertEndTime
        case digest
        case accelerateRegion
    }

    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: QueryLiveDomainDetailV2ResultCodingKeys.self)
        if decoderContainer.contains(.id)
        {
            self.id = try decoderContainer.decode(Int?.self, forKey: .id)
        }
        if decoderContainer.contains(.domain)
        {
            self.domain = try decoderContainer.decode(String?.self, forKey: .domain)
        }
        if decoderContainer.contains(.domainType)
        {
            self.domainType = try decoderContainer.decode(String?.self, forKey: .domainType)
        }
        if decoderContainer.contains(.publishDomain)
        {
            self.publishDomain = try decoderContainer.decode(String?.self, forKey: .publishDomain)
        }
        if decoderContainer.contains(.createTime)
        {
            self.createTime = try decoderContainer.decode(String?.self, forKey: .createTime)
        }
        if decoderContainer.contains(.cname)
        {
            self.cname = try decoderContainer.decode(String?.self, forKey: .cname)
        }
        if decoderContainer.contains(.siteType)
        {
            self.siteType = try decoderContainer.decode(String?.self, forKey: .siteType)
        }
        if decoderContainer.contains(.playProtocol)
        {
            self.playProtocol = try decoderContainer.decode([String?]?.self, forKey: .playProtocol)
        }
        if decoderContainer.contains(.status)
        {
            self.status = try decoderContainer.decode(String?.self, forKey: .status)
        }
        if decoderContainer.contains(.source)
        {
            self.source = try decoderContainer.decode(SnowLeopardBackSourceInfo?.self, forKey: .source)
        }
        if decoderContainer.contains(.sourceType)
        {
            self.sourceType = try decoderContainer.decode(String?.self, forKey: .sourceType)
        }
        if decoderContainer.contains(.backSourceType)
        {
            self.backSourceType = try decoderContainer.decode(String?.self, forKey: .backSourceType)
        }
        if decoderContainer.contains(.videoType)
        {
            self.videoType = try decoderContainer.decode(String?.self, forKey: .videoType)
        }
        if decoderContainer.contains(.audioType)
        {
            self.audioType = try decoderContainer.decode(String?.self, forKey: .audioType)
        }
        if decoderContainer.contains(.type)
        {
            self.type = try decoderContainer.decode(String?.self, forKey: .type)
        }
        if decoderContainer.contains(.defaultSourceHost)
        {
            self.defaultSourceHost = try decoderContainer.decode(String?.self, forKey: .defaultSourceHost)
        }
        if decoderContainer.contains(.archiveNo)
        {
            self.archiveNo = try decoderContainer.decode(String?.self, forKey: .archiveNo)
        }
        if decoderContainer.contains(.forwardCustomVhost)
        {
            self.forwardCustomVhost = try decoderContainer.decode(String?.self, forKey: .forwardCustomVhost)
        }
        if decoderContainer.contains(.flvUrls)
        {
            self.flvUrls = try decoderContainer.decode([String?]?.self, forKey: .flvUrls)
        }
        if decoderContainer.contains(.hlsUrls)
        {
            self.hlsUrls = try decoderContainer.decode([String?]?.self, forKey: .hlsUrls)
        }
        if decoderContainer.contains(.rtmpUrls)
        {
            self.rtmpUrls = try decoderContainer.decode([String?]?.self, forKey: .rtmpUrls)
        }
        if decoderContainer.contains(.protocolConverts)
        {
            self.protocolConverts = try decoderContainer.decode([ProtocolConvert?]?.self, forKey: .protocolConverts)
        }
        if decoderContainer.contains(.certificate)
        {
            self.certificate = try decoderContainer.decode(String?.self, forKey: .certificate)
        }
        if decoderContainer.contains(.rsaKey)
        {
            self.rsaKey = try decoderContainer.decode(String?.self, forKey: .rsaKey)
        }
        if decoderContainer.contains(.accesskeyType)
        {
            self.accesskeyType = try decoderContainer.decode(Int?.self, forKey: .accesskeyType)
        }
        if decoderContainer.contains(.accesskeyKey)
        {
            self.accesskeyKey = try decoderContainer.decode(String?.self, forKey: .accesskeyKey)
        }
        if decoderContainer.contains(.playAuthLifeTime)
        {
            self.playAuthLifeTime = try decoderContainer.decode(Int?.self, forKey: .playAuthLifeTime)
        }
        if decoderContainer.contains(.authLifeTime)
        {
            self.authLifeTime = try decoderContainer.decode(Int?.self, forKey: .authLifeTime)
        }
        if decoderContainer.contains(.forwardAccessKeyType)
        {
            self.forwardAccessKeyType = try decoderContainer.decode(Int?.self, forKey: .forwardAccessKeyType)
        }
        if decoderContainer.contains(.forwardPrivateKey)
        {
            self.forwardPrivateKey = try decoderContainer.decode(String?.self, forKey: .forwardPrivateKey)
        }
        if decoderContainer.contains(.originAccessKeyType)
        {
            self.originAccessKeyType = try decoderContainer.decode(Int?.self, forKey: .originAccessKeyType)
        }
        if decoderContainer.contains(.originPrivateKey)
        {
            self.originPrivateKey = try decoderContainer.decode(String?.self, forKey: .originPrivateKey)
        }
        if decoderContainer.contains(.allowApps)
        {
            self.allowApps = try decoderContainer.decode([String?]?.self, forKey: .allowApps)
        }
        if decoderContainer.contains(.ips)
        {
            self.ips = try decoderContainer.decode([String?]?.self, forKey: .ips)
        }
        if decoderContainer.contains(.blackIpsEnable)
        {
            self.blackIpsEnable = try decoderContainer.decode(String?.self, forKey: .blackIpsEnable)
        }
        if decoderContainer.contains(.ignoreQueryString)
        {
            self.ignoreQueryString = try decoderContainer.decode(String?.self, forKey: .ignoreQueryString)
        }
        if decoderContainer.contains(.referType)
        {
            self.referType = try decoderContainer.decode(String?.self, forKey: .referType)
        }
        if decoderContainer.contains(.referList)
        {
            self.referList = try decoderContainer.decode([String?]?.self, forKey: .referList)
        }
        if decoderContainer.contains(.allowNoReferHeader)
        {
            self.allowNoReferHeader = try decoderContainer.decode(String?.self, forKey: .allowNoReferHeader)
        }
        if decoderContainer.contains(.allowNullReferHeader)
        {
            self.allowNullReferHeader = try decoderContainer.decode(String?.self, forKey: .allowNullReferHeader)
        }
        if decoderContainer.contains(.publishNormalTimeout)
        {
            self.publishNormalTimeout = try decoderContainer.decode(Int?.self, forKey: .publishNormalTimeout)
        }
        if decoderContainer.contains(.notifyCustomUrl)
        {
            self.notifyCustomUrl = try decoderContainer.decode(String?.self, forKey: .notifyCustomUrl)
        }
        if decoderContainer.contains(.notifyCustomAuthKey)
        {
            self.notifyCustomAuthKey = try decoderContainer.decode(String?.self, forKey: .notifyCustomAuthKey)
        }
        if decoderContainer.contains(.certFrom)
        {
            self.certFrom = try decoderContainer.decode(String?.self, forKey: .certFrom)
        }
        if decoderContainer.contains(.sslCertId)
        {
            self.sslCertId = try decoderContainer.decode(String?.self, forKey: .sslCertId)
        }
        if decoderContainer.contains(.certName)
        {
            self.certName = try decoderContainer.decode(String?.self, forKey: .certName)
        }
        if decoderContainer.contains(.certType)
        {
            self.certType = try decoderContainer.decode(String?.self, forKey: .certType)
        }
        if decoderContainer.contains(.sslCertStartTime)
        {
            self.sslCertStartTime = try decoderContainer.decode(String?.self, forKey: .sslCertStartTime)
        }
        if decoderContainer.contains(.sslCertEndTime)
        {
            self.sslCertEndTime = try decoderContainer.decode(String?.self, forKey: .sslCertEndTime)
        }
        if decoderContainer.contains(.digest)
        {
            self.digest = try decoderContainer.decode(String?.self, forKey: .digest)
        }
        if decoderContainer.contains(.accelerateRegion)
        {
            self.accelerateRegion = try decoderContainer.decode(String?.self, forKey: .accelerateRegion)
        }
    }
}
public extension QueryLiveDomainDetailV2Result{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: QueryLiveDomainDetailV2ResultCodingKeys.self)
        try encoderContainer.encode(id, forKey: .id)
        try encoderContainer.encode(domain, forKey: .domain)
        try encoderContainer.encode(domainType, forKey: .domainType)
        try encoderContainer.encode(publishDomain, forKey: .publishDomain)
        try encoderContainer.encode(createTime, forKey: .createTime)
        try encoderContainer.encode(cname, forKey: .cname)
        try encoderContainer.encode(siteType, forKey: .siteType)
        try encoderContainer.encode(playProtocol, forKey: .playProtocol)
        try encoderContainer.encode(status, forKey: .status)
        try encoderContainer.encode(source, forKey: .source)
        try encoderContainer.encode(sourceType, forKey: .sourceType)
        try encoderContainer.encode(backSourceType, forKey: .backSourceType)
        try encoderContainer.encode(videoType, forKey: .videoType)
        try encoderContainer.encode(audioType, forKey: .audioType)
        try encoderContainer.encode(type, forKey: .type)
        try encoderContainer.encode(defaultSourceHost, forKey: .defaultSourceHost)
        try encoderContainer.encode(archiveNo, forKey: .archiveNo)
        try encoderContainer.encode(forwardCustomVhost, forKey: .forwardCustomVhost)
        try encoderContainer.encode(flvUrls, forKey: .flvUrls)
        try encoderContainer.encode(hlsUrls, forKey: .hlsUrls)
        try encoderContainer.encode(rtmpUrls, forKey: .rtmpUrls)
        try encoderContainer.encode(protocolConverts, forKey: .protocolConverts)
        try encoderContainer.encode(certificate, forKey: .certificate)
        try encoderContainer.encode(rsaKey, forKey: .rsaKey)
        try encoderContainer.encode(accesskeyType, forKey: .accesskeyType)
        try encoderContainer.encode(accesskeyKey, forKey: .accesskeyKey)
        try encoderContainer.encode(playAuthLifeTime, forKey: .playAuthLifeTime)
        try encoderContainer.encode(authLifeTime, forKey: .authLifeTime)
        try encoderContainer.encode(forwardAccessKeyType, forKey: .forwardAccessKeyType)
        try encoderContainer.encode(forwardPrivateKey, forKey: .forwardPrivateKey)
        try encoderContainer.encode(originAccessKeyType, forKey: .originAccessKeyType)
        try encoderContainer.encode(originPrivateKey, forKey: .originPrivateKey)
        try encoderContainer.encode(allowApps, forKey: .allowApps)
        try encoderContainer.encode(ips, forKey: .ips)
        try encoderContainer.encode(blackIpsEnable, forKey: .blackIpsEnable)
        try encoderContainer.encode(ignoreQueryString, forKey: .ignoreQueryString)
        try encoderContainer.encode(referType, forKey: .referType)
        try encoderContainer.encode(referList, forKey: .referList)
        try encoderContainer.encode(allowNoReferHeader, forKey: .allowNoReferHeader)
        try encoderContainer.encode(allowNullReferHeader, forKey: .allowNullReferHeader)
        try encoderContainer.encode(publishNormalTimeout, forKey: .publishNormalTimeout)
        try encoderContainer.encode(notifyCustomUrl, forKey: .notifyCustomUrl)
        try encoderContainer.encode(notifyCustomAuthKey, forKey: .notifyCustomAuthKey)
        try encoderContainer.encode(certFrom, forKey: .certFrom)
        try encoderContainer.encode(sslCertId, forKey: .sslCertId)
        try encoderContainer.encode(certName, forKey: .certName)
        try encoderContainer.encode(certType, forKey: .certType)
        try encoderContainer.encode(sslCertStartTime, forKey: .sslCertStartTime)
        try encoderContainer.encode(sslCertEndTime, forKey: .sslCertEndTime)
        try encoderContainer.encode(digest, forKey: .digest)
        try encoderContainer.encode(accelerateRegion, forKey: .accelerateRegion)
    }
}
/// 查询直播域名详情v1 
public class QueryLiveDomainDetailResult:NSObject,JdCloudResult
{
    /// 域名类型
    var domainType:String?

    /// 播放域名
    var playDomain:String?

    /// 推流域名
    var publishDomain:String?

    /// 回源域名
    var originDomain:String?

    /// 创建时间
    var createdTime:String?

    /// cname
    var cname:String?

    /// 站点类型推流push，拉流pull
    var siteType:String?

    /// 域名状态
    var status:String?

    /// 回源信息
    var source:BackSourceInfo?

    /// 域名回源类型
    var sourceType:String?

    /// 回源类型目前只能未rtmp
    var backSourceType:String?

    /// 视频格式 H.264
    var videoType:String?

    /// 音频格式AAC
    var audioType:String?

    /// 域名类型
    var type:String?

    /// 默认回源host
    var defaultSourceHost:String?

    /// 备案号
    var archiveNo:String?

    /// rtmpDomain
    var rtmpDomain:String?

    /// rtmpCname
    var rtmpCname:String?

    /// hdlDomain
    var hdlDomain:String?

    /// hdlCname
    var hdlCname:String?

    /// hlsDomain
    var hlsDomain:String?

    /// hlsCname
    var hlsCname:String?

    /// forwardCustomVhost
    var forwardCustomVhost:String?

    /// flvUrls
    var flvUrls:[String?]?

    /// hlsUrls
    var hlsUrls:[String?]?

    /// rtmpUrls
    var rtmpUrls:[String?]?

    /// 转协议
    var protocolConverts:[ProtocolConvert?]?

    /// https证书
    var certificate:String?

    /// https私钥
    var rsaKey:String?

    /// url鉴权开关
    var accesskeyType:Int?

    /// url鉴权key
    var accesskeyKey:String?

    /// playAuthLifeTime
    var playAuthLifeTime:Int?

    /// authLifeTime
    var authLifeTime:Int?

    /// 转推鉴权开关
    var forwardAccessKeyType:Int?

    /// 转推鉴权key
    var forwardPrivateKey:String?

    /// 回源鉴权开关
    var originAccessKeyType:Int?

    /// 回源鉴权key
    var originPrivateKey:String?

    /// app列表
    var allowApps:[String?]?

    /// ip黑名单列表
    var ips:[String?]?

    /// 是否开启ip黑名单
    var blackIpsEnable:String?

    /// 外部关联id
    var externId:String?

    /// ignoreQueryString
    var ignoreQueryString:String?

    /// referType
    var referType:String?

    /// referList
    var referList:[String?]?

    /// 允许无refer
    var allowNoReferHeader:String?

    /// 允许空refer
    var allowNullReferHeader:String?

    /// 推流中断超时时间(单位秒)
    var publishNormalTimeout:String?

    /// 推断流通知Url
    var notifyCustomUrl:String?

    /// 推断流通知key
    var notifyCustomAuthKey:String?

    /// 证书来源有两种类型：default,ssl
    var certFrom:String?

    /// ssl证书id
    var sslCertId:String?

    /// 证书名称
    var certName:String?

    /// 证书类型
    var certType:String?

    /// SslCertStartTime
    var sslCertStartTime:String?

    /// SslCertEndTime
    var sslCertEndTime:String?

    /// AccelerateRegion
    var accelerateRegion:String?



    public override init(){
        super.init()
    }

    enum QueryLiveDomainDetailResultCodingKeys: String, CodingKey {
        case domainType
        case playDomain
        case publishDomain
        case originDomain
        case createdTime
        case cname
        case siteType
        case status
        case source
        case sourceType
        case backSourceType
        case videoType
        case audioType
        case type
        case defaultSourceHost
        case archiveNo
        case rtmpDomain
        case rtmpCname
        case hdlDomain
        case hdlCname
        case hlsDomain
        case hlsCname
        case forwardCustomVhost
        case flvUrls
        case hlsUrls
        case rtmpUrls
        case protocolConverts
        case certificate
        case rsaKey
        case accesskeyType
        case accesskeyKey
        case playAuthLifeTime
        case authLifeTime
        case forwardAccessKeyType
        case forwardPrivateKey
        case originAccessKeyType
        case originPrivateKey
        case allowApps
        case ips
        case blackIpsEnable
        case externId
        case ignoreQueryString
        case referType
        case referList
        case allowNoReferHeader
        case allowNullReferHeader
        case publishNormalTimeout
        case notifyCustomUrl
        case notifyCustomAuthKey
        case certFrom
        case sslCertId
        case certName
        case certType
        case sslCertStartTime
        case sslCertEndTime
        case accelerateRegion
    }

    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: QueryLiveDomainDetailResultCodingKeys.self)
        if decoderContainer.contains(.domainType)
        {
            self.domainType = try decoderContainer.decode(String?.self, forKey: .domainType)
        }
        if decoderContainer.contains(.playDomain)
        {
            self.playDomain = try decoderContainer.decode(String?.self, forKey: .playDomain)
        }
        if decoderContainer.contains(.publishDomain)
        {
            self.publishDomain = try decoderContainer.decode(String?.self, forKey: .publishDomain)
        }
        if decoderContainer.contains(.originDomain)
        {
            self.originDomain = try decoderContainer.decode(String?.self, forKey: .originDomain)
        }
        if decoderContainer.contains(.createdTime)
        {
            self.createdTime = try decoderContainer.decode(String?.self, forKey: .createdTime)
        }
        if decoderContainer.contains(.cname)
        {
            self.cname = try decoderContainer.decode(String?.self, forKey: .cname)
        }
        if decoderContainer.contains(.siteType)
        {
            self.siteType = try decoderContainer.decode(String?.self, forKey: .siteType)
        }
        if decoderContainer.contains(.status)
        {
            self.status = try decoderContainer.decode(String?.self, forKey: .status)
        }
        if decoderContainer.contains(.source)
        {
            self.source = try decoderContainer.decode(BackSourceInfo?.self, forKey: .source)
        }
        if decoderContainer.contains(.sourceType)
        {
            self.sourceType = try decoderContainer.decode(String?.self, forKey: .sourceType)
        }
        if decoderContainer.contains(.backSourceType)
        {
            self.backSourceType = try decoderContainer.decode(String?.self, forKey: .backSourceType)
        }
        if decoderContainer.contains(.videoType)
        {
            self.videoType = try decoderContainer.decode(String?.self, forKey: .videoType)
        }
        if decoderContainer.contains(.audioType)
        {
            self.audioType = try decoderContainer.decode(String?.self, forKey: .audioType)
        }
        if decoderContainer.contains(.type)
        {
            self.type = try decoderContainer.decode(String?.self, forKey: .type)
        }
        if decoderContainer.contains(.defaultSourceHost)
        {
            self.defaultSourceHost = try decoderContainer.decode(String?.self, forKey: .defaultSourceHost)
        }
        if decoderContainer.contains(.archiveNo)
        {
            self.archiveNo = try decoderContainer.decode(String?.self, forKey: .archiveNo)
        }
        if decoderContainer.contains(.rtmpDomain)
        {
            self.rtmpDomain = try decoderContainer.decode(String?.self, forKey: .rtmpDomain)
        }
        if decoderContainer.contains(.rtmpCname)
        {
            self.rtmpCname = try decoderContainer.decode(String?.self, forKey: .rtmpCname)
        }
        if decoderContainer.contains(.hdlDomain)
        {
            self.hdlDomain = try decoderContainer.decode(String?.self, forKey: .hdlDomain)
        }
        if decoderContainer.contains(.hdlCname)
        {
            self.hdlCname = try decoderContainer.decode(String?.self, forKey: .hdlCname)
        }
        if decoderContainer.contains(.hlsDomain)
        {
            self.hlsDomain = try decoderContainer.decode(String?.self, forKey: .hlsDomain)
        }
        if decoderContainer.contains(.hlsCname)
        {
            self.hlsCname = try decoderContainer.decode(String?.self, forKey: .hlsCname)
        }
        if decoderContainer.contains(.forwardCustomVhost)
        {
            self.forwardCustomVhost = try decoderContainer.decode(String?.self, forKey: .forwardCustomVhost)
        }
        if decoderContainer.contains(.flvUrls)
        {
            self.flvUrls = try decoderContainer.decode([String?]?.self, forKey: .flvUrls)
        }
        if decoderContainer.contains(.hlsUrls)
        {
            self.hlsUrls = try decoderContainer.decode([String?]?.self, forKey: .hlsUrls)
        }
        if decoderContainer.contains(.rtmpUrls)
        {
            self.rtmpUrls = try decoderContainer.decode([String?]?.self, forKey: .rtmpUrls)
        }
        if decoderContainer.contains(.protocolConverts)
        {
            self.protocolConverts = try decoderContainer.decode([ProtocolConvert?]?.self, forKey: .protocolConverts)
        }
        if decoderContainer.contains(.certificate)
        {
            self.certificate = try decoderContainer.decode(String?.self, forKey: .certificate)
        }
        if decoderContainer.contains(.rsaKey)
        {
            self.rsaKey = try decoderContainer.decode(String?.self, forKey: .rsaKey)
        }
        if decoderContainer.contains(.accesskeyType)
        {
            self.accesskeyType = try decoderContainer.decode(Int?.self, forKey: .accesskeyType)
        }
        if decoderContainer.contains(.accesskeyKey)
        {
            self.accesskeyKey = try decoderContainer.decode(String?.self, forKey: .accesskeyKey)
        }
        if decoderContainer.contains(.playAuthLifeTime)
        {
            self.playAuthLifeTime = try decoderContainer.decode(Int?.self, forKey: .playAuthLifeTime)
        }
        if decoderContainer.contains(.authLifeTime)
        {
            self.authLifeTime = try decoderContainer.decode(Int?.self, forKey: .authLifeTime)
        }
        if decoderContainer.contains(.forwardAccessKeyType)
        {
            self.forwardAccessKeyType = try decoderContainer.decode(Int?.self, forKey: .forwardAccessKeyType)
        }
        if decoderContainer.contains(.forwardPrivateKey)
        {
            self.forwardPrivateKey = try decoderContainer.decode(String?.self, forKey: .forwardPrivateKey)
        }
        if decoderContainer.contains(.originAccessKeyType)
        {
            self.originAccessKeyType = try decoderContainer.decode(Int?.self, forKey: .originAccessKeyType)
        }
        if decoderContainer.contains(.originPrivateKey)
        {
            self.originPrivateKey = try decoderContainer.decode(String?.self, forKey: .originPrivateKey)
        }
        if decoderContainer.contains(.allowApps)
        {
            self.allowApps = try decoderContainer.decode([String?]?.self, forKey: .allowApps)
        }
        if decoderContainer.contains(.ips)
        {
            self.ips = try decoderContainer.decode([String?]?.self, forKey: .ips)
        }
        if decoderContainer.contains(.blackIpsEnable)
        {
            self.blackIpsEnable = try decoderContainer.decode(String?.self, forKey: .blackIpsEnable)
        }
        if decoderContainer.contains(.externId)
        {
            self.externId = try decoderContainer.decode(String?.self, forKey: .externId)
        }
        if decoderContainer.contains(.ignoreQueryString)
        {
            self.ignoreQueryString = try decoderContainer.decode(String?.self, forKey: .ignoreQueryString)
        }
        if decoderContainer.contains(.referType)
        {
            self.referType = try decoderContainer.decode(String?.self, forKey: .referType)
        }
        if decoderContainer.contains(.referList)
        {
            self.referList = try decoderContainer.decode([String?]?.self, forKey: .referList)
        }
        if decoderContainer.contains(.allowNoReferHeader)
        {
            self.allowNoReferHeader = try decoderContainer.decode(String?.self, forKey: .allowNoReferHeader)
        }
        if decoderContainer.contains(.allowNullReferHeader)
        {
            self.allowNullReferHeader = try decoderContainer.decode(String?.self, forKey: .allowNullReferHeader)
        }
        if decoderContainer.contains(.publishNormalTimeout)
        {
            self.publishNormalTimeout = try decoderContainer.decode(String?.self, forKey: .publishNormalTimeout)
        }
        if decoderContainer.contains(.notifyCustomUrl)
        {
            self.notifyCustomUrl = try decoderContainer.decode(String?.self, forKey: .notifyCustomUrl)
        }
        if decoderContainer.contains(.notifyCustomAuthKey)
        {
            self.notifyCustomAuthKey = try decoderContainer.decode(String?.self, forKey: .notifyCustomAuthKey)
        }
        if decoderContainer.contains(.certFrom)
        {
            self.certFrom = try decoderContainer.decode(String?.self, forKey: .certFrom)
        }
        if decoderContainer.contains(.sslCertId)
        {
            self.sslCertId = try decoderContainer.decode(String?.self, forKey: .sslCertId)
        }
        if decoderContainer.contains(.certName)
        {
            self.certName = try decoderContainer.decode(String?.self, forKey: .certName)
        }
        if decoderContainer.contains(.certType)
        {
            self.certType = try decoderContainer.decode(String?.self, forKey: .certType)
        }
        if decoderContainer.contains(.sslCertStartTime)
        {
            self.sslCertStartTime = try decoderContainer.decode(String?.self, forKey: .sslCertStartTime)
        }
        if decoderContainer.contains(.sslCertEndTime)
        {
            self.sslCertEndTime = try decoderContainer.decode(String?.self, forKey: .sslCertEndTime)
        }
        if decoderContainer.contains(.accelerateRegion)
        {
            self.accelerateRegion = try decoderContainer.decode(String?.self, forKey: .accelerateRegion)
        }
    }
}
public extension QueryLiveDomainDetailResult{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: QueryLiveDomainDetailResultCodingKeys.self)
        try encoderContainer.encode(domainType, forKey: .domainType)
        try encoderContainer.encode(playDomain, forKey: .playDomain)
        try encoderContainer.encode(publishDomain, forKey: .publishDomain)
        try encoderContainer.encode(originDomain, forKey: .originDomain)
        try encoderContainer.encode(createdTime, forKey: .createdTime)
        try encoderContainer.encode(cname, forKey: .cname)
        try encoderContainer.encode(siteType, forKey: .siteType)
        try encoderContainer.encode(status, forKey: .status)
        try encoderContainer.encode(source, forKey: .source)
        try encoderContainer.encode(sourceType, forKey: .sourceType)
        try encoderContainer.encode(backSourceType, forKey: .backSourceType)
        try encoderContainer.encode(videoType, forKey: .videoType)
        try encoderContainer.encode(audioType, forKey: .audioType)
        try encoderContainer.encode(type, forKey: .type)
        try encoderContainer.encode(defaultSourceHost, forKey: .defaultSourceHost)
        try encoderContainer.encode(archiveNo, forKey: .archiveNo)
        try encoderContainer.encode(rtmpDomain, forKey: .rtmpDomain)
        try encoderContainer.encode(rtmpCname, forKey: .rtmpCname)
        try encoderContainer.encode(hdlDomain, forKey: .hdlDomain)
        try encoderContainer.encode(hdlCname, forKey: .hdlCname)
        try encoderContainer.encode(hlsDomain, forKey: .hlsDomain)
        try encoderContainer.encode(hlsCname, forKey: .hlsCname)
        try encoderContainer.encode(forwardCustomVhost, forKey: .forwardCustomVhost)
        try encoderContainer.encode(flvUrls, forKey: .flvUrls)
        try encoderContainer.encode(hlsUrls, forKey: .hlsUrls)
        try encoderContainer.encode(rtmpUrls, forKey: .rtmpUrls)
        try encoderContainer.encode(protocolConverts, forKey: .protocolConverts)
        try encoderContainer.encode(certificate, forKey: .certificate)
        try encoderContainer.encode(rsaKey, forKey: .rsaKey)
        try encoderContainer.encode(accesskeyType, forKey: .accesskeyType)
        try encoderContainer.encode(accesskeyKey, forKey: .accesskeyKey)
        try encoderContainer.encode(playAuthLifeTime, forKey: .playAuthLifeTime)
        try encoderContainer.encode(authLifeTime, forKey: .authLifeTime)
        try encoderContainer.encode(forwardAccessKeyType, forKey: .forwardAccessKeyType)
        try encoderContainer.encode(forwardPrivateKey, forKey: .forwardPrivateKey)
        try encoderContainer.encode(originAccessKeyType, forKey: .originAccessKeyType)
        try encoderContainer.encode(originPrivateKey, forKey: .originPrivateKey)
        try encoderContainer.encode(allowApps, forKey: .allowApps)
        try encoderContainer.encode(ips, forKey: .ips)
        try encoderContainer.encode(blackIpsEnable, forKey: .blackIpsEnable)
        try encoderContainer.encode(externId, forKey: .externId)
        try encoderContainer.encode(ignoreQueryString, forKey: .ignoreQueryString)
        try encoderContainer.encode(referType, forKey: .referType)
        try encoderContainer.encode(referList, forKey: .referList)
        try encoderContainer.encode(allowNoReferHeader, forKey: .allowNoReferHeader)
        try encoderContainer.encode(allowNullReferHeader, forKey: .allowNullReferHeader)
        try encoderContainer.encode(publishNormalTimeout, forKey: .publishNormalTimeout)
        try encoderContainer.encode(notifyCustomUrl, forKey: .notifyCustomUrl)
        try encoderContainer.encode(notifyCustomAuthKey, forKey: .notifyCustomAuthKey)
        try encoderContainer.encode(certFrom, forKey: .certFrom)
        try encoderContainer.encode(sslCertId, forKey: .sslCertId)
        try encoderContainer.encode(certName, forKey: .certName)
        try encoderContainer.encode(certType, forKey: .certType)
        try encoderContainer.encode(sslCertStartTime, forKey: .sslCertStartTime)
        try encoderContainer.encode(sslCertEndTime, forKey: .sslCertEndTime)
        try encoderContainer.encode(accelerateRegion, forKey: .accelerateRegion)
    }
}
public class BatchCreateLiveDomainResponse:NSObject,Codable
{
    var requestId:String?;

    var error:ServiceError?;

    var result:BatchCreateLiveDomainResult?;

    enum BatchCreateLiveDomainResponseCodingKeys: String, CodingKey {
        case requestId
        case error
        case result
    }

    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: BatchCreateLiveDomainResponseCodingKeys.self)
        self.requestId = try decoderContainer.decodeIfPresent(String?.self, forKey: .requestId) ?? nil
        self.error = try decoderContainer.decodeIfPresent(ServiceError?.self, forKey: .error) ?? nil
        self.result = try decoderContainer.decodeIfPresent(BatchCreateLiveDomainResult?.self, forKey: .result) ?? nil
    }
}

public extension BatchCreateLiveDomainResponse{
        func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: BatchCreateLiveDomainResponseCodingKeys.self)
        try encoderContainer.encode(requestId, forKey: .requestId)
        try encoderContainer.encode(error, forKey: .error)
        try encoderContainer.encode(result, forKey: .result)
    }
}    

///  查询关联域名
public class DescribebindedDomainsRequest:JdCloudRequest
{
    /// 用户域名
    var domain:String


    public init(regionId: String,domain:String){
        self.domain = domain
        super.init(regionId: regionId)
    }


    enum DescribebindedDomainsRequestRequestCodingKeys: String, CodingKey {
        case domain
    }

    public override func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: DescribebindedDomainsRequestRequestCodingKeys.self)
        try encoderContainer.encode(domain, forKey: .domain)

    }
}

public class QueryLiveDomainDetailResponse:NSObject,Codable
{
    var requestId:String?;

    var error:ServiceError?;

    var result:QueryLiveDomainDetailResult?;

    enum QueryLiveDomainDetailResponseCodingKeys: String, CodingKey {
        case requestId
        case error
        case result
    }

    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: QueryLiveDomainDetailResponseCodingKeys.self)
        self.requestId = try decoderContainer.decodeIfPresent(String?.self, forKey: .requestId) ?? nil
        self.error = try decoderContainer.decodeIfPresent(ServiceError?.self, forKey: .error) ?? nil
        self.result = try decoderContainer.decodeIfPresent(QueryLiveDomainDetailResult?.self, forKey: .result) ?? nil
    }
}

public extension QueryLiveDomainDetailResponse{
        func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: QueryLiveDomainDetailResponseCodingKeys.self)
        try encoderContainer.encode(requestId, forKey: .requestId)
        try encoderContainer.encode(error, forKey: .error)
        try encoderContainer.encode(result, forKey: .result)
    }
}    
/// 创建直播域名V2 
public class CreateLiveDomainResult:NSObject,JdCloudResult
{
}

///  绑定推流域名
public class BindPublishDomainRequest:JdCloudRequest
{
    /// 用户域名
    var domain:String

    /// 推流域名
    var publishDomain:String


    public init(regionId: String,domain:String,publishDomain:String){
        self.domain = domain
        self.publishDomain = publishDomain
        super.init(regionId: regionId)
    }


    enum BindPublishDomainRequestRequestCodingKeys: String, CodingKey {
        case domain
        case publishDomain
    }

    public override func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: BindPublishDomainRequestRequestCodingKeys.self)
        try encoderContainer.encode(domain, forKey: .domain)
        try encoderContainer.encode(publishDomain, forKey: .publishDomain)

    }
}

/// 查询关联域名 
public class DescribebindedDomainsResult:NSObject,JdCloudResult
{
    /// 相关域名列表
    var relatedDomainList:[RelatedDomains?]?



    public override init(){
        super.init()
    }

    enum DescribebindedDomainsResultCodingKeys: String, CodingKey {
        case relatedDomainList
    }

    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: DescribebindedDomainsResultCodingKeys.self)
        if decoderContainer.contains(.relatedDomainList)
        {
            self.relatedDomainList = try decoderContainer.decode([RelatedDomains?]?.self, forKey: .relatedDomainList)
        }
    }
}
public extension DescribebindedDomainsResult{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: DescribebindedDomainsResultCodingKeys.self)
        try encoderContainer.encode(relatedDomainList, forKey: .relatedDomainList)
    }
}
public class DescribebindedDomainsResponse:NSObject,Codable
{
    var requestId:String?;

    var error:ServiceError?;

    var result:DescribebindedDomainsResult?;

    enum DescribebindedDomainsResponseCodingKeys: String, CodingKey {
        case requestId
        case error
        case result
    }

    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: DescribebindedDomainsResponseCodingKeys.self)
        self.requestId = try decoderContainer.decodeIfPresent(String?.self, forKey: .requestId) ?? nil
        self.error = try decoderContainer.decodeIfPresent(ServiceError?.self, forKey: .error) ?? nil
        self.result = try decoderContainer.decodeIfPresent(DescribebindedDomainsResult?.self, forKey: .result) ?? nil
    }
}

public extension DescribebindedDomainsResponse{
        func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: DescribebindedDomainsResponseCodingKeys.self)
        try encoderContainer.encode(requestId, forKey: .requestId)
        try encoderContainer.encode(error, forKey: .error)
        try encoderContainer.encode(result, forKey: .result)
    }
}    
/// 绑定推流域名 
public class BindPublishDomainResult:NSObject,JdCloudResult
{
}

///  查询直播域名详情v2
public class QueryLiveDomainDetailV2Request:JdCloudRequest
{
    /// 用户域名
    var domain:String


    public init(regionId: String,domain:String){
        self.domain = domain
        super.init(regionId: regionId)
    }


    enum QueryLiveDomainDetailV2RequestRequestCodingKeys: String, CodingKey {
        case domain
    }

    public override func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: QueryLiveDomainDetailV2RequestRequestCodingKeys.self)
        try encoderContainer.encode(domain, forKey: .domain)

    }
}

/// 查询直播域名app列表 
public class QueryLiveDomainAppsResult:NSObject,JdCloudResult
{
    /// app列表
    var apps:[String?]?

    /// 域名
    var domain:String?



    public override init(){
        super.init()
    }

    enum QueryLiveDomainAppsResultCodingKeys: String, CodingKey {
        case apps
        case domain
    }

    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: QueryLiveDomainAppsResultCodingKeys.self)
        if decoderContainer.contains(.apps)
        {
            self.apps = try decoderContainer.decode([String?]?.self, forKey: .apps)
        }
        if decoderContainer.contains(.domain)
        {
            self.domain = try decoderContainer.decode(String?.self, forKey: .domain)
        }
    }
}
public extension QueryLiveDomainAppsResult{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: QueryLiveDomainAppsResultCodingKeys.self)
        try encoderContainer.encode(apps, forKey: .apps)
        try encoderContainer.encode(domain, forKey: .domain)
    }
}

///  查询直播域名app列表
public class QueryLiveDomainAppsRequest:JdCloudRequest
{
    /// 用户域名
    var domain:String


    public init(regionId: String,domain:String){
        self.domain = domain
        super.init(regionId: regionId)
    }


    enum QueryLiveDomainAppsRequestRequestCodingKeys: String, CodingKey {
        case domain
    }

    public override func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: QueryLiveDomainAppsRequestRequestCodingKeys.self)
        try encoderContainer.encode(domain, forKey: .domain)

    }
}


///  创建直播域名
public class BatchCreateLiveDomainRequest:JdCloudRequest
{
    /// 播放域名
    var playDomain:String?

    /// 创建推流域名时，必传推流域名
    var publishDomain:String?

    /// 回源类型只能是[ips,domain]中的一种
    var sourceType:String?

    /// BackHttpType
    var backHttpType:String?

    /// 默认回源host
    var defaultSourceHost:String?

    /// 站点类型pull(拉流)push(推流)
    var siteType:String?

    /// 回源类型，目前只能为rtmp
    var backSourceType:String?

    /// IpSource
    var ipSource:[IpSourceInfo?]?

    /// DomainSource
    var domainSource:[DomainSourceInfo?]?

    /// 加速区域(mainLand:中国大陆，nonMainLand:海外加港澳台，all:全球)默认为中国大陆
    var accelerateRegion:String?




    enum BatchCreateLiveDomainRequestRequestCodingKeys: String, CodingKey {
        case playDomain
        case publishDomain
        case sourceType
        case backHttpType
        case defaultSourceHost
        case siteType
        case backSourceType
        case ipSource
        case domainSource
        case accelerateRegion
    }

    public override func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: BatchCreateLiveDomainRequestRequestCodingKeys.self)
        try encoderContainer.encode(playDomain, forKey: .playDomain)
        try encoderContainer.encode(publishDomain, forKey: .publishDomain)
        try encoderContainer.encode(sourceType, forKey: .sourceType)
        try encoderContainer.encode(backHttpType, forKey: .backHttpType)
        try encoderContainer.encode(defaultSourceHost, forKey: .defaultSourceHost)
        try encoderContainer.encode(siteType, forKey: .siteType)
        try encoderContainer.encode(backSourceType, forKey: .backSourceType)
        try encoderContainer.encode(ipSource, forKey: .ipSource)
        try encoderContainer.encode(domainSource, forKey: .domainSource)
        try encoderContainer.encode(accelerateRegion, forKey: .accelerateRegion)

    }
}


///  设置转推域名
public class ModifyLiveDomainForwardCustomVhostRequest:JdCloudRequest
{
    /// 转推域名
    var forwardCustomVhost:String?

    /// 用户域名
    var domain:String


    public init(regionId: String,domain:String){
        self.domain = domain
        super.init(regionId: regionId)
    }


    enum ModifyLiveDomainForwardCustomVhostRequestRequestCodingKeys: String, CodingKey {
        case forwardCustomVhost
        case domain
    }

    public override func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: ModifyLiveDomainForwardCustomVhostRequestRequestCodingKeys.self)
        try encoderContainer.encode(forwardCustomVhost, forKey: .forwardCustomVhost)
        try encoderContainer.encode(domain, forKey: .domain)

    }
}


///  查询直播域名详情v1
public class QueryLiveDomainDetailRequest:JdCloudRequest
{
    /// 用户域名
    var domain:String


    public init(regionId: String,domain:String){
        self.domain = domain
        super.init(regionId: regionId)
    }


    enum QueryLiveDomainDetailRequestRequestCodingKeys: String, CodingKey {
        case domain
    }

    public override func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: QueryLiveDomainDetailRequestRequestCodingKeys.self)
        try encoderContainer.encode(domain, forKey: .domain)

    }
}

public class DescribePublishDomainsResponse:NSObject,Codable
{
    var requestId:String?;

    var error:ServiceError?;

    var result:DescribePublishDomainsResult?;

    enum DescribePublishDomainsResponseCodingKeys: String, CodingKey {
        case requestId
        case error
        case result
    }

    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: DescribePublishDomainsResponseCodingKeys.self)
        self.requestId = try decoderContainer.decodeIfPresent(String?.self, forKey: .requestId) ?? nil
        self.error = try decoderContainer.decodeIfPresent(ServiceError?.self, forKey: .error) ?? nil
        self.result = try decoderContainer.decodeIfPresent(DescribePublishDomainsResult?.self, forKey: .result) ?? nil
    }
}

public extension DescribePublishDomainsResponse{
        func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: DescribePublishDomainsResponseCodingKeys.self)
        try encoderContainer.encode(requestId, forKey: .requestId)
        try encoderContainer.encode(error, forKey: .error)
        try encoderContainer.encode(result, forKey: .result)
    }
}    
public class QueryLiveDomainDetailV2Response:NSObject,Codable
{
    var requestId:String?;

    var error:ServiceError?;

    var result:QueryLiveDomainDetailV2Result?;

    enum QueryLiveDomainDetailV2ResponseCodingKeys: String, CodingKey {
        case requestId
        case error
        case result
    }

    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: QueryLiveDomainDetailV2ResponseCodingKeys.self)
        self.requestId = try decoderContainer.decodeIfPresent(String?.self, forKey: .requestId) ?? nil
        self.error = try decoderContainer.decodeIfPresent(ServiceError?.self, forKey: .error) ?? nil
        self.result = try decoderContainer.decodeIfPresent(QueryLiveDomainDetailV2Result?.self, forKey: .result) ?? nil
    }
}

public extension QueryLiveDomainDetailV2Response{
        func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: QueryLiveDomainDetailV2ResponseCodingKeys.self)
        try encoderContainer.encode(requestId, forKey: .requestId)
        try encoderContainer.encode(error, forKey: .error)
        try encoderContainer.encode(result, forKey: .result)
    }
}    

///  创建直播域名V2
public class CreateLiveDomainRequest:JdCloudRequest
{
    /// 播放域名（仅siteType&#x3D;1且publishDomain不为空时可为空）
    var playDomain:String?

    /// 推流域名（siteType&#x3D;push时playDomain与publishDomain不能同时传入）
    var publishDomain:String?

    /// 回源类型只能是[ips,domain]中的一种
    var sourceType:String?

    /// BackHttpType
    var backHttpType:String?

    /// 默认回源host
    var defaultSourceHost:String?

    /// 站点类型1:push(推流模式),2:pull(拉流模式),3:mix(混合模式)
    var siteType:String?

    /// 回源类型，支持rtmp, http-flv, https-flv, http-hls,https-hls，默认rtmp
    var backSourceType:String?

    /// 播放协议，默认为rtmp,hdl,hls全选
    var playProtocol:[String?]?

    /// 转推地址
    var forwardCustomVhost:String?

    /// 回源IP信息
    var ipSource:[IpSourceInfo?]?

    /// 回源域名信息
    var domainSource:[DomainSourceInfo?]?

    /// 默认为H.264
    var videoType:String?

    /// 默认为AAC
    var audioType:String?




    enum CreateLiveDomainRequestRequestCodingKeys: String, CodingKey {
        case playDomain
        case publishDomain
        case sourceType
        case backHttpType
        case defaultSourceHost
        case siteType
        case backSourceType
        case playProtocol
        case forwardCustomVhost
        case ipSource
        case domainSource
        case videoType
        case audioType
    }

    public override func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: CreateLiveDomainRequestRequestCodingKeys.self)
        try encoderContainer.encode(playDomain, forKey: .playDomain)
        try encoderContainer.encode(publishDomain, forKey: .publishDomain)
        try encoderContainer.encode(sourceType, forKey: .sourceType)
        try encoderContainer.encode(backHttpType, forKey: .backHttpType)
        try encoderContainer.encode(defaultSourceHost, forKey: .defaultSourceHost)
        try encoderContainer.encode(siteType, forKey: .siteType)
        try encoderContainer.encode(backSourceType, forKey: .backSourceType)
        try encoderContainer.encode(playProtocol, forKey: .playProtocol)
        try encoderContainer.encode(forwardCustomVhost, forKey: .forwardCustomVhost)
        try encoderContainer.encode(ipSource, forKey: .ipSource)
        try encoderContainer.encode(domainSource, forKey: .domainSource)
        try encoderContainer.encode(videoType, forKey: .videoType)
        try encoderContainer.encode(audioType, forKey: .audioType)

    }
}


///  查询全部推流域名
public class DescribePublishDomainsRequest:JdCloudRequest
{
}

public class ModifyLiveDomainForwardCustomVhostResponse:NSObject,Codable
{
    var requestId:String?;

    var error:ServiceError?;

    var result:ModifyLiveDomainForwardCustomVhostResult?;

    enum ModifyLiveDomainForwardCustomVhostResponseCodingKeys: String, CodingKey {
        case requestId
        case error
        case result
    }

    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: ModifyLiveDomainForwardCustomVhostResponseCodingKeys.self)
        self.requestId = try decoderContainer.decodeIfPresent(String?.self, forKey: .requestId) ?? nil
        self.error = try decoderContainer.decodeIfPresent(ServiceError?.self, forKey: .error) ?? nil
        self.result = try decoderContainer.decodeIfPresent(ModifyLiveDomainForwardCustomVhostResult?.self, forKey: .result) ?? nil
    }
}

public extension ModifyLiveDomainForwardCustomVhostResponse{
        func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: ModifyLiveDomainForwardCustomVhostResponseCodingKeys.self)
        try encoderContainer.encode(requestId, forKey: .requestId)
        try encoderContainer.encode(error, forKey: .error)
        try encoderContainer.encode(result, forKey: .result)
    }
}    
/// 查询全部推流域名 
public class DescribePublishDomainsResult:NSObject,JdCloudResult
{
    /// 推流域名列表
    var publishDomainList:[String?]?



    public override init(){
        super.init()
    }

    enum DescribePublishDomainsResultCodingKeys: String, CodingKey {
        case publishDomainList
    }

    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: DescribePublishDomainsResultCodingKeys.self)
        if decoderContainer.contains(.publishDomainList)
        {
            self.publishDomainList = try decoderContainer.decode([String?]?.self, forKey: .publishDomainList)
        }
    }
}
public extension DescribePublishDomainsResult{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: DescribePublishDomainsResultCodingKeys.self)
        try encoderContainer.encode(publishDomainList, forKey: .publishDomainList)
    }
}
/// 设置转推域名 
public class ModifyLiveDomainForwardCustomVhostResult:NSObject,JdCloudResult
{
}
/// 启动加速域名 
public class StartDomainResult:NSObject,JdCloudResult
{
}
public class QueryOssBucketsResponse:NSObject,Codable
{
    var requestId:String?;

    var error:ServiceError?;

    var result:QueryOssBucketsResult?;

    enum QueryOssBucketsResponseCodingKeys: String, CodingKey {
        case requestId
        case error
        case result
    }

    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: QueryOssBucketsResponseCodingKeys.self)
        self.requestId = try decoderContainer.decodeIfPresent(String?.self, forKey: .requestId) ?? nil
        self.error = try decoderContainer.decodeIfPresent(ServiceError?.self, forKey: .error) ?? nil
        self.result = try decoderContainer.decodeIfPresent(QueryOssBucketsResult?.self, forKey: .result) ?? nil
    }
}

public extension QueryOssBucketsResponse{
        func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: QueryOssBucketsResponseCodingKeys.self)
        try encoderContainer.encode(requestId, forKey: .requestId)
        try encoderContainer.encode(error, forKey: .error)
        try encoderContainer.encode(result, forKey: .result)
    }
}    
/// 创建点播加速域名 
public class BatchCreateResult:NSObject,JdCloudResult
{
}
/// 查询加速域名接口 
public class GetDomainListResult:NSObject,JdCloudResult
{
    /// TotalCount
    var totalCount:Int32?

    /// PageSize
    var pageSize:Int32?

    /// PageNumber
    var pageNumber:Int32?

    /// 域名列表
    var domains:[ListDomainItem?]?



    public override init(){
        super.init()
    }

    enum GetDomainListResultCodingKeys: String, CodingKey {
        case totalCount
        case pageSize
        case pageNumber
        case domains
    }

    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: GetDomainListResultCodingKeys.self)
        if decoderContainer.contains(.totalCount)
        {
            self.totalCount = try decoderContainer.decode(Int32?.self, forKey: .totalCount)
        }
        if decoderContainer.contains(.pageSize)
        {
            self.pageSize = try decoderContainer.decode(Int32?.self, forKey: .pageSize)
        }
        if decoderContainer.contains(.pageNumber)
        {
            self.pageNumber = try decoderContainer.decode(Int32?.self, forKey: .pageNumber)
        }
        if decoderContainer.contains(.domains)
        {
            self.domains = try decoderContainer.decode([ListDomainItem?]?.self, forKey: .domains)
        }
    }
}
public extension GetDomainListResult{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: GetDomainListResultCodingKeys.self)
        try encoderContainer.encode(totalCount, forKey: .totalCount)
        try encoderContainer.encode(pageSize, forKey: .pageSize)
        try encoderContainer.encode(pageNumber, forKey: .pageNumber)
        try encoderContainer.encode(domains, forKey: .domains)
    }
}

///  停止加速域名
public class StopDomainRequest:JdCloudRequest
{
    /// 用户域名
    var domain:String


    public init(regionId: String,domain:String){
        self.domain = domain
        super.init(regionId: regionId)
    }


    enum StopDomainRequestRequestCodingKeys: String, CodingKey {
        case domain
    }

    public override func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: StopDomainRequestRequestCodingKeys.self)
        try encoderContainer.encode(domain, forKey: .domain)

    }
}


///  创建点播加速域名
public class BatchCreateRequest:JdCloudRequest
{
    /// Domains
    var domains:[String?]?

    /// 回源类型只能是[ips,domain,oss]中的一种
    var sourceType:String?

    /// 点播域名的类型只能是[vod,download,web]中的一种
    var cdnType:String?

    /// 回源方式,只能是[https,http]中的一种,默认http
    var backSourceType:String?

    /// 日带宽(Mbps)
    var dailyBandWidth:Int64?

    /// 服务质量,只能是[good,general]中的一种,默认为good
    var quaility:String?

    /// MaxFileSize
    var maxFileSize:Int64?

    /// MinFileSize
    var minFileSize:Int64?

    /// SumFileSize
    var sumFileSize:Int64?

    /// AvgFileSize
    var avgFileSize:Int64?

    /// DefaultSourceHost
    var defaultSourceHost:String?

    /// HttpType
    var httpType:String?

    /// IpSource
    var ipSource:[IpSourceInfo?]?

    /// DomainSource
    var domainSource:[DomainSourceInfo?]?

    /// OssSource
    var ossSource:String?

    /// 加速区域 (mainLand:中国大陆，nonMainLand:海外加港澳台，all:全球)默认为中国大陆
    var accelerateRegion:String?




    enum BatchCreateRequestRequestCodingKeys: String, CodingKey {
        case domains
        case sourceType
        case cdnType
        case backSourceType
        case dailyBandWidth
        case quaility
        case maxFileSize
        case minFileSize
        case sumFileSize
        case avgFileSize
        case defaultSourceHost
        case httpType
        case ipSource
        case domainSource
        case ossSource
        case accelerateRegion
    }

    public override func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: BatchCreateRequestRequestCodingKeys.self)
        try encoderContainer.encode(domains, forKey: .domains)
        try encoderContainer.encode(sourceType, forKey: .sourceType)
        try encoderContainer.encode(cdnType, forKey: .cdnType)
        try encoderContainer.encode(backSourceType, forKey: .backSourceType)
        try encoderContainer.encode(dailyBandWidth, forKey: .dailyBandWidth)
        try encoderContainer.encode(quaility, forKey: .quaility)
        try encoderContainer.encode(maxFileSize, forKey: .maxFileSize)
        try encoderContainer.encode(minFileSize, forKey: .minFileSize)
        try encoderContainer.encode(sumFileSize, forKey: .sumFileSize)
        try encoderContainer.encode(avgFileSize, forKey: .avgFileSize)
        try encoderContainer.encode(defaultSourceHost, forKey: .defaultSourceHost)
        try encoderContainer.encode(httpType, forKey: .httpType)
        try encoderContainer.encode(ipSource, forKey: .ipSource)
        try encoderContainer.encode(domainSource, forKey: .domainSource)
        try encoderContainer.encode(ossSource, forKey: .ossSource)
        try encoderContainer.encode(accelerateRegion, forKey: .accelerateRegion)

    }
}


///  查询加速域名接口
public class GetDomainListRequest:JdCloudRequest
{
    /// 根据关键字进行模糊匹配
    var keyWord:String?

    /// pageNumber,默认值1
    var pageNumber:Int32?

    /// pageSize,最大值50,默认值20
    var pageSize:Int32?

    /// 根据域名状态查询, 可选值[offline, online, configuring, auditing, audit_reject]
    var status:String?

    /// 域名类型，(web:静态小文件，download:大文件加速，vod:视频加速，live:直播加速),不传查所有
    var type:String?

    /// 加速区域，(mainLand:中国大陆，nonMainLand:海外加港澳台，all:全球),不传为全球
    var accelerateRegion:String?




    enum GetDomainListRequestRequestCodingKeys: String, CodingKey {
        case keyWord
        case pageNumber
        case pageSize
        case status
        case type
        case accelerateRegion
    }

    public override func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: GetDomainListRequestRequestCodingKeys.self)
        try encoderContainer.encode(keyWord, forKey: .keyWord)
        try encoderContainer.encode(pageNumber, forKey: .pageNumber)
        try encoderContainer.encode(pageSize, forKey: .pageSize)
        try encoderContainer.encode(status, forKey: .status)
        try encoderContainer.encode(type, forKey: .type)
        try encoderContainer.encode(accelerateRegion, forKey: .accelerateRegion)

    }
}

public class BatchCreateResponse:NSObject,Codable
{
    var requestId:String?;

    var error:ServiceError?;

    var result:BatchCreateResult?;

    enum BatchCreateResponseCodingKeys: String, CodingKey {
        case requestId
        case error
        case result
    }

    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: BatchCreateResponseCodingKeys.self)
        self.requestId = try decoderContainer.decodeIfPresent(String?.self, forKey: .requestId) ?? nil
        self.error = try decoderContainer.decodeIfPresent(ServiceError?.self, forKey: .error) ?? nil
        self.result = try decoderContainer.decodeIfPresent(BatchCreateResult?.self, forKey: .result) ?? nil
    }
}

public extension BatchCreateResponse{
        func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: BatchCreateResponseCodingKeys.self)
        try encoderContainer.encode(requestId, forKey: .requestId)
        try encoderContainer.encode(error, forKey: .error)
        try encoderContainer.encode(result, forKey: .result)
    }
}    

///  查询oss存储域名
public class QueryOssBucketsRequest:JdCloudRequest
{
}

/// 查询oss存储域名 
public class QueryOssBucketsResult:NSObject,JdCloudResult
{
    /// Total
    var total:Int32?

    /// OssBuckets
    var ossBuckets:[AnyObject?]?



    public override init(){
        super.init()
    }

    enum QueryOssBucketsResultCodingKeys: String, CodingKey {
        case total
        case ossBuckets
    }

    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: QueryOssBucketsResultCodingKeys.self)
        if decoderContainer.contains(.total)
        {
            self.total = try decoderContainer.decode(Int32?.self, forKey: .total)
        }
    }
}
public extension QueryOssBucketsResult{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: QueryOssBucketsResultCodingKeys.self)
        try encoderContainer.encode(total, forKey: .total)
    }
}
public class StopDomainResponse:NSObject,Codable
{
    var requestId:String?;

    var error:ServiceError?;

    var result:StopDomainResult?;

    enum StopDomainResponseCodingKeys: String, CodingKey {
        case requestId
        case error
        case result
    }

    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: StopDomainResponseCodingKeys.self)
        self.requestId = try decoderContainer.decodeIfPresent(String?.self, forKey: .requestId) ?? nil
        self.error = try decoderContainer.decodeIfPresent(ServiceError?.self, forKey: .error) ?? nil
        self.result = try decoderContainer.decodeIfPresent(StopDomainResult?.self, forKey: .result) ?? nil
    }
}

public extension StopDomainResponse{
        func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: StopDomainResponseCodingKeys.self)
        try encoderContainer.encode(requestId, forKey: .requestId)
        try encoderContainer.encode(error, forKey: .error)
        try encoderContainer.encode(result, forKey: .result)
    }
}    

///  通过标签查询加速域名接口
public class GetDomainListByFilterRequest:JdCloudRequest
{
    /// 根据关键字进行模糊匹配
    var keyWord:String?

    /// pageNumber,默认值为1
    var pageNumber:Int32?

    /// pageSize,默认值为20,最大值为50
    var pageSize:Int32?

    /// 根据域名状态查询, 可选值[offline, online, configuring, auditing, audit_reject]
    var status:String?

    /// 域名类型，(web:静态小文件，download:大文件加速，vod:视频加速，live:直播加速),不传查所有
    var type:String?

    /// 加速区域，(mainLand:中国大陆，nonMainLand:海外加港澳台，all:全球),不传为全球
    var accelerateRegion:String?

    /// 标签过滤条件
    var tagFilters:[TagFilter?]?




    enum GetDomainListByFilterRequestRequestCodingKeys: String, CodingKey {
        case keyWord
        case pageNumber
        case pageSize
        case status
        case type
        case accelerateRegion
        case tagFilters
    }

    public override func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: GetDomainListByFilterRequestRequestCodingKeys.self)
        try encoderContainer.encode(keyWord, forKey: .keyWord)
        try encoderContainer.encode(pageNumber, forKey: .pageNumber)
        try encoderContainer.encode(pageSize, forKey: .pageSize)
        try encoderContainer.encode(status, forKey: .status)
        try encoderContainer.encode(type, forKey: .type)
        try encoderContainer.encode(accelerateRegion, forKey: .accelerateRegion)
        try encoderContainer.encode(tagFilters, forKey: .tagFilters)

    }
}


///  查询加速域名详情
public class GetDomainDetailRequest:JdCloudRequest
{
    /// 用户域名
    var domain:String


    public init(regionId: String,domain:String){
        self.domain = domain
        super.init(regionId: regionId)
    }


    enum GetDomainDetailRequestRequestCodingKeys: String, CodingKey {
        case domain
    }

    public override func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: GetDomainDetailRequestRequestCodingKeys.self)
        try encoderContainer.encode(domain, forKey: .domain)

    }
}

/// 查询加速域名详情 
public class GetDomainDetailResult:NSObject,JdCloudResult
{
    /// null
    var allStatus:String?

    /// AllowNoReferHeader
    var allowNoReferHeader:String?

    /// AllowNullReferHeader
    var allowNullReferHeader:String?

    /// DailyBandWidth
    var dailyBandWidth:Int?

    /// ForbiddenType
    var forbiddenType:String?

    /// MaxFileSize
    var maxFileSize:Int64?

    /// MinFileSize
    var minFileSize:Int64?

    /// SumFileSize
    var sumFileSize:Int64?

    /// AvgFileSize
    var avgFileSize:Int64?

    /// ReferList
    var referList:[String?]?

    /// ReferType
    var referType:String?

    /// Domain
    var domain:String?

    /// Cname
    var cname:String?

    /// ArchiveNo
    var archiveNo:String?

    /// Type
    var type:String?

    /// Created
    var created:String?

    /// Modified
    var modified:String?

    /// Status
    var status:String?

    /// AuditStatus
    var auditStatus:String?

    /// Source
    var source:BackSourceInfo?

    /// SourceType
    var sourceType:String?

    /// 默认的回源host
    var defaultSourceHost:String?

    /// BackSourceType
    var backSourceType:String?

    /// HttpType
    var httpType:String?

    /// Certificate
    var certificate:String?

    /// RsaKey
    var rsaKey:String?

    /// JumpType
    var jumpType:String?

    /// CertFrom
    var certFrom:String?

    /// SslCertId
    var sslCertId:String?

    /// CertName
    var certName:String?

    /// CertType
    var certType:String?

    /// SslCertStartTime
    var sslCertStartTime:String?

    /// SslCertEndTime
    var sslCertEndTime:String?

    /// 加速区域
    var accelerateRegion:String?



    public override init(){
        super.init()
    }

    enum GetDomainDetailResultCodingKeys: String, CodingKey {
        case allStatus
        case allowNoReferHeader
        case allowNullReferHeader
        case dailyBandWidth
        case forbiddenType
        case maxFileSize
        case minFileSize
        case sumFileSize
        case avgFileSize
        case referList
        case referType
        case domain
        case cname
        case archiveNo
        case type
        case created
        case modified
        case status
        case auditStatus
        case source
        case sourceType
        case defaultSourceHost
        case backSourceType
        case httpType
        case certificate
        case rsaKey
        case jumpType
        case certFrom
        case sslCertId
        case certName
        case certType
        case sslCertStartTime
        case sslCertEndTime
        case accelerateRegion
    }

    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: GetDomainDetailResultCodingKeys.self)
        if decoderContainer.contains(.allStatus)
        {
            self.allStatus = try decoderContainer.decode(String?.self, forKey: .allStatus)
        }
        if decoderContainer.contains(.allowNoReferHeader)
        {
            self.allowNoReferHeader = try decoderContainer.decode(String?.self, forKey: .allowNoReferHeader)
        }
        if decoderContainer.contains(.allowNullReferHeader)
        {
            self.allowNullReferHeader = try decoderContainer.decode(String?.self, forKey: .allowNullReferHeader)
        }
        if decoderContainer.contains(.dailyBandWidth)
        {
            self.dailyBandWidth = try decoderContainer.decode(Int?.self, forKey: .dailyBandWidth)
        }
        if decoderContainer.contains(.forbiddenType)
        {
            self.forbiddenType = try decoderContainer.decode(String?.self, forKey: .forbiddenType)
        }
        if decoderContainer.contains(.maxFileSize)
        {
            self.maxFileSize = try decoderContainer.decode(Int64?.self, forKey: .maxFileSize)
        }
        if decoderContainer.contains(.minFileSize)
        {
            self.minFileSize = try decoderContainer.decode(Int64?.self, forKey: .minFileSize)
        }
        if decoderContainer.contains(.sumFileSize)
        {
            self.sumFileSize = try decoderContainer.decode(Int64?.self, forKey: .sumFileSize)
        }
        if decoderContainer.contains(.avgFileSize)
        {
            self.avgFileSize = try decoderContainer.decode(Int64?.self, forKey: .avgFileSize)
        }
        if decoderContainer.contains(.referList)
        {
            self.referList = try decoderContainer.decode([String?]?.self, forKey: .referList)
        }
        if decoderContainer.contains(.referType)
        {
            self.referType = try decoderContainer.decode(String?.self, forKey: .referType)
        }
        if decoderContainer.contains(.domain)
        {
            self.domain = try decoderContainer.decode(String?.self, forKey: .domain)
        }
        if decoderContainer.contains(.cname)
        {
            self.cname = try decoderContainer.decode(String?.self, forKey: .cname)
        }
        if decoderContainer.contains(.archiveNo)
        {
            self.archiveNo = try decoderContainer.decode(String?.self, forKey: .archiveNo)
        }
        if decoderContainer.contains(.type)
        {
            self.type = try decoderContainer.decode(String?.self, forKey: .type)
        }
        if decoderContainer.contains(.created)
        {
            self.created = try decoderContainer.decode(String?.self, forKey: .created)
        }
        if decoderContainer.contains(.modified)
        {
            self.modified = try decoderContainer.decode(String?.self, forKey: .modified)
        }
        if decoderContainer.contains(.status)
        {
            self.status = try decoderContainer.decode(String?.self, forKey: .status)
        }
        if decoderContainer.contains(.auditStatus)
        {
            self.auditStatus = try decoderContainer.decode(String?.self, forKey: .auditStatus)
        }
        if decoderContainer.contains(.source)
        {
            self.source = try decoderContainer.decode(BackSourceInfo?.self, forKey: .source)
        }
        if decoderContainer.contains(.sourceType)
        {
            self.sourceType = try decoderContainer.decode(String?.self, forKey: .sourceType)
        }
        if decoderContainer.contains(.defaultSourceHost)
        {
            self.defaultSourceHost = try decoderContainer.decode(String?.self, forKey: .defaultSourceHost)
        }
        if decoderContainer.contains(.backSourceType)
        {
            self.backSourceType = try decoderContainer.decode(String?.self, forKey: .backSourceType)
        }
        if decoderContainer.contains(.httpType)
        {
            self.httpType = try decoderContainer.decode(String?.self, forKey: .httpType)
        }
        if decoderContainer.contains(.certificate)
        {
            self.certificate = try decoderContainer.decode(String?.self, forKey: .certificate)
        }
        if decoderContainer.contains(.rsaKey)
        {
            self.rsaKey = try decoderContainer.decode(String?.self, forKey: .rsaKey)
        }
        if decoderContainer.contains(.jumpType)
        {
            self.jumpType = try decoderContainer.decode(String?.self, forKey: .jumpType)
        }
        if decoderContainer.contains(.certFrom)
        {
            self.certFrom = try decoderContainer.decode(String?.self, forKey: .certFrom)
        }
        if decoderContainer.contains(.sslCertId)
        {
            self.sslCertId = try decoderContainer.decode(String?.self, forKey: .sslCertId)
        }
        if decoderContainer.contains(.certName)
        {
            self.certName = try decoderContainer.decode(String?.self, forKey: .certName)
        }
        if decoderContainer.contains(.certType)
        {
            self.certType = try decoderContainer.decode(String?.self, forKey: .certType)
        }
        if decoderContainer.contains(.sslCertStartTime)
        {
            self.sslCertStartTime = try decoderContainer.decode(String?.self, forKey: .sslCertStartTime)
        }
        if decoderContainer.contains(.sslCertEndTime)
        {
            self.sslCertEndTime = try decoderContainer.decode(String?.self, forKey: .sslCertEndTime)
        }
        if decoderContainer.contains(.accelerateRegion)
        {
            self.accelerateRegion = try decoderContainer.decode(String?.self, forKey: .accelerateRegion)
        }
    }
}
public extension GetDomainDetailResult{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: GetDomainDetailResultCodingKeys.self)
        try encoderContainer.encode(allStatus, forKey: .allStatus)
        try encoderContainer.encode(allowNoReferHeader, forKey: .allowNoReferHeader)
        try encoderContainer.encode(allowNullReferHeader, forKey: .allowNullReferHeader)
        try encoderContainer.encode(dailyBandWidth, forKey: .dailyBandWidth)
        try encoderContainer.encode(forbiddenType, forKey: .forbiddenType)
        try encoderContainer.encode(maxFileSize, forKey: .maxFileSize)
        try encoderContainer.encode(minFileSize, forKey: .minFileSize)
        try encoderContainer.encode(sumFileSize, forKey: .sumFileSize)
        try encoderContainer.encode(avgFileSize, forKey: .avgFileSize)
        try encoderContainer.encode(referList, forKey: .referList)
        try encoderContainer.encode(referType, forKey: .referType)
        try encoderContainer.encode(domain, forKey: .domain)
        try encoderContainer.encode(cname, forKey: .cname)
        try encoderContainer.encode(archiveNo, forKey: .archiveNo)
        try encoderContainer.encode(type, forKey: .type)
        try encoderContainer.encode(created, forKey: .created)
        try encoderContainer.encode(modified, forKey: .modified)
        try encoderContainer.encode(status, forKey: .status)
        try encoderContainer.encode(auditStatus, forKey: .auditStatus)
        try encoderContainer.encode(source, forKey: .source)
        try encoderContainer.encode(sourceType, forKey: .sourceType)
        try encoderContainer.encode(defaultSourceHost, forKey: .defaultSourceHost)
        try encoderContainer.encode(backSourceType, forKey: .backSourceType)
        try encoderContainer.encode(httpType, forKey: .httpType)
        try encoderContainer.encode(certificate, forKey: .certificate)
        try encoderContainer.encode(rsaKey, forKey: .rsaKey)
        try encoderContainer.encode(jumpType, forKey: .jumpType)
        try encoderContainer.encode(certFrom, forKey: .certFrom)
        try encoderContainer.encode(sslCertId, forKey: .sslCertId)
        try encoderContainer.encode(certName, forKey: .certName)
        try encoderContainer.encode(certType, forKey: .certType)
        try encoderContainer.encode(sslCertStartTime, forKey: .sslCertStartTime)
        try encoderContainer.encode(sslCertEndTime, forKey: .sslCertEndTime)
        try encoderContainer.encode(accelerateRegion, forKey: .accelerateRegion)
    }
}
/// 停止加速域名 
public class StopDomainResult:NSObject,JdCloudResult
{
}
public class GetDomainListResponse:NSObject,Codable
{
    var requestId:String?;

    var error:ServiceError?;

    var result:GetDomainListResult?;

    enum GetDomainListResponseCodingKeys: String, CodingKey {
        case requestId
        case error
        case result
    }

    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: GetDomainListResponseCodingKeys.self)
        self.requestId = try decoderContainer.decodeIfPresent(String?.self, forKey: .requestId) ?? nil
        self.error = try decoderContainer.decodeIfPresent(ServiceError?.self, forKey: .error) ?? nil
        self.result = try decoderContainer.decodeIfPresent(GetDomainListResult?.self, forKey: .result) ?? nil
    }
}

public extension GetDomainListResponse{
        func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: GetDomainListResponseCodingKeys.self)
        try encoderContainer.encode(requestId, forKey: .requestId)
        try encoderContainer.encode(error, forKey: .error)
        try encoderContainer.encode(result, forKey: .result)
    }
}    
public class GetDomainDetailResponse:NSObject,Codable
{
    var requestId:String?;

    var error:ServiceError?;

    var result:GetDomainDetailResult?;

    enum GetDomainDetailResponseCodingKeys: String, CodingKey {
        case requestId
        case error
        case result
    }

    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: GetDomainDetailResponseCodingKeys.self)
        self.requestId = try decoderContainer.decodeIfPresent(String?.self, forKey: .requestId) ?? nil
        self.error = try decoderContainer.decodeIfPresent(ServiceError?.self, forKey: .error) ?? nil
        self.result = try decoderContainer.decodeIfPresent(GetDomainDetailResult?.self, forKey: .result) ?? nil
    }
}

public extension GetDomainDetailResponse{
        func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: GetDomainDetailResponseCodingKeys.self)
        try encoderContainer.encode(requestId, forKey: .requestId)
        try encoderContainer.encode(error, forKey: .error)
        try encoderContainer.encode(result, forKey: .result)
    }
}    
/// 查询域名配置信息 
public class QueryDomainConfigResult:NSObject,JdCloudResult
{
    /// 忽略参数[on,off]
    var ignoreQueryString:String?

    /// range参数[on,off]
    var range:String?

    /// httpType参数[on,off]
    var httpType:String?

    /// https证书
    var httpsCertificate:String?

    /// rsa秘钥
    var httpsRsaKey:String?

    /// 跳转类型[default,http,https]
    var httpsJumpType:String?

    /// 是否支持视频拖拽[on,off]
    var videoDraft:String?

    /// group
    var groupName:String?

    /// ShareId
    var shareId:Int64?

    /// ShareName
    var shareName:String?

    /// JcdnTimeAnti
    var jcdnTimeAnti:String?

    /// ShareCache
    var shareCache:String?

    /// IsShareOpen
    var isShareOpen:String?

    /// CacheRules
    var cacheRules:[CacheRule?]?



    public override init(){
        super.init()
    }

    enum QueryDomainConfigResultCodingKeys: String, CodingKey {
        case ignoreQueryString
        case range
        case httpType
        case httpsCertificate
        case httpsRsaKey
        case httpsJumpType
        case videoDraft
        case groupName
        case shareId
        case shareName
        case jcdnTimeAnti
        case shareCache
        case isShareOpen
        case cacheRules
    }

    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: QueryDomainConfigResultCodingKeys.self)
        if decoderContainer.contains(.ignoreQueryString)
        {
            self.ignoreQueryString = try decoderContainer.decode(String?.self, forKey: .ignoreQueryString)
        }
        if decoderContainer.contains(.range)
        {
            self.range = try decoderContainer.decode(String?.self, forKey: .range)
        }
        if decoderContainer.contains(.httpType)
        {
            self.httpType = try decoderContainer.decode(String?.self, forKey: .httpType)
        }
        if decoderContainer.contains(.httpsCertificate)
        {
            self.httpsCertificate = try decoderContainer.decode(String?.self, forKey: .httpsCertificate)
        }
        if decoderContainer.contains(.httpsRsaKey)
        {
            self.httpsRsaKey = try decoderContainer.decode(String?.self, forKey: .httpsRsaKey)
        }
        if decoderContainer.contains(.httpsJumpType)
        {
            self.httpsJumpType = try decoderContainer.decode(String?.self, forKey: .httpsJumpType)
        }
        if decoderContainer.contains(.videoDraft)
        {
            self.videoDraft = try decoderContainer.decode(String?.self, forKey: .videoDraft)
        }
        if decoderContainer.contains(.groupName)
        {
            self.groupName = try decoderContainer.decode(String?.self, forKey: .groupName)
        }
        if decoderContainer.contains(.shareId)
        {
            self.shareId = try decoderContainer.decode(Int64?.self, forKey: .shareId)
        }
        if decoderContainer.contains(.shareName)
        {
            self.shareName = try decoderContainer.decode(String?.self, forKey: .shareName)
        }
        if decoderContainer.contains(.jcdnTimeAnti)
        {
            self.jcdnTimeAnti = try decoderContainer.decode(String?.self, forKey: .jcdnTimeAnti)
        }
        if decoderContainer.contains(.shareCache)
        {
            self.shareCache = try decoderContainer.decode(String?.self, forKey: .shareCache)
        }
        if decoderContainer.contains(.isShareOpen)
        {
            self.isShareOpen = try decoderContainer.decode(String?.self, forKey: .isShareOpen)
        }
        if decoderContainer.contains(.cacheRules)
        {
            self.cacheRules = try decoderContainer.decode([CacheRule?]?.self, forKey: .cacheRules)
        }
    }
}
public extension QueryDomainConfigResult{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: QueryDomainConfigResultCodingKeys.self)
        try encoderContainer.encode(ignoreQueryString, forKey: .ignoreQueryString)
        try encoderContainer.encode(range, forKey: .range)
        try encoderContainer.encode(httpType, forKey: .httpType)
        try encoderContainer.encode(httpsCertificate, forKey: .httpsCertificate)
        try encoderContainer.encode(httpsRsaKey, forKey: .httpsRsaKey)
        try encoderContainer.encode(httpsJumpType, forKey: .httpsJumpType)
        try encoderContainer.encode(videoDraft, forKey: .videoDraft)
        try encoderContainer.encode(groupName, forKey: .groupName)
        try encoderContainer.encode(shareId, forKey: .shareId)
        try encoderContainer.encode(shareName, forKey: .shareName)
        try encoderContainer.encode(jcdnTimeAnti, forKey: .jcdnTimeAnti)
        try encoderContainer.encode(shareCache, forKey: .shareCache)
        try encoderContainer.encode(isShareOpen, forKey: .isShareOpen)
        try encoderContainer.encode(cacheRules, forKey: .cacheRules)
    }
}
/// 删除加速域名 
public class DeleteDomainResult:NSObject,JdCloudResult
{
}
public class StartDomainResponse:NSObject,Codable
{
    var requestId:String?;

    var error:ServiceError?;

    var result:StartDomainResult?;

    enum StartDomainResponseCodingKeys: String, CodingKey {
        case requestId
        case error
        case result
    }

    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: StartDomainResponseCodingKeys.self)
        self.requestId = try decoderContainer.decodeIfPresent(String?.self, forKey: .requestId) ?? nil
        self.error = try decoderContainer.decodeIfPresent(ServiceError?.self, forKey: .error) ?? nil
        self.result = try decoderContainer.decodeIfPresent(StartDomainResult?.self, forKey: .result) ?? nil
    }
}

public extension StartDomainResponse{
        func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: StartDomainResponseCodingKeys.self)
        try encoderContainer.encode(requestId, forKey: .requestId)
        try encoderContainer.encode(error, forKey: .error)
        try encoderContainer.encode(result, forKey: .result)
    }
}    

///  创建点播加速域名
public class CreateDomainRequest:JdCloudRequest
{
    /// 回源类型只能是[ips,domain,oss]中的一种
    var sourceType:String?

    /// 点播域名的类型只能是[vod,download,web]中的一种
    var cdnType:String?

    /// 回源方式,只能是[https,http]中的一种,默认http
    var backSourceType:String?

    /// 日带宽(Mbps)
    var dailyBandWidth:Int64?

    /// 服务质量,只能是[good,general]中的一种,默认为good
    var quaility:String?

    /// MaxFileSize
    var maxFileSize:Int64?

    /// MinFileSize
    var minFileSize:Int64?

    /// SumFileSize
    var sumFileSize:Int64?

    /// AvgFileSize
    var avgFileSize:Int64?

    /// DefaultSourceHost
    var defaultSourceHost:String?

    /// HttpType
    var httpType:String?

    /// IpSource
    var ipSource:[IpSourceInfo?]?

    /// DomainSource
    var domainSource:[DomainSourceInfo?]?

    /// OssSource
    var ossSource:String?

    /// 加速区域:(mainLand:中国大陆，nonMainLand:海外加港澳台，all:全球)默认为中国大陆
    var accelerateRegion:String?

    /// 用户域名
    var domain:String


    public init(regionId: String,domain:String){
        self.domain = domain
        super.init(regionId: regionId)
    }


    enum CreateDomainRequestRequestCodingKeys: String, CodingKey {
        case sourceType
        case cdnType
        case backSourceType
        case dailyBandWidth
        case quaility
        case maxFileSize
        case minFileSize
        case sumFileSize
        case avgFileSize
        case defaultSourceHost
        case httpType
        case ipSource
        case domainSource
        case ossSource
        case accelerateRegion
        case domain
    }

    public override func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: CreateDomainRequestRequestCodingKeys.self)
        try encoderContainer.encode(sourceType, forKey: .sourceType)
        try encoderContainer.encode(cdnType, forKey: .cdnType)
        try encoderContainer.encode(backSourceType, forKey: .backSourceType)
        try encoderContainer.encode(dailyBandWidth, forKey: .dailyBandWidth)
        try encoderContainer.encode(quaility, forKey: .quaility)
        try encoderContainer.encode(maxFileSize, forKey: .maxFileSize)
        try encoderContainer.encode(minFileSize, forKey: .minFileSize)
        try encoderContainer.encode(sumFileSize, forKey: .sumFileSize)
        try encoderContainer.encode(avgFileSize, forKey: .avgFileSize)
        try encoderContainer.encode(defaultSourceHost, forKey: .defaultSourceHost)
        try encoderContainer.encode(httpType, forKey: .httpType)
        try encoderContainer.encode(ipSource, forKey: .ipSource)
        try encoderContainer.encode(domainSource, forKey: .domainSource)
        try encoderContainer.encode(ossSource, forKey: .ossSource)
        try encoderContainer.encode(accelerateRegion, forKey: .accelerateRegion)
        try encoderContainer.encode(domain, forKey: .domain)

    }
}

public class DeleteDomainResponse:NSObject,Codable
{
    var requestId:String?;

    var error:ServiceError?;

    var result:DeleteDomainResult?;

    enum DeleteDomainResponseCodingKeys: String, CodingKey {
        case requestId
        case error
        case result
    }

    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: DeleteDomainResponseCodingKeys.self)
        self.requestId = try decoderContainer.decodeIfPresent(String?.self, forKey: .requestId) ?? nil
        self.error = try decoderContainer.decodeIfPresent(ServiceError?.self, forKey: .error) ?? nil
        self.result = try decoderContainer.decodeIfPresent(DeleteDomainResult?.self, forKey: .result) ?? nil
    }
}

public extension DeleteDomainResponse{
        func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: DeleteDomainResponseCodingKeys.self)
        try encoderContainer.encode(requestId, forKey: .requestId)
        try encoderContainer.encode(error, forKey: .error)
        try encoderContainer.encode(result, forKey: .result)
    }
}    

///  删除加速域名
public class DeleteDomainRequest:JdCloudRequest
{
    /// 用户域名
    var domain:String


    public init(regionId: String,domain:String){
        self.domain = domain
        super.init(regionId: regionId)
    }


    enum DeleteDomainRequestRequestCodingKeys: String, CodingKey {
        case domain
    }

    public override func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: DeleteDomainRequestRequestCodingKeys.self)
        try encoderContainer.encode(domain, forKey: .domain)

    }
}

/// 创建点播加速域名 
public class CreateDomainResult:NSObject,JdCloudResult
{
}
public class QueryDomainConfigResponse:NSObject,Codable
{
    var requestId:String?;

    var error:ServiceError?;

    var result:QueryDomainConfigResult?;

    enum QueryDomainConfigResponseCodingKeys: String, CodingKey {
        case requestId
        case error
        case result
    }

    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: QueryDomainConfigResponseCodingKeys.self)
        self.requestId = try decoderContainer.decodeIfPresent(String?.self, forKey: .requestId) ?? nil
        self.error = try decoderContainer.decodeIfPresent(ServiceError?.self, forKey: .error) ?? nil
        self.result = try decoderContainer.decodeIfPresent(QueryDomainConfigResult?.self, forKey: .result) ?? nil
    }
}

public extension QueryDomainConfigResponse{
        func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: QueryDomainConfigResponseCodingKeys.self)
        try encoderContainer.encode(requestId, forKey: .requestId)
        try encoderContainer.encode(error, forKey: .error)
        try encoderContainer.encode(result, forKey: .result)
    }
}    
public class CreateDomainResponse:NSObject,Codable
{
    var requestId:String?;

    var error:ServiceError?;

    var result:CreateDomainResult?;

    enum CreateDomainResponseCodingKeys: String, CodingKey {
        case requestId
        case error
        case result
    }

    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: CreateDomainResponseCodingKeys.self)
        self.requestId = try decoderContainer.decodeIfPresent(String?.self, forKey: .requestId) ?? nil
        self.error = try decoderContainer.decodeIfPresent(ServiceError?.self, forKey: .error) ?? nil
        self.result = try decoderContainer.decodeIfPresent(CreateDomainResult?.self, forKey: .result) ?? nil
    }
}

public extension CreateDomainResponse{
        func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: CreateDomainResponseCodingKeys.self)
        try encoderContainer.encode(requestId, forKey: .requestId)
        try encoderContainer.encode(error, forKey: .error)
        try encoderContainer.encode(result, forKey: .result)
    }
}    

///  启动加速域名
public class StartDomainRequest:JdCloudRequest
{
    /// 用户域名
    var domain:String


    public init(regionId: String,domain:String){
        self.domain = domain
        super.init(regionId: regionId)
    }


    enum StartDomainRequestRequestCodingKeys: String, CodingKey {
        case domain
    }

    public override func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: StartDomainRequestRequestCodingKeys.self)
        try encoderContainer.encode(domain, forKey: .domain)

    }
}

/// 通过标签查询加速域名接口 
public class GetDomainListByFilterResult:NSObject,JdCloudResult
{
    /// TotalCount
    var totalCount:Int32?

    /// PageSize
    var pageSize:Int32?

    /// PageNumber
    var pageNumber:Int32?

    /// Domains
    var domains:[ListDomainItemByFilter?]?



    public override init(){
        super.init()
    }

    enum GetDomainListByFilterResultCodingKeys: String, CodingKey {
        case totalCount
        case pageSize
        case pageNumber
        case domains
    }

    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: GetDomainListByFilterResultCodingKeys.self)
        if decoderContainer.contains(.totalCount)
        {
            self.totalCount = try decoderContainer.decode(Int32?.self, forKey: .totalCount)
        }
        if decoderContainer.contains(.pageSize)
        {
            self.pageSize = try decoderContainer.decode(Int32?.self, forKey: .pageSize)
        }
        if decoderContainer.contains(.pageNumber)
        {
            self.pageNumber = try decoderContainer.decode(Int32?.self, forKey: .pageNumber)
        }
        if decoderContainer.contains(.domains)
        {
            self.domains = try decoderContainer.decode([ListDomainItemByFilter?]?.self, forKey: .domains)
        }
    }
}
public extension GetDomainListByFilterResult{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: GetDomainListByFilterResultCodingKeys.self)
        try encoderContainer.encode(totalCount, forKey: .totalCount)
        try encoderContainer.encode(pageSize, forKey: .pageSize)
        try encoderContainer.encode(pageNumber, forKey: .pageNumber)
        try encoderContainer.encode(domains, forKey: .domains)
    }
}

///  查询域名配置信息
public class QueryDomainConfigRequest:JdCloudRequest
{
    /// 用户域名
    var domain:String


    public init(regionId: String,domain:String){
        self.domain = domain
        super.init(regionId: regionId)
    }


    enum QueryDomainConfigRequestRequestCodingKeys: String, CodingKey {
        case domain
    }

    public override func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: QueryDomainConfigRequestRequestCodingKeys.self)
        try encoderContainer.encode(domain, forKey: .domain)

    }
}

public class GetDomainListByFilterResponse:NSObject,Codable
{
    var requestId:String?;

    var error:ServiceError?;

    var result:GetDomainListByFilterResult?;

    enum GetDomainListByFilterResponseCodingKeys: String, CodingKey {
        case requestId
        case error
        case result
    }

    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: GetDomainListByFilterResponseCodingKeys.self)
        self.requestId = try decoderContainer.decodeIfPresent(String?.self, forKey: .requestId) ?? nil
        self.error = try decoderContainer.decodeIfPresent(ServiceError?.self, forKey: .error) ?? nil
        self.result = try decoderContainer.decodeIfPresent(GetDomainListByFilterResult?.self, forKey: .result) ?? nil
    }
}

public extension GetDomainListByFilterResponse{
        func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: GetDomainListByFilterResponseCodingKeys.self)
        try encoderContainer.encode(requestId, forKey: .requestId)
        try encoderContainer.encode(error, forKey: .error)
        try encoderContainer.encode(result, forKey: .result)
    }
}    
/// 查看证书详情 
public class GetSslCertDetailResult:NSObject,JdCloudResult
{
    /// 证书Id
    var sslCertId:String?

    /// 证书名称
    var certName:String?

    /// 绑定域名
    var commonName:String?

    /// 证书类型
    var certType:String?

    /// 开始时间
    var sslCertStartTime:String?

    /// 结束时间
    var sslCertEndTime:String?

    /// 是否允许被删除,1允许,0不允许
    var deletable:Int?

    /// 对私钥文件使用sha256算法计算的摘要信息
    var digest:String?

    /// 绑定的域名
    var relatedDomains:[String?]?



    public override init(){
        super.init()
    }

    enum GetSslCertDetailResultCodingKeys: String, CodingKey {
        case sslCertId
        case certName
        case commonName
        case certType
        case sslCertStartTime
        case sslCertEndTime
        case deletable
        case digest
        case relatedDomains
    }

    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: GetSslCertDetailResultCodingKeys.self)
        if decoderContainer.contains(.sslCertId)
        {
            self.sslCertId = try decoderContainer.decode(String?.self, forKey: .sslCertId)
        }
        if decoderContainer.contains(.certName)
        {
            self.certName = try decoderContainer.decode(String?.self, forKey: .certName)
        }
        if decoderContainer.contains(.commonName)
        {
            self.commonName = try decoderContainer.decode(String?.self, forKey: .commonName)
        }
        if decoderContainer.contains(.certType)
        {
            self.certType = try decoderContainer.decode(String?.self, forKey: .certType)
        }
        if decoderContainer.contains(.sslCertStartTime)
        {
            self.sslCertStartTime = try decoderContainer.decode(String?.self, forKey: .sslCertStartTime)
        }
        if decoderContainer.contains(.sslCertEndTime)
        {
            self.sslCertEndTime = try decoderContainer.decode(String?.self, forKey: .sslCertEndTime)
        }
        if decoderContainer.contains(.deletable)
        {
            self.deletable = try decoderContainer.decode(Int?.self, forKey: .deletable)
        }
        if decoderContainer.contains(.digest)
        {
            self.digest = try decoderContainer.decode(String?.self, forKey: .digest)
        }
        if decoderContainer.contains(.relatedDomains)
        {
            self.relatedDomains = try decoderContainer.decode([String?]?.self, forKey: .relatedDomains)
        }
    }
}
public extension GetSslCertDetailResult{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: GetSslCertDetailResultCodingKeys.self)
        try encoderContainer.encode(sslCertId, forKey: .sslCertId)
        try encoderContainer.encode(certName, forKey: .certName)
        try encoderContainer.encode(commonName, forKey: .commonName)
        try encoderContainer.encode(certType, forKey: .certType)
        try encoderContainer.encode(sslCertStartTime, forKey: .sslCertStartTime)
        try encoderContainer.encode(sslCertEndTime, forKey: .sslCertEndTime)
        try encoderContainer.encode(deletable, forKey: .deletable)
        try encoderContainer.encode(digest, forKey: .digest)
        try encoderContainer.encode(relatedDomains, forKey: .relatedDomains)
    }
}

///  查看证书详情
public class GetSslCertDetailRequest:JdCloudRequest
{
    /// 证书 Id
    var sslCertId:String


    public init(regionId: String,sslCertId:String){
        self.sslCertId = sslCertId
        super.init(regionId: regionId)
    }


    enum GetSslCertDetailRequestRequestCodingKeys: String, CodingKey {
        case sslCertId
    }

    public override func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: GetSslCertDetailRequestRequestCodingKeys.self)
        try encoderContainer.encode(sslCertId, forKey: .sslCertId)

    }
}


///  查看证书列表
public class GetSslCertListRequest:JdCloudRequest
{
    /// 第几页，从1开始计数
    var pageNumber:Int?

    /// 每页显示的数目
    var pageSize:Int?

    /// 域名，支持按照域名检索证书
    var domain:String?




    enum GetSslCertListRequestRequestCodingKeys: String, CodingKey {
        case pageNumber
        case pageSize
        case domain
    }

    public override func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: GetSslCertListRequestRequestCodingKeys.self)
        try encoderContainer.encode(pageNumber, forKey: .pageNumber)
        try encoderContainer.encode(pageSize, forKey: .pageSize)
        try encoderContainer.encode(domain, forKey: .domain)

    }
}

public class GetSslCertDetailResponse:NSObject,Codable
{
    var requestId:String?;

    var error:ServiceError?;

    var result:GetSslCertDetailResult?;

    enum GetSslCertDetailResponseCodingKeys: String, CodingKey {
        case requestId
        case error
        case result
    }

    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: GetSslCertDetailResponseCodingKeys.self)
        self.requestId = try decoderContainer.decodeIfPresent(String?.self, forKey: .requestId) ?? nil
        self.error = try decoderContainer.decodeIfPresent(ServiceError?.self, forKey: .error) ?? nil
        self.result = try decoderContainer.decodeIfPresent(GetSslCertDetailResult?.self, forKey: .result) ?? nil
    }
}

public extension GetSslCertDetailResponse{
        func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: GetSslCertDetailResponseCodingKeys.self)
        try encoderContainer.encode(requestId, forKey: .requestId)
        try encoderContainer.encode(error, forKey: .error)
        try encoderContainer.encode(result, forKey: .result)
    }
}    
public class UploadCertResponse:NSObject,Codable
{
    var requestId:String?;

    var error:ServiceError?;

    var result:UploadCertResult?;

    enum UploadCertResponseCodingKeys: String, CodingKey {
        case requestId
        case error
        case result
    }

    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: UploadCertResponseCodingKeys.self)
        self.requestId = try decoderContainer.decodeIfPresent(String?.self, forKey: .requestId) ?? nil
        self.error = try decoderContainer.decodeIfPresent(ServiceError?.self, forKey: .error) ?? nil
        self.result = try decoderContainer.decodeIfPresent(UploadCertResult?.self, forKey: .result) ?? nil
    }
}

public extension UploadCertResponse{
        func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: UploadCertResponseCodingKeys.self)
        try encoderContainer.encode(requestId, forKey: .requestId)
        try encoderContainer.encode(error, forKey: .error)
        try encoderContainer.encode(result, forKey: .result)
    }
}    

///  上传证书
public class UploadCertRequest:JdCloudRequest
{
    /// 证书名称
    var certName:String

    /// 私钥
    var keyFile:String

    /// 证书
    var certFile:String

    /// 证书别名
    var aliasName:String?


    public init(regionId: String,certName:String,keyFile:String,certFile:String){
        self.certName = certName
        self.keyFile = keyFile
        self.certFile = certFile
        super.init(regionId: regionId)
    }


    enum UploadCertRequestRequestCodingKeys: String, CodingKey {
        case certName
        case keyFile
        case certFile
        case aliasName
    }

    public override func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: UploadCertRequestRequestCodingKeys.self)
        try encoderContainer.encode(certName, forKey: .certName)
        try encoderContainer.encode(keyFile, forKey: .keyFile)
        try encoderContainer.encode(certFile, forKey: .certFile)
        try encoderContainer.encode(aliasName, forKey: .aliasName)

    }
}

/// 查看证书列表 
public class GetSslCertListResult:NSObject,JdCloudResult
{
    /// 证书列表详情
    var certList:[SslCertModel?]?

    /// 总数量
    var totalCount:Int?



    public override init(){
        super.init()
    }

    enum GetSslCertListResultCodingKeys: String, CodingKey {
        case certList
        case totalCount
    }

    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: GetSslCertListResultCodingKeys.self)
        if decoderContainer.contains(.certList)
        {
            self.certList = try decoderContainer.decode([SslCertModel?]?.self, forKey: .certList)
        }
        if decoderContainer.contains(.totalCount)
        {
            self.totalCount = try decoderContainer.decode(Int?.self, forKey: .totalCount)
        }
    }
}
public extension GetSslCertListResult{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: GetSslCertListResultCodingKeys.self)
        try encoderContainer.encode(certList, forKey: .certList)
        try encoderContainer.encode(totalCount, forKey: .totalCount)
    }
}
public class GetSslCertListResponse:NSObject,Codable
{
    var requestId:String?;

    var error:ServiceError?;

    var result:GetSslCertListResult?;

    enum GetSslCertListResponseCodingKeys: String, CodingKey {
        case requestId
        case error
        case result
    }

    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: GetSslCertListResponseCodingKeys.self)
        self.requestId = try decoderContainer.decodeIfPresent(String?.self, forKey: .requestId) ?? nil
        self.error = try decoderContainer.decodeIfPresent(ServiceError?.self, forKey: .error) ?? nil
        self.result = try decoderContainer.decodeIfPresent(GetSslCertListResult?.self, forKey: .result) ?? nil
    }
}

public extension GetSslCertListResponse{
        func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: GetSslCertListResponseCodingKeys.self)
        try encoderContainer.encode(requestId, forKey: .requestId)
        try encoderContainer.encode(error, forKey: .error)
        try encoderContainer.encode(result, forKey: .result)
    }
}    
/// 上传证书 
public class UploadCertResult:NSObject,JdCloudResult
{
    /// CertId
    var certId:String?

    /// 对私钥文件使用sha256算法计算的摘要信息
    var digest:String?



    public override init(){
        super.init()
    }

    enum UploadCertResultCodingKeys: String, CodingKey {
        case certId
        case digest
    }

    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: UploadCertResultCodingKeys.self)
        if decoderContainer.contains(.certId)
        {
            self.certId = try decoderContainer.decode(String?.self, forKey: .certId)
        }
        if decoderContainer.contains(.digest)
        {
            self.digest = try decoderContainer.decode(String?.self, forKey: .digest)
        }
    }
}
public extension UploadCertResult{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: UploadCertResultCodingKeys.self)
        try encoderContainer.encode(certId, forKey: .certId)
        try encoderContainer.encode(digest, forKey: .digest)
    }
}
public class CreateRefreshTaskForCallbackV2Response:NSObject,Codable
{
    var requestId:String?;

    var error:ServiceError?;

    var result:CreateRefreshTaskForCallbackV2Result?;

    enum CreateRefreshTaskForCallbackV2ResponseCodingKeys: String, CodingKey {
        case requestId
        case error
        case result
    }

    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: CreateRefreshTaskForCallbackV2ResponseCodingKeys.self)
        self.requestId = try decoderContainer.decodeIfPresent(String?.self, forKey: .requestId) ?? nil
        self.error = try decoderContainer.decodeIfPresent(ServiceError?.self, forKey: .error) ?? nil
        self.result = try decoderContainer.decodeIfPresent(CreateRefreshTaskForCallbackV2Result?.self, forKey: .result) ?? nil
    }
}

public extension CreateRefreshTaskForCallbackV2Response{
        func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: CreateRefreshTaskForCallbackV2ResponseCodingKeys.self)
        try encoderContainer.encode(requestId, forKey: .requestId)
        try encoderContainer.encode(error, forKey: .error)
        try encoderContainer.encode(result, forKey: .result)
    }
}    

///  根据taskIds查询刷新预热任务
public class QueryRefreshTaskByIdsRequest:JdCloudRequest
{
    /// 查询的任务taskIds列表,最多能查10条
    var taskIds:[String?]?

    /// url的模糊查询关键字
    var keyword:String?




    enum QueryRefreshTaskByIdsRequestRequestCodingKeys: String, CodingKey {
        case taskIds
        case keyword
    }

    public override func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: QueryRefreshTaskByIdsRequestRequestCodingKeys.self)
        try encoderContainer.encode(taskIds, forKey: .taskIds)
        try encoderContainer.encode(keyword, forKey: .keyword)

    }
}

public class CreateRefreshTaskResponse:NSObject,Codable
{
    var requestId:String?;

    var error:ServiceError?;

    var result:CreateRefreshTaskResult?;

    enum CreateRefreshTaskResponseCodingKeys: String, CodingKey {
        case requestId
        case error
        case result
    }

    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: CreateRefreshTaskResponseCodingKeys.self)
        self.requestId = try decoderContainer.decodeIfPresent(String?.self, forKey: .requestId) ?? nil
        self.error = try decoderContainer.decodeIfPresent(ServiceError?.self, forKey: .error) ?? nil
        self.result = try decoderContainer.decodeIfPresent(CreateRefreshTaskResult?.self, forKey: .result) ?? nil
    }
}

public extension CreateRefreshTaskResponse{
        func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: CreateRefreshTaskResponseCodingKeys.self)
        try encoderContainer.encode(requestId, forKey: .requestId)
        try encoderContainer.encode(error, forKey: .error)
        try encoderContainer.encode(result, forKey: .result)
    }
}    
/// 创建刷新预热回调任务 
public class CreateRefreshTaskForCallbackV2Result:NSObject,JdCloudResult
{
    /// 失败任务的个数
    var errorCount:Int32?

    /// 任务的id
    var taskId:String?



    public override init(){
        super.init()
    }

    enum CreateRefreshTaskForCallbackV2ResultCodingKeys: String, CodingKey {
        case errorCount
        case taskId
    }

    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: CreateRefreshTaskForCallbackV2ResultCodingKeys.self)
        if decoderContainer.contains(.errorCount)
        {
            self.errorCount = try decoderContainer.decode(Int32?.self, forKey: .errorCount)
        }
        if decoderContainer.contains(.taskId)
        {
            self.taskId = try decoderContainer.decode(String?.self, forKey: .taskId)
        }
    }
}
public extension CreateRefreshTaskForCallbackV2Result{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: CreateRefreshTaskForCallbackV2ResultCodingKeys.self)
        try encoderContainer.encode(errorCount, forKey: .errorCount)
        try encoderContainer.encode(taskId, forKey: .taskId)
    }
}

///  根据taskId查询刷新预热任务
public class QueryRefreshTaskByIdRequest:JdCloudRequest
{
    /// 域名组id
    var taskId:String


    public init(regionId: String,taskId:String){
        self.taskId = taskId
        super.init(regionId: regionId)
    }


    enum QueryRefreshTaskByIdRequestRequestCodingKeys: String, CodingKey {
        case taskId
    }

    public override func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: QueryRefreshTaskByIdRequestRequestCodingKeys.self)
        try encoderContainer.encode(taskId, forKey: .taskId)

    }
}

public class CreateRefreshTaskForCallbackResponse:NSObject,Codable
{
    var requestId:String?;

    var error:ServiceError?;

    var result:CreateRefreshTaskForCallbackResult?;

    enum CreateRefreshTaskForCallbackResponseCodingKeys: String, CodingKey {
        case requestId
        case error
        case result
    }

    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: CreateRefreshTaskForCallbackResponseCodingKeys.self)
        self.requestId = try decoderContainer.decodeIfPresent(String?.self, forKey: .requestId) ?? nil
        self.error = try decoderContainer.decodeIfPresent(ServiceError?.self, forKey: .error) ?? nil
        self.result = try decoderContainer.decodeIfPresent(CreateRefreshTaskForCallbackResult?.self, forKey: .result) ?? nil
    }
}

public extension CreateRefreshTaskForCallbackResponse{
        func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: CreateRefreshTaskForCallbackResponseCodingKeys.self)
        try encoderContainer.encode(requestId, forKey: .requestId)
        try encoderContainer.encode(error, forKey: .error)
        try encoderContainer.encode(result, forKey: .result)
    }
}    
public class QueryRefreshTaskByIdResponse:NSObject,Codable
{
    var requestId:String?;

    var error:ServiceError?;

    var result:QueryRefreshTaskByIdResult?;

    enum QueryRefreshTaskByIdResponseCodingKeys: String, CodingKey {
        case requestId
        case error
        case result
    }

    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: QueryRefreshTaskByIdResponseCodingKeys.self)
        self.requestId = try decoderContainer.decodeIfPresent(String?.self, forKey: .requestId) ?? nil
        self.error = try decoderContainer.decodeIfPresent(ServiceError?.self, forKey: .error) ?? nil
        self.result = try decoderContainer.decodeIfPresent(QueryRefreshTaskByIdResult?.self, forKey: .result) ?? nil
    }
}

public extension QueryRefreshTaskByIdResponse{
        func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: QueryRefreshTaskByIdResponseCodingKeys.self)
        try encoderContainer.encode(requestId, forKey: .requestId)
        try encoderContainer.encode(error, forKey: .error)
        try encoderContainer.encode(result, forKey: .result)
    }
}    
public class QueryRefreshTaskResponse:NSObject,Codable
{
    var requestId:String?;

    var error:ServiceError?;

    var result:QueryRefreshTaskResult?;

    enum QueryRefreshTaskResponseCodingKeys: String, CodingKey {
        case requestId
        case error
        case result
    }

    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: QueryRefreshTaskResponseCodingKeys.self)
        self.requestId = try decoderContainer.decodeIfPresent(String?.self, forKey: .requestId) ?? nil
        self.error = try decoderContainer.decodeIfPresent(ServiceError?.self, forKey: .error) ?? nil
        self.result = try decoderContainer.decodeIfPresent(QueryRefreshTaskResult?.self, forKey: .result) ?? nil
    }
}

public extension QueryRefreshTaskResponse{
        func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: QueryRefreshTaskResponseCodingKeys.self)
        try encoderContainer.encode(requestId, forKey: .requestId)
        try encoderContainer.encode(error, forKey: .error)
        try encoderContainer.encode(result, forKey: .result)
    }
}    

///  创建刷新预热任务
public class CreateRefreshTaskRequest:JdCloudRequest
{
    /// 刷新预热类型,(url:url刷新,dir:目录刷新,prefetch:预热)
    var taskType:String?

    /// Urls
    var urls:[String?]?




    enum CreateRefreshTaskRequestRequestCodingKeys: String, CodingKey {
        case taskType
        case urls
    }

    public override func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: CreateRefreshTaskRequestRequestCodingKeys.self)
        try encoderContainer.encode(taskType, forKey: .taskType)
        try encoderContainer.encode(urls, forKey: .urls)

    }
}


///  查询刷新预热任务
public class QueryRefreshTaskRequest:JdCloudRequest
{
    /// 查询起始时间,UTC时间，格式为:yyyy-MM-dd&#39;T&#39;HH:mm:ss&#39;Z&#39;，示例:2018-10-21T10:00:00Z
    var startTime:String?

    /// 查询截止时间,UTC时间，格式为:yyyy-MM-dd&#39;T&#39;HH:mm:ss&#39;Z&#39;，示例:2018-10-21T10:00:00Z
    var endTime:String?

    /// url或者目录的模糊查询关键字
    var keyword:String?

    /// 任务id
    var taskId:String?

    /// null
    var taskStatus:String?

    /// null
    var taskType:String?

    /// 分页页数,默认值1
    var pageNumber:Int32?

    /// 分页页面大小,默认值50
    var pageSize:Int32?




    enum QueryRefreshTaskRequestRequestCodingKeys: String, CodingKey {
        case startTime
        case endTime
        case keyword
        case taskId
        case taskStatus
        case taskType
        case pageNumber
        case pageSize
    }

    public override func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: QueryRefreshTaskRequestRequestCodingKeys.self)
        try encoderContainer.encode(startTime, forKey: .startTime)
        try encoderContainer.encode(endTime, forKey: .endTime)
        try encoderContainer.encode(keyword, forKey: .keyword)
        try encoderContainer.encode(taskId, forKey: .taskId)
        try encoderContainer.encode(taskStatus, forKey: .taskStatus)
        try encoderContainer.encode(taskType, forKey: .taskType)
        try encoderContainer.encode(pageNumber, forKey: .pageNumber)
        try encoderContainer.encode(pageSize, forKey: .pageSize)

    }
}


///  创建刷新预热回调任务
public class CreateRefreshTaskForCallbackRequest:JdCloudRequest
{
    /// 刷新预热类型,(url:url刷新,dir:目录刷新,prefetch:预热)
    var taskType:String?

    /// UrlItems
    var urlItems:[UrlItem?]?




    enum CreateRefreshTaskForCallbackRequestRequestCodingKeys: String, CodingKey {
        case taskType
        case urlItems
    }

    public override func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: CreateRefreshTaskForCallbackRequestRequestCodingKeys.self)
        try encoderContainer.encode(taskType, forKey: .taskType)
        try encoderContainer.encode(urlItems, forKey: .urlItems)

    }
}

/// 查询刷新预热任务 
public class QueryRefreshTaskResult:NSObject,JdCloudResult
{
    /// 总的刷新预热条数.
    var total:Int32?

    /// Tasks
    var tasks:[RefreshTask?]?



    public override init(){
        super.init()
    }

    enum QueryRefreshTaskResultCodingKeys: String, CodingKey {
        case total
        case tasks
    }

    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: QueryRefreshTaskResultCodingKeys.self)
        if decoderContainer.contains(.total)
        {
            self.total = try decoderContainer.decode(Int32?.self, forKey: .total)
        }
        if decoderContainer.contains(.tasks)
        {
            self.tasks = try decoderContainer.decode([RefreshTask?]?.self, forKey: .tasks)
        }
    }
}
public extension QueryRefreshTaskResult{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: QueryRefreshTaskResultCodingKeys.self)
        try encoderContainer.encode(total, forKey: .total)
        try encoderContainer.encode(tasks, forKey: .tasks)
    }
}

///  创建刷新预热回调任务
public class CreateRefreshTaskForCallbackV2Request:JdCloudRequest
{
    /// 刷新预热类型,(url:url刷新,dir:目录刷新,prefetch:预热)
    var taskType:String?

    /// UrlItems
    var urlItems:[UrlItemV2?]?




    enum CreateRefreshTaskForCallbackV2RequestRequestCodingKeys: String, CodingKey {
        case taskType
        case urlItems
    }

    public override func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: CreateRefreshTaskForCallbackV2RequestRequestCodingKeys.self)
        try encoderContainer.encode(taskType, forKey: .taskType)
        try encoderContainer.encode(urlItems, forKey: .urlItems)

    }
}

/// 创建刷新预热任务 
public class CreateRefreshTaskResult:NSObject,JdCloudResult
{
    /// 失败任务的个数
    var errorCount:Int32?

    /// 任务的id
    var taskId:String?



    public override init(){
        super.init()
    }

    enum CreateRefreshTaskResultCodingKeys: String, CodingKey {
        case errorCount
        case taskId
    }

    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: CreateRefreshTaskResultCodingKeys.self)
        if decoderContainer.contains(.errorCount)
        {
            self.errorCount = try decoderContainer.decode(Int32?.self, forKey: .errorCount)
        }
        if decoderContainer.contains(.taskId)
        {
            self.taskId = try decoderContainer.decode(String?.self, forKey: .taskId)
        }
    }
}
public extension CreateRefreshTaskResult{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: CreateRefreshTaskResultCodingKeys.self)
        try encoderContainer.encode(errorCount, forKey: .errorCount)
        try encoderContainer.encode(taskId, forKey: .taskId)
    }
}
public class QueryRefreshTaskByIdsResponse:NSObject,Codable
{
    var requestId:String?;

    var error:ServiceError?;

    var result:QueryRefreshTaskByIdsResult?;

    enum QueryRefreshTaskByIdsResponseCodingKeys: String, CodingKey {
        case requestId
        case error
        case result
    }

    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: QueryRefreshTaskByIdsResponseCodingKeys.self)
        self.requestId = try decoderContainer.decodeIfPresent(String?.self, forKey: .requestId) ?? nil
        self.error = try decoderContainer.decodeIfPresent(ServiceError?.self, forKey: .error) ?? nil
        self.result = try decoderContainer.decodeIfPresent(QueryRefreshTaskByIdsResult?.self, forKey: .result) ?? nil
    }
}

public extension QueryRefreshTaskByIdsResponse{
        func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: QueryRefreshTaskByIdsResponseCodingKeys.self)
        try encoderContainer.encode(requestId, forKey: .requestId)
        try encoderContainer.encode(error, forKey: .error)
        try encoderContainer.encode(result, forKey: .result)
    }
}    
/// 创建刷新预热回调任务 
public class CreateRefreshTaskForCallbackResult:NSObject,JdCloudResult
{
    /// 失败任务的个数
    var errorCount:Int32?

    /// 任务的id
    var taskId:String?



    public override init(){
        super.init()
    }

    enum CreateRefreshTaskForCallbackResultCodingKeys: String, CodingKey {
        case errorCount
        case taskId
    }

    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: CreateRefreshTaskForCallbackResultCodingKeys.self)
        if decoderContainer.contains(.errorCount)
        {
            self.errorCount = try decoderContainer.decode(Int32?.self, forKey: .errorCount)
        }
        if decoderContainer.contains(.taskId)
        {
            self.taskId = try decoderContainer.decode(String?.self, forKey: .taskId)
        }
    }
}
public extension CreateRefreshTaskForCallbackResult{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: CreateRefreshTaskForCallbackResultCodingKeys.self)
        try encoderContainer.encode(errorCount, forKey: .errorCount)
        try encoderContainer.encode(taskId, forKey: .taskId)
    }
}
/// 根据taskId查询刷新预热任务 
public class QueryRefreshTaskByIdResult:NSObject,JdCloudResult
{
    /// Task
    var task:RefreshTask?



    public override init(){
        super.init()
    }

    enum QueryRefreshTaskByIdResultCodingKeys: String, CodingKey {
        case task
    }

    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: QueryRefreshTaskByIdResultCodingKeys.self)
        if decoderContainer.contains(.task)
        {
            self.task = try decoderContainer.decode(RefreshTask?.self, forKey: .task)
        }
    }
}
public extension QueryRefreshTaskByIdResult{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: QueryRefreshTaskByIdResultCodingKeys.self)
        try encoderContainer.encode(task, forKey: .task)
    }
}
/// 根据taskIds查询刷新预热任务 
public class QueryRefreshTaskByIdsResult:NSObject,JdCloudResult
{
    /// Tasks
    var tasks:[RefreshTask?]?



    public override init(){
        super.init()
    }

    enum QueryRefreshTaskByIdsResultCodingKeys: String, CodingKey {
        case tasks
    }

    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: QueryRefreshTaskByIdsResultCodingKeys.self)
        if decoderContainer.contains(.tasks)
        {
            self.tasks = try decoderContainer.decode([RefreshTask?]?.self, forKey: .tasks)
        }
    }
}
public extension QueryRefreshTaskByIdsResult{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: QueryRefreshTaskByIdsResultCodingKeys.self)
        try encoderContainer.encode(tasks, forKey: .tasks)
    }
}
/// 创建域名组 
public class CreateDomainGroupResult:NSObject,JdCloudResult
{
}

///  查询未分组域名
public class QueryDomainsNotInGroupRequest:JdCloudRequest
{
}


///  创建域名组
public class CreateDomainGroupRequest:JdCloudRequest
{
    /// 是否共享内存
    var shareCache:String?

    /// 主域名,开启共享缓存时必传
    var primaryDomain:String?

    /// 域名组名称
    var domainGroupName:String?

    /// 域名组内域名包含主域名
    var domains:[String?]?




    enum CreateDomainGroupRequestRequestCodingKeys: String, CodingKey {
        case shareCache
        case primaryDomain
        case domainGroupName
        case domains
    }

    public override func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: CreateDomainGroupRequestRequestCodingKeys.self)
        try encoderContainer.encode(shareCache, forKey: .shareCache)
        try encoderContainer.encode(primaryDomain, forKey: .primaryDomain)
        try encoderContainer.encode(domainGroupName, forKey: .domainGroupName)
        try encoderContainer.encode(domains, forKey: .domains)

    }
}

public class QueryDomainGroupDetailResponse:NSObject,Codable
{
    var requestId:String?;

    var error:ServiceError?;

    var result:QueryDomainGroupDetailResult?;

    enum QueryDomainGroupDetailResponseCodingKeys: String, CodingKey {
        case requestId
        case error
        case result
    }

    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: QueryDomainGroupDetailResponseCodingKeys.self)
        self.requestId = try decoderContainer.decodeIfPresent(String?.self, forKey: .requestId) ?? nil
        self.error = try decoderContainer.decodeIfPresent(ServiceError?.self, forKey: .error) ?? nil
        self.result = try decoderContainer.decodeIfPresent(QueryDomainGroupDetailResult?.self, forKey: .result) ?? nil
    }
}

public extension QueryDomainGroupDetailResponse{
        func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: QueryDomainGroupDetailResponseCodingKeys.self)
        try encoderContainer.encode(requestId, forKey: .requestId)
        try encoderContainer.encode(error, forKey: .error)
        try encoderContainer.encode(result, forKey: .result)
    }
}    
public class UpdateDomainGroupResponse:NSObject,Codable
{
    var requestId:String?;

    var error:ServiceError?;

    var result:UpdateDomainGroupResult?;

    enum UpdateDomainGroupResponseCodingKeys: String, CodingKey {
        case requestId
        case error
        case result
    }

    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: UpdateDomainGroupResponseCodingKeys.self)
        self.requestId = try decoderContainer.decodeIfPresent(String?.self, forKey: .requestId) ?? nil
        self.error = try decoderContainer.decodeIfPresent(ServiceError?.self, forKey: .error) ?? nil
        self.result = try decoderContainer.decodeIfPresent(UpdateDomainGroupResult?.self, forKey: .result) ?? nil
    }
}

public extension UpdateDomainGroupResponse{
        func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: UpdateDomainGroupResponseCodingKeys.self)
        try encoderContainer.encode(requestId, forKey: .requestId)
        try encoderContainer.encode(error, forKey: .error)
        try encoderContainer.encode(result, forKey: .result)
    }
}    
public class QueryDomainGroupListResponse:NSObject,Codable
{
    var requestId:String?;

    var error:ServiceError?;

    var result:QueryDomainGroupListResult?;

    enum QueryDomainGroupListResponseCodingKeys: String, CodingKey {
        case requestId
        case error
        case result
    }

    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: QueryDomainGroupListResponseCodingKeys.self)
        self.requestId = try decoderContainer.decodeIfPresent(String?.self, forKey: .requestId) ?? nil
        self.error = try decoderContainer.decodeIfPresent(ServiceError?.self, forKey: .error) ?? nil
        self.result = try decoderContainer.decodeIfPresent(QueryDomainGroupListResult?.self, forKey: .result) ?? nil
    }
}

public extension QueryDomainGroupListResponse{
        func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: QueryDomainGroupListResponseCodingKeys.self)
        try encoderContainer.encode(requestId, forKey: .requestId)
        try encoderContainer.encode(error, forKey: .error)
        try encoderContainer.encode(result, forKey: .result)
    }
}    
public class QueryDomainsNotInGroupResponse:NSObject,Codable
{
    var requestId:String?;

    var error:ServiceError?;

    var result:QueryDomainsNotInGroupResult?;

    enum QueryDomainsNotInGroupResponseCodingKeys: String, CodingKey {
        case requestId
        case error
        case result
    }

    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: QueryDomainsNotInGroupResponseCodingKeys.self)
        self.requestId = try decoderContainer.decodeIfPresent(String?.self, forKey: .requestId) ?? nil
        self.error = try decoderContainer.decodeIfPresent(ServiceError?.self, forKey: .error) ?? nil
        self.result = try decoderContainer.decodeIfPresent(QueryDomainsNotInGroupResult?.self, forKey: .result) ?? nil
    }
}

public extension QueryDomainsNotInGroupResponse{
        func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: QueryDomainsNotInGroupResponseCodingKeys.self)
        try encoderContainer.encode(requestId, forKey: .requestId)
        try encoderContainer.encode(error, forKey: .error)
        try encoderContainer.encode(result, forKey: .result)
    }
}    
public class BatchDeleteDomainGroupResponse:NSObject,Codable
{
    var requestId:String?;

    var error:ServiceError?;

    var result:BatchDeleteDomainGroupResult?;

    enum BatchDeleteDomainGroupResponseCodingKeys: String, CodingKey {
        case requestId
        case error
        case result
    }

    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: BatchDeleteDomainGroupResponseCodingKeys.self)
        self.requestId = try decoderContainer.decodeIfPresent(String?.self, forKey: .requestId) ?? nil
        self.error = try decoderContainer.decodeIfPresent(ServiceError?.self, forKey: .error) ?? nil
        self.result = try decoderContainer.decodeIfPresent(BatchDeleteDomainGroupResult?.self, forKey: .result) ?? nil
    }
}

public extension BatchDeleteDomainGroupResponse{
        func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: BatchDeleteDomainGroupResponseCodingKeys.self)
        try encoderContainer.encode(requestId, forKey: .requestId)
        try encoderContainer.encode(error, forKey: .error)
        try encoderContainer.encode(result, forKey: .result)
    }
}    

///  查询域名组接口
public class QueryDomainGroupListRequest:JdCloudRequest
{
    /// 根据是否共享内存筛选
    var shareCache:String?

    /// pageNumber
    var pageNumber:Int32?

    /// pageSize
    var pageSize:Int32?

    /// 根据主域名模糊查询
    var primaryDomain:String?

    /// 根据域名组模糊查询
    var domainGroupName:String?




    enum QueryDomainGroupListRequestRequestCodingKeys: String, CodingKey {
        case shareCache
        case pageNumber
        case pageSize
        case primaryDomain
        case domainGroupName
    }

    public override func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: QueryDomainGroupListRequestRequestCodingKeys.self)
        try encoderContainer.encode(shareCache, forKey: .shareCache)
        try encoderContainer.encode(pageNumber, forKey: .pageNumber)
        try encoderContainer.encode(pageSize, forKey: .pageSize)
        try encoderContainer.encode(primaryDomain, forKey: .primaryDomain)
        try encoderContainer.encode(domainGroupName, forKey: .domainGroupName)

    }
}


///  查询域名组详情
public class QueryDomainGroupDetailRequest:JdCloudRequest
{
    /// 域名组id
    var id:Int64


    public init(regionId: String,id:Int64){
        self.id = id
        super.init(regionId: regionId)
    }


    enum QueryDomainGroupDetailRequestRequestCodingKeys: String, CodingKey {
        case id
    }

    public override func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: QueryDomainGroupDetailRequestRequestCodingKeys.self)
        try encoderContainer.encode(id, forKey: .id)

    }
}

/// 查询域名组详情 
public class QueryDomainGroupDetailResult:NSObject,JdCloudResult
{
    /// 域名组成员
    var domains:[String?]?

    /// 主域名
    var primaryDomain:String?

    /// 是否共享缓存
    var shareCache:String?

    /// 域名组名称
    var domainGroupName:String?



    public override init(){
        super.init()
    }

    enum QueryDomainGroupDetailResultCodingKeys: String, CodingKey {
        case domains
        case primaryDomain
        case shareCache
        case domainGroupName
    }

    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: QueryDomainGroupDetailResultCodingKeys.self)
        if decoderContainer.contains(.domains)
        {
            self.domains = try decoderContainer.decode([String?]?.self, forKey: .domains)
        }
        if decoderContainer.contains(.primaryDomain)
        {
            self.primaryDomain = try decoderContainer.decode(String?.self, forKey: .primaryDomain)
        }
        if decoderContainer.contains(.shareCache)
        {
            self.shareCache = try decoderContainer.decode(String?.self, forKey: .shareCache)
        }
        if decoderContainer.contains(.domainGroupName)
        {
            self.domainGroupName = try decoderContainer.decode(String?.self, forKey: .domainGroupName)
        }
    }
}
public extension QueryDomainGroupDetailResult{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: QueryDomainGroupDetailResultCodingKeys.self)
        try encoderContainer.encode(domains, forKey: .domains)
        try encoderContainer.encode(primaryDomain, forKey: .primaryDomain)
        try encoderContainer.encode(shareCache, forKey: .shareCache)
        try encoderContainer.encode(domainGroupName, forKey: .domainGroupName)
    }
}
/// 批量删除域名组 
public class BatchDeleteDomainGroupResult:NSObject,JdCloudResult
{
}
/// 查询域名组接口 
public class QueryDomainGroupListResult:NSObject,JdCloudResult
{
    /// TotalCount
    var totalCount:Int32?

    /// PageSize
    var pageSize:Int32?

    /// PageNumber
    var pageNumber:Int32?

    /// DomainGroups
    var domainGroups:[DomainGroupItem?]?



    public override init(){
        super.init()
    }

    enum QueryDomainGroupListResultCodingKeys: String, CodingKey {
        case totalCount
        case pageSize
        case pageNumber
        case domainGroups
    }

    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: QueryDomainGroupListResultCodingKeys.self)
        if decoderContainer.contains(.totalCount)
        {
            self.totalCount = try decoderContainer.decode(Int32?.self, forKey: .totalCount)
        }
        if decoderContainer.contains(.pageSize)
        {
            self.pageSize = try decoderContainer.decode(Int32?.self, forKey: .pageSize)
        }
        if decoderContainer.contains(.pageNumber)
        {
            self.pageNumber = try decoderContainer.decode(Int32?.self, forKey: .pageNumber)
        }
        if decoderContainer.contains(.domainGroups)
        {
            self.domainGroups = try decoderContainer.decode([DomainGroupItem?]?.self, forKey: .domainGroups)
        }
    }
}
public extension QueryDomainGroupListResult{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: QueryDomainGroupListResultCodingKeys.self)
        try encoderContainer.encode(totalCount, forKey: .totalCount)
        try encoderContainer.encode(pageSize, forKey: .pageSize)
        try encoderContainer.encode(pageNumber, forKey: .pageNumber)
        try encoderContainer.encode(domainGroups, forKey: .domainGroups)
    }
}
public class CreateDomainGroupResponse:NSObject,Codable
{
    var requestId:String?;

    var error:ServiceError?;

    var result:CreateDomainGroupResult?;

    enum CreateDomainGroupResponseCodingKeys: String, CodingKey {
        case requestId
        case error
        case result
    }

    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: CreateDomainGroupResponseCodingKeys.self)
        self.requestId = try decoderContainer.decodeIfPresent(String?.self, forKey: .requestId) ?? nil
        self.error = try decoderContainer.decodeIfPresent(ServiceError?.self, forKey: .error) ?? nil
        self.result = try decoderContainer.decodeIfPresent(CreateDomainGroupResult?.self, forKey: .result) ?? nil
    }
}

public extension CreateDomainGroupResponse{
        func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: CreateDomainGroupResponseCodingKeys.self)
        try encoderContainer.encode(requestId, forKey: .requestId)
        try encoderContainer.encode(error, forKey: .error)
        try encoderContainer.encode(result, forKey: .result)
    }
}    

///  更新域名组
public class UpdateDomainGroupRequest:JdCloudRequest
{
    /// 域名组内域名，包含主域名
    var domains:[String?]?

    /// 主域名,开启共享缓存时必传
    var primaryDomain:String?

    /// 是否共享内存
    var shareCache:String?

    /// DomainGroupName
    var domainGroupName:String?

    /// 域名组id
    var id:Int64


    public init(regionId: String,id:Int64){
        self.id = id
        super.init(regionId: regionId)
    }


    enum UpdateDomainGroupRequestRequestCodingKeys: String, CodingKey {
        case domains
        case primaryDomain
        case shareCache
        case domainGroupName
        case id
    }

    public override func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: UpdateDomainGroupRequestRequestCodingKeys.self)
        try encoderContainer.encode(domains, forKey: .domains)
        try encoderContainer.encode(primaryDomain, forKey: .primaryDomain)
        try encoderContainer.encode(shareCache, forKey: .shareCache)
        try encoderContainer.encode(domainGroupName, forKey: .domainGroupName)
        try encoderContainer.encode(id, forKey: .id)

    }
}


///  批量删除域名组
public class BatchDeleteDomainGroupRequest:JdCloudRequest
{
    /// Ids
    var ids:[Int64?]?


    public init(regionId: String,ids:[Int64?]?){
        self.ids = ids
        super.init(regionId: regionId)
    }


    enum BatchDeleteDomainGroupRequestRequestCodingKeys: String, CodingKey {
        case ids
    }

    public override func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: BatchDeleteDomainGroupRequestRequestCodingKeys.self)
        try encoderContainer.encode(ids, forKey: .ids)

    }
}

/// 查询未分组域名 
public class QueryDomainsNotInGroupResult:NSObject,JdCloudResult
{
    /// Domains
    var domains:[String?]?



    public override init(){
        super.init()
    }

    enum QueryDomainsNotInGroupResultCodingKeys: String, CodingKey {
        case domains
    }

    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: QueryDomainsNotInGroupResultCodingKeys.self)
        if decoderContainer.contains(.domains)
        {
            self.domains = try decoderContainer.decode([String?]?.self, forKey: .domains)
        }
    }
}
public extension QueryDomainsNotInGroupResult{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: QueryDomainsNotInGroupResultCodingKeys.self)
        try encoderContainer.encode(domains, forKey: .domains)
    }
}
/// 更新域名组 
public class UpdateDomainGroupResult:NSObject,JdCloudResult
{
}

///  设置域名refer
public class SetReferRequest:JdCloudRequest
{
    /// refer类型，取值：block（黑名单），allow（白名单）默认为block
    var referType:String?

    /// 逗号隔开的域名列表，如果referList传空则为删除
    var referList:[String?]?

    /// 是否允许空refer访问，默认为“on”
    var allowNoReferHeader:String?

    /// 是否允许无ua访问，默认为“on”
    var allowNullReferHeader:String?

    /// 用户域名
    var domain:String


    public init(regionId: String,domain:String){
        self.domain = domain
        super.init(regionId: regionId)
    }


    enum SetReferRequestRequestCodingKeys: String, CodingKey {
        case referType
        case referList
        case allowNoReferHeader
        case allowNullReferHeader
        case domain
    }

    public override func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: SetReferRequestRequestCodingKeys.self)
        try encoderContainer.encode(referType, forKey: .referType)
        try encoderContainer.encode(referList, forKey: .referList)
        try encoderContainer.encode(allowNoReferHeader, forKey: .allowNoReferHeader)
        try encoderContainer.encode(allowNullReferHeader, forKey: .allowNullReferHeader)
        try encoderContainer.encode(domain, forKey: .domain)

    }
}

/// 添加缓存规则 
public class CreateCacheRuleResult:NSObject,JdCloudResult
{
    /// 缓存规则配置ID
    var configId:Int64?



    public override init(){
        super.init()
    }

    enum CreateCacheRuleResultCodingKeys: String, CodingKey {
        case configId
    }

    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: CreateCacheRuleResultCodingKeys.self)
        if decoderContainer.contains(.configId)
        {
            self.configId = try decoderContainer.decode(Int64?.self, forKey: .configId)
        }
    }
}
public extension CreateCacheRuleResult{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: CreateCacheRuleResultCodingKeys.self)
        try encoderContainer.encode(configId, forKey: .configId)
    }
}

///  查询url鉴权
public class QueryAccesskeyConfigRequest:JdCloudRequest
{
    /// 用户域名
    var domain:String


    public init(regionId: String,domain:String){
        self.domain = domain
        super.init(regionId: regionId)
    }


    enum QueryAccesskeyConfigRequestRequestCodingKeys: String, CodingKey {
        case domain
    }

    public override func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: QueryAccesskeyConfigRequestRequestCodingKeys.self)
        try encoderContainer.encode(domain, forKey: .domain)

    }
}

public class OperateShareCacheResponse:NSObject,Codable
{
    var requestId:String?;

    var error:ServiceError?;

    var result:OperateShareCacheResult?;

    enum OperateShareCacheResponseCodingKeys: String, CodingKey {
        case requestId
        case error
        case result
    }

    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: OperateShareCacheResponseCodingKeys.self)
        self.requestId = try decoderContainer.decodeIfPresent(String?.self, forKey: .requestId) ?? nil
        self.error = try decoderContainer.decodeIfPresent(ServiceError?.self, forKey: .error) ?? nil
        self.result = try decoderContainer.decodeIfPresent(OperateShareCacheResult?.self, forKey: .result) ?? nil
    }
}

public extension OperateShareCacheResponse{
        func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: OperateShareCacheResponseCodingKeys.self)
        try encoderContainer.encode(requestId, forKey: .requestId)
        try encoderContainer.encode(error, forKey: .error)
        try encoderContainer.encode(result, forKey: .result)
    }
}    
/// 查询默认http header头部参数列表 
public class QueryDefaultHttpHeaderKeyResult:NSObject,JdCloudResult
{
    /// 默认的http请求头
    var reqDefaultHttpHeaderKey:[String?]?

    /// 默认的http响应头
    var respDefaultHttpHeaderKey:[String?]?



    public override init(){
        super.init()
    }

    enum QueryDefaultHttpHeaderKeyResultCodingKeys: String, CodingKey {
        case reqDefaultHttpHeaderKey
        case respDefaultHttpHeaderKey
    }

    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: QueryDefaultHttpHeaderKeyResultCodingKeys.self)
        if decoderContainer.contains(.reqDefaultHttpHeaderKey)
        {
            self.reqDefaultHttpHeaderKey = try decoderContainer.decode([String?]?.self, forKey: .reqDefaultHttpHeaderKey)
        }
        if decoderContainer.contains(.respDefaultHttpHeaderKey)
        {
            self.respDefaultHttpHeaderKey = try decoderContainer.decode([String?]?.self, forKey: .respDefaultHttpHeaderKey)
        }
    }
}
public extension QueryDefaultHttpHeaderKeyResult{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: QueryDefaultHttpHeaderKeyResultCodingKeys.self)
        try encoderContainer.encode(reqDefaultHttpHeaderKey, forKey: .reqDefaultHttpHeaderKey)
        try encoderContainer.encode(respDefaultHttpHeaderKey, forKey: .respDefaultHttpHeaderKey)
    }
}
public class SetUserAgentConfigResponse:NSObject,Codable
{
    var requestId:String?;

    var error:ServiceError?;

    var result:SetUserAgentConfigResult?;

    enum SetUserAgentConfigResponseCodingKeys: String, CodingKey {
        case requestId
        case error
        case result
    }

    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: SetUserAgentConfigResponseCodingKeys.self)
        self.requestId = try decoderContainer.decodeIfPresent(String?.self, forKey: .requestId) ?? nil
        self.error = try decoderContainer.decodeIfPresent(ServiceError?.self, forKey: .error) ?? nil
        self.result = try decoderContainer.decodeIfPresent(SetUserAgentConfigResult?.self, forKey: .result) ?? nil
    }
}

public extension SetUserAgentConfigResponse{
        func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: SetUserAgentConfigResponseCodingKeys.self)
        try encoderContainer.encode(requestId, forKey: .requestId)
        try encoderContainer.encode(error, forKey: .error)
        try encoderContainer.encode(result, forKey: .result)
    }
}    
/// 设置协议跟随回源 
public class SetFollowSourceProtocolResult:NSObject,JdCloudResult
{
    /// 任务id
    var taskId:String?



    public override init(){
        super.init()
    }

    enum SetFollowSourceProtocolResultCodingKeys: String, CodingKey {
        case taskId
    }

    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: SetFollowSourceProtocolResultCodingKeys.self)
        if decoderContainer.contains(.taskId)
        {
            self.taskId = try decoderContainer.decode(String?.self, forKey: .taskId)
        }
    }
}
public extension SetFollowSourceProtocolResult{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: SetFollowSourceProtocolResultCodingKeys.self)
        try encoderContainer.encode(taskId, forKey: .taskId)
    }
}

///  查询http header头
public class QueryHttpHeaderRequest:JdCloudRequest
{
    /// 用户域名
    var domain:String


    public init(regionId: String,domain:String){
        self.domain = domain
        super.init(regionId: regionId)
    }


    enum QueryHttpHeaderRequestRequestCodingKeys: String, CodingKey {
        case domain
    }

    public override func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: QueryHttpHeaderRequestRequestCodingKeys.self)
        try encoderContainer.encode(domain, forKey: .domain)

    }
}

public class SetIpBlackListResponse:NSObject,Codable
{
    var requestId:String?;

    var error:ServiceError?;

    var result:SetIpBlackListResult?;

    enum SetIpBlackListResponseCodingKeys: String, CodingKey {
        case requestId
        case error
        case result
    }

    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: SetIpBlackListResponseCodingKeys.self)
        self.requestId = try decoderContainer.decodeIfPresent(String?.self, forKey: .requestId) ?? nil
        self.error = try decoderContainer.decodeIfPresent(ServiceError?.self, forKey: .error) ?? nil
        self.result = try decoderContainer.decodeIfPresent(SetIpBlackListResult?.self, forKey: .result) ?? nil
    }
}

public extension SetIpBlackListResponse{
        func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: SetIpBlackListResponseCodingKeys.self)
        try encoderContainer.encode(requestId, forKey: .requestId)
        try encoderContainer.encode(error, forKey: .error)
        try encoderContainer.encode(result, forKey: .result)
    }
}    
/// 设置range参数 
public class SetRangeResult:NSObject,JdCloudResult
{
}
/// 设置url鉴权 
public class SetAccesskeyConfigResult:NSObject,JdCloudResult
{
}

///  设置ip黑名单
public class SetIpBlackListRequest:JdCloudRequest
{
    /// ip黑名单,ips中url不能超过50条
    var ips:[String?]?

    /// 用户域名
    var domain:String


    public init(regionId: String,domain:String){
        self.domain = domain
        super.init(regionId: regionId)
    }


    enum SetIpBlackListRequestRequestCodingKeys: String, CodingKey {
        case ips
        case domain
    }

    public override func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: SetIpBlackListRequestRequestCodingKeys.self)
        try encoderContainer.encode(ips, forKey: .ips)
        try encoderContainer.encode(domain, forKey: .domain)

    }
}

/// 删除httpHeader 
public class DeleteHttpHeaderResult:NSObject,JdCloudResult
{
}
public class SetFollowSourceProtocolResponse:NSObject,Codable
{
    var requestId:String?;

    var error:ServiceError?;

    var result:SetFollowSourceProtocolResult?;

    enum SetFollowSourceProtocolResponseCodingKeys: String, CodingKey {
        case requestId
        case error
        case result
    }

    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: SetFollowSourceProtocolResponseCodingKeys.self)
        self.requestId = try decoderContainer.decodeIfPresent(String?.self, forKey: .requestId) ?? nil
        self.error = try decoderContainer.decodeIfPresent(ServiceError?.self, forKey: .error) ?? nil
        self.result = try decoderContainer.decodeIfPresent(SetFollowSourceProtocolResult?.self, forKey: .result) ?? nil
    }
}

public extension SetFollowSourceProtocolResponse{
        func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: SetFollowSourceProtocolResponseCodingKeys.self)
        try encoderContainer.encode(requestId, forKey: .requestId)
        try encoderContainer.encode(error, forKey: .error)
        try encoderContainer.encode(result, forKey: .result)
    }
}    

///  更新域名配置
public class SetDomainConfigRequest:JdCloudRequest
{
    /// http类型,只能为http或者https
    var httpType:String?

    /// 回源类型
    var backSourceType:String?

    /// 有三种类型：default、http、https
    var jumpType:String?

    /// 用户域名
    var domain:String


    public init(regionId: String,domain:String){
        self.domain = domain
        super.init(regionId: regionId)
    }


    enum SetDomainConfigRequestRequestCodingKeys: String, CodingKey {
        case httpType
        case backSourceType
        case jumpType
        case domain
    }

    public override func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: SetDomainConfigRequestRequestCodingKeys.self)
        try encoderContainer.encode(httpType, forKey: .httpType)
        try encoderContainer.encode(backSourceType, forKey: .backSourceType)
        try encoderContainer.encode(jumpType, forKey: .jumpType)
        try encoderContainer.encode(domain, forKey: .domain)

    }
}


///  查询ip黑名单
public class QueryIpBlackListRequest:JdCloudRequest
{
    /// 用户域名
    var domain:String


    public init(regionId: String,domain:String){
        self.domain = domain
        super.init(regionId: regionId)
    }


    enum QueryIpBlackListRequestRequestCodingKeys: String, CodingKey {
        case domain
    }

    public override func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: QueryIpBlackListRequestRequestCodingKeys.self)
        try encoderContainer.encode(domain, forKey: .domain)

    }
}


///  删除缓存规则
public class DeleteCacheRuleRequest:JdCloudRequest
{
    /// 缓存规则配置ID
    var configId:Int64?

    /// 用户域名
    var domain:String


    public init(regionId: String,domain:String){
        self.domain = domain
        super.init(regionId: regionId)
    }


    enum DeleteCacheRuleRequestRequestCodingKeys: String, CodingKey {
        case configId
        case domain
    }

    public override func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: DeleteCacheRuleRequestRequestCodingKeys.self)
        try encoderContainer.encode(configId, forKey: .configId)
        try encoderContainer.encode(domain, forKey: .domain)

    }
}


///  删除httpHeader
public class DeleteHttpHeaderRequest:JdCloudRequest
{
    /// header类型[resp,req]
    var headerType:String?

    /// header名
    var headerName:String?

    /// 用户域名
    var domain:String


    public init(regionId: String,domain:String){
        self.domain = domain
        super.init(regionId: regionId)
    }


    enum DeleteHttpHeaderRequestRequestCodingKeys: String, CodingKey {
        case headerType
        case headerName
        case domain
    }

    public override func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: DeleteHttpHeaderRequestRequestCodingKeys.self)
        try encoderContainer.encode(headerType, forKey: .headerType)
        try encoderContainer.encode(headerName, forKey: .headerName)
        try encoderContainer.encode(domain, forKey: .domain)

    }
}

/// 设置回源302跳转 
public class SetFollowRedirectResult:NSObject,JdCloudResult
{
}
/// 设置域名refer 
public class SetReferResult:NSObject,JdCloudResult
{
}

///  停止源站监控
public class StopMonitorRequest:JdCloudRequest
{
    /// 用户域名
    var domain:String


    public init(regionId: String,domain:String){
        self.domain = domain
        super.init(regionId: regionId)
    }


    enum StopMonitorRequestRequestCodingKeys: String, CodingKey {
        case domain
    }

    public override func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: StopMonitorRequestRequestCodingKeys.self)
        try encoderContainer.encode(domain, forKey: .domain)

    }
}

/// 更新域名配置 
public class SetDomainConfigResult:NSObject,JdCloudResult
{
    /// 任务taskId
    var taskId:String?



    public override init(){
        super.init()
    }

    enum SetDomainConfigResultCodingKeys: String, CodingKey {
        case taskId
    }

    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: SetDomainConfigResultCodingKeys.self)
        if decoderContainer.contains(.taskId)
        {
            self.taskId = try decoderContainer.decode(String?.self, forKey: .taskId)
        }
    }
}
public extension SetDomainConfigResult{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: SetDomainConfigResultCodingKeys.self)
        try encoderContainer.encode(taskId, forKey: .taskId)
    }
}
public class DeleteHttpHeaderResponse:NSObject,Codable
{
    var requestId:String?;

    var error:ServiceError?;

    var result:DeleteHttpHeaderResult?;

    enum DeleteHttpHeaderResponseCodingKeys: String, CodingKey {
        case requestId
        case error
        case result
    }

    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: DeleteHttpHeaderResponseCodingKeys.self)
        self.requestId = try decoderContainer.decodeIfPresent(String?.self, forKey: .requestId) ?? nil
        self.error = try decoderContainer.decodeIfPresent(ServiceError?.self, forKey: .error) ?? nil
        self.result = try decoderContainer.decodeIfPresent(DeleteHttpHeaderResult?.self, forKey: .result) ?? nil
    }
}

public extension DeleteHttpHeaderResponse{
        func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: DeleteHttpHeaderResponseCodingKeys.self)
        try encoderContainer.encode(requestId, forKey: .requestId)
        try encoderContainer.encode(error, forKey: .error)
        try encoderContainer.encode(result, forKey: .result)
    }
}    
public class SetHttpTypeResponse:NSObject,Codable
{
    var requestId:String?;

    var error:ServiceError?;

    var result:SetHttpTypeResult?;

    enum SetHttpTypeResponseCodingKeys: String, CodingKey {
        case requestId
        case error
        case result
    }

    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: SetHttpTypeResponseCodingKeys.self)
        self.requestId = try decoderContainer.decodeIfPresent(String?.self, forKey: .requestId) ?? nil
        self.error = try decoderContainer.decodeIfPresent(ServiceError?.self, forKey: .error) ?? nil
        self.result = try decoderContainer.decodeIfPresent(SetHttpTypeResult?.self, forKey: .result) ?? nil
    }
}

public extension SetHttpTypeResponse{
        func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: SetHttpTypeResponseCodingKeys.self)
        try encoderContainer.encode(requestId, forKey: .requestId)
        try encoderContainer.encode(error, forKey: .error)
        try encoderContainer.encode(result, forKey: .result)
    }
}    
/// 查询回源302跳转信息 
public class QueryFollowRedirectResult:NSObject,JdCloudResult
{
    /// Domain
    var domain:String?

    /// FollowRedirect
    var followRedirect:String?



    public override init(){
        super.init()
    }

    enum QueryFollowRedirectResultCodingKeys: String, CodingKey {
        case domain
        case followRedirect
    }

    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: QueryFollowRedirectResultCodingKeys.self)
        if decoderContainer.contains(.domain)
        {
            self.domain = try decoderContainer.decode(String?.self, forKey: .domain)
        }
        if decoderContainer.contains(.followRedirect)
        {
            self.followRedirect = try decoderContainer.decode(String?.self, forKey: .followRedirect)
        }
    }
}
public extension QueryFollowRedirectResult{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: QueryFollowRedirectResultCodingKeys.self)
        try encoderContainer.encode(domain, forKey: .domain)
        try encoderContainer.encode(followRedirect, forKey: .followRedirect)
    }
}

///  添加httpHeader
public class SetHttpHeaderRequest:JdCloudRequest
{
    /// header类型[resp,req]
    var headerType:String?

    /// header名
    var headerName:String?

    /// header值
    var headerValue:String?

    /// 用户域名
    var domain:String


    public init(regionId: String,domain:String){
        self.domain = domain
        super.init(regionId: regionId)
    }


    enum SetHttpHeaderRequestRequestCodingKeys: String, CodingKey {
        case headerType
        case headerName
        case headerValue
        case domain
    }

    public override func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: SetHttpHeaderRequestRequestCodingKeys.self)
        try encoderContainer.encode(headerType, forKey: .headerType)
        try encoderContainer.encode(headerName, forKey: .headerName)
        try encoderContainer.encode(headerValue, forKey: .headerValue)
        try encoderContainer.encode(domain, forKey: .domain)

    }
}

/// 设置ip黑名单 
public class SetIpBlackListResult:NSObject,JdCloudResult
{
}
public class QueryUserAgentResponse:NSObject,Codable
{
    var requestId:String?;

    var error:ServiceError?;

    var result:QueryUserAgentResult?;

    enum QueryUserAgentResponseCodingKeys: String, CodingKey {
        case requestId
        case error
        case result
    }

    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: QueryUserAgentResponseCodingKeys.self)
        self.requestId = try decoderContainer.decodeIfPresent(String?.self, forKey: .requestId) ?? nil
        self.error = try decoderContainer.decodeIfPresent(ServiceError?.self, forKey: .error) ?? nil
        self.result = try decoderContainer.decodeIfPresent(QueryUserAgentResult?.self, forKey: .result) ?? nil
    }
}

public extension QueryUserAgentResponse{
        func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: QueryUserAgentResponseCodingKeys.self)
        try encoderContainer.encode(requestId, forKey: .requestId)
        try encoderContainer.encode(error, forKey: .error)
        try encoderContainer.encode(result, forKey: .result)
    }
}    

///  泛域名共享缓存
public class OperateShareCacheRequest:JdCloudRequest
{
    /// 共享缓存只能是off或者on
    var status:String?

    /// 用户域名
    var domain:String


    public init(regionId: String,domain:String){
        self.domain = domain
        super.init(regionId: regionId)
    }


    enum OperateShareCacheRequestRequestCodingKeys: String, CodingKey {
        case status
        case domain
    }

    public override func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: OperateShareCacheRequestRequestCodingKeys.self)
        try encoderContainer.encode(status, forKey: .status)
        try encoderContainer.encode(domain, forKey: .domain)

    }
}


///  设置视频拖拽
public class SetVideoDraftRequest:JdCloudRequest
{
    /// 开关取值[on,off]
    var status:String?

    /// 用户域名
    var domain:String


    public init(regionId: String,domain:String){
        self.domain = domain
        super.init(regionId: regionId)
    }


    enum SetVideoDraftRequestRequestCodingKeys: String, CodingKey {
        case status
        case domain
    }

    public override func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: SetVideoDraftRequestRequestCodingKeys.self)
        try encoderContainer.encode(status, forKey: .status)
        try encoderContainer.encode(domain, forKey: .domain)

    }
}

/// 删除缓存规则 
public class DeleteCacheRuleResult:NSObject,JdCloudResult
{
}
/// 设置视频拖拽 
public class SetVideoDraftResult:NSObject,JdCloudResult
{
}
/// 设置userAgent信息 
public class SetUserAgentConfigResult:NSObject,JdCloudResult
{
}
public class QueryAccesskeyConfigResponse:NSObject,Codable
{
    var requestId:String?;

    var error:ServiceError?;

    var result:QueryAccesskeyConfigResult?;

    enum QueryAccesskeyConfigResponseCodingKeys: String, CodingKey {
        case requestId
        case error
        case result
    }

    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: QueryAccesskeyConfigResponseCodingKeys.self)
        self.requestId = try decoderContainer.decodeIfPresent(String?.self, forKey: .requestId) ?? nil
        self.error = try decoderContainer.decodeIfPresent(ServiceError?.self, forKey: .error) ?? nil
        self.result = try decoderContainer.decodeIfPresent(QueryAccesskeyConfigResult?.self, forKey: .result) ?? nil
    }
}

public extension QueryAccesskeyConfigResponse{
        func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: QueryAccesskeyConfigResponseCodingKeys.self)
        try encoderContainer.encode(requestId, forKey: .requestId)
        try encoderContainer.encode(error, forKey: .error)
        try encoderContainer.encode(result, forKey: .result)
    }
}    
/// 设置忽略参数 
public class SetIgnoreQueryStringResult:NSObject,JdCloudResult
{
}
/// 添加httpHeader 
public class SetHttpHeaderResult:NSObject,JdCloudResult
{
}

///  设置源站监控信息
public class SetMonitorRequest:JdCloudRequest
{
    /// 探测周期，取值1和5，单位为分钟
    var cycle:Int32?

    /// 探测路径
    var monitorPath:String?

    /// http请求头
    var httpRequestHeader:[String:String?]?

    /// 用户域名
    var domain:String


    public init(regionId: String,domain:String){
        self.domain = domain
        super.init(regionId: regionId)
    }


    enum SetMonitorRequestRequestCodingKeys: String, CodingKey {
        case cycle
        case monitorPath
        case httpRequestHeader
        case domain
    }

    public override func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: SetMonitorRequestRequestCodingKeys.self)
        try encoderContainer.encode(cycle, forKey: .cycle)
        try encoderContainer.encode(monitorPath, forKey: .monitorPath)
        try encoderContainer.encode(httpRequestHeader, forKey: .httpRequestHeader)
        try encoderContainer.encode(domain, forKey: .domain)

    }
}

public class SetHttpHeaderResponse:NSObject,Codable
{
    var requestId:String?;

    var error:ServiceError?;

    var result:SetHttpHeaderResult?;

    enum SetHttpHeaderResponseCodingKeys: String, CodingKey {
        case requestId
        case error
        case result
    }

    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: SetHttpHeaderResponseCodingKeys.self)
        self.requestId = try decoderContainer.decodeIfPresent(String?.self, forKey: .requestId) ?? nil
        self.error = try decoderContainer.decodeIfPresent(ServiceError?.self, forKey: .error) ?? nil
        self.result = try decoderContainer.decodeIfPresent(SetHttpHeaderResult?.self, forKey: .result) ?? nil
    }
}

public extension SetHttpHeaderResponse{
        func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: SetHttpHeaderResponseCodingKeys.self)
        try encoderContainer.encode(requestId, forKey: .requestId)
        try encoderContainer.encode(error, forKey: .error)
        try encoderContainer.encode(result, forKey: .result)
    }
}    
public class QueryHttpHeaderResponse:NSObject,Codable
{
    var requestId:String?;

    var error:ServiceError?;

    var result:QueryHttpHeaderResult?;

    enum QueryHttpHeaderResponseCodingKeys: String, CodingKey {
        case requestId
        case error
        case result
    }

    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: QueryHttpHeaderResponseCodingKeys.self)
        self.requestId = try decoderContainer.decodeIfPresent(String?.self, forKey: .requestId) ?? nil
        self.error = try decoderContainer.decodeIfPresent(ServiceError?.self, forKey: .error) ?? nil
        self.result = try decoderContainer.decodeIfPresent(QueryHttpHeaderResult?.self, forKey: .result) ?? nil
    }
}

public extension QueryHttpHeaderResponse{
        func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: QueryHttpHeaderResponseCodingKeys.self)
        try encoderContainer.encode(requestId, forKey: .requestId)
        try encoderContainer.encode(error, forKey: .error)
        try encoderContainer.encode(result, forKey: .result)
    }
}    
/// 查询http header头 
public class QueryHttpHeaderResult:NSObject,JdCloudResult
{
    /// Domain
    var domain:String?

    /// Headers
    var headers:[QueryHttpHeaderResp?]?



    public override init(){
        super.init()
    }

    enum QueryHttpHeaderResultCodingKeys: String, CodingKey {
        case domain
        case headers
    }

    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: QueryHttpHeaderResultCodingKeys.self)
        if decoderContainer.contains(.domain)
        {
            self.domain = try decoderContainer.decode(String?.self, forKey: .domain)
        }
        if decoderContainer.contains(.headers)
        {
            self.headers = try decoderContainer.decode([QueryHttpHeaderResp?]?.self, forKey: .headers)
        }
    }
}
public extension QueryHttpHeaderResult{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: QueryHttpHeaderResultCodingKeys.self)
        try encoderContainer.encode(domain, forKey: .domain)
        try encoderContainer.encode(headers, forKey: .headers)
    }
}

///  设置忽略参数
public class SetIgnoreQueryStringRequest:JdCloudRequest
{
    /// 开关取值[on,off]
    var status:String?

    /// 用户域名
    var domain:String


    public init(regionId: String,domain:String){
        self.domain = domain
        super.init(regionId: regionId)
    }


    enum SetIgnoreQueryStringRequestRequestCodingKeys: String, CodingKey {
        case status
        case domain
    }

    public override func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: SetIgnoreQueryStringRequestRequestCodingKeys.self)
        try encoderContainer.encode(status, forKey: .status)
        try encoderContainer.encode(domain, forKey: .domain)

    }
}

/// 泛域名共享缓存 
public class OperateShareCacheResult:NSObject,JdCloudResult
{
}
public class StopMonitorResponse:NSObject,Codable
{
    var requestId:String?;

    var error:ServiceError?;

    var result:StopMonitorResult?;

    enum StopMonitorResponseCodingKeys: String, CodingKey {
        case requestId
        case error
        case result
    }

    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: StopMonitorResponseCodingKeys.self)
        self.requestId = try decoderContainer.decodeIfPresent(String?.self, forKey: .requestId) ?? nil
        self.error = try decoderContainer.decodeIfPresent(ServiceError?.self, forKey: .error) ?? nil
        self.result = try decoderContainer.decodeIfPresent(StopMonitorResult?.self, forKey: .result) ?? nil
    }
}

public extension StopMonitorResponse{
        func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: StopMonitorResponseCodingKeys.self)
        try encoderContainer.encode(requestId, forKey: .requestId)
        try encoderContainer.encode(error, forKey: .error)
        try encoderContainer.encode(result, forKey: .result)
    }
}    
public class DeleteCacheRuleResponse:NSObject,Codable
{
    var requestId:String?;

    var error:ServiceError?;

    var result:DeleteCacheRuleResult?;

    enum DeleteCacheRuleResponseCodingKeys: String, CodingKey {
        case requestId
        case error
        case result
    }

    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: DeleteCacheRuleResponseCodingKeys.self)
        self.requestId = try decoderContainer.decodeIfPresent(String?.self, forKey: .requestId) ?? nil
        self.error = try decoderContainer.decodeIfPresent(ServiceError?.self, forKey: .error) ?? nil
        self.result = try decoderContainer.decodeIfPresent(DeleteCacheRuleResult?.self, forKey: .result) ?? nil
    }
}

public extension DeleteCacheRuleResponse{
        func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: DeleteCacheRuleResponseCodingKeys.self)
        try encoderContainer.encode(requestId, forKey: .requestId)
        try encoderContainer.encode(error, forKey: .error)
        try encoderContainer.encode(result, forKey: .result)
    }
}    
/// 设置源站信息 
public class SetSourceResult:NSObject,JdCloudResult
{
    /// 任务id
    var taskId:String?



    public override init(){
        super.init()
    }

    enum SetSourceResultCodingKeys: String, CodingKey {
        case taskId
    }

    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: SetSourceResultCodingKeys.self)
        if decoderContainer.contains(.taskId)
        {
            self.taskId = try decoderContainer.decode(String?.self, forKey: .taskId)
        }
    }
}
public extension SetSourceResult{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: SetSourceResultCodingKeys.self)
        try encoderContainer.encode(taskId, forKey: .taskId)
    }
}
public class SetSourceResponse:NSObject,Codable
{
    var requestId:String?;

    var error:ServiceError?;

    var result:SetSourceResult?;

    enum SetSourceResponseCodingKeys: String, CodingKey {
        case requestId
        case error
        case result
    }

    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: SetSourceResponseCodingKeys.self)
        self.requestId = try decoderContainer.decodeIfPresent(String?.self, forKey: .requestId) ?? nil
        self.error = try decoderContainer.decodeIfPresent(ServiceError?.self, forKey: .error) ?? nil
        self.result = try decoderContainer.decodeIfPresent(SetSourceResult?.self, forKey: .result) ?? nil
    }
}

public extension SetSourceResponse{
        func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: SetSourceResponseCodingKeys.self)
        try encoderContainer.encode(requestId, forKey: .requestId)
        try encoderContainer.encode(error, forKey: .error)
        try encoderContainer.encode(result, forKey: .result)
    }
}    
/// 查询协议跟随回源 
public class QueryFollowSourceProtocolResult:NSObject,JdCloudResult
{
    /// Domain
    var domain:String?

    /// FollowProtocolStatus
    var followProtocolStatus:String?



    public override init(){
        super.init()
    }

    enum QueryFollowSourceProtocolResultCodingKeys: String, CodingKey {
        case domain
        case followProtocolStatus
    }

    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: QueryFollowSourceProtocolResultCodingKeys.self)
        if decoderContainer.contains(.domain)
        {
            self.domain = try decoderContainer.decode(String?.self, forKey: .domain)
        }
        if decoderContainer.contains(.followProtocolStatus)
        {
            self.followProtocolStatus = try decoderContainer.decode(String?.self, forKey: .followProtocolStatus)
        }
    }
}
public extension QueryFollowSourceProtocolResult{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: QueryFollowSourceProtocolResultCodingKeys.self)
        try encoderContainer.encode(domain, forKey: .domain)
        try encoderContainer.encode(followProtocolStatus, forKey: .followProtocolStatus)
    }
}

///  修改缓存规则
public class UpdateCacheRuleRequest:JdCloudRequest
{
    /// 此条配置的权重值, 取值范围为1-10,1最大
    var weight:Int32?

    /// 缓存时间,单位秒
    var ttl:Int64?

    /// 规则内容。其他类型只能以/或者.开头，如/a/b或.jpg
    var contents:String?

    /// 缓存方式：0、不缓存，1自定义
    var cacheType:Int32?

    /// 缓存规则配置ID
    var configId:Int64?

    /// 用户域名
    var domain:String


    public init(regionId: String,domain:String){
        self.domain = domain
        super.init(regionId: regionId)
    }


    enum UpdateCacheRuleRequestRequestCodingKeys: String, CodingKey {
        case weight
        case ttl
        case contents
        case cacheType
        case configId
        case domain
    }

    public override func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: UpdateCacheRuleRequestRequestCodingKeys.self)
        try encoderContainer.encode(weight, forKey: .weight)
        try encoderContainer.encode(ttl, forKey: .ttl)
        try encoderContainer.encode(contents, forKey: .contents)
        try encoderContainer.encode(cacheType, forKey: .cacheType)
        try encoderContainer.encode(configId, forKey: .configId)
        try encoderContainer.encode(domain, forKey: .domain)

    }
}

/// 停止源站监控 
public class StopMonitorResult:NSObject,JdCloudResult
{
}
public class OperateIpBlackListResponse:NSObject,Codable
{
    var requestId:String?;

    var error:ServiceError?;

    var result:OperateIpBlackListResult?;

    enum OperateIpBlackListResponseCodingKeys: String, CodingKey {
        case requestId
        case error
        case result
    }

    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: OperateIpBlackListResponseCodingKeys.self)
        self.requestId = try decoderContainer.decodeIfPresent(String?.self, forKey: .requestId) ?? nil
        self.error = try decoderContainer.decodeIfPresent(ServiceError?.self, forKey: .error) ?? nil
        self.result = try decoderContainer.decodeIfPresent(OperateIpBlackListResult?.self, forKey: .result) ?? nil
    }
}

public extension OperateIpBlackListResponse{
        func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: OperateIpBlackListResponseCodingKeys.self)
        try encoderContainer.encode(requestId, forKey: .requestId)
        try encoderContainer.encode(error, forKey: .error)
        try encoderContainer.encode(result, forKey: .result)
    }
}    
/// 预览证书 
public class PreviewCertificateResult:NSObject,JdCloudResult
{
    /// SigAlgName
    var sigAlgName:String?

    /// Issuer
    var issuer:String?

    /// StartDate
    var startDate:String?

    /// EndDate
    var endDate:String?

    /// User
    var user:String?

    /// SigHashAlgName
    var sigHashAlgName:String?



    public override init(){
        super.init()
    }

    enum PreviewCertificateResultCodingKeys: String, CodingKey {
        case sigAlgName
        case issuer
        case startDate
        case endDate
        case user
        case sigHashAlgName
    }

    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: PreviewCertificateResultCodingKeys.self)
        if decoderContainer.contains(.sigAlgName)
        {
            self.sigAlgName = try decoderContainer.decode(String?.self, forKey: .sigAlgName)
        }
        if decoderContainer.contains(.issuer)
        {
            self.issuer = try decoderContainer.decode(String?.self, forKey: .issuer)
        }
        if decoderContainer.contains(.startDate)
        {
            self.startDate = try decoderContainer.decode(String?.self, forKey: .startDate)
        }
        if decoderContainer.contains(.endDate)
        {
            self.endDate = try decoderContainer.decode(String?.self, forKey: .endDate)
        }
        if decoderContainer.contains(.user)
        {
            self.user = try decoderContainer.decode(String?.self, forKey: .user)
        }
        if decoderContainer.contains(.sigHashAlgName)
        {
            self.sigHashAlgName = try decoderContainer.decode(String?.self, forKey: .sigHashAlgName)
        }
    }
}
public extension PreviewCertificateResult{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: PreviewCertificateResultCodingKeys.self)
        try encoderContainer.encode(sigAlgName, forKey: .sigAlgName)
        try encoderContainer.encode(issuer, forKey: .issuer)
        try encoderContainer.encode(startDate, forKey: .startDate)
        try encoderContainer.encode(endDate, forKey: .endDate)
        try encoderContainer.encode(user, forKey: .user)
        try encoderContainer.encode(sigHashAlgName, forKey: .sigHashAlgName)
    }
}
public class QueryIpBlackListResponse:NSObject,Codable
{
    var requestId:String?;

    var error:ServiceError?;

    var result:QueryIpBlackListResult?;

    enum QueryIpBlackListResponseCodingKeys: String, CodingKey {
        case requestId
        case error
        case result
    }

    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: QueryIpBlackListResponseCodingKeys.self)
        self.requestId = try decoderContainer.decodeIfPresent(String?.self, forKey: .requestId) ?? nil
        self.error = try decoderContainer.decodeIfPresent(ServiceError?.self, forKey: .error) ?? nil
        self.result = try decoderContainer.decodeIfPresent(QueryIpBlackListResult?.self, forKey: .result) ?? nil
    }
}

public extension QueryIpBlackListResponse{
        func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: QueryIpBlackListResponseCodingKeys.self)
        try encoderContainer.encode(requestId, forKey: .requestId)
        try encoderContainer.encode(error, forKey: .error)
        try encoderContainer.encode(result, forKey: .result)
    }
}    

///  添加缓存规则
public class CreateCacheRuleRequest:JdCloudRequest
{
    /// 此条配置的权重值, 取值范围为1-10,1最大
    var weight:Int32?

    /// 缓存时间,单位秒
    var ttl:Int64?

    /// 规则内容。其他类型只能以/或者.开头，如/a/b或.jpg
    var contents:String?

    /// 缓存方式：0、不缓存，1自定义
    var cacheType:Int32?

    /// 用户域名
    var domain:String


    public init(regionId: String,domain:String){
        self.domain = domain
        super.init(regionId: regionId)
    }


    enum CreateCacheRuleRequestRequestCodingKeys: String, CodingKey {
        case weight
        case ttl
        case contents
        case cacheType
        case domain
    }

    public override func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: CreateCacheRuleRequestRequestCodingKeys.self)
        try encoderContainer.encode(weight, forKey: .weight)
        try encoderContainer.encode(ttl, forKey: .ttl)
        try encoderContainer.encode(contents, forKey: .contents)
        try encoderContainer.encode(cacheType, forKey: .cacheType)
        try encoderContainer.encode(domain, forKey: .domain)

    }
}

public class SetMonitorResponse:NSObject,Codable
{
    var requestId:String?;

    var error:ServiceError?;

    var result:SetMonitorResult?;

    enum SetMonitorResponseCodingKeys: String, CodingKey {
        case requestId
        case error
        case result
    }

    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: SetMonitorResponseCodingKeys.self)
        self.requestId = try decoderContainer.decodeIfPresent(String?.self, forKey: .requestId) ?? nil
        self.error = try decoderContainer.decodeIfPresent(ServiceError?.self, forKey: .error) ?? nil
        self.result = try decoderContainer.decodeIfPresent(SetMonitorResult?.self, forKey: .result) ?? nil
    }
}

public extension SetMonitorResponse{
        func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: SetMonitorResponseCodingKeys.self)
        try encoderContainer.encode(requestId, forKey: .requestId)
        try encoderContainer.encode(error, forKey: .error)
        try encoderContainer.encode(result, forKey: .result)
    }
}    
public class SetIgnoreQueryStringResponse:NSObject,Codable
{
    var requestId:String?;

    var error:ServiceError?;

    var result:SetIgnoreQueryStringResult?;

    enum SetIgnoreQueryStringResponseCodingKeys: String, CodingKey {
        case requestId
        case error
        case result
    }

    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: SetIgnoreQueryStringResponseCodingKeys.self)
        self.requestId = try decoderContainer.decodeIfPresent(String?.self, forKey: .requestId) ?? nil
        self.error = try decoderContainer.decodeIfPresent(ServiceError?.self, forKey: .error) ?? nil
        self.result = try decoderContainer.decodeIfPresent(SetIgnoreQueryStringResult?.self, forKey: .result) ?? nil
    }
}

public extension SetIgnoreQueryStringResponse{
        func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: SetIgnoreQueryStringResponseCodingKeys.self)
        try encoderContainer.encode(requestId, forKey: .requestId)
        try encoderContainer.encode(error, forKey: .error)
        try encoderContainer.encode(result, forKey: .result)
    }
}    
public class QueryMonitorResponse:NSObject,Codable
{
    var requestId:String?;

    var error:ServiceError?;

    var result:QueryMonitorResult?;

    enum QueryMonitorResponseCodingKeys: String, CodingKey {
        case requestId
        case error
        case result
    }

    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: QueryMonitorResponseCodingKeys.self)
        self.requestId = try decoderContainer.decodeIfPresent(String?.self, forKey: .requestId) ?? nil
        self.error = try decoderContainer.decodeIfPresent(ServiceError?.self, forKey: .error) ?? nil
        self.result = try decoderContainer.decodeIfPresent(QueryMonitorResult?.self, forKey: .result) ?? nil
    }
}

public extension QueryMonitorResponse{
        func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: QueryMonitorResponseCodingKeys.self)
        try encoderContainer.encode(requestId, forKey: .requestId)
        try encoderContainer.encode(error, forKey: .error)
        try encoderContainer.encode(result, forKey: .result)
    }
}    

///  查询协议跟随回源
public class QueryFollowSourceProtocolRequest:JdCloudRequest
{
    /// 用户域名
    var domain:String


    public init(regionId: String,domain:String){
        self.domain = domain
        super.init(regionId: regionId)
    }


    enum QueryFollowSourceProtocolRequestRequestCodingKeys: String, CodingKey {
        case domain
    }

    public override func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: QueryFollowSourceProtocolRequestRequestCodingKeys.self)
        try encoderContainer.encode(domain, forKey: .domain)

    }
}


///  查询默认http header头部参数列表
public class QueryDefaultHttpHeaderKeyRequest:JdCloudRequest
{
}


///  设置http协议
public class SetHttpTypeRequest:JdCloudRequest
{
    /// http类型,只能为http或者https,默认为http.当设为https时,需要调用“设置通讯协议”接口上传证书和私钥
    var httpType:String?

    /// 用户证书,当Type为https时必须设置
    var certificate:String?

    /// 证书私钥
    var rsaKey:String?

    /// 有三种类型：default、http、https
    var jumpType:String?

    /// 证书来源有两种类型：default,ssl
    var certFrom:String?

    /// ssl证书id
    var sslCertId:String?

    /// 是否同步到ssl,boolean值，取值true或者false
    var syncToSsl:Bool?

    /// syncToSsl是true时，certName是必填项
    var certName:String?

    /// 用户域名
    var domain:String


    public init(regionId: String,domain:String){
        self.domain = domain
        super.init(regionId: regionId)
    }


    enum SetHttpTypeRequestRequestCodingKeys: String, CodingKey {
        case httpType
        case certificate
        case rsaKey
        case jumpType
        case certFrom
        case sslCertId
        case syncToSsl
        case certName
        case domain
    }

    public override func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: SetHttpTypeRequestRequestCodingKeys.self)
        try encoderContainer.encode(httpType, forKey: .httpType)
        try encoderContainer.encode(certificate, forKey: .certificate)
        try encoderContainer.encode(rsaKey, forKey: .rsaKey)
        try encoderContainer.encode(jumpType, forKey: .jumpType)
        try encoderContainer.encode(certFrom, forKey: .certFrom)
        try encoderContainer.encode(sslCertId, forKey: .sslCertId)
        try encoderContainer.encode(syncToSsl, forKey: .syncToSsl)
        try encoderContainer.encode(certName, forKey: .certName)
        try encoderContainer.encode(domain, forKey: .domain)

    }
}


///  查询源站监控信息
public class QueryMonitorRequest:JdCloudRequest
{
    /// 用户域名
    var domain:String


    public init(regionId: String,domain:String){
        self.domain = domain
        super.init(regionId: regionId)
    }


    enum QueryMonitorRequestRequestCodingKeys: String, CodingKey {
        case domain
    }

    public override func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: QueryMonitorRequestRequestCodingKeys.self)
        try encoderContainer.encode(domain, forKey: .domain)

    }
}


///  查询回源302跳转信息
public class QueryFollowRedirectRequest:JdCloudRequest
{
    /// 用户域名
    var domain:String


    public init(regionId: String,domain:String){
        self.domain = domain
        super.init(regionId: regionId)
    }


    enum QueryFollowRedirectRequestRequestCodingKeys: String, CodingKey {
        case domain
    }

    public override func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: QueryFollowRedirectRequestRequestCodingKeys.self)
        try encoderContainer.encode(domain, forKey: .domain)

    }
}


///  设置url鉴权
public class SetAccesskeyConfigRequest:JdCloudRequest
{
    /// 鉴权类型，0表示无鉴权，1表示参数鉴权，2表示路径鉴权
    var accesskeyType:Int32?

    /// 密码，长度为8到32
    var accesskeyKey:String?

    /// 是否是回源鉴权 0表示是 1表示否
    var accesskeyKeep:Int32?

    /// 用户域名
    var domain:String


    public init(regionId: String,domain:String){
        self.domain = domain
        super.init(regionId: regionId)
    }


    enum SetAccesskeyConfigRequestRequestCodingKeys: String, CodingKey {
        case accesskeyType
        case accesskeyKey
        case accesskeyKeep
        case domain
    }

    public override func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: SetAccesskeyConfigRequestRequestCodingKeys.self)
        try encoderContainer.encode(accesskeyType, forKey: .accesskeyType)
        try encoderContainer.encode(accesskeyKey, forKey: .accesskeyKey)
        try encoderContainer.encode(accesskeyKeep, forKey: .accesskeyKeep)
        try encoderContainer.encode(domain, forKey: .domain)

    }
}


///  设置源站信息
public class SetSourceRequest:JdCloudRequest
{
    /// 回源类型只能是[ips,domain,oss]中的一种
    var sourceType:String?

    /// 回源方式,只能是[https,http]中的一种,默认http
    var backSourceType:String?

    /// IpSource
    var ipSource:[IpSourceInfo?]?

    /// DomainSource
    var domainSource:[DomainSourceInfo?]?

    /// oss回源域名
    var ossSource:String?

    /// 默认回源host
    var defaultSourceHost:String?

    /// 用户域名
    var domain:String


    public init(regionId: String,domain:String){
        self.domain = domain
        super.init(regionId: regionId)
    }


    enum SetSourceRequestRequestCodingKeys: String, CodingKey {
        case sourceType
        case backSourceType
        case ipSource
        case domainSource
        case ossSource
        case defaultSourceHost
        case domain
    }

    public override func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: SetSourceRequestRequestCodingKeys.self)
        try encoderContainer.encode(sourceType, forKey: .sourceType)
        try encoderContainer.encode(backSourceType, forKey: .backSourceType)
        try encoderContainer.encode(ipSource, forKey: .ipSource)
        try encoderContainer.encode(domainSource, forKey: .domainSource)
        try encoderContainer.encode(ossSource, forKey: .ossSource)
        try encoderContainer.encode(defaultSourceHost, forKey: .defaultSourceHost)
        try encoderContainer.encode(domain, forKey: .domain)

    }
}

/// 设置ip黑名单状态 
public class OperateIpBlackListResult:NSObject,JdCloudResult
{
}
public class QueryFollowRedirectResponse:NSObject,Codable
{
    var requestId:String?;

    var error:ServiceError?;

    var result:QueryFollowRedirectResult?;

    enum QueryFollowRedirectResponseCodingKeys: String, CodingKey {
        case requestId
        case error
        case result
    }

    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: QueryFollowRedirectResponseCodingKeys.self)
        self.requestId = try decoderContainer.decodeIfPresent(String?.self, forKey: .requestId) ?? nil
        self.error = try decoderContainer.decodeIfPresent(ServiceError?.self, forKey: .error) ?? nil
        self.result = try decoderContainer.decodeIfPresent(QueryFollowRedirectResult?.self, forKey: .result) ?? nil
    }
}

public extension QueryFollowRedirectResponse{
        func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: QueryFollowRedirectResponseCodingKeys.self)
        try encoderContainer.encode(requestId, forKey: .requestId)
        try encoderContainer.encode(error, forKey: .error)
        try encoderContainer.encode(result, forKey: .result)
    }
}    
public class UpdateCacheRuleResponse:NSObject,Codable
{
    var requestId:String?;

    var error:ServiceError?;

    var result:UpdateCacheRuleResult?;

    enum UpdateCacheRuleResponseCodingKeys: String, CodingKey {
        case requestId
        case error
        case result
    }

    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: UpdateCacheRuleResponseCodingKeys.self)
        self.requestId = try decoderContainer.decodeIfPresent(String?.self, forKey: .requestId) ?? nil
        self.error = try decoderContainer.decodeIfPresent(ServiceError?.self, forKey: .error) ?? nil
        self.result = try decoderContainer.decodeIfPresent(UpdateCacheRuleResult?.self, forKey: .result) ?? nil
    }
}

public extension UpdateCacheRuleResponse{
        func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: UpdateCacheRuleResponseCodingKeys.self)
        try encoderContainer.encode(requestId, forKey: .requestId)
        try encoderContainer.encode(error, forKey: .error)
        try encoderContainer.encode(result, forKey: .result)
    }
}    

///  设置range参数
public class SetRangeRequest:JdCloudRequest
{
    /// 开关取值[on,off]
    var status:String?

    /// 用户域名
    var domain:String


    public init(regionId: String,domain:String){
        self.domain = domain
        super.init(regionId: regionId)
    }


    enum SetRangeRequestRequestCodingKeys: String, CodingKey {
        case status
        case domain
    }

    public override func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: SetRangeRequestRequestCodingKeys.self)
        try encoderContainer.encode(status, forKey: .status)
        try encoderContainer.encode(domain, forKey: .domain)

    }
}

public class SetDomainConfigResponse:NSObject,Codable
{
    var requestId:String?;

    var error:ServiceError?;

    var result:SetDomainConfigResult?;

    enum SetDomainConfigResponseCodingKeys: String, CodingKey {
        case requestId
        case error
        case result
    }

    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: SetDomainConfigResponseCodingKeys.self)
        self.requestId = try decoderContainer.decodeIfPresent(String?.self, forKey: .requestId) ?? nil
        self.error = try decoderContainer.decodeIfPresent(ServiceError?.self, forKey: .error) ?? nil
        self.result = try decoderContainer.decodeIfPresent(SetDomainConfigResult?.self, forKey: .result) ?? nil
    }
}

public extension SetDomainConfigResponse{
        func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: SetDomainConfigResponseCodingKeys.self)
        try encoderContainer.encode(requestId, forKey: .requestId)
        try encoderContainer.encode(error, forKey: .error)
        try encoderContainer.encode(result, forKey: .result)
    }
}    
/// 设置源站监控信息 
public class SetMonitorResult:NSObject,JdCloudResult
{
    /// MonitorId
    var monitorId:Int64?



    public override init(){
        super.init()
    }

    enum SetMonitorResultCodingKeys: String, CodingKey {
        case monitorId
    }

    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: SetMonitorResultCodingKeys.self)
        if decoderContainer.contains(.monitorId)
        {
            self.monitorId = try decoderContainer.decode(Int64?.self, forKey: .monitorId)
        }
    }
}
public extension SetMonitorResult{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: SetMonitorResultCodingKeys.self)
        try encoderContainer.encode(monitorId, forKey: .monitorId)
    }
}
/// 查询url鉴权 
public class QueryAccesskeyConfigResult:NSObject,JdCloudResult
{
    /// 鉴权类型，0表示无鉴权，1表示参数鉴权，2表示路径鉴权
    var accesskeyType:Int32?

    /// 密码，长度为8到32
    var accesskeyKey:String?

    /// 是否是回源鉴权 0表示是 1表示否
    var accesskeyKeep:Int32?



    public override init(){
        super.init()
    }

    enum QueryAccesskeyConfigResultCodingKeys: String, CodingKey {
        case accesskeyType
        case accesskeyKey
        case accesskeyKeep
    }

    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: QueryAccesskeyConfigResultCodingKeys.self)
        if decoderContainer.contains(.accesskeyType)
        {
            self.accesskeyType = try decoderContainer.decode(Int32?.self, forKey: .accesskeyType)
        }
        if decoderContainer.contains(.accesskeyKey)
        {
            self.accesskeyKey = try decoderContainer.decode(String?.self, forKey: .accesskeyKey)
        }
        if decoderContainer.contains(.accesskeyKeep)
        {
            self.accesskeyKeep = try decoderContainer.decode(Int32?.self, forKey: .accesskeyKeep)
        }
    }
}
public extension QueryAccesskeyConfigResult{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: QueryAccesskeyConfigResultCodingKeys.self)
        try encoderContainer.encode(accesskeyType, forKey: .accesskeyType)
        try encoderContainer.encode(accesskeyKey, forKey: .accesskeyKey)
        try encoderContainer.encode(accesskeyKeep, forKey: .accesskeyKeep)
    }
}

///  设置userAgent信息
public class SetUserAgentConfigRequest:JdCloudRequest
{
    /// userAgent类型,取值：block（黑名单）,allow（白名单）,默认为block
    var userAgentType:String?

    /// UA列表,如果userAgentList为空,则为全部删除
    var userAgentList:[String?]?

    /// 用户域名
    var domain:String


    public init(regionId: String,domain:String){
        self.domain = domain
        super.init(regionId: regionId)
    }


    enum SetUserAgentConfigRequestRequestCodingKeys: String, CodingKey {
        case userAgentType
        case userAgentList
        case domain
    }

    public override func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: SetUserAgentConfigRequestRequestCodingKeys.self)
        try encoderContainer.encode(userAgentType, forKey: .userAgentType)
        try encoderContainer.encode(userAgentList, forKey: .userAgentList)
        try encoderContainer.encode(domain, forKey: .domain)

    }
}


///  预览证书
public class PreviewCertificateRequest:JdCloudRequest
{
    /// Content
    var content:String?

    /// 用户域名
    var domain:String


    public init(regionId: String,domain:String){
        self.domain = domain
        super.init(regionId: regionId)
    }


    enum PreviewCertificateRequestRequestCodingKeys: String, CodingKey {
        case content
        case domain
    }

    public override func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: PreviewCertificateRequestRequestCodingKeys.self)
        try encoderContainer.encode(content, forKey: .content)
        try encoderContainer.encode(domain, forKey: .domain)

    }
}

/// 修改缓存规则 
public class UpdateCacheRuleResult:NSObject,JdCloudResult
{
}

///  设置userAgent信息
public class QueryUserAgentRequest:JdCloudRequest
{
    /// 用户域名
    var domain:String


    public init(regionId: String,domain:String){
        self.domain = domain
        super.init(regionId: regionId)
    }


    enum QueryUserAgentRequestRequestCodingKeys: String, CodingKey {
        case domain
    }

    public override func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: QueryUserAgentRequestRequestCodingKeys.self)
        try encoderContainer.encode(domain, forKey: .domain)

    }
}

public class SetReferResponse:NSObject,Codable
{
    var requestId:String?;

    var error:ServiceError?;

    var result:SetReferResult?;

    enum SetReferResponseCodingKeys: String, CodingKey {
        case requestId
        case error
        case result
    }

    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: SetReferResponseCodingKeys.self)
        self.requestId = try decoderContainer.decodeIfPresent(String?.self, forKey: .requestId) ?? nil
        self.error = try decoderContainer.decodeIfPresent(ServiceError?.self, forKey: .error) ?? nil
        self.result = try decoderContainer.decodeIfPresent(SetReferResult?.self, forKey: .result) ?? nil
    }
}

public extension SetReferResponse{
        func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: SetReferResponseCodingKeys.self)
        try encoderContainer.encode(requestId, forKey: .requestId)
        try encoderContainer.encode(error, forKey: .error)
        try encoderContainer.encode(result, forKey: .result)
    }
}    
public class SetRangeResponse:NSObject,Codable
{
    var requestId:String?;

    var error:ServiceError?;

    var result:SetRangeResult?;

    enum SetRangeResponseCodingKeys: String, CodingKey {
        case requestId
        case error
        case result
    }

    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: SetRangeResponseCodingKeys.self)
        self.requestId = try decoderContainer.decodeIfPresent(String?.self, forKey: .requestId) ?? nil
        self.error = try decoderContainer.decodeIfPresent(ServiceError?.self, forKey: .error) ?? nil
        self.result = try decoderContainer.decodeIfPresent(SetRangeResult?.self, forKey: .result) ?? nil
    }
}

public extension SetRangeResponse{
        func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: SetRangeResponseCodingKeys.self)
        try encoderContainer.encode(requestId, forKey: .requestId)
        try encoderContainer.encode(error, forKey: .error)
        try encoderContainer.encode(result, forKey: .result)
    }
}    
public class CreateCacheRuleResponse:NSObject,Codable
{
    var requestId:String?;

    var error:ServiceError?;

    var result:CreateCacheRuleResult?;

    enum CreateCacheRuleResponseCodingKeys: String, CodingKey {
        case requestId
        case error
        case result
    }

    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: CreateCacheRuleResponseCodingKeys.self)
        self.requestId = try decoderContainer.decodeIfPresent(String?.self, forKey: .requestId) ?? nil
        self.error = try decoderContainer.decodeIfPresent(ServiceError?.self, forKey: .error) ?? nil
        self.result = try decoderContainer.decodeIfPresent(CreateCacheRuleResult?.self, forKey: .result) ?? nil
    }
}

public extension CreateCacheRuleResponse{
        func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: CreateCacheRuleResponseCodingKeys.self)
        try encoderContainer.encode(requestId, forKey: .requestId)
        try encoderContainer.encode(error, forKey: .error)
        try encoderContainer.encode(result, forKey: .result)
    }
}    

///  设置协议跟随回源
public class SetFollowSourceProtocolRequest:JdCloudRequest
{
    /// 开关取值[on,off]
    var status:String?

    /// 用户域名
    var domain:String


    public init(regionId: String,domain:String){
        self.domain = domain
        super.init(regionId: regionId)
    }


    enum SetFollowSourceProtocolRequestRequestCodingKeys: String, CodingKey {
        case status
        case domain
    }

    public override func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: SetFollowSourceProtocolRequestRequestCodingKeys.self)
        try encoderContainer.encode(status, forKey: .status)
        try encoderContainer.encode(domain, forKey: .domain)

    }
}


///  设置ip黑名单状态
public class OperateIpBlackListRequest:JdCloudRequest
{
    /// ip黑名单状态取值[on,off]
    var status:String?

    /// 用户域名
    var domain:String


    public init(regionId: String,domain:String){
        self.domain = domain
        super.init(regionId: regionId)
    }


    enum OperateIpBlackListRequestRequestCodingKeys: String, CodingKey {
        case status
        case domain
    }

    public override func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: OperateIpBlackListRequestRequestCodingKeys.self)
        try encoderContainer.encode(status, forKey: .status)
        try encoderContainer.encode(domain, forKey: .domain)

    }
}

public class QueryDefaultHttpHeaderKeyResponse:NSObject,Codable
{
    var requestId:String?;

    var error:ServiceError?;

    var result:QueryDefaultHttpHeaderKeyResult?;

    enum QueryDefaultHttpHeaderKeyResponseCodingKeys: String, CodingKey {
        case requestId
        case error
        case result
    }

    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: QueryDefaultHttpHeaderKeyResponseCodingKeys.self)
        self.requestId = try decoderContainer.decodeIfPresent(String?.self, forKey: .requestId) ?? nil
        self.error = try decoderContainer.decodeIfPresent(ServiceError?.self, forKey: .error) ?? nil
        self.result = try decoderContainer.decodeIfPresent(QueryDefaultHttpHeaderKeyResult?.self, forKey: .result) ?? nil
    }
}

public extension QueryDefaultHttpHeaderKeyResponse{
        func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: QueryDefaultHttpHeaderKeyResponseCodingKeys.self)
        try encoderContainer.encode(requestId, forKey: .requestId)
        try encoderContainer.encode(error, forKey: .error)
        try encoderContainer.encode(result, forKey: .result)
    }
}    
public class SetAccesskeyConfigResponse:NSObject,Codable
{
    var requestId:String?;

    var error:ServiceError?;

    var result:SetAccesskeyConfigResult?;

    enum SetAccesskeyConfigResponseCodingKeys: String, CodingKey {
        case requestId
        case error
        case result
    }

    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: SetAccesskeyConfigResponseCodingKeys.self)
        self.requestId = try decoderContainer.decodeIfPresent(String?.self, forKey: .requestId) ?? nil
        self.error = try decoderContainer.decodeIfPresent(ServiceError?.self, forKey: .error) ?? nil
        self.result = try decoderContainer.decodeIfPresent(SetAccesskeyConfigResult?.self, forKey: .result) ?? nil
    }
}

public extension SetAccesskeyConfigResponse{
        func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: SetAccesskeyConfigResponseCodingKeys.self)
        try encoderContainer.encode(requestId, forKey: .requestId)
        try encoderContainer.encode(error, forKey: .error)
        try encoderContainer.encode(result, forKey: .result)
    }
}    
/// 查询ip黑名单 
public class QueryIpBlackListResult:NSObject,JdCloudResult
{
    /// 域名
    var domain:String?

    /// 黑名单列表
    var ips:[AnyObject?]?

    /// 黑名单状态,on:开启,off:关闭
    var status:String?



    public override init(){
        super.init()
    }

    enum QueryIpBlackListResultCodingKeys: String, CodingKey {
        case domain
        case ips
        case status
    }

    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: QueryIpBlackListResultCodingKeys.self)
        if decoderContainer.contains(.domain)
        {
            self.domain = try decoderContainer.decode(String?.self, forKey: .domain)
        }
        if decoderContainer.contains(.status)
        {
            self.status = try decoderContainer.decode(String?.self, forKey: .status)
        }
    }
}
public extension QueryIpBlackListResult{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: QueryIpBlackListResultCodingKeys.self)
        try encoderContainer.encode(domain, forKey: .domain)
        try encoderContainer.encode(status, forKey: .status)
    }
}
public class SetVideoDraftResponse:NSObject,Codable
{
    var requestId:String?;

    var error:ServiceError?;

    var result:SetVideoDraftResult?;

    enum SetVideoDraftResponseCodingKeys: String, CodingKey {
        case requestId
        case error
        case result
    }

    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: SetVideoDraftResponseCodingKeys.self)
        self.requestId = try decoderContainer.decodeIfPresent(String?.self, forKey: .requestId) ?? nil
        self.error = try decoderContainer.decodeIfPresent(ServiceError?.self, forKey: .error) ?? nil
        self.result = try decoderContainer.decodeIfPresent(SetVideoDraftResult?.self, forKey: .result) ?? nil
    }
}

public extension SetVideoDraftResponse{
        func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: SetVideoDraftResponseCodingKeys.self)
        try encoderContainer.encode(requestId, forKey: .requestId)
        try encoderContainer.encode(error, forKey: .error)
        try encoderContainer.encode(result, forKey: .result)
    }
}    
public class SetFollowRedirectResponse:NSObject,Codable
{
    var requestId:String?;

    var error:ServiceError?;

    var result:SetFollowRedirectResult?;

    enum SetFollowRedirectResponseCodingKeys: String, CodingKey {
        case requestId
        case error
        case result
    }

    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: SetFollowRedirectResponseCodingKeys.self)
        self.requestId = try decoderContainer.decodeIfPresent(String?.self, forKey: .requestId) ?? nil
        self.error = try decoderContainer.decodeIfPresent(ServiceError?.self, forKey: .error) ?? nil
        self.result = try decoderContainer.decodeIfPresent(SetFollowRedirectResult?.self, forKey: .result) ?? nil
    }
}

public extension SetFollowRedirectResponse{
        func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: SetFollowRedirectResponseCodingKeys.self)
        try encoderContainer.encode(requestId, forKey: .requestId)
        try encoderContainer.encode(error, forKey: .error)
        try encoderContainer.encode(result, forKey: .result)
    }
}    
public class QueryFollowSourceProtocolResponse:NSObject,Codable
{
    var requestId:String?;

    var error:ServiceError?;

    var result:QueryFollowSourceProtocolResult?;

    enum QueryFollowSourceProtocolResponseCodingKeys: String, CodingKey {
        case requestId
        case error
        case result
    }

    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: QueryFollowSourceProtocolResponseCodingKeys.self)
        self.requestId = try decoderContainer.decodeIfPresent(String?.self, forKey: .requestId) ?? nil
        self.error = try decoderContainer.decodeIfPresent(ServiceError?.self, forKey: .error) ?? nil
        self.result = try decoderContainer.decodeIfPresent(QueryFollowSourceProtocolResult?.self, forKey: .result) ?? nil
    }
}

public extension QueryFollowSourceProtocolResponse{
        func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: QueryFollowSourceProtocolResponseCodingKeys.self)
        try encoderContainer.encode(requestId, forKey: .requestId)
        try encoderContainer.encode(error, forKey: .error)
        try encoderContainer.encode(result, forKey: .result)
    }
}    

///  设置回源302跳转
public class SetFollowRedirectRequest:JdCloudRequest
{
    /// 开关取值[on,off]
    var status:String?

    /// 用户域名
    var domain:String


    public init(regionId: String,domain:String){
        self.domain = domain
        super.init(regionId: regionId)
    }


    enum SetFollowRedirectRequestRequestCodingKeys: String, CodingKey {
        case status
        case domain
    }

    public override func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: SetFollowRedirectRequestRequestCodingKeys.self)
        try encoderContainer.encode(status, forKey: .status)
        try encoderContainer.encode(domain, forKey: .domain)

    }
}

/// 设置http协议 
public class SetHttpTypeResult:NSObject,JdCloudResult
{
    /// 任务taskId
    var taskId:String?



    public override init(){
        super.init()
    }

    enum SetHttpTypeResultCodingKeys: String, CodingKey {
        case taskId
    }

    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: SetHttpTypeResultCodingKeys.self)
        if decoderContainer.contains(.taskId)
        {
            self.taskId = try decoderContainer.decode(String?.self, forKey: .taskId)
        }
    }
}
public extension SetHttpTypeResult{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: SetHttpTypeResultCodingKeys.self)
        try encoderContainer.encode(taskId, forKey: .taskId)
    }
}
public class PreviewCertificateResponse:NSObject,Codable
{
    var requestId:String?;

    var error:ServiceError?;

    var result:PreviewCertificateResult?;

    enum PreviewCertificateResponseCodingKeys: String, CodingKey {
        case requestId
        case error
        case result
    }

    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: PreviewCertificateResponseCodingKeys.self)
        self.requestId = try decoderContainer.decodeIfPresent(String?.self, forKey: .requestId) ?? nil
        self.error = try decoderContainer.decodeIfPresent(ServiceError?.self, forKey: .error) ?? nil
        self.result = try decoderContainer.decodeIfPresent(PreviewCertificateResult?.self, forKey: .result) ?? nil
    }
}

public extension PreviewCertificateResponse{
        func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: PreviewCertificateResponseCodingKeys.self)
        try encoderContainer.encode(requestId, forKey: .requestId)
        try encoderContainer.encode(error, forKey: .error)
        try encoderContainer.encode(result, forKey: .result)
    }
}    
/// 设置userAgent信息 
public class QueryUserAgentResult:NSObject,JdCloudResult
{
    /// Domain
    var domain:String?

    /// userAgent类型,取值：block（黑名单）,allow（白名单）,默认为block
    var userAgentType:String?

    /// UA列表
    var userAgentList:[String?]?

    /// 是否允许空userAgent访问,默认为“on”
    var allowNoUserAgentHeader:String?



    public override init(){
        super.init()
    }

    enum QueryUserAgentResultCodingKeys: String, CodingKey {
        case domain
        case userAgentType
        case userAgentList
        case allowNoUserAgentHeader
    }

    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: QueryUserAgentResultCodingKeys.self)
        if decoderContainer.contains(.domain)
        {
            self.domain = try decoderContainer.decode(String?.self, forKey: .domain)
        }
        if decoderContainer.contains(.userAgentType)
        {
            self.userAgentType = try decoderContainer.decode(String?.self, forKey: .userAgentType)
        }
        if decoderContainer.contains(.userAgentList)
        {
            self.userAgentList = try decoderContainer.decode([String?]?.self, forKey: .userAgentList)
        }
        if decoderContainer.contains(.allowNoUserAgentHeader)
        {
            self.allowNoUserAgentHeader = try decoderContainer.decode(String?.self, forKey: .allowNoUserAgentHeader)
        }
    }
}
public extension QueryUserAgentResult{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: QueryUserAgentResultCodingKeys.self)
        try encoderContainer.encode(domain, forKey: .domain)
        try encoderContainer.encode(userAgentType, forKey: .userAgentType)
        try encoderContainer.encode(userAgentList, forKey: .userAgentList)
        try encoderContainer.encode(allowNoUserAgentHeader, forKey: .allowNoUserAgentHeader)
    }
}
/// 查询源站监控信息 
public class QueryMonitorResult:NSObject,JdCloudResult
{
    /// 域名
    var domain:String?

    /// 探测周期，单位分钟
    var cycle:Int32?

    /// 探测路径
    var monitorPath:String?

    /// 查询结果,类型为HashMap&lt;String, Object&gt;
    var httpRequestHeader:[String:String?]?



    public override init(){
        super.init()
    }

    enum QueryMonitorResultCodingKeys: String, CodingKey {
        case domain
        case cycle
        case monitorPath
        case httpRequestHeader
    }

    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: QueryMonitorResultCodingKeys.self)
        if decoderContainer.contains(.domain)
        {
            self.domain = try decoderContainer.decode(String?.self, forKey: .domain)
        }
        if decoderContainer.contains(.cycle)
        {
            self.cycle = try decoderContainer.decode(Int32?.self, forKey: .cycle)
        }
        if decoderContainer.contains(.monitorPath)
        {
            self.monitorPath = try decoderContainer.decode(String?.self, forKey: .monitorPath)
        }
        if decoderContainer.contains(.httpRequestHeader)
        {
            self.httpRequestHeader = try decoderContainer.decode([String:String?]?.self, forKey: .httpRequestHeader)
        }
    }
}
public extension QueryMonitorResult{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: QueryMonitorResultCodingKeys.self)
        try encoderContainer.encode(domain, forKey: .domain)
        try encoderContainer.encode(cycle, forKey: .cycle)
        try encoderContainer.encode(monitorPath, forKey: .monitorPath)
        try encoderContainer.encode(httpRequestHeader, forKey: .httpRequestHeader)
    }
}

///  查询geo地域
public class QueryGeoAreasRequest:JdCloudRequest
{
}

public class SetNetProtectionRulesResponse:NSObject,Codable
{
    var requestId:String?;

    var error:ServiceError?;

    var result:SetNetProtectionRulesResult?;

    enum SetNetProtectionRulesResponseCodingKeys: String, CodingKey {
        case requestId
        case error
        case result
    }

    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: SetNetProtectionRulesResponseCodingKeys.self)
        self.requestId = try decoderContainer.decodeIfPresent(String?.self, forKey: .requestId) ?? nil
        self.error = try decoderContainer.decodeIfPresent(ServiceError?.self, forKey: .error) ?? nil
        self.result = try decoderContainer.decodeIfPresent(SetNetProtectionRulesResult?.self, forKey: .result) ?? nil
    }
}

public extension SetNetProtectionRulesResponse{
        func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: SetNetProtectionRulesResponseCodingKeys.self)
        try encoderContainer.encode(requestId, forKey: .requestId)
        try encoderContainer.encode(error, forKey: .error)
        try encoderContainer.encode(result, forKey: .result)
    }
}    
public class SearchAttackLogResponse:NSObject,Codable
{
    var requestId:String?;

    var error:ServiceError?;

    var result:SearchAttackLogResult?;

    enum SearchAttackLogResponseCodingKeys: String, CodingKey {
        case requestId
        case error
        case result
    }

    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: SearchAttackLogResponseCodingKeys.self)
        self.requestId = try decoderContainer.decodeIfPresent(String?.self, forKey: .requestId) ?? nil
        self.error = try decoderContainer.decodeIfPresent(ServiceError?.self, forKey: .error) ?? nil
        self.result = try decoderContainer.decodeIfPresent(SearchAttackLogResult?.self, forKey: .result) ?? nil
    }
}

public extension SearchAttackLogResponse{
        func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: SearchAttackLogResponseCodingKeys.self)
        try encoderContainer.encode(requestId, forKey: .requestId)
        try encoderContainer.encode(error, forKey: .error)
        try encoderContainer.encode(result, forKey: .result)
    }
}    

///  设置网络防护层规则总开关
public class SetNetProtectionRulesSwitchRequest:JdCloudRequest
{
    /// on,off
    var switchStatus:String?




    enum SetNetProtectionRulesSwitchRequestRequestCodingKeys: String, CodingKey {
        case switchStatus
    }

    public override func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: SetNetProtectionRulesSwitchRequestRequestCodingKeys.self)
        try encoderContainer.encode(switchStatus, forKey: .switchStatus)

    }
}

/// 设置网络防护层规则总开关 
public class SetNetProtectionRulesSwitchResult:NSObject,JdCloudResult
{
}

///  查询网络防护层规则
public class QueryNetProtectionRulesSwitchRequest:JdCloudRequest
{
}

/// 攻击类型统计接口 
public class QueryAttackTypeCountResult:NSObject,JdCloudResult
{
    /// AttackTypeCounts
    var attackTypeCounts:[AttackTypeCount?]?



    public override init(){
        super.init()
    }

    enum QueryAttackTypeCountResultCodingKeys: String, CodingKey {
        case attackTypeCounts
    }

    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: QueryAttackTypeCountResultCodingKeys.self)
        if decoderContainer.contains(.attackTypeCounts)
        {
            self.attackTypeCounts = try decoderContainer.decode([AttackTypeCount?]?.self, forKey: .attackTypeCounts)
        }
    }
}
public extension QueryAttackTypeCountResult{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: QueryAttackTypeCountResultCodingKeys.self)
        try encoderContainer.encode(attackTypeCounts, forKey: .attackTypeCounts)
    }
}

///  设置网络防护层规则
public class SetNetProtectionRulesRequest:JdCloudRequest
{
    /// 源新建连接限速，取值on,off，其中on开启，off关闭
    var srcNewConnLimitEnable:String?

    /// 目的新建连接，取值on,off，其中on开启，off关闭
    var dstNewConnLimitEnable:String?

    /// 报文最小长度（包最小长度）,取值：1-1500
    var datagramRangeMin:Int64?

    /// 报文最大长度（包最大长度）,取值：1-1500
    var datagramRangeMax:Int64?

    /// 目的新建连接限速值，取值：0-4294967295
    var dstNewConnLimitValue:Int64?

    /// 源新建连接限速值，取值：0-4294967295
    var srcNewConnLimitValue:Int64?

    /// 地域黑名单（GEO IP拦截）
    var geoBlack:[String?]?

    /// ip 黑名单
    var ipBlack:[String?]?

    /// ip 白名单
    var ipWhite:[String?]?




    enum SetNetProtectionRulesRequestRequestCodingKeys: String, CodingKey {
        case srcNewConnLimitEnable
        case dstNewConnLimitEnable
        case datagramRangeMin
        case datagramRangeMax
        case dstNewConnLimitValue
        case srcNewConnLimitValue
        case geoBlack
        case ipBlack
        case ipWhite
    }

    public override func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: SetNetProtectionRulesRequestRequestCodingKeys.self)
        try encoderContainer.encode(srcNewConnLimitEnable, forKey: .srcNewConnLimitEnable)
        try encoderContainer.encode(dstNewConnLimitEnable, forKey: .dstNewConnLimitEnable)
        try encoderContainer.encode(datagramRangeMin, forKey: .datagramRangeMin)
        try encoderContainer.encode(datagramRangeMax, forKey: .datagramRangeMax)
        try encoderContainer.encode(dstNewConnLimitValue, forKey: .dstNewConnLimitValue)
        try encoderContainer.encode(srcNewConnLimitValue, forKey: .srcNewConnLimitValue)
        try encoderContainer.encode(geoBlack, forKey: .geoBlack)
        try encoderContainer.encode(ipBlack, forKey: .ipBlack)
        try encoderContainer.encode(ipWhite, forKey: .ipWhite)

    }
}

/// 查询网络防护层规则 
public class QueryNetProtectionRulesSwitchResult:NSObject,JdCloudResult
{
    /// on:开启,off:关闭
    var switchStatus:String?



    public override init(){
        super.init()
    }

    enum QueryNetProtectionRulesSwitchResultCodingKeys: String, CodingKey {
        case switchStatus
    }

    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: QueryNetProtectionRulesSwitchResultCodingKeys.self)
        if decoderContainer.contains(.switchStatus)
        {
            self.switchStatus = try decoderContainer.decode(String?.self, forKey: .switchStatus)
        }
    }
}
public extension QueryNetProtectionRulesSwitchResult{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: QueryNetProtectionRulesSwitchResultCodingKeys.self)
        try encoderContainer.encode(switchStatus, forKey: .switchStatus)
    }
}

///  查询网络防护层规则接口
public class QueryNetProtectionRulesRequest:JdCloudRequest
{
}

public class SetNetProtectionRulesSwitchResponse:NSObject,Codable
{
    var requestId:String?;

    var error:ServiceError?;

    var result:SetNetProtectionRulesSwitchResult?;

    enum SetNetProtectionRulesSwitchResponseCodingKeys: String, CodingKey {
        case requestId
        case error
        case result
    }

    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: SetNetProtectionRulesSwitchResponseCodingKeys.self)
        self.requestId = try decoderContainer.decodeIfPresent(String?.self, forKey: .requestId) ?? nil
        self.error = try decoderContainer.decodeIfPresent(ServiceError?.self, forKey: .error) ?? nil
        self.result = try decoderContainer.decodeIfPresent(SetNetProtectionRulesSwitchResult?.self, forKey: .result) ?? nil
    }
}

public extension SetNetProtectionRulesSwitchResponse{
        func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: SetNetProtectionRulesSwitchResponseCodingKeys.self)
        try encoderContainer.encode(requestId, forKey: .requestId)
        try encoderContainer.encode(error, forKey: .error)
        try encoderContainer.encode(result, forKey: .result)
    }
}    

///  攻击类型统计接口
public class QueryAttackTypeCountRequest:JdCloudRequest
{
    /// 查询起始时间,UTC时间，格式为:yyyy-MM-dd&#39;T&#39;HH:mm:ss&#39;Z&#39;，示例:2019-08-16T06:00:00Z
    var startTime:String?

    /// 查询截止时间,UTC时间，格式为:yyyy-MM-dd&#39;T&#39;HH:mm:ss&#39;Z&#39;，示例:2019-08-16T07:00:00Z
    var endTime:String?




    enum QueryAttackTypeCountRequestRequestCodingKeys: String, CodingKey {
        case startTime
        case endTime
    }

    public override func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: QueryAttackTypeCountRequestRequestCodingKeys.self)
        try encoderContainer.encode(startTime, forKey: .startTime)
        try encoderContainer.encode(endTime, forKey: .endTime)

    }
}

public class QueryAttackTypeCountResponse:NSObject,Codable
{
    var requestId:String?;

    var error:ServiceError?;

    var result:QueryAttackTypeCountResult?;

    enum QueryAttackTypeCountResponseCodingKeys: String, CodingKey {
        case requestId
        case error
        case result
    }

    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: QueryAttackTypeCountResponseCodingKeys.self)
        self.requestId = try decoderContainer.decodeIfPresent(String?.self, forKey: .requestId) ?? nil
        self.error = try decoderContainer.decodeIfPresent(ServiceError?.self, forKey: .error) ?? nil
        self.result = try decoderContainer.decodeIfPresent(QueryAttackTypeCountResult?.self, forKey: .result) ?? nil
    }
}

public extension QueryAttackTypeCountResponse{
        func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: QueryAttackTypeCountResponseCodingKeys.self)
        try encoderContainer.encode(requestId, forKey: .requestId)
        try encoderContainer.encode(error, forKey: .error)
        try encoderContainer.encode(result, forKey: .result)
    }
}    
/// 查询geo地域 
public class QueryGeoAreasResult:NSObject,JdCloudResult
{
    /// 地域黑名单（GEO IP拦截）
    var geoBlack:[GeoArea?]?



    public override init(){
        super.init()
    }

    enum QueryGeoAreasResultCodingKeys: String, CodingKey {
        case geoBlack
    }

    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: QueryGeoAreasResultCodingKeys.self)
        if decoderContainer.contains(.geoBlack)
        {
            self.geoBlack = try decoderContainer.decode([GeoArea?]?.self, forKey: .geoBlack)
        }
    }
}
public extension QueryGeoAreasResult{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: QueryGeoAreasResultCodingKeys.self)
        try encoderContainer.encode(geoBlack, forKey: .geoBlack)
    }
}
public class QueryNetProtectionRulesResponse:NSObject,Codable
{
    var requestId:String?;

    var error:ServiceError?;

    var result:QueryNetProtectionRulesResult?;

    enum QueryNetProtectionRulesResponseCodingKeys: String, CodingKey {
        case requestId
        case error
        case result
    }

    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: QueryNetProtectionRulesResponseCodingKeys.self)
        self.requestId = try decoderContainer.decodeIfPresent(String?.self, forKey: .requestId) ?? nil
        self.error = try decoderContainer.decodeIfPresent(ServiceError?.self, forKey: .error) ?? nil
        self.result = try decoderContainer.decodeIfPresent(QueryNetProtectionRulesResult?.self, forKey: .result) ?? nil
    }
}

public extension QueryNetProtectionRulesResponse{
        func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: QueryNetProtectionRulesResponseCodingKeys.self)
        try encoderContainer.encode(requestId, forKey: .requestId)
        try encoderContainer.encode(error, forKey: .error)
        try encoderContainer.encode(result, forKey: .result)
    }
}    
/// 攻击记录查询 
public class SearchAttackLogResult:NSObject,JdCloudResult
{
    /// 记录数
    var currentCount:Int32?

    /// DataList
    var dataList:[AttackLogRecord?]?

    /// 总记录数
    var totalCount:Int32?

    /// 总页数
    var totalPage:Int32?



    public override init(){
        super.init()
    }

    enum SearchAttackLogResultCodingKeys: String, CodingKey {
        case currentCount
        case dataList
        case totalCount
        case totalPage
    }

    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: SearchAttackLogResultCodingKeys.self)
        if decoderContainer.contains(.currentCount)
        {
            self.currentCount = try decoderContainer.decode(Int32?.self, forKey: .currentCount)
        }
        if decoderContainer.contains(.dataList)
        {
            self.dataList = try decoderContainer.decode([AttackLogRecord?]?.self, forKey: .dataList)
        }
        if decoderContainer.contains(.totalCount)
        {
            self.totalCount = try decoderContainer.decode(Int32?.self, forKey: .totalCount)
        }
        if decoderContainer.contains(.totalPage)
        {
            self.totalPage = try decoderContainer.decode(Int32?.self, forKey: .totalPage)
        }
    }
}
public extension SearchAttackLogResult{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: SearchAttackLogResultCodingKeys.self)
        try encoderContainer.encode(currentCount, forKey: .currentCount)
        try encoderContainer.encode(dataList, forKey: .dataList)
        try encoderContainer.encode(totalCount, forKey: .totalCount)
        try encoderContainer.encode(totalPage, forKey: .totalPage)
    }
}
/// 查询网络防护层规则接口 
public class QueryNetProtectionRulesResult:NSObject,JdCloudResult
{
    /// 网络防护层总开关，取值on,off，其中on开启，off关闭
    var switchStatus:String?

    /// 源新建连接限速，取值on,off，其中on开启，off关闭
    var srcNewConnLimitEnable:String?

    /// 目的新建连接，取值on,off，其中on开启，off关闭
    var dstNewConnLimitEnable:String?

    /// 报文最小长度（包最小长度）,取值：1-1500
    var datagramRangeMin:Int64?

    /// 报文最大长度（包最大长度）,取值：1-1500
    var datagramRangeMax:Int64?

    /// 源新建连接限速值，取值：0-4294967295
    var srcNewConnLimitValue:Int64?

    /// 目的新建连接限速值，取值：0-4294967295
    var dstNewConnLimitValue:Int64?

    /// 地域黑名单（GEO IP拦截）
    var geoBlack:[GeoArea?]?

    /// ip 黑名单
    var ipBlack:[String?]?

    /// ip 白名单
    var ipWhite:[String?]?



    public override init(){
        super.init()
    }

    enum QueryNetProtectionRulesResultCodingKeys: String, CodingKey {
        case switchStatus
        case srcNewConnLimitEnable
        case dstNewConnLimitEnable
        case datagramRangeMin
        case datagramRangeMax
        case srcNewConnLimitValue
        case dstNewConnLimitValue
        case geoBlack
        case ipBlack
        case ipWhite
    }

    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: QueryNetProtectionRulesResultCodingKeys.self)
        if decoderContainer.contains(.switchStatus)
        {
            self.switchStatus = try decoderContainer.decode(String?.self, forKey: .switchStatus)
        }
        if decoderContainer.contains(.srcNewConnLimitEnable)
        {
            self.srcNewConnLimitEnable = try decoderContainer.decode(String?.self, forKey: .srcNewConnLimitEnable)
        }
        if decoderContainer.contains(.dstNewConnLimitEnable)
        {
            self.dstNewConnLimitEnable = try decoderContainer.decode(String?.self, forKey: .dstNewConnLimitEnable)
        }
        if decoderContainer.contains(.datagramRangeMin)
        {
            self.datagramRangeMin = try decoderContainer.decode(Int64?.self, forKey: .datagramRangeMin)
        }
        if decoderContainer.contains(.datagramRangeMax)
        {
            self.datagramRangeMax = try decoderContainer.decode(Int64?.self, forKey: .datagramRangeMax)
        }
        if decoderContainer.contains(.srcNewConnLimitValue)
        {
            self.srcNewConnLimitValue = try decoderContainer.decode(Int64?.self, forKey: .srcNewConnLimitValue)
        }
        if decoderContainer.contains(.dstNewConnLimitValue)
        {
            self.dstNewConnLimitValue = try decoderContainer.decode(Int64?.self, forKey: .dstNewConnLimitValue)
        }
        if decoderContainer.contains(.geoBlack)
        {
            self.geoBlack = try decoderContainer.decode([GeoArea?]?.self, forKey: .geoBlack)
        }
        if decoderContainer.contains(.ipBlack)
        {
            self.ipBlack = try decoderContainer.decode([String?]?.self, forKey: .ipBlack)
        }
        if decoderContainer.contains(.ipWhite)
        {
            self.ipWhite = try decoderContainer.decode([String?]?.self, forKey: .ipWhite)
        }
    }
}
public extension QueryNetProtectionRulesResult{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: QueryNetProtectionRulesResultCodingKeys.self)
        try encoderContainer.encode(switchStatus, forKey: .switchStatus)
        try encoderContainer.encode(srcNewConnLimitEnable, forKey: .srcNewConnLimitEnable)
        try encoderContainer.encode(dstNewConnLimitEnable, forKey: .dstNewConnLimitEnable)
        try encoderContainer.encode(datagramRangeMin, forKey: .datagramRangeMin)
        try encoderContainer.encode(datagramRangeMax, forKey: .datagramRangeMax)
        try encoderContainer.encode(srcNewConnLimitValue, forKey: .srcNewConnLimitValue)
        try encoderContainer.encode(dstNewConnLimitValue, forKey: .dstNewConnLimitValue)
        try encoderContainer.encode(geoBlack, forKey: .geoBlack)
        try encoderContainer.encode(ipBlack, forKey: .ipBlack)
        try encoderContainer.encode(ipWhite, forKey: .ipWhite)
    }
}
/// DDOS攻击报表接口 
public class QueryDdosGraphResult:NSObject,JdCloudResult
{
    /// 流量数据
    var dataList:[ProtectData?]?

    /// 流量单位
    var unit:[String?]?



    public override init(){
        super.init()
    }

    enum QueryDdosGraphResultCodingKeys: String, CodingKey {
        case dataList
        case unit
    }

    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: QueryDdosGraphResultCodingKeys.self)
        if decoderContainer.contains(.dataList)
        {
            self.dataList = try decoderContainer.decode([ProtectData?]?.self, forKey: .dataList)
        }
        if decoderContainer.contains(.unit)
        {
            self.unit = try decoderContainer.decode([String?]?.self, forKey: .unit)
        }
    }
}
public extension QueryDdosGraphResult{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: QueryDdosGraphResultCodingKeys.self)
        try encoderContainer.encode(dataList, forKey: .dataList)
        try encoderContainer.encode(unit, forKey: .unit)
    }
}
public class QueryDdosGraphResponse:NSObject,Codable
{
    var requestId:String?;

    var error:ServiceError?;

    var result:QueryDdosGraphResult?;

    enum QueryDdosGraphResponseCodingKeys: String, CodingKey {
        case requestId
        case error
        case result
    }

    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: QueryDdosGraphResponseCodingKeys.self)
        self.requestId = try decoderContainer.decodeIfPresent(String?.self, forKey: .requestId) ?? nil
        self.error = try decoderContainer.decodeIfPresent(ServiceError?.self, forKey: .error) ?? nil
        self.result = try decoderContainer.decodeIfPresent(QueryDdosGraphResult?.self, forKey: .result) ?? nil
    }
}

public extension QueryDdosGraphResponse{
        func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: QueryDdosGraphResponseCodingKeys.self)
        try encoderContainer.encode(requestId, forKey: .requestId)
        try encoderContainer.encode(error, forKey: .error)
        try encoderContainer.encode(result, forKey: .result)
    }
}    

///  攻击记录查询
public class SearchAttackLogRequest:JdCloudRequest
{
    /// 查询起始时间,UTC时间，格式为:yyyy-MM-dd&#39;T&#39;HH:mm:ss&#39;Z&#39;，示例:2019-08-16T06:00:00Z
    var startTime:String?

    /// 查询截止时间,UTC时间，格式为:yyyy-MM-dd&#39;T&#39;HH:mm:ss&#39;Z&#39;，示例:2019-08-16T07:00:00Z
    var endTime:String?

    /// 页码
    var pageNumber:Int32?

    /// 分页条数
    var pageSize:Int32?

    /// 排序字段，默认传avgbandwidth
    var sortField:String?

    /// 排序规则，默认是降序排序，传值asc或者desc
    var sortRule:String?




    enum SearchAttackLogRequestRequestCodingKeys: String, CodingKey {
        case startTime
        case endTime
        case pageNumber
        case pageSize
        case sortField
        case sortRule
    }

    public override func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: SearchAttackLogRequestRequestCodingKeys.self)
        try encoderContainer.encode(startTime, forKey: .startTime)
        try encoderContainer.encode(endTime, forKey: .endTime)
        try encoderContainer.encode(pageNumber, forKey: .pageNumber)
        try encoderContainer.encode(pageSize, forKey: .pageSize)
        try encoderContainer.encode(sortField, forKey: .sortField)
        try encoderContainer.encode(sortRule, forKey: .sortRule)

    }
}

public class QueryNetProtectionRulesSwitchResponse:NSObject,Codable
{
    var requestId:String?;

    var error:ServiceError?;

    var result:QueryNetProtectionRulesSwitchResult?;

    enum QueryNetProtectionRulesSwitchResponseCodingKeys: String, CodingKey {
        case requestId
        case error
        case result
    }

    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: QueryNetProtectionRulesSwitchResponseCodingKeys.self)
        self.requestId = try decoderContainer.decodeIfPresent(String?.self, forKey: .requestId) ?? nil
        self.error = try decoderContainer.decodeIfPresent(ServiceError?.self, forKey: .error) ?? nil
        self.result = try decoderContainer.decodeIfPresent(QueryNetProtectionRulesSwitchResult?.self, forKey: .result) ?? nil
    }
}

public extension QueryNetProtectionRulesSwitchResponse{
        func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: QueryNetProtectionRulesSwitchResponseCodingKeys.self)
        try encoderContainer.encode(requestId, forKey: .requestId)
        try encoderContainer.encode(error, forKey: .error)
        try encoderContainer.encode(result, forKey: .result)
    }
}    
public class QueryGeoAreasResponse:NSObject,Codable
{
    var requestId:String?;

    var error:ServiceError?;

    var result:QueryGeoAreasResult?;

    enum QueryGeoAreasResponseCodingKeys: String, CodingKey {
        case requestId
        case error
        case result
    }

    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: QueryGeoAreasResponseCodingKeys.self)
        self.requestId = try decoderContainer.decodeIfPresent(String?.self, forKey: .requestId) ?? nil
        self.error = try decoderContainer.decodeIfPresent(ServiceError?.self, forKey: .error) ?? nil
        self.result = try decoderContainer.decodeIfPresent(QueryGeoAreasResult?.self, forKey: .result) ?? nil
    }
}

public extension QueryGeoAreasResponse{
        func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: QueryGeoAreasResponseCodingKeys.self)
        try encoderContainer.encode(requestId, forKey: .requestId)
        try encoderContainer.encode(error, forKey: .error)
        try encoderContainer.encode(result, forKey: .result)
    }
}    

///  DDOS攻击报表接口
public class QueryDdosGraphRequest:JdCloudRequest
{
    /// 查询起始时间,UTC时间，格式为:yyyy-MM-dd&#39;T&#39;HH:mm:ss&#39;Z&#39;，示例:2019-08-16T06:00:00Z
    var startTime:String?

    /// 查询截止时间,UTC时间，格式为:yyyy-MM-dd&#39;T&#39;HH:mm:ss&#39;Z&#39;，示例:2019-08-16T07:00:00Z
    var endTime:String?




    enum QueryDdosGraphRequestRequestCodingKeys: String, CodingKey {
        case startTime
        case endTime
    }

    public override func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: QueryDdosGraphRequestRequestCodingKeys.self)
        try encoderContainer.encode(startTime, forKey: .startTime)
        try encoderContainer.encode(endTime, forKey: .endTime)

    }
}

/// 设置网络防护层规则 
public class SetNetProtectionRulesResult:NSObject,JdCloudResult
{
}
public class QueryOnlineBillingTypeResponse:NSObject,Codable
{
    var requestId:String?;

    var error:ServiceError?;

    var result:QueryOnlineBillingTypeResult?;

    enum QueryOnlineBillingTypeResponseCodingKeys: String, CodingKey {
        case requestId
        case error
        case result
    }

    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: QueryOnlineBillingTypeResponseCodingKeys.self)
        self.requestId = try decoderContainer.decodeIfPresent(String?.self, forKey: .requestId) ?? nil
        self.error = try decoderContainer.decodeIfPresent(ServiceError?.self, forKey: .error) ?? nil
        self.result = try decoderContainer.decodeIfPresent(QueryOnlineBillingTypeResult?.self, forKey: .result) ?? nil
    }
}

public extension QueryOnlineBillingTypeResponse{
        func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: QueryOnlineBillingTypeResponseCodingKeys.self)
        try encoderContainer.encode(requestId, forKey: .requestId)
        try encoderContainer.encode(error, forKey: .error)
        try encoderContainer.encode(result, forKey: .result)
    }
}    

///  设置线上计费方式
public class SetOnlineBillingTypeRequest:JdCloudRequest
{
    /// 计费方式,取值[0,1],0:日流量计费,1:日峰值带宽计费.
    var allType:Int32?




    enum SetOnlineBillingTypeRequestRequestCodingKeys: String, CodingKey {
        case allType
    }

    public override func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: SetOnlineBillingTypeRequestRequestCodingKeys.self)
        try encoderContainer.encode(allType, forKey: .allType)

    }
}


///  设置线上计费方式
public class QueryOnlineBillingTypeRequest:JdCloudRequest
{
}

public class SetOnlineBillingTypeResponse:NSObject,Codable
{
    var requestId:String?;

    var error:ServiceError?;

    var result:SetOnlineBillingTypeResult?;

    enum SetOnlineBillingTypeResponseCodingKeys: String, CodingKey {
        case requestId
        case error
        case result
    }

    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: SetOnlineBillingTypeResponseCodingKeys.self)
        self.requestId = try decoderContainer.decodeIfPresent(String?.self, forKey: .requestId) ?? nil
        self.error = try decoderContainer.decodeIfPresent(ServiceError?.self, forKey: .error) ?? nil
        self.result = try decoderContainer.decodeIfPresent(SetOnlineBillingTypeResult?.self, forKey: .result) ?? nil
    }
}

public extension SetOnlineBillingTypeResponse{
        func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: SetOnlineBillingTypeResponseCodingKeys.self)
        try encoderContainer.encode(requestId, forKey: .requestId)
        try encoderContainer.encode(error, forKey: .error)
        try encoderContainer.encode(result, forKey: .result)
    }
}    
/// 设置线上计费方式 
public class SetOnlineBillingTypeResult:NSObject,JdCloudResult
{
}
/// 设置线上计费方式 
public class QueryOnlineBillingTypeResult:NSObject,JdCloudResult
{
    /// 计费方式,取值[0,1],0:日流量计费,1:日峰值带宽计费.
    var allType:Int32?

    /// vip(1:vip客户,0:普通客户)
    var vip:Int32?



    public override init(){
        super.init()
    }

    enum QueryOnlineBillingTypeResultCodingKeys: String, CodingKey {
        case allType
        case vip
    }

    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: QueryOnlineBillingTypeResultCodingKeys.self)
        if decoderContainer.contains(.allType)
        {
            self.allType = try decoderContainer.decode(Int32?.self, forKey: .allType)
        }
        if decoderContainer.contains(.vip)
        {
            self.vip = try decoderContainer.decode(Int32?.self, forKey: .vip)
        }
    }
}
public extension QueryOnlineBillingTypeResult{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: QueryOnlineBillingTypeResultCodingKeys.self)
        try encoderContainer.encode(allType, forKey: .allType)
        try encoderContainer.encode(vip, forKey: .vip)
    }
}

///  查询统计数据
public class QueryMixStatisticsDataRequest:JdCloudRequest
{
    /// 查询起始时间,UTC时间，格式为:yyyy-MM-dd&#39;T&#39;HH:mm:ss&#39;Z&#39;，示例:2018-10-21T10:00:00Z
    var startTime:String?

    /// 查询截止时间,UTC时间，格式为:yyyy-MM-dd&#39;T&#39;HH:mm:ss&#39;Z&#39;，示例:2018-10-21T10:00:00Z
    var endTime:String?

    /// 需要查询的域名, 必须为用户pin下有权限的域名
    var domain:String?

    /// 需要查询的字段
    var fields:String?

    /// Area
    var area:String?

    /// Isp
    var isp:String?

    /// 时间粒度，可选值:[oneMin,fiveMin,followTime],followTime只会返回一个汇总后的数据
    var period:String?

    /// 查询协议，可选值:[http,https,all],传空默认返回全部协议汇总后的数据
    var scheme:String?




    enum QueryMixStatisticsDataRequestRequestCodingKeys: String, CodingKey {
        case startTime
        case endTime
        case domain
        case fields
        case area
        case isp
        case period
        case scheme
    }

    public override func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: QueryMixStatisticsDataRequestRequestCodingKeys.self)
        try encoderContainer.encode(startTime, forKey: .startTime)
        try encoderContainer.encode(endTime, forKey: .endTime)
        try encoderContainer.encode(domain, forKey: .domain)
        try encoderContainer.encode(fields, forKey: .fields)
        try encoderContainer.encode(area, forKey: .area)
        try encoderContainer.encode(isp, forKey: .isp)
        try encoderContainer.encode(period, forKey: .period)
        try encoderContainer.encode(scheme, forKey: .scheme)

    }
}


///  查询统计数据
public class QueryStatisticsDataRequest:JdCloudRequest
{
    /// 查询起始时间,UTC时间，格式为:yyyy-MM-dd&#39;T&#39;HH:mm:ss&#39;Z&#39;，示例:2018-10-21T10:00:00Z
    var startTime:String?

    /// 查询截止时间,UTC时间，格式为:yyyy-MM-dd&#39;T&#39;HH:mm:ss&#39;Z&#39;，示例:2018-10-21T10:00:00Z
    var endTime:String?

    /// 需要查询的域名, 必须为用户pin下有权限的域名
    var domain:String?

    /// 待查询的子域名
    var subDomain:String?

    /// 需要查询的字段
    var fields:String?

    /// Area
    var area:String?

    /// Isp
    var isp:String?

    /// Origin
    var origin:String?

    /// 时间粒度，可选值:[oneMin,fiveMin,followTime],followTime只会返回一个汇总后的数据
    var period:String?




    enum QueryStatisticsDataRequestRequestCodingKeys: String, CodingKey {
        case startTime
        case endTime
        case domain
        case subDomain
        case fields
        case area
        case isp
        case origin
        case period
    }

    public override func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: QueryStatisticsDataRequestRequestCodingKeys.self)
        try encoderContainer.encode(startTime, forKey: .startTime)
        try encoderContainer.encode(endTime, forKey: .endTime)
        try encoderContainer.encode(domain, forKey: .domain)
        try encoderContainer.encode(subDomain, forKey: .subDomain)
        try encoderContainer.encode(fields, forKey: .fields)
        try encoderContainer.encode(area, forKey: .area)
        try encoderContainer.encode(isp, forKey: .isp)
        try encoderContainer.encode(origin, forKey: .origin)
        try encoderContainer.encode(period, forKey: .period)

    }
}

public class QueryStatisticsDataGroupByAreaResponse:NSObject,Codable
{
    var requestId:String?;

    var error:ServiceError?;

    var result:QueryStatisticsDataGroupByAreaResult?;

    enum QueryStatisticsDataGroupByAreaResponseCodingKeys: String, CodingKey {
        case requestId
        case error
        case result
    }

    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: QueryStatisticsDataGroupByAreaResponseCodingKeys.self)
        self.requestId = try decoderContainer.decodeIfPresent(String?.self, forKey: .requestId) ?? nil
        self.error = try decoderContainer.decodeIfPresent(ServiceError?.self, forKey: .error) ?? nil
        self.result = try decoderContainer.decodeIfPresent(QueryStatisticsDataGroupByAreaResult?.self, forKey: .result) ?? nil
    }
}

public extension QueryStatisticsDataGroupByAreaResponse{
        func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: QueryStatisticsDataGroupByAreaResponseCodingKeys.self)
        try encoderContainer.encode(requestId, forKey: .requestId)
        try encoderContainer.encode(error, forKey: .error)
        try encoderContainer.encode(result, forKey: .result)
    }
}    
public class QueryLiveStatisticsAreaDataGroupByResponse:NSObject,Codable
{
    var requestId:String?;

    var error:ServiceError?;

    var result:QueryLiveStatisticsAreaDataGroupByResult?;

    enum QueryLiveStatisticsAreaDataGroupByResponseCodingKeys: String, CodingKey {
        case requestId
        case error
        case result
    }

    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: QueryLiveStatisticsAreaDataGroupByResponseCodingKeys.self)
        self.requestId = try decoderContainer.decodeIfPresent(String?.self, forKey: .requestId) ?? nil
        self.error = try decoderContainer.decodeIfPresent(ServiceError?.self, forKey: .error) ?? nil
        self.result = try decoderContainer.decodeIfPresent(QueryLiveStatisticsAreaDataGroupByResult?.self, forKey: .result) ?? nil
    }
}

public extension QueryLiveStatisticsAreaDataGroupByResponse{
        func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: QueryLiveStatisticsAreaDataGroupByResponseCodingKeys.self)
        try encoderContainer.encode(requestId, forKey: .requestId)
        try encoderContainer.encode(error, forKey: .error)
        try encoderContainer.encode(result, forKey: .result)
    }
}    
/// 批量域名查询日志 
public class QueryDomainsLogResult:NSObject,JdCloudResult
{
    /// Logs
    var logs:[DomainsLog?]?



    public override init(){
        super.init()
    }

    enum QueryDomainsLogResultCodingKeys: String, CodingKey {
        case logs
    }

    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: QueryDomainsLogResultCodingKeys.self)
        if decoderContainer.contains(.logs)
        {
            self.logs = try decoderContainer.decode([DomainsLog?]?.self, forKey: .logs)
        }
    }
}
public extension QueryDomainsLogResult{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: QueryDomainsLogResultCodingKeys.self)
        try encoderContainer.encode(logs, forKey: .logs)
    }
}
/// 查询TOP IP 
public class QueryStatisticsTopIpResult:NSObject,JdCloudResult
{
    /// StartTime
    var startTime:String?

    /// EndTime
    var endTime:String?

    /// Domain
    var domain:String?

    /// IpData
    var ipData:[StatisticsTopIpData?]?



    public override init(){
        super.init()
    }

    enum QueryStatisticsTopIpResultCodingKeys: String, CodingKey {
        case startTime
        case endTime
        case domain
        case ipData
    }

    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: QueryStatisticsTopIpResultCodingKeys.self)
        if decoderContainer.contains(.startTime)
        {
            self.startTime = try decoderContainer.decode(String?.self, forKey: .startTime)
        }
        if decoderContainer.contains(.endTime)
        {
            self.endTime = try decoderContainer.decode(String?.self, forKey: .endTime)
        }
        if decoderContainer.contains(.domain)
        {
            self.domain = try decoderContainer.decode(String?.self, forKey: .domain)
        }
        if decoderContainer.contains(.ipData)
        {
            self.ipData = try decoderContainer.decode([StatisticsTopIpData?]?.self, forKey: .ipData)
        }
    }
}
public extension QueryStatisticsTopIpResult{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: QueryStatisticsTopIpResultCodingKeys.self)
        try encoderContainer.encode(startTime, forKey: .startTime)
        try encoderContainer.encode(endTime, forKey: .endTime)
        try encoderContainer.encode(domain, forKey: .domain)
        try encoderContainer.encode(ipData, forKey: .ipData)
    }
}

///  分地区及运营商查询统计数据
public class QueryLiveStatisticsAreaDataGroupByRequest:JdCloudRequest
{
    /// 查询起始时间,UTC时间，格式为:yyyy-MM-dd&#39;T&#39;HH:mm:ss&#39;Z&#39;，示例:2018-10-21T10:00:00Z
    var startTime:String?

    /// 查询截止时间,UTC时间，格式为:yyyy-MM-dd&#39;T&#39;HH:mm:ss&#39;Z&#39;，示例:2018-10-21T10:00:00Z
    var endTime:String?

    /// 需要查询的域名, 必须为用户pin下有权限的域名
    var domain:String?

    /// app名
    var appName:String?

    /// 需要查询的字段
    var fields:String?

    /// Area
    var area:String?

    /// Isp
    var isp:String?

    /// StreamName
    var streamName:String?

    /// 时间粒度，可选值:[oneMin,fiveMin,followTime],followTime只会返回一个汇总后的数据
    var period:String?

    /// 分组依据
    var groupBy:String?

    /// SubDomain
    var subDomain:String?

    /// 查询的流协议
    var scheme:String?

    /// ReqMethod
    var reqMethod:String?




    enum QueryLiveStatisticsAreaDataGroupByRequestRequestCodingKeys: String, CodingKey {
        case startTime
        case endTime
        case domain
        case appName
        case fields
        case area
        case isp
        case streamName
        case period
        case groupBy
        case subDomain
        case scheme
        case reqMethod
    }

    public override func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: QueryLiveStatisticsAreaDataGroupByRequestRequestCodingKeys.self)
        try encoderContainer.encode(startTime, forKey: .startTime)
        try encoderContainer.encode(endTime, forKey: .endTime)
        try encoderContainer.encode(domain, forKey: .domain)
        try encoderContainer.encode(appName, forKey: .appName)
        try encoderContainer.encode(fields, forKey: .fields)
        try encoderContainer.encode(area, forKey: .area)
        try encoderContainer.encode(isp, forKey: .isp)
        try encoderContainer.encode(streamName, forKey: .streamName)
        try encoderContainer.encode(period, forKey: .period)
        try encoderContainer.encode(groupBy, forKey: .groupBy)
        try encoderContainer.encode(subDomain, forKey: .subDomain)
        try encoderContainer.encode(scheme, forKey: .scheme)
        try encoderContainer.encode(reqMethod, forKey: .reqMethod)

    }
}


///  查询统计数据并进行汇总加和
public class QueryStatisticsDataGroupSumRequest:JdCloudRequest
{
    /// 查询起始时间,UTC时间，格式为:yyyy-MM-dd&#39;T&#39;HH:mm:ss&#39;Z&#39;，示例:2018-10-21T10:00:00Z
    var startTime:String?

    /// 查询截止时间,UTC时间，格式为:yyyy-MM-dd&#39;T&#39;HH:mm:ss&#39;Z&#39;，示例:2018-10-21T10:00:00Z
    var endTime:String?

    /// 需要查询的域名, 必须为用户pin下有权限的域名
    var domain:String?

    /// 待查询的子域名
    var subDomain:String?

    /// 需要查询的字段
    var fields:String?

    /// Area
    var area:String?

    /// Isp
    var isp:String?

    /// Origin
    var origin:String?

    /// 时间粒度，可选值:[oneMin,fiveMin,followTime],followTime只会返回一个汇总后的数据
    var period:String?

    /// 分组依据
    var groupBy:String?




    enum QueryStatisticsDataGroupSumRequestRequestCodingKeys: String, CodingKey {
        case startTime
        case endTime
        case domain
        case subDomain
        case fields
        case area
        case isp
        case origin
        case period
        case groupBy
    }

    public override func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: QueryStatisticsDataGroupSumRequestRequestCodingKeys.self)
        try encoderContainer.encode(startTime, forKey: .startTime)
        try encoderContainer.encode(endTime, forKey: .endTime)
        try encoderContainer.encode(domain, forKey: .domain)
        try encoderContainer.encode(subDomain, forKey: .subDomain)
        try encoderContainer.encode(fields, forKey: .fields)
        try encoderContainer.encode(area, forKey: .area)
        try encoderContainer.encode(isp, forKey: .isp)
        try encoderContainer.encode(origin, forKey: .origin)
        try encoderContainer.encode(period, forKey: .period)
        try encoderContainer.encode(groupBy, forKey: .groupBy)

    }
}


///  分地区及运营商查询统计数据
public class QueryMixStatisticsWithAreaDataRequest:JdCloudRequest
{
    /// 查询起始时间,UTC时间，格式为:yyyy-MM-dd&#39;T&#39;HH:mm:ss&#39;Z&#39;，示例:2018-10-21T10:00:00Z
    var startTime:String?

    /// 查询截止时间,UTC时间，格式为:yyyy-MM-dd&#39;T&#39;HH:mm:ss&#39;Z&#39;，示例:2018-10-21T10:00:00Z
    var endTime:String?

    /// 需要查询的域名, 必须为用户pin下有权限的域名
    var domain:String?

    /// 需要查询的字段
    var fields:String?

    /// Area
    var area:String?

    /// Isp
    var isp:String?

    /// 时间粒度，可选值:[oneMin,fiveMin,followTime],followTime只会返回一个汇总后的数据
    var period:String?




    enum QueryMixStatisticsWithAreaDataRequestRequestCodingKeys: String, CodingKey {
        case startTime
        case endTime
        case domain
        case fields
        case area
        case isp
        case period
    }

    public override func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: QueryMixStatisticsWithAreaDataRequestRequestCodingKeys.self)
        try encoderContainer.encode(startTime, forKey: .startTime)
        try encoderContainer.encode(endTime, forKey: .endTime)
        try encoderContainer.encode(domain, forKey: .domain)
        try encoderContainer.encode(fields, forKey: .fields)
        try encoderContainer.encode(area, forKey: .area)
        try encoderContainer.encode(isp, forKey: .isp)
        try encoderContainer.encode(period, forKey: .period)

    }
}

/// 查询统计数据 
public class QueryStatisticsDataResult:NSObject,JdCloudResult
{
    /// StartTime
    var startTime:String?

    /// EndTime
    var endTime:String?

    /// Domain
    var domain:String?

    /// Statistics
    var statistics:[StatisticsDataItem?]?



    public override init(){
        super.init()
    }

    enum QueryStatisticsDataResultCodingKeys: String, CodingKey {
        case startTime
        case endTime
        case domain
        case statistics
    }

    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: QueryStatisticsDataResultCodingKeys.self)
        if decoderContainer.contains(.startTime)
        {
            self.startTime = try decoderContainer.decode(String?.self, forKey: .startTime)
        }
        if decoderContainer.contains(.endTime)
        {
            self.endTime = try decoderContainer.decode(String?.self, forKey: .endTime)
        }
        if decoderContainer.contains(.domain)
        {
            self.domain = try decoderContainer.decode(String?.self, forKey: .domain)
        }
        if decoderContainer.contains(.statistics)
        {
            self.statistics = try decoderContainer.decode([StatisticsDataItem?]?.self, forKey: .statistics)
        }
    }
}
public extension QueryStatisticsDataResult{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: QueryStatisticsDataResultCodingKeys.self)
        try encoderContainer.encode(startTime, forKey: .startTime)
        try encoderContainer.encode(endTime, forKey: .endTime)
        try encoderContainer.encode(domain, forKey: .domain)
        try encoderContainer.encode(statistics, forKey: .statistics)
    }
}

///  分地区及运营商查询统计数据
public class QueryStatisticsDataGroupByAreaRequest:JdCloudRequest
{
    /// 查询起始时间,UTC时间，格式为:yyyy-MM-dd&#39;T&#39;HH:mm:ss&#39;Z&#39;，示例:2018-10-21T10:00:00Z
    var startTime:String?

    /// 查询截止时间,UTC时间，格式为:yyyy-MM-dd&#39;T&#39;HH:mm:ss&#39;Z&#39;，示例:2018-10-21T10:00:00Z
    var endTime:String?

    /// 需要查询的域名, 必须为用户pin下有权限的域名
    var domain:String?

    /// 待查询的子域名
    var subDomain:String?

    /// 需要查询的字段
    var fields:String?

    /// Area
    var area:String?

    /// Isp
    var isp:String?

    /// Origin
    var origin:String?

    /// 时间粒度，可选值:[oneMin,fiveMin,followTime],followTime只会返回一个汇总后的数据
    var period:String?

    /// 分组依据
    var groupBy:String?

    /// 查询协议，可选值:[http,https,all],传空默认返回全部协议汇总后的数据
    var scheme:String?




    enum QueryStatisticsDataGroupByAreaRequestRequestCodingKeys: String, CodingKey {
        case startTime
        case endTime
        case domain
        case subDomain
        case fields
        case area
        case isp
        case origin
        case period
        case groupBy
        case scheme
    }

    public override func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: QueryStatisticsDataGroupByAreaRequestRequestCodingKeys.self)
        try encoderContainer.encode(startTime, forKey: .startTime)
        try encoderContainer.encode(endTime, forKey: .endTime)
        try encoderContainer.encode(domain, forKey: .domain)
        try encoderContainer.encode(subDomain, forKey: .subDomain)
        try encoderContainer.encode(fields, forKey: .fields)
        try encoderContainer.encode(area, forKey: .area)
        try encoderContainer.encode(isp, forKey: .isp)
        try encoderContainer.encode(origin, forKey: .origin)
        try encoderContainer.encode(period, forKey: .period)
        try encoderContainer.encode(groupBy, forKey: .groupBy)
        try encoderContainer.encode(scheme, forKey: .scheme)

    }
}

public class QueryStatisticsTopUrlResponse:NSObject,Codable
{
    var requestId:String?;

    var error:ServiceError?;

    var result:QueryStatisticsTopUrlResult?;

    enum QueryStatisticsTopUrlResponseCodingKeys: String, CodingKey {
        case requestId
        case error
        case result
    }

    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: QueryStatisticsTopUrlResponseCodingKeys.self)
        self.requestId = try decoderContainer.decodeIfPresent(String?.self, forKey: .requestId) ?? nil
        self.error = try decoderContainer.decodeIfPresent(ServiceError?.self, forKey: .error) ?? nil
        self.result = try decoderContainer.decodeIfPresent(QueryStatisticsTopUrlResult?.self, forKey: .result) ?? nil
    }
}

public extension QueryStatisticsTopUrlResponse{
        func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: QueryStatisticsTopUrlResponseCodingKeys.self)
        try encoderContainer.encode(requestId, forKey: .requestId)
        try encoderContainer.encode(error, forKey: .error)
        try encoderContainer.encode(result, forKey: .result)
    }
}    

///  查询统计数据
public class QueryLiveStatisticsDataRequest:JdCloudRequest
{
    /// 查询起始时间,UTC时间，格式为:yyyy-MM-dd&#39;T&#39;HH:mm:ss&#39;Z&#39;，示例:2018-10-21T10:00:00Z
    var startTime:String?

    /// 查询截止时间,UTC时间，格式为:yyyy-MM-dd&#39;T&#39;HH:mm:ss&#39;Z&#39;，示例:2018-10-21T10:00:00Z
    var endTime:String?

    /// 需要查询的域名, 必须为用户pin下有权限的域名
    var domain:String?

    /// app名
    var appName:String?

    /// 流名
    var streamName:String?

    /// 子域名
    var subDomain:String?

    /// 需要查询的字段
    var fields:String?

    /// Area
    var area:String?

    /// Isp
    var isp:String?

    /// ReqMethod
    var reqMethod:String?

    /// 查询的流协议类型
    var scheme:String?

    /// 时间粒度，可选值:[oneMin,fiveMin,followTime],followTime只会返回一个汇总后的数据
    var period:String?




    enum QueryLiveStatisticsDataRequestRequestCodingKeys: String, CodingKey {
        case startTime
        case endTime
        case domain
        case appName
        case streamName
        case subDomain
        case fields
        case area
        case isp
        case reqMethod
        case scheme
        case period
    }

    public override func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: QueryLiveStatisticsDataRequestRequestCodingKeys.self)
        try encoderContainer.encode(startTime, forKey: .startTime)
        try encoderContainer.encode(endTime, forKey: .endTime)
        try encoderContainer.encode(domain, forKey: .domain)
        try encoderContainer.encode(appName, forKey: .appName)
        try encoderContainer.encode(streamName, forKey: .streamName)
        try encoderContainer.encode(subDomain, forKey: .subDomain)
        try encoderContainer.encode(fields, forKey: .fields)
        try encoderContainer.encode(area, forKey: .area)
        try encoderContainer.encode(isp, forKey: .isp)
        try encoderContainer.encode(reqMethod, forKey: .reqMethod)
        try encoderContainer.encode(scheme, forKey: .scheme)
        try encoderContainer.encode(period, forKey: .period)

    }
}

/// 查询TOP Url 
public class QueryStatisticsTopUrlResult:NSObject,JdCloudResult
{
    /// StartTime
    var startTime:String?

    /// EndTime
    var endTime:String?

    /// Domain
    var domain:String?

    /// UrlData
    var urlData:[StatisticsTopUrlData?]?



    public override init(){
        super.init()
    }

    enum QueryStatisticsTopUrlResultCodingKeys: String, CodingKey {
        case startTime
        case endTime
        case domain
        case urlData
    }

    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: QueryStatisticsTopUrlResultCodingKeys.self)
        if decoderContainer.contains(.startTime)
        {
            self.startTime = try decoderContainer.decode(String?.self, forKey: .startTime)
        }
        if decoderContainer.contains(.endTime)
        {
            self.endTime = try decoderContainer.decode(String?.self, forKey: .endTime)
        }
        if decoderContainer.contains(.domain)
        {
            self.domain = try decoderContainer.decode(String?.self, forKey: .domain)
        }
        if decoderContainer.contains(.urlData)
        {
            self.urlData = try decoderContainer.decode([StatisticsTopUrlData?]?.self, forKey: .urlData)
        }
    }
}
public extension QueryStatisticsTopUrlResult{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: QueryStatisticsTopUrlResultCodingKeys.self)
        try encoderContainer.encode(startTime, forKey: .startTime)
        try encoderContainer.encode(endTime, forKey: .endTime)
        try encoderContainer.encode(domain, forKey: .domain)
        try encoderContainer.encode(urlData, forKey: .urlData)
    }
}
public class QueryStatisticsDataResponse:NSObject,Codable
{
    var requestId:String?;

    var error:ServiceError?;

    var result:QueryStatisticsDataResult?;

    enum QueryStatisticsDataResponseCodingKeys: String, CodingKey {
        case requestId
        case error
        case result
    }

    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: QueryStatisticsDataResponseCodingKeys.self)
        self.requestId = try decoderContainer.decodeIfPresent(String?.self, forKey: .requestId) ?? nil
        self.error = try decoderContainer.decodeIfPresent(ServiceError?.self, forKey: .error) ?? nil
        self.result = try decoderContainer.decodeIfPresent(QueryStatisticsDataResult?.self, forKey: .result) ?? nil
    }
}

public extension QueryStatisticsDataResponse{
        func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: QueryStatisticsDataResponseCodingKeys.self)
        try encoderContainer.encode(requestId, forKey: .requestId)
        try encoderContainer.encode(error, forKey: .error)
        try encoderContainer.encode(result, forKey: .result)
    }
}    
public class QueryLiveTrafficGroupSumResponse:NSObject,Codable
{
    var requestId:String?;

    var error:ServiceError?;

    var result:QueryLiveTrafficGroupSumResult?;

    enum QueryLiveTrafficGroupSumResponseCodingKeys: String, CodingKey {
        case requestId
        case error
        case result
    }

    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: QueryLiveTrafficGroupSumResponseCodingKeys.self)
        self.requestId = try decoderContainer.decodeIfPresent(String?.self, forKey: .requestId) ?? nil
        self.error = try decoderContainer.decodeIfPresent(ServiceError?.self, forKey: .error) ?? nil
        self.result = try decoderContainer.decodeIfPresent(QueryLiveTrafficGroupSumResult?.self, forKey: .result) ?? nil
    }
}

public extension QueryLiveTrafficGroupSumResponse{
        func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: QueryLiveTrafficGroupSumResponseCodingKeys.self)
        try encoderContainer.encode(requestId, forKey: .requestId)
        try encoderContainer.encode(error, forKey: .error)
        try encoderContainer.encode(result, forKey: .result)
    }
}    

///  查询TOP IP
public class QueryStatisticsTopIpRequest:JdCloudRequest
{
    /// 查询起始时间,UTC时间，格式为:yyyy-MM-dd&#39;T&#39;HH:mm:ss&#39;Z&#39;，示例:2018-10-21T10:00:00Z
    var startTime:String?

    /// 查询截止时间,UTC时间，格式为:yyyy-MM-dd&#39;T&#39;HH:mm:ss&#39;Z&#39;，示例:2018-10-21T10:00:00Z
    var endTime:String?

    /// 需要查询的域名, 必须为用户pin下有权限的域名
    var domain:String?

    /// 待查询的子域名
    var subDomain:String?

    /// Size
    var size:Int?

    /// 排序依据
    var topBy:String?




    enum QueryStatisticsTopIpRequestRequestCodingKeys: String, CodingKey {
        case startTime
        case endTime
        case domain
        case subDomain
        case size
        case topBy
    }

    public override func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: QueryStatisticsTopIpRequestRequestCodingKeys.self)
        try encoderContainer.encode(startTime, forKey: .startTime)
        try encoderContainer.encode(endTime, forKey: .endTime)
        try encoderContainer.encode(domain, forKey: .domain)
        try encoderContainer.encode(subDomain, forKey: .subDomain)
        try encoderContainer.encode(size, forKey: .size)
        try encoderContainer.encode(topBy, forKey: .topBy)

    }
}

/// 查询统计数据并进行汇总加和 
public class QueryMixTrafficGroupSumResult:NSObject,JdCloudResult
{
    /// StartTime
    var startTime:String?

    /// EndTime
    var endTime:String?

    /// Domain
    var domain:String?

    /// Statistics
    var statistics:[StatisticsGroupSumDataItem?]?



    public override init(){
        super.init()
    }

    enum QueryMixTrafficGroupSumResultCodingKeys: String, CodingKey {
        case startTime
        case endTime
        case domain
        case statistics
    }

    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: QueryMixTrafficGroupSumResultCodingKeys.self)
        if decoderContainer.contains(.startTime)
        {
            self.startTime = try decoderContainer.decode(String?.self, forKey: .startTime)
        }
        if decoderContainer.contains(.endTime)
        {
            self.endTime = try decoderContainer.decode(String?.self, forKey: .endTime)
        }
        if decoderContainer.contains(.domain)
        {
            self.domain = try decoderContainer.decode(String?.self, forKey: .domain)
        }
        if decoderContainer.contains(.statistics)
        {
            self.statistics = try decoderContainer.decode([StatisticsGroupSumDataItem?]?.self, forKey: .statistics)
        }
    }
}
public extension QueryMixTrafficGroupSumResult{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: QueryMixTrafficGroupSumResultCodingKeys.self)
        try encoderContainer.encode(startTime, forKey: .startTime)
        try encoderContainer.encode(endTime, forKey: .endTime)
        try encoderContainer.encode(domain, forKey: .domain)
        try encoderContainer.encode(statistics, forKey: .statistics)
    }
}

///  查询日志
public class QueryDomainLogRequest:JdCloudRequest
{
    /// 查询起始时间,UTC时间，格式为:yyyy-MM-dd&#39;T&#39;HH:mm:ss&#39;Z&#39;，示例:2018-10-21T10:00:00Z
    var startTime:String?

    /// 查询截止时间,UTC时间，格式为:yyyy-MM-dd&#39;T&#39;HH:mm:ss&#39;Z&#39;，示例:2018-10-21T10:00:00Z
    var endTime:String?

    /// 时间间隔，取值(hour，day，fiveMin)，不传默认小时。
    var interval:String?

    /// 日志类型，取值(log，zip,gz)，不传默认gz。
    var logType:String?

    /// 页面大小，默认值10
    var pageSize:Int32?

    /// 分页页数，默认值1
    var pageNumber:Int32?

    /// 用户域名
    var domain:String


    public init(regionId: String,domain:String){
        self.domain = domain
        super.init(regionId: regionId)
    }


    enum QueryDomainLogRequestRequestCodingKeys: String, CodingKey {
        case startTime
        case endTime
        case interval
        case logType
        case pageSize
        case pageNumber
        case domain
    }

    public override func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: QueryDomainLogRequestRequestCodingKeys.self)
        try encoderContainer.encode(startTime, forKey: .startTime)
        try encoderContainer.encode(endTime, forKey: .endTime)
        try encoderContainer.encode(interval, forKey: .interval)
        try encoderContainer.encode(logType, forKey: .logType)
        try encoderContainer.encode(pageSize, forKey: .pageSize)
        try encoderContainer.encode(pageNumber, forKey: .pageNumber)
        try encoderContainer.encode(domain, forKey: .domain)

    }
}

public class QueryStatisticsTopIpResponse:NSObject,Codable
{
    var requestId:String?;

    var error:ServiceError?;

    var result:QueryStatisticsTopIpResult?;

    enum QueryStatisticsTopIpResponseCodingKeys: String, CodingKey {
        case requestId
        case error
        case result
    }

    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: QueryStatisticsTopIpResponseCodingKeys.self)
        self.requestId = try decoderContainer.decodeIfPresent(String?.self, forKey: .requestId) ?? nil
        self.error = try decoderContainer.decodeIfPresent(ServiceError?.self, forKey: .error) ?? nil
        self.result = try decoderContainer.decodeIfPresent(QueryStatisticsTopIpResult?.self, forKey: .result) ?? nil
    }
}

public extension QueryStatisticsTopIpResponse{
        func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: QueryStatisticsTopIpResponseCodingKeys.self)
        try encoderContainer.encode(requestId, forKey: .requestId)
        try encoderContainer.encode(error, forKey: .error)
        try encoderContainer.encode(result, forKey: .result)
    }
}    
/// 查询统计数据并进行汇总加和 
public class QueryStatisticsDataGroupSumResult:NSObject,JdCloudResult
{
    /// StartTime
    var startTime:String?

    /// EndTime
    var endTime:String?

    /// Domain
    var domain:String?

    /// Statistics
    var statistics:[StatisticsGroupSumDataItem?]?



    public override init(){
        super.init()
    }

    enum QueryStatisticsDataGroupSumResultCodingKeys: String, CodingKey {
        case startTime
        case endTime
        case domain
        case statistics
    }

    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: QueryStatisticsDataGroupSumResultCodingKeys.self)
        if decoderContainer.contains(.startTime)
        {
            self.startTime = try decoderContainer.decode(String?.self, forKey: .startTime)
        }
        if decoderContainer.contains(.endTime)
        {
            self.endTime = try decoderContainer.decode(String?.self, forKey: .endTime)
        }
        if decoderContainer.contains(.domain)
        {
            self.domain = try decoderContainer.decode(String?.self, forKey: .domain)
        }
        if decoderContainer.contains(.statistics)
        {
            self.statistics = try decoderContainer.decode([StatisticsGroupSumDataItem?]?.self, forKey: .statistics)
        }
    }
}
public extension QueryStatisticsDataGroupSumResult{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: QueryStatisticsDataGroupSumResultCodingKeys.self)
        try encoderContainer.encode(startTime, forKey: .startTime)
        try encoderContainer.encode(endTime, forKey: .endTime)
        try encoderContainer.encode(domain, forKey: .domain)
        try encoderContainer.encode(statistics, forKey: .statistics)
    }
}
/// 查询统计数据并进行汇总加和 
public class QueryLiveTrafficGroupSumResult:NSObject,JdCloudResult
{
    /// StartTime
    var startTime:String?

    /// EndTime
    var endTime:String?

    /// Domain
    var domain:String?

    /// Statistics
    var statistics:[StatisticsGroupSumDataItem?]?



    public override init(){
        super.init()
    }

    enum QueryLiveTrafficGroupSumResultCodingKeys: String, CodingKey {
        case startTime
        case endTime
        case domain
        case statistics
    }

    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: QueryLiveTrafficGroupSumResultCodingKeys.self)
        if decoderContainer.contains(.startTime)
        {
            self.startTime = try decoderContainer.decode(String?.self, forKey: .startTime)
        }
        if decoderContainer.contains(.endTime)
        {
            self.endTime = try decoderContainer.decode(String?.self, forKey: .endTime)
        }
        if decoderContainer.contains(.domain)
        {
            self.domain = try decoderContainer.decode(String?.self, forKey: .domain)
        }
        if decoderContainer.contains(.statistics)
        {
            self.statistics = try decoderContainer.decode([StatisticsGroupSumDataItem?]?.self, forKey: .statistics)
        }
    }
}
public extension QueryLiveTrafficGroupSumResult{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: QueryLiveTrafficGroupSumResultCodingKeys.self)
        try encoderContainer.encode(startTime, forKey: .startTime)
        try encoderContainer.encode(endTime, forKey: .endTime)
        try encoderContainer.encode(domain, forKey: .domain)
        try encoderContainer.encode(statistics, forKey: .statistics)
    }
}

///  查询TOP Url
public class QueryStatisticsTopUrlRequest:JdCloudRequest
{
    /// 查询起始时间,UTC时间，格式为:yyyy-MM-dd&#39;T&#39;HH:mm:ss&#39;Z&#39;，示例:2018-10-21T10:00:00Z
    var startTime:String?

    /// 查询截止时间,UTC时间，格式为:yyyy-MM-dd&#39;T&#39;HH:mm:ss&#39;Z&#39;，示例:2018-10-21T10:00:00Z
    var endTime:String?

    /// 需要查询的域名, 必须为用户pin下有权限的域名
    var domain:String?

    /// 待查询的子域名
    var subDomain:String?

    /// Size
    var size:Int?

    /// 排序依据
    var topBy:String?




    enum QueryStatisticsTopUrlRequestRequestCodingKeys: String, CodingKey {
        case startTime
        case endTime
        case domain
        case subDomain
        case size
        case topBy
    }

    public override func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: QueryStatisticsTopUrlRequestRequestCodingKeys.self)
        try encoderContainer.encode(startTime, forKey: .startTime)
        try encoderContainer.encode(endTime, forKey: .endTime)
        try encoderContainer.encode(domain, forKey: .domain)
        try encoderContainer.encode(subDomain, forKey: .subDomain)
        try encoderContainer.encode(size, forKey: .size)
        try encoderContainer.encode(topBy, forKey: .topBy)

    }
}

/// 查询统计数据 
public class QueryLiveStatisticsDataResult:NSObject,JdCloudResult
{
    /// StartTime
    var startTime:String?

    /// EndTime
    var endTime:String?

    /// Domain
    var domain:String?

    /// Statistics
    var statistics:[StatisticsDataItem?]?



    public override init(){
        super.init()
    }

    enum QueryLiveStatisticsDataResultCodingKeys: String, CodingKey {
        case startTime
        case endTime
        case domain
        case statistics
    }

    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: QueryLiveStatisticsDataResultCodingKeys.self)
        if decoderContainer.contains(.startTime)
        {
            self.startTime = try decoderContainer.decode(String?.self, forKey: .startTime)
        }
        if decoderContainer.contains(.endTime)
        {
            self.endTime = try decoderContainer.decode(String?.self, forKey: .endTime)
        }
        if decoderContainer.contains(.domain)
        {
            self.domain = try decoderContainer.decode(String?.self, forKey: .domain)
        }
        if decoderContainer.contains(.statistics)
        {
            self.statistics = try decoderContainer.decode([StatisticsDataItem?]?.self, forKey: .statistics)
        }
    }
}
public extension QueryLiveStatisticsDataResult{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: QueryLiveStatisticsDataResultCodingKeys.self)
        try encoderContainer.encode(startTime, forKey: .startTime)
        try encoderContainer.encode(endTime, forKey: .endTime)
        try encoderContainer.encode(domain, forKey: .domain)
        try encoderContainer.encode(statistics, forKey: .statistics)
    }
}
public class QueryMixStatisticsWithAreaDataResponse:NSObject,Codable
{
    var requestId:String?;

    var error:ServiceError?;

    var result:QueryMixStatisticsWithAreaDataResult?;

    enum QueryMixStatisticsWithAreaDataResponseCodingKeys: String, CodingKey {
        case requestId
        case error
        case result
    }

    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: QueryMixStatisticsWithAreaDataResponseCodingKeys.self)
        self.requestId = try decoderContainer.decodeIfPresent(String?.self, forKey: .requestId) ?? nil
        self.error = try decoderContainer.decodeIfPresent(ServiceError?.self, forKey: .error) ?? nil
        self.result = try decoderContainer.decodeIfPresent(QueryMixStatisticsWithAreaDataResult?.self, forKey: .result) ?? nil
    }
}

public extension QueryMixStatisticsWithAreaDataResponse{
        func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: QueryMixStatisticsWithAreaDataResponseCodingKeys.self)
        try encoderContainer.encode(requestId, forKey: .requestId)
        try encoderContainer.encode(error, forKey: .error)
        try encoderContainer.encode(result, forKey: .result)
    }
}    
/// 查询统计数据 
public class QueryMixStatisticsDataResult:NSObject,JdCloudResult
{
    /// StartTime
    var startTime:String?

    /// EndTime
    var endTime:String?

    /// Domain
    var domain:String?

    /// Statistics
    var statistics:[StatisticsDataItem?]?



    public override init(){
        super.init()
    }

    enum QueryMixStatisticsDataResultCodingKeys: String, CodingKey {
        case startTime
        case endTime
        case domain
        case statistics
    }

    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: QueryMixStatisticsDataResultCodingKeys.self)
        if decoderContainer.contains(.startTime)
        {
            self.startTime = try decoderContainer.decode(String?.self, forKey: .startTime)
        }
        if decoderContainer.contains(.endTime)
        {
            self.endTime = try decoderContainer.decode(String?.self, forKey: .endTime)
        }
        if decoderContainer.contains(.domain)
        {
            self.domain = try decoderContainer.decode(String?.self, forKey: .domain)
        }
        if decoderContainer.contains(.statistics)
        {
            self.statistics = try decoderContainer.decode([StatisticsDataItem?]?.self, forKey: .statistics)
        }
    }
}
public extension QueryMixStatisticsDataResult{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: QueryMixStatisticsDataResultCodingKeys.self)
        try encoderContainer.encode(startTime, forKey: .startTime)
        try encoderContainer.encode(endTime, forKey: .endTime)
        try encoderContainer.encode(domain, forKey: .domain)
        try encoderContainer.encode(statistics, forKey: .statistics)
    }
}
public class QueryDomainsLogResponse:NSObject,Codable
{
    var requestId:String?;

    var error:ServiceError?;

    var result:QueryDomainsLogResult?;

    enum QueryDomainsLogResponseCodingKeys: String, CodingKey {
        case requestId
        case error
        case result
    }

    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: QueryDomainsLogResponseCodingKeys.self)
        self.requestId = try decoderContainer.decodeIfPresent(String?.self, forKey: .requestId) ?? nil
        self.error = try decoderContainer.decodeIfPresent(ServiceError?.self, forKey: .error) ?? nil
        self.result = try decoderContainer.decodeIfPresent(QueryDomainsLogResult?.self, forKey: .result) ?? nil
    }
}

public extension QueryDomainsLogResponse{
        func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: QueryDomainsLogResponseCodingKeys.self)
        try encoderContainer.encode(requestId, forKey: .requestId)
        try encoderContainer.encode(error, forKey: .error)
        try encoderContainer.encode(result, forKey: .result)
    }
}    
/// 分地区及运营商查询统计数据 
public class QueryStatisticsDataGroupByAreaResult:NSObject,JdCloudResult
{
    /// StartTime
    var startTime:String?

    /// EndTime
    var endTime:String?

    /// Domain
    var domain:String?

    /// Statistics
    var statistics:[StatisticsWithAreaGroupDetail?]?



    public override init(){
        super.init()
    }

    enum QueryStatisticsDataGroupByAreaResultCodingKeys: String, CodingKey {
        case startTime
        case endTime
        case domain
        case statistics
    }

    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: QueryStatisticsDataGroupByAreaResultCodingKeys.self)
        if decoderContainer.contains(.startTime)
        {
            self.startTime = try decoderContainer.decode(String?.self, forKey: .startTime)
        }
        if decoderContainer.contains(.endTime)
        {
            self.endTime = try decoderContainer.decode(String?.self, forKey: .endTime)
        }
        if decoderContainer.contains(.domain)
        {
            self.domain = try decoderContainer.decode(String?.self, forKey: .domain)
        }
        if decoderContainer.contains(.statistics)
        {
            self.statistics = try decoderContainer.decode([StatisticsWithAreaGroupDetail?]?.self, forKey: .statistics)
        }
    }
}
public extension QueryStatisticsDataGroupByAreaResult{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: QueryStatisticsDataGroupByAreaResultCodingKeys.self)
        try encoderContainer.encode(startTime, forKey: .startTime)
        try encoderContainer.encode(endTime, forKey: .endTime)
        try encoderContainer.encode(domain, forKey: .domain)
        try encoderContainer.encode(statistics, forKey: .statistics)
    }
}
/// 查询日志 
public class QueryDomainLogResult:NSObject,JdCloudResult
{
    /// 总的数量
    var total:Int32?

    /// 页面大小
    var pageSize:Int32?

    /// 页面页数
    var pageNumber:Int32?

    /// Urls
    var urls:[DomainLog?]?



    public override init(){
        super.init()
    }

    enum QueryDomainLogResultCodingKeys: String, CodingKey {
        case total
        case pageSize
        case pageNumber
        case urls
    }

    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: QueryDomainLogResultCodingKeys.self)
        if decoderContainer.contains(.total)
        {
            self.total = try decoderContainer.decode(Int32?.self, forKey: .total)
        }
        if decoderContainer.contains(.pageSize)
        {
            self.pageSize = try decoderContainer.decode(Int32?.self, forKey: .pageSize)
        }
        if decoderContainer.contains(.pageNumber)
        {
            self.pageNumber = try decoderContainer.decode(Int32?.self, forKey: .pageNumber)
        }
        if decoderContainer.contains(.urls)
        {
            self.urls = try decoderContainer.decode([DomainLog?]?.self, forKey: .urls)
        }
    }
}
public extension QueryDomainLogResult{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: QueryDomainLogResultCodingKeys.self)
        try encoderContainer.encode(total, forKey: .total)
        try encoderContainer.encode(pageSize, forKey: .pageSize)
        try encoderContainer.encode(pageNumber, forKey: .pageNumber)
        try encoderContainer.encode(urls, forKey: .urls)
    }
}
public class QueryStatisticsDataGroupSumResponse:NSObject,Codable
{
    var requestId:String?;

    var error:ServiceError?;

    var result:QueryStatisticsDataGroupSumResult?;

    enum QueryStatisticsDataGroupSumResponseCodingKeys: String, CodingKey {
        case requestId
        case error
        case result
    }

    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: QueryStatisticsDataGroupSumResponseCodingKeys.self)
        self.requestId = try decoderContainer.decodeIfPresent(String?.self, forKey: .requestId) ?? nil
        self.error = try decoderContainer.decodeIfPresent(ServiceError?.self, forKey: .error) ?? nil
        self.result = try decoderContainer.decodeIfPresent(QueryStatisticsDataGroupSumResult?.self, forKey: .result) ?? nil
    }
}

public extension QueryStatisticsDataGroupSumResponse{
        func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: QueryStatisticsDataGroupSumResponseCodingKeys.self)
        try encoderContainer.encode(requestId, forKey: .requestId)
        try encoderContainer.encode(error, forKey: .error)
        try encoderContainer.encode(result, forKey: .result)
    }
}    
/// 分地区及运营商查询统计数据 
public class QueryMixStatisticsWithAreaDataResult:NSObject,JdCloudResult
{
    /// StartTime
    var startTime:String?

    /// EndTime
    var endTime:String?

    /// Domain
    var domain:String?

    /// Statistics
    var statistics:[StatisticsWithAreaGroupDetail?]?



    public override init(){
        super.init()
    }

    enum QueryMixStatisticsWithAreaDataResultCodingKeys: String, CodingKey {
        case startTime
        case endTime
        case domain
        case statistics
    }

    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: QueryMixStatisticsWithAreaDataResultCodingKeys.self)
        if decoderContainer.contains(.startTime)
        {
            self.startTime = try decoderContainer.decode(String?.self, forKey: .startTime)
        }
        if decoderContainer.contains(.endTime)
        {
            self.endTime = try decoderContainer.decode(String?.self, forKey: .endTime)
        }
        if decoderContainer.contains(.domain)
        {
            self.domain = try decoderContainer.decode(String?.self, forKey: .domain)
        }
        if decoderContainer.contains(.statistics)
        {
            self.statistics = try decoderContainer.decode([StatisticsWithAreaGroupDetail?]?.self, forKey: .statistics)
        }
    }
}
public extension QueryMixStatisticsWithAreaDataResult{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: QueryMixStatisticsWithAreaDataResultCodingKeys.self)
        try encoderContainer.encode(startTime, forKey: .startTime)
        try encoderContainer.encode(endTime, forKey: .endTime)
        try encoderContainer.encode(domain, forKey: .domain)
        try encoderContainer.encode(statistics, forKey: .statistics)
    }
}
/// 分地区及运营商查询统计数据 
public class QueryLiveStatisticsAreaDataGroupByResult:NSObject,JdCloudResult
{
    /// StartTime
    var startTime:String?

    /// EndTime
    var endTime:String?

    /// Domain
    var domain:String?

    /// Statistics
    var statistics:[StatisticsWithAreaGroupDetail?]?



    public override init(){
        super.init()
    }

    enum QueryLiveStatisticsAreaDataGroupByResultCodingKeys: String, CodingKey {
        case startTime
        case endTime
        case domain
        case statistics
    }

    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: QueryLiveStatisticsAreaDataGroupByResultCodingKeys.self)
        if decoderContainer.contains(.startTime)
        {
            self.startTime = try decoderContainer.decode(String?.self, forKey: .startTime)
        }
        if decoderContainer.contains(.endTime)
        {
            self.endTime = try decoderContainer.decode(String?.self, forKey: .endTime)
        }
        if decoderContainer.contains(.domain)
        {
            self.domain = try decoderContainer.decode(String?.self, forKey: .domain)
        }
        if decoderContainer.contains(.statistics)
        {
            self.statistics = try decoderContainer.decode([StatisticsWithAreaGroupDetail?]?.self, forKey: .statistics)
        }
    }
}
public extension QueryLiveStatisticsAreaDataGroupByResult{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: QueryLiveStatisticsAreaDataGroupByResultCodingKeys.self)
        try encoderContainer.encode(startTime, forKey: .startTime)
        try encoderContainer.encode(endTime, forKey: .endTime)
        try encoderContainer.encode(domain, forKey: .domain)
        try encoderContainer.encode(statistics, forKey: .statistics)
    }
}
public class QueryDomainLogResponse:NSObject,Codable
{
    var requestId:String?;

    var error:ServiceError?;

    var result:QueryDomainLogResult?;

    enum QueryDomainLogResponseCodingKeys: String, CodingKey {
        case requestId
        case error
        case result
    }

    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: QueryDomainLogResponseCodingKeys.self)
        self.requestId = try decoderContainer.decodeIfPresent(String?.self, forKey: .requestId) ?? nil
        self.error = try decoderContainer.decodeIfPresent(ServiceError?.self, forKey: .error) ?? nil
        self.result = try decoderContainer.decodeIfPresent(QueryDomainLogResult?.self, forKey: .result) ?? nil
    }
}

public extension QueryDomainLogResponse{
        func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: QueryDomainLogResponseCodingKeys.self)
        try encoderContainer.encode(requestId, forKey: .requestId)
        try encoderContainer.encode(error, forKey: .error)
        try encoderContainer.encode(result, forKey: .result)
    }
}    

///  批量域名查询日志
public class QueryDomainsLogRequest:JdCloudRequest
{
    /// Domains
    var domains:[String?]?

    /// 查询起始时间,UTC时间，格式为:yyyy-MM-dd&#39;T&#39;HH:mm:ss&#39;Z&#39;，示例:2018-10-21T10:00:00Z
    var startTime:String?

    /// 查询截止时间,UTC时间，格式为:yyyy-MM-dd&#39;T&#39;HH:mm:ss&#39;Z&#39;，示例:2018-10-21T10:00:00Z
    var endTime:String?

    /// 时间间隔，取值(hour，day，fiveMin)，不传默认小时。
    var interval:String?

    /// 日志类型，取值(log，zip,gz)，不传默认gz。
    var logType:String?




    enum QueryDomainsLogRequestRequestCodingKeys: String, CodingKey {
        case domains
        case startTime
        case endTime
        case interval
        case logType
    }

    public override func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: QueryDomainsLogRequestRequestCodingKeys.self)
        try encoderContainer.encode(domains, forKey: .domains)
        try encoderContainer.encode(startTime, forKey: .startTime)
        try encoderContainer.encode(endTime, forKey: .endTime)
        try encoderContainer.encode(interval, forKey: .interval)
        try encoderContainer.encode(logType, forKey: .logType)

    }
}

public class QueryMixTrafficGroupSumResponse:NSObject,Codable
{
    var requestId:String?;

    var error:ServiceError?;

    var result:QueryMixTrafficGroupSumResult?;

    enum QueryMixTrafficGroupSumResponseCodingKeys: String, CodingKey {
        case requestId
        case error
        case result
    }

    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: QueryMixTrafficGroupSumResponseCodingKeys.self)
        self.requestId = try decoderContainer.decodeIfPresent(String?.self, forKey: .requestId) ?? nil
        self.error = try decoderContainer.decodeIfPresent(ServiceError?.self, forKey: .error) ?? nil
        self.result = try decoderContainer.decodeIfPresent(QueryMixTrafficGroupSumResult?.self, forKey: .result) ?? nil
    }
}

public extension QueryMixTrafficGroupSumResponse{
        func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: QueryMixTrafficGroupSumResponseCodingKeys.self)
        try encoderContainer.encode(requestId, forKey: .requestId)
        try encoderContainer.encode(error, forKey: .error)
        try encoderContainer.encode(result, forKey: .result)
    }
}    
public class QueryLiveStatisticsDataResponse:NSObject,Codable
{
    var requestId:String?;

    var error:ServiceError?;

    var result:QueryLiveStatisticsDataResult?;

    enum QueryLiveStatisticsDataResponseCodingKeys: String, CodingKey {
        case requestId
        case error
        case result
    }

    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: QueryLiveStatisticsDataResponseCodingKeys.self)
        self.requestId = try decoderContainer.decodeIfPresent(String?.self, forKey: .requestId) ?? nil
        self.error = try decoderContainer.decodeIfPresent(ServiceError?.self, forKey: .error) ?? nil
        self.result = try decoderContainer.decodeIfPresent(QueryLiveStatisticsDataResult?.self, forKey: .result) ?? nil
    }
}

public extension QueryLiveStatisticsDataResponse{
        func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: QueryLiveStatisticsDataResponseCodingKeys.self)
        try encoderContainer.encode(requestId, forKey: .requestId)
        try encoderContainer.encode(error, forKey: .error)
        try encoderContainer.encode(result, forKey: .result)
    }
}    

///  查询统计数据并进行汇总加和
public class QueryLiveTrafficGroupSumRequest:JdCloudRequest
{
    /// 查询起始时间,UTC时间，格式为:yyyy-MM-dd&#39;T&#39;HH:mm:ss&#39;Z&#39;，示例:2018-10-21T10:00:00Z
    var startTime:String?

    /// 查询截止时间,UTC时间，格式为:yyyy-MM-dd&#39;T&#39;HH:mm:ss&#39;Z&#39;，示例:2018-10-21T10:00:00Z
    var endTime:String?

    /// 需要查询的域名, 必须为用户pin下有权限的域名
    var domain:String?

    /// SubDomain
    var subDomain:String?

    /// app名
    var appName:String?

    /// 流名
    var streamName:String?

    /// 需要查询的字段
    var fields:String?

    /// Area
    var area:String?

    /// Isp
    var isp:String?

    /// 查询的流协议
    var scheme:String?

    /// 时间粒度，可选值:[oneMin,fiveMin,followTime],followTime只会返回一个汇总后的数据
    var period:String?

    /// 分组依据
    var groupBy:String?

    /// ReqMethod
    var reqMethod:String?




    enum QueryLiveTrafficGroupSumRequestRequestCodingKeys: String, CodingKey {
        case startTime
        case endTime
        case domain
        case subDomain
        case appName
        case streamName
        case fields
        case area
        case isp
        case scheme
        case period
        case groupBy
        case reqMethod
    }

    public override func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: QueryLiveTrafficGroupSumRequestRequestCodingKeys.self)
        try encoderContainer.encode(startTime, forKey: .startTime)
        try encoderContainer.encode(endTime, forKey: .endTime)
        try encoderContainer.encode(domain, forKey: .domain)
        try encoderContainer.encode(subDomain, forKey: .subDomain)
        try encoderContainer.encode(appName, forKey: .appName)
        try encoderContainer.encode(streamName, forKey: .streamName)
        try encoderContainer.encode(fields, forKey: .fields)
        try encoderContainer.encode(area, forKey: .area)
        try encoderContainer.encode(isp, forKey: .isp)
        try encoderContainer.encode(scheme, forKey: .scheme)
        try encoderContainer.encode(period, forKey: .period)
        try encoderContainer.encode(groupBy, forKey: .groupBy)
        try encoderContainer.encode(reqMethod, forKey: .reqMethod)

    }
}

public class QueryMixStatisticsDataResponse:NSObject,Codable
{
    var requestId:String?;

    var error:ServiceError?;

    var result:QueryMixStatisticsDataResult?;

    enum QueryMixStatisticsDataResponseCodingKeys: String, CodingKey {
        case requestId
        case error
        case result
    }

    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: QueryMixStatisticsDataResponseCodingKeys.self)
        self.requestId = try decoderContainer.decodeIfPresent(String?.self, forKey: .requestId) ?? nil
        self.error = try decoderContainer.decodeIfPresent(ServiceError?.self, forKey: .error) ?? nil
        self.result = try decoderContainer.decodeIfPresent(QueryMixStatisticsDataResult?.self, forKey: .result) ?? nil
    }
}

public extension QueryMixStatisticsDataResponse{
        func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: QueryMixStatisticsDataResponseCodingKeys.self)
        try encoderContainer.encode(requestId, forKey: .requestId)
        try encoderContainer.encode(error, forKey: .error)
        try encoderContainer.encode(result, forKey: .result)
    }
}    

///  查询统计数据并进行汇总加和
public class QueryMixTrafficGroupSumRequest:JdCloudRequest
{
    /// 查询起始时间,UTC时间，格式为:yyyy-MM-dd&#39;T&#39;HH:mm:ss&#39;Z&#39;，示例:2018-10-21T10:00:00Z
    var startTime:String?

    /// 查询截止时间,UTC时间，格式为:yyyy-MM-dd&#39;T&#39;HH:mm:ss&#39;Z&#39;，示例:2018-10-21T10:00:00Z
    var endTime:String?

    /// 需要查询的域名, 必须为用户pin下有权限的域名
    var domain:String?

    /// 需要查询的字段
    var fields:String?

    /// Area
    var area:String?

    /// Isp
    var isp:String?

    /// 时间粒度，可选值:[oneMin,fiveMin,followTime],followTime只会返回一个汇总后的数据
    var period:String?

    /// 分组依据,只能按域名分组
    var groupBy:String?




    enum QueryMixTrafficGroupSumRequestRequestCodingKeys: String, CodingKey {
        case startTime
        case endTime
        case domain
        case fields
        case area
        case isp
        case period
        case groupBy
    }

    public override func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: QueryMixTrafficGroupSumRequestRequestCodingKeys.self)
        try encoderContainer.encode(startTime, forKey: .startTime)
        try encoderContainer.encode(endTime, forKey: .endTime)
        try encoderContainer.encode(domain, forKey: .domain)
        try encoderContainer.encode(fields, forKey: .fields)
        try encoderContainer.encode(area, forKey: .area)
        try encoderContainer.encode(isp, forKey: .isp)
        try encoderContainer.encode(period, forKey: .period)
        try encoderContainer.encode(groupBy, forKey: .groupBy)

    }
}

/// 查询waf地域信息 
public class QueryWafRegionsResult:NSObject,JdCloudResult
{
    /// 中国地区，地域信息
    var china:[WafRegionsModel?]?

    /// 海外地区，地域信息
    var foreign:[WafRegionsModel?]?



    public override init(){
        super.init()
    }

    enum QueryWafRegionsResultCodingKeys: String, CodingKey {
        case china
        case foreign
    }

    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: QueryWafRegionsResultCodingKeys.self)
        if decoderContainer.contains(.china)
        {
            self.china = try decoderContainer.decode([WafRegionsModel?]?.self, forKey: .china)
        }
        if decoderContainer.contains(.foreign)
        {
            self.foreign = try decoderContainer.decode([WafRegionsModel?]?.self, forKey: .foreign)
        }
    }
}
public extension QueryWafRegionsResult{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: QueryWafRegionsResultCodingKeys.self)
        try encoderContainer.encode(china, forKey: .china)
        try encoderContainer.encode(foreign, forKey: .foreign)
    }
}
public class SetCCProtectSwitchResponse:NSObject,Codable
{
    var requestId:String?;

    var error:ServiceError?;

    var result:SetCCProtectSwitchResult?;

    enum SetCCProtectSwitchResponseCodingKeys: String, CodingKey {
        case requestId
        case error
        case result
    }

    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: SetCCProtectSwitchResponseCodingKeys.self)
        self.requestId = try decoderContainer.decodeIfPresent(String?.self, forKey: .requestId) ?? nil
        self.error = try decoderContainer.decodeIfPresent(ServiceError?.self, forKey: .error) ?? nil
        self.result = try decoderContainer.decodeIfPresent(SetCCProtectSwitchResult?.self, forKey: .result) ?? nil
    }
}

public extension SetCCProtectSwitchResponse{
        func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: SetCCProtectSwitchResponseCodingKeys.self)
        try encoderContainer.encode(requestId, forKey: .requestId)
        try encoderContainer.encode(error, forKey: .error)
        try encoderContainer.encode(result, forKey: .result)
    }
}    
public class SetWafSwitchResponse:NSObject,Codable
{
    var requestId:String?;

    var error:ServiceError?;

    var result:SetWafSwitchResult?;

    enum SetWafSwitchResponseCodingKeys: String, CodingKey {
        case requestId
        case error
        case result
    }

    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: SetWafSwitchResponseCodingKeys.self)
        self.requestId = try decoderContainer.decodeIfPresent(String?.self, forKey: .requestId) ?? nil
        self.error = try decoderContainer.decodeIfPresent(ServiceError?.self, forKey: .error) ?? nil
        self.result = try decoderContainer.decodeIfPresent(SetWafSwitchResult?.self, forKey: .result) ?? nil
    }
}

public extension SetWafSwitchResponse{
        func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: SetWafSwitchResponseCodingKeys.self)
        try encoderContainer.encode(requestId, forKey: .requestId)
        try encoderContainer.encode(error, forKey: .error)
        try encoderContainer.encode(result, forKey: .result)
    }
}    
/// 查询waf ip黑名单配置状态 
public class QueryIpBlackSettingStatusResult:NSObject,JdCloudResult
{
    /// true or false, true:scdn的黑名单为打开状态，并至少存在一条ruleType&#x3D;ip的黑名单规则且为启用状态
    var settingStatus:Bool?



    public override init(){
        super.init()
    }

    enum QueryIpBlackSettingStatusResultCodingKeys: String, CodingKey {
        case settingStatus
    }

    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: QueryIpBlackSettingStatusResultCodingKeys.self)
        if decoderContainer.contains(.settingStatus)
        {
            self.settingStatus = try decoderContainer.decode(Bool?.self, forKey: .settingStatus)
        }
    }
}
public extension QueryIpBlackSettingStatusResult{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: QueryIpBlackSettingStatusResultCodingKeys.self)
        try encoderContainer.encode(settingStatus, forKey: .settingStatus)
    }
}
public class SetWafWhiteRuleSwitchResponse:NSObject,Codable
{
    var requestId:String?;

    var error:ServiceError?;

    var result:SetWafWhiteRuleSwitchResult?;

    enum SetWafWhiteRuleSwitchResponseCodingKeys: String, CodingKey {
        case requestId
        case error
        case result
    }

    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: SetWafWhiteRuleSwitchResponseCodingKeys.self)
        self.requestId = try decoderContainer.decodeIfPresent(String?.self, forKey: .requestId) ?? nil
        self.error = try decoderContainer.decodeIfPresent(ServiceError?.self, forKey: .error) ?? nil
        self.result = try decoderContainer.decodeIfPresent(SetWafWhiteRuleSwitchResult?.self, forKey: .result) ?? nil
    }
}

public extension SetWafWhiteRuleSwitchResponse{
        func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: SetWafWhiteRuleSwitchResponseCodingKeys.self)
        try encoderContainer.encode(requestId, forKey: .requestId)
        try encoderContainer.encode(error, forKey: .error)
        try encoderContainer.encode(result, forKey: .result)
    }
}    

///  查询WAF黑名单开关
public class QueryWafBlackRuleSwitchRequest:JdCloudRequest
{
    /// 用户域名
    var domain:String


    public init(regionId: String,domain:String){
        self.domain = domain
        super.init(regionId: regionId)
    }


    enum QueryWafBlackRuleSwitchRequestRequestCodingKeys: String, CodingKey {
        case domain
    }

    public override func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: QueryWafBlackRuleSwitchRequestRequestCodingKeys.self)
        try encoderContainer.encode(domain, forKey: .domain)

    }
}

/// 禁用WAF黑名单 
public class DisableWafBlackRulesResult:NSObject,JdCloudResult
{
}

///  禁用CC防护规则
public class DisableCCProtectRuleRequest:JdCloudRequest
{
    /// Ids
    var ids:[String?]?

    /// 用户域名
    var domain:String


    public init(regionId: String,domain:String){
        self.domain = domain
        super.init(regionId: regionId)
    }


    enum DisableCCProtectRuleRequestRequestCodingKeys: String, CodingKey {
        case ids
        case domain
    }

    public override func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: DisableCCProtectRuleRequestRequestCodingKeys.self)
        try encoderContainer.encode(ids, forKey: .ids)
        try encoderContainer.encode(domain, forKey: .domain)

    }
}

public class DeleteWafWhiteRulesResponse:NSObject,Codable
{
    var requestId:String?;

    var error:ServiceError?;

    var result:DeleteWafWhiteRulesResult?;

    enum DeleteWafWhiteRulesResponseCodingKeys: String, CodingKey {
        case requestId
        case error
        case result
    }

    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: DeleteWafWhiteRulesResponseCodingKeys.self)
        self.requestId = try decoderContainer.decodeIfPresent(String?.self, forKey: .requestId) ?? nil
        self.error = try decoderContainer.decodeIfPresent(ServiceError?.self, forKey: .error) ?? nil
        self.result = try decoderContainer.decodeIfPresent(DeleteWafWhiteRulesResult?.self, forKey: .result) ?? nil
    }
}

public extension DeleteWafWhiteRulesResponse{
        func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: DeleteWafWhiteRulesResponseCodingKeys.self)
        try encoderContainer.encode(requestId, forKey: .requestId)
        try encoderContainer.encode(error, forKey: .error)
        try encoderContainer.encode(result, forKey: .result)
    }
}    
/// 设置CC 防护开关 
public class SetCCProtectSwitchResult:NSObject,JdCloudResult
{
}
public class QueryWafSwitchResponse:NSObject,Codable
{
    var requestId:String?;

    var error:ServiceError?;

    var result:QueryWafSwitchResult?;

    enum QueryWafSwitchResponseCodingKeys: String, CodingKey {
        case requestId
        case error
        case result
    }

    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: QueryWafSwitchResponseCodingKeys.self)
        self.requestId = try decoderContainer.decodeIfPresent(String?.self, forKey: .requestId) ?? nil
        self.error = try decoderContainer.decodeIfPresent(ServiceError?.self, forKey: .error) ?? nil
        self.result = try decoderContainer.decodeIfPresent(QueryWafSwitchResult?.self, forKey: .result) ?? nil
    }
}

public extension QueryWafSwitchResponse{
        func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: QueryWafSwitchResponseCodingKeys.self)
        try encoderContainer.encode(requestId, forKey: .requestId)
        try encoderContainer.encode(error, forKey: .error)
        try encoderContainer.encode(result, forKey: .result)
    }
}    

///  查询web防护开关
public class QueryWebProtectSwitchRequest:JdCloudRequest
{
    /// 用户域名
    var domain:String


    public init(regionId: String,domain:String){
        self.domain = domain
        super.init(regionId: regionId)
    }


    enum QueryWebProtectSwitchRequestRequestCodingKeys: String, CodingKey {
        case domain
    }

    public override func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: QueryWebProtectSwitchRequestRequestCodingKeys.self)
        try encoderContainer.encode(domain, forKey: .domain)

    }
}


///  新增一条黑名单规则
public class CreateWafBlackRuleRequest:JdCloudRequest
{
    /// 黑名单类型， uri ip geo
    var ruleType:String?

    /// 匹配模式,uri类型有效，0&#x3D;完全匹配  1&#x3D;前缀匹配 2&#x3D;包含 3&#x3D;正则 4&#x3D;大于 5&#x3D;后缀
    var matchOp:Int32?

    /// 匹配值
    var val:String?

    /// 1：forbidden，493封禁并返回自定义页面 2：redirect，302跳转 3： verify@captcha 4： verify@jscookie
    var atOp:Int32?

    /// action为1时为自定义页面名称,空值或缺省值default为默认页面，2时为跳转url，其他时无效
    var atVal:String?

    /// 用户域名
    var domain:String


    public init(regionId: String,domain:String){
        self.domain = domain
        super.init(regionId: regionId)
    }


    enum CreateWafBlackRuleRequestRequestCodingKeys: String, CodingKey {
        case ruleType
        case matchOp
        case val
        case atOp
        case atVal
        case domain
    }

    public override func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: CreateWafBlackRuleRequestRequestCodingKeys.self)
        try encoderContainer.encode(ruleType, forKey: .ruleType)
        try encoderContainer.encode(matchOp, forKey: .matchOp)
        try encoderContainer.encode(val, forKey: .val)
        try encoderContainer.encode(atOp, forKey: .atOp)
        try encoderContainer.encode(atVal, forKey: .atVal)
        try encoderContainer.encode(domain, forKey: .domain)

    }
}

public class CreateWafBlackRuleResponse:NSObject,Codable
{
    var requestId:String?;

    var error:ServiceError?;

    var result:CreateWafBlackRuleResult?;

    enum CreateWafBlackRuleResponseCodingKeys: String, CodingKey {
        case requestId
        case error
        case result
    }

    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: CreateWafBlackRuleResponseCodingKeys.self)
        self.requestId = try decoderContainer.decodeIfPresent(String?.self, forKey: .requestId) ?? nil
        self.error = try decoderContainer.decodeIfPresent(ServiceError?.self, forKey: .error) ?? nil
        self.result = try decoderContainer.decodeIfPresent(CreateWafBlackRuleResult?.self, forKey: .result) ?? nil
    }
}

public extension CreateWafBlackRuleResponse{
        func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: CreateWafBlackRuleResponseCodingKeys.self)
        try encoderContainer.encode(requestId, forKey: .requestId)
        try encoderContainer.encode(error, forKey: .error)
        try encoderContainer.encode(result, forKey: .result)
    }
}    
/// 新增一条CC防护规则 
public class CreateCCProtectRuleResult:NSObject,JdCloudResult
{
}
public class EnableWafBlackRulesResponse:NSObject,Codable
{
    var requestId:String?;

    var error:ServiceError?;

    var result:EnableWafBlackRulesResult?;

    enum EnableWafBlackRulesResponseCodingKeys: String, CodingKey {
        case requestId
        case error
        case result
    }

    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: EnableWafBlackRulesResponseCodingKeys.self)
        self.requestId = try decoderContainer.decodeIfPresent(String?.self, forKey: .requestId) ?? nil
        self.error = try decoderContainer.decodeIfPresent(ServiceError?.self, forKey: .error) ?? nil
        self.result = try decoderContainer.decodeIfPresent(EnableWafBlackRulesResult?.self, forKey: .result) ?? nil
    }
}

public extension EnableWafBlackRulesResponse{
        func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: EnableWafBlackRulesResponseCodingKeys.self)
        try encoderContainer.encode(requestId, forKey: .requestId)
        try encoderContainer.encode(error, forKey: .error)
        try encoderContainer.encode(result, forKey: .result)
    }
}    

///  修改指定的黑名单规则
public class UpdateWafBlackRuleRequest:JdCloudRequest
{
    /// 黑名单类型， uri ip geo
    var ruleType:String?

    /// 匹配模式,uri类型有效，0&#x3D;完全匹配  1&#x3D;前缀匹配 2&#x3D;包含 3&#x3D;正则 4&#x3D;大于 5&#x3D;后缀
    var matchOp:Int32?

    /// 匹配值
    var val:String?

    /// 1：forbidden，493封禁并返回自定义页面 2：redirect，302跳转 3： verify@captcha 4： verify@jscookie
    var atOp:Int32?

    /// action为1时为自定义页面名称,空值或缺省值default为默认页面，2时为跳转url，其他时无效
    var atVal:String?

    /// 用户域名
    var domain:String

    /// 需要修改的黑名单ID
    var id:String


    public init(regionId: String,domain:String,id:String){
        self.domain = domain
        self.id = id
        super.init(regionId: regionId)
    }


    enum UpdateWafBlackRuleRequestRequestCodingKeys: String, CodingKey {
        case ruleType
        case matchOp
        case val
        case atOp
        case atVal
        case domain
        case id
    }

    public override func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: UpdateWafBlackRuleRequestRequestCodingKeys.self)
        try encoderContainer.encode(ruleType, forKey: .ruleType)
        try encoderContainer.encode(matchOp, forKey: .matchOp)
        try encoderContainer.encode(val, forKey: .val)
        try encoderContainer.encode(atOp, forKey: .atOp)
        try encoderContainer.encode(atVal, forKey: .atVal)
        try encoderContainer.encode(domain, forKey: .domain)
        try encoderContainer.encode(id, forKey: .id)

    }
}

public class QueryWebProtectSettingsResponse:NSObject,Codable
{
    var requestId:String?;

    var error:ServiceError?;

    var result:QueryWebProtectSettingsResult?;

    enum QueryWebProtectSettingsResponseCodingKeys: String, CodingKey {
        case requestId
        case error
        case result
    }

    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: QueryWebProtectSettingsResponseCodingKeys.self)
        self.requestId = try decoderContainer.decodeIfPresent(String?.self, forKey: .requestId) ?? nil
        self.error = try decoderContainer.decodeIfPresent(ServiceError?.self, forKey: .error) ?? nil
        self.result = try decoderContainer.decodeIfPresent(QueryWebProtectSettingsResult?.self, forKey: .result) ?? nil
    }
}

public extension QueryWebProtectSettingsResponse{
        func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: QueryWebProtectSettingsResponseCodingKeys.self)
        try encoderContainer.encode(requestId, forKey: .requestId)
        try encoderContainer.encode(error, forKey: .error)
        try encoderContainer.encode(result, forKey: .result)
    }
}    
/// 查询WAF总开关 
public class QueryWafSwitchResult:NSObject,JdCloudResult
{
    /// 开关状态, on:开启,off:关闭
    var switchStatus:String?



    public override init(){
        super.init()
    }

    enum QueryWafSwitchResultCodingKeys: String, CodingKey {
        case switchStatus
    }

    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: QueryWafSwitchResultCodingKeys.self)
        if decoderContainer.contains(.switchStatus)
        {
            self.switchStatus = try decoderContainer.decode(String?.self, forKey: .switchStatus)
        }
    }
}
public extension QueryWafSwitchResult{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: QueryWafSwitchResultCodingKeys.self)
        try encoderContainer.encode(switchStatus, forKey: .switchStatus)
    }
}
public class QueryIpBlackSettingStatusResponse:NSObject,Codable
{
    var requestId:String?;

    var error:ServiceError?;

    var result:QueryIpBlackSettingStatusResult?;

    enum QueryIpBlackSettingStatusResponseCodingKeys: String, CodingKey {
        case requestId
        case error
        case result
    }

    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: QueryIpBlackSettingStatusResponseCodingKeys.self)
        self.requestId = try decoderContainer.decodeIfPresent(String?.self, forKey: .requestId) ?? nil
        self.error = try decoderContainer.decodeIfPresent(ServiceError?.self, forKey: .error) ?? nil
        self.result = try decoderContainer.decodeIfPresent(QueryIpBlackSettingStatusResult?.self, forKey: .result) ?? nil
    }
}

public extension QueryIpBlackSettingStatusResponse{
        func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: QueryIpBlackSettingStatusResponseCodingKeys.self)
        try encoderContainer.encode(requestId, forKey: .requestId)
        try encoderContainer.encode(error, forKey: .error)
        try encoderContainer.encode(result, forKey: .result)
    }
}    

///  查询WAF白名单规则列表
public class QuerywafWhiteRulesRequest:JdCloudRequest
{
    /// ruleType, valid values [ip, geo, uri]
    var ruleType:String

    /// ruleId, defalut empty
    var id:String?

    /// page size , default 0 to query all
    var pageSize:Int32?

    /// page index , default 0 to query all
    var pageIndex:Int32?

    /// 用户域名
    var domain:String


    public init(regionId: String,ruleType:String,domain:String){
        self.ruleType = ruleType
        self.domain = domain
        super.init(regionId: regionId)
    }


    enum QuerywafWhiteRulesRequestRequestCodingKeys: String, CodingKey {
        case ruleType
        case id
        case pageSize
        case pageIndex
        case domain
    }

    public override func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: QuerywafWhiteRulesRequestRequestCodingKeys.self)
        try encoderContainer.encode(ruleType, forKey: .ruleType)
        try encoderContainer.encode(id, forKey: .id)
        try encoderContainer.encode(pageSize, forKey: .pageSize)
        try encoderContainer.encode(pageIndex, forKey: .pageIndex)
        try encoderContainer.encode(domain, forKey: .domain)

    }
}

/// 新增一条黑名单规则 
public class CreateWafBlackRuleResult:NSObject,JdCloudResult
{
}
/// 删除WAF黑名单 
public class DeleteWafBlackRulesResult:NSObject,JdCloudResult
{
}

///  设置web防护开关
public class SetWebProtectSwitchRequest:JdCloudRequest
{
    /// 开关状态, on:开启,off:关闭
    var switchStatus:String?

    /// 用户域名
    var domain:String


    public init(regionId: String,domain:String){
        self.domain = domain
        super.init(regionId: regionId)
    }


    enum SetWebProtectSwitchRequestRequestCodingKeys: String, CodingKey {
        case switchStatus
        case domain
    }

    public override func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: SetWebProtectSwitchRequestRequestCodingKeys.self)
        try encoderContainer.encode(switchStatus, forKey: .switchStatus)
        try encoderContainer.encode(domain, forKey: .domain)

    }
}


///  删除WAF黑名单
public class DeleteWafBlackRulesRequest:JdCloudRequest
{
    /// RuleType
    var ruleType:String

    /// 用户域名
    var domain:String

    /// Ids
    var ids:String


    public init(regionId: String,ruleType:String,domain:String,ids:String){
        self.ruleType = ruleType
        self.domain = domain
        self.ids = ids
        super.init(regionId: regionId)
    }


    enum DeleteWafBlackRulesRequestRequestCodingKeys: String, CodingKey {
        case ruleType
        case domain
        case ids
    }

    public override func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: DeleteWafBlackRulesRequestRequestCodingKeys.self)
        try encoderContainer.encode(ruleType, forKey: .ruleType)
        try encoderContainer.encode(domain, forKey: .domain)
        try encoderContainer.encode(ids, forKey: .ids)

    }
}


///  设置web防护开关
public class UpdateWebProtectSettingsRequest:JdCloudRequest
{
    /// 0：拦截模式 (阻断forbidden 493跳到自定义页面) ，1-检测模式(观察notice)
    var wafMode:String?

    /// 规则策略等级 0为宽松, 1为正常, 2为严格
    var wafLevel:Int32?

    /// 拦截模式跳转的自定义页面名称, 缺省或default返回默认页面
    var redirection:String?

    /// 用户域名
    var domain:String


    public init(regionId: String,domain:String){
        self.domain = domain
        super.init(regionId: regionId)
    }


    enum UpdateWebProtectSettingsRequestRequestCodingKeys: String, CodingKey {
        case wafMode
        case wafLevel
        case redirection
        case domain
    }

    public override func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: UpdateWebProtectSettingsRequestRequestCodingKeys.self)
        try encoderContainer.encode(wafMode, forKey: .wafMode)
        try encoderContainer.encode(wafLevel, forKey: .wafLevel)
        try encoderContainer.encode(redirection, forKey: .redirection)
        try encoderContainer.encode(domain, forKey: .domain)

    }
}

public class SetWafBlackRuleSwitchResponse:NSObject,Codable
{
    var requestId:String?;

    var error:ServiceError?;

    var result:SetWafBlackRuleSwitchResult?;

    enum SetWafBlackRuleSwitchResponseCodingKeys: String, CodingKey {
        case requestId
        case error
        case result
    }

    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: SetWafBlackRuleSwitchResponseCodingKeys.self)
        self.requestId = try decoderContainer.decodeIfPresent(String?.self, forKey: .requestId) ?? nil
        self.error = try decoderContainer.decodeIfPresent(ServiceError?.self, forKey: .error) ?? nil
        self.result = try decoderContainer.decodeIfPresent(SetWafBlackRuleSwitchResult?.self, forKey: .result) ?? nil
    }
}

public extension SetWafBlackRuleSwitchResponse{
        func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: SetWafBlackRuleSwitchResponseCodingKeys.self)
        try encoderContainer.encode(requestId, forKey: .requestId)
        try encoderContainer.encode(error, forKey: .error)
        try encoderContainer.encode(result, forKey: .result)
    }
}    
/// 启用WAF白名单 
public class EnableWafWhiteRulesResult:NSObject,JdCloudResult
{
}
/// 修改指定的白名单规则 
public class UpdateWafWhiteRuleResult:NSObject,JdCloudResult
{
}
public class QueryCCProtectSwitchResponse:NSObject,Codable
{
    var requestId:String?;

    var error:ServiceError?;

    var result:QueryCCProtectSwitchResult?;

    enum QueryCCProtectSwitchResponseCodingKeys: String, CodingKey {
        case requestId
        case error
        case result
    }

    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: QueryCCProtectSwitchResponseCodingKeys.self)
        self.requestId = try decoderContainer.decodeIfPresent(String?.self, forKey: .requestId) ?? nil
        self.error = try decoderContainer.decodeIfPresent(ServiceError?.self, forKey: .error) ?? nil
        self.result = try decoderContainer.decodeIfPresent(QueryCCProtectSwitchResult?.self, forKey: .result) ?? nil
    }
}

public extension QueryCCProtectSwitchResponse{
        func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: QueryCCProtectSwitchResponseCodingKeys.self)
        try encoderContainer.encode(requestId, forKey: .requestId)
        try encoderContainer.encode(error, forKey: .error)
        try encoderContainer.encode(result, forKey: .result)
    }
}    
/// 设置WAF黑名单开关 
public class SetWafBlackRuleSwitchResult:NSObject,JdCloudResult
{
}
public class EnableCCProtectRuleResponse:NSObject,Codable
{
    var requestId:String?;

    var error:ServiceError?;

    var result:EnableCCProtectRuleResult?;

    enum EnableCCProtectRuleResponseCodingKeys: String, CodingKey {
        case requestId
        case error
        case result
    }

    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: EnableCCProtectRuleResponseCodingKeys.self)
        self.requestId = try decoderContainer.decodeIfPresent(String?.self, forKey: .requestId) ?? nil
        self.error = try decoderContainer.decodeIfPresent(ServiceError?.self, forKey: .error) ?? nil
        self.result = try decoderContainer.decodeIfPresent(EnableCCProtectRuleResult?.self, forKey: .result) ?? nil
    }
}

public extension EnableCCProtectRuleResponse{
        func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: EnableCCProtectRuleResponseCodingKeys.self)
        try encoderContainer.encode(requestId, forKey: .requestId)
        try encoderContainer.encode(error, forKey: .error)
        try encoderContainer.encode(result, forKey: .result)
    }
}    
public class CreateWafWhiteRuleResponse:NSObject,Codable
{
    var requestId:String?;

    var error:ServiceError?;

    var result:CreateWafWhiteRuleResult?;

    enum CreateWafWhiteRuleResponseCodingKeys: String, CodingKey {
        case requestId
        case error
        case result
    }

    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: CreateWafWhiteRuleResponseCodingKeys.self)
        self.requestId = try decoderContainer.decodeIfPresent(String?.self, forKey: .requestId) ?? nil
        self.error = try decoderContainer.decodeIfPresent(ServiceError?.self, forKey: .error) ?? nil
        self.result = try decoderContainer.decodeIfPresent(CreateWafWhiteRuleResult?.self, forKey: .result) ?? nil
    }
}

public extension CreateWafWhiteRuleResponse{
        func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: CreateWafWhiteRuleResponseCodingKeys.self)
        try encoderContainer.encode(requestId, forKey: .requestId)
        try encoderContainer.encode(error, forKey: .error)
        try encoderContainer.encode(result, forKey: .result)
    }
}    
public class DeleteCCProtectRuleResponse:NSObject,Codable
{
    var requestId:String?;

    var error:ServiceError?;

    var result:DeleteCCProtectRuleResult?;

    enum DeleteCCProtectRuleResponseCodingKeys: String, CodingKey {
        case requestId
        case error
        case result
    }

    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: DeleteCCProtectRuleResponseCodingKeys.self)
        self.requestId = try decoderContainer.decodeIfPresent(String?.self, forKey: .requestId) ?? nil
        self.error = try decoderContainer.decodeIfPresent(ServiceError?.self, forKey: .error) ?? nil
        self.result = try decoderContainer.decodeIfPresent(DeleteCCProtectRuleResult?.self, forKey: .result) ?? nil
    }
}

public extension DeleteCCProtectRuleResponse{
        func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: DeleteCCProtectRuleResponseCodingKeys.self)
        try encoderContainer.encode(requestId, forKey: .requestId)
        try encoderContainer.encode(error, forKey: .error)
        try encoderContainer.encode(result, forKey: .result)
    }
}    
/// 启用WAF黑名单 
public class EnableWafBlackRulesResult:NSObject,JdCloudResult
{
}
/// 修改指定的黑名单规则 
public class UpdateWafBlackRuleResult:NSObject,JdCloudResult
{
}

///  查询CC防护规则列表
public class QueryCCProtectRulesRequest:JdCloudRequest
{
    /// ruleId, defalut empty
    var id:String?

    /// page size , default 0 to query all
    var pageSize:Int32?

    /// page index , default 0 to query all
    var pageIndex:Int32?

    /// 用户域名
    var domain:String


    public init(regionId: String,domain:String){
        self.domain = domain
        super.init(regionId: regionId)
    }


    enum QueryCCProtectRulesRequestRequestCodingKeys: String, CodingKey {
        case id
        case pageSize
        case pageIndex
        case domain
    }

    public override func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: QueryCCProtectRulesRequestRequestCodingKeys.self)
        try encoderContainer.encode(id, forKey: .id)
        try encoderContainer.encode(pageSize, forKey: .pageSize)
        try encoderContainer.encode(pageIndex, forKey: .pageIndex)
        try encoderContainer.encode(domain, forKey: .domain)

    }
}


///  启用WAF白名单
public class EnableWafWhiteRulesRequest:JdCloudRequest
{
    /// Ids
    var ids:[String?]?

    /// RuleType
    var ruleType:String?

    /// 用户域名
    var domain:String


    public init(regionId: String,domain:String){
        self.domain = domain
        super.init(regionId: regionId)
    }


    enum EnableWafWhiteRulesRequestRequestCodingKeys: String, CodingKey {
        case ids
        case ruleType
        case domain
    }

    public override func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: EnableWafWhiteRulesRequestRequestCodingKeys.self)
        try encoderContainer.encode(ids, forKey: .ids)
        try encoderContainer.encode(ruleType, forKey: .ruleType)
        try encoderContainer.encode(domain, forKey: .domain)

    }
}


///  启用CC防护规则
public class EnableCCProtectRuleRequest:JdCloudRequest
{
    /// Ids
    var ids:[String?]?

    /// 用户域名
    var domain:String


    public init(regionId: String,domain:String){
        self.domain = domain
        super.init(regionId: regionId)
    }


    enum EnableCCProtectRuleRequestRequestCodingKeys: String, CodingKey {
        case ids
        case domain
    }

    public override func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: EnableCCProtectRuleRequestRequestCodingKeys.self)
        try encoderContainer.encode(ids, forKey: .ids)
        try encoderContainer.encode(domain, forKey: .domain)

    }
}

/// 删除ccProtectRule 
public class DeleteCCProtectRuleResult:NSObject,JdCloudResult
{
}

///  查询web防护开关
public class QueryWebProtectSettingsRequest:JdCloudRequest
{
    /// 用户域名
    var domain:String


    public init(regionId: String,domain:String){
        self.domain = domain
        super.init(regionId: regionId)
    }


    enum QueryWebProtectSettingsRequestRequestCodingKeys: String, CodingKey {
        case domain
    }

    public override func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: QueryWebProtectSettingsRequestRequestCodingKeys.self)
        try encoderContainer.encode(domain, forKey: .domain)

    }
}

/// 查询CC 防护开关 
public class QueryCCProtectSwitchResult:NSObject,JdCloudResult
{
    /// 开关状态, on:开启,off:关闭
    var switchStatus:String?



    public override init(){
        super.init()
    }

    enum QueryCCProtectSwitchResultCodingKeys: String, CodingKey {
        case switchStatus
    }

    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: QueryCCProtectSwitchResultCodingKeys.self)
        if decoderContainer.contains(.switchStatus)
        {
            self.switchStatus = try decoderContainer.decode(String?.self, forKey: .switchStatus)
        }
    }
}
public extension QueryCCProtectSwitchResult{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: QueryCCProtectSwitchResultCodingKeys.self)
        try encoderContainer.encode(switchStatus, forKey: .switchStatus)
    }
}
/// 启用CC防护规则 
public class EnableCCProtectRuleResult:NSObject,JdCloudResult
{
}

///  新增一条CC防护规则
public class CreateCCProtectRuleRequest:JdCloudRequest
{
    /// null
    var uri:String?

    /// null
    var detectPeriod:Int32?

    /// null
    var singleIpLimit:Int32?

    /// null
    var blockType:Int32?

    /// null
    var blockTime:Int32?

    /// 用户域名
    var domain:String


    public init(regionId: String,domain:String){
        self.domain = domain
        super.init(regionId: regionId)
    }


    enum CreateCCProtectRuleRequestRequestCodingKeys: String, CodingKey {
        case uri
        case detectPeriod
        case singleIpLimit
        case blockType
        case blockTime
        case domain
    }

    public override func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: CreateCCProtectRuleRequestRequestCodingKeys.self)
        try encoderContainer.encode(uri, forKey: .uri)
        try encoderContainer.encode(detectPeriod, forKey: .detectPeriod)
        try encoderContainer.encode(singleIpLimit, forKey: .singleIpLimit)
        try encoderContainer.encode(blockType, forKey: .blockType)
        try encoderContainer.encode(blockTime, forKey: .blockTime)
        try encoderContainer.encode(domain, forKey: .domain)

    }
}

public class DeleteWafBlackRulesResponse:NSObject,Codable
{
    var requestId:String?;

    var error:ServiceError?;

    var result:DeleteWafBlackRulesResult?;

    enum DeleteWafBlackRulesResponseCodingKeys: String, CodingKey {
        case requestId
        case error
        case result
    }

    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: DeleteWafBlackRulesResponseCodingKeys.self)
        self.requestId = try decoderContainer.decodeIfPresent(String?.self, forKey: .requestId) ?? nil
        self.error = try decoderContainer.decodeIfPresent(ServiceError?.self, forKey: .error) ?? nil
        self.result = try decoderContainer.decodeIfPresent(DeleteWafBlackRulesResult?.self, forKey: .result) ?? nil
    }
}

public extension DeleteWafBlackRulesResponse{
        func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: DeleteWafBlackRulesResponseCodingKeys.self)
        try encoderContainer.encode(requestId, forKey: .requestId)
        try encoderContainer.encode(error, forKey: .error)
        try encoderContainer.encode(result, forKey: .result)
    }
}    
/// 设置WAF总开关 
public class SetWafSwitchResult:NSObject,JdCloudResult
{
}
/// 查询CC防护规则列表 
public class QueryCCProtectRulesResult:NSObject,JdCloudResult
{
    /// CC 防护规则列表
    var rules:[WafCCProtectRuleModel?]?



    public override init(){
        super.init()
    }

    enum QueryCCProtectRulesResultCodingKeys: String, CodingKey {
        case rules
    }

    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: QueryCCProtectRulesResultCodingKeys.self)
        if decoderContainer.contains(.rules)
        {
            self.rules = try decoderContainer.decode([WafCCProtectRuleModel?]?.self, forKey: .rules)
        }
    }
}
public extension QueryCCProtectRulesResult{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: QueryCCProtectRulesResultCodingKeys.self)
        try encoderContainer.encode(rules, forKey: .rules)
    }
}

///  查询WAF总开关
public class QueryWafSwitchRequest:JdCloudRequest
{
    /// 用户域名
    var domain:String


    public init(regionId: String,domain:String){
        self.domain = domain
        super.init(regionId: regionId)
    }


    enum QueryWafSwitchRequestRequestCodingKeys: String, CodingKey {
        case domain
    }

    public override func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: QueryWafSwitchRequestRequestCodingKeys.self)
        try encoderContainer.encode(domain, forKey: .domain)

    }
}


///  设置CC 防护开关
public class SetCCProtectSwitchRequest:JdCloudRequest
{
    /// 开关状态, on:开启,off:关闭
    var switchStatus:String?

    /// 用户域名
    var domain:String


    public init(regionId: String,domain:String){
        self.domain = domain
        super.init(regionId: regionId)
    }


    enum SetCCProtectSwitchRequestRequestCodingKeys: String, CodingKey {
        case switchStatus
        case domain
    }

    public override func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: SetCCProtectSwitchRequestRequestCodingKeys.self)
        try encoderContainer.encode(switchStatus, forKey: .switchStatus)
        try encoderContainer.encode(domain, forKey: .domain)

    }
}

public class EnableWafWhiteRulesResponse:NSObject,Codable
{
    var requestId:String?;

    var error:ServiceError?;

    var result:EnableWafWhiteRulesResult?;

    enum EnableWafWhiteRulesResponseCodingKeys: String, CodingKey {
        case requestId
        case error
        case result
    }

    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: EnableWafWhiteRulesResponseCodingKeys.self)
        self.requestId = try decoderContainer.decodeIfPresent(String?.self, forKey: .requestId) ?? nil
        self.error = try decoderContainer.decodeIfPresent(ServiceError?.self, forKey: .error) ?? nil
        self.result = try decoderContainer.decodeIfPresent(EnableWafWhiteRulesResult?.self, forKey: .result) ?? nil
    }
}

public extension EnableWafWhiteRulesResponse{
        func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: EnableWafWhiteRulesResponseCodingKeys.self)
        try encoderContainer.encode(requestId, forKey: .requestId)
        try encoderContainer.encode(error, forKey: .error)
        try encoderContainer.encode(result, forKey: .result)
    }
}    

///  设置WAF白名单开关
public class SetWafWhiteRuleSwitchRequest:JdCloudRequest
{
    /// 开关状态, on:开启,off:关闭
    var switchStatus:String?

    /// 用户域名
    var domain:String


    public init(regionId: String,domain:String){
        self.domain = domain
        super.init(regionId: regionId)
    }


    enum SetWafWhiteRuleSwitchRequestRequestCodingKeys: String, CodingKey {
        case switchStatus
        case domain
    }

    public override func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: SetWafWhiteRuleSwitchRequestRequestCodingKeys.self)
        try encoderContainer.encode(switchStatus, forKey: .switchStatus)
        try encoderContainer.encode(domain, forKey: .domain)

    }
}

/// 查询web防护开关 
public class QueryWebProtectSettingsResult:NSObject,JdCloudResult
{
    /// 0：拦截模式 (阻断forbidden 493跳到自定义页面) ，1-检测模式(观察notice)
    var wafMode:String?

    /// 规则策略等级 0为宽松, 1为正常, 2为严格
    var wafLevel:Int32?

    /// 拦截模式跳转的自定义页面名称, 缺省或default返回默认页面
    var redirection:String?



    public override init(){
        super.init()
    }

    enum QueryWebProtectSettingsResultCodingKeys: String, CodingKey {
        case wafMode
        case wafLevel
        case redirection
    }

    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: QueryWebProtectSettingsResultCodingKeys.self)
        if decoderContainer.contains(.wafMode)
        {
            self.wafMode = try decoderContainer.decode(String?.self, forKey: .wafMode)
        }
        if decoderContainer.contains(.wafLevel)
        {
            self.wafLevel = try decoderContainer.decode(Int32?.self, forKey: .wafLevel)
        }
        if decoderContainer.contains(.redirection)
        {
            self.redirection = try decoderContainer.decode(String?.self, forKey: .redirection)
        }
    }
}
public extension QueryWebProtectSettingsResult{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: QueryWebProtectSettingsResultCodingKeys.self)
        try encoderContainer.encode(wafMode, forKey: .wafMode)
        try encoderContainer.encode(wafLevel, forKey: .wafLevel)
        try encoderContainer.encode(redirection, forKey: .redirection)
    }
}
public class DisableWafWhiteRulesResponse:NSObject,Codable
{
    var requestId:String?;

    var error:ServiceError?;

    var result:DisableWafWhiteRulesResult?;

    enum DisableWafWhiteRulesResponseCodingKeys: String, CodingKey {
        case requestId
        case error
        case result
    }

    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: DisableWafWhiteRulesResponseCodingKeys.self)
        self.requestId = try decoderContainer.decodeIfPresent(String?.self, forKey: .requestId) ?? nil
        self.error = try decoderContainer.decodeIfPresent(ServiceError?.self, forKey: .error) ?? nil
        self.result = try decoderContainer.decodeIfPresent(DisableWafWhiteRulesResult?.self, forKey: .result) ?? nil
    }
}

public extension DisableWafWhiteRulesResponse{
        func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: DisableWafWhiteRulesResponseCodingKeys.self)
        try encoderContainer.encode(requestId, forKey: .requestId)
        try encoderContainer.encode(error, forKey: .error)
        try encoderContainer.encode(result, forKey: .result)
    }
}    

///  修改CC防护规则
public class UpdateCCProtectRuleRequest:JdCloudRequest
{
    /// null
    var uri:String?

    /// null
    var detectPeriod:Int32?

    /// null
    var singleIpLimit:Int32?

    /// null
    var blockType:Int32?

    /// null
    var blockTime:Int32?

    /// 用户域名
    var domain:String

    /// 需要修改的规则ID
    var id:String


    public init(regionId: String,domain:String,id:String){
        self.domain = domain
        self.id = id
        super.init(regionId: regionId)
    }


    enum UpdateCCProtectRuleRequestRequestCodingKeys: String, CodingKey {
        case uri
        case detectPeriod
        case singleIpLimit
        case blockType
        case blockTime
        case domain
        case id
    }

    public override func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: UpdateCCProtectRuleRequestRequestCodingKeys.self)
        try encoderContainer.encode(uri, forKey: .uri)
        try encoderContainer.encode(detectPeriod, forKey: .detectPeriod)
        try encoderContainer.encode(singleIpLimit, forKey: .singleIpLimit)
        try encoderContainer.encode(blockType, forKey: .blockType)
        try encoderContainer.encode(blockTime, forKey: .blockTime)
        try encoderContainer.encode(domain, forKey: .domain)
        try encoderContainer.encode(id, forKey: .id)

    }
}

/// 查询WAF黑名单规则列表 
public class QuerywafBlackRulesResult:NSObject,JdCloudResult
{
    /// 黑名单列表
    var rules:[WafBlackRuleModel?]?



    public override init(){
        super.init()
    }

    enum QuerywafBlackRulesResultCodingKeys: String, CodingKey {
        case rules
    }

    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: QuerywafBlackRulesResultCodingKeys.self)
        if decoderContainer.contains(.rules)
        {
            self.rules = try decoderContainer.decode([WafBlackRuleModel?]?.self, forKey: .rules)
        }
    }
}
public extension QuerywafBlackRulesResult{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: QuerywafBlackRulesResultCodingKeys.self)
        try encoderContainer.encode(rules, forKey: .rules)
    }
}

///  禁用WAF黑名单
public class DisableWafBlackRulesRequest:JdCloudRequest
{
    /// Ids
    var ids:[String?]?

    /// RuleType
    var ruleType:String?

    /// 用户域名
    var domain:String


    public init(regionId: String,domain:String){
        self.domain = domain
        super.init(regionId: regionId)
    }


    enum DisableWafBlackRulesRequestRequestCodingKeys: String, CodingKey {
        case ids
        case ruleType
        case domain
    }

    public override func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: DisableWafBlackRulesRequestRequestCodingKeys.self)
        try encoderContainer.encode(ids, forKey: .ids)
        try encoderContainer.encode(ruleType, forKey: .ruleType)
        try encoderContainer.encode(domain, forKey: .domain)

    }
}


///  设置WAF总开关
public class SetWafSwitchRequest:JdCloudRequest
{
    /// 开关状态, on:开启,off:关闭
    var switchStatus:String?

    /// 用户域名
    var domain:String


    public init(regionId: String,domain:String){
        self.domain = domain
        super.init(regionId: regionId)
    }


    enum SetWafSwitchRequestRequestCodingKeys: String, CodingKey {
        case switchStatus
        case domain
    }

    public override func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: SetWafSwitchRequestRequestCodingKeys.self)
        try encoderContainer.encode(switchStatus, forKey: .switchStatus)
        try encoderContainer.encode(domain, forKey: .domain)

    }
}

/// 设置web防护开关 
public class UpdateWebProtectSettingsResult:NSObject,JdCloudResult
{
}
/// 新增一条白名单规则 
public class CreateWafWhiteRuleResult:NSObject,JdCloudResult
{
}

///  禁用WAF白名单
public class DisableWafWhiteRulesRequest:JdCloudRequest
{
    /// Ids
    var ids:[String?]?

    /// RuleType
    var ruleType:String?

    /// 用户域名
    var domain:String


    public init(regionId: String,domain:String){
        self.domain = domain
        super.init(regionId: regionId)
    }


    enum DisableWafWhiteRulesRequestRequestCodingKeys: String, CodingKey {
        case ids
        case ruleType
        case domain
    }

    public override func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: DisableWafWhiteRulesRequestRequestCodingKeys.self)
        try encoderContainer.encode(ids, forKey: .ids)
        try encoderContainer.encode(ruleType, forKey: .ruleType)
        try encoderContainer.encode(domain, forKey: .domain)

    }
}


///  查询WAF总开关
public class QueryWafWhiteRuleSwitchRequest:JdCloudRequest
{
    /// 用户域名
    var domain:String


    public init(regionId: String,domain:String){
        self.domain = domain
        super.init(regionId: regionId)
    }


    enum QueryWafWhiteRuleSwitchRequestRequestCodingKeys: String, CodingKey {
        case domain
    }

    public override func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: QueryWafWhiteRuleSwitchRequestRequestCodingKeys.self)
        try encoderContainer.encode(domain, forKey: .domain)

    }
}

public class UpdateWafWhiteRuleResponse:NSObject,Codable
{
    var requestId:String?;

    var error:ServiceError?;

    var result:UpdateWafWhiteRuleResult?;

    enum UpdateWafWhiteRuleResponseCodingKeys: String, CodingKey {
        case requestId
        case error
        case result
    }

    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: UpdateWafWhiteRuleResponseCodingKeys.self)
        self.requestId = try decoderContainer.decodeIfPresent(String?.self, forKey: .requestId) ?? nil
        self.error = try decoderContainer.decodeIfPresent(ServiceError?.self, forKey: .error) ?? nil
        self.result = try decoderContainer.decodeIfPresent(UpdateWafWhiteRuleResult?.self, forKey: .result) ?? nil
    }
}

public extension UpdateWafWhiteRuleResponse{
        func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: UpdateWafWhiteRuleResponseCodingKeys.self)
        try encoderContainer.encode(requestId, forKey: .requestId)
        try encoderContainer.encode(error, forKey: .error)
        try encoderContainer.encode(result, forKey: .result)
    }
}    
/// 查询WAF黑名单开关 
public class QueryWafBlackRuleSwitchResult:NSObject,JdCloudResult
{
    /// 开关状态, on:开启,off:关闭
    var switchStatus:String?



    public override init(){
        super.init()
    }

    enum QueryWafBlackRuleSwitchResultCodingKeys: String, CodingKey {
        case switchStatus
    }

    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: QueryWafBlackRuleSwitchResultCodingKeys.self)
        if decoderContainer.contains(.switchStatus)
        {
            self.switchStatus = try decoderContainer.decode(String?.self, forKey: .switchStatus)
        }
    }
}
public extension QueryWafBlackRuleSwitchResult{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: QueryWafBlackRuleSwitchResultCodingKeys.self)
        try encoderContainer.encode(switchStatus, forKey: .switchStatus)
    }
}

///  设置WAF黑名单开关
public class SetWafBlackRuleSwitchRequest:JdCloudRequest
{
    /// 开关状态, on:开启,off:关闭
    var switchStatus:String?

    /// 用户域名
    var domain:String


    public init(regionId: String,domain:String){
        self.domain = domain
        super.init(regionId: regionId)
    }


    enum SetWafBlackRuleSwitchRequestRequestCodingKeys: String, CodingKey {
        case switchStatus
        case domain
    }

    public override func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: SetWafBlackRuleSwitchRequestRequestCodingKeys.self)
        try encoderContainer.encode(switchStatus, forKey: .switchStatus)
        try encoderContainer.encode(domain, forKey: .domain)

    }
}


///  修改指定的白名单规则
public class UpdateWafWhiteRuleRequest:JdCloudRequest
{
    /// 白名单类型， uri ip geo
    var ruleType:String?

    /// 匹配模式,uri类型有效，0&#x3D;完全匹配  1&#x3D;前缀匹配 2&#x3D;包含 3&#x3D;正则 4&#x3D;大于 5&#x3D;后缀
    var matchOp:Int32?

    /// 匹配值
    var val:String?

    /// 后续处理 &quot;waf&quot; &quot;cc&quot; &quot;deny&quot;自由组合，空表示跳过后续所有阶段
    var actions:[String?]?

    /// 用户域名
    var domain:String

    /// 需要修改的白名单ID
    var id:String


    public init(regionId: String,domain:String,id:String){
        self.domain = domain
        self.id = id
        super.init(regionId: regionId)
    }


    enum UpdateWafWhiteRuleRequestRequestCodingKeys: String, CodingKey {
        case ruleType
        case matchOp
        case val
        case actions
        case domain
        case id
    }

    public override func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: UpdateWafWhiteRuleRequestRequestCodingKeys.self)
        try encoderContainer.encode(ruleType, forKey: .ruleType)
        try encoderContainer.encode(matchOp, forKey: .matchOp)
        try encoderContainer.encode(val, forKey: .val)
        try encoderContainer.encode(actions, forKey: .actions)
        try encoderContainer.encode(domain, forKey: .domain)
        try encoderContainer.encode(id, forKey: .id)

    }
}

/// 禁用CC防护规则 
public class DisableCCProtectRuleResult:NSObject,JdCloudResult
{
}
/// 设置web防护开关 
public class SetWebProtectSwitchResult:NSObject,JdCloudResult
{
}
public class QuerywafWhiteRulesResponse:NSObject,Codable
{
    var requestId:String?;

    var error:ServiceError?;

    var result:QuerywafWhiteRulesResult?;

    enum QuerywafWhiteRulesResponseCodingKeys: String, CodingKey {
        case requestId
        case error
        case result
    }

    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: QuerywafWhiteRulesResponseCodingKeys.self)
        self.requestId = try decoderContainer.decodeIfPresent(String?.self, forKey: .requestId) ?? nil
        self.error = try decoderContainer.decodeIfPresent(ServiceError?.self, forKey: .error) ?? nil
        self.result = try decoderContainer.decodeIfPresent(QuerywafWhiteRulesResult?.self, forKey: .result) ?? nil
    }
}

public extension QuerywafWhiteRulesResponse{
        func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: QuerywafWhiteRulesResponseCodingKeys.self)
        try encoderContainer.encode(requestId, forKey: .requestId)
        try encoderContainer.encode(error, forKey: .error)
        try encoderContainer.encode(result, forKey: .result)
    }
}    
public class UpdateWafBlackRuleResponse:NSObject,Codable
{
    var requestId:String?;

    var error:ServiceError?;

    var result:UpdateWafBlackRuleResult?;

    enum UpdateWafBlackRuleResponseCodingKeys: String, CodingKey {
        case requestId
        case error
        case result
    }

    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: UpdateWafBlackRuleResponseCodingKeys.self)
        self.requestId = try decoderContainer.decodeIfPresent(String?.self, forKey: .requestId) ?? nil
        self.error = try decoderContainer.decodeIfPresent(ServiceError?.self, forKey: .error) ?? nil
        self.result = try decoderContainer.decodeIfPresent(UpdateWafBlackRuleResult?.self, forKey: .result) ?? nil
    }
}

public extension UpdateWafBlackRuleResponse{
        func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: UpdateWafBlackRuleResponseCodingKeys.self)
        try encoderContainer.encode(requestId, forKey: .requestId)
        try encoderContainer.encode(error, forKey: .error)
        try encoderContainer.encode(result, forKey: .result)
    }
}    
public class QueryWafWhiteRuleSwitchResponse:NSObject,Codable
{
    var requestId:String?;

    var error:ServiceError?;

    var result:QueryWafWhiteRuleSwitchResult?;

    enum QueryWafWhiteRuleSwitchResponseCodingKeys: String, CodingKey {
        case requestId
        case error
        case result
    }

    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: QueryWafWhiteRuleSwitchResponseCodingKeys.self)
        self.requestId = try decoderContainer.decodeIfPresent(String?.self, forKey: .requestId) ?? nil
        self.error = try decoderContainer.decodeIfPresent(ServiceError?.self, forKey: .error) ?? nil
        self.result = try decoderContainer.decodeIfPresent(QueryWafWhiteRuleSwitchResult?.self, forKey: .result) ?? nil
    }
}

public extension QueryWafWhiteRuleSwitchResponse{
        func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: QueryWafWhiteRuleSwitchResponseCodingKeys.self)
        try encoderContainer.encode(requestId, forKey: .requestId)
        try encoderContainer.encode(error, forKey: .error)
        try encoderContainer.encode(result, forKey: .result)
    }
}    

///  新增一条白名单规则
public class CreateWafWhiteRuleRequest:JdCloudRequest
{
    /// 白名单类型， uri ip geo
    var ruleType:String?

    /// 匹配模式,uri类型有效，0&#x3D;完全匹配  1&#x3D;前缀匹配 2&#x3D;包含 3&#x3D;正则 4&#x3D;大于 5&#x3D;后缀
    var matchOp:Int32?

    /// 匹配值
    var val:String?

    /// 后续处理 &quot;waf&quot; &quot;cc&quot; &quot;deny&quot;自由组合，空表示跳过后续所有阶段
    var actions:[String?]?

    /// 用户域名
    var domain:String


    public init(regionId: String,domain:String){
        self.domain = domain
        super.init(regionId: regionId)
    }


    enum CreateWafWhiteRuleRequestRequestCodingKeys: String, CodingKey {
        case ruleType
        case matchOp
        case val
        case actions
        case domain
    }

    public override func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: CreateWafWhiteRuleRequestRequestCodingKeys.self)
        try encoderContainer.encode(ruleType, forKey: .ruleType)
        try encoderContainer.encode(matchOp, forKey: .matchOp)
        try encoderContainer.encode(val, forKey: .val)
        try encoderContainer.encode(actions, forKey: .actions)
        try encoderContainer.encode(domain, forKey: .domain)

    }
}

/// 禁用WAF白名单 
public class DisableWafWhiteRulesResult:NSObject,JdCloudResult
{
}
public class UpdateWebProtectSettingsResponse:NSObject,Codable
{
    var requestId:String?;

    var error:ServiceError?;

    var result:UpdateWebProtectSettingsResult?;

    enum UpdateWebProtectSettingsResponseCodingKeys: String, CodingKey {
        case requestId
        case error
        case result
    }

    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: UpdateWebProtectSettingsResponseCodingKeys.self)
        self.requestId = try decoderContainer.decodeIfPresent(String?.self, forKey: .requestId) ?? nil
        self.error = try decoderContainer.decodeIfPresent(ServiceError?.self, forKey: .error) ?? nil
        self.result = try decoderContainer.decodeIfPresent(UpdateWebProtectSettingsResult?.self, forKey: .result) ?? nil
    }
}

public extension UpdateWebProtectSettingsResponse{
        func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: UpdateWebProtectSettingsResponseCodingKeys.self)
        try encoderContainer.encode(requestId, forKey: .requestId)
        try encoderContainer.encode(error, forKey: .error)
        try encoderContainer.encode(result, forKey: .result)
    }
}    
public class QuerywafBlackRulesResponse:NSObject,Codable
{
    var requestId:String?;

    var error:ServiceError?;

    var result:QuerywafBlackRulesResult?;

    enum QuerywafBlackRulesResponseCodingKeys: String, CodingKey {
        case requestId
        case error
        case result
    }

    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: QuerywafBlackRulesResponseCodingKeys.self)
        self.requestId = try decoderContainer.decodeIfPresent(String?.self, forKey: .requestId) ?? nil
        self.error = try decoderContainer.decodeIfPresent(ServiceError?.self, forKey: .error) ?? nil
        self.result = try decoderContainer.decodeIfPresent(QuerywafBlackRulesResult?.self, forKey: .result) ?? nil
    }
}

public extension QuerywafBlackRulesResponse{
        func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: QuerywafBlackRulesResponseCodingKeys.self)
        try encoderContainer.encode(requestId, forKey: .requestId)
        try encoderContainer.encode(error, forKey: .error)
        try encoderContainer.encode(result, forKey: .result)
    }
}    
public class QueryWafRegionsResponse:NSObject,Codable
{
    var requestId:String?;

    var error:ServiceError?;

    var result:QueryWafRegionsResult?;

    enum QueryWafRegionsResponseCodingKeys: String, CodingKey {
        case requestId
        case error
        case result
    }

    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: QueryWafRegionsResponseCodingKeys.self)
        self.requestId = try decoderContainer.decodeIfPresent(String?.self, forKey: .requestId) ?? nil
        self.error = try decoderContainer.decodeIfPresent(ServiceError?.self, forKey: .error) ?? nil
        self.result = try decoderContainer.decodeIfPresent(QueryWafRegionsResult?.self, forKey: .result) ?? nil
    }
}

public extension QueryWafRegionsResponse{
        func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: QueryWafRegionsResponseCodingKeys.self)
        try encoderContainer.encode(requestId, forKey: .requestId)
        try encoderContainer.encode(error, forKey: .error)
        try encoderContainer.encode(result, forKey: .result)
    }
}    
/// 删除WAF白名单 
public class DeleteWafWhiteRulesResult:NSObject,JdCloudResult
{
}

///  删除ccProtectRule
public class DeleteCCProtectRuleRequest:JdCloudRequest
{
    /// 用户域名
    var domain:String

    /// Ids
    var ids:String


    public init(regionId: String,domain:String,ids:String){
        self.domain = domain
        self.ids = ids
        super.init(regionId: regionId)
    }


    enum DeleteCCProtectRuleRequestRequestCodingKeys: String, CodingKey {
        case domain
        case ids
    }

    public override func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: DeleteCCProtectRuleRequestRequestCodingKeys.self)
        try encoderContainer.encode(domain, forKey: .domain)
        try encoderContainer.encode(ids, forKey: .ids)

    }
}

/// 设置WAF白名单开关 
public class SetWafWhiteRuleSwitchResult:NSObject,JdCloudResult
{
}
public class DisableCCProtectRuleResponse:NSObject,Codable
{
    var requestId:String?;

    var error:ServiceError?;

    var result:DisableCCProtectRuleResult?;

    enum DisableCCProtectRuleResponseCodingKeys: String, CodingKey {
        case requestId
        case error
        case result
    }

    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: DisableCCProtectRuleResponseCodingKeys.self)
        self.requestId = try decoderContainer.decodeIfPresent(String?.self, forKey: .requestId) ?? nil
        self.error = try decoderContainer.decodeIfPresent(ServiceError?.self, forKey: .error) ?? nil
        self.result = try decoderContainer.decodeIfPresent(DisableCCProtectRuleResult?.self, forKey: .result) ?? nil
    }
}

public extension DisableCCProtectRuleResponse{
        func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: DisableCCProtectRuleResponseCodingKeys.self)
        try encoderContainer.encode(requestId, forKey: .requestId)
        try encoderContainer.encode(error, forKey: .error)
        try encoderContainer.encode(result, forKey: .result)
    }
}    

///  启用WAF黑名单
public class EnableWafBlackRulesRequest:JdCloudRequest
{
    /// Ids
    var ids:[String?]?

    /// RuleType
    var ruleType:String?

    /// 用户域名
    var domain:String


    public init(regionId: String,domain:String){
        self.domain = domain
        super.init(regionId: regionId)
    }


    enum EnableWafBlackRulesRequestRequestCodingKeys: String, CodingKey {
        case ids
        case ruleType
        case domain
    }

    public override func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: EnableWafBlackRulesRequestRequestCodingKeys.self)
        try encoderContainer.encode(ids, forKey: .ids)
        try encoderContainer.encode(ruleType, forKey: .ruleType)
        try encoderContainer.encode(domain, forKey: .domain)

    }
}

public class QueryWafBlackRuleSwitchResponse:NSObject,Codable
{
    var requestId:String?;

    var error:ServiceError?;

    var result:QueryWafBlackRuleSwitchResult?;

    enum QueryWafBlackRuleSwitchResponseCodingKeys: String, CodingKey {
        case requestId
        case error
        case result
    }

    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: QueryWafBlackRuleSwitchResponseCodingKeys.self)
        self.requestId = try decoderContainer.decodeIfPresent(String?.self, forKey: .requestId) ?? nil
        self.error = try decoderContainer.decodeIfPresent(ServiceError?.self, forKey: .error) ?? nil
        self.result = try decoderContainer.decodeIfPresent(QueryWafBlackRuleSwitchResult?.self, forKey: .result) ?? nil
    }
}

public extension QueryWafBlackRuleSwitchResponse{
        func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: QueryWafBlackRuleSwitchResponseCodingKeys.self)
        try encoderContainer.encode(requestId, forKey: .requestId)
        try encoderContainer.encode(error, forKey: .error)
        try encoderContainer.encode(result, forKey: .result)
    }
}    
/// 修改CC防护规则 
public class UpdateCCProtectRuleResult:NSObject,JdCloudResult
{
}

///  查询waf ip黑名单配置状态
public class QueryIpBlackSettingStatusRequest:JdCloudRequest
{
    /// 用户域名
    var domain:String


    public init(regionId: String,domain:String){
        self.domain = domain
        super.init(regionId: regionId)
    }


    enum QueryIpBlackSettingStatusRequestRequestCodingKeys: String, CodingKey {
        case domain
    }

    public override func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: QueryIpBlackSettingStatusRequestRequestCodingKeys.self)
        try encoderContainer.encode(domain, forKey: .domain)

    }
}

public class UpdateCCProtectRuleResponse:NSObject,Codable
{
    var requestId:String?;

    var error:ServiceError?;

    var result:UpdateCCProtectRuleResult?;

    enum UpdateCCProtectRuleResponseCodingKeys: String, CodingKey {
        case requestId
        case error
        case result
    }

    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: UpdateCCProtectRuleResponseCodingKeys.self)
        self.requestId = try decoderContainer.decodeIfPresent(String?.self, forKey: .requestId) ?? nil
        self.error = try decoderContainer.decodeIfPresent(ServiceError?.self, forKey: .error) ?? nil
        self.result = try decoderContainer.decodeIfPresent(UpdateCCProtectRuleResult?.self, forKey: .result) ?? nil
    }
}

public extension UpdateCCProtectRuleResponse{
        func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: UpdateCCProtectRuleResponseCodingKeys.self)
        try encoderContainer.encode(requestId, forKey: .requestId)
        try encoderContainer.encode(error, forKey: .error)
        try encoderContainer.encode(result, forKey: .result)
    }
}    
public class DisableWafBlackRulesResponse:NSObject,Codable
{
    var requestId:String?;

    var error:ServiceError?;

    var result:DisableWafBlackRulesResult?;

    enum DisableWafBlackRulesResponseCodingKeys: String, CodingKey {
        case requestId
        case error
        case result
    }

    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: DisableWafBlackRulesResponseCodingKeys.self)
        self.requestId = try decoderContainer.decodeIfPresent(String?.self, forKey: .requestId) ?? nil
        self.error = try decoderContainer.decodeIfPresent(ServiceError?.self, forKey: .error) ?? nil
        self.result = try decoderContainer.decodeIfPresent(DisableWafBlackRulesResult?.self, forKey: .result) ?? nil
    }
}

public extension DisableWafBlackRulesResponse{
        func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: DisableWafBlackRulesResponseCodingKeys.self)
        try encoderContainer.encode(requestId, forKey: .requestId)
        try encoderContainer.encode(error, forKey: .error)
        try encoderContainer.encode(result, forKey: .result)
    }
}    
/// 查询WAF白名单规则列表 
public class QuerywafWhiteRulesResult:NSObject,JdCloudResult
{
    /// 白名单列表
    var rules:[WafWhiteRuleModel?]?



    public override init(){
        super.init()
    }

    enum QuerywafWhiteRulesResultCodingKeys: String, CodingKey {
        case rules
    }

    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: QuerywafWhiteRulesResultCodingKeys.self)
        if decoderContainer.contains(.rules)
        {
            self.rules = try decoderContainer.decode([WafWhiteRuleModel?]?.self, forKey: .rules)
        }
    }
}
public extension QuerywafWhiteRulesResult{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: QuerywafWhiteRulesResultCodingKeys.self)
        try encoderContainer.encode(rules, forKey: .rules)
    }
}

///  查询WAF黑名单规则列表
public class QuerywafBlackRulesRequest:JdCloudRequest
{
    /// ruleType, valid values [ip, geo, uri]
    var ruleType:String

    /// ruleId, defalut empty
    var id:String?

    /// page size , default 0 to query all
    var pageSize:Int32?

    /// page index , default 0 to query all
    var pageIndex:Int32?

    /// 用户域名
    var domain:String


    public init(regionId: String,ruleType:String,domain:String){
        self.ruleType = ruleType
        self.domain = domain
        super.init(regionId: regionId)
    }


    enum QuerywafBlackRulesRequestRequestCodingKeys: String, CodingKey {
        case ruleType
        case id
        case pageSize
        case pageIndex
        case domain
    }

    public override func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: QuerywafBlackRulesRequestRequestCodingKeys.self)
        try encoderContainer.encode(ruleType, forKey: .ruleType)
        try encoderContainer.encode(id, forKey: .id)
        try encoderContainer.encode(pageSize, forKey: .pageSize)
        try encoderContainer.encode(pageIndex, forKey: .pageIndex)
        try encoderContainer.encode(domain, forKey: .domain)

    }
}

public class QueryCCProtectRulesResponse:NSObject,Codable
{
    var requestId:String?;

    var error:ServiceError?;

    var result:QueryCCProtectRulesResult?;

    enum QueryCCProtectRulesResponseCodingKeys: String, CodingKey {
        case requestId
        case error
        case result
    }

    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: QueryCCProtectRulesResponseCodingKeys.self)
        self.requestId = try decoderContainer.decodeIfPresent(String?.self, forKey: .requestId) ?? nil
        self.error = try decoderContainer.decodeIfPresent(ServiceError?.self, forKey: .error) ?? nil
        self.result = try decoderContainer.decodeIfPresent(QueryCCProtectRulesResult?.self, forKey: .result) ?? nil
    }
}

public extension QueryCCProtectRulesResponse{
        func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: QueryCCProtectRulesResponseCodingKeys.self)
        try encoderContainer.encode(requestId, forKey: .requestId)
        try encoderContainer.encode(error, forKey: .error)
        try encoderContainer.encode(result, forKey: .result)
    }
}    
public class SetWebProtectSwitchResponse:NSObject,Codable
{
    var requestId:String?;

    var error:ServiceError?;

    var result:SetWebProtectSwitchResult?;

    enum SetWebProtectSwitchResponseCodingKeys: String, CodingKey {
        case requestId
        case error
        case result
    }

    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: SetWebProtectSwitchResponseCodingKeys.self)
        self.requestId = try decoderContainer.decodeIfPresent(String?.self, forKey: .requestId) ?? nil
        self.error = try decoderContainer.decodeIfPresent(ServiceError?.self, forKey: .error) ?? nil
        self.result = try decoderContainer.decodeIfPresent(SetWebProtectSwitchResult?.self, forKey: .result) ?? nil
    }
}

public extension SetWebProtectSwitchResponse{
        func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: SetWebProtectSwitchResponseCodingKeys.self)
        try encoderContainer.encode(requestId, forKey: .requestId)
        try encoderContainer.encode(error, forKey: .error)
        try encoderContainer.encode(result, forKey: .result)
    }
}    
/// 查询WAF总开关 
public class QueryWafWhiteRuleSwitchResult:NSObject,JdCloudResult
{
    /// 开关状态, on:开启,off:关闭
    var switchStatus:String?



    public override init(){
        super.init()
    }

    enum QueryWafWhiteRuleSwitchResultCodingKeys: String, CodingKey {
        case switchStatus
    }

    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: QueryWafWhiteRuleSwitchResultCodingKeys.self)
        if decoderContainer.contains(.switchStatus)
        {
            self.switchStatus = try decoderContainer.decode(String?.self, forKey: .switchStatus)
        }
    }
}
public extension QueryWafWhiteRuleSwitchResult{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: QueryWafWhiteRuleSwitchResultCodingKeys.self)
        try encoderContainer.encode(switchStatus, forKey: .switchStatus)
    }
}
public class CreateCCProtectRuleResponse:NSObject,Codable
{
    var requestId:String?;

    var error:ServiceError?;

    var result:CreateCCProtectRuleResult?;

    enum CreateCCProtectRuleResponseCodingKeys: String, CodingKey {
        case requestId
        case error
        case result
    }

    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: CreateCCProtectRuleResponseCodingKeys.self)
        self.requestId = try decoderContainer.decodeIfPresent(String?.self, forKey: .requestId) ?? nil
        self.error = try decoderContainer.decodeIfPresent(ServiceError?.self, forKey: .error) ?? nil
        self.result = try decoderContainer.decodeIfPresent(CreateCCProtectRuleResult?.self, forKey: .result) ?? nil
    }
}

public extension CreateCCProtectRuleResponse{
        func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: CreateCCProtectRuleResponseCodingKeys.self)
        try encoderContainer.encode(requestId, forKey: .requestId)
        try encoderContainer.encode(error, forKey: .error)
        try encoderContainer.encode(result, forKey: .result)
    }
}    

///  查询CC 防护开关
public class QueryCCProtectSwitchRequest:JdCloudRequest
{
    /// 用户域名
    var domain:String


    public init(regionId: String,domain:String){
        self.domain = domain
        super.init(regionId: regionId)
    }


    enum QueryCCProtectSwitchRequestRequestCodingKeys: String, CodingKey {
        case domain
    }

    public override func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: QueryCCProtectSwitchRequestRequestCodingKeys.self)
        try encoderContainer.encode(domain, forKey: .domain)

    }
}

public class QueryWebProtectSwitchResponse:NSObject,Codable
{
    var requestId:String?;

    var error:ServiceError?;

    var result:QueryWebProtectSwitchResult?;

    enum QueryWebProtectSwitchResponseCodingKeys: String, CodingKey {
        case requestId
        case error
        case result
    }

    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: QueryWebProtectSwitchResponseCodingKeys.self)
        self.requestId = try decoderContainer.decodeIfPresent(String?.self, forKey: .requestId) ?? nil
        self.error = try decoderContainer.decodeIfPresent(ServiceError?.self, forKey: .error) ?? nil
        self.result = try decoderContainer.decodeIfPresent(QueryWebProtectSwitchResult?.self, forKey: .result) ?? nil
    }
}

public extension QueryWebProtectSwitchResponse{
        func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: QueryWebProtectSwitchResponseCodingKeys.self)
        try encoderContainer.encode(requestId, forKey: .requestId)
        try encoderContainer.encode(error, forKey: .error)
        try encoderContainer.encode(result, forKey: .result)
    }
}    
/// 查询web防护开关 
public class QueryWebProtectSwitchResult:NSObject,JdCloudResult
{
    /// 开关状态, on:开启,off:关闭
    var switchStatus:String?



    public override init(){
        super.init()
    }

    enum QueryWebProtectSwitchResultCodingKeys: String, CodingKey {
        case switchStatus
    }

    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: QueryWebProtectSwitchResultCodingKeys.self)
        if decoderContainer.contains(.switchStatus)
        {
            self.switchStatus = try decoderContainer.decode(String?.self, forKey: .switchStatus)
        }
    }
}
public extension QueryWebProtectSwitchResult{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: QueryWebProtectSwitchResultCodingKeys.self)
        try encoderContainer.encode(switchStatus, forKey: .switchStatus)
    }
}

///  删除WAF白名单
public class DeleteWafWhiteRulesRequest:JdCloudRequest
{
    /// RuleType
    var ruleType:String

    /// 用户域名
    var domain:String

    /// Ids
    var ids:String


    public init(regionId: String,ruleType:String,domain:String,ids:String){
        self.ruleType = ruleType
        self.domain = domain
        self.ids = ids
        super.init(regionId: regionId)
    }


    enum DeleteWafWhiteRulesRequestRequestCodingKeys: String, CodingKey {
        case ruleType
        case domain
        case ids
    }

    public override func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: DeleteWafWhiteRulesRequestRequestCodingKeys.self)
        try encoderContainer.encode(ruleType, forKey: .ruleType)
        try encoderContainer.encode(domain, forKey: .domain)
        try encoderContainer.encode(ids, forKey: .ids)

    }
}


///  查询waf地域信息
public class QueryWafRegionsRequest:JdCloudRequest
{
    /// skipType, valid values [skip, deny]
    var skipType:String


    public init(regionId: String,skipType:String){
        self.skipType = skipType
        super.init(regionId: regionId)
    }


    enum QueryWafRegionsRequestRequestCodingKeys: String, CodingKey {
        case skipType
    }

    public override func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: QueryWafRegionsRequestRequestCodingKeys.self)
        try encoderContainer.encode(skipType, forKey: .skipType)

    }
}


///  获取所有上层节点的ip
public class GetAllUpperNodeIpListRequest:JdCloudRequest
{
}

/// 获取所有上层节点的ip 
public class GetAllUpperNodeIpListResult:NSObject,JdCloudResult
{
    /// IpList
    var ipList:[String?]?



    public override init(){
        super.init()
    }

    enum GetAllUpperNodeIpListResultCodingKeys: String, CodingKey {
        case ipList
    }

    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: GetAllUpperNodeIpListResultCodingKeys.self)
        if decoderContainer.contains(.ipList)
        {
            self.ipList = try decoderContainer.decode([String?]?.self, forKey: .ipList)
        }
    }
}
public extension GetAllUpperNodeIpListResult{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: GetAllUpperNodeIpListResultCodingKeys.self)
        try encoderContainer.encode(ipList, forKey: .ipList)
    }
}
public class GetAllUpperNodeIpListResponse:NSObject,Codable
{
    var requestId:String?;

    var error:ServiceError?;

    var result:GetAllUpperNodeIpListResult?;

    enum GetAllUpperNodeIpListResponseCodingKeys: String, CodingKey {
        case requestId
        case error
        case result
    }

    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: GetAllUpperNodeIpListResponseCodingKeys.self)
        self.requestId = try decoderContainer.decodeIfPresent(String?.self, forKey: .requestId) ?? nil
        self.error = try decoderContainer.decodeIfPresent(ServiceError?.self, forKey: .error) ?? nil
        self.result = try decoderContainer.decodeIfPresent(GetAllUpperNodeIpListResult?.self, forKey: .result) ?? nil
    }
}

public extension GetAllUpperNodeIpListResponse{
        func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: GetAllUpperNodeIpListResponseCodingKeys.self)
        try encoderContainer.encode(requestId, forKey: .requestId)
        try encoderContainer.encode(error, forKey: .error)
        try encoderContainer.encode(result, forKey: .result)
    }
}    
/// 查找地域运营商列表 
public class QueryAreaIspListResult:NSObject,JdCloudResult
{
    /// MainLand
    var mainLand:[AreaIspItem?]?

    /// Overseas
    var overseas:[AreaIspItem?]?

    /// Isp
    var isp:[AreaIspItem?]?



    public override init(){
        super.init()
    }

    enum QueryAreaIspListResultCodingKeys: String, CodingKey {
        case mainLand
        case overseas
        case isp
    }

    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: QueryAreaIspListResultCodingKeys.self)
        if decoderContainer.contains(.mainLand)
        {
            self.mainLand = try decoderContainer.decode([AreaIspItem?]?.self, forKey: .mainLand)
        }
        if decoderContainer.contains(.overseas)
        {
            self.overseas = try decoderContainer.decode([AreaIspItem?]?.self, forKey: .overseas)
        }
        if decoderContainer.contains(.isp)
        {
            self.isp = try decoderContainer.decode([AreaIspItem?]?.self, forKey: .isp)
        }
    }
}
public extension QueryAreaIspListResult{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: QueryAreaIspListResultCodingKeys.self)
        try encoderContainer.encode(mainLand, forKey: .mainLand)
        try encoderContainer.encode(overseas, forKey: .overseas)
        try encoderContainer.encode(isp, forKey: .isp)
    }
}

///  查找地域运营商列表
public class QueryAreaIspListRequest:JdCloudRequest
{
}

public class QueryAreaIspListResponse:NSObject,Codable
{
    var requestId:String?;

    var error:ServiceError?;

    var result:QueryAreaIspListResult?;

    enum QueryAreaIspListResponseCodingKeys: String, CodingKey {
        case requestId
        case error
        case result
    }

    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: QueryAreaIspListResponseCodingKeys.self)
        self.requestId = try decoderContainer.decodeIfPresent(String?.self, forKey: .requestId) ?? nil
        self.error = try decoderContainer.decodeIfPresent(ServiceError?.self, forKey: .error) ?? nil
        self.result = try decoderContainer.decodeIfPresent(QueryAreaIspListResult?.self, forKey: .result) ?? nil
    }
}

public extension QueryAreaIspListResponse{
        func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: QueryAreaIspListResponseCodingKeys.self)
        try encoderContainer.encode(requestId, forKey: .requestId)
        try encoderContainer.encode(error, forKey: .error)
        try encoderContainer.encode(result, forKey: .result)
    }
}    
/// 查询攻击来源 
public class WafQueryPvForAreaAndIpResult:NSObject,JdCloudResult
{
    /// AreaDatas
    var areaDatas:[AreaData?]?



    public override init(){
        super.init()
    }

    enum WafQueryPvForAreaAndIpResultCodingKeys: String, CodingKey {
        case areaDatas
    }

    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: WafQueryPvForAreaAndIpResultCodingKeys.self)
        if decoderContainer.contains(.areaDatas)
        {
            self.areaDatas = try decoderContainer.decode([AreaData?]?.self, forKey: .areaDatas)
        }
    }
}
public extension WafQueryPvForAreaAndIpResult{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: WafQueryPvForAreaAndIpResultCodingKeys.self)
        try encoderContainer.encode(areaDatas, forKey: .areaDatas)
    }
}

///  查询总请求量与攻击请求量
public class WafQueryPvRequest:JdCloudRequest
{
    /// 查询起始时间,UTC时间，格式为:yyyy-MM-dd&#39;T&#39;HH:mm:ss&#39;Z&#39;，示例:2018-10-21T10:00:00Z
    var startTime:String?

    /// 查询截止时间,UTC时间，格式为:yyyy-MM-dd&#39;T&#39;HH:mm:ss&#39;Z&#39;，示例:2018-10-21T10:00:00Z
    var endTime:String?

    /// 需要查询的域名, 必须为用户pin下有权限的域名
    var domain:String?




    enum WafQueryPvRequestRequestCodingKeys: String, CodingKey {
        case startTime
        case endTime
        case domain
    }

    public override func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: WafQueryPvRequestRequestCodingKeys.self)
        try encoderContainer.encode(startTime, forKey: .startTime)
        try encoderContainer.encode(endTime, forKey: .endTime)
        try encoderContainer.encode(domain, forKey: .domain)

    }
}


///  查询攻击来源
public class WafQueryPvForAreaAndIpRequest:JdCloudRequest
{
    /// 查询起始时间,UTC时间，格式为:yyyy-MM-dd&#39;T&#39;HH:mm:ss&#39;Z&#39;，示例:2018-10-21T10:00:00Z
    var startTime:String?

    /// 查询截止时间,UTC时间，格式为:yyyy-MM-dd&#39;T&#39;HH:mm:ss&#39;Z&#39;，示例:2018-10-21T10:00:00Z
    var endTime:String?

    /// 需要查询的域名, 必须为用户pin下有权限的域名
    var domain:String?




    enum WafQueryPvForAreaAndIpRequestRequestCodingKeys: String, CodingKey {
        case startTime
        case endTime
        case domain
    }

    public override func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: WafQueryPvForAreaAndIpRequestRequestCodingKeys.self)
        try encoderContainer.encode(startTime, forKey: .startTime)
        try encoderContainer.encode(endTime, forKey: .endTime)
        try encoderContainer.encode(domain, forKey: .domain)

    }
}

public class WafQueryPvForAreaAndIpResponse:NSObject,Codable
{
    var requestId:String?;

    var error:ServiceError?;

    var result:WafQueryPvForAreaAndIpResult?;

    enum WafQueryPvForAreaAndIpResponseCodingKeys: String, CodingKey {
        case requestId
        case error
        case result
    }

    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: WafQueryPvForAreaAndIpResponseCodingKeys.self)
        self.requestId = try decoderContainer.decodeIfPresent(String?.self, forKey: .requestId) ?? nil
        self.error = try decoderContainer.decodeIfPresent(ServiceError?.self, forKey: .error) ?? nil
        self.result = try decoderContainer.decodeIfPresent(WafQueryPvForAreaAndIpResult?.self, forKey: .result) ?? nil
    }
}

public extension WafQueryPvForAreaAndIpResponse{
        func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: WafQueryPvForAreaAndIpResponseCodingKeys.self)
        try encoderContainer.encode(requestId, forKey: .requestId)
        try encoderContainer.encode(error, forKey: .error)
        try encoderContainer.encode(result, forKey: .result)
    }
}    
/// 查询攻击记录详情 
public class WafQueryAttackDetailsResult:NSObject,JdCloudResult
{
    /// Total
    var total:String?

    /// AttackDetails
    var attackDetails:[AttackDetail?]?



    public override init(){
        super.init()
    }

    enum WafQueryAttackDetailsResultCodingKeys: String, CodingKey {
        case total
        case attackDetails
    }

    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: WafQueryAttackDetailsResultCodingKeys.self)
        if decoderContainer.contains(.total)
        {
            self.total = try decoderContainer.decode(String?.self, forKey: .total)
        }
        if decoderContainer.contains(.attackDetails)
        {
            self.attackDetails = try decoderContainer.decode([AttackDetail?]?.self, forKey: .attackDetails)
        }
    }
}
public extension WafQueryAttackDetailsResult{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: WafQueryAttackDetailsResultCodingKeys.self)
        try encoderContainer.encode(total, forKey: .total)
        try encoderContainer.encode(attackDetails, forKey: .attackDetails)
    }
}

///  查询攻击记录详情
public class WafQueryAttackDetailsRequest:JdCloudRequest
{
    /// 查询起始时间,UTC时间，格式为:yyyy-MM-dd&#39;T&#39;HH:mm:ss&#39;Z&#39;，示例:2018-10-21T10:00:00Z
    var startTime:String?

    /// 查询截止时间,UTC时间，格式为:yyyy-MM-dd&#39;T&#39;HH:mm:ss&#39;Z&#39;，示例:2018-10-21T10:00:00Z
    var endTime:String?

    /// 需要查询的域名, 必须为用户pin下有权限的域名
    var domain:String?

    /// 排序字段
    var sortField:String?

    /// 排序规则：desc，asc
    var sortRule:String?

    /// 页码，从1开始
    var pageNumber:Int?

    /// 页大小，默认20
    var pageSize:Int?




    enum WafQueryAttackDetailsRequestRequestCodingKeys: String, CodingKey {
        case startTime
        case endTime
        case domain
        case sortField
        case sortRule
        case pageNumber
        case pageSize
    }

    public override func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: WafQueryAttackDetailsRequestRequestCodingKeys.self)
        try encoderContainer.encode(startTime, forKey: .startTime)
        try encoderContainer.encode(endTime, forKey: .endTime)
        try encoderContainer.encode(domain, forKey: .domain)
        try encoderContainer.encode(sortField, forKey: .sortField)
        try encoderContainer.encode(sortRule, forKey: .sortRule)
        try encoderContainer.encode(pageNumber, forKey: .pageNumber)
        try encoderContainer.encode(pageSize, forKey: .pageSize)

    }
}

/// 查询总请求量与攻击请求量 
public class WafQueryPvResult:NSObject,JdCloudResult
{
    /// Pvs
    var pvs:[PvItem?]?



    public override init(){
        super.init()
    }

    enum WafQueryPvResultCodingKeys: String, CodingKey {
        case pvs
    }

    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: WafQueryPvResultCodingKeys.self)
        if decoderContainer.contains(.pvs)
        {
            self.pvs = try decoderContainer.decode([PvItem?]?.self, forKey: .pvs)
        }
    }
}
public extension WafQueryPvResult{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: WafQueryPvResultCodingKeys.self)
        try encoderContainer.encode(pvs, forKey: .pvs)
    }
}
public class WafQueryAttackDetailsResponse:NSObject,Codable
{
    var requestId:String?;

    var error:ServiceError?;

    var result:WafQueryAttackDetailsResult?;

    enum WafQueryAttackDetailsResponseCodingKeys: String, CodingKey {
        case requestId
        case error
        case result
    }

    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: WafQueryAttackDetailsResponseCodingKeys.self)
        self.requestId = try decoderContainer.decodeIfPresent(String?.self, forKey: .requestId) ?? nil
        self.error = try decoderContainer.decodeIfPresent(ServiceError?.self, forKey: .error) ?? nil
        self.result = try decoderContainer.decodeIfPresent(WafQueryAttackDetailsResult?.self, forKey: .result) ?? nil
    }
}

public extension WafQueryAttackDetailsResponse{
        func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: WafQueryAttackDetailsResponseCodingKeys.self)
        try encoderContainer.encode(requestId, forKey: .requestId)
        try encoderContainer.encode(error, forKey: .error)
        try encoderContainer.encode(result, forKey: .result)
    }
}    
public class WafQueryPvResponse:NSObject,Codable
{
    var requestId:String?;

    var error:ServiceError?;

    var result:WafQueryPvResult?;

    enum WafQueryPvResponseCodingKeys: String, CodingKey {
        case requestId
        case error
        case result
    }

    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: WafQueryPvResponseCodingKeys.self)
        self.requestId = try decoderContainer.decodeIfPresent(String?.self, forKey: .requestId) ?? nil
        self.error = try decoderContainer.decodeIfPresent(ServiceError?.self, forKey: .error) ?? nil
        self.result = try decoderContainer.decodeIfPresent(WafQueryPvResult?.self, forKey: .result) ?? nil
    }
}

public extension WafQueryPvResponse{
        func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: WafQueryPvResponseCodingKeys.self)
        try encoderContainer.encode(requestId, forKey: .requestId)
        try encoderContainer.encode(error, forKey: .error)
        try encoderContainer.encode(result, forKey: .result)
    }
}    

///  查询域名配置状态
public class QueryDomainConfigStatusRequest:JdCloudRequest
{
    /// 任务ID
    var taskId:String


    public init(regionId: String,taskId:String){
        self.taskId = taskId
        super.init(regionId: regionId)
    }


    enum QueryDomainConfigStatusRequestRequestCodingKeys: String, CodingKey {
        case taskId
    }

    public override func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: QueryDomainConfigStatusRequestRequestCodingKeys.self)
        try encoderContainer.encode(taskId, forKey: .taskId)

    }
}

/// 查询域名配置状态 
public class QueryDomainConfigStatusResult:NSObject,JdCloudResult
{
    /// 任务状态,[success:成功,failed:失败,configuring:配置中]
    var taskStatus:String?



    public override init(){
        super.init()
    }

    enum QueryDomainConfigStatusResultCodingKeys: String, CodingKey {
        case taskStatus
    }

    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: QueryDomainConfigStatusResultCodingKeys.self)
        if decoderContainer.contains(.taskStatus)
        {
            self.taskStatus = try decoderContainer.decode(String?.self, forKey: .taskStatus)
        }
    }
}
public extension QueryDomainConfigStatusResult{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: QueryDomainConfigStatusResultCodingKeys.self)
        try encoderContainer.encode(taskStatus, forKey: .taskStatus)
    }
}
public class QueryDomainConfigStatusResponse:NSObject,Codable
{
    var requestId:String?;

    var error:ServiceError?;

    var result:QueryDomainConfigStatusResult?;

    enum QueryDomainConfigStatusResponseCodingKeys: String, CodingKey {
        case requestId
        case error
        case result
    }

    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: QueryDomainConfigStatusResponseCodingKeys.self)
        self.requestId = try decoderContainer.decodeIfPresent(String?.self, forKey: .requestId) ?? nil
        self.error = try decoderContainer.decodeIfPresent(ServiceError?.self, forKey: .error) ?? nil
        self.result = try decoderContainer.decodeIfPresent(QueryDomainConfigStatusResult?.self, forKey: .result) ?? nil
    }
}

public extension QueryDomainConfigStatusResponse{
        func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: QueryDomainConfigStatusResponseCodingKeys.self)
        try encoderContainer.encode(requestId, forKey: .requestId)
        try encoderContainer.encode(error, forKey: .error)
        try encoderContainer.encode(result, forKey: .result)
    }
}    

///  获取所有上层节点的ip
public class CheckWhetherIpBelongToJCloudRequest:JdCloudRequest
{
    /// Ips
    var ips:[String?]?




    enum CheckWhetherIpBelongToJCloudRequestRequestCodingKeys: String, CodingKey {
        case ips
    }

    public override func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: CheckWhetherIpBelongToJCloudRequestRequestCodingKeys.self)
        try encoderContainer.encode(ips, forKey: .ips)

    }
}

/// 获取所有上层节点的ip 
public class CheckWhetherIpBelongToJCloudResult:NSObject,JdCloudResult
{
    /// IpList
    var ipList:[CheckWhetherIpBelongToJCloudItem?]?



    public override init(){
        super.init()
    }

    enum CheckWhetherIpBelongToJCloudResultCodingKeys: String, CodingKey {
        case ipList
    }

    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: CheckWhetherIpBelongToJCloudResultCodingKeys.self)
        if decoderContainer.contains(.ipList)
        {
            self.ipList = try decoderContainer.decode([CheckWhetherIpBelongToJCloudItem?]?.self, forKey: .ipList)
        }
    }
}
public extension CheckWhetherIpBelongToJCloudResult{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: CheckWhetherIpBelongToJCloudResultCodingKeys.self)
        try encoderContainer.encode(ipList, forKey: .ipList)
    }
}
public class CheckWhetherIpBelongToJCloudResponse:NSObject,Codable
{
    var requestId:String?;

    var error:ServiceError?;

    var result:CheckWhetherIpBelongToJCloudResult?;

    enum CheckWhetherIpBelongToJCloudResponseCodingKeys: String, CodingKey {
        case requestId
        case error
        case result
    }

    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: CheckWhetherIpBelongToJCloudResponseCodingKeys.self)
        self.requestId = try decoderContainer.decodeIfPresent(String?.self, forKey: .requestId) ?? nil
        self.error = try decoderContainer.decodeIfPresent(ServiceError?.self, forKey: .error) ?? nil
        self.result = try decoderContainer.decodeIfPresent(CheckWhetherIpBelongToJCloudResult?.self, forKey: .result) ?? nil
    }
}

public extension CheckWhetherIpBelongToJCloudResponse{
        func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: CheckWhetherIpBelongToJCloudResponseCodingKeys.self)
        try encoderContainer.encode(requestId, forKey: .requestId)
        try encoderContainer.encode(error, forKey: .error)
        try encoderContainer.encode(result, forKey: .result)
    }
}    
public class CreateLiveDomainPrefecthTaskResponse:NSObject,Codable
{
    var requestId:String?;

    var error:ServiceError?;

    var result:CreateLiveDomainPrefecthTaskResult?;

    enum CreateLiveDomainPrefecthTaskResponseCodingKeys: String, CodingKey {
        case requestId
        case error
        case result
    }

    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: CreateLiveDomainPrefecthTaskResponseCodingKeys.self)
        self.requestId = try decoderContainer.decodeIfPresent(String?.self, forKey: .requestId) ?? nil
        self.error = try decoderContainer.decodeIfPresent(ServiceError?.self, forKey: .error) ?? nil
        self.result = try decoderContainer.decodeIfPresent(CreateLiveDomainPrefecthTaskResult?.self, forKey: .result) ?? nil
    }
}

public extension CreateLiveDomainPrefecthTaskResponse{
        func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: CreateLiveDomainPrefecthTaskResponseCodingKeys.self)
        try encoderContainer.encode(requestId, forKey: .requestId)
        try encoderContainer.encode(error, forKey: .error)
        try encoderContainer.encode(result, forKey: .result)
    }
}    
public class QueryLivePrefetchTaskResponse:NSObject,Codable
{
    var requestId:String?;

    var error:ServiceError?;

    var result:QueryLivePrefetchTaskResult?;

    enum QueryLivePrefetchTaskResponseCodingKeys: String, CodingKey {
        case requestId
        case error
        case result
    }

    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: QueryLivePrefetchTaskResponseCodingKeys.self)
        self.requestId = try decoderContainer.decodeIfPresent(String?.self, forKey: .requestId) ?? nil
        self.error = try decoderContainer.decodeIfPresent(ServiceError?.self, forKey: .error) ?? nil
        self.result = try decoderContainer.decodeIfPresent(QueryLivePrefetchTaskResult?.self, forKey: .result) ?? nil
    }
}

public extension QueryLivePrefetchTaskResponse{
        func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: QueryLivePrefetchTaskResponseCodingKeys.self)
        try encoderContainer.encode(requestId, forKey: .requestId)
        try encoderContainer.encode(error, forKey: .error)
        try encoderContainer.encode(result, forKey: .result)
    }
}    

///  创建直播预热任务
public class CreateLiveDomainPrefecthTaskRequest:JdCloudRequest
{
    /// 预热的URL
    var urlList:[String?]?

    /// 预热时长
    var prefetchTime:Int?

    /// 操作类型只能是[start,stop]中的一种
    var action:String?




    enum CreateLiveDomainPrefecthTaskRequestRequestCodingKeys: String, CodingKey {
        case urlList
        case prefetchTime
        case action
    }

    public override func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: CreateLiveDomainPrefecthTaskRequestRequestCodingKeys.self)
        try encoderContainer.encode(urlList, forKey: .urlList)
        try encoderContainer.encode(prefetchTime, forKey: .prefetchTime)
        try encoderContainer.encode(action, forKey: .action)

    }
}

/// 创建直播预热任务 
public class CreateLiveDomainPrefecthTaskResult:NSObject,JdCloudResult
{
}
/// 查询直播预热任务 
public class QueryLivePrefetchTaskResult:NSObject,JdCloudResult
{
    /// Result
    var result:[QueryLivePrefetchItem?]?



    public override init(){
        super.init()
    }

    enum QueryLivePrefetchTaskResultCodingKeys: String, CodingKey {
        case result
    }

    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: QueryLivePrefetchTaskResultCodingKeys.self)
        if decoderContainer.contains(.result)
        {
            self.result = try decoderContainer.decode([QueryLivePrefetchItem?]?.self, forKey: .result)
        }
    }
}
public extension QueryLivePrefetchTaskResult{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: QueryLivePrefetchTaskResultCodingKeys.self)
        try encoderContainer.encode(result, forKey: .result)
    }
}

///  查询直播预热任务
public class QueryLivePrefetchTaskRequest:JdCloudRequest
{
    /// 预热的URL
    var urlList:[String?]?




    enum QueryLivePrefetchTaskRequestRequestCodingKeys: String, CodingKey {
        case urlList
    }

    public override func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: QueryLivePrefetchTaskRequestRequestCodingKeys.self)
        try encoderContainer.encode(urlList, forKey: .urlList)

    }
}


///  带宽查询接口
public class QueryBandRequest:JdCloudRequest
{
    /// 查询起始时间,UTC时间，格式为:yyyy-MM-dd&#39;T&#39;HH:mm:ss&#39;Z&#39;，示例:2018-10-21T10:00:00Z
    var startTime:String?

    /// 查询截止时间,UTC时间，格式为:yyyy-MM-dd&#39;T&#39;HH:mm:ss&#39;Z&#39;，示例:2018-10-21T10:00:00Z
    var endTime:String?

    /// 需要查询的域名, 必须为用户pin下有权限的域名
    var domain:String?

    /// 地域
    var area:String?

    /// 运营商
    var isp:String?

    /// 查询周期
    var period:String?




    enum QueryBandRequestRequestCodingKeys: String, CodingKey {
        case startTime
        case endTime
        case domain
        case area
        case isp
        case period
    }

    public override func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: QueryBandRequestRequestCodingKeys.self)
        try encoderContainer.encode(startTime, forKey: .startTime)
        try encoderContainer.encode(endTime, forKey: .endTime)
        try encoderContainer.encode(domain, forKey: .domain)
        try encoderContainer.encode(area, forKey: .area)
        try encoderContainer.encode(isp, forKey: .isp)
        try encoderContainer.encode(period, forKey: .period)

    }
}


///  分地域运营商带宽查询接口
public class QueryBandWithAreaRequest:JdCloudRequest
{
    /// 查询起始时间,UTC时间，格式为:yyyy-MM-dd&#39;T&#39;HH:mm:ss&#39;Z&#39;，示例:2018-10-21T10:00:00Z
    var startTime:String?

    /// 查询截止时间,UTC时间，格式为:yyyy-MM-dd&#39;T&#39;HH:mm:ss&#39;Z&#39;，示例:2018-10-21T10:00:00Z
    var endTime:String?

    /// 需要查询的域名, 必须为用户pin下有权限的域名
    var domain:String?

    /// 地域
    var area:String?

    /// 运营商
    var isp:String?

    /// 查询周期
    var period:String?




    enum QueryBandWithAreaRequestRequestCodingKeys: String, CodingKey {
        case startTime
        case endTime
        case domain
        case area
        case isp
        case period
    }

    public override func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: QueryBandWithAreaRequestRequestCodingKeys.self)
        try encoderContainer.encode(startTime, forKey: .startTime)
        try encoderContainer.encode(endTime, forKey: .endTime)
        try encoderContainer.encode(domain, forKey: .domain)
        try encoderContainer.encode(area, forKey: .area)
        try encoderContainer.encode(isp, forKey: .isp)
        try encoderContainer.encode(period, forKey: .period)

    }
}

/// 带宽查询接口 
public class QueryBandResult:NSObject,JdCloudResult
{
    /// ResultList
    var resultList:[BandTrafficDataItem?]?



    public override init(){
        super.init()
    }

    enum QueryBandResultCodingKeys: String, CodingKey {
        case resultList
    }

    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: QueryBandResultCodingKeys.self)
        if decoderContainer.contains(.resultList)
        {
            self.resultList = try decoderContainer.decode([BandTrafficDataItem?]?.self, forKey: .resultList)
        }
    }
}
public extension QueryBandResult{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: QueryBandResultCodingKeys.self)
        try encoderContainer.encode(resultList, forKey: .resultList)
    }
}
public class QueryBandWithAreaResponse:NSObject,Codable
{
    var requestId:String?;

    var error:ServiceError?;

    var result:QueryBandWithAreaResult?;

    enum QueryBandWithAreaResponseCodingKeys: String, CodingKey {
        case requestId
        case error
        case result
    }

    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: QueryBandWithAreaResponseCodingKeys.self)
        self.requestId = try decoderContainer.decodeIfPresent(String?.self, forKey: .requestId) ?? nil
        self.error = try decoderContainer.decodeIfPresent(ServiceError?.self, forKey: .error) ?? nil
        self.result = try decoderContainer.decodeIfPresent(QueryBandWithAreaResult?.self, forKey: .result) ?? nil
    }
}

public extension QueryBandWithAreaResponse{
        func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: QueryBandWithAreaResponseCodingKeys.self)
        try encoderContainer.encode(requestId, forKey: .requestId)
        try encoderContainer.encode(error, forKey: .error)
        try encoderContainer.encode(result, forKey: .result)
    }
}    
public class QueryBandResponse:NSObject,Codable
{
    var requestId:String?;

    var error:ServiceError?;

    var result:QueryBandResult?;

    enum QueryBandResponseCodingKeys: String, CodingKey {
        case requestId
        case error
        case result
    }

    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: QueryBandResponseCodingKeys.self)
        self.requestId = try decoderContainer.decodeIfPresent(String?.self, forKey: .requestId) ?? nil
        self.error = try decoderContainer.decodeIfPresent(ServiceError?.self, forKey: .error) ?? nil
        self.result = try decoderContainer.decodeIfPresent(QueryBandResult?.self, forKey: .result) ?? nil
    }
}

public extension QueryBandResponse{
        func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: QueryBandResponseCodingKeys.self)
        try encoderContainer.encode(requestId, forKey: .requestId)
        try encoderContainer.encode(error, forKey: .error)
        try encoderContainer.encode(result, forKey: .result)
    }
}    
/// 分地域运营商带宽查询接口 
public class QueryBandWithAreaResult:NSObject,JdCloudResult
{
    /// ResultList
    var resultList:[BandTrafficWithAreaDataItem?]?



    public override init(){
        super.init()
    }

    enum QueryBandWithAreaResultCodingKeys: String, CodingKey {
        case resultList
    }

    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: QueryBandWithAreaResultCodingKeys.self)
        if decoderContainer.contains(.resultList)
        {
            self.resultList = try decoderContainer.decode([BandTrafficWithAreaDataItem?]?.self, forKey: .resultList)
        }
    }
}
public extension QueryBandWithAreaResult{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: QueryBandWithAreaResultCodingKeys.self)
        try encoderContainer.encode(resultList, forKey: .resultList)
    }
}

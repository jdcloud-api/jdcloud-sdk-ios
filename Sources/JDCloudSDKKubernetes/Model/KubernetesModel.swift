/* Copyright 2018 JDCLOUD.COM

   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at

     http:#www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.

   Cluster
   集群相关接口

   OpenAPI spec version: v1
   Contact: 

   NOTE: This class is auto generated by the jdcloud code generator program.
 */


import Foundation
///  描述配置信息
public class ValidNodeConfig:NSObject,Codable{
    /// kubernetes node 的版本
    var nodeVersion:String?
    /// 镜像id
    var imageId:[String?]?



    public override init(){
            super.init()
    }

    enum ValidNodeConfigCodingKeys: String, CodingKey {
        case nodeVersion
        case imageId
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: ValidNodeConfigCodingKeys.self)
        if decoderContainer.contains(.nodeVersion)
        {
            self.nodeVersion = try decoderContainer.decode(String?.self, forKey: .nodeVersion)
        }
        if decoderContainer.contains(.imageId)
        {
            self.imageId = try decoderContainer.decode([String?]?.self, forKey: .imageId)
        }
    }
}
public extension ValidNodeConfig{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: ValidNodeConfigCodingKeys.self)
         try encoderContainer.encode(nodeVersion, forKey: .nodeVersion)
         try encoderContainer.encode(imageId, forKey: .imageId)
    }
}
///  nodeVersion
public class NodeVersion:NSObject,Codable{
    /// 节点版本号
    var version:String?
    /// 镜像操作系统
    var imageOs:String?
    /// 版本状态
    var versionStatus:String?



    public override init(){
            super.init()
    }

    enum NodeVersionCodingKeys: String, CodingKey {
        case version
        case imageOs
        case versionStatus
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: NodeVersionCodingKeys.self)
        if decoderContainer.contains(.version)
        {
            self.version = try decoderContainer.decode(String?.self, forKey: .version)
        }
        if decoderContainer.contains(.imageOs)
        {
            self.imageOs = try decoderContainer.decode(String?.self, forKey: .imageOs)
        }
        if decoderContainer.contains(.versionStatus)
        {
            self.versionStatus = try decoderContainer.decode(String?.self, forKey: .versionStatus)
        }
    }
}
public extension NodeVersion{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: NodeVersionCodingKeys.self)
         try encoderContainer.encode(version, forKey: .version)
         try encoderContainer.encode(imageOs, forKey: .imageOs)
         try encoderContainer.encode(versionStatus, forKey: .versionStatus)
    }
}
///  masterImage
public class MasterImage:NSObject,Codable{
    /// 镜像编码
    var code:String?
    /// 虚机镜像id
    var imageId:String?
    /// 主版本号
    var mainVersion:String?
    /// 内部版本号
    var innerVersion:String?
    /// 是否默认镜像
    var isDefault:Bool?
    /// 可见度:0：所有人可见；1：授权用户可见；2：只有白名单用户可见
    var visibility:Int?
    /// 默认节点镜像编码
    var defaultNodeImageCode:String?
    /// 工作节点镜像
    var nodeImages:[NodeImage?]?



    public override init(){
            super.init()
    }

    enum MasterImageCodingKeys: String, CodingKey {
        case code
        case imageId
        case mainVersion
        case innerVersion
        case isDefault
        case visibility
        case defaultNodeImageCode
        case nodeImages
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: MasterImageCodingKeys.self)
        if decoderContainer.contains(.code)
        {
            self.code = try decoderContainer.decode(String?.self, forKey: .code)
        }
        if decoderContainer.contains(.imageId)
        {
            self.imageId = try decoderContainer.decode(String?.self, forKey: .imageId)
        }
        if decoderContainer.contains(.mainVersion)
        {
            self.mainVersion = try decoderContainer.decode(String?.self, forKey: .mainVersion)
        }
        if decoderContainer.contains(.innerVersion)
        {
            self.innerVersion = try decoderContainer.decode(String?.self, forKey: .innerVersion)
        }
        if decoderContainer.contains(.isDefault)
        {
            self.isDefault = try decoderContainer.decode(Bool?.self, forKey: .isDefault)
        }
        if decoderContainer.contains(.visibility)
        {
            self.visibility = try decoderContainer.decode(Int?.self, forKey: .visibility)
        }
        if decoderContainer.contains(.defaultNodeImageCode)
        {
            self.defaultNodeImageCode = try decoderContainer.decode(String?.self, forKey: .defaultNodeImageCode)
        }
        if decoderContainer.contains(.nodeImages)
        {
            self.nodeImages = try decoderContainer.decode([NodeImage?]?.self, forKey: .nodeImages)
        }
    }
}
public extension MasterImage{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: MasterImageCodingKeys.self)
         try encoderContainer.encode(code, forKey: .code)
         try encoderContainer.encode(imageId, forKey: .imageId)
         try encoderContainer.encode(mainVersion, forKey: .mainVersion)
         try encoderContainer.encode(innerVersion, forKey: .innerVersion)
         try encoderContainer.encode(isDefault, forKey: .isDefault)
         try encoderContainer.encode(visibility, forKey: .visibility)
         try encoderContainer.encode(defaultNodeImageCode, forKey: .defaultNodeImageCode)
         try encoderContainer.encode(nodeImages, forKey: .nodeImages)
    }
}
///  nodeImage
public class NodeImage:NSObject,Codable{
    /// 镜像编码
    var code:String?
    /// 虚机镜像id
    var imageId:String?
    /// 镜像操作系统
    var imageOs:String?
    /// 主版本号
    var mainVersion:String?
    /// 内部版本号
    var innerVersion:String?
    /// 可见度
    var visibility:Int?



    public override init(){
            super.init()
    }

    enum NodeImageCodingKeys: String, CodingKey {
        case code
        case imageId
        case imageOs
        case mainVersion
        case innerVersion
        case visibility
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: NodeImageCodingKeys.self)
        if decoderContainer.contains(.code)
        {
            self.code = try decoderContainer.decode(String?.self, forKey: .code)
        }
        if decoderContainer.contains(.imageId)
        {
            self.imageId = try decoderContainer.decode(String?.self, forKey: .imageId)
        }
        if decoderContainer.contains(.imageOs)
        {
            self.imageOs = try decoderContainer.decode(String?.self, forKey: .imageOs)
        }
        if decoderContainer.contains(.mainVersion)
        {
            self.mainVersion = try decoderContainer.decode(String?.self, forKey: .mainVersion)
        }
        if decoderContainer.contains(.innerVersion)
        {
            self.innerVersion = try decoderContainer.decode(String?.self, forKey: .innerVersion)
        }
        if decoderContainer.contains(.visibility)
        {
            self.visibility = try decoderContainer.decode(Int?.self, forKey: .visibility)
        }
    }
}
public extension NodeImage{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: NodeImageCodingKeys.self)
         try encoderContainer.encode(code, forKey: .code)
         try encoderContainer.encode(imageId, forKey: .imageId)
         try encoderContainer.encode(imageOs, forKey: .imageOs)
         try encoderContainer.encode(mainVersion, forKey: .mainVersion)
         try encoderContainer.encode(innerVersion, forKey: .innerVersion)
         try encoderContainer.encode(visibility, forKey: .visibility)
    }
}
///  masterVersion
public class MasterVersion:NSObject,Codable{
    /// 集群版本号
    var version:String?
    /// 是否默认版本
    var isDefault:Bool?
    /// 默认工作节点版本号
    var defaultNodeVersion:String?
    /// 版本状态
    var versionStatus:String?
    /// node 节点的配置
    var nodeVersions:[NodeVersion?]?



    public override init(){
            super.init()
    }

    enum MasterVersionCodingKeys: String, CodingKey {
        case version
        case isDefault
        case defaultNodeVersion
        case versionStatus
        case nodeVersions
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: MasterVersionCodingKeys.self)
        if decoderContainer.contains(.version)
        {
            self.version = try decoderContainer.decode(String?.self, forKey: .version)
        }
        if decoderContainer.contains(.isDefault)
        {
            self.isDefault = try decoderContainer.decode(Bool?.self, forKey: .isDefault)
        }
        if decoderContainer.contains(.defaultNodeVersion)
        {
            self.defaultNodeVersion = try decoderContainer.decode(String?.self, forKey: .defaultNodeVersion)
        }
        if decoderContainer.contains(.versionStatus)
        {
            self.versionStatus = try decoderContainer.decode(String?.self, forKey: .versionStatus)
        }
        if decoderContainer.contains(.nodeVersions)
        {
            self.nodeVersions = try decoderContainer.decode([NodeVersion?]?.self, forKey: .nodeVersions)
        }
    }
}
public extension MasterVersion{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: MasterVersionCodingKeys.self)
         try encoderContainer.encode(version, forKey: .version)
         try encoderContainer.encode(isDefault, forKey: .isDefault)
         try encoderContainer.encode(defaultNodeVersion, forKey: .defaultNodeVersion)
         try encoderContainer.encode(versionStatus, forKey: .versionStatus)
         try encoderContainer.encode(nodeVersions, forKey: .nodeVersions)
    }
}
///  serverConfig
public class ServerConfig:NSObject,Codable{
    /// kubernetes master 的支持版本
    var validMasterVersions:[String?]?
    /// kubernetes master 的默认版本
    var defaultMasterVersion:String?
    /// node 节点的配置
    var validNodeConfig:[ValidNodeConfig?]?



    public override init(){
            super.init()
    }

    enum ServerConfigCodingKeys: String, CodingKey {
        case validMasterVersions
        case defaultMasterVersion
        case validNodeConfig
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: ServerConfigCodingKeys.self)
        if decoderContainer.contains(.validMasterVersions)
        {
            self.validMasterVersions = try decoderContainer.decode([String?]?.self, forKey: .validMasterVersions)
        }
        if decoderContainer.contains(.defaultMasterVersion)
        {
            self.defaultMasterVersion = try decoderContainer.decode(String?.self, forKey: .defaultMasterVersion)
        }
        if decoderContainer.contains(.validNodeConfig)
        {
            self.validNodeConfig = try decoderContainer.decode([ValidNodeConfig?]?.self, forKey: .validNodeConfig)
        }
    }
}
public extension ServerConfig{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: ServerConfigCodingKeys.self)
         try encoderContainer.encode(validMasterVersions, forKey: .validMasterVersions)
         try encoderContainer.encode(defaultMasterVersion, forKey: .defaultMasterVersion)
         try encoderContainer.encode(validNodeConfig, forKey: .validNodeConfig)
    }
}
///  描述工作节点组配置信息
public class NodeGroup:NSObject,Codable{
    /// 集群 id
    var clusterId:String?
    /// 工作节点组 id
    var nodeGroupId:String?
    /// 工作节点组名称
    var name:String?
    /// 工作节点组描述
    var descriptionValue:String?
    /// 工作节点组配置信息
    var nodeConfig:NodeConfig?
    /// 工作节点版本
    var version:String?
    /// 工作节点所属的网络信息
    var nodeNetwork:NodeNetwork?
    /// 当前工作节点数量
    var currentCount:Int?
    /// 期望的工作节点数量
    var expectCount:Int?
    /// 工作节点组的ag id ，通过agid可以查询该工作节点组下的实例
    var agId:String?
    /// 工作节点组所在的 az
    var azs:[String?]?
    /// 工作节点组的 ag 对应的实例模板
    var instanceTemplateId:String?
    /// 状态  [pending,running,resizing,reconciling,deleting,deleted,error,running_with_error(部分节点有问题)]
    var state:String?
    /// Tags
    var tags:[Tag?]?
    /// 更新时间
    var updateTime:String?
    /// 状态变更原因
    var stateMessage:String?
    /// 是否开启自动修复
    var autoRepair:Bool?
    /// 控制节点操作进度
    var progress:NodeGroupProgress?
    /// 创建时间
    var createdTime:String?



    public override init(){
            super.init()
    }

    enum NodeGroupCodingKeys: String, CodingKey {
        case clusterId
        case nodeGroupId
        case name
        case descriptionValue = "description"
        case nodeConfig
        case version
        case nodeNetwork
        case currentCount
        case expectCount
        case agId
        case azs
        case instanceTemplateId
        case state
        case tags
        case updateTime
        case stateMessage
        case autoRepair
        case progress
        case createdTime
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: NodeGroupCodingKeys.self)
        if decoderContainer.contains(.clusterId)
        {
            self.clusterId = try decoderContainer.decode(String?.self, forKey: .clusterId)
        }
        if decoderContainer.contains(.nodeGroupId)
        {
            self.nodeGroupId = try decoderContainer.decode(String?.self, forKey: .nodeGroupId)
        }
        if decoderContainer.contains(.name)
        {
            self.name = try decoderContainer.decode(String?.self, forKey: .name)
        }
        if decoderContainer.contains(.descriptionValue)
        {
            self.descriptionValue = try decoderContainer.decode(String?.self, forKey: .descriptionValue)
        }
        if decoderContainer.contains(.nodeConfig)
        {
            self.nodeConfig = try decoderContainer.decode(NodeConfig?.self, forKey: .nodeConfig)
        }
        if decoderContainer.contains(.version)
        {
            self.version = try decoderContainer.decode(String?.self, forKey: .version)
        }
        if decoderContainer.contains(.nodeNetwork)
        {
            self.nodeNetwork = try decoderContainer.decode(NodeNetwork?.self, forKey: .nodeNetwork)
        }
        if decoderContainer.contains(.currentCount)
        {
            self.currentCount = try decoderContainer.decode(Int?.self, forKey: .currentCount)
        }
        if decoderContainer.contains(.expectCount)
        {
            self.expectCount = try decoderContainer.decode(Int?.self, forKey: .expectCount)
        }
        if decoderContainer.contains(.agId)
        {
            self.agId = try decoderContainer.decode(String?.self, forKey: .agId)
        }
        if decoderContainer.contains(.azs)
        {
            self.azs = try decoderContainer.decode([String?]?.self, forKey: .azs)
        }
        if decoderContainer.contains(.instanceTemplateId)
        {
            self.instanceTemplateId = try decoderContainer.decode(String?.self, forKey: .instanceTemplateId)
        }
        if decoderContainer.contains(.state)
        {
            self.state = try decoderContainer.decode(String?.self, forKey: .state)
        }
        if decoderContainer.contains(.tags)
        {
            self.tags = try decoderContainer.decode([Tag?]?.self, forKey: .tags)
        }
        if decoderContainer.contains(.updateTime)
        {
            self.updateTime = try decoderContainer.decode(String?.self, forKey: .updateTime)
        }
        if decoderContainer.contains(.stateMessage)
        {
            self.stateMessage = try decoderContainer.decode(String?.self, forKey: .stateMessage)
        }
        if decoderContainer.contains(.autoRepair)
        {
            self.autoRepair = try decoderContainer.decode(Bool?.self, forKey: .autoRepair)
        }
        if decoderContainer.contains(.progress)
        {
            self.progress = try decoderContainer.decode(NodeGroupProgress?.self, forKey: .progress)
        }
        if decoderContainer.contains(.createdTime)
        {
            self.createdTime = try decoderContainer.decode(String?.self, forKey: .createdTime)
        }
    }
}
public extension NodeGroup{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: NodeGroupCodingKeys.self)
         try encoderContainer.encode(clusterId, forKey: .clusterId)
         try encoderContainer.encode(nodeGroupId, forKey: .nodeGroupId)
         try encoderContainer.encode(name, forKey: .name)
         try encoderContainer.encode(descriptionValue, forKey: .descriptionValue)
         try encoderContainer.encode(nodeConfig, forKey: .nodeConfig)
         try encoderContainer.encode(version, forKey: .version)
         try encoderContainer.encode(nodeNetwork, forKey: .nodeNetwork)
         try encoderContainer.encode(currentCount, forKey: .currentCount)
         try encoderContainer.encode(expectCount, forKey: .expectCount)
         try encoderContainer.encode(agId, forKey: .agId)
         try encoderContainer.encode(azs, forKey: .azs)
         try encoderContainer.encode(instanceTemplateId, forKey: .instanceTemplateId)
         try encoderContainer.encode(state, forKey: .state)
         try encoderContainer.encode(tags, forKey: .tags)
         try encoderContainer.encode(updateTime, forKey: .updateTime)
         try encoderContainer.encode(stateMessage, forKey: .stateMessage)
         try encoderContainer.encode(autoRepair, forKey: .autoRepair)
         try encoderContainer.encode(progress, forKey: .progress)
         try encoderContainer.encode(createdTime, forKey: .createdTime)
    }
}
///  工作节点配置信息
public class NodeConfigSpec:NSObject,Codable{
    /// 实例类型
    /// Required:true
    var instanceType:String
    /// 工作节点版本，不指定则使用默认版本
    var version:String?
    /// 云主机密码，默认为集群密码，密码规范参考：[公共参数规范](https://docs.jdcloud.com/cn/virtual-machines/api/general_parameters)
    var password:String?
    /// 云主机SSH密钥对名称，当前仅支持一个。使用中的SSH密钥请勿删除。
    var keyNames:[String?]?
    /// 云主机系统盘配置信息
    var systemDisk:DiskSpec?
    /// 工作节点组标签，最多支持 10 个
    var labels:[LabelSpec?]?



    public  init(instanceType:String){
             self.instanceType = instanceType
    }

    enum NodeConfigSpecCodingKeys: String, CodingKey {
        case instanceType
        case version
        case password
        case keyNames
        case systemDisk
        case labels
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: NodeConfigSpecCodingKeys.self)
        self.instanceType = try decoderContainer.decode(String.self, forKey: .instanceType)
        if decoderContainer.contains(.version)
        {
            self.version = try decoderContainer.decode(String?.self, forKey: .version)
        }
        if decoderContainer.contains(.password)
        {
            self.password = try decoderContainer.decode(String?.self, forKey: .password)
        }
        if decoderContainer.contains(.keyNames)
        {
            self.keyNames = try decoderContainer.decode([String?]?.self, forKey: .keyNames)
        }
        if decoderContainer.contains(.systemDisk)
        {
            self.systemDisk = try decoderContainer.decode(DiskSpec?.self, forKey: .systemDisk)
        }
        if decoderContainer.contains(.labels)
        {
            self.labels = try decoderContainer.decode([LabelSpec?]?.self, forKey: .labels)
        }
    }
}
public extension NodeConfigSpec{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: NodeConfigSpecCodingKeys.self)
         try encoderContainer.encode(instanceType, forKey: .instanceType)
         try encoderContainer.encode(version, forKey: .version)
         try encoderContainer.encode(password, forKey: .password)
         try encoderContainer.encode(keyNames, forKey: .keyNames)
         try encoderContainer.encode(systemDisk, forKey: .systemDisk)
         try encoderContainer.encode(labels, forKey: .labels)
    }
}
///  节点网络配置
public class NodeNetwork:NSObject,Codable{
    /// pod子网的id
    var podSubnetId:String?
    /// node子网的id
    var nodeSubnetId:String?
    /// service子网的id
    var serviceSubnetId:String?
    /// service关联LB的具有公网访问能力的子网id
    var servicePublicSubnetId:String?
    /// node的cidr
    var nodeNetworkCidr:String?
    /// vpc id
    var vpcId:String?



    public override init(){
            super.init()
    }

    enum NodeNetworkCodingKeys: String, CodingKey {
        case podSubnetId
        case nodeSubnetId
        case serviceSubnetId
        case servicePublicSubnetId
        case nodeNetworkCidr
        case vpcId
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: NodeNetworkCodingKeys.self)
        if decoderContainer.contains(.podSubnetId)
        {
            self.podSubnetId = try decoderContainer.decode(String?.self, forKey: .podSubnetId)
        }
        if decoderContainer.contains(.nodeSubnetId)
        {
            self.nodeSubnetId = try decoderContainer.decode(String?.self, forKey: .nodeSubnetId)
        }
        if decoderContainer.contains(.serviceSubnetId)
        {
            self.serviceSubnetId = try decoderContainer.decode(String?.self, forKey: .serviceSubnetId)
        }
        if decoderContainer.contains(.servicePublicSubnetId)
        {
            self.servicePublicSubnetId = try decoderContainer.decode(String?.self, forKey: .servicePublicSubnetId)
        }
        if decoderContainer.contains(.nodeNetworkCidr)
        {
            self.nodeNetworkCidr = try decoderContainer.decode(String?.self, forKey: .nodeNetworkCidr)
        }
        if decoderContainer.contains(.vpcId)
        {
            self.vpcId = try decoderContainer.decode(String?.self, forKey: .vpcId)
        }
    }
}
public extension NodeNetwork{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: NodeNetworkCodingKeys.self)
         try encoderContainer.encode(podSubnetId, forKey: .podSubnetId)
         try encoderContainer.encode(nodeSubnetId, forKey: .nodeSubnetId)
         try encoderContainer.encode(serviceSubnetId, forKey: .serviceSubnetId)
         try encoderContainer.encode(servicePublicSubnetId, forKey: .servicePublicSubnetId)
         try encoderContainer.encode(nodeNetworkCidr, forKey: .nodeNetworkCidr)
         try encoderContainer.encode(vpcId, forKey: .vpcId)
    }
}
///  工作节点组进度
public class NodeGroupProgress:NSObject,Codable{
    /// 工作节点组 id
    var nodeGroupId:String?
    /// 操作类型, upgrade, downgrade, rollback
    var action:String?
    /// 总工作节点个数
    var totalCount:Int?
    /// 升级完成工作节点个数
    var updatedCount:Int?



    public override init(){
            super.init()
    }

    enum NodeGroupProgressCodingKeys: String, CodingKey {
        case nodeGroupId
        case action
        case totalCount
        case updatedCount
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: NodeGroupProgressCodingKeys.self)
        if decoderContainer.contains(.nodeGroupId)
        {
            self.nodeGroupId = try decoderContainer.decode(String?.self, forKey: .nodeGroupId)
        }
        if decoderContainer.contains(.action)
        {
            self.action = try decoderContainer.decode(String?.self, forKey: .action)
        }
        if decoderContainer.contains(.totalCount)
        {
            self.totalCount = try decoderContainer.decode(Int?.self, forKey: .totalCount)
        }
        if decoderContainer.contains(.updatedCount)
        {
            self.updatedCount = try decoderContainer.decode(Int?.self, forKey: .updatedCount)
        }
    }
}
public extension NodeGroupProgress{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: NodeGroupProgressCodingKeys.self)
         try encoderContainer.encode(nodeGroupId, forKey: .nodeGroupId)
         try encoderContainer.encode(action, forKey: .action)
         try encoderContainer.encode(totalCount, forKey: .totalCount)
         try encoderContainer.encode(updatedCount, forKey: .updatedCount)
    }
}
///  工作节点配置信息
public class NodeConfig:NSObject,Codable{
    /// 实例类型
    var instanceType:String?
    /// 镜像信息
    var imageId:String?
    /// 云主机SSH密钥对名称
    var keyNames:[String?]?
    /// 云主机磁盘类型
    var systemDiskCategory:String?
    /// 云主机云盘系统盘大小  单位(GB)
    var systemDiskSize:Int?
    /// 云主机云盘系统盘类型
    var systemDiskType:String?
    /// 云主机云盘 iops，仅限 ssd 类型云盘有效
    var systemDiskIops:Int?
    /// 工作节点组标签
    var labels:[LabelSpec?]?



    public override init(){
            super.init()
    }

    enum NodeConfigCodingKeys: String, CodingKey {
        case instanceType
        case imageId
        case keyNames
        case systemDiskCategory
        case systemDiskSize
        case systemDiskType
        case systemDiskIops
        case labels
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: NodeConfigCodingKeys.self)
        if decoderContainer.contains(.instanceType)
        {
            self.instanceType = try decoderContainer.decode(String?.self, forKey: .instanceType)
        }
        if decoderContainer.contains(.imageId)
        {
            self.imageId = try decoderContainer.decode(String?.self, forKey: .imageId)
        }
        if decoderContainer.contains(.keyNames)
        {
            self.keyNames = try decoderContainer.decode([String?]?.self, forKey: .keyNames)
        }
        if decoderContainer.contains(.systemDiskCategory)
        {
            self.systemDiskCategory = try decoderContainer.decode(String?.self, forKey: .systemDiskCategory)
        }
        if decoderContainer.contains(.systemDiskSize)
        {
            self.systemDiskSize = try decoderContainer.decode(Int?.self, forKey: .systemDiskSize)
        }
        if decoderContainer.contains(.systemDiskType)
        {
            self.systemDiskType = try decoderContainer.decode(String?.self, forKey: .systemDiskType)
        }
        if decoderContainer.contains(.systemDiskIops)
        {
            self.systemDiskIops = try decoderContainer.decode(Int?.self, forKey: .systemDiskIops)
        }
        if decoderContainer.contains(.labels)
        {
            self.labels = try decoderContainer.decode([LabelSpec?]?.self, forKey: .labels)
        }
    }
}
public extension NodeConfig{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: NodeConfigCodingKeys.self)
         try encoderContainer.encode(instanceType, forKey: .instanceType)
         try encoderContainer.encode(imageId, forKey: .imageId)
         try encoderContainer.encode(keyNames, forKey: .keyNames)
         try encoderContainer.encode(systemDiskCategory, forKey: .systemDiskCategory)
         try encoderContainer.encode(systemDiskSize, forKey: .systemDiskSize)
         try encoderContainer.encode(systemDiskType, forKey: .systemDiskType)
         try encoderContainer.encode(systemDiskIops, forKey: .systemDiskIops)
         try encoderContainer.encode(labels, forKey: .labels)
    }
}
///  工作节点组标签
public class LabelSpec:NSObject,Codable{
    /// key包含两个部分：prefix与name，name是必须的，prefix是可选的。prefix与name分隔用&quot;/&quot;。 
      /// name 可以是字母，数字，[-_.]。长度小于63。prefix：遵循DNS标准（例如：kubernetes.io/），长度不超过253 
      /// [参照](https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/#syntax-and-character-set)    
      /// 
    /// Required:true
    var key:String
    /// 字母，数字,[-_.],长度不超过63
    var value:String?



    public  init(key:String){
             self.key = key
    }

    enum LabelSpecCodingKeys: String, CodingKey {
        case key
        case value
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: LabelSpecCodingKeys.self)
        self.key = try decoderContainer.decode(String.self, forKey: .key)
        if decoderContainer.contains(.value)
        {
            self.value = try decoderContainer.decode(String?.self, forKey: .value)
        }
    }
}
public extension LabelSpec{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: LabelSpecCodingKeys.self)
         try encoderContainer.encode(key, forKey: .key)
         try encoderContainer.encode(value, forKey: .value)
    }
}
///  tag
public class Tag:NSObject,Codable{
    /// Tag键
    var key:String?
    /// Tag值
    var value:String?



    public override init(){
            super.init()
    }

    enum TagCodingKeys: String, CodingKey {
        case key
        case value
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: TagCodingKeys.self)
        if decoderContainer.contains(.key)
        {
            self.key = try decoderContainer.decode(String?.self, forKey: .key)
        }
        if decoderContainer.contains(.value)
        {
            self.value = try decoderContainer.decode(String?.self, forKey: .value)
        }
    }
}
public extension Tag{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: TagCodingKeys.self)
         try encoderContainer.encode(key, forKey: .key)
         try encoderContainer.encode(value, forKey: .value)
    }
}
///  tagFilter
public class TagFilter:NSObject,Codable{
    /// Tag键
    var key:String?
    /// Tag值
    var values:[String?]?



    public override init(){
            super.init()
    }

    enum TagFilterCodingKeys: String, CodingKey {
        case key
        case values
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: TagFilterCodingKeys.self)
        if decoderContainer.contains(.key)
        {
            self.key = try decoderContainer.decode(String?.self, forKey: .key)
        }
        if decoderContainer.contains(.values)
        {
            self.values = try decoderContainer.decode([String?]?.self, forKey: .values)
        }
    }
}
public extension TagFilter{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: TagFilterCodingKeys.self)
         try encoderContainer.encode(key, forKey: .key)
         try encoderContainer.encode(values, forKey: .values)
    }
}
///  NodeGroup 的系统盘配置
      /// - 云盘的相关参数仅限category为cloud时生效
      /// - 磁盘分类，系统盘支持local或cloud
      /// - 磁盘大小
      ///   - local：不能指定大小
      ///   - cloud：取值范围: 40-500GB，步长 10，默认为100GB
      /// - ssd.io1 云盘iops
      ///   - 步长 10
      ///   - 范围 [200，min(32000，size×50)]
      ///   - 默认值 size×30
      /// 
public class DiskSpec:NSObject,Codable{
    /// 磁盘类型，取值为cloud、local，默认为cloud
    var systemDiskCategory:String?
    /// 云盘系统盘的大小 单位(GB)
    var systemDiskSize:Int?
    /// 云盘系统盘的类型，支持 hdd.std1,ssd.gp1,ssd.io1
    var systemDiskType:String?
    /// 云盘 iops，仅限 ssd.io1 类型云盘有效
    var systemDiskIops:Int?



    public override init(){
            super.init()
    }

    enum DiskSpecCodingKeys: String, CodingKey {
        case systemDiskCategory
        case systemDiskSize
        case systemDiskType
        case systemDiskIops
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: DiskSpecCodingKeys.self)
        if decoderContainer.contains(.systemDiskCategory)
        {
            self.systemDiskCategory = try decoderContainer.decode(String?.self, forKey: .systemDiskCategory)
        }
        if decoderContainer.contains(.systemDiskSize)
        {
            self.systemDiskSize = try decoderContainer.decode(Int?.self, forKey: .systemDiskSize)
        }
        if decoderContainer.contains(.systemDiskType)
        {
            self.systemDiskType = try decoderContainer.decode(String?.self, forKey: .systemDiskType)
        }
        if decoderContainer.contains(.systemDiskIops)
        {
            self.systemDiskIops = try decoderContainer.decode(Int?.self, forKey: .systemDiskIops)
        }
    }
}
public extension DiskSpec{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: DiskSpecCodingKeys.self)
         try encoderContainer.encode(systemDiskCategory, forKey: .systemDiskCategory)
         try encoderContainer.encode(systemDiskSize, forKey: .systemDiskSize)
         try encoderContainer.encode(systemDiskType, forKey: .systemDiskType)
         try encoderContainer.encode(systemDiskIops, forKey: .systemDiskIops)
    }
}
///  quota
public class Quota:NSObject,Codable{
    /// 资源类型[kubernetes]
    var resourceType:String?
    /// 可用资源上限
    var limit:Int?
    /// 已用资源数量
    var used:Int?



    public override init(){
            super.init()
    }

    enum QuotaCodingKeys: String, CodingKey {
        case resourceType
        case limit
        case used
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: QuotaCodingKeys.self)
        if decoderContainer.contains(.resourceType)
        {
            self.resourceType = try decoderContainer.decode(String?.self, forKey: .resourceType)
        }
        if decoderContainer.contains(.limit)
        {
            self.limit = try decoderContainer.decode(Int?.self, forKey: .limit)
        }
        if decoderContainer.contains(.used)
        {
            self.used = try decoderContainer.decode(Int?.self, forKey: .used)
        }
    }
}
public extension Quota{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: QuotaCodingKeys.self)
         try encoderContainer.encode(resourceType, forKey: .resourceType)
         try encoderContainer.encode(limit, forKey: .limit)
         try encoderContainer.encode(used, forKey: .used)
    }
}
///  描述工作节点组配置信息
public class NodeGroupSpec:NSObject,Codable{
    /// 名称
    /// Required:true
    var name:String
    /// Description
    var descriptionValue:String?
    /// 工作节点组的信息
    /// Required:true
    var nodeConfig:NodeConfigSpec
    /// 工作节点组的 az，必须为集群az的子集，默认为集群az
    var azs:[String?]?
    /// 工作节点组初始化大小，至少为1个
    /// Required:true
    var initialNodeCount:Int
    /// 工作节点组运行的vpc
    /// Required:true
    var vpcId:String
    /// 工作节点组的cidr
    var nodeCidr:String?
    /// 是否开启自动修复，默认不开启。
    var autoRepair:Bool?



    public  init(name:String,nodeConfig:NodeConfigSpec,initialNodeCount:Int,vpcId:String){
             self.name = name
             self.nodeConfig = nodeConfig
             self.initialNodeCount = initialNodeCount
             self.vpcId = vpcId
    }

    enum NodeGroupSpecCodingKeys: String, CodingKey {
        case name
        case descriptionValue = "description"
        case nodeConfig
        case azs
        case initialNodeCount
        case vpcId
        case nodeCidr
        case autoRepair
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: NodeGroupSpecCodingKeys.self)
        self.name = try decoderContainer.decode(String.self, forKey: .name)
        if decoderContainer.contains(.descriptionValue)
        {
            self.descriptionValue = try decoderContainer.decode(String?.self, forKey: .descriptionValue)
        }
        self.nodeConfig = try decoderContainer.decode(NodeConfigSpec.self, forKey: .nodeConfig)
        if decoderContainer.contains(.azs)
        {
            self.azs = try decoderContainer.decode([String?]?.self, forKey: .azs)
        }
        self.initialNodeCount = try decoderContainer.decode(Int.self, forKey: .initialNodeCount)
        self.vpcId = try decoderContainer.decode(String.self, forKey: .vpcId)
        if decoderContainer.contains(.nodeCidr)
        {
            self.nodeCidr = try decoderContainer.decode(String?.self, forKey: .nodeCidr)
        }
        if decoderContainer.contains(.autoRepair)
        {
            self.autoRepair = try decoderContainer.decode(Bool?.self, forKey: .autoRepair)
        }
    }
}
public extension NodeGroupSpec{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: NodeGroupSpecCodingKeys.self)
         try encoderContainer.encode(name, forKey: .name)
         try encoderContainer.encode(descriptionValue, forKey: .descriptionValue)
         try encoderContainer.encode(nodeConfig, forKey: .nodeConfig)
         try encoderContainer.encode(azs, forKey: .azs)
         try encoderContainer.encode(initialNodeCount, forKey: .initialNodeCount)
         try encoderContainer.encode(vpcId, forKey: .vpcId)
         try encoderContainer.encode(nodeCidr, forKey: .nodeCidr)
         try encoderContainer.encode(autoRepair, forKey: .autoRepair)
    }
}
///  集群升级计划
public class UpgradePlan:NSObject,Codable{
    /// 升级方式 auto, manual
    var mode:String?
    /// 升级范围 cluster, master, nodegroup
    var scope:String?
    /// 升级计划状态 waiting, upgrading
    var state:String?
    /// master 期望版本
    var masterExpectedVersion:String?
    /// node 期望版本
    var nodeExpectedVersion:String?
    /// 升级启动时间
    var startTime:String?
    /// 持续时长
    var duration:Int?



    public override init(){
            super.init()
    }

    enum UpgradePlanCodingKeys: String, CodingKey {
        case mode
        case scope
        case state
        case masterExpectedVersion
        case nodeExpectedVersion
        case startTime
        case duration
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: UpgradePlanCodingKeys.self)
        if decoderContainer.contains(.mode)
        {
            self.mode = try decoderContainer.decode(String?.self, forKey: .mode)
        }
        if decoderContainer.contains(.scope)
        {
            self.scope = try decoderContainer.decode(String?.self, forKey: .scope)
        }
        if decoderContainer.contains(.state)
        {
            self.state = try decoderContainer.decode(String?.self, forKey: .state)
        }
        if decoderContainer.contains(.masterExpectedVersion)
        {
            self.masterExpectedVersion = try decoderContainer.decode(String?.self, forKey: .masterExpectedVersion)
        }
        if decoderContainer.contains(.nodeExpectedVersion)
        {
            self.nodeExpectedVersion = try decoderContainer.decode(String?.self, forKey: .nodeExpectedVersion)
        }
        if decoderContainer.contains(.startTime)
        {
            self.startTime = try decoderContainer.decode(String?.self, forKey: .startTime)
        }
        if decoderContainer.contains(.duration)
        {
            self.duration = try decoderContainer.decode(Int?.self, forKey: .duration)
        }
    }
}
public extension UpgradePlan{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: UpgradePlanCodingKeys.self)
         try encoderContainer.encode(mode, forKey: .mode)
         try encoderContainer.encode(scope, forKey: .scope)
         try encoderContainer.encode(state, forKey: .state)
         try encoderContainer.encode(masterExpectedVersion, forKey: .masterExpectedVersion)
         try encoderContainer.encode(nodeExpectedVersion, forKey: .nodeExpectedVersion)
         try encoderContainer.encode(startTime, forKey: .startTime)
         try encoderContainer.encode(duration, forKey: .duration)
    }
}
///  集群组件配置
public class AddonConfig:NSObject,Codable{
    /// 组件名称
    var name:String?
    /// 组件是否开启
    var enabled:Bool?



    public override init(){
            super.init()
    }

    enum AddonConfigCodingKeys: String, CodingKey {
        case name
        case enabled
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: AddonConfigCodingKeys.self)
        if decoderContainer.contains(.name)
        {
            self.name = try decoderContainer.decode(String?.self, forKey: .name)
        }
        if decoderContainer.contains(.enabled)
        {
            self.enabled = try decoderContainer.decode(Bool?.self, forKey: .enabled)
        }
    }
}
public extension AddonConfig{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: AddonConfigCodingKeys.self)
         try encoderContainer.encode(name, forKey: .name)
         try encoderContainer.encode(enabled, forKey: .enabled)
    }
}
///  集群维护窗口
public class MaintenanceWindowSpec:NSObject,Codable{
    /// daily, weekly, monthly， 默认 weekly
    var periodType:String?
    /// 维护操作开始具体日期, 仅对 periodType 取值为 weekly 或 monthly 时有效, periodType 为 weekly 时可以取 1-7, periodType 为 monthly 时可取 1-28
      /// 
    var startDay:Int?
    /// 维护操作开始具体时间. 时间格式符合RFC3339，并使用 UTC 时间，精确到分钟，例如 23:27
    /// Required:true
    var startTime:String
    /// 时区，使用 IANA 数据格式，例如：&quot;Asia/Shanghai&quot; 或 &quot;America/Los_Angeles&quot;，默认 &quot;UTC&quot;
    var timeZone:String?
    /// 维护运行时长: 4-24 小时，步长 1 小时， 默认为： 4小时
    var duration:Int?



    public  init(startTime:String){
             self.startTime = startTime
    }

    enum MaintenanceWindowSpecCodingKeys: String, CodingKey {
        case periodType
        case startDay
        case startTime
        case timeZone
        case duration
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: MaintenanceWindowSpecCodingKeys.self)
        if decoderContainer.contains(.periodType)
        {
            self.periodType = try decoderContainer.decode(String?.self, forKey: .periodType)
        }
        if decoderContainer.contains(.startDay)
        {
            self.startDay = try decoderContainer.decode(Int?.self, forKey: .startDay)
        }
        self.startTime = try decoderContainer.decode(String.self, forKey: .startTime)
        if decoderContainer.contains(.timeZone)
        {
            self.timeZone = try decoderContainer.decode(String?.self, forKey: .timeZone)
        }
        if decoderContainer.contains(.duration)
        {
            self.duration = try decoderContainer.decode(Int?.self, forKey: .duration)
        }
    }
}
public extension MaintenanceWindowSpec{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: MaintenanceWindowSpecCodingKeys.self)
         try encoderContainer.encode(periodType, forKey: .periodType)
         try encoderContainer.encode(startDay, forKey: .startDay)
         try encoderContainer.encode(startTime, forKey: .startTime)
         try encoderContainer.encode(timeZone, forKey: .timeZone)
         try encoderContainer.encode(duration, forKey: .duration)
    }
}
///  cluster 详情
public class Cluster:NSObject,Codable{
    /// 集群id
    var clusterId:String?
    /// 名称
    var name:String?
    /// 描述
    var descriptionValue:String?
    /// kubernetes的版本
    var version:String?
    /// 集群所在的az
    var azs:[String?]?
    /// 节点组列表
    var nodeGroups:[NodeGroup?]?
    /// k8s的cluster的cidr
    var clusterCidr:String?
    /// 认证信息
    var masterAuth:MasterAuth?
    /// 状态  [pending,running,reconciling（升级时的状态）, deleting, deleted, error]
    var clusterState:String?
    /// 状态变更原因
    var stateMessage:String?
    /// 更新时间
    var updateTime:String?
    /// 创建时间
    var createTime:String?
    /// 用户的AccessKey，插件调用open-api时的认证凭证
    var accessKey:String?
    /// 基本验证方式
    var basicAuth:Bool?
    /// 证书验证方式
    var clientCertificate:Bool?
    /// 用户访问的ip
    var endpoint:String?
    /// endpoint的port
    var endpointPort:String?
    /// endpoint的dashboard port
    var dashboardPort:String?
    /// deprecated 优先以addonsConfig中的配置为准 &lt;br&gt;用户是否启用集群自定义监控，true 表示开启用，false 表示未开启用
    var userMetrics:Bool?
    /// 集群组件配置信息
    var addonsConfig:[AddonConfig?]?
    /// 是否开启集群自动升级，true 表示开启，false 表示未开启
    var autoUpgrade:Bool?
    /// 配置集群维护策略
    var maintenanceWindow:MaintenanceWindow?
    /// 集群升级计划信息, 仅展示最新一条升级计划信息
    var upgradePlan:UpgradePlan?
    /// 控制节点操作进度
    var masterProgress:MaintenanceWindow?



    public override init(){
            super.init()
    }

    enum ClusterCodingKeys: String, CodingKey {
        case clusterId
        case name
        case descriptionValue = "description"
        case version
        case azs
        case nodeGroups
        case clusterCidr
        case masterAuth
        case clusterState
        case stateMessage
        case updateTime
        case createTime
        case accessKey
        case basicAuth
        case clientCertificate
        case endpoint
        case endpointPort
        case dashboardPort
        case userMetrics
        case addonsConfig
        case autoUpgrade
        case maintenanceWindow
        case upgradePlan
        case masterProgress
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: ClusterCodingKeys.self)
        if decoderContainer.contains(.clusterId)
        {
            self.clusterId = try decoderContainer.decode(String?.self, forKey: .clusterId)
        }
        if decoderContainer.contains(.name)
        {
            self.name = try decoderContainer.decode(String?.self, forKey: .name)
        }
        if decoderContainer.contains(.descriptionValue)
        {
            self.descriptionValue = try decoderContainer.decode(String?.self, forKey: .descriptionValue)
        }
        if decoderContainer.contains(.version)
        {
            self.version = try decoderContainer.decode(String?.self, forKey: .version)
        }
        if decoderContainer.contains(.azs)
        {
            self.azs = try decoderContainer.decode([String?]?.self, forKey: .azs)
        }
        if decoderContainer.contains(.nodeGroups)
        {
            self.nodeGroups = try decoderContainer.decode([NodeGroup?]?.self, forKey: .nodeGroups)
        }
        if decoderContainer.contains(.clusterCidr)
        {
            self.clusterCidr = try decoderContainer.decode(String?.self, forKey: .clusterCidr)
        }
        if decoderContainer.contains(.masterAuth)
        {
            self.masterAuth = try decoderContainer.decode(MasterAuth?.self, forKey: .masterAuth)
        }
        if decoderContainer.contains(.clusterState)
        {
            self.clusterState = try decoderContainer.decode(String?.self, forKey: .clusterState)
        }
        if decoderContainer.contains(.stateMessage)
        {
            self.stateMessage = try decoderContainer.decode(String?.self, forKey: .stateMessage)
        }
        if decoderContainer.contains(.updateTime)
        {
            self.updateTime = try decoderContainer.decode(String?.self, forKey: .updateTime)
        }
        if decoderContainer.contains(.createTime)
        {
            self.createTime = try decoderContainer.decode(String?.self, forKey: .createTime)
        }
        if decoderContainer.contains(.accessKey)
        {
            self.accessKey = try decoderContainer.decode(String?.self, forKey: .accessKey)
        }
        if decoderContainer.contains(.basicAuth)
        {
            self.basicAuth = try decoderContainer.decode(Bool?.self, forKey: .basicAuth)
        }
        if decoderContainer.contains(.clientCertificate)
        {
            self.clientCertificate = try decoderContainer.decode(Bool?.self, forKey: .clientCertificate)
        }
        if decoderContainer.contains(.endpoint)
        {
            self.endpoint = try decoderContainer.decode(String?.self, forKey: .endpoint)
        }
        if decoderContainer.contains(.endpointPort)
        {
            self.endpointPort = try decoderContainer.decode(String?.self, forKey: .endpointPort)
        }
        if decoderContainer.contains(.dashboardPort)
        {
            self.dashboardPort = try decoderContainer.decode(String?.self, forKey: .dashboardPort)
        }
        if decoderContainer.contains(.userMetrics)
        {
            self.userMetrics = try decoderContainer.decode(Bool?.self, forKey: .userMetrics)
        }
        if decoderContainer.contains(.addonsConfig)
        {
            self.addonsConfig = try decoderContainer.decode([AddonConfig?]?.self, forKey: .addonsConfig)
        }
        if decoderContainer.contains(.autoUpgrade)
        {
            self.autoUpgrade = try decoderContainer.decode(Bool?.self, forKey: .autoUpgrade)
        }
        if decoderContainer.contains(.maintenanceWindow)
        {
            self.maintenanceWindow = try decoderContainer.decode(MaintenanceWindow?.self, forKey: .maintenanceWindow)
        }
        if decoderContainer.contains(.upgradePlan)
        {
            self.upgradePlan = try decoderContainer.decode(UpgradePlan?.self, forKey: .upgradePlan)
        }
        if decoderContainer.contains(.masterProgress)
        {
            self.masterProgress = try decoderContainer.decode(MaintenanceWindow?.self, forKey: .masterProgress)
        }
    }
}
public extension Cluster{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: ClusterCodingKeys.self)
         try encoderContainer.encode(clusterId, forKey: .clusterId)
         try encoderContainer.encode(name, forKey: .name)
         try encoderContainer.encode(descriptionValue, forKey: .descriptionValue)
         try encoderContainer.encode(version, forKey: .version)
         try encoderContainer.encode(azs, forKey: .azs)
         try encoderContainer.encode(nodeGroups, forKey: .nodeGroups)
         try encoderContainer.encode(clusterCidr, forKey: .clusterCidr)
         try encoderContainer.encode(masterAuth, forKey: .masterAuth)
         try encoderContainer.encode(clusterState, forKey: .clusterState)
         try encoderContainer.encode(stateMessage, forKey: .stateMessage)
         try encoderContainer.encode(updateTime, forKey: .updateTime)
         try encoderContainer.encode(createTime, forKey: .createTime)
         try encoderContainer.encode(accessKey, forKey: .accessKey)
         try encoderContainer.encode(basicAuth, forKey: .basicAuth)
         try encoderContainer.encode(clientCertificate, forKey: .clientCertificate)
         try encoderContainer.encode(endpoint, forKey: .endpoint)
         try encoderContainer.encode(endpointPort, forKey: .endpointPort)
         try encoderContainer.encode(dashboardPort, forKey: .dashboardPort)
         try encoderContainer.encode(userMetrics, forKey: .userMetrics)
         try encoderContainer.encode(addonsConfig, forKey: .addonsConfig)
         try encoderContainer.encode(autoUpgrade, forKey: .autoUpgrade)
         try encoderContainer.encode(maintenanceWindow, forKey: .maintenanceWindow)
         try encoderContainer.encode(upgradePlan, forKey: .upgradePlan)
         try encoderContainer.encode(masterProgress, forKey: .masterProgress)
    }
}
///  集群维护窗口
public class MaintenanceWindow:NSObject,Codable{
    /// daily, weekly, monthly， 默认 weekly
    var periodType:String?
    /// 维护操作开始具体日期, 仅对 periodType 取值为 weekly 或 monthly 时有效, periodType 为 weekly 时可以取 1-7, periodType 为 monthly 时可取 1-28
      /// 
    var startDay:Int?
    /// 维护操作开始具体时间. 时间格式符合RFC3339，并使用 UTC 时间，精确到分钟，例如 23:27
    var startTime:String?
    /// 维护运行时长: 4-24 小时，步长 1 小时， 默认为： 4小时
    var duration:Int?



    public override init(){
            super.init()
    }

    enum MaintenanceWindowCodingKeys: String, CodingKey {
        case periodType
        case startDay
        case startTime
        case duration
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: MaintenanceWindowCodingKeys.self)
        if decoderContainer.contains(.periodType)
        {
            self.periodType = try decoderContainer.decode(String?.self, forKey: .periodType)
        }
        if decoderContainer.contains(.startDay)
        {
            self.startDay = try decoderContainer.decode(Int?.self, forKey: .startDay)
        }
        if decoderContainer.contains(.startTime)
        {
            self.startTime = try decoderContainer.decode(String?.self, forKey: .startTime)
        }
        if decoderContainer.contains(.duration)
        {
            self.duration = try decoderContainer.decode(Int?.self, forKey: .duration)
        }
    }
}
public extension MaintenanceWindow{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: MaintenanceWindowCodingKeys.self)
         try encoderContainer.encode(periodType, forKey: .periodType)
         try encoderContainer.encode(startDay, forKey: .startDay)
         try encoderContainer.encode(startTime, forKey: .startTime)
         try encoderContainer.encode(duration, forKey: .duration)
    }
}
///  描述一个masterAuth
public class MasterAuth:NSObject,Codable{
    /// base64编码，集群的根的public certificate
    var clusterCaCertificate:String?
    /// base64编码，客户端连接集群的public certificate
    var clientCertificate:String?
    /// base64编码, client的私钥
    var clientKey:String?
    /// basic auth的user
    var user:String?
    /// basic auth的password
    var password:String?



    public override init(){
            super.init()
    }

    enum MasterAuthCodingKeys: String, CodingKey {
        case clusterCaCertificate
        case clientCertificate
        case clientKey
        case user
        case password
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: MasterAuthCodingKeys.self)
        if decoderContainer.contains(.clusterCaCertificate)
        {
            self.clusterCaCertificate = try decoderContainer.decode(String?.self, forKey: .clusterCaCertificate)
        }
        if decoderContainer.contains(.clientCertificate)
        {
            self.clientCertificate = try decoderContainer.decode(String?.self, forKey: .clientCertificate)
        }
        if decoderContainer.contains(.clientKey)
        {
            self.clientKey = try decoderContainer.decode(String?.self, forKey: .clientKey)
        }
        if decoderContainer.contains(.user)
        {
            self.user = try decoderContainer.decode(String?.self, forKey: .user)
        }
        if decoderContainer.contains(.password)
        {
            self.password = try decoderContainer.decode(String?.self, forKey: .password)
        }
    }
}
public extension MasterAuth{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: MasterAuthCodingKeys.self)
         try encoderContainer.encode(clusterCaCertificate, forKey: .clusterCaCertificate)
         try encoderContainer.encode(clientCertificate, forKey: .clientCertificate)
         try encoderContainer.encode(clientKey, forKey: .clientKey)
         try encoderContainer.encode(user, forKey: .user)
         try encoderContainer.encode(password, forKey: .password)
    }
}
///  集群组件配置
public class AddonConfigSpec:NSObject,Codable{
    /// 组件名称，目前支持customMetrics、logging
    /// Required:true
    var name:String
    /// 是否开启该组件，默认为false。
    var enabled:Bool?



    public  init(name:String){
             self.name = name
    }

    enum AddonConfigSpecCodingKeys: String, CodingKey {
        case name
        case enabled
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: AddonConfigSpecCodingKeys.self)
        self.name = try decoderContainer.decode(String.self, forKey: .name)
        if decoderContainer.contains(.enabled)
        {
            self.enabled = try decoderContainer.decode(Bool?.self, forKey: .enabled)
        }
    }
}
public extension AddonConfigSpec{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: AddonConfigSpecCodingKeys.self)
         try encoderContainer.encode(name, forKey: .name)
         try encoderContainer.encode(enabled, forKey: .enabled)
    }
}
///  控制节点进度
public class MasterProgress:NSObject,Codable{
    /// 操作类型 upgrade,rollback,downgrade 等
    var action:String?
    /// 升级范围, 目前只有三个值：0, 50, 100
    var progress:String?



    public override init(){
            super.init()
    }

    enum MasterProgressCodingKeys: String, CodingKey {
        case action
        case progress
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: MasterProgressCodingKeys.self)
        if decoderContainer.contains(.action)
        {
            self.action = try decoderContainer.decode(String?.self, forKey: .action)
        }
        if decoderContainer.contains(.progress)
        {
            self.progress = try decoderContainer.decode(String?.self, forKey: .progress)
        }
    }
}
public extension MasterProgress{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: MasterProgressCodingKeys.self)
         try encoderContainer.encode(action, forKey: .action)
         try encoderContainer.encode(progress, forKey: .progress)
    }
}
///  创建集群请求参数模型
public class ClusterSpec:NSObject,Codable{
    /// 名称（同一用户的 cluster 允许重名）
    /// Required:true
    var name:String
    /// 描述
    var descriptionValue:String?
    /// 默认开启 basicAuth与clientCertificate最少选择一个
    var basicAuth:Bool?
    /// 默认开启 basicAuth与clientCertificate最少选择一个
    var clientCertificate:Bool?
    /// kubernetes的版本,默认1.8
    var version:String?
    /// 集群所在的az
    /// Required:true
    var azs:[String?]?
    /// 实例组
    var nodeGroup:NodeGroupSpec?
    /// k8s的master的cidr
    /// Required:true
    var masterCIDR:String
    /// 用户的AccessKey，插件调用open-api时的认证凭证
    /// Required:true
    var accessKey:String
    /// 用户的SecretKey，插件调用open-api时的认证凭证
    /// Required:true
    var secretKey:String



    public  init(name:String,azs:[String?]?,masterCIDR:String,accessKey:String,secretKey:String){
             self.name = name
             self.azs = azs
             self.masterCIDR = masterCIDR
             self.accessKey = accessKey
             self.secretKey = secretKey
    }

    enum ClusterSpecCodingKeys: String, CodingKey {
        case name
        case descriptionValue = "description"
        case basicAuth
        case clientCertificate
        case version
        case azs
        case nodeGroup
        case masterCIDR
        case accessKey
        case secretKey
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: ClusterSpecCodingKeys.self)
        self.name = try decoderContainer.decode(String.self, forKey: .name)
        if decoderContainer.contains(.descriptionValue)
        {
            self.descriptionValue = try decoderContainer.decode(String?.self, forKey: .descriptionValue)
        }
        if decoderContainer.contains(.basicAuth)
        {
            self.basicAuth = try decoderContainer.decode(Bool?.self, forKey: .basicAuth)
        }
        if decoderContainer.contains(.clientCertificate)
        {
            self.clientCertificate = try decoderContainer.decode(Bool?.self, forKey: .clientCertificate)
        }
        if decoderContainer.contains(.version)
        {
            self.version = try decoderContainer.decode(String?.self, forKey: .version)
        }
        self.azs = try decoderContainer.decode([String?]?.self, forKey: .azs)
        if decoderContainer.contains(.nodeGroup)
        {
            self.nodeGroup = try decoderContainer.decode(NodeGroupSpec?.self, forKey: .nodeGroup)
        }
        self.masterCIDR = try decoderContainer.decode(String.self, forKey: .masterCIDR)
        self.accessKey = try decoderContainer.decode(String.self, forKey: .accessKey)
        self.secretKey = try decoderContainer.decode(String.self, forKey: .secretKey)
    }
}
public extension ClusterSpec{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: ClusterSpecCodingKeys.self)
         try encoderContainer.encode(name, forKey: .name)
         try encoderContainer.encode(descriptionValue, forKey: .descriptionValue)
         try encoderContainer.encode(basicAuth, forKey: .basicAuth)
         try encoderContainer.encode(clientCertificate, forKey: .clientCertificate)
         try encoderContainer.encode(version, forKey: .version)
         try encoderContainer.encode(azs, forKey: .azs)
         try encoderContainer.encode(nodeGroup, forKey: .nodeGroup)
         try encoderContainer.encode(masterCIDR, forKey: .masterCIDR)
         try encoderContainer.encode(accessKey, forKey: .accessKey)
         try encoderContainer.encode(secretKey, forKey: .secretKey)
    }
}
///  标签信息详情
public class Label:NSObject,Codable{
    /// Key
    var key:String?
    /// Value
    var value:String?



    public override init(){
            super.init()
    }

    enum LabelCodingKeys: String, CodingKey {
        case key
        case value
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: LabelCodingKeys.self)
        if decoderContainer.contains(.key)
        {
            self.key = try decoderContainer.decode(String?.self, forKey: .key)
        }
        if decoderContainer.contains(.value)
        {
            self.value = try decoderContainer.decode(String?.self, forKey: .value)
        }
    }
}
public extension Label{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: LabelCodingKeys.self)
         try encoderContainer.encode(key, forKey: .key)
         try encoderContainer.encode(value, forKey: .value)
    }
}

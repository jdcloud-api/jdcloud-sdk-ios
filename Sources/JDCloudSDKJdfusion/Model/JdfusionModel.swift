/* Copyright 2018 JDCLOUD.COM

   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at

     http:#www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.

   Rds-Database
   与RDS数据库相关的接口

   OpenAPI spec version: v1
   Contact: 

   NOTE: This class is auto generated by the jdcloud code generator program.
 */


import Foundation
///  createSubnet
public class CreateSubnet:NSObject,Codable{
    /// Subnet的Id
    var id:String?
    /// 子网名称
    var name:String?
    /// 子网所属VPC的Id
    /// Required:true
    var vpcId:String
    /// 子网网段
    /// Required:true
    var cidrBlock:String
    /// 子网描述信息
    var descriptionValue:String?
    /// 子网所属可用域Id
    /// Required:true
    var az:String
    /// 创建时间
    var createdTime:String?
    /// 所属云提供商ID
    var cloudID:String?



    public  init(vpcId:String,cidrBlock:String,az:String){
             self.vpcId = vpcId
             self.cidrBlock = cidrBlock
             self.az = az
    }

    enum CreateSubnetCodingKeys: String, CodingKey {
        case id
        case name
        case vpcId
        case cidrBlock
        case descriptionValue = "description"
        case az
        case createdTime
        case cloudID
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: CreateSubnetCodingKeys.self)
        if decoderContainer.contains(.id)
        {
            self.id = try decoderContainer.decode(String?.self, forKey: .id)
        }
        if decoderContainer.contains(.name)
        {
            self.name = try decoderContainer.decode(String?.self, forKey: .name)
        }
        self.vpcId = try decoderContainer.decode(String.self, forKey: .vpcId)
        self.cidrBlock = try decoderContainer.decode(String.self, forKey: .cidrBlock)
        if decoderContainer.contains(.descriptionValue)
        {
            self.descriptionValue = try decoderContainer.decode(String?.self, forKey: .descriptionValue)
        }
        self.az = try decoderContainer.decode(String.self, forKey: .az)
        if decoderContainer.contains(.createdTime)
        {
            self.createdTime = try decoderContainer.decode(String?.self, forKey: .createdTime)
        }
        if decoderContainer.contains(.cloudID)
        {
            self.cloudID = try decoderContainer.decode(String?.self, forKey: .cloudID)
        }
    }
}
public extension CreateSubnet{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: CreateSubnetCodingKeys.self)
         try encoderContainer.encode(id, forKey: .id)
         try encoderContainer.encode(name, forKey: .name)
         try encoderContainer.encode(vpcId, forKey: .vpcId)
         try encoderContainer.encode(cidrBlock, forKey: .cidrBlock)
         try encoderContainer.encode(descriptionValue, forKey: .descriptionValue)
         try encoderContainer.encode(az, forKey: .az)
         try encoderContainer.encode(createdTime, forKey: .createdTime)
         try encoderContainer.encode(cloudID, forKey: .cloudID)
    }
}
///  子网属性信息
public class SubnetDesInfo:NSObject,Codable{
    /// Subnet的Id
    var id:String?
    /// 子网名称
    var name:String?
    /// 子网所属VPC的Id
    var vpcId:String?
    /// 子网网段
    var cidrBlock:String?
    /// 子网描述信息
    var descriptionValue:String?
    /// 子网所属可用域Id
    var az:String?
    /// 创建时间
    var createdTime:String?
    /// 所属云提供商ID
    var cloudID:String?



    public override init(){
            super.init()
    }

    enum SubnetDesInfoCodingKeys: String, CodingKey {
        case id
        case name
        case vpcId
        case cidrBlock
        case descriptionValue = "description"
        case az
        case createdTime
        case cloudID
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: SubnetDesInfoCodingKeys.self)
        if decoderContainer.contains(.id)
        {
            self.id = try decoderContainer.decode(String?.self, forKey: .id)
        }
        if decoderContainer.contains(.name)
        {
            self.name = try decoderContainer.decode(String?.self, forKey: .name)
        }
        if decoderContainer.contains(.vpcId)
        {
            self.vpcId = try decoderContainer.decode(String?.self, forKey: .vpcId)
        }
        if decoderContainer.contains(.cidrBlock)
        {
            self.cidrBlock = try decoderContainer.decode(String?.self, forKey: .cidrBlock)
        }
        if decoderContainer.contains(.descriptionValue)
        {
            self.descriptionValue = try decoderContainer.decode(String?.self, forKey: .descriptionValue)
        }
        if decoderContainer.contains(.az)
        {
            self.az = try decoderContainer.decode(String?.self, forKey: .az)
        }
        if decoderContainer.contains(.createdTime)
        {
            self.createdTime = try decoderContainer.decode(String?.self, forKey: .createdTime)
        }
        if decoderContainer.contains(.cloudID)
        {
            self.cloudID = try decoderContainer.decode(String?.self, forKey: .cloudID)
        }
    }
}
public extension SubnetDesInfo{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: SubnetDesInfoCodingKeys.self)
         try encoderContainer.encode(id, forKey: .id)
         try encoderContainer.encode(name, forKey: .name)
         try encoderContainer.encode(vpcId, forKey: .vpcId)
         try encoderContainer.encode(cidrBlock, forKey: .cidrBlock)
         try encoderContainer.encode(descriptionValue, forKey: .descriptionValue)
         try encoderContainer.encode(az, forKey: .az)
         try encoderContainer.encode(createdTime, forKey: .createdTime)
         try encoderContainer.encode(cloudID, forKey: .cloudID)
    }
}
///  创建资源tf信息
public class ResourceTFInfo:NSObject,Codable{
    /// uuid
    var uuid:String?
    /// 请求体
    var body:String?
    /// 状态
    var status:String?
    /// 执行结果
    var result:String?
    /// 创建时间
    var createdTime:String?
    /// 更新时间
    var updateTime:String?
    /// cloud provider
    var provider:String?
    /// cloud ID
    var cloudId:String?
    /// user ID
    var userId:String?



    public override init(){
            super.init()
    }

    enum ResourceTFInfoCodingKeys: String, CodingKey {
        case uuid
        case body
        case status
        case result
        case createdTime
        case updateTime
        case provider
        case cloudId
        case userId
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: ResourceTFInfoCodingKeys.self)
        if decoderContainer.contains(.uuid)
        {
            self.uuid = try decoderContainer.decode(String?.self, forKey: .uuid)
        }
        if decoderContainer.contains(.body)
        {
            self.body = try decoderContainer.decode(String?.self, forKey: .body)
        }
        if decoderContainer.contains(.status)
        {
            self.status = try decoderContainer.decode(String?.self, forKey: .status)
        }
        if decoderContainer.contains(.result)
        {
            self.result = try decoderContainer.decode(String?.self, forKey: .result)
        }
        if decoderContainer.contains(.createdTime)
        {
            self.createdTime = try decoderContainer.decode(String?.self, forKey: .createdTime)
        }
        if decoderContainer.contains(.updateTime)
        {
            self.updateTime = try decoderContainer.decode(String?.self, forKey: .updateTime)
        }
        if decoderContainer.contains(.provider)
        {
            self.provider = try decoderContainer.decode(String?.self, forKey: .provider)
        }
        if decoderContainer.contains(.cloudId)
        {
            self.cloudId = try decoderContainer.decode(String?.self, forKey: .cloudId)
        }
        if decoderContainer.contains(.userId)
        {
            self.userId = try decoderContainer.decode(String?.self, forKey: .userId)
        }
    }
}
public extension ResourceTFInfo{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: ResourceTFInfoCodingKeys.self)
         try encoderContainer.encode(uuid, forKey: .uuid)
         try encoderContainer.encode(body, forKey: .body)
         try encoderContainer.encode(status, forKey: .status)
         try encoderContainer.encode(result, forKey: .result)
         try encoderContainer.encode(createdTime, forKey: .createdTime)
         try encoderContainer.encode(updateTime, forKey: .updateTime)
         try encoderContainer.encode(provider, forKey: .provider)
         try encoderContainer.encode(cloudId, forKey: .cloudId)
         try encoderContainer.encode(userId, forKey: .userId)
    }
}
///  VPC 信息
public class VpcInfo:NSObject,Codable{
    /// Vpc的Id
    var id:String?
    /// 私有网络名称
    var name:String?
    /// 地址范围
    var cidrBlock:String?
    /// VPC 描述
    var descriptionValue:String?
    /// 创建时间
    var createdTime:String?
    /// 所属云提供商ID
    var cloudID:String?



    public override init(){
            super.init()
    }

    enum VpcInfoCodingKeys: String, CodingKey {
        case id
        case name
        case cidrBlock
        case descriptionValue = "description"
        case createdTime
        case cloudID
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: VpcInfoCodingKeys.self)
        if decoderContainer.contains(.id)
        {
            self.id = try decoderContainer.decode(String?.self, forKey: .id)
        }
        if decoderContainer.contains(.name)
        {
            self.name = try decoderContainer.decode(String?.self, forKey: .name)
        }
        if decoderContainer.contains(.cidrBlock)
        {
            self.cidrBlock = try decoderContainer.decode(String?.self, forKey: .cidrBlock)
        }
        if decoderContainer.contains(.descriptionValue)
        {
            self.descriptionValue = try decoderContainer.decode(String?.self, forKey: .descriptionValue)
        }
        if decoderContainer.contains(.createdTime)
        {
            self.createdTime = try decoderContainer.decode(String?.self, forKey: .createdTime)
        }
        if decoderContainer.contains(.cloudID)
        {
            self.cloudID = try decoderContainer.decode(String?.self, forKey: .cloudID)
        }
    }
}
public extension VpcInfo{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: VpcInfoCodingKeys.self)
         try encoderContainer.encode(id, forKey: .id)
         try encoderContainer.encode(name, forKey: .name)
         try encoderContainer.encode(cidrBlock, forKey: .cidrBlock)
         try encoderContainer.encode(descriptionValue, forKey: .descriptionValue)
         try encoderContainer.encode(createdTime, forKey: .createdTime)
         try encoderContainer.encode(cloudID, forKey: .cloudID)
    }
}
///  vpcInfoDetail
public class VpcInfoDetail:NSObject,Codable{
    /// Vpc的Id
    var id:String?
    /// 私有网络名称
    var name:String?
    /// 地址范围
    var cidrBlock:String?
    /// VPC 描述
    var descriptionValue:String?
    /// 创建时间
    var createdTime:String?
    /// 所属云提供商ID
    var cloudID:String?
    /// 私有网络包含的子网列表
    var subnets:[SubnetInfo?]?
    /// 路由表ID集合
    var routeTableIds:[String?]?



    public override init(){
            super.init()
    }

    enum VpcInfoDetailCodingKeys: String, CodingKey {
        case id
        case name
        case cidrBlock
        case descriptionValue = "description"
        case createdTime
        case cloudID
        case subnets
        case routeTableIds
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: VpcInfoDetailCodingKeys.self)
        if decoderContainer.contains(.id)
        {
            self.id = try decoderContainer.decode(String?.self, forKey: .id)
        }
        if decoderContainer.contains(.name)
        {
            self.name = try decoderContainer.decode(String?.self, forKey: .name)
        }
        if decoderContainer.contains(.cidrBlock)
        {
            self.cidrBlock = try decoderContainer.decode(String?.self, forKey: .cidrBlock)
        }
        if decoderContainer.contains(.descriptionValue)
        {
            self.descriptionValue = try decoderContainer.decode(String?.self, forKey: .descriptionValue)
        }
        if decoderContainer.contains(.createdTime)
        {
            self.createdTime = try decoderContainer.decode(String?.self, forKey: .createdTime)
        }
        if decoderContainer.contains(.cloudID)
        {
            self.cloudID = try decoderContainer.decode(String?.self, forKey: .cloudID)
        }
        if decoderContainer.contains(.subnets)
        {
            self.subnets = try decoderContainer.decode([SubnetInfo?]?.self, forKey: .subnets)
        }
        if decoderContainer.contains(.routeTableIds)
        {
            self.routeTableIds = try decoderContainer.decode([String?]?.self, forKey: .routeTableIds)
        }
    }
}
public extension VpcInfoDetail{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: VpcInfoDetailCodingKeys.self)
         try encoderContainer.encode(id, forKey: .id)
         try encoderContainer.encode(name, forKey: .name)
         try encoderContainer.encode(cidrBlock, forKey: .cidrBlock)
         try encoderContainer.encode(descriptionValue, forKey: .descriptionValue)
         try encoderContainer.encode(createdTime, forKey: .createdTime)
         try encoderContainer.encode(cloudID, forKey: .cloudID)
         try encoderContainer.encode(subnets, forKey: .subnets)
         try encoderContainer.encode(routeTableIds, forKey: .routeTableIds)
    }
}
///  vpcListInfo
public class VpcListInfo:NSObject,Codable{
    /// Vpc的Id
    var id:String?
    /// 私有网络名称
    var name:String?
    /// VPC的网段
    var cidrBlock:String?
    /// VPC 描述
    var descriptionValue:String?
    /// 创建时间
    var createdTime:String?
    /// 所属云提供商ID
    var cloudID:String?
    /// 私有网络包含的子网列表
    var subnetIds:[String?]?
    /// 路由表ID集合
    var routeTableIds:[String?]?



    public override init(){
            super.init()
    }

    enum VpcListInfoCodingKeys: String, CodingKey {
        case id
        case name
        case cidrBlock
        case descriptionValue = "description"
        case createdTime
        case cloudID
        case subnetIds
        case routeTableIds
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: VpcListInfoCodingKeys.self)
        if decoderContainer.contains(.id)
        {
            self.id = try decoderContainer.decode(String?.self, forKey: .id)
        }
        if decoderContainer.contains(.name)
        {
            self.name = try decoderContainer.decode(String?.self, forKey: .name)
        }
        if decoderContainer.contains(.cidrBlock)
        {
            self.cidrBlock = try decoderContainer.decode(String?.self, forKey: .cidrBlock)
        }
        if decoderContainer.contains(.descriptionValue)
        {
            self.descriptionValue = try decoderContainer.decode(String?.self, forKey: .descriptionValue)
        }
        if decoderContainer.contains(.createdTime)
        {
            self.createdTime = try decoderContainer.decode(String?.self, forKey: .createdTime)
        }
        if decoderContainer.contains(.cloudID)
        {
            self.cloudID = try decoderContainer.decode(String?.self, forKey: .cloudID)
        }
        if decoderContainer.contains(.subnetIds)
        {
            self.subnetIds = try decoderContainer.decode([String?]?.self, forKey: .subnetIds)
        }
        if decoderContainer.contains(.routeTableIds)
        {
            self.routeTableIds = try decoderContainer.decode([String?]?.self, forKey: .routeTableIds)
        }
    }
}
public extension VpcListInfo{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: VpcListInfoCodingKeys.self)
         try encoderContainer.encode(id, forKey: .id)
         try encoderContainer.encode(name, forKey: .name)
         try encoderContainer.encode(cidrBlock, forKey: .cidrBlock)
         try encoderContainer.encode(descriptionValue, forKey: .descriptionValue)
         try encoderContainer.encode(createdTime, forKey: .createdTime)
         try encoderContainer.encode(cloudID, forKey: .cloudID)
         try encoderContainer.encode(subnetIds, forKey: .subnetIds)
         try encoderContainer.encode(routeTableIds, forKey: .routeTableIds)
    }
}
///  子网属性信息
public class SubnetInfo:NSObject,Codable{
    /// Subnet的Id
    var id:String?
    /// 子网所属VPC的Id
    var vpcId:String?
    /// 子网名称
    var subnetName:String?
    /// 子网网段
    var cidrBlock:String?
    /// 子网可用ip数量
    var availableIpCount:Int32?
    /// 子网描述信息
    var descriptionValue:String?
    /// 子网的结束地址
    var endIp:String?
    /// 子网关联的路由表Id
    var routeTableId:String?
    /// 子网的起始地址
    var startIp:String?
    /// 所属云提供商ID
    var cloudID:String?
    /// 可用区
    var az:String?
    /// 子网创建时间
    var createdTime:String?



    public override init(){
            super.init()
    }

    enum SubnetInfoCodingKeys: String, CodingKey {
        case id
        case vpcId
        case subnetName
        case cidrBlock
        case availableIpCount
        case descriptionValue = "description"
        case endIp
        case routeTableId
        case startIp
        case cloudID
        case az
        case createdTime
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: SubnetInfoCodingKeys.self)
        if decoderContainer.contains(.id)
        {
            self.id = try decoderContainer.decode(String?.self, forKey: .id)
        }
        if decoderContainer.contains(.vpcId)
        {
            self.vpcId = try decoderContainer.decode(String?.self, forKey: .vpcId)
        }
        if decoderContainer.contains(.subnetName)
        {
            self.subnetName = try decoderContainer.decode(String?.self, forKey: .subnetName)
        }
        if decoderContainer.contains(.cidrBlock)
        {
            self.cidrBlock = try decoderContainer.decode(String?.self, forKey: .cidrBlock)
        }
        if decoderContainer.contains(.availableIpCount)
        {
            self.availableIpCount = try decoderContainer.decode(Int32?.self, forKey: .availableIpCount)
        }
        if decoderContainer.contains(.descriptionValue)
        {
            self.descriptionValue = try decoderContainer.decode(String?.self, forKey: .descriptionValue)
        }
        if decoderContainer.contains(.endIp)
        {
            self.endIp = try decoderContainer.decode(String?.self, forKey: .endIp)
        }
        if decoderContainer.contains(.routeTableId)
        {
            self.routeTableId = try decoderContainer.decode(String?.self, forKey: .routeTableId)
        }
        if decoderContainer.contains(.startIp)
        {
            self.startIp = try decoderContainer.decode(String?.self, forKey: .startIp)
        }
        if decoderContainer.contains(.cloudID)
        {
            self.cloudID = try decoderContainer.decode(String?.self, forKey: .cloudID)
        }
        if decoderContainer.contains(.az)
        {
            self.az = try decoderContainer.decode(String?.self, forKey: .az)
        }
        if decoderContainer.contains(.createdTime)
        {
            self.createdTime = try decoderContainer.decode(String?.self, forKey: .createdTime)
        }
    }
}
public extension SubnetInfo{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: SubnetInfoCodingKeys.self)
         try encoderContainer.encode(id, forKey: .id)
         try encoderContainer.encode(vpcId, forKey: .vpcId)
         try encoderContainer.encode(subnetName, forKey: .subnetName)
         try encoderContainer.encode(cidrBlock, forKey: .cidrBlock)
         try encoderContainer.encode(availableIpCount, forKey: .availableIpCount)
         try encoderContainer.encode(descriptionValue, forKey: .descriptionValue)
         try encoderContainer.encode(endIp, forKey: .endIp)
         try encoderContainer.encode(routeTableId, forKey: .routeTableId)
         try encoderContainer.encode(startIp, forKey: .startIp)
         try encoderContainer.encode(cloudID, forKey: .cloudID)
         try encoderContainer.encode(az, forKey: .az)
         try encoderContainer.encode(createdTime, forKey: .createdTime)
    }
}
///  系统盘配置
public class SysDiskInfo:NSObject,Codable{
    /// 硬盘大小
    var diskSize:Int32?
    /// 磁盘介质分类，目前为预留，可以为空
    var diskMediumType:String?
    /// 磁盘名称
    var diskName:String?
    /// 磁盘是否随主机一起删除
    var autoDelete:String?
    /// 磁盘状态
    var status:String?



    public override init(){
            super.init()
    }

    enum SysDiskInfoCodingKeys: String, CodingKey {
        case diskSize
        case diskMediumType
        case diskName
        case autoDelete
        case status
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: SysDiskInfoCodingKeys.self)
        if decoderContainer.contains(.diskSize)
        {
            self.diskSize = try decoderContainer.decode(Int32?.self, forKey: .diskSize)
        }
        if decoderContainer.contains(.diskMediumType)
        {
            self.diskMediumType = try decoderContainer.decode(String?.self, forKey: .diskMediumType)
        }
        if decoderContainer.contains(.diskName)
        {
            self.diskName = try decoderContainer.decode(String?.self, forKey: .diskName)
        }
        if decoderContainer.contains(.autoDelete)
        {
            self.autoDelete = try decoderContainer.decode(String?.self, forKey: .autoDelete)
        }
        if decoderContainer.contains(.status)
        {
            self.status = try decoderContainer.decode(String?.self, forKey: .status)
        }
    }
}
public extension SysDiskInfo{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: SysDiskInfoCodingKeys.self)
         try encoderContainer.encode(diskSize, forKey: .diskSize)
         try encoderContainer.encode(diskMediumType, forKey: .diskMediumType)
         try encoderContainer.encode(diskName, forKey: .diskName)
         try encoderContainer.encode(autoDelete, forKey: .autoDelete)
         try encoderContainer.encode(status, forKey: .status)
    }
}
///  vmInfoDetail
public class VmInfoDetail:NSObject,Codable{
    /// 资源ID，如果为空，则执行创建操作，否则执行修改操作
    var id:String?
    /// 可用区,根据各云平台规范填写
    var region:String?
    /// 云主机所属的可用区
    var az:String?
    /// 云主机名称
    var name:String?
    /// 云主机
    var hostName:String?
    /// 镜像ID
    var imageId:String?
    /// ImageType
    var imageType:ImageType?
    /// InstanceType
    var instanceType:InstanceType?
    /// 云主机描述
    var descriptionValue:String?
    /// 子网ID
    var subnetId:String?
    /// Tags
    var tags:[Tag?]?
    /// 所属云提供商ID
    var cloudID:String?
    /// 密钥对名称,jd当前只支持传入一个
    var keyNames:[String?]?
    /// 主网卡主IP绑定弹性IP的地址
    var elasticIpAddress:String?
    /// 私有ip地址
    var privateIpAddress:String?
    /// 安全组ID
    var securityGroupIds:[String?]?
    /// 云主机状态
    var status:String?
    /// 创建时间
    var createdTime:String?
    /// SysDiskInfo
    var sysDiskInfo:SysDiskInfo?
    /// 数据盘配置信息
    var dataDiskAttachments:[DataDiskAttachment?]?
    /// PrimaryNetworkInterface
    var primaryNetworkInterface:NetAttachment?
    /// 辅助网卡配置
    var secondaryNetworkInterfaces:[NetAttachment?]?
    /// 扩展信息
    var metadata:String?



    public override init(){
            super.init()
    }

    enum VmInfoDetailCodingKeys: String, CodingKey {
        case id
        case region
        case az
        case name
        case hostName
        case imageId
        case imageType
        case instanceType
        case descriptionValue = "description"
        case subnetId
        case tags
        case cloudID
        case keyNames
        case elasticIpAddress
        case privateIpAddress
        case securityGroupIds
        case status
        case createdTime
        case sysDiskInfo
        case dataDiskAttachments
        case primaryNetworkInterface
        case secondaryNetworkInterfaces
        case metadata
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: VmInfoDetailCodingKeys.self)
        if decoderContainer.contains(.id)
        {
            self.id = try decoderContainer.decode(String?.self, forKey: .id)
        }
        if decoderContainer.contains(.region)
        {
            self.region = try decoderContainer.decode(String?.self, forKey: .region)
        }
        if decoderContainer.contains(.az)
        {
            self.az = try decoderContainer.decode(String?.self, forKey: .az)
        }
        if decoderContainer.contains(.name)
        {
            self.name = try decoderContainer.decode(String?.self, forKey: .name)
        }
        if decoderContainer.contains(.hostName)
        {
            self.hostName = try decoderContainer.decode(String?.self, forKey: .hostName)
        }
        if decoderContainer.contains(.imageId)
        {
            self.imageId = try decoderContainer.decode(String?.self, forKey: .imageId)
        }
        if decoderContainer.contains(.imageType)
        {
            self.imageType = try decoderContainer.decode(ImageType?.self, forKey: .imageType)
        }
        if decoderContainer.contains(.instanceType)
        {
            self.instanceType = try decoderContainer.decode(InstanceType?.self, forKey: .instanceType)
        }
        if decoderContainer.contains(.descriptionValue)
        {
            self.descriptionValue = try decoderContainer.decode(String?.self, forKey: .descriptionValue)
        }
        if decoderContainer.contains(.subnetId)
        {
            self.subnetId = try decoderContainer.decode(String?.self, forKey: .subnetId)
        }
        if decoderContainer.contains(.tags)
        {
            self.tags = try decoderContainer.decode([Tag?]?.self, forKey: .tags)
        }
        if decoderContainer.contains(.cloudID)
        {
            self.cloudID = try decoderContainer.decode(String?.self, forKey: .cloudID)
        }
        if decoderContainer.contains(.keyNames)
        {
            self.keyNames = try decoderContainer.decode([String?]?.self, forKey: .keyNames)
        }
        if decoderContainer.contains(.elasticIpAddress)
        {
            self.elasticIpAddress = try decoderContainer.decode(String?.self, forKey: .elasticIpAddress)
        }
        if decoderContainer.contains(.privateIpAddress)
        {
            self.privateIpAddress = try decoderContainer.decode(String?.self, forKey: .privateIpAddress)
        }
        if decoderContainer.contains(.securityGroupIds)
        {
            self.securityGroupIds = try decoderContainer.decode([String?]?.self, forKey: .securityGroupIds)
        }
        if decoderContainer.contains(.status)
        {
            self.status = try decoderContainer.decode(String?.self, forKey: .status)
        }
        if decoderContainer.contains(.createdTime)
        {
            self.createdTime = try decoderContainer.decode(String?.self, forKey: .createdTime)
        }
        if decoderContainer.contains(.sysDiskInfo)
        {
            self.sysDiskInfo = try decoderContainer.decode(SysDiskInfo?.self, forKey: .sysDiskInfo)
        }
        if decoderContainer.contains(.dataDiskAttachments)
        {
            self.dataDiskAttachments = try decoderContainer.decode([DataDiskAttachment?]?.self, forKey: .dataDiskAttachments)
        }
        if decoderContainer.contains(.primaryNetworkInterface)
        {
            self.primaryNetworkInterface = try decoderContainer.decode(NetAttachment?.self, forKey: .primaryNetworkInterface)
        }
        if decoderContainer.contains(.secondaryNetworkInterfaces)
        {
            self.secondaryNetworkInterfaces = try decoderContainer.decode([NetAttachment?]?.self, forKey: .secondaryNetworkInterfaces)
        }
        if decoderContainer.contains(.metadata)
        {
            self.metadata = try decoderContainer.decode(String?.self, forKey: .metadata)
        }
    }
}
public extension VmInfoDetail{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: VmInfoDetailCodingKeys.self)
         try encoderContainer.encode(id, forKey: .id)
         try encoderContainer.encode(region, forKey: .region)
         try encoderContainer.encode(az, forKey: .az)
         try encoderContainer.encode(name, forKey: .name)
         try encoderContainer.encode(hostName, forKey: .hostName)
         try encoderContainer.encode(imageId, forKey: .imageId)
         try encoderContainer.encode(imageType, forKey: .imageType)
         try encoderContainer.encode(instanceType, forKey: .instanceType)
         try encoderContainer.encode(descriptionValue, forKey: .descriptionValue)
         try encoderContainer.encode(subnetId, forKey: .subnetId)
         try encoderContainer.encode(tags, forKey: .tags)
         try encoderContainer.encode(cloudID, forKey: .cloudID)
         try encoderContainer.encode(keyNames, forKey: .keyNames)
         try encoderContainer.encode(elasticIpAddress, forKey: .elasticIpAddress)
         try encoderContainer.encode(privateIpAddress, forKey: .privateIpAddress)
         try encoderContainer.encode(securityGroupIds, forKey: .securityGroupIds)
         try encoderContainer.encode(status, forKey: .status)
         try encoderContainer.encode(createdTime, forKey: .createdTime)
         try encoderContainer.encode(sysDiskInfo, forKey: .sysDiskInfo)
         try encoderContainer.encode(dataDiskAttachments, forKey: .dataDiskAttachments)
         try encoderContainer.encode(primaryNetworkInterface, forKey: .primaryNetworkInterface)
         try encoderContainer.encode(secondaryNetworkInterfaces, forKey: .secondaryNetworkInterfaces)
         try encoderContainer.encode(metadata, forKey: .metadata)
    }
}
///  数据盘配置
public class DataDiskInfo:NSObject,Codable{
    /// 硬盘ID
    var diskId:String?
    /// 硬盘大小
    var diskSize:Int32?
    /// 磁盘介质分类，目前为预留，可以为空
    var diskMediumType:String?
    /// 磁盘名称
    var diskName:String?
    /// 磁盘是否随主机一起删除
    var autoDelete:String?
    /// 磁盘状态
    var status:String?



    public override init(){
            super.init()
    }

    enum DataDiskInfoCodingKeys: String, CodingKey {
        case diskId
        case diskSize
        case diskMediumType
        case diskName
        case autoDelete
        case status
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: DataDiskInfoCodingKeys.self)
        if decoderContainer.contains(.diskId)
        {
            self.diskId = try decoderContainer.decode(String?.self, forKey: .diskId)
        }
        if decoderContainer.contains(.diskSize)
        {
            self.diskSize = try decoderContainer.decode(Int32?.self, forKey: .diskSize)
        }
        if decoderContainer.contains(.diskMediumType)
        {
            self.diskMediumType = try decoderContainer.decode(String?.self, forKey: .diskMediumType)
        }
        if decoderContainer.contains(.diskName)
        {
            self.diskName = try decoderContainer.decode(String?.self, forKey: .diskName)
        }
        if decoderContainer.contains(.autoDelete)
        {
            self.autoDelete = try decoderContainer.decode(String?.self, forKey: .autoDelete)
        }
        if decoderContainer.contains(.status)
        {
            self.status = try decoderContainer.decode(String?.self, forKey: .status)
        }
    }
}
public extension DataDiskInfo{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: DataDiskInfoCodingKeys.self)
         try encoderContainer.encode(diskId, forKey: .diskId)
         try encoderContainer.encode(diskSize, forKey: .diskSize)
         try encoderContainer.encode(diskMediumType, forKey: .diskMediumType)
         try encoderContainer.encode(diskName, forKey: .diskName)
         try encoderContainer.encode(autoDelete, forKey: .autoDelete)
         try encoderContainer.encode(status, forKey: .status)
    }
}
///  createVm
public class CreateVm:NSObject,Codable{
    /// 资源ID，如果为空，则执行创建操作，否则执行修改操作
    var id:String?
    /// 可用区,根据各云平台规范填写
    var region:String?
    /// 云主机所属的可用区
    var az:String?
    /// 云主机名称
    /// Required:true
    var name:String
    /// 云主机
    var hostName:String?
    /// ImageType
    var imageType:ImageType?
    /// InstanceType
    var instanceType:InstanceType?
    /// 云主机描述
    var descriptionValue:String?
    /// 子网ID
    /// Required:true
    var subnetId:String
    /// Tags
    var tags:[Tag?]?
    /// 所属云提供商ID
    var cloudID:String?
    /// 密钥对名称,jd当前只支持传入一个
    var keyNames:[String?]?
    /// 主网卡主IP绑定弹性IP的地址
    var elasticIpAddress:String?
    /// 私有ip地址
    var privateIpAddress:String?
    /// 云主机状态
    var status:String?
    /// 创建时间
    var createdTime:String?
    /// 镜像文件ID，启动实例时选择的镜像资源
    /// Required:true
    var imageId:String
    /// 规格类型
    /// Required:true
    var instanceFlavorType:String
    /// 指定新创建实例所属于的安全组代码，同一个安全组内的实例之间可以互相访问
    var securityGroupId:String?
    /// 否  公网入带宽最大值，单位为Mbit/s
    var internetMaxBandwidthIn:Int32?
    /// 否  公网出带宽最大值，单位为Mbit/s
    var internetMaxBandwidthOut:Int32?
    /// 否  实例的密码
    var password:String?
    /// 否  是否使用镜像预设的密码
    var passwordInherit:Bool?
    /// 否  实例自定义数据，需要以Base64方式编码，原始数据最多为16KB
    var userData:String?
    /// 否  密钥对名称
    var keyPairName:String?
    /// SystemDisk
    var systemDisk:SystemDisk?



    public  init(name:String,subnetId:String,imageId:String,instanceFlavorType:String){
             self.name = name
             self.subnetId = subnetId
             self.imageId = imageId
             self.instanceFlavorType = instanceFlavorType
    }

    enum CreateVmCodingKeys: String, CodingKey {
        case id
        case region
        case az
        case name
        case hostName
        case imageType
        case instanceType
        case descriptionValue = "description"
        case subnetId
        case tags
        case cloudID
        case keyNames
        case elasticIpAddress
        case privateIpAddress
        case status
        case createdTime
        case imageId
        case instanceFlavorType
        case securityGroupId
        case internetMaxBandwidthIn
        case internetMaxBandwidthOut
        case password
        case passwordInherit
        case userData
        case keyPairName
        case systemDisk
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: CreateVmCodingKeys.self)
        if decoderContainer.contains(.id)
        {
            self.id = try decoderContainer.decode(String?.self, forKey: .id)
        }
        if decoderContainer.contains(.region)
        {
            self.region = try decoderContainer.decode(String?.self, forKey: .region)
        }
        if decoderContainer.contains(.az)
        {
            self.az = try decoderContainer.decode(String?.self, forKey: .az)
        }
        self.name = try decoderContainer.decode(String.self, forKey: .name)
        if decoderContainer.contains(.hostName)
        {
            self.hostName = try decoderContainer.decode(String?.self, forKey: .hostName)
        }
        if decoderContainer.contains(.imageType)
        {
            self.imageType = try decoderContainer.decode(ImageType?.self, forKey: .imageType)
        }
        if decoderContainer.contains(.instanceType)
        {
            self.instanceType = try decoderContainer.decode(InstanceType?.self, forKey: .instanceType)
        }
        if decoderContainer.contains(.descriptionValue)
        {
            self.descriptionValue = try decoderContainer.decode(String?.self, forKey: .descriptionValue)
        }
        self.subnetId = try decoderContainer.decode(String.self, forKey: .subnetId)
        if decoderContainer.contains(.tags)
        {
            self.tags = try decoderContainer.decode([Tag?]?.self, forKey: .tags)
        }
        if decoderContainer.contains(.cloudID)
        {
            self.cloudID = try decoderContainer.decode(String?.self, forKey: .cloudID)
        }
        if decoderContainer.contains(.keyNames)
        {
            self.keyNames = try decoderContainer.decode([String?]?.self, forKey: .keyNames)
        }
        if decoderContainer.contains(.elasticIpAddress)
        {
            self.elasticIpAddress = try decoderContainer.decode(String?.self, forKey: .elasticIpAddress)
        }
        if decoderContainer.contains(.privateIpAddress)
        {
            self.privateIpAddress = try decoderContainer.decode(String?.self, forKey: .privateIpAddress)
        }
        if decoderContainer.contains(.status)
        {
            self.status = try decoderContainer.decode(String?.self, forKey: .status)
        }
        if decoderContainer.contains(.createdTime)
        {
            self.createdTime = try decoderContainer.decode(String?.self, forKey: .createdTime)
        }
        self.imageId = try decoderContainer.decode(String.self, forKey: .imageId)
        self.instanceFlavorType = try decoderContainer.decode(String.self, forKey: .instanceFlavorType)
        if decoderContainer.contains(.securityGroupId)
        {
            self.securityGroupId = try decoderContainer.decode(String?.self, forKey: .securityGroupId)
        }
        if decoderContainer.contains(.internetMaxBandwidthIn)
        {
            self.internetMaxBandwidthIn = try decoderContainer.decode(Int32?.self, forKey: .internetMaxBandwidthIn)
        }
        if decoderContainer.contains(.internetMaxBandwidthOut)
        {
            self.internetMaxBandwidthOut = try decoderContainer.decode(Int32?.self, forKey: .internetMaxBandwidthOut)
        }
        if decoderContainer.contains(.password)
        {
            self.password = try decoderContainer.decode(String?.self, forKey: .password)
        }
        if decoderContainer.contains(.passwordInherit)
        {
            self.passwordInherit = try decoderContainer.decode(Bool?.self, forKey: .passwordInherit)
        }
        if decoderContainer.contains(.userData)
        {
            self.userData = try decoderContainer.decode(String?.self, forKey: .userData)
        }
        if decoderContainer.contains(.keyPairName)
        {
            self.keyPairName = try decoderContainer.decode(String?.self, forKey: .keyPairName)
        }
        if decoderContainer.contains(.systemDisk)
        {
            self.systemDisk = try decoderContainer.decode(SystemDisk?.self, forKey: .systemDisk)
        }
    }
}
public extension CreateVm{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: CreateVmCodingKeys.self)
         try encoderContainer.encode(id, forKey: .id)
         try encoderContainer.encode(region, forKey: .region)
         try encoderContainer.encode(az, forKey: .az)
         try encoderContainer.encode(name, forKey: .name)
         try encoderContainer.encode(hostName, forKey: .hostName)
         try encoderContainer.encode(imageType, forKey: .imageType)
         try encoderContainer.encode(instanceType, forKey: .instanceType)
         try encoderContainer.encode(descriptionValue, forKey: .descriptionValue)
         try encoderContainer.encode(subnetId, forKey: .subnetId)
         try encoderContainer.encode(tags, forKey: .tags)
         try encoderContainer.encode(cloudID, forKey: .cloudID)
         try encoderContainer.encode(keyNames, forKey: .keyNames)
         try encoderContainer.encode(elasticIpAddress, forKey: .elasticIpAddress)
         try encoderContainer.encode(privateIpAddress, forKey: .privateIpAddress)
         try encoderContainer.encode(status, forKey: .status)
         try encoderContainer.encode(createdTime, forKey: .createdTime)
         try encoderContainer.encode(imageId, forKey: .imageId)
         try encoderContainer.encode(instanceFlavorType, forKey: .instanceFlavorType)
         try encoderContainer.encode(securityGroupId, forKey: .securityGroupId)
         try encoderContainer.encode(internetMaxBandwidthIn, forKey: .internetMaxBandwidthIn)
         try encoderContainer.encode(internetMaxBandwidthOut, forKey: .internetMaxBandwidthOut)
         try encoderContainer.encode(password, forKey: .password)
         try encoderContainer.encode(passwordInherit, forKey: .passwordInherit)
         try encoderContainer.encode(userData, forKey: .userData)
         try encoderContainer.encode(keyPairName, forKey: .keyPairName)
         try encoderContainer.encode(systemDisk, forKey: .systemDisk)
    }
}
///  网卡接口规范
public class NetworkInterface:NSObject,Codable{
    /// 以太网地址
    var macAddress:String?
    /// 弹性网卡ID
    var networkInterfaceId:String?
    /// 源和目标IP地址校验,取值为0或者1
    var sanityCheck:Int32?
    /// 子网ID
    var subnetId:String?
    /// 虚拟网络ID
    var vpcId:String?
    /// PrimaryIp
    var primaryIp:Ip?
    /// 网卡辅IP
    var secondaryIps:[Ip?]?
    /// 所属安全组列表
    var securityGroups:[SecurityGroup?]?



    public override init(){
            super.init()
    }

    enum NetworkInterfaceCodingKeys: String, CodingKey {
        case macAddress
        case networkInterfaceId
        case sanityCheck
        case subnetId
        case vpcId
        case primaryIp
        case secondaryIps
        case securityGroups
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: NetworkInterfaceCodingKeys.self)
        if decoderContainer.contains(.macAddress)
        {
            self.macAddress = try decoderContainer.decode(String?.self, forKey: .macAddress)
        }
        if decoderContainer.contains(.networkInterfaceId)
        {
            self.networkInterfaceId = try decoderContainer.decode(String?.self, forKey: .networkInterfaceId)
        }
        if decoderContainer.contains(.sanityCheck)
        {
            self.sanityCheck = try decoderContainer.decode(Int32?.self, forKey: .sanityCheck)
        }
        if decoderContainer.contains(.subnetId)
        {
            self.subnetId = try decoderContainer.decode(String?.self, forKey: .subnetId)
        }
        if decoderContainer.contains(.vpcId)
        {
            self.vpcId = try decoderContainer.decode(String?.self, forKey: .vpcId)
        }
        if decoderContainer.contains(.primaryIp)
        {
            self.primaryIp = try decoderContainer.decode(Ip?.self, forKey: .primaryIp)
        }
        if decoderContainer.contains(.secondaryIps)
        {
            self.secondaryIps = try decoderContainer.decode([Ip?]?.self, forKey: .secondaryIps)
        }
        if decoderContainer.contains(.securityGroups)
        {
            self.securityGroups = try decoderContainer.decode([SecurityGroup?]?.self, forKey: .securityGroups)
        }
    }
}
public extension NetworkInterface{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: NetworkInterfaceCodingKeys.self)
         try encoderContainer.encode(macAddress, forKey: .macAddress)
         try encoderContainer.encode(networkInterfaceId, forKey: .networkInterfaceId)
         try encoderContainer.encode(sanityCheck, forKey: .sanityCheck)
         try encoderContainer.encode(subnetId, forKey: .subnetId)
         try encoderContainer.encode(vpcId, forKey: .vpcId)
         try encoderContainer.encode(primaryIp, forKey: .primaryIp)
         try encoderContainer.encode(secondaryIps, forKey: .secondaryIps)
         try encoderContainer.encode(securityGroups, forKey: .securityGroups)
    }
}
///  虚拟机配置描述
public class InstanceType:NSObject,Codable{
    /// 实例配置类型名称
    var name:String?
    /// 处理器核数，单位为C
    var cpu:Int32?
    /// 内存大小，单位为M
    var memory:Int32?



    public override init(){
            super.init()
    }

    enum InstanceTypeCodingKeys: String, CodingKey {
        case name
        case cpu
        case memory
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: InstanceTypeCodingKeys.self)
        if decoderContainer.contains(.name)
        {
            self.name = try decoderContainer.decode(String?.self, forKey: .name)
        }
        if decoderContainer.contains(.cpu)
        {
            self.cpu = try decoderContainer.decode(Int32?.self, forKey: .cpu)
        }
        if decoderContainer.contains(.memory)
        {
            self.memory = try decoderContainer.decode(Int32?.self, forKey: .memory)
        }
    }
}
public extension InstanceType{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: InstanceTypeCodingKeys.self)
         try encoderContainer.encode(name, forKey: .name)
         try encoderContainer.encode(cpu, forKey: .cpu)
         try encoderContainer.encode(memory, forKey: .memory)
    }
}
///  主机镜像描述
public class ImageType:NSObject,Codable{
    /// 镜像ID
    var id:String?
    /// 镜像描述
    var desc:String?
    /// 镜像来源
    var imageSource:String?
    /// 镜像名称
    var name:String?
    /// 镜像的操作系统类型
    var osType:String?
    /// 镜像的操作系统版本
    var osVersion:String?
    /// 镜像的操作系统发行版
    var platform:String?
    /// 镜像所属区域
    var region:String?
    /// 所属云提供商ID
    var cloudID:String?



    public override init(){
            super.init()
    }

    enum ImageTypeCodingKeys: String, CodingKey {
        case id
        case desc
        case imageSource
        case name
        case osType
        case osVersion
        case platform
        case region
        case cloudID
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: ImageTypeCodingKeys.self)
        if decoderContainer.contains(.id)
        {
            self.id = try decoderContainer.decode(String?.self, forKey: .id)
        }
        if decoderContainer.contains(.desc)
        {
            self.desc = try decoderContainer.decode(String?.self, forKey: .desc)
        }
        if decoderContainer.contains(.imageSource)
        {
            self.imageSource = try decoderContainer.decode(String?.self, forKey: .imageSource)
        }
        if decoderContainer.contains(.name)
        {
            self.name = try decoderContainer.decode(String?.self, forKey: .name)
        }
        if decoderContainer.contains(.osType)
        {
            self.osType = try decoderContainer.decode(String?.self, forKey: .osType)
        }
        if decoderContainer.contains(.osVersion)
        {
            self.osVersion = try decoderContainer.decode(String?.self, forKey: .osVersion)
        }
        if decoderContainer.contains(.platform)
        {
            self.platform = try decoderContainer.decode(String?.self, forKey: .platform)
        }
        if decoderContainer.contains(.region)
        {
            self.region = try decoderContainer.decode(String?.self, forKey: .region)
        }
        if decoderContainer.contains(.cloudID)
        {
            self.cloudID = try decoderContainer.decode(String?.self, forKey: .cloudID)
        }
    }
}
public extension ImageType{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: ImageTypeCodingKeys.self)
         try encoderContainer.encode(id, forKey: .id)
         try encoderContainer.encode(desc, forKey: .desc)
         try encoderContainer.encode(imageSource, forKey: .imageSource)
         try encoderContainer.encode(name, forKey: .name)
         try encoderContainer.encode(osType, forKey: .osType)
         try encoderContainer.encode(osVersion, forKey: .osVersion)
         try encoderContainer.encode(platform, forKey: .platform)
         try encoderContainer.encode(region, forKey: .region)
         try encoderContainer.encode(cloudID, forKey: .cloudID)
    }
}
///  网卡配置信息
public class NetAttachment:NSObject,Codable{
    /// 指明删除实例时是否删除网卡,默认true；（当前只能是true）
    var autoDelete:Bool?
    /// 设备Index
    var deviceIndex:Int32?
    /// NetworkInterface
    var networkInterface:NetworkInterface?



    public override init(){
            super.init()
    }

    enum NetAttachmentCodingKeys: String, CodingKey {
        case autoDelete
        case deviceIndex
        case networkInterface
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: NetAttachmentCodingKeys.self)
        if decoderContainer.contains(.autoDelete)
        {
            self.autoDelete = try decoderContainer.decode(Bool?.self, forKey: .autoDelete)
        }
        if decoderContainer.contains(.deviceIndex)
        {
            self.deviceIndex = try decoderContainer.decode(Int32?.self, forKey: .deviceIndex)
        }
        if decoderContainer.contains(.networkInterface)
        {
            self.networkInterface = try decoderContainer.decode(NetworkInterface?.self, forKey: .networkInterface)
        }
    }
}
public extension NetAttachment{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: NetAttachmentCodingKeys.self)
         try encoderContainer.encode(autoDelete, forKey: .autoDelete)
         try encoderContainer.encode(deviceIndex, forKey: .deviceIndex)
         try encoderContainer.encode(networkInterface, forKey: .networkInterface)
    }
}
///  securityGroup
public class SecurityGroup:NSObject,Codable{
    /// 安全组ID
    var groupId:String?
    /// 安全组名称
    var groupName:String?



    public override init(){
            super.init()
    }

    enum SecurityGroupCodingKeys: String, CodingKey {
        case groupId
        case groupName
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: SecurityGroupCodingKeys.self)
        if decoderContainer.contains(.groupId)
        {
            self.groupId = try decoderContainer.decode(String?.self, forKey: .groupId)
        }
        if decoderContainer.contains(.groupName)
        {
            self.groupName = try decoderContainer.decode(String?.self, forKey: .groupName)
        }
    }
}
public extension SecurityGroup{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: SecurityGroupCodingKeys.self)
         try encoderContainer.encode(groupId, forKey: .groupId)
         try encoderContainer.encode(groupName, forKey: .groupName)
    }
}
///  否  系统盘配置
public class SystemDisk:NSObject,Codable{
    /// 否  系统盘的磁盘种类
    var category:String?
    /// 系统盘大小
    var diskSize:Int32?
    /// 系统盘描述
    var descriptionValue:String?



    public override init(){
            super.init()
    }

    enum SystemDiskCodingKeys: String, CodingKey {
        case category
        case diskSize
        case descriptionValue = "description"
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: SystemDiskCodingKeys.self)
        if decoderContainer.contains(.category)
        {
            self.category = try decoderContainer.decode(String?.self, forKey: .category)
        }
        if decoderContainer.contains(.diskSize)
        {
            self.diskSize = try decoderContainer.decode(Int32?.self, forKey: .diskSize)
        }
        if decoderContainer.contains(.descriptionValue)
        {
            self.descriptionValue = try decoderContainer.decode(String?.self, forKey: .descriptionValue)
        }
    }
}
public extension SystemDisk{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: SystemDiskCodingKeys.self)
         try encoderContainer.encode(category, forKey: .category)
         try encoderContainer.encode(diskSize, forKey: .diskSize)
         try encoderContainer.encode(descriptionValue, forKey: .descriptionValue)
    }
}
///  IP配置
public class Ip:NSObject,Codable{
    /// 弹性IP实例地址
    var elasticIpAddress:String?
    /// 私有IP的IPV4地址
    var privateIpAddress:String?



    public override init(){
            super.init()
    }

    enum IpCodingKeys: String, CodingKey {
        case elasticIpAddress
        case privateIpAddress
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: IpCodingKeys.self)
        if decoderContainer.contains(.elasticIpAddress)
        {
            self.elasticIpAddress = try decoderContainer.decode(String?.self, forKey: .elasticIpAddress)
        }
        if decoderContainer.contains(.privateIpAddress)
        {
            self.privateIpAddress = try decoderContainer.decode(String?.self, forKey: .privateIpAddress)
        }
    }
}
public extension Ip{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: IpCodingKeys.self)
         try encoderContainer.encode(elasticIpAddress, forKey: .elasticIpAddress)
         try encoderContainer.encode(privateIpAddress, forKey: .privateIpAddress)
    }
}
///  dataDiskAttachment
public class DataDiskAttachment:NSObject,Codable{
    /// 是否随云主机一起删除,true：自动；false：非自动
    var autoDelete:Bool?
    /// DataDisk
    var dataDisk:DataDiskInfo?
    /// 数据盘逻辑挂载点
    var deviceName:String?
    /// 磁盘分类,取值为本地盘(local)或者数据盘(cloud)
    var diskCategory:String?



    public override init(){
            super.init()
    }

    enum DataDiskAttachmentCodingKeys: String, CodingKey {
        case autoDelete
        case dataDisk
        case deviceName
        case diskCategory
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: DataDiskAttachmentCodingKeys.self)
        if decoderContainer.contains(.autoDelete)
        {
            self.autoDelete = try decoderContainer.decode(Bool?.self, forKey: .autoDelete)
        }
        if decoderContainer.contains(.dataDisk)
        {
            self.dataDisk = try decoderContainer.decode(DataDiskInfo?.self, forKey: .dataDisk)
        }
        if decoderContainer.contains(.deviceName)
        {
            self.deviceName = try decoderContainer.decode(String?.self, forKey: .deviceName)
        }
        if decoderContainer.contains(.diskCategory)
        {
            self.diskCategory = try decoderContainer.decode(String?.self, forKey: .diskCategory)
        }
    }
}
public extension DataDiskAttachment{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: DataDiskAttachmentCodingKeys.self)
         try encoderContainer.encode(autoDelete, forKey: .autoDelete)
         try encoderContainer.encode(dataDisk, forKey: .dataDisk)
         try encoderContainer.encode(deviceName, forKey: .deviceName)
         try encoderContainer.encode(diskCategory, forKey: .diskCategory)
    }
}
///  tag
public class Tag:NSObject,Codable{
    /// 标签KEY值
    var tagKey:String?
    /// 标签Value值
    var tagValue:String?



    public override init(){
            super.init()
    }

    enum TagCodingKeys: String, CodingKey {
        case tagKey
        case tagValue
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: TagCodingKeys.self)
        if decoderContainer.contains(.tagKey)
        {
            self.tagKey = try decoderContainer.decode(String?.self, forKey: .tagKey)
        }
        if decoderContainer.contains(.tagValue)
        {
            self.tagValue = try decoderContainer.decode(String?.self, forKey: .tagValue)
        }
    }
}
public extension Tag{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: TagCodingKeys.self)
         try encoderContainer.encode(tagKey, forKey: .tagKey)
         try encoderContainer.encode(tagValue, forKey: .tagValue)
    }
}
///  vmInfo
public class VmInfo:NSObject,Codable{
    /// 资源ID，如果为空，则执行创建操作，否则执行修改操作
    var id:String?
    /// 可用区,根据各云平台规范填写
    var region:String?
    /// 云主机所属的可用区
    var az:String?
    /// 云主机名称
    var name:String?
    /// 云主机
    var hostName:String?
    /// ImageType
    var imageType:ImageType?
    /// InstanceType
    var instanceType:InstanceType?
    /// 云主机描述
    var descriptionValue:String?
    /// 子网ID
    var subnetId:String?
    /// Tags
    var tags:[Tag?]?
    /// 所属云提供商ID
    var cloudID:String?
    /// 密钥对名称,jd当前只支持传入一个
    var keyNames:[String?]?
    /// 主网卡主IP绑定弹性IP的地址
    var elasticIpAddress:String?
    /// 私有ip地址
    var privateIpAddress:String?
    /// 云主机状态
    var status:String?
    /// 创建时间
    var createdTime:String?
    /// 镜像ID
    var imageId:String?
    /// 安全组ID
    var securityGroupIds:[String?]?



    public override init(){
            super.init()
    }

    enum VmInfoCodingKeys: String, CodingKey {
        case id
        case region
        case az
        case name
        case hostName
        case imageType
        case instanceType
        case descriptionValue = "description"
        case subnetId
        case tags
        case cloudID
        case keyNames
        case elasticIpAddress
        case privateIpAddress
        case status
        case createdTime
        case imageId
        case securityGroupIds
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: VmInfoCodingKeys.self)
        if decoderContainer.contains(.id)
        {
            self.id = try decoderContainer.decode(String?.self, forKey: .id)
        }
        if decoderContainer.contains(.region)
        {
            self.region = try decoderContainer.decode(String?.self, forKey: .region)
        }
        if decoderContainer.contains(.az)
        {
            self.az = try decoderContainer.decode(String?.self, forKey: .az)
        }
        if decoderContainer.contains(.name)
        {
            self.name = try decoderContainer.decode(String?.self, forKey: .name)
        }
        if decoderContainer.contains(.hostName)
        {
            self.hostName = try decoderContainer.decode(String?.self, forKey: .hostName)
        }
        if decoderContainer.contains(.imageType)
        {
            self.imageType = try decoderContainer.decode(ImageType?.self, forKey: .imageType)
        }
        if decoderContainer.contains(.instanceType)
        {
            self.instanceType = try decoderContainer.decode(InstanceType?.self, forKey: .instanceType)
        }
        if decoderContainer.contains(.descriptionValue)
        {
            self.descriptionValue = try decoderContainer.decode(String?.self, forKey: .descriptionValue)
        }
        if decoderContainer.contains(.subnetId)
        {
            self.subnetId = try decoderContainer.decode(String?.self, forKey: .subnetId)
        }
        if decoderContainer.contains(.tags)
        {
            self.tags = try decoderContainer.decode([Tag?]?.self, forKey: .tags)
        }
        if decoderContainer.contains(.cloudID)
        {
            self.cloudID = try decoderContainer.decode(String?.self, forKey: .cloudID)
        }
        if decoderContainer.contains(.keyNames)
        {
            self.keyNames = try decoderContainer.decode([String?]?.self, forKey: .keyNames)
        }
        if decoderContainer.contains(.elasticIpAddress)
        {
            self.elasticIpAddress = try decoderContainer.decode(String?.self, forKey: .elasticIpAddress)
        }
        if decoderContainer.contains(.privateIpAddress)
        {
            self.privateIpAddress = try decoderContainer.decode(String?.self, forKey: .privateIpAddress)
        }
        if decoderContainer.contains(.status)
        {
            self.status = try decoderContainer.decode(String?.self, forKey: .status)
        }
        if decoderContainer.contains(.createdTime)
        {
            self.createdTime = try decoderContainer.decode(String?.self, forKey: .createdTime)
        }
        if decoderContainer.contains(.imageId)
        {
            self.imageId = try decoderContainer.decode(String?.self, forKey: .imageId)
        }
        if decoderContainer.contains(.securityGroupIds)
        {
            self.securityGroupIds = try decoderContainer.decode([String?]?.self, forKey: .securityGroupIds)
        }
    }
}
public extension VmInfo{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: VmInfoCodingKeys.self)
         try encoderContainer.encode(id, forKey: .id)
         try encoderContainer.encode(region, forKey: .region)
         try encoderContainer.encode(az, forKey: .az)
         try encoderContainer.encode(name, forKey: .name)
         try encoderContainer.encode(hostName, forKey: .hostName)
         try encoderContainer.encode(imageType, forKey: .imageType)
         try encoderContainer.encode(instanceType, forKey: .instanceType)
         try encoderContainer.encode(descriptionValue, forKey: .descriptionValue)
         try encoderContainer.encode(subnetId, forKey: .subnetId)
         try encoderContainer.encode(tags, forKey: .tags)
         try encoderContainer.encode(cloudID, forKey: .cloudID)
         try encoderContainer.encode(keyNames, forKey: .keyNames)
         try encoderContainer.encode(elasticIpAddress, forKey: .elasticIpAddress)
         try encoderContainer.encode(privateIpAddress, forKey: .privateIpAddress)
         try encoderContainer.encode(status, forKey: .status)
         try encoderContainer.encode(createdTime, forKey: .createdTime)
         try encoderContainer.encode(imageId, forKey: .imageId)
         try encoderContainer.encode(securityGroupIds, forKey: .securityGroupIds)
    }
}
///  createRDSInstance
public class CreateRDSInstance:NSObject,Codable{
    /// RDS实例ID
    var id:String?
    /// RDS实例名称
    var name:String?
    /// 计费信息,prepaid\postpaid
    /// Required:true
    var payType:String
    /// 可用区ID
    var azs:[String?]?
    /// 实例引擎类型
    /// Required:true
    var engine:String
    /// 实例状态
    var status:String?
    /// 实例类型
    var instanceType:String?
    /// 所属云提供商ID
    var cloudID:String?
    /// 数据库版本号
    /// Required:true
    var engineVersion:String
    /// 实例规格
    /// Required:true
    var instanceClass:String
    /// 磁盘大小，单位GB
    /// Required:true
    var storageGB:Int32
    /// VPC ID
    /// Required:true
    var vpcId:String
    /// 子网ID
    /// Required:true
    var subnetId:String
    /// 创建时间
    var createTime:String?



    public  init(payType:String,engine:String,engineVersion:String,instanceClass:String,storageGB:Int32,vpcId:String,subnetId:String){
             self.payType = payType
             self.engine = engine
             self.engineVersion = engineVersion
             self.instanceClass = instanceClass
             self.storageGB = storageGB
             self.vpcId = vpcId
             self.subnetId = subnetId
    }

    enum CreateRDSInstanceCodingKeys: String, CodingKey {
        case id
        case name
        case payType
        case azs
        case engine
        case status
        case instanceType
        case cloudID
        case engineVersion
        case instanceClass
        case storageGB
        case vpcId
        case subnetId
        case createTime
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: CreateRDSInstanceCodingKeys.self)
        if decoderContainer.contains(.id)
        {
            self.id = try decoderContainer.decode(String?.self, forKey: .id)
        }
        if decoderContainer.contains(.name)
        {
            self.name = try decoderContainer.decode(String?.self, forKey: .name)
        }
        self.payType = try decoderContainer.decode(String.self, forKey: .payType)
        if decoderContainer.contains(.azs)
        {
            self.azs = try decoderContainer.decode([String?]?.self, forKey: .azs)
        }
        self.engine = try decoderContainer.decode(String.self, forKey: .engine)
        if decoderContainer.contains(.status)
        {
            self.status = try decoderContainer.decode(String?.self, forKey: .status)
        }
        if decoderContainer.contains(.instanceType)
        {
            self.instanceType = try decoderContainer.decode(String?.self, forKey: .instanceType)
        }
        if decoderContainer.contains(.cloudID)
        {
            self.cloudID = try decoderContainer.decode(String?.self, forKey: .cloudID)
        }
        self.engineVersion = try decoderContainer.decode(String.self, forKey: .engineVersion)
        self.instanceClass = try decoderContainer.decode(String.self, forKey: .instanceClass)
        self.storageGB = try decoderContainer.decode(Int32.self, forKey: .storageGB)
        self.vpcId = try decoderContainer.decode(String.self, forKey: .vpcId)
        self.subnetId = try decoderContainer.decode(String.self, forKey: .subnetId)
        if decoderContainer.contains(.createTime)
        {
            self.createTime = try decoderContainer.decode(String?.self, forKey: .createTime)
        }
    }
}
public extension CreateRDSInstance{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: CreateRDSInstanceCodingKeys.self)
         try encoderContainer.encode(id, forKey: .id)
         try encoderContainer.encode(name, forKey: .name)
         try encoderContainer.encode(payType, forKey: .payType)
         try encoderContainer.encode(azs, forKey: .azs)
         try encoderContainer.encode(engine, forKey: .engine)
         try encoderContainer.encode(status, forKey: .status)
         try encoderContainer.encode(instanceType, forKey: .instanceType)
         try encoderContainer.encode(cloudID, forKey: .cloudID)
         try encoderContainer.encode(engineVersion, forKey: .engineVersion)
         try encoderContainer.encode(instanceClass, forKey: .instanceClass)
         try encoderContainer.encode(storageGB, forKey: .storageGB)
         try encoderContainer.encode(vpcId, forKey: .vpcId)
         try encoderContainer.encode(subnetId, forKey: .subnetId)
         try encoderContainer.encode(createTime, forKey: .createTime)
    }
}
///  RDS数据库实例详细信息
public class RdsInstanceDetailInfo:NSObject,Codable{
    /// RDS实例ID
    var id:String?
    /// RDS实例名称
    var name:String?
    /// 可用区ID
    var azs:[String?]?
    /// 实例引擎类型
    var engine:String?
    /// 实例引擎版本
    var engineVersion:String?
    /// 实例状态
    var status:String?
    /// 付费方式，Postpaid：后付费; Prepaid：预付费
    var payType:String?
    /// 磁盘，单位GB
    var storageGB:Int32?
    /// 内存大小，单位MB
    var memoryMB:Double?
    /// 实例类型
    var instanceType:String?
    /// 实例规格
    var instanceClassType:String?
    /// 实例的访问模式
    var connectionMode:String?
    /// 连接地址
    var connectionString:String?
    /// CPU核数
    var instanceCPU:Int?
    /// 端口
    var port:String?
    /// VPC ID
    var vpcId:String?
    /// subnet ID
    var subnetId:String?
    /// 所属云提供商ID
    var cloudID:String?



    public override init(){
            super.init()
    }

    enum RdsInstanceDetailInfoCodingKeys: String, CodingKey {
        case id
        case name
        case azs
        case engine
        case engineVersion
        case status
        case payType
        case storageGB
        case memoryMB
        case instanceType
        case instanceClassType
        case connectionMode
        case connectionString
        case instanceCPU
        case port
        case vpcId
        case subnetId
        case cloudID
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: RdsInstanceDetailInfoCodingKeys.self)
        if decoderContainer.contains(.id)
        {
            self.id = try decoderContainer.decode(String?.self, forKey: .id)
        }
        if decoderContainer.contains(.name)
        {
            self.name = try decoderContainer.decode(String?.self, forKey: .name)
        }
        if decoderContainer.contains(.azs)
        {
            self.azs = try decoderContainer.decode([String?]?.self, forKey: .azs)
        }
        if decoderContainer.contains(.engine)
        {
            self.engine = try decoderContainer.decode(String?.self, forKey: .engine)
        }
        if decoderContainer.contains(.engineVersion)
        {
            self.engineVersion = try decoderContainer.decode(String?.self, forKey: .engineVersion)
        }
        if decoderContainer.contains(.status)
        {
            self.status = try decoderContainer.decode(String?.self, forKey: .status)
        }
        if decoderContainer.contains(.payType)
        {
            self.payType = try decoderContainer.decode(String?.self, forKey: .payType)
        }
        if decoderContainer.contains(.storageGB)
        {
            self.storageGB = try decoderContainer.decode(Int32?.self, forKey: .storageGB)
        }
        if decoderContainer.contains(.memoryMB)
        {
            self.memoryMB = try decoderContainer.decode(Double?.self, forKey: .memoryMB)
        }
        if decoderContainer.contains(.instanceType)
        {
            self.instanceType = try decoderContainer.decode(String?.self, forKey: .instanceType)
        }
        if decoderContainer.contains(.instanceClassType)
        {
            self.instanceClassType = try decoderContainer.decode(String?.self, forKey: .instanceClassType)
        }
        if decoderContainer.contains(.connectionMode)
        {
            self.connectionMode = try decoderContainer.decode(String?.self, forKey: .connectionMode)
        }
        if decoderContainer.contains(.connectionString)
        {
            self.connectionString = try decoderContainer.decode(String?.self, forKey: .connectionString)
        }
        if decoderContainer.contains(.instanceCPU)
        {
            self.instanceCPU = try decoderContainer.decode(Int?.self, forKey: .instanceCPU)
        }
        if decoderContainer.contains(.port)
        {
            self.port = try decoderContainer.decode(String?.self, forKey: .port)
        }
        if decoderContainer.contains(.vpcId)
        {
            self.vpcId = try decoderContainer.decode(String?.self, forKey: .vpcId)
        }
        if decoderContainer.contains(.subnetId)
        {
            self.subnetId = try decoderContainer.decode(String?.self, forKey: .subnetId)
        }
        if decoderContainer.contains(.cloudID)
        {
            self.cloudID = try decoderContainer.decode(String?.self, forKey: .cloudID)
        }
    }
}
public extension RdsInstanceDetailInfo{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: RdsInstanceDetailInfoCodingKeys.self)
         try encoderContainer.encode(id, forKey: .id)
         try encoderContainer.encode(name, forKey: .name)
         try encoderContainer.encode(azs, forKey: .azs)
         try encoderContainer.encode(engine, forKey: .engine)
         try encoderContainer.encode(engineVersion, forKey: .engineVersion)
         try encoderContainer.encode(status, forKey: .status)
         try encoderContainer.encode(payType, forKey: .payType)
         try encoderContainer.encode(storageGB, forKey: .storageGB)
         try encoderContainer.encode(memoryMB, forKey: .memoryMB)
         try encoderContainer.encode(instanceType, forKey: .instanceType)
         try encoderContainer.encode(instanceClassType, forKey: .instanceClassType)
         try encoderContainer.encode(connectionMode, forKey: .connectionMode)
         try encoderContainer.encode(connectionString, forKey: .connectionString)
         try encoderContainer.encode(instanceCPU, forKey: .instanceCPU)
         try encoderContainer.encode(port, forKey: .port)
         try encoderContainer.encode(vpcId, forKey: .vpcId)
         try encoderContainer.encode(subnetId, forKey: .subnetId)
         try encoderContainer.encode(cloudID, forKey: .cloudID)
    }
}
///  应用部署信息
public class DeploymentApplyInfo:NSObject,Codable{
    /// ID
    var id:String?
    /// 备注信息
    var comment:String?
    /// 应用时间
    var applyTime:String?
    /// 版本
    var version:String?
    /// Content
    var content:DeploymentResourcesInfo?



    public override init(){
            super.init()
    }

    enum DeploymentApplyInfoCodingKeys: String, CodingKey {
        case id
        case comment
        case applyTime
        case version
        case content
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: DeploymentApplyInfoCodingKeys.self)
        if decoderContainer.contains(.id)
        {
            self.id = try decoderContainer.decode(String?.self, forKey: .id)
        }
        if decoderContainer.contains(.comment)
        {
            self.comment = try decoderContainer.decode(String?.self, forKey: .comment)
        }
        if decoderContainer.contains(.applyTime)
        {
            self.applyTime = try decoderContainer.decode(String?.self, forKey: .applyTime)
        }
        if decoderContainer.contains(.version)
        {
            self.version = try decoderContainer.decode(String?.self, forKey: .version)
        }
        if decoderContainer.contains(.content)
        {
            self.content = try decoderContainer.decode(DeploymentResourcesInfo?.self, forKey: .content)
        }
    }
}
public extension DeploymentApplyInfo{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: DeploymentApplyInfoCodingKeys.self)
         try encoderContainer.encode(id, forKey: .id)
         try encoderContainer.encode(comment, forKey: .comment)
         try encoderContainer.encode(applyTime, forKey: .applyTime)
         try encoderContainer.encode(version, forKey: .version)
         try encoderContainer.encode(content, forKey: .content)
    }
}
///  挂载云硬盘
public class DeploymentAttachDisk:NSObject,Codable{
    /// 云硬盘 id
    /// Required:true
    var diskId:String
    /// 虚拟机 id
    /// Required:true
    var instanceId:String



    public  init(diskId:String,instanceId:String){
             self.diskId = diskId
             self.instanceId = instanceId
    }

    enum DeploymentAttachDiskCodingKeys: String, CodingKey {
        case diskId
        case instanceId
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: DeploymentAttachDiskCodingKeys.self)
        self.diskId = try decoderContainer.decode(String.self, forKey: .diskId)
        self.instanceId = try decoderContainer.decode(String.self, forKey: .instanceId)
    }
}
public extension DeploymentAttachDisk{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: DeploymentAttachDiskCodingKeys.self)
         try encoderContainer.encode(diskId, forKey: .diskId)
         try encoderContainer.encode(instanceId, forKey: .instanceId)
    }
}
///  创建存储桶
public class DeploymentBucket:NSObject,Codable{
    /// 存储桶名称
    var name:String?
    /// 访问控制，private,public-read,public-read-write
    var acl:String?



    public override init(){
            super.init()
    }

    enum DeploymentBucketCodingKeys: String, CodingKey {
        case name
        case acl
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: DeploymentBucketCodingKeys.self)
        if decoderContainer.contains(.name)
        {
            self.name = try decoderContainer.decode(String?.self, forKey: .name)
        }
        if decoderContainer.contains(.acl)
        {
            self.acl = try decoderContainer.decode(String?.self, forKey: .acl)
        }
    }
}
public extension DeploymentBucket{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: DeploymentBucketCodingKeys.self)
         try encoderContainer.encode(name, forKey: .name)
         try encoderContainer.encode(acl, forKey: .acl)
    }
}
///  deploymentResourcesInfo
public class DeploymentResourcesInfo:NSObject,Codable{
    /// Vms
    var vms:[String:CreateVm?]?
    /// Eips
    var eips:[String:AllocateEipAddress?]?
    /// Subnets
    var subnets:[String:CreateSubnet?]?
    /// NetworkInterfaces
    var networkInterfaces:[String:CreateNetInterface?]?
    /// Slbs
    var slbs:[String:SlbInfo?]?
    /// SecurityGroups
    var securityGroups:[String:CreateSecurityGroup?]?
    /// SecurityGroupRules
    var securityGroupRules:[String:CreateSgRule?]?
    /// Keypairs
    var keypairs:[String:CreateKeypair?]?
    /// Disks
    var disks:[String:CreateDataDisk?]?
    /// Vpcs
    var vpcs:[String:VpcInfo?]?
    /// VserverGroups
    var vserverGroups:[String:CreateVserverGroup?]?
    /// HttpListeners
    var httpListeners:[String:CreateLoadBalancerHTTPListener?]?
    /// DiskAttachment
    var diskAttachment:[String:DeploymentAttachDisk?]?
    /// NetInterfaceAttachment
    var netInterfaceAttachment:[String:DeploymentAttachNetInterface?]?
    /// EipAssociate
    var eipAssociate:[String:DeploymentAssociateEip?]?
    /// Rds
    var rds:[String:CreateRDSInstance?]?
    /// RdsDatabase
    var rdsDatabase:[String:DeploymentRdsDatabase?]?
    /// RdsAccount
    var rdsAccount:[String:DeploymentRdsAccount?]?
    /// RdsAccountGrant
    var rdsAccountGrant:[String:DeploymentAccountGrant?]?
    /// Bucket
    var bucket:[String:DeploymentBucket?]?
    /// Variables
    var variables:[String:String?]?



    public override init(){
            super.init()
    }

    enum DeploymentResourcesInfoCodingKeys: String, CodingKey {
        case vms
        case eips
        case subnets
        case networkInterfaces
        case slbs
        case securityGroups
        case securityGroupRules
        case keypairs
        case disks
        case vpcs
        case vserverGroups
        case httpListeners
        case diskAttachment
        case netInterfaceAttachment
        case eipAssociate
        case rds
        case rdsDatabase
        case rdsAccount
        case rdsAccountGrant
        case bucket
        case variables
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: DeploymentResourcesInfoCodingKeys.self)
        if decoderContainer.contains(.vms)
        {
            self.vms = try decoderContainer.decode([String:CreateVm?]?.self, forKey: .vms)
        }
        if decoderContainer.contains(.eips)
        {
            self.eips = try decoderContainer.decode([String:AllocateEipAddress?]?.self, forKey: .eips)
        }
        if decoderContainer.contains(.subnets)
        {
            self.subnets = try decoderContainer.decode([String:CreateSubnet?]?.self, forKey: .subnets)
        }
        if decoderContainer.contains(.networkInterfaces)
        {
            self.networkInterfaces = try decoderContainer.decode([String:CreateNetInterface?]?.self, forKey: .networkInterfaces)
        }
        if decoderContainer.contains(.slbs)
        {
            self.slbs = try decoderContainer.decode([String:SlbInfo?]?.self, forKey: .slbs)
        }
        if decoderContainer.contains(.securityGroups)
        {
            self.securityGroups = try decoderContainer.decode([String:CreateSecurityGroup?]?.self, forKey: .securityGroups)
        }
        if decoderContainer.contains(.securityGroupRules)
        {
            self.securityGroupRules = try decoderContainer.decode([String:CreateSgRule?]?.self, forKey: .securityGroupRules)
        }
        if decoderContainer.contains(.keypairs)
        {
            self.keypairs = try decoderContainer.decode([String:CreateKeypair?]?.self, forKey: .keypairs)
        }
        if decoderContainer.contains(.disks)
        {
            self.disks = try decoderContainer.decode([String:CreateDataDisk?]?.self, forKey: .disks)
        }
        if decoderContainer.contains(.vpcs)
        {
            self.vpcs = try decoderContainer.decode([String:VpcInfo?]?.self, forKey: .vpcs)
        }
        if decoderContainer.contains(.vserverGroups)
        {
            self.vserverGroups = try decoderContainer.decode([String:CreateVserverGroup?]?.self, forKey: .vserverGroups)
        }
        if decoderContainer.contains(.httpListeners)
        {
            self.httpListeners = try decoderContainer.decode([String:CreateLoadBalancerHTTPListener?]?.self, forKey: .httpListeners)
        }
        if decoderContainer.contains(.diskAttachment)
        {
            self.diskAttachment = try decoderContainer.decode([String:DeploymentAttachDisk?]?.self, forKey: .diskAttachment)
        }
        if decoderContainer.contains(.netInterfaceAttachment)
        {
            self.netInterfaceAttachment = try decoderContainer.decode([String:DeploymentAttachNetInterface?]?.self, forKey: .netInterfaceAttachment)
        }
        if decoderContainer.contains(.eipAssociate)
        {
            self.eipAssociate = try decoderContainer.decode([String:DeploymentAssociateEip?]?.self, forKey: .eipAssociate)
        }
        if decoderContainer.contains(.rds)
        {
            self.rds = try decoderContainer.decode([String:CreateRDSInstance?]?.self, forKey: .rds)
        }
        if decoderContainer.contains(.rdsDatabase)
        {
            self.rdsDatabase = try decoderContainer.decode([String:DeploymentRdsDatabase?]?.self, forKey: .rdsDatabase)
        }
        if decoderContainer.contains(.rdsAccount)
        {
            self.rdsAccount = try decoderContainer.decode([String:DeploymentRdsAccount?]?.self, forKey: .rdsAccount)
        }
        if decoderContainer.contains(.rdsAccountGrant)
        {
            self.rdsAccountGrant = try decoderContainer.decode([String:DeploymentAccountGrant?]?.self, forKey: .rdsAccountGrant)
        }
        if decoderContainer.contains(.bucket)
        {
            self.bucket = try decoderContainer.decode([String:DeploymentBucket?]?.self, forKey: .bucket)
        }
        if decoderContainer.contains(.variables)
        {
            self.variables = try decoderContainer.decode([String:String?]?.self, forKey: .variables)
        }
    }
}
public extension DeploymentResourcesInfo{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: DeploymentResourcesInfoCodingKeys.self)
         try encoderContainer.encode(vms, forKey: .vms)
         try encoderContainer.encode(eips, forKey: .eips)
         try encoderContainer.encode(subnets, forKey: .subnets)
         try encoderContainer.encode(networkInterfaces, forKey: .networkInterfaces)
         try encoderContainer.encode(slbs, forKey: .slbs)
         try encoderContainer.encode(securityGroups, forKey: .securityGroups)
         try encoderContainer.encode(securityGroupRules, forKey: .securityGroupRules)
         try encoderContainer.encode(keypairs, forKey: .keypairs)
         try encoderContainer.encode(disks, forKey: .disks)
         try encoderContainer.encode(vpcs, forKey: .vpcs)
         try encoderContainer.encode(vserverGroups, forKey: .vserverGroups)
         try encoderContainer.encode(httpListeners, forKey: .httpListeners)
         try encoderContainer.encode(diskAttachment, forKey: .diskAttachment)
         try encoderContainer.encode(netInterfaceAttachment, forKey: .netInterfaceAttachment)
         try encoderContainer.encode(eipAssociate, forKey: .eipAssociate)
         try encoderContainer.encode(rds, forKey: .rds)
         try encoderContainer.encode(rdsDatabase, forKey: .rdsDatabase)
         try encoderContainer.encode(rdsAccount, forKey: .rdsAccount)
         try encoderContainer.encode(rdsAccountGrant, forKey: .rdsAccountGrant)
         try encoderContainer.encode(bucket, forKey: .bucket)
         try encoderContainer.encode(variables, forKey: .variables)
    }
}
///  负载均衡后端服务
public class BackendServer:NSObject,Codable{
    /// 所属云ID
    var cloudID:String?
    /// 负载均衡实例ID。
    var serverId:String?
    /// 负载均衡实例的名称。
    var serverHealthStatus:String?
    /// 后端服务器端口。
    var port:Int32?
    /// 后端服务器的权重。
    var weight:Int32?
    /// 后端服务器类型。
    var type:String?



    public override init(){
            super.init()
    }

    enum BackendServerCodingKeys: String, CodingKey {
        case cloudID
        case serverId
        case serverHealthStatus
        case port
        case weight
        case type
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: BackendServerCodingKeys.self)
        if decoderContainer.contains(.cloudID)
        {
            self.cloudID = try decoderContainer.decode(String?.self, forKey: .cloudID)
        }
        if decoderContainer.contains(.serverId)
        {
            self.serverId = try decoderContainer.decode(String?.self, forKey: .serverId)
        }
        if decoderContainer.contains(.serverHealthStatus)
        {
            self.serverHealthStatus = try decoderContainer.decode(String?.self, forKey: .serverHealthStatus)
        }
        if decoderContainer.contains(.port)
        {
            self.port = try decoderContainer.decode(Int32?.self, forKey: .port)
        }
        if decoderContainer.contains(.weight)
        {
            self.weight = try decoderContainer.decode(Int32?.self, forKey: .weight)
        }
        if decoderContainer.contains(.type)
        {
            self.type = try decoderContainer.decode(String?.self, forKey: .type)
        }
    }
}
public extension BackendServer{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: BackendServerCodingKeys.self)
         try encoderContainer.encode(cloudID, forKey: .cloudID)
         try encoderContainer.encode(serverId, forKey: .serverId)
         try encoderContainer.encode(serverHealthStatus, forKey: .serverHealthStatus)
         try encoderContainer.encode(port, forKey: .port)
         try encoderContainer.encode(weight, forKey: .weight)
         try encoderContainer.encode(type, forKey: .type)
    }
}
///  createKeypair
public class CreateKeypair:NSObject,Codable{
    /// 密钥名称
    /// Required:true
    var name:String
    /// 密钥指纹
    var keyFingerprint:String?
    /// 云注册信息ID
    var cloudID:String?
    /// 否  导入的公钥
    var publicKey:String?



    public  init(name:String){
             self.name = name
    }

    enum CreateKeypairCodingKeys: String, CodingKey {
        case name
        case keyFingerprint
        case cloudID
        case publicKey
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: CreateKeypairCodingKeys.self)
        self.name = try decoderContainer.decode(String.self, forKey: .name)
        if decoderContainer.contains(.keyFingerprint)
        {
            self.keyFingerprint = try decoderContainer.decode(String?.self, forKey: .keyFingerprint)
        }
        if decoderContainer.contains(.cloudID)
        {
            self.cloudID = try decoderContainer.decode(String?.self, forKey: .cloudID)
        }
        if decoderContainer.contains(.publicKey)
        {
            self.publicKey = try decoderContainer.decode(String?.self, forKey: .publicKey)
        }
    }
}
public extension CreateKeypair{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: CreateKeypairCodingKeys.self)
         try encoderContainer.encode(name, forKey: .name)
         try encoderContainer.encode(keyFingerprint, forKey: .keyFingerprint)
         try encoderContainer.encode(cloudID, forKey: .cloudID)
         try encoderContainer.encode(publicKey, forKey: .publicKey)
    }
}
///  createVserverGroup
public class CreateVserverGroup:NSObject,Codable{
    /// 负载均衡实例ID
    var loadBalancerId:String?
    /// 服务器组名称
    var vserverGroupName:String?
    /// 安全组权限规则集合
    var backendServers:[BackendServer?]?



    public override init(){
            super.init()
    }

    enum CreateVserverGroupCodingKeys: String, CodingKey {
        case loadBalancerId
        case vserverGroupName
        case backendServers
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: CreateVserverGroupCodingKeys.self)
        if decoderContainer.contains(.loadBalancerId)
        {
            self.loadBalancerId = try decoderContainer.decode(String?.self, forKey: .loadBalancerId)
        }
        if decoderContainer.contains(.vserverGroupName)
        {
            self.vserverGroupName = try decoderContainer.decode(String?.self, forKey: .vserverGroupName)
        }
        if decoderContainer.contains(.backendServers)
        {
            self.backendServers = try decoderContainer.decode([BackendServer?]?.self, forKey: .backendServers)
        }
    }
}
public extension CreateVserverGroup{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: CreateVserverGroupCodingKeys.self)
         try encoderContainer.encode(loadBalancerId, forKey: .loadBalancerId)
         try encoderContainer.encode(vserverGroupName, forKey: .vserverGroupName)
         try encoderContainer.encode(backendServers, forKey: .backendServers)
    }
}
///  挂载网卡
public class DeploymentAttachNetInterface:NSObject,Codable{
    /// 网卡 id
    /// Required:true
    var interfaceId:String
    /// 虚拟机 id
    /// Required:true
    var instanceId:String



    public  init(interfaceId:String,instanceId:String){
             self.interfaceId = interfaceId
             self.instanceId = instanceId
    }

    enum DeploymentAttachNetInterfaceCodingKeys: String, CodingKey {
        case interfaceId
        case instanceId
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: DeploymentAttachNetInterfaceCodingKeys.self)
        self.interfaceId = try decoderContainer.decode(String.self, forKey: .interfaceId)
        self.instanceId = try decoderContainer.decode(String.self, forKey: .instanceId)
    }
}
public extension DeploymentAttachNetInterface{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: DeploymentAttachNetInterfaceCodingKeys.self)
         try encoderContainer.encode(interfaceId, forKey: .interfaceId)
         try encoderContainer.encode(instanceId, forKey: .instanceId)
    }
}
///  createNetInterface
public class CreateNetInterface:NSObject,Codable{
    /// 网卡的Id
    var id:String?
    /// 网卡名称
    var name:String?
    /// 网卡描述信息
    var descriptionValue:String?
    /// VPC的Id
    var vpcId:String?
    /// 网卡类型
    var type:String?
    /// 子网id
    /// Required:true
    var subnetId:String
    /// 可用区的 ID
    var az:String?
    /// 弹性网卡关联的公网 IP
    var associatedPublicIp:String?
    /// 弹性网卡主私有 IP 地址
    var privateIpAddress:String?
    /// 弹性网卡的 MAC 地址
    var macAddress:String?
    /// 弹性网卡附加的实例 ID
    var instanceId:String?
    /// 创建时间
    var createdTime:String?
    /// 所属云提供商ID
    var cloudID:String?
    /// 安全组
    /// Required:true
    var securityGroupId:String



    public  init(subnetId:String,securityGroupId:String){
             self.subnetId = subnetId
             self.securityGroupId = securityGroupId
    }

    enum CreateNetInterfaceCodingKeys: String, CodingKey {
        case id
        case name
        case descriptionValue = "description"
        case vpcId
        case type
        case subnetId
        case az
        case associatedPublicIp
        case privateIpAddress
        case macAddress
        case instanceId
        case createdTime
        case cloudID
        case securityGroupId
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: CreateNetInterfaceCodingKeys.self)
        if decoderContainer.contains(.id)
        {
            self.id = try decoderContainer.decode(String?.self, forKey: .id)
        }
        if decoderContainer.contains(.name)
        {
            self.name = try decoderContainer.decode(String?.self, forKey: .name)
        }
        if decoderContainer.contains(.descriptionValue)
        {
            self.descriptionValue = try decoderContainer.decode(String?.self, forKey: .descriptionValue)
        }
        if decoderContainer.contains(.vpcId)
        {
            self.vpcId = try decoderContainer.decode(String?.self, forKey: .vpcId)
        }
        if decoderContainer.contains(.type)
        {
            self.type = try decoderContainer.decode(String?.self, forKey: .type)
        }
        self.subnetId = try decoderContainer.decode(String.self, forKey: .subnetId)
        if decoderContainer.contains(.az)
        {
            self.az = try decoderContainer.decode(String?.self, forKey: .az)
        }
        if decoderContainer.contains(.associatedPublicIp)
        {
            self.associatedPublicIp = try decoderContainer.decode(String?.self, forKey: .associatedPublicIp)
        }
        if decoderContainer.contains(.privateIpAddress)
        {
            self.privateIpAddress = try decoderContainer.decode(String?.self, forKey: .privateIpAddress)
        }
        if decoderContainer.contains(.macAddress)
        {
            self.macAddress = try decoderContainer.decode(String?.self, forKey: .macAddress)
        }
        if decoderContainer.contains(.instanceId)
        {
            self.instanceId = try decoderContainer.decode(String?.self, forKey: .instanceId)
        }
        if decoderContainer.contains(.createdTime)
        {
            self.createdTime = try decoderContainer.decode(String?.self, forKey: .createdTime)
        }
        if decoderContainer.contains(.cloudID)
        {
            self.cloudID = try decoderContainer.decode(String?.self, forKey: .cloudID)
        }
        self.securityGroupId = try decoderContainer.decode(String.self, forKey: .securityGroupId)
    }
}
public extension CreateNetInterface{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: CreateNetInterfaceCodingKeys.self)
         try encoderContainer.encode(id, forKey: .id)
         try encoderContainer.encode(name, forKey: .name)
         try encoderContainer.encode(descriptionValue, forKey: .descriptionValue)
         try encoderContainer.encode(vpcId, forKey: .vpcId)
         try encoderContainer.encode(type, forKey: .type)
         try encoderContainer.encode(subnetId, forKey: .subnetId)
         try encoderContainer.encode(az, forKey: .az)
         try encoderContainer.encode(associatedPublicIp, forKey: .associatedPublicIp)
         try encoderContainer.encode(privateIpAddress, forKey: .privateIpAddress)
         try encoderContainer.encode(macAddress, forKey: .macAddress)
         try encoderContainer.encode(instanceId, forKey: .instanceId)
         try encoderContainer.encode(createdTime, forKey: .createdTime)
         try encoderContainer.encode(cloudID, forKey: .cloudID)
         try encoderContainer.encode(securityGroupId, forKey: .securityGroupId)
    }
}
///  arrayDiskAttachment
public class ArrayDiskAttachment:NSObject,Codable{
    /// 挂载实例的ID
    var instanceId:String?



    public override init(){
            super.init()
    }

    enum ArrayDiskAttachmentCodingKeys: String, CodingKey {
        case instanceId
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: ArrayDiskAttachmentCodingKeys.self)
        if decoderContainer.contains(.instanceId)
        {
            self.instanceId = try decoderContainer.decode(String?.self, forKey: .instanceId)
        }
    }
}
public extension ArrayDiskAttachment{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: ArrayDiskAttachmentCodingKeys.self)
         try encoderContainer.encode(instanceId, forKey: .instanceId)
    }
}
///  部署信息
public class DeploymentBaseInfo:NSObject,Codable{
    /// 云ID
    var cloudId:String?
    /// 版本
    var version:String?
    /// 是否只读 0：否 1：是
    var readOnly:Int32?
    /// ID
    var id:String?
    /// 名称
    var name:String?
    /// 描述
    var descriptionValue:String?
    /// 用户ID
    var userId:String?
    /// 创建时间
    var createdTime:String?
    /// 更新时间
    var updatedTime:String?
    /// 最近一次操作
    var lastOperation:String?



    public override init(){
            super.init()
    }

    enum DeploymentBaseInfoCodingKeys: String, CodingKey {
        case cloudId
        case version
        case readOnly
        case id
        case name
        case descriptionValue = "description"
        case userId
        case createdTime
        case updatedTime
        case lastOperation
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: DeploymentBaseInfoCodingKeys.self)
        if decoderContainer.contains(.cloudId)
        {
            self.cloudId = try decoderContainer.decode(String?.self, forKey: .cloudId)
        }
        if decoderContainer.contains(.version)
        {
            self.version = try decoderContainer.decode(String?.self, forKey: .version)
        }
        if decoderContainer.contains(.readOnly)
        {
            self.readOnly = try decoderContainer.decode(Int32?.self, forKey: .readOnly)
        }
        if decoderContainer.contains(.id)
        {
            self.id = try decoderContainer.decode(String?.self, forKey: .id)
        }
        if decoderContainer.contains(.name)
        {
            self.name = try decoderContainer.decode(String?.self, forKey: .name)
        }
        if decoderContainer.contains(.descriptionValue)
        {
            self.descriptionValue = try decoderContainer.decode(String?.self, forKey: .descriptionValue)
        }
        if decoderContainer.contains(.userId)
        {
            self.userId = try decoderContainer.decode(String?.self, forKey: .userId)
        }
        if decoderContainer.contains(.createdTime)
        {
            self.createdTime = try decoderContainer.decode(String?.self, forKey: .createdTime)
        }
        if decoderContainer.contains(.updatedTime)
        {
            self.updatedTime = try decoderContainer.decode(String?.self, forKey: .updatedTime)
        }
        if decoderContainer.contains(.lastOperation)
        {
            self.lastOperation = try decoderContainer.decode(String?.self, forKey: .lastOperation)
        }
    }
}
public extension DeploymentBaseInfo{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: DeploymentBaseInfoCodingKeys.self)
         try encoderContainer.encode(cloudId, forKey: .cloudId)
         try encoderContainer.encode(version, forKey: .version)
         try encoderContainer.encode(readOnly, forKey: .readOnly)
         try encoderContainer.encode(id, forKey: .id)
         try encoderContainer.encode(name, forKey: .name)
         try encoderContainer.encode(descriptionValue, forKey: .descriptionValue)
         try encoderContainer.encode(userId, forKey: .userId)
         try encoderContainer.encode(createdTime, forKey: .createdTime)
         try encoderContainer.encode(updatedTime, forKey: .updatedTime)
         try encoderContainer.encode(lastOperation, forKey: .lastOperation)
    }
}
///  分配公网IP
public class AllocateEipAddress:NSObject,Codable{
    /// 公网IP名称
    /// Required:true
    var name:String
    /// EIP的带宽峰值，单位为Mbps
    /// Required:true
    var bandwidth:String
    /// IP服务商
    /// Required:true
    var provider:String



    public  init(name:String,bandwidth:String,provider:String){
             self.name = name
             self.bandwidth = bandwidth
             self.provider = provider
    }

    enum AllocateEipAddressCodingKeys: String, CodingKey {
        case name
        case bandwidth
        case provider
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: AllocateEipAddressCodingKeys.self)
        self.name = try decoderContainer.decode(String.self, forKey: .name)
        self.bandwidth = try decoderContainer.decode(String.self, forKey: .bandwidth)
        self.provider = try decoderContainer.decode(String.self, forKey: .provider)
    }
}
public extension AllocateEipAddress{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: AllocateEipAddressCodingKeys.self)
         try encoderContainer.encode(name, forKey: .name)
         try encoderContainer.encode(bandwidth, forKey: .bandwidth)
         try encoderContainer.encode(provider, forKey: .provider)
    }
}
///  负载均衡实例描述
public class SlbInfo:NSObject,Codable{
    /// 所属云ID
    var cloudID:String?
    /// 负载均衡实例ID。
    var id:String?
    /// 负载均衡实例的名称。
    var name:String?
    /// 负载均衡实例状态
    var status:String?
    /// 负载均衡实例的服务地址。
    var ipAddress:String?
    /// 负载均衡实例的网络类型。
    var addressType:String?
    /// 私网负载均衡实例的交换机ID。
    var subnetId:String?
    /// 私网负载均衡实例的专有网络ID。
    var vpc:String?
    /// 私网负载均衡实例的网络类型
    var networkType:String?
    /// 可用区域。
    var azs:[String?]?
    /// 创建时间
    var createdTime:String?



    public override init(){
            super.init()
    }

    enum SlbInfoCodingKeys: String, CodingKey {
        case cloudID
        case id
        case name
        case status
        case ipAddress
        case addressType
        case subnetId
        case vpc
        case networkType
        case azs
        case createdTime
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: SlbInfoCodingKeys.self)
        if decoderContainer.contains(.cloudID)
        {
            self.cloudID = try decoderContainer.decode(String?.self, forKey: .cloudID)
        }
        if decoderContainer.contains(.id)
        {
            self.id = try decoderContainer.decode(String?.self, forKey: .id)
        }
        if decoderContainer.contains(.name)
        {
            self.name = try decoderContainer.decode(String?.self, forKey: .name)
        }
        if decoderContainer.contains(.status)
        {
            self.status = try decoderContainer.decode(String?.self, forKey: .status)
        }
        if decoderContainer.contains(.ipAddress)
        {
            self.ipAddress = try decoderContainer.decode(String?.self, forKey: .ipAddress)
        }
        if decoderContainer.contains(.addressType)
        {
            self.addressType = try decoderContainer.decode(String?.self, forKey: .addressType)
        }
        if decoderContainer.contains(.subnetId)
        {
            self.subnetId = try decoderContainer.decode(String?.self, forKey: .subnetId)
        }
        if decoderContainer.contains(.vpc)
        {
            self.vpc = try decoderContainer.decode(String?.self, forKey: .vpc)
        }
        if decoderContainer.contains(.networkType)
        {
            self.networkType = try decoderContainer.decode(String?.self, forKey: .networkType)
        }
        if decoderContainer.contains(.azs)
        {
            self.azs = try decoderContainer.decode([String?]?.self, forKey: .azs)
        }
        if decoderContainer.contains(.createdTime)
        {
            self.createdTime = try decoderContainer.decode(String?.self, forKey: .createdTime)
        }
    }
}
public extension SlbInfo{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: SlbInfoCodingKeys.self)
         try encoderContainer.encode(cloudID, forKey: .cloudID)
         try encoderContainer.encode(id, forKey: .id)
         try encoderContainer.encode(name, forKey: .name)
         try encoderContainer.encode(status, forKey: .status)
         try encoderContainer.encode(ipAddress, forKey: .ipAddress)
         try encoderContainer.encode(addressType, forKey: .addressType)
         try encoderContainer.encode(subnetId, forKey: .subnetId)
         try encoderContainer.encode(vpc, forKey: .vpc)
         try encoderContainer.encode(networkType, forKey: .networkType)
         try encoderContainer.encode(azs, forKey: .azs)
         try encoderContainer.encode(createdTime, forKey: .createdTime)
    }
}
///  deployment
public class Deployment:NSObject,Codable{
    /// 名称
    var name:String?



    public override init(){
            super.init()
    }

    enum DeploymentCodingKeys: String, CodingKey {
        case name
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: DeploymentCodingKeys.self)
        if decoderContainer.contains(.name)
        {
            self.name = try decoderContainer.decode(String?.self, forKey: .name)
        }
    }
}
public extension Deployment{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: DeploymentCodingKeys.self)
         try encoderContainer.encode(name, forKey: .name)
    }
}
///  deploymentInfo
public class DeploymentInfo:NSObject,Codable{
    /// Info
    var info:DeploymentBaseInfo?
    /// Content
    var content:DeploymentResourcesInfo?



    public override init(){
            super.init()
    }

    enum DeploymentInfoCodingKeys: String, CodingKey {
        case info
        case content
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: DeploymentInfoCodingKeys.self)
        if decoderContainer.contains(.info)
        {
            self.info = try decoderContainer.decode(DeploymentBaseInfo?.self, forKey: .info)
        }
        if decoderContainer.contains(.content)
        {
            self.content = try decoderContainer.decode(DeploymentResourcesInfo?.self, forKey: .content)
        }
    }
}
public extension DeploymentInfo{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: DeploymentInfoCodingKeys.self)
         try encoderContainer.encode(info, forKey: .info)
         try encoderContainer.encode(content, forKey: .content)
    }
}
///  创建安全组规则
public class CreateSgRule:NSObject,Codable{
    /// 规则类型，ingress、egress
    /// Required:true
    var ruleType:String
    /// 协议，tcp、udp、icmp 或者 all
    /// Required:true
    var protocolValue:String
    /// 起始端口
    /// Required:true
    var fromPort:Int32
    /// 终止端口
    /// Required:true
    var toPort:Int32
    /// 安全组ID
    /// Required:true
    var securityGroupId:String
    /// 网络类型，internet、intranet
    var nicType:String?
    /// 认证策略，accept、drop
    var policy:String?
    /// 认证策略的权重，1-100。
    var priority:Int32?
    /// 目标IP地址范围
    /// Required:true
    var cidrIp:String



    public  init(ruleType:String,protocolValue:String,fromPort:Int32,toPort:Int32,securityGroupId:String,cidrIp:String){
             self.ruleType = ruleType
             self.protocolValue = protocolValue
             self.fromPort = fromPort
             self.toPort = toPort
             self.securityGroupId = securityGroupId
             self.cidrIp = cidrIp
    }

    enum CreateSgRuleCodingKeys: String, CodingKey {
        case ruleType
        case protocolValue = "protocol"
        case fromPort
        case toPort
        case securityGroupId
        case nicType
        case policy
        case priority
        case cidrIp
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: CreateSgRuleCodingKeys.self)
        self.ruleType = try decoderContainer.decode(String.self, forKey: .ruleType)
        self.protocolValue = try decoderContainer.decode(String.self, forKey: .protocolValue)
        self.fromPort = try decoderContainer.decode(Int32.self, forKey: .fromPort)
        self.toPort = try decoderContainer.decode(Int32.self, forKey: .toPort)
        self.securityGroupId = try decoderContainer.decode(String.self, forKey: .securityGroupId)
        if decoderContainer.contains(.nicType)
        {
            self.nicType = try decoderContainer.decode(String?.self, forKey: .nicType)
        }
        if decoderContainer.contains(.policy)
        {
            self.policy = try decoderContainer.decode(String?.self, forKey: .policy)
        }
        if decoderContainer.contains(.priority)
        {
            self.priority = try decoderContainer.decode(Int32?.self, forKey: .priority)
        }
        self.cidrIp = try decoderContainer.decode(String.self, forKey: .cidrIp)
    }
}
public extension CreateSgRule{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: CreateSgRuleCodingKeys.self)
         try encoderContainer.encode(ruleType, forKey: .ruleType)
         try encoderContainer.encode(protocolValue, forKey: .protocolValue)
         try encoderContainer.encode(fromPort, forKey: .fromPort)
         try encoderContainer.encode(toPort, forKey: .toPort)
         try encoderContainer.encode(securityGroupId, forKey: .securityGroupId)
         try encoderContainer.encode(nicType, forKey: .nicType)
         try encoderContainer.encode(policy, forKey: .policy)
         try encoderContainer.encode(priority, forKey: .priority)
         try encoderContainer.encode(cidrIp, forKey: .cidrIp)
    }
}
///  apply
public class Apply:NSObject,Codable{
    /// 备注信息
    var comment:String?



    public override init(){
            super.init()
    }

    enum ApplyCodingKeys: String, CodingKey {
        case comment
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: ApplyCodingKeys.self)
        if decoderContainer.contains(.comment)
        {
            self.comment = try decoderContainer.decode(String?.self, forKey: .comment)
        }
    }
}
public extension Apply{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: ApplyCodingKeys.self)
         try encoderContainer.encode(comment, forKey: .comment)
    }
}
///  createSecurityGroup
public class CreateSecurityGroup:NSObject,Codable{
    /// 注册云信息ID
    var cloudID:String?
    /// 安全组 id
    var id:String?
    /// 目标安全组名称
    var name:String?
    /// 安全组描述信息
    var descriptionValue:String?
    /// VPC id
    var vpcId:String?
    /// 创建时间
    var createdTime:String?



    public override init(){
            super.init()
    }

    enum CreateSecurityGroupCodingKeys: String, CodingKey {
        case cloudID
        case id
        case name
        case descriptionValue = "description"
        case vpcId
        case createdTime
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: CreateSecurityGroupCodingKeys.self)
        if decoderContainer.contains(.cloudID)
        {
            self.cloudID = try decoderContainer.decode(String?.self, forKey: .cloudID)
        }
        if decoderContainer.contains(.id)
        {
            self.id = try decoderContainer.decode(String?.self, forKey: .id)
        }
        if decoderContainer.contains(.name)
        {
            self.name = try decoderContainer.decode(String?.self, forKey: .name)
        }
        if decoderContainer.contains(.descriptionValue)
        {
            self.descriptionValue = try decoderContainer.decode(String?.self, forKey: .descriptionValue)
        }
        if decoderContainer.contains(.vpcId)
        {
            self.vpcId = try decoderContainer.decode(String?.self, forKey: .vpcId)
        }
        if decoderContainer.contains(.createdTime)
        {
            self.createdTime = try decoderContainer.decode(String?.self, forKey: .createdTime)
        }
    }
}
public extension CreateSecurityGroup{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: CreateSecurityGroupCodingKeys.self)
         try encoderContainer.encode(cloudID, forKey: .cloudID)
         try encoderContainer.encode(id, forKey: .id)
         try encoderContainer.encode(name, forKey: .name)
         try encoderContainer.encode(descriptionValue, forKey: .descriptionValue)
         try encoderContainer.encode(vpcId, forKey: .vpcId)
         try encoderContainer.encode(createdTime, forKey: .createdTime)
    }
}
///  createLoadBalancerHTTPListener
public class CreateLoadBalancerHTTPListener:NSObject,Codable{
    /// 是  负载均衡实例ID
    var loadBalancerId:String?
    /// 是  负载均衡实例前端使用的端口
    var listenerPort:Int32?
    /// 是  负载均衡实例后端使用的端口
    var backendServerPort:Int32?
    /// 否  服务器组ID
    var vserverGroupId:String?
    /// 是  监听的带宽峰值
    var bandwidth:Int32?
    /// 否  健康检查使用的端口
    var healthCheckConnectPort:Int32?
    /// 否  健康检查连续成功多少次后，将后端服务器的健康检查状态由fail判定为success。取值：2-10
    var healthyThreshold:Int32?
    /// 否  健康检查连续失败多少次后，将后端服务器的健康检查状态由success判定为fail。取值：2-10
    var unhealthyThreshold:Int32?
    /// 否  接收来自运行状况检查的响应需要等待的时间。如果后端ECS在指定的时间内没有正确响应，则判定为健康检查失败。取值：1-300（秒）
    var healthCheckTimeout:Int32?
    /// 否  健康检查的时间间隔。取值：1-50（秒）
    var healthCheckInterval:Int32?
    /// 否  健康检查正常的HTTP状态码，多个状态码用逗号分隔。取值：http_2xx（默认值） | http_3xx | http_4xx | http_5xx
    var healthCheckHttpCode:String?



    public override init(){
            super.init()
    }

    enum CreateLoadBalancerHTTPListenerCodingKeys: String, CodingKey {
        case loadBalancerId
        case listenerPort
        case backendServerPort
        case vserverGroupId
        case bandwidth
        case healthCheckConnectPort
        case healthyThreshold
        case unhealthyThreshold
        case healthCheckTimeout
        case healthCheckInterval
        case healthCheckHttpCode
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: CreateLoadBalancerHTTPListenerCodingKeys.self)
        if decoderContainer.contains(.loadBalancerId)
        {
            self.loadBalancerId = try decoderContainer.decode(String?.self, forKey: .loadBalancerId)
        }
        if decoderContainer.contains(.listenerPort)
        {
            self.listenerPort = try decoderContainer.decode(Int32?.self, forKey: .listenerPort)
        }
        if decoderContainer.contains(.backendServerPort)
        {
            self.backendServerPort = try decoderContainer.decode(Int32?.self, forKey: .backendServerPort)
        }
        if decoderContainer.contains(.vserverGroupId)
        {
            self.vserverGroupId = try decoderContainer.decode(String?.self, forKey: .vserverGroupId)
        }
        if decoderContainer.contains(.bandwidth)
        {
            self.bandwidth = try decoderContainer.decode(Int32?.self, forKey: .bandwidth)
        }
        if decoderContainer.contains(.healthCheckConnectPort)
        {
            self.healthCheckConnectPort = try decoderContainer.decode(Int32?.self, forKey: .healthCheckConnectPort)
        }
        if decoderContainer.contains(.healthyThreshold)
        {
            self.healthyThreshold = try decoderContainer.decode(Int32?.self, forKey: .healthyThreshold)
        }
        if decoderContainer.contains(.unhealthyThreshold)
        {
            self.unhealthyThreshold = try decoderContainer.decode(Int32?.self, forKey: .unhealthyThreshold)
        }
        if decoderContainer.contains(.healthCheckTimeout)
        {
            self.healthCheckTimeout = try decoderContainer.decode(Int32?.self, forKey: .healthCheckTimeout)
        }
        if decoderContainer.contains(.healthCheckInterval)
        {
            self.healthCheckInterval = try decoderContainer.decode(Int32?.self, forKey: .healthCheckInterval)
        }
        if decoderContainer.contains(.healthCheckHttpCode)
        {
            self.healthCheckHttpCode = try decoderContainer.decode(String?.self, forKey: .healthCheckHttpCode)
        }
    }
}
public extension CreateLoadBalancerHTTPListener{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: CreateLoadBalancerHTTPListenerCodingKeys.self)
         try encoderContainer.encode(loadBalancerId, forKey: .loadBalancerId)
         try encoderContainer.encode(listenerPort, forKey: .listenerPort)
         try encoderContainer.encode(backendServerPort, forKey: .backendServerPort)
         try encoderContainer.encode(vserverGroupId, forKey: .vserverGroupId)
         try encoderContainer.encode(bandwidth, forKey: .bandwidth)
         try encoderContainer.encode(healthCheckConnectPort, forKey: .healthCheckConnectPort)
         try encoderContainer.encode(healthyThreshold, forKey: .healthyThreshold)
         try encoderContainer.encode(unhealthyThreshold, forKey: .unhealthyThreshold)
         try encoderContainer.encode(healthCheckTimeout, forKey: .healthCheckTimeout)
         try encoderContainer.encode(healthCheckInterval, forKey: .healthCheckInterval)
         try encoderContainer.encode(healthCheckHttpCode, forKey: .healthCheckHttpCode)
    }
}
///  创建账号
public class DeploymentRdsAccount:NSObject,Codable{
    /// 实例ID
    var instId:String?
    /// 账号名称
    var name:String?
    /// 账号密码
    var password:String?



    public override init(){
            super.init()
    }

    enum DeploymentRdsAccountCodingKeys: String, CodingKey {
        case instId
        case name
        case password
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: DeploymentRdsAccountCodingKeys.self)
        if decoderContainer.contains(.instId)
        {
            self.instId = try decoderContainer.decode(String?.self, forKey: .instId)
        }
        if decoderContainer.contains(.name)
        {
            self.name = try decoderContainer.decode(String?.self, forKey: .name)
        }
        if decoderContainer.contains(.password)
        {
            self.password = try decoderContainer.decode(String?.self, forKey: .password)
        }
    }
}
public extension DeploymentRdsAccount{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: DeploymentRdsAccountCodingKeys.self)
         try encoderContainer.encode(instId, forKey: .instId)
         try encoderContainer.encode(name, forKey: .name)
         try encoderContainer.encode(password, forKey: .password)
    }
}
///  创建数据库
public class DeploymentRdsDatabase:NSObject,Codable{
    /// 实例ID
    var instId:String?
    /// 数据库名称
    var name:String?
    /// 字符编码
    var characterSetName:String?



    public override init(){
            super.init()
    }

    enum DeploymentRdsDatabaseCodingKeys: String, CodingKey {
        case instId
        case name
        case characterSetName
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: DeploymentRdsDatabaseCodingKeys.self)
        if decoderContainer.contains(.instId)
        {
            self.instId = try decoderContainer.decode(String?.self, forKey: .instId)
        }
        if decoderContainer.contains(.name)
        {
            self.name = try decoderContainer.decode(String?.self, forKey: .name)
        }
        if decoderContainer.contains(.characterSetName)
        {
            self.characterSetName = try decoderContainer.decode(String?.self, forKey: .characterSetName)
        }
    }
}
public extension DeploymentRdsDatabase{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: DeploymentRdsDatabaseCodingKeys.self)
         try encoderContainer.encode(instId, forKey: .instId)
         try encoderContainer.encode(name, forKey: .name)
         try encoderContainer.encode(characterSetName, forKey: .characterSetName)
    }
}
///  createDataDisk
public class CreateDataDisk:NSObject,Codable{
    /// 云注册信息ID
    var cloudID:String?
    /// 云硬盘ID
    var id:String?
    /// 云硬盘名称
    var name:String?
    /// 云硬盘描述
    var descriptionValue:String?
    /// 磁盘大小,单位为 GiB
    /// Required:true
    var diskSizeGB:Int32
    /// 挂载信息
    var attachments:[ArrayDiskAttachment?]?
    /// 云硬盘所属AZ
    /// Required:true
    var az:String
    /// 磁盘类型,取值为 ssd 或 premium-hdd
    var diskType:String?
    /// 创建该云硬盘的快照ID
    var snapshotId:String?
    /// 云硬盘状态
    var status:String?
    /// Tags
    var tags:[Tag?]?
    /// 创建时间
    var createdTime:String?



    public  init(diskSizeGB:Int32,az:String){
             self.diskSizeGB = diskSizeGB
             self.az = az
    }

    enum CreateDataDiskCodingKeys: String, CodingKey {
        case cloudID
        case id
        case name
        case descriptionValue = "description"
        case diskSizeGB
        case attachments
        case az
        case diskType
        case snapshotId
        case status
        case tags
        case createdTime
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: CreateDataDiskCodingKeys.self)
        if decoderContainer.contains(.cloudID)
        {
            self.cloudID = try decoderContainer.decode(String?.self, forKey: .cloudID)
        }
        if decoderContainer.contains(.id)
        {
            self.id = try decoderContainer.decode(String?.self, forKey: .id)
        }
        if decoderContainer.contains(.name)
        {
            self.name = try decoderContainer.decode(String?.self, forKey: .name)
        }
        if decoderContainer.contains(.descriptionValue)
        {
            self.descriptionValue = try decoderContainer.decode(String?.self, forKey: .descriptionValue)
        }
        self.diskSizeGB = try decoderContainer.decode(Int32.self, forKey: .diskSizeGB)
        if decoderContainer.contains(.attachments)
        {
            self.attachments = try decoderContainer.decode([ArrayDiskAttachment?]?.self, forKey: .attachments)
        }
        self.az = try decoderContainer.decode(String.self, forKey: .az)
        if decoderContainer.contains(.diskType)
        {
            self.diskType = try decoderContainer.decode(String?.self, forKey: .diskType)
        }
        if decoderContainer.contains(.snapshotId)
        {
            self.snapshotId = try decoderContainer.decode(String?.self, forKey: .snapshotId)
        }
        if decoderContainer.contains(.status)
        {
            self.status = try decoderContainer.decode(String?.self, forKey: .status)
        }
        if decoderContainer.contains(.tags)
        {
            self.tags = try decoderContainer.decode([Tag?]?.self, forKey: .tags)
        }
        if decoderContainer.contains(.createdTime)
        {
            self.createdTime = try decoderContainer.decode(String?.self, forKey: .createdTime)
        }
    }
}
public extension CreateDataDisk{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: CreateDataDiskCodingKeys.self)
         try encoderContainer.encode(cloudID, forKey: .cloudID)
         try encoderContainer.encode(id, forKey: .id)
         try encoderContainer.encode(name, forKey: .name)
         try encoderContainer.encode(descriptionValue, forKey: .descriptionValue)
         try encoderContainer.encode(diskSizeGB, forKey: .diskSizeGB)
         try encoderContainer.encode(attachments, forKey: .attachments)
         try encoderContainer.encode(az, forKey: .az)
         try encoderContainer.encode(diskType, forKey: .diskType)
         try encoderContainer.encode(snapshotId, forKey: .snapshotId)
         try encoderContainer.encode(status, forKey: .status)
         try encoderContainer.encode(tags, forKey: .tags)
         try encoderContainer.encode(createdTime, forKey: .createdTime)
    }
}
///  taskInfo
public class TaskInfo:NSObject,Codable{
    /// 任务执行开始时间
    var beginTime:String?
    /// 任务执行结束时间
    var endTime:String?
    /// 任务执行状态：running、finished
    var taskStatus:String?
    /// 任务执行结果：done、error、nochange
    var taskResult:String?
    /// 任务执行最后编码:
      /// CREATEING_RESOURCE_INFO-&gt;未完成:正在构建目标资源信息
      /// CREATE_RESOURCE_INFO_ERROR-&gt;失败完成:目标资源描述信息创建失败！
      /// CREATE_RESOURCE_INFO_SUCCESS-&gt;未完成:目标资源描述信息创建成功！开始初始化构建程序
      /// PROGRAM_INITING-&gt;未完成:正在初始化构建程序
      /// PROGRAM_INIT_ERROR-&gt;失败完成:构建程序初始化失败！
      /// PROGRAM_INIT_SUCCESS-&gt;未完成:构建程序初始化成功！开始分析本次构建任务
      /// TASK_PLAN_ERROR-&gt;失败完成:构建分析发生错误！
      /// TASK_PLAN_NOCHANGE-&gt;完成:本次构建无可执行操作
      /// TASK_PLAN_SUCCESS-&gt;未完成:分析完成！开始执行资源构建
      /// TASK_RUN_FAILED-&gt;失败完成:资源构建任务执行失败！
      /// TASK_RUN_NOCHANGE-&gt;完成:本次构建未执行任何操作
      /// TASK_RUN_SUCCESS-&gt;完成:资源构建任务执行完毕！
    var lastCode:String?
    /// 任务执行之后编码描述
    var taskLastInfo:String?
    /// 任务执行成功后返回的ID列表
    var resourceIDs:[AnyObject?]?
    /// 任务执行日志信息
    var msg:[AnyObject?]?



    public override init(){
            super.init()
    }

    enum TaskInfoCodingKeys: String, CodingKey {
        case beginTime
        case endTime
        case taskStatus
        case taskResult
        case lastCode
        case taskLastInfo
        case resourceIDs
        case msg
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: TaskInfoCodingKeys.self)
        if decoderContainer.contains(.beginTime)
        {
            self.beginTime = try decoderContainer.decode(String?.self, forKey: .beginTime)
        }
        if decoderContainer.contains(.endTime)
        {
            self.endTime = try decoderContainer.decode(String?.self, forKey: .endTime)
        }
        if decoderContainer.contains(.taskStatus)
        {
            self.taskStatus = try decoderContainer.decode(String?.self, forKey: .taskStatus)
        }
        if decoderContainer.contains(.taskResult)
        {
            self.taskResult = try decoderContainer.decode(String?.self, forKey: .taskResult)
        }
        if decoderContainer.contains(.lastCode)
        {
            self.lastCode = try decoderContainer.decode(String?.self, forKey: .lastCode)
        }
        if decoderContainer.contains(.taskLastInfo)
        {
            self.taskLastInfo = try decoderContainer.decode(String?.self, forKey: .taskLastInfo)
        }
    }
}
public extension TaskInfo{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: TaskInfoCodingKeys.self)
         try encoderContainer.encode(beginTime, forKey: .beginTime)
         try encoderContainer.encode(endTime, forKey: .endTime)
         try encoderContainer.encode(taskStatus, forKey: .taskStatus)
         try encoderContainer.encode(taskResult, forKey: .taskResult)
         try encoderContainer.encode(lastCode, forKey: .lastCode)
         try encoderContainer.encode(taskLastInfo, forKey: .taskLastInfo)
    }
}
///  reverseDeploymentInfo
public class ReverseDeploymentInfo:NSObject,Codable{
    /// 模板名称
    var name:String?
    /// 描述
    var descriptionValue:String?
    /// 版本
    var version:String?
    /// 是否只读 0：否 1：是
    var readOnly:Int32?
    /// Resources
    var resources:ReverseDeploymentResourcesInfo?



    public override init(){
            super.init()
    }

    enum ReverseDeploymentInfoCodingKeys: String, CodingKey {
        case name
        case descriptionValue = "description"
        case version
        case readOnly
        case resources
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: ReverseDeploymentInfoCodingKeys.self)
        if decoderContainer.contains(.name)
        {
            self.name = try decoderContainer.decode(String?.self, forKey: .name)
        }
        if decoderContainer.contains(.descriptionValue)
        {
            self.descriptionValue = try decoderContainer.decode(String?.self, forKey: .descriptionValue)
        }
        if decoderContainer.contains(.version)
        {
            self.version = try decoderContainer.decode(String?.self, forKey: .version)
        }
        if decoderContainer.contains(.readOnly)
        {
            self.readOnly = try decoderContainer.decode(Int32?.self, forKey: .readOnly)
        }
        if decoderContainer.contains(.resources)
        {
            self.resources = try decoderContainer.decode(ReverseDeploymentResourcesInfo?.self, forKey: .resources)
        }
    }
}
public extension ReverseDeploymentInfo{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: ReverseDeploymentInfoCodingKeys.self)
         try encoderContainer.encode(name, forKey: .name)
         try encoderContainer.encode(descriptionValue, forKey: .descriptionValue)
         try encoderContainer.encode(version, forKey: .version)
         try encoderContainer.encode(readOnly, forKey: .readOnly)
         try encoderContainer.encode(resources, forKey: .resources)
    }
}
///  绑定公网IP
public class DeploymentAssociateEip:NSObject,Codable{
    /// 公网IP id
    var eipId:String?
    /// 云产品的实例ID
    var instanceId:String?
    /// 要解绑的资源类型  虚拟机：vm 负载均衡：slb
    var instanceType:String?



    public override init(){
            super.init()
    }

    enum DeploymentAssociateEipCodingKeys: String, CodingKey {
        case eipId
        case instanceId
        case instanceType
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: DeploymentAssociateEipCodingKeys.self)
        if decoderContainer.contains(.eipId)
        {
            self.eipId = try decoderContainer.decode(String?.self, forKey: .eipId)
        }
        if decoderContainer.contains(.instanceId)
        {
            self.instanceId = try decoderContainer.decode(String?.self, forKey: .instanceId)
        }
        if decoderContainer.contains(.instanceType)
        {
            self.instanceType = try decoderContainer.decode(String?.self, forKey: .instanceType)
        }
    }
}
public extension DeploymentAssociateEip{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: DeploymentAssociateEipCodingKeys.self)
         try encoderContainer.encode(eipId, forKey: .eipId)
         try encoderContainer.encode(instanceId, forKey: .instanceId)
         try encoderContainer.encode(instanceType, forKey: .instanceType)
    }
}
///  账号授权
public class DeploymentAccountGrant:NSObject,Codable{
    /// 实例ID
    var instId:String?
    /// 账号名称
    var accountName:String?
    /// 数据库名称
    var dbName:String?
    /// 权限
    var privilege:String?



    public override init(){
            super.init()
    }

    enum DeploymentAccountGrantCodingKeys: String, CodingKey {
        case instId
        case accountName
        case dbName
        case privilege
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: DeploymentAccountGrantCodingKeys.self)
        if decoderContainer.contains(.instId)
        {
            self.instId = try decoderContainer.decode(String?.self, forKey: .instId)
        }
        if decoderContainer.contains(.accountName)
        {
            self.accountName = try decoderContainer.decode(String?.self, forKey: .accountName)
        }
        if decoderContainer.contains(.dbName)
        {
            self.dbName = try decoderContainer.decode(String?.self, forKey: .dbName)
        }
        if decoderContainer.contains(.privilege)
        {
            self.privilege = try decoderContainer.decode(String?.self, forKey: .privilege)
        }
    }
}
public extension DeploymentAccountGrant{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: DeploymentAccountGrantCodingKeys.self)
         try encoderContainer.encode(instId, forKey: .instId)
         try encoderContainer.encode(accountName, forKey: .accountName)
         try encoderContainer.encode(dbName, forKey: .dbName)
         try encoderContainer.encode(privilege, forKey: .privilege)
    }
}
///  资源ID
public class ReverseDeploymentResourcesInfo:NSObject,Codable{
    /// VmIds
    var vmIds:[String:String?]?
    /// EipIds
    var eipIds:[String:String?]?
    /// SubnetIds
    var subnetIds:[String:String?]?
    /// NetworkInterfaceIds
    var networkInterfaceIds:[String:String?]?
    /// SlbIds
    var slbIds:[String:String?]?
    /// SecurityGroupIds
    var securityGroupIds:[String:String?]?
    /// KeypairIds
    var keypairIds:[String:String?]?
    /// DiskIds
    var diskIds:[String:String?]?
    /// VpcIds
    var vpcIds:[String:String?]?
    /// VserverGroupIds
    var vserverGroupIds:[String:String?]?
    /// HttpListenerIds
    var httpListenerIds:[String:String?]?
    /// DiskAttachmentIds
    var diskAttachmentIds:[String:String?]?
    /// NetInterfaceAttachmentIds
    var netInterfaceAttachmentIds:[String:String?]?
    /// EipAssociateIds
    var eipAssociateIds:[String:String?]?



    public override init(){
            super.init()
    }

    enum ReverseDeploymentResourcesInfoCodingKeys: String, CodingKey {
        case vmIds
        case eipIds
        case subnetIds
        case networkInterfaceIds
        case slbIds
        case securityGroupIds
        case keypairIds
        case diskIds
        case vpcIds
        case vserverGroupIds
        case httpListenerIds
        case diskAttachmentIds
        case netInterfaceAttachmentIds
        case eipAssociateIds
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: ReverseDeploymentResourcesInfoCodingKeys.self)
        if decoderContainer.contains(.vmIds)
        {
            self.vmIds = try decoderContainer.decode([String:String?]?.self, forKey: .vmIds)
        }
        if decoderContainer.contains(.eipIds)
        {
            self.eipIds = try decoderContainer.decode([String:String?]?.self, forKey: .eipIds)
        }
        if decoderContainer.contains(.subnetIds)
        {
            self.subnetIds = try decoderContainer.decode([String:String?]?.self, forKey: .subnetIds)
        }
        if decoderContainer.contains(.networkInterfaceIds)
        {
            self.networkInterfaceIds = try decoderContainer.decode([String:String?]?.self, forKey: .networkInterfaceIds)
        }
        if decoderContainer.contains(.slbIds)
        {
            self.slbIds = try decoderContainer.decode([String:String?]?.self, forKey: .slbIds)
        }
        if decoderContainer.contains(.securityGroupIds)
        {
            self.securityGroupIds = try decoderContainer.decode([String:String?]?.self, forKey: .securityGroupIds)
        }
        if decoderContainer.contains(.keypairIds)
        {
            self.keypairIds = try decoderContainer.decode([String:String?]?.self, forKey: .keypairIds)
        }
        if decoderContainer.contains(.diskIds)
        {
            self.diskIds = try decoderContainer.decode([String:String?]?.self, forKey: .diskIds)
        }
        if decoderContainer.contains(.vpcIds)
        {
            self.vpcIds = try decoderContainer.decode([String:String?]?.self, forKey: .vpcIds)
        }
        if decoderContainer.contains(.vserverGroupIds)
        {
            self.vserverGroupIds = try decoderContainer.decode([String:String?]?.self, forKey: .vserverGroupIds)
        }
        if decoderContainer.contains(.httpListenerIds)
        {
            self.httpListenerIds = try decoderContainer.decode([String:String?]?.self, forKey: .httpListenerIds)
        }
        if decoderContainer.contains(.diskAttachmentIds)
        {
            self.diskAttachmentIds = try decoderContainer.decode([String:String?]?.self, forKey: .diskAttachmentIds)
        }
        if decoderContainer.contains(.netInterfaceAttachmentIds)
        {
            self.netInterfaceAttachmentIds = try decoderContainer.decode([String:String?]?.self, forKey: .netInterfaceAttachmentIds)
        }
        if decoderContainer.contains(.eipAssociateIds)
        {
            self.eipAssociateIds = try decoderContainer.decode([String:String?]?.self, forKey: .eipAssociateIds)
        }
    }
}
public extension ReverseDeploymentResourcesInfo{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: ReverseDeploymentResourcesInfoCodingKeys.self)
         try encoderContainer.encode(vmIds, forKey: .vmIds)
         try encoderContainer.encode(eipIds, forKey: .eipIds)
         try encoderContainer.encode(subnetIds, forKey: .subnetIds)
         try encoderContainer.encode(networkInterfaceIds, forKey: .networkInterfaceIds)
         try encoderContainer.encode(slbIds, forKey: .slbIds)
         try encoderContainer.encode(securityGroupIds, forKey: .securityGroupIds)
         try encoderContainer.encode(keypairIds, forKey: .keypairIds)
         try encoderContainer.encode(diskIds, forKey: .diskIds)
         try encoderContainer.encode(vpcIds, forKey: .vpcIds)
         try encoderContainer.encode(vserverGroupIds, forKey: .vserverGroupIds)
         try encoderContainer.encode(httpListenerIds, forKey: .httpListenerIds)
         try encoderContainer.encode(diskAttachmentIds, forKey: .diskAttachmentIds)
         try encoderContainer.encode(netInterfaceAttachmentIds, forKey: .netInterfaceAttachmentIds)
         try encoderContainer.encode(eipAssociateIds, forKey: .eipAssociateIds)
    }
}
///  秘钥对信息
public class KeypairInfo:NSObject,Codable{
    /// 密钥名称
    var name:String?
    /// 密钥指纹
    var keyFingerprint:String?
    /// 云注册信息ID
    var cloudID:String?



    public override init(){
            super.init()
    }

    enum KeypairInfoCodingKeys: String, CodingKey {
        case name
        case keyFingerprint
        case cloudID
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: KeypairInfoCodingKeys.self)
        if decoderContainer.contains(.name)
        {
            self.name = try decoderContainer.decode(String?.self, forKey: .name)
        }
        if decoderContainer.contains(.keyFingerprint)
        {
            self.keyFingerprint = try decoderContainer.decode(String?.self, forKey: .keyFingerprint)
        }
        if decoderContainer.contains(.cloudID)
        {
            self.cloudID = try decoderContainer.decode(String?.self, forKey: .cloudID)
        }
    }
}
public extension KeypairInfo{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: KeypairInfoCodingKeys.self)
         try encoderContainer.encode(name, forKey: .name)
         try encoderContainer.encode(keyFingerprint, forKey: .keyFingerprint)
         try encoderContainer.encode(cloudID, forKey: .cloudID)
    }
}
///  文件信息
public class TransferTaskFailedFileInfo:NSObject,Codable{
    /// 文件路径
    var path:String?



    public override init(){
            super.init()
    }

    enum TransferTaskFailedFileInfoCodingKeys: String, CodingKey {
        case path
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: TransferTaskFailedFileInfoCodingKeys.self)
        if decoderContainer.contains(.path)
        {
            self.path = try decoderContainer.decode(String?.self, forKey: .path)
        }
    }
}
public extension TransferTaskFailedFileInfo{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: TransferTaskFailedFileInfoCodingKeys.self)
         try encoderContainer.encode(path, forKey: .path)
    }
}
///  创建任务信息
public class TransferTaskProgressInfo:NSObject,Codable{
    /// 任务ID
    var id:String?
    /// 运行状态
    var status:String?
    /// 启动时间
    var timeStart:String?
    /// 迁移成功文件个数
    var succeedFileCount:String?
    /// 迁移失败文件个数
    var failedFileCount:String?



    public override init(){
            super.init()
    }

    enum TransferTaskProgressInfoCodingKeys: String, CodingKey {
        case id
        case status
        case timeStart
        case succeedFileCount
        case failedFileCount
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: TransferTaskProgressInfoCodingKeys.self)
        if decoderContainer.contains(.id)
        {
            self.id = try decoderContainer.decode(String?.self, forKey: .id)
        }
        if decoderContainer.contains(.status)
        {
            self.status = try decoderContainer.decode(String?.self, forKey: .status)
        }
        if decoderContainer.contains(.timeStart)
        {
            self.timeStart = try decoderContainer.decode(String?.self, forKey: .timeStart)
        }
        if decoderContainer.contains(.succeedFileCount)
        {
            self.succeedFileCount = try decoderContainer.decode(String?.self, forKey: .succeedFileCount)
        }
        if decoderContainer.contains(.failedFileCount)
        {
            self.failedFileCount = try decoderContainer.decode(String?.self, forKey: .failedFileCount)
        }
    }
}
public extension TransferTaskProgressInfo{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: TransferTaskProgressInfoCodingKeys.self)
         try encoderContainer.encode(id, forKey: .id)
         try encoderContainer.encode(status, forKey: .status)
         try encoderContainer.encode(timeStart, forKey: .timeStart)
         try encoderContainer.encode(succeedFileCount, forKey: .succeedFileCount)
         try encoderContainer.encode(failedFileCount, forKey: .failedFileCount)
    }
}
///  taskAddressInfo
public class TaskAddressInfo:NSObject,Codable{
    /// 任务类型:源地址中支持 s3file, aliyunfile，目标现在只支持s3file
    var storageType:String?
    /// 源地址的accesskey
    var accessKey:String?
    /// 源地址的securitykey
    var secretKey:String?
    /// 源地址的Endpoint
    var endpoint:String?
    /// 源地址的Bucket
    var bucket:String?
    /// 源地址的Prefix，不能以/开头
    var prefix:String?
    /// 云信息ID
    var cloudID:String?



    public override init(){
            super.init()
    }

    enum TaskAddressInfoCodingKeys: String, CodingKey {
        case storageType
        case accessKey
        case secretKey
        case endpoint
        case bucket
        case prefix
        case cloudID
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: TaskAddressInfoCodingKeys.self)
        if decoderContainer.contains(.storageType)
        {
            self.storageType = try decoderContainer.decode(String?.self, forKey: .storageType)
        }
        if decoderContainer.contains(.accessKey)
        {
            self.accessKey = try decoderContainer.decode(String?.self, forKey: .accessKey)
        }
        if decoderContainer.contains(.secretKey)
        {
            self.secretKey = try decoderContainer.decode(String?.self, forKey: .secretKey)
        }
        if decoderContainer.contains(.endpoint)
        {
            self.endpoint = try decoderContainer.decode(String?.self, forKey: .endpoint)
        }
        if decoderContainer.contains(.bucket)
        {
            self.bucket = try decoderContainer.decode(String?.self, forKey: .bucket)
        }
        if decoderContainer.contains(.prefix)
        {
            self.prefix = try decoderContainer.decode(String?.self, forKey: .prefix)
        }
        if decoderContainer.contains(.cloudID)
        {
            self.cloudID = try decoderContainer.decode(String?.self, forKey: .cloudID)
        }
    }
}
public extension TaskAddressInfo{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: TaskAddressInfoCodingKeys.self)
         try encoderContainer.encode(storageType, forKey: .storageType)
         try encoderContainer.encode(accessKey, forKey: .accessKey)
         try encoderContainer.encode(secretKey, forKey: .secretKey)
         try encoderContainer.encode(endpoint, forKey: .endpoint)
         try encoderContainer.encode(bucket, forKey: .bucket)
         try encoderContainer.encode(prefix, forKey: .prefix)
         try encoderContainer.encode(cloudID, forKey: .cloudID)
    }
}
///  transferSimpleTaskInfo
public class TransferSimpleTaskInfo:NSObject,Codable{
    /// 任务名称
    var name:String?
    /// SrcAddress
    var srcAddress:SimpleTaskAddressInfo?
    /// DstAddress
    var dstAddress:SimpleTaskAddressInfo?



    public override init(){
            super.init()
    }

    enum TransferSimpleTaskInfoCodingKeys: String, CodingKey {
        case name
        case srcAddress
        case dstAddress
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: TransferSimpleTaskInfoCodingKeys.self)
        if decoderContainer.contains(.name)
        {
            self.name = try decoderContainer.decode(String?.self, forKey: .name)
        }
        if decoderContainer.contains(.srcAddress)
        {
            self.srcAddress = try decoderContainer.decode(SimpleTaskAddressInfo?.self, forKey: .srcAddress)
        }
        if decoderContainer.contains(.dstAddress)
        {
            self.dstAddress = try decoderContainer.decode(SimpleTaskAddressInfo?.self, forKey: .dstAddress)
        }
    }
}
public extension TransferSimpleTaskInfo{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: TransferSimpleTaskInfoCodingKeys.self)
         try encoderContainer.encode(name, forKey: .name)
         try encoderContainer.encode(srcAddress, forKey: .srcAddress)
         try encoderContainer.encode(dstAddress, forKey: .dstAddress)
    }
}
///  transferTaskInfo
public class TransferTaskInfo:NSObject,Codable{
    /// 任务名称
    var name:String?
    /// SrcAddress
    var srcAddress:TaskAddressInfo?
    /// DstAddress
    var dstAddress:TaskAddressInfo?



    public override init(){
            super.init()
    }

    enum TransferTaskInfoCodingKeys: String, CodingKey {
        case name
        case srcAddress
        case dstAddress
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: TransferTaskInfoCodingKeys.self)
        if decoderContainer.contains(.name)
        {
            self.name = try decoderContainer.decode(String?.self, forKey: .name)
        }
        if decoderContainer.contains(.srcAddress)
        {
            self.srcAddress = try decoderContainer.decode(TaskAddressInfo?.self, forKey: .srcAddress)
        }
        if decoderContainer.contains(.dstAddress)
        {
            self.dstAddress = try decoderContainer.decode(TaskAddressInfo?.self, forKey: .dstAddress)
        }
    }
}
public extension TransferTaskInfo{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: TransferTaskInfoCodingKeys.self)
         try encoderContainer.encode(name, forKey: .name)
         try encoderContainer.encode(srcAddress, forKey: .srcAddress)
         try encoderContainer.encode(dstAddress, forKey: .dstAddress)
    }
}
///  simpleTaskAddressInfo
public class SimpleTaskAddressInfo:NSObject,Codable{
    /// 云信息ID
    var cloudID:String?
    /// 源地址的Bucket
    var bucket:String?
    /// 源地址的Prefix，不能以/开头
    var prefix:String?



    public override init(){
            super.init()
    }

    enum SimpleTaskAddressInfoCodingKeys: String, CodingKey {
        case cloudID
        case bucket
        case prefix
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: SimpleTaskAddressInfoCodingKeys.self)
        if decoderContainer.contains(.cloudID)
        {
            self.cloudID = try decoderContainer.decode(String?.self, forKey: .cloudID)
        }
        if decoderContainer.contains(.bucket)
        {
            self.bucket = try decoderContainer.decode(String?.self, forKey: .bucket)
        }
        if decoderContainer.contains(.prefix)
        {
            self.prefix = try decoderContainer.decode(String?.self, forKey: .prefix)
        }
    }
}
public extension SimpleTaskAddressInfo{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: SimpleTaskAddressInfoCodingKeys.self)
         try encoderContainer.encode(cloudID, forKey: .cloudID)
         try encoderContainer.encode(bucket, forKey: .bucket)
         try encoderContainer.encode(prefix, forKey: .prefix)
    }
}
///  迁移任务信息
public class TransferTaskInfoWithID:NSObject,Codable{
    /// 任务ID
    var id:String?
    /// 任务名称
    var name:String?
    /// SrcAddress
    var srcAddress:TaskAddressInfo?
    /// DstAddress
    var dstAddress:TaskAddressInfo?



    public override init(){
            super.init()
    }

    enum TransferTaskInfoWithIDCodingKeys: String, CodingKey {
        case id
        case name
        case srcAddress
        case dstAddress
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: TransferTaskInfoWithIDCodingKeys.self)
        if decoderContainer.contains(.id)
        {
            self.id = try decoderContainer.decode(String?.self, forKey: .id)
        }
        if decoderContainer.contains(.name)
        {
            self.name = try decoderContainer.decode(String?.self, forKey: .name)
        }
        if decoderContainer.contains(.srcAddress)
        {
            self.srcAddress = try decoderContainer.decode(TaskAddressInfo?.self, forKey: .srcAddress)
        }
        if decoderContainer.contains(.dstAddress)
        {
            self.dstAddress = try decoderContainer.decode(TaskAddressInfo?.self, forKey: .dstAddress)
        }
    }
}
public extension TransferTaskInfoWithID{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: TransferTaskInfoWithIDCodingKeys.self)
         try encoderContainer.encode(id, forKey: .id)
         try encoderContainer.encode(name, forKey: .name)
         try encoderContainer.encode(srcAddress, forKey: .srcAddress)
         try encoderContainer.encode(dstAddress, forKey: .dstAddress)
    }
}
///  transferTaskFailedDetailInfo
public class TransferTaskFailedDetailInfo:NSObject,Codable{
    /// 错误文件个数
    var count:String?
    /// Files
    var files:[TransferTaskFailedFileInfo?]?



    public override init(){
            super.init()
    }

    enum TransferTaskFailedDetailInfoCodingKeys: String, CodingKey {
        case count
        case files
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: TransferTaskFailedDetailInfoCodingKeys.self)
        if decoderContainer.contains(.count)
        {
            self.count = try decoderContainer.decode(String?.self, forKey: .count)
        }
        if decoderContainer.contains(.files)
        {
            self.files = try decoderContainer.decode([TransferTaskFailedFileInfo?]?.self, forKey: .files)
        }
    }
}
public extension TransferTaskFailedDetailInfo{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: TransferTaskFailedDetailInfoCodingKeys.self)
         try encoderContainer.encode(count, forKey: .count)
         try encoderContainer.encode(files, forKey: .files)
    }
}
///  createOSSBucket
public class CreateOSSBucket:NSObject,Codable{
    /// 存储桶名称
    /// Required:true
    var name:String
    /// 创建时间
    var creationDate:String?
    /// 云信息
    var cloudID:String?
    /// 访问控制,private\public-read\public-read-write
    var acl:String?



    public  init(name:String){
             self.name = name
    }

    enum CreateOSSBucketCodingKeys: String, CodingKey {
        case name
        case creationDate
        case cloudID
        case acl
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: CreateOSSBucketCodingKeys.self)
        self.name = try decoderContainer.decode(String.self, forKey: .name)
        if decoderContainer.contains(.creationDate)
        {
            self.creationDate = try decoderContainer.decode(String?.self, forKey: .creationDate)
        }
        if decoderContainer.contains(.cloudID)
        {
            self.cloudID = try decoderContainer.decode(String?.self, forKey: .cloudID)
        }
        if decoderContainer.contains(.acl)
        {
            self.acl = try decoderContainer.decode(String?.self, forKey: .acl)
        }
    }
}
public extension CreateOSSBucket{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: CreateOSSBucketCodingKeys.self)
         try encoderContainer.encode(name, forKey: .name)
         try encoderContainer.encode(creationDate, forKey: .creationDate)
         try encoderContainer.encode(cloudID, forKey: .cloudID)
         try encoderContainer.encode(acl, forKey: .acl)
    }
}
///  OSS存储桶详细信息
public class OssBucketDetailInfo:NSObject,Codable{
    /// 存储桶名称
    var name:String?
    /// 存储桶权限
    var acl:String?
    /// 内网endpoint
    var intranetEndpoint:String?
    /// 外网endpoint
    var extranetEndpoint:String?
    /// 创建时间
    var creationDate:String?
    /// 云信息
    var cloudID:String?



    public override init(){
            super.init()
    }

    enum OssBucketDetailInfoCodingKeys: String, CodingKey {
        case name
        case acl
        case intranetEndpoint
        case extranetEndpoint
        case creationDate
        case cloudID
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: OssBucketDetailInfoCodingKeys.self)
        if decoderContainer.contains(.name)
        {
            self.name = try decoderContainer.decode(String?.self, forKey: .name)
        }
        if decoderContainer.contains(.acl)
        {
            self.acl = try decoderContainer.decode(String?.self, forKey: .acl)
        }
        if decoderContainer.contains(.intranetEndpoint)
        {
            self.intranetEndpoint = try decoderContainer.decode(String?.self, forKey: .intranetEndpoint)
        }
        if decoderContainer.contains(.extranetEndpoint)
        {
            self.extranetEndpoint = try decoderContainer.decode(String?.self, forKey: .extranetEndpoint)
        }
        if decoderContainer.contains(.creationDate)
        {
            self.creationDate = try decoderContainer.decode(String?.self, forKey: .creationDate)
        }
        if decoderContainer.contains(.cloudID)
        {
            self.cloudID = try decoderContainer.decode(String?.self, forKey: .cloudID)
        }
    }
}
public extension OssBucketDetailInfo{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: OssBucketDetailInfoCodingKeys.self)
         try encoderContainer.encode(name, forKey: .name)
         try encoderContainer.encode(acl, forKey: .acl)
         try encoderContainer.encode(intranetEndpoint, forKey: .intranetEndpoint)
         try encoderContainer.encode(extranetEndpoint, forKey: .extranetEndpoint)
         try encoderContainer.encode(creationDate, forKey: .creationDate)
         try encoderContainer.encode(cloudID, forKey: .cloudID)
    }
}
///  OSS文件信息
public class OssFileInfo:NSObject,Codable{
    /// 存储桶名称
    var bucketName:String?
    /// 文件存储Key值
    var key:String?
    /// 文件大小（字节）
    var size:Double?
    /// 上次修改时间
    var lastModifiedTime:String?
    /// 存储类型
    var storageClass:String?



    public override init(){
            super.init()
    }

    enum OssFileInfoCodingKeys: String, CodingKey {
        case bucketName
        case key
        case size
        case lastModifiedTime
        case storageClass
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: OssFileInfoCodingKeys.self)
        if decoderContainer.contains(.bucketName)
        {
            self.bucketName = try decoderContainer.decode(String?.self, forKey: .bucketName)
        }
        if decoderContainer.contains(.key)
        {
            self.key = try decoderContainer.decode(String?.self, forKey: .key)
        }
        if decoderContainer.contains(.size)
        {
            self.size = try decoderContainer.decode(Double?.self, forKey: .size)
        }
        if decoderContainer.contains(.lastModifiedTime)
        {
            self.lastModifiedTime = try decoderContainer.decode(String?.self, forKey: .lastModifiedTime)
        }
        if decoderContainer.contains(.storageClass)
        {
            self.storageClass = try decoderContainer.decode(String?.self, forKey: .storageClass)
        }
    }
}
public extension OssFileInfo{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: OssFileInfoCodingKeys.self)
         try encoderContainer.encode(bucketName, forKey: .bucketName)
         try encoderContainer.encode(key, forKey: .key)
         try encoderContainer.encode(size, forKey: .size)
         try encoderContainer.encode(lastModifiedTime, forKey: .lastModifiedTime)
         try encoderContainer.encode(storageClass, forKey: .storageClass)
    }
}
///  OSS存储桶信息
public class OssBucketInfo:NSObject,Codable{
    /// 存储桶名称
    var name:String?
    /// 创建时间
    var creationDate:String?
    /// 云信息
    var cloudID:String?



    public override init(){
            super.init()
    }

    enum OssBucketInfoCodingKeys: String, CodingKey {
        case name
        case creationDate
        case cloudID
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: OssBucketInfoCodingKeys.self)
        if decoderContainer.contains(.name)
        {
            self.name = try decoderContainer.decode(String?.self, forKey: .name)
        }
        if decoderContainer.contains(.creationDate)
        {
            self.creationDate = try decoderContainer.decode(String?.self, forKey: .creationDate)
        }
        if decoderContainer.contains(.cloudID)
        {
            self.cloudID = try decoderContainer.decode(String?.self, forKey: .cloudID)
        }
    }
}
public extension OssBucketInfo{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: OssBucketInfoCodingKeys.self)
         try encoderContainer.encode(name, forKey: .name)
         try encoderContainer.encode(creationDate, forKey: .creationDate)
         try encoderContainer.encode(cloudID, forKey: .cloudID)
    }
}
///  迁移通道
public class CloudInfo:NSObject,Codable{
    /// 云ID
    var cloudId:String?
    /// 数据库ID
    var rdsId:String?
    /// 数据库账号
    var username:String?
    /// 数据库密码
    var password:String?



    public override init(){
            super.init()
    }

    enum CloudInfoCodingKeys: String, CodingKey {
        case cloudId
        case rdsId
        case username
        case password
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: CloudInfoCodingKeys.self)
        if decoderContainer.contains(.cloudId)
        {
            self.cloudId = try decoderContainer.decode(String?.self, forKey: .cloudId)
        }
        if decoderContainer.contains(.rdsId)
        {
            self.rdsId = try decoderContainer.decode(String?.self, forKey: .rdsId)
        }
        if decoderContainer.contains(.username)
        {
            self.username = try decoderContainer.decode(String?.self, forKey: .username)
        }
        if decoderContainer.contains(.password)
        {
            self.password = try decoderContainer.decode(String?.self, forKey: .password)
        }
    }
}
public extension CloudInfo{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: CloudInfoCodingKeys.self)
         try encoderContainer.encode(cloudId, forKey: .cloudId)
         try encoderContainer.encode(rdsId, forKey: .rdsId)
         try encoderContainer.encode(username, forKey: .username)
         try encoderContainer.encode(password, forKey: .password)
    }
}
///  迁移通道
public class ChannelBaseInfo:NSObject,Codable{
    /// ID
    var id:String?
    /// 名称
    var name:String?
    /// 名称
    var descriptionValue:String?
    /// 状态
    var status:String?



    public override init(){
            super.init()
    }

    enum ChannelBaseInfoCodingKeys: String, CodingKey {
        case id
        case name
        case descriptionValue = "description"
        case status
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: ChannelBaseInfoCodingKeys.self)
        if decoderContainer.contains(.id)
        {
            self.id = try decoderContainer.decode(String?.self, forKey: .id)
        }
        if decoderContainer.contains(.name)
        {
            self.name = try decoderContainer.decode(String?.self, forKey: .name)
        }
        if decoderContainer.contains(.descriptionValue)
        {
            self.descriptionValue = try decoderContainer.decode(String?.self, forKey: .descriptionValue)
        }
        if decoderContainer.contains(.status)
        {
            self.status = try decoderContainer.decode(String?.self, forKey: .status)
        }
    }
}
public extension ChannelBaseInfo{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: ChannelBaseInfoCodingKeys.self)
         try encoderContainer.encode(id, forKey: .id)
         try encoderContainer.encode(name, forKey: .name)
         try encoderContainer.encode(descriptionValue, forKey: .descriptionValue)
         try encoderContainer.encode(status, forKey: .status)
    }
}
///  channelInfo
public class ChannelInfo:NSObject,Codable{
    /// Info
    var info:ChannelBaseInfo?
    /// Source
    var source:DataMediaInfo?
    /// Target
    var target:DataMediaInfo?



    public override init(){
            super.init()
    }

    enum ChannelInfoCodingKeys: String, CodingKey {
        case info
        case source
        case target
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: ChannelInfoCodingKeys.self)
        if decoderContainer.contains(.info)
        {
            self.info = try decoderContainer.decode(ChannelBaseInfo?.self, forKey: .info)
        }
        if decoderContainer.contains(.source)
        {
            self.source = try decoderContainer.decode(DataMediaInfo?.self, forKey: .source)
        }
        if decoderContainer.contains(.target)
        {
            self.target = try decoderContainer.decode(DataMediaInfo?.self, forKey: .target)
        }
    }
}
public extension ChannelInfo{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: ChannelInfoCodingKeys.self)
         try encoderContainer.encode(info, forKey: .info)
         try encoderContainer.encode(source, forKey: .source)
         try encoderContainer.encode(target, forKey: .target)
    }
}
///  源数据配置
public class DatasourceInfo:NSObject,Codable{
    /// ID
    var id:String?
    /// 服务器地址
    var address:String?
    /// 端口
    var port:Int32?
    /// 数据库账号
    var username:String?
    /// 数据库密码
    var password:String?



    public override init(){
            super.init()
    }

    enum DatasourceInfoCodingKeys: String, CodingKey {
        case id
        case address
        case port
        case username
        case password
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: DatasourceInfoCodingKeys.self)
        if decoderContainer.contains(.id)
        {
            self.id = try decoderContainer.decode(String?.self, forKey: .id)
        }
        if decoderContainer.contains(.address)
        {
            self.address = try decoderContainer.decode(String?.self, forKey: .address)
        }
        if decoderContainer.contains(.port)
        {
            self.port = try decoderContainer.decode(Int32?.self, forKey: .port)
        }
        if decoderContainer.contains(.username)
        {
            self.username = try decoderContainer.decode(String?.self, forKey: .username)
        }
        if decoderContainer.contains(.password)
        {
            self.password = try decoderContainer.decode(String?.self, forKey: .password)
        }
    }
}
public extension DatasourceInfo{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: DatasourceInfoCodingKeys.self)
         try encoderContainer.encode(id, forKey: .id)
         try encoderContainer.encode(address, forKey: .address)
         try encoderContainer.encode(port, forKey: .port)
         try encoderContainer.encode(username, forKey: .username)
         try encoderContainer.encode(password, forKey: .password)
    }
}
///  源数据配置
public class DataMediaInfo:NSObject,Codable{
    /// Cloud
    var cloud:CloudInfo?
    /// Datasource
    var datasource:DatasourceInfo?
    /// schema
    var schema:String?
    /// table
    var tables:[String?]?



    public override init(){
            super.init()
    }

    enum DataMediaInfoCodingKeys: String, CodingKey {
        case cloud
        case datasource
        case schema
        case tables
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: DataMediaInfoCodingKeys.self)
        if decoderContainer.contains(.cloud)
        {
            self.cloud = try decoderContainer.decode(CloudInfo?.self, forKey: .cloud)
        }
        if decoderContainer.contains(.datasource)
        {
            self.datasource = try decoderContainer.decode(DatasourceInfo?.self, forKey: .datasource)
        }
        if decoderContainer.contains(.schema)
        {
            self.schema = try decoderContainer.decode(String?.self, forKey: .schema)
        }
        if decoderContainer.contains(.tables)
        {
            self.tables = try decoderContainer.decode([String?]?.self, forKey: .tables)
        }
    }
}
public extension DataMediaInfo{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: DataMediaInfoCodingKeys.self)
         try encoderContainer.encode(cloud, forKey: .cloud)
         try encoderContainer.encode(datasource, forKey: .datasource)
         try encoderContainer.encode(schema, forKey: .schema)
         try encoderContainer.encode(tables, forKey: .tables)
    }
}
///  安全组规则类型
public class PermissionType:NSObject,Codable{
    /// 云注册信息ID
    var cloudID:String?
    /// IP协议
    var ipProtocol:String?
    /// 端口范围
    var portRange:String?
    /// 描述信息
    var descriptionValue:String?
    /// 源IP地址段，用于入方向授权
    var sourceCidrIp:String?
    /// 源安全组，用于入方向授权
    var sourceGroupId:String?
    /// 源安全组所属阿里云账户Id
    var sourceGroupOwnerAccount:String?
    /// 目标IP地址段，用于出方向授权
    var destCidrIp:String?
    /// 目标安全组，用于出方向授权
    var destGroupId:String?
    /// 目标安全组所属阿里云账户Id
    var destGroupOwnerAccount:String?
    /// 授权策略
    var policy:String?
    /// 网络类型
    var nicType:String?
    /// 规则优先级
    var priority:String?
    /// 授权方向
    var direction:String?



    public override init(){
            super.init()
    }

    enum PermissionTypeCodingKeys: String, CodingKey {
        case cloudID
        case ipProtocol
        case portRange
        case descriptionValue = "description"
        case sourceCidrIp
        case sourceGroupId
        case sourceGroupOwnerAccount
        case destCidrIp
        case destGroupId
        case destGroupOwnerAccount
        case policy
        case nicType
        case priority
        case direction
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: PermissionTypeCodingKeys.self)
        if decoderContainer.contains(.cloudID)
        {
            self.cloudID = try decoderContainer.decode(String?.self, forKey: .cloudID)
        }
        if decoderContainer.contains(.ipProtocol)
        {
            self.ipProtocol = try decoderContainer.decode(String?.self, forKey: .ipProtocol)
        }
        if decoderContainer.contains(.portRange)
        {
            self.portRange = try decoderContainer.decode(String?.self, forKey: .portRange)
        }
        if decoderContainer.contains(.descriptionValue)
        {
            self.descriptionValue = try decoderContainer.decode(String?.self, forKey: .descriptionValue)
        }
        if decoderContainer.contains(.sourceCidrIp)
        {
            self.sourceCidrIp = try decoderContainer.decode(String?.self, forKey: .sourceCidrIp)
        }
        if decoderContainer.contains(.sourceGroupId)
        {
            self.sourceGroupId = try decoderContainer.decode(String?.self, forKey: .sourceGroupId)
        }
        if decoderContainer.contains(.sourceGroupOwnerAccount)
        {
            self.sourceGroupOwnerAccount = try decoderContainer.decode(String?.self, forKey: .sourceGroupOwnerAccount)
        }
        if decoderContainer.contains(.destCidrIp)
        {
            self.destCidrIp = try decoderContainer.decode(String?.self, forKey: .destCidrIp)
        }
        if decoderContainer.contains(.destGroupId)
        {
            self.destGroupId = try decoderContainer.decode(String?.self, forKey: .destGroupId)
        }
        if decoderContainer.contains(.destGroupOwnerAccount)
        {
            self.destGroupOwnerAccount = try decoderContainer.decode(String?.self, forKey: .destGroupOwnerAccount)
        }
        if decoderContainer.contains(.policy)
        {
            self.policy = try decoderContainer.decode(String?.self, forKey: .policy)
        }
        if decoderContainer.contains(.nicType)
        {
            self.nicType = try decoderContainer.decode(String?.self, forKey: .nicType)
        }
        if decoderContainer.contains(.priority)
        {
            self.priority = try decoderContainer.decode(String?.self, forKey: .priority)
        }
        if decoderContainer.contains(.direction)
        {
            self.direction = try decoderContainer.decode(String?.self, forKey: .direction)
        }
    }
}
public extension PermissionType{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: PermissionTypeCodingKeys.self)
         try encoderContainer.encode(cloudID, forKey: .cloudID)
         try encoderContainer.encode(ipProtocol, forKey: .ipProtocol)
         try encoderContainer.encode(portRange, forKey: .portRange)
         try encoderContainer.encode(descriptionValue, forKey: .descriptionValue)
         try encoderContainer.encode(sourceCidrIp, forKey: .sourceCidrIp)
         try encoderContainer.encode(sourceGroupId, forKey: .sourceGroupId)
         try encoderContainer.encode(sourceGroupOwnerAccount, forKey: .sourceGroupOwnerAccount)
         try encoderContainer.encode(destCidrIp, forKey: .destCidrIp)
         try encoderContainer.encode(destGroupId, forKey: .destGroupId)
         try encoderContainer.encode(destGroupOwnerAccount, forKey: .destGroupOwnerAccount)
         try encoderContainer.encode(policy, forKey: .policy)
         try encoderContainer.encode(nicType, forKey: .nicType)
         try encoderContainer.encode(priority, forKey: .priority)
         try encoderContainer.encode(direction, forKey: .direction)
    }
}
///  安全组详情
public class SecurityGroupInfo:NSObject,Codable{
    /// 注册云信息ID
    var cloudID:String?
    /// 安全组 id
    var id:String?
    /// 目标安全组名称
    var name:String?
    /// 安全组描述信息
    var descriptionValue:String?
    /// VPC id
    var vpcId:String?
    /// 创建时间
    var createdTime:String?



    public override init(){
            super.init()
    }

    enum SecurityGroupInfoCodingKeys: String, CodingKey {
        case cloudID
        case id
        case name
        case descriptionValue = "description"
        case vpcId
        case createdTime
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: SecurityGroupInfoCodingKeys.self)
        if decoderContainer.contains(.cloudID)
        {
            self.cloudID = try decoderContainer.decode(String?.self, forKey: .cloudID)
        }
        if decoderContainer.contains(.id)
        {
            self.id = try decoderContainer.decode(String?.self, forKey: .id)
        }
        if decoderContainer.contains(.name)
        {
            self.name = try decoderContainer.decode(String?.self, forKey: .name)
        }
        if decoderContainer.contains(.descriptionValue)
        {
            self.descriptionValue = try decoderContainer.decode(String?.self, forKey: .descriptionValue)
        }
        if decoderContainer.contains(.vpcId)
        {
            self.vpcId = try decoderContainer.decode(String?.self, forKey: .vpcId)
        }
        if decoderContainer.contains(.createdTime)
        {
            self.createdTime = try decoderContainer.decode(String?.self, forKey: .createdTime)
        }
    }
}
public extension SecurityGroupInfo{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: SecurityGroupInfoCodingKeys.self)
         try encoderContainer.encode(cloudID, forKey: .cloudID)
         try encoderContainer.encode(id, forKey: .id)
         try encoderContainer.encode(name, forKey: .name)
         try encoderContainer.encode(descriptionValue, forKey: .descriptionValue)
         try encoderContainer.encode(vpcId, forKey: .vpcId)
         try encoderContainer.encode(createdTime, forKey: .createdTime)
    }
}
///  securityGroupDetail
public class SecurityGroupDetail:NSObject,Codable{
    /// 注册云信息ID
    var cloudID:String?
    /// 安全组 id
    var id:String?
    /// 目标安全组名称
    var name:String?
    /// 安全组描述信息
    var descriptionValue:String?
    /// VPC id
    var vpcId:String?
    /// 创建时间
    var createdTime:String?
    /// 安全组权限规则集合
    var permissions:[PermissionType?]?



    public override init(){
            super.init()
    }

    enum SecurityGroupDetailCodingKeys: String, CodingKey {
        case cloudID
        case id
        case name
        case descriptionValue = "description"
        case vpcId
        case createdTime
        case permissions
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: SecurityGroupDetailCodingKeys.self)
        if decoderContainer.contains(.cloudID)
        {
            self.cloudID = try decoderContainer.decode(String?.self, forKey: .cloudID)
        }
        if decoderContainer.contains(.id)
        {
            self.id = try decoderContainer.decode(String?.self, forKey: .id)
        }
        if decoderContainer.contains(.name)
        {
            self.name = try decoderContainer.decode(String?.self, forKey: .name)
        }
        if decoderContainer.contains(.descriptionValue)
        {
            self.descriptionValue = try decoderContainer.decode(String?.self, forKey: .descriptionValue)
        }
        if decoderContainer.contains(.vpcId)
        {
            self.vpcId = try decoderContainer.decode(String?.self, forKey: .vpcId)
        }
        if decoderContainer.contains(.createdTime)
        {
            self.createdTime = try decoderContainer.decode(String?.self, forKey: .createdTime)
        }
        if decoderContainer.contains(.permissions)
        {
            self.permissions = try decoderContainer.decode([PermissionType?]?.self, forKey: .permissions)
        }
    }
}
public extension SecurityGroupDetail{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: SecurityGroupDetailCodingKeys.self)
         try encoderContainer.encode(cloudID, forKey: .cloudID)
         try encoderContainer.encode(id, forKey: .id)
         try encoderContainer.encode(name, forKey: .name)
         try encoderContainer.encode(descriptionValue, forKey: .descriptionValue)
         try encoderContainer.encode(vpcId, forKey: .vpcId)
         try encoderContainer.encode(createdTime, forKey: .createdTime)
         try encoderContainer.encode(permissions, forKey: .permissions)
    }
}
///  createRDSAccount
public class CreateRDSAccount:NSObject,Codable{
    /// 账号名
    /// Required:true
    var name:String
    /// 密码
    /// Required:true
    var password:String



    public  init(name:String,password:String){
             self.name = name
             self.password = password
    }

    enum CreateRDSAccountCodingKeys: String, CodingKey {
        case name
        case password
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: CreateRDSAccountCodingKeys.self)
        self.name = try decoderContainer.decode(String.self, forKey: .name)
        self.password = try decoderContainer.decode(String.self, forKey: .password)
    }
}
public extension CreateRDSAccount{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: CreateRDSAccountCodingKeys.self)
         try encoderContainer.encode(name, forKey: .name)
         try encoderContainer.encode(password, forKey: .password)
    }
}
///  dbPrivilegeInfo
public class DbPrivilegeInfo:NSObject,Codable{
    /// 数据库名
    /// Required:true
    var dbName:String
    /// 权限，RO:只读，RW:读写
    /// Required:true
    var privilege:String



    public  init(dbName:String,privilege:String){
             self.dbName = dbName
             self.privilege = privilege
    }

    enum DbPrivilegeInfoCodingKeys: String, CodingKey {
        case dbName
        case privilege
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: DbPrivilegeInfoCodingKeys.self)
        self.dbName = try decoderContainer.decode(String.self, forKey: .dbName)
        self.privilege = try decoderContainer.decode(String.self, forKey: .privilege)
    }
}
public extension DbPrivilegeInfo{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: DbPrivilegeInfoCodingKeys.self)
         try encoderContainer.encode(dbName, forKey: .dbName)
         try encoderContainer.encode(privilege, forKey: .privilege)
    }
}
///  RDS实例账号的权限
public class RdsAccountPrivilege:NSObject,Codable{
    /// 数据库名称
    var dbName:String?
    /// 账号对数据库所具有的权限
    var privilege:String?
    /// 所属云提供商ID
    var cloudID:String?



    public override init(){
            super.init()
    }

    enum RdsAccountPrivilegeCodingKeys: String, CodingKey {
        case dbName
        case privilege
        case cloudID
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: RdsAccountPrivilegeCodingKeys.self)
        if decoderContainer.contains(.dbName)
        {
            self.dbName = try decoderContainer.decode(String?.self, forKey: .dbName)
        }
        if decoderContainer.contains(.privilege)
        {
            self.privilege = try decoderContainer.decode(String?.self, forKey: .privilege)
        }
        if decoderContainer.contains(.cloudID)
        {
            self.cloudID = try decoderContainer.decode(String?.self, forKey: .cloudID)
        }
    }
}
public extension RdsAccountPrivilege{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: RdsAccountPrivilegeCodingKeys.self)
         try encoderContainer.encode(dbName, forKey: .dbName)
         try encoderContainer.encode(privilege, forKey: .privilege)
         try encoderContainer.encode(cloudID, forKey: .cloudID)
    }
}
///  RDS实例账号
public class RdsAccountInfo:NSObject,Codable{
    /// 账号名
    var name:String?
    /// 账号状态
    var status:String?
    /// AccountPrivileges
    var accountPrivileges:[RdsAccountPrivilege?]?
    /// 所属云提供商ID
    var cloudID:String?



    public override init(){
            super.init()
    }

    enum RdsAccountInfoCodingKeys: String, CodingKey {
        case name
        case status
        case accountPrivileges
        case cloudID
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: RdsAccountInfoCodingKeys.self)
        if decoderContainer.contains(.name)
        {
            self.name = try decoderContainer.decode(String?.self, forKey: .name)
        }
        if decoderContainer.contains(.status)
        {
            self.status = try decoderContainer.decode(String?.self, forKey: .status)
        }
        if decoderContainer.contains(.accountPrivileges)
        {
            self.accountPrivileges = try decoderContainer.decode([RdsAccountPrivilege?]?.self, forKey: .accountPrivileges)
        }
        if decoderContainer.contains(.cloudID)
        {
            self.cloudID = try decoderContainer.decode(String?.self, forKey: .cloudID)
        }
    }
}
public extension RdsAccountInfo{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: RdsAccountInfoCodingKeys.self)
         try encoderContainer.encode(name, forKey: .name)
         try encoderContainer.encode(status, forKey: .status)
         try encoderContainer.encode(accountPrivileges, forKey: .accountPrivileges)
         try encoderContainer.encode(cloudID, forKey: .cloudID)
    }
}
///  虚机规格
public class InstanceTypeInfo:NSObject,Codable{
    /// 类型
    var instanceType:String?
    /// 处理器核数，单位为C
    var cpu:Int32?
    /// 内存大小，单位为M
    var memory:Int32?
    /// GPU 数量
    var gpuAmount:Int32?
    /// GPU 类型
    var gpuSpec:String?
    /// 本地存储的单盘容量
    var localStorageSize:Int32?
    /// 本地存储的类型
    var localStorageType:String?
    /// 本地存储的数量
    var localStorageAmount:Int32?
    /// 支持弹性网卡的数量
    var nicLimit:Int32?



    public override init(){
            super.init()
    }

    enum InstanceTypeInfoCodingKeys: String, CodingKey {
        case instanceType
        case cpu
        case memory
        case gpuAmount
        case gpuSpec
        case localStorageSize
        case localStorageType
        case localStorageAmount
        case nicLimit
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: InstanceTypeInfoCodingKeys.self)
        if decoderContainer.contains(.instanceType)
        {
            self.instanceType = try decoderContainer.decode(String?.self, forKey: .instanceType)
        }
        if decoderContainer.contains(.cpu)
        {
            self.cpu = try decoderContainer.decode(Int32?.self, forKey: .cpu)
        }
        if decoderContainer.contains(.memory)
        {
            self.memory = try decoderContainer.decode(Int32?.self, forKey: .memory)
        }
        if decoderContainer.contains(.gpuAmount)
        {
            self.gpuAmount = try decoderContainer.decode(Int32?.self, forKey: .gpuAmount)
        }
        if decoderContainer.contains(.gpuSpec)
        {
            self.gpuSpec = try decoderContainer.decode(String?.self, forKey: .gpuSpec)
        }
        if decoderContainer.contains(.localStorageSize)
        {
            self.localStorageSize = try decoderContainer.decode(Int32?.self, forKey: .localStorageSize)
        }
        if decoderContainer.contains(.localStorageType)
        {
            self.localStorageType = try decoderContainer.decode(String?.self, forKey: .localStorageType)
        }
        if decoderContainer.contains(.localStorageAmount)
        {
            self.localStorageAmount = try decoderContainer.decode(Int32?.self, forKey: .localStorageAmount)
        }
        if decoderContainer.contains(.nicLimit)
        {
            self.nicLimit = try decoderContainer.decode(Int32?.self, forKey: .nicLimit)
        }
    }
}
public extension InstanceTypeInfo{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: InstanceTypeInfoCodingKeys.self)
         try encoderContainer.encode(instanceType, forKey: .instanceType)
         try encoderContainer.encode(cpu, forKey: .cpu)
         try encoderContainer.encode(memory, forKey: .memory)
         try encoderContainer.encode(gpuAmount, forKey: .gpuAmount)
         try encoderContainer.encode(gpuSpec, forKey: .gpuSpec)
         try encoderContainer.encode(localStorageSize, forKey: .localStorageSize)
         try encoderContainer.encode(localStorageType, forKey: .localStorageType)
         try encoderContainer.encode(localStorageAmount, forKey: .localStorageAmount)
         try encoderContainer.encode(nicLimit, forKey: .nicLimit)
    }
}
///  负载均衡监听器
public class LbHttpListener:NSObject,Codable{
    /// 负载均衡实例前端使用的端口。
    var listenerPort:Int32?
    /// 负载均衡实例后端使用的端口。
    var backendServerPort:Int32?
    /// 当前监听的状态。
    var status:String?
    /// 调度算法。
    var scheduler:String?
    /// 绑定的服务器组ID。
    var vServerGroupId:String?
    /// 是否开启健康检查。
    var healthCheck:String?
    /// 否  健康检查使用的端口
    var healthCheckConnectPort:Int32?
    /// 否  健康检查连续成功多少次后，将后端服务器的健康检查状态由fail判定为success。取值：2-10
    var healthyThreshold:Int32?
    /// 否  健康检查连续失败多少次后，将后端服务器的健康检查状态由success判定为fail。取值：2-10
    var unhealthyThreshold:Int32?
    /// 否  接收来自运行状况检查的响应需要等待的时间。如果后端ECS在指定的时间内没有正确响应，则判定为健康检查失败。取值：1-300（秒）
    var healthCheckTimeout:Int32?
    /// 否  健康检查的时间间隔。取值：1-50（秒）
    var healthCheckInterval:Int32?
    /// 否  健康检查正常的HTTP状态码，多个状态码用逗号分隔。取值：http_2xx（默认值） | http_3xx | http_4xx | http_5xx
    var healthCheckHttpCode:String?



    public override init(){
            super.init()
    }

    enum LbHttpListenerCodingKeys: String, CodingKey {
        case listenerPort
        case backendServerPort
        case status
        case scheduler
        case vServerGroupId
        case healthCheck
        case healthCheckConnectPort
        case healthyThreshold
        case unhealthyThreshold
        case healthCheckTimeout
        case healthCheckInterval
        case healthCheckHttpCode
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: LbHttpListenerCodingKeys.self)
        if decoderContainer.contains(.listenerPort)
        {
            self.listenerPort = try decoderContainer.decode(Int32?.self, forKey: .listenerPort)
        }
        if decoderContainer.contains(.backendServerPort)
        {
            self.backendServerPort = try decoderContainer.decode(Int32?.self, forKey: .backendServerPort)
        }
        if decoderContainer.contains(.status)
        {
            self.status = try decoderContainer.decode(String?.self, forKey: .status)
        }
        if decoderContainer.contains(.scheduler)
        {
            self.scheduler = try decoderContainer.decode(String?.self, forKey: .scheduler)
        }
        if decoderContainer.contains(.vServerGroupId)
        {
            self.vServerGroupId = try decoderContainer.decode(String?.self, forKey: .vServerGroupId)
        }
        if decoderContainer.contains(.healthCheck)
        {
            self.healthCheck = try decoderContainer.decode(String?.self, forKey: .healthCheck)
        }
        if decoderContainer.contains(.healthCheckConnectPort)
        {
            self.healthCheckConnectPort = try decoderContainer.decode(Int32?.self, forKey: .healthCheckConnectPort)
        }
        if decoderContainer.contains(.healthyThreshold)
        {
            self.healthyThreshold = try decoderContainer.decode(Int32?.self, forKey: .healthyThreshold)
        }
        if decoderContainer.contains(.unhealthyThreshold)
        {
            self.unhealthyThreshold = try decoderContainer.decode(Int32?.self, forKey: .unhealthyThreshold)
        }
        if decoderContainer.contains(.healthCheckTimeout)
        {
            self.healthCheckTimeout = try decoderContainer.decode(Int32?.self, forKey: .healthCheckTimeout)
        }
        if decoderContainer.contains(.healthCheckInterval)
        {
            self.healthCheckInterval = try decoderContainer.decode(Int32?.self, forKey: .healthCheckInterval)
        }
        if decoderContainer.contains(.healthCheckHttpCode)
        {
            self.healthCheckHttpCode = try decoderContainer.decode(String?.self, forKey: .healthCheckHttpCode)
        }
    }
}
public extension LbHttpListener{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: LbHttpListenerCodingKeys.self)
         try encoderContainer.encode(listenerPort, forKey: .listenerPort)
         try encoderContainer.encode(backendServerPort, forKey: .backendServerPort)
         try encoderContainer.encode(status, forKey: .status)
         try encoderContainer.encode(scheduler, forKey: .scheduler)
         try encoderContainer.encode(vServerGroupId, forKey: .vServerGroupId)
         try encoderContainer.encode(healthCheck, forKey: .healthCheck)
         try encoderContainer.encode(healthCheckConnectPort, forKey: .healthCheckConnectPort)
         try encoderContainer.encode(healthyThreshold, forKey: .healthyThreshold)
         try encoderContainer.encode(unhealthyThreshold, forKey: .unhealthyThreshold)
         try encoderContainer.encode(healthCheckTimeout, forKey: .healthCheckTimeout)
         try encoderContainer.encode(healthCheckInterval, forKey: .healthCheckInterval)
         try encoderContainer.encode(healthCheckHttpCode, forKey: .healthCheckHttpCode)
    }
}
///  解绑公网IP
public class UnassociateEipAddress:NSObject,Codable{
    /// 云产品的实例ID
    var instanceId:String?
    /// 要解绑的资源类型
    var instanceType:String?



    public override init(){
            super.init()
    }

    enum UnassociateEipAddressCodingKeys: String, CodingKey {
        case instanceId
        case instanceType
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: UnassociateEipAddressCodingKeys.self)
        if decoderContainer.contains(.instanceId)
        {
            self.instanceId = try decoderContainer.decode(String?.self, forKey: .instanceId)
        }
        if decoderContainer.contains(.instanceType)
        {
            self.instanceType = try decoderContainer.decode(String?.self, forKey: .instanceType)
        }
    }
}
public extension UnassociateEipAddress{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: UnassociateEipAddressCodingKeys.self)
         try encoderContainer.encode(instanceId, forKey: .instanceId)
         try encoderContainer.encode(instanceType, forKey: .instanceType)
    }
}
///  绑定公网IP
public class AssociateEipAddress:NSObject,Codable{
    /// 云产品的实例ID
    var instanceId:String?
    /// 要绑定的云产品实例的类型
    var instanceType:String?



    public override init(){
            super.init()
    }

    enum AssociateEipAddressCodingKeys: String, CodingKey {
        case instanceId
        case instanceType
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: AssociateEipAddressCodingKeys.self)
        if decoderContainer.contains(.instanceId)
        {
            self.instanceId = try decoderContainer.decode(String?.self, forKey: .instanceId)
        }
        if decoderContainer.contains(.instanceType)
        {
            self.instanceType = try decoderContainer.decode(String?.self, forKey: .instanceType)
        }
    }
}
public extension AssociateEipAddress{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: AssociateEipAddressCodingKeys.self)
         try encoderContainer.encode(instanceId, forKey: .instanceId)
         try encoderContainer.encode(instanceType, forKey: .instanceType)
    }
}
///  公网IP信息
public class EipAddress:NSObject,Codable{
    /// 云注册信息ID
    var cloudID:String?
    /// 公网IP地址
    var ipAddress:String?
    /// 公网IP ID
    var id:String?
    /// 状态
    var status:String?
    /// 当前绑定的实例类型
    var instanceType:String?
    /// 当前绑定的实例ID
    var instanceId:String?
    /// EIP的带宽峰值，单位为Mbps
    var bandwidth:String?
    /// EIP的创建时间
    var allocationTime:String?



    public override init(){
            super.init()
    }

    enum EipAddressCodingKeys: String, CodingKey {
        case cloudID
        case ipAddress
        case id
        case status
        case instanceType
        case instanceId
        case bandwidth
        case allocationTime
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: EipAddressCodingKeys.self)
        if decoderContainer.contains(.cloudID)
        {
            self.cloudID = try decoderContainer.decode(String?.self, forKey: .cloudID)
        }
        if decoderContainer.contains(.ipAddress)
        {
            self.ipAddress = try decoderContainer.decode(String?.self, forKey: .ipAddress)
        }
        if decoderContainer.contains(.id)
        {
            self.id = try decoderContainer.decode(String?.self, forKey: .id)
        }
        if decoderContainer.contains(.status)
        {
            self.status = try decoderContainer.decode(String?.self, forKey: .status)
        }
        if decoderContainer.contains(.instanceType)
        {
            self.instanceType = try decoderContainer.decode(String?.self, forKey: .instanceType)
        }
        if decoderContainer.contains(.instanceId)
        {
            self.instanceId = try decoderContainer.decode(String?.self, forKey: .instanceId)
        }
        if decoderContainer.contains(.bandwidth)
        {
            self.bandwidth = try decoderContainer.decode(String?.self, forKey: .bandwidth)
        }
        if decoderContainer.contains(.allocationTime)
        {
            self.allocationTime = try decoderContainer.decode(String?.self, forKey: .allocationTime)
        }
    }
}
public extension EipAddress{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: EipAddressCodingKeys.self)
         try encoderContainer.encode(cloudID, forKey: .cloudID)
         try encoderContainer.encode(ipAddress, forKey: .ipAddress)
         try encoderContainer.encode(id, forKey: .id)
         try encoderContainer.encode(status, forKey: .status)
         try encoderContainer.encode(instanceType, forKey: .instanceType)
         try encoderContainer.encode(instanceId, forKey: .instanceId)
         try encoderContainer.encode(bandwidth, forKey: .bandwidth)
         try encoderContainer.encode(allocationTime, forKey: .allocationTime)
    }
}
///  云硬盘信息
public class CloudDataDisk:NSObject,Codable{
    /// 云注册信息ID
    var cloudID:String?
    /// 云硬盘ID
    var id:String?
    /// 云硬盘名称
    var name:String?
    /// 云硬盘描述
    var descriptionValue:String?
    /// 磁盘大小,单位为 GiB
    var diskSizeGB:Int32?
    /// 挂载信息
    var attachments:[ArrayDiskAttachment?]?
    /// 云硬盘所属AZ
    var az:String?
    /// 磁盘类型,取值为 ssd 或 premium-hdd
    var diskType:String?
    /// 创建该云硬盘的快照ID
    var snapshotId:String?
    /// 云硬盘状态
    var status:String?
    /// Tags
    var tags:[Tag?]?
    /// 创建时间
    var createdTime:String?



    public override init(){
            super.init()
    }

    enum CloudDataDiskCodingKeys: String, CodingKey {
        case cloudID
        case id
        case name
        case descriptionValue = "description"
        case diskSizeGB
        case attachments
        case az
        case diskType
        case snapshotId
        case status
        case tags
        case createdTime
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: CloudDataDiskCodingKeys.self)
        if decoderContainer.contains(.cloudID)
        {
            self.cloudID = try decoderContainer.decode(String?.self, forKey: .cloudID)
        }
        if decoderContainer.contains(.id)
        {
            self.id = try decoderContainer.decode(String?.self, forKey: .id)
        }
        if decoderContainer.contains(.name)
        {
            self.name = try decoderContainer.decode(String?.self, forKey: .name)
        }
        if decoderContainer.contains(.descriptionValue)
        {
            self.descriptionValue = try decoderContainer.decode(String?.self, forKey: .descriptionValue)
        }
        if decoderContainer.contains(.diskSizeGB)
        {
            self.diskSizeGB = try decoderContainer.decode(Int32?.self, forKey: .diskSizeGB)
        }
        if decoderContainer.contains(.attachments)
        {
            self.attachments = try decoderContainer.decode([ArrayDiskAttachment?]?.self, forKey: .attachments)
        }
        if decoderContainer.contains(.az)
        {
            self.az = try decoderContainer.decode(String?.self, forKey: .az)
        }
        if decoderContainer.contains(.diskType)
        {
            self.diskType = try decoderContainer.decode(String?.self, forKey: .diskType)
        }
        if decoderContainer.contains(.snapshotId)
        {
            self.snapshotId = try decoderContainer.decode(String?.self, forKey: .snapshotId)
        }
        if decoderContainer.contains(.status)
        {
            self.status = try decoderContainer.decode(String?.self, forKey: .status)
        }
        if decoderContainer.contains(.tags)
        {
            self.tags = try decoderContainer.decode([Tag?]?.self, forKey: .tags)
        }
        if decoderContainer.contains(.createdTime)
        {
            self.createdTime = try decoderContainer.decode(String?.self, forKey: .createdTime)
        }
    }
}
public extension CloudDataDisk{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: CloudDataDiskCodingKeys.self)
         try encoderContainer.encode(cloudID, forKey: .cloudID)
         try encoderContainer.encode(id, forKey: .id)
         try encoderContainer.encode(name, forKey: .name)
         try encoderContainer.encode(descriptionValue, forKey: .descriptionValue)
         try encoderContainer.encode(diskSizeGB, forKey: .diskSizeGB)
         try encoderContainer.encode(attachments, forKey: .attachments)
         try encoderContainer.encode(az, forKey: .az)
         try encoderContainer.encode(diskType, forKey: .diskType)
         try encoderContainer.encode(snapshotId, forKey: .snapshotId)
         try encoderContainer.encode(status, forKey: .status)
         try encoderContainer.encode(tags, forKey: .tags)
         try encoderContainer.encode(createdTime, forKey: .createdTime)
    }
}
///  挂载云硬盘
public class AttachDataDisk:NSObject,Codable{
    /// 虚拟机 id
    /// Required:true
    var instanceId:String
    /// 释放实例时，该云盘是否随实例一起释放。默认值：False
    var deleteWithInstance:Bool?



    public  init(instanceId:String){
             self.instanceId = instanceId
    }

    enum AttachDataDiskCodingKeys: String, CodingKey {
        case instanceId
        case deleteWithInstance
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: AttachDataDiskCodingKeys.self)
        self.instanceId = try decoderContainer.decode(String.self, forKey: .instanceId)
        if decoderContainer.contains(.deleteWithInstance)
        {
            self.deleteWithInstance = try decoderContainer.decode(Bool?.self, forKey: .deleteWithInstance)
        }
    }
}
public extension AttachDataDisk{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: AttachDataDiskCodingKeys.self)
         try encoderContainer.encode(instanceId, forKey: .instanceId)
         try encoderContainer.encode(deleteWithInstance, forKey: .deleteWithInstance)
    }
}
///  挂载云硬盘
public class DetachDataDisk:NSObject,Codable{
    /// 虚拟机 id
    /// Required:true
    var instanceId:String



    public  init(instanceId:String){
             self.instanceId = instanceId
    }

    enum DetachDataDiskCodingKeys: String, CodingKey {
        case instanceId
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: DetachDataDiskCodingKeys.self)
        self.instanceId = try decoderContainer.decode(String.self, forKey: .instanceId)
    }
}
public extension DetachDataDisk{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: DetachDataDiskCodingKeys.self)
         try encoderContainer.encode(instanceId, forKey: .instanceId)
    }
}
///  privateIp
public class PrivateIp:NSObject,Codable{
    /// 内网IP的地址。
    var ipAddress:String?
    /// 是否为主IP
    var primary:Bool?
    /// 弹性IP实例ID。
    var eipId:String?
    /// 弹性IP实例地址。
    var eipAddress:String?



    public override init(){
            super.init()
    }

    enum PrivateIpCodingKeys: String, CodingKey {
        case ipAddress
        case primary
        case eipId
        case eipAddress
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: PrivateIpCodingKeys.self)
        if decoderContainer.contains(.ipAddress)
        {
            self.ipAddress = try decoderContainer.decode(String?.self, forKey: .ipAddress)
        }
        if decoderContainer.contains(.primary)
        {
            self.primary = try decoderContainer.decode(Bool?.self, forKey: .primary)
        }
        if decoderContainer.contains(.eipId)
        {
            self.eipId = try decoderContainer.decode(String?.self, forKey: .eipId)
        }
        if decoderContainer.contains(.eipAddress)
        {
            self.eipAddress = try decoderContainer.decode(String?.self, forKey: .eipAddress)
        }
    }
}
public extension PrivateIp{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: PrivateIpCodingKeys.self)
         try encoderContainer.encode(ipAddress, forKey: .ipAddress)
         try encoderContainer.encode(primary, forKey: .primary)
         try encoderContainer.encode(eipId, forKey: .eipId)
         try encoderContainer.encode(eipAddress, forKey: .eipAddress)
    }
}
///  卸载网卡
public class DetachNetInterface:NSObject,Codable{
    /// 虚拟机 id
    /// Required:true
    var instanceId:String



    public  init(instanceId:String){
             self.instanceId = instanceId
    }

    enum DetachNetInterfaceCodingKeys: String, CodingKey {
        case instanceId
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: DetachNetInterfaceCodingKeys.self)
        self.instanceId = try decoderContainer.decode(String.self, forKey: .instanceId)
    }
}
public extension DetachNetInterface{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: DetachNetInterfaceCodingKeys.self)
         try encoderContainer.encode(instanceId, forKey: .instanceId)
    }
}
///  子网属性信息
public class NetInterfaceInfo:NSObject,Codable{
    /// 网卡的Id
    var id:String?
    /// 网卡名称
    var name:String?
    /// 网卡描述信息
    var descriptionValue:String?
    /// VPC的Id
    var vpcId:String?
    /// 网卡类型
    var type:String?
    /// 子网id
    var subnetId:String?
    /// 可用区的 ID
    var az:String?
    /// 弹性网卡关联的公网 IP
    var associatedPublicIp:String?
    /// 弹性网卡主私有 IP 地址
    var privateIpAddress:String?
    /// 弹性网卡的 MAC 地址
    var macAddress:String?
    /// 弹性网卡附加的实例 ID
    var instanceId:String?
    /// 创建时间
    var createdTime:String?
    /// 所属云提供商ID
    var cloudID:String?
    /// 安全组id列表
    var securityGroupIds:[String?]?
    /// 内网ip详情列表。
    var privateIps:[PrivateIp?]?



    public override init(){
            super.init()
    }

    enum NetInterfaceInfoCodingKeys: String, CodingKey {
        case id
        case name
        case descriptionValue = "description"
        case vpcId
        case type
        case subnetId
        case az
        case associatedPublicIp
        case privateIpAddress
        case macAddress
        case instanceId
        case createdTime
        case cloudID
        case securityGroupIds
        case privateIps
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: NetInterfaceInfoCodingKeys.self)
        if decoderContainer.contains(.id)
        {
            self.id = try decoderContainer.decode(String?.self, forKey: .id)
        }
        if decoderContainer.contains(.name)
        {
            self.name = try decoderContainer.decode(String?.self, forKey: .name)
        }
        if decoderContainer.contains(.descriptionValue)
        {
            self.descriptionValue = try decoderContainer.decode(String?.self, forKey: .descriptionValue)
        }
        if decoderContainer.contains(.vpcId)
        {
            self.vpcId = try decoderContainer.decode(String?.self, forKey: .vpcId)
        }
        if decoderContainer.contains(.type)
        {
            self.type = try decoderContainer.decode(String?.self, forKey: .type)
        }
        if decoderContainer.contains(.subnetId)
        {
            self.subnetId = try decoderContainer.decode(String?.self, forKey: .subnetId)
        }
        if decoderContainer.contains(.az)
        {
            self.az = try decoderContainer.decode(String?.self, forKey: .az)
        }
        if decoderContainer.contains(.associatedPublicIp)
        {
            self.associatedPublicIp = try decoderContainer.decode(String?.self, forKey: .associatedPublicIp)
        }
        if decoderContainer.contains(.privateIpAddress)
        {
            self.privateIpAddress = try decoderContainer.decode(String?.self, forKey: .privateIpAddress)
        }
        if decoderContainer.contains(.macAddress)
        {
            self.macAddress = try decoderContainer.decode(String?.self, forKey: .macAddress)
        }
        if decoderContainer.contains(.instanceId)
        {
            self.instanceId = try decoderContainer.decode(String?.self, forKey: .instanceId)
        }
        if decoderContainer.contains(.createdTime)
        {
            self.createdTime = try decoderContainer.decode(String?.self, forKey: .createdTime)
        }
        if decoderContainer.contains(.cloudID)
        {
            self.cloudID = try decoderContainer.decode(String?.self, forKey: .cloudID)
        }
        if decoderContainer.contains(.securityGroupIds)
        {
            self.securityGroupIds = try decoderContainer.decode([String?]?.self, forKey: .securityGroupIds)
        }
        if decoderContainer.contains(.privateIps)
        {
            self.privateIps = try decoderContainer.decode([PrivateIp?]?.self, forKey: .privateIps)
        }
    }
}
public extension NetInterfaceInfo{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: NetInterfaceInfoCodingKeys.self)
         try encoderContainer.encode(id, forKey: .id)
         try encoderContainer.encode(name, forKey: .name)
         try encoderContainer.encode(descriptionValue, forKey: .descriptionValue)
         try encoderContainer.encode(vpcId, forKey: .vpcId)
         try encoderContainer.encode(type, forKey: .type)
         try encoderContainer.encode(subnetId, forKey: .subnetId)
         try encoderContainer.encode(az, forKey: .az)
         try encoderContainer.encode(associatedPublicIp, forKey: .associatedPublicIp)
         try encoderContainer.encode(privateIpAddress, forKey: .privateIpAddress)
         try encoderContainer.encode(macAddress, forKey: .macAddress)
         try encoderContainer.encode(instanceId, forKey: .instanceId)
         try encoderContainer.encode(createdTime, forKey: .createdTime)
         try encoderContainer.encode(cloudID, forKey: .cloudID)
         try encoderContainer.encode(securityGroupIds, forKey: .securityGroupIds)
         try encoderContainer.encode(privateIps, forKey: .privateIps)
    }
}
///  挂载网卡
public class AttachNetInterface:NSObject,Codable{
    /// 虚拟机 id
    /// Required:true
    var instanceId:String



    public  init(instanceId:String){
             self.instanceId = instanceId
    }

    enum AttachNetInterfaceCodingKeys: String, CodingKey {
        case instanceId
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: AttachNetInterfaceCodingKeys.self)
        self.instanceId = try decoderContainer.decode(String.self, forKey: .instanceId)
    }
}
public extension AttachNetInterface{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: AttachNetInterfaceCodingKeys.self)
         try encoderContainer.encode(instanceId, forKey: .instanceId)
    }
}
///  listenerPortsAndProtocol
public class ListenerPortsAndProtocol:NSObject,Codable{
    /// 负载均衡实例前端使用的端口。
    var listenerPort:Int32?
    /// 负载均衡实例前端使用的协议。
    var listenerProtocol:String?
    /// 是否启用监听转发。
    var listenerForward:String?
    /// 转发到的目的监听端口，必须是已经存在的HTTPS监听端口。
    var forwardPort:Int32?



    public override init(){
            super.init()
    }

    enum ListenerPortsAndProtocolCodingKeys: String, CodingKey {
        case listenerPort
        case listenerProtocol
        case listenerForward
        case forwardPort
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: ListenerPortsAndProtocolCodingKeys.self)
        if decoderContainer.contains(.listenerPort)
        {
            self.listenerPort = try decoderContainer.decode(Int32?.self, forKey: .listenerPort)
        }
        if decoderContainer.contains(.listenerProtocol)
        {
            self.listenerProtocol = try decoderContainer.decode(String?.self, forKey: .listenerProtocol)
        }
        if decoderContainer.contains(.listenerForward)
        {
            self.listenerForward = try decoderContainer.decode(String?.self, forKey: .listenerForward)
        }
        if decoderContainer.contains(.forwardPort)
        {
            self.forwardPort = try decoderContainer.decode(Int32?.self, forKey: .forwardPort)
        }
    }
}
public extension ListenerPortsAndProtocol{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: ListenerPortsAndProtocolCodingKeys.self)
         try encoderContainer.encode(listenerPort, forKey: .listenerPort)
         try encoderContainer.encode(listenerProtocol, forKey: .listenerProtocol)
         try encoderContainer.encode(listenerForward, forKey: .listenerForward)
         try encoderContainer.encode(forwardPort, forKey: .forwardPort)
    }
}
///  slbInfoDetail
public class SlbInfoDetail:NSObject,Codable{
    /// 所属云ID
    var cloudID:String?
    /// 负载均衡实例ID。
    var id:String?
    /// 负载均衡实例的名称。
    var name:String?
    /// 负载均衡实例状态
    var status:String?
    /// 负载均衡实例的服务地址。
    var ipAddress:String?
    /// 负载均衡实例的网络类型。
    var addressType:String?
    /// 私网负载均衡实例的交换机ID。
    var subnetId:String?
    /// 私网负载均衡实例的专有网络ID。
    var vpc:String?
    /// 私网负载均衡实例的网络类型
    var networkType:String?
    /// 实例的主可用区ID。
    var masterAz:String?
    /// 实例的备可用区ID。
    var slaveAz:String?
    /// 创建时间
    var createdTime:String?
    /// 负载均衡实例前端使用的端口和协议列表。
    var listenerPortsAndProtocol:[ListenerPortsAndProtocol?]?
    /// 负载均衡实例的后端服务器列表。
    var backendServers:[BackendServer2?]?
    /// 负载均衡实例的的性能规格。取值：slb.s1.small、slb.s2.small、slb.s2.medium、slb.s3.small、slb.s3.medium、slb.s3.large
    var loadBalancerSpec:String?



    public override init(){
            super.init()
    }

    enum SlbInfoDetailCodingKeys: String, CodingKey {
        case cloudID
        case id
        case name
        case status
        case ipAddress
        case addressType
        case subnetId
        case vpc
        case networkType
        case masterAz
        case slaveAz
        case createdTime
        case listenerPortsAndProtocol
        case backendServers
        case loadBalancerSpec
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: SlbInfoDetailCodingKeys.self)
        if decoderContainer.contains(.cloudID)
        {
            self.cloudID = try decoderContainer.decode(String?.self, forKey: .cloudID)
        }
        if decoderContainer.contains(.id)
        {
            self.id = try decoderContainer.decode(String?.self, forKey: .id)
        }
        if decoderContainer.contains(.name)
        {
            self.name = try decoderContainer.decode(String?.self, forKey: .name)
        }
        if decoderContainer.contains(.status)
        {
            self.status = try decoderContainer.decode(String?.self, forKey: .status)
        }
        if decoderContainer.contains(.ipAddress)
        {
            self.ipAddress = try decoderContainer.decode(String?.self, forKey: .ipAddress)
        }
        if decoderContainer.contains(.addressType)
        {
            self.addressType = try decoderContainer.decode(String?.self, forKey: .addressType)
        }
        if decoderContainer.contains(.subnetId)
        {
            self.subnetId = try decoderContainer.decode(String?.self, forKey: .subnetId)
        }
        if decoderContainer.contains(.vpc)
        {
            self.vpc = try decoderContainer.decode(String?.self, forKey: .vpc)
        }
        if decoderContainer.contains(.networkType)
        {
            self.networkType = try decoderContainer.decode(String?.self, forKey: .networkType)
        }
        if decoderContainer.contains(.masterAz)
        {
            self.masterAz = try decoderContainer.decode(String?.self, forKey: .masterAz)
        }
        if decoderContainer.contains(.slaveAz)
        {
            self.slaveAz = try decoderContainer.decode(String?.self, forKey: .slaveAz)
        }
        if decoderContainer.contains(.createdTime)
        {
            self.createdTime = try decoderContainer.decode(String?.self, forKey: .createdTime)
        }
        if decoderContainer.contains(.listenerPortsAndProtocol)
        {
            self.listenerPortsAndProtocol = try decoderContainer.decode([ListenerPortsAndProtocol?]?.self, forKey: .listenerPortsAndProtocol)
        }
        if decoderContainer.contains(.backendServers)
        {
            self.backendServers = try decoderContainer.decode([BackendServer2?]?.self, forKey: .backendServers)
        }
        if decoderContainer.contains(.loadBalancerSpec)
        {
            self.loadBalancerSpec = try decoderContainer.decode(String?.self, forKey: .loadBalancerSpec)
        }
    }
}
public extension SlbInfoDetail{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: SlbInfoDetailCodingKeys.self)
         try encoderContainer.encode(cloudID, forKey: .cloudID)
         try encoderContainer.encode(id, forKey: .id)
         try encoderContainer.encode(name, forKey: .name)
         try encoderContainer.encode(status, forKey: .status)
         try encoderContainer.encode(ipAddress, forKey: .ipAddress)
         try encoderContainer.encode(addressType, forKey: .addressType)
         try encoderContainer.encode(subnetId, forKey: .subnetId)
         try encoderContainer.encode(vpc, forKey: .vpc)
         try encoderContainer.encode(networkType, forKey: .networkType)
         try encoderContainer.encode(masterAz, forKey: .masterAz)
         try encoderContainer.encode(slaveAz, forKey: .slaveAz)
         try encoderContainer.encode(createdTime, forKey: .createdTime)
         try encoderContainer.encode(listenerPortsAndProtocol, forKey: .listenerPortsAndProtocol)
         try encoderContainer.encode(backendServers, forKey: .backendServers)
         try encoderContainer.encode(loadBalancerSpec, forKey: .loadBalancerSpec)
    }
}
///  backendServer2
public class BackendServer2:NSObject,Codable{
    /// 后端服务器名（ECS实例）ID。
    var serverId:String?
    /// 后端服务器的权重。
    var weight:Int32?
    /// 后端服务器类型。
    var type:String?



    public override init(){
            super.init()
    }

    enum BackendServer2CodingKeys: String, CodingKey {
        case serverId
        case weight
        case type
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: BackendServer2CodingKeys.self)
        if decoderContainer.contains(.serverId)
        {
            self.serverId = try decoderContainer.decode(String?.self, forKey: .serverId)
        }
        if decoderContainer.contains(.weight)
        {
            self.weight = try decoderContainer.decode(Int32?.self, forKey: .weight)
        }
        if decoderContainer.contains(.type)
        {
            self.type = try decoderContainer.decode(String?.self, forKey: .type)
        }
    }
}
public extension BackendServer2{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: BackendServer2CodingKeys.self)
         try encoderContainer.encode(serverId, forKey: .serverId)
         try encoderContainer.encode(weight, forKey: .weight)
         try encoderContainer.encode(type, forKey: .type)
    }
}
///  负载均衡后端服务
public class VserverGroupInfo:NSObject,Codable{
    /// 所属云ID
    var cloudID:String?
    /// 服务器组ID
    var vserverGroupId:String?
    /// 服务器组名称
    var vserverGroupName:String?



    public override init(){
            super.init()
    }

    enum VserverGroupInfoCodingKeys: String, CodingKey {
        case cloudID
        case vserverGroupId
        case vserverGroupName
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: VserverGroupInfoCodingKeys.self)
        if decoderContainer.contains(.cloudID)
        {
            self.cloudID = try decoderContainer.decode(String?.self, forKey: .cloudID)
        }
        if decoderContainer.contains(.vserverGroupId)
        {
            self.vserverGroupId = try decoderContainer.decode(String?.self, forKey: .vserverGroupId)
        }
        if decoderContainer.contains(.vserverGroupName)
        {
            self.vserverGroupName = try decoderContainer.decode(String?.self, forKey: .vserverGroupName)
        }
    }
}
public extension VserverGroupInfo{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: VserverGroupInfoCodingKeys.self)
         try encoderContainer.encode(cloudID, forKey: .cloudID)
         try encoderContainer.encode(vserverGroupId, forKey: .vserverGroupId)
         try encoderContainer.encode(vserverGroupName, forKey: .vserverGroupName)
    }
}
///  负载均衡后端服务
public class VserverGroupBackendServer:NSObject,Codable{
    /// 负载均衡实例ID。
    var serverId:String?
    /// 后端服务器端口。
    var port:Int32?
    /// 后端服务器的权重。
    var weight:Int32?



    public override init(){
            super.init()
    }

    enum VserverGroupBackendServerCodingKeys: String, CodingKey {
        case serverId
        case port
        case weight
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: VserverGroupBackendServerCodingKeys.self)
        if decoderContainer.contains(.serverId)
        {
            self.serverId = try decoderContainer.decode(String?.self, forKey: .serverId)
        }
        if decoderContainer.contains(.port)
        {
            self.port = try decoderContainer.decode(Int32?.self, forKey: .port)
        }
        if decoderContainer.contains(.weight)
        {
            self.weight = try decoderContainer.decode(Int32?.self, forKey: .weight)
        }
    }
}
public extension VserverGroupBackendServer{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: VserverGroupBackendServerCodingKeys.self)
         try encoderContainer.encode(serverId, forKey: .serverId)
         try encoderContainer.encode(port, forKey: .port)
         try encoderContainer.encode(weight, forKey: .weight)
    }
}
///  vserverGroupDetail
public class VserverGroupDetail:NSObject,Codable{
    /// 所属云ID
    var cloudID:String?
    /// 服务器组ID
    var vserverGroupId:String?
    /// 服务器组名称
    var vserverGroupName:String?
    /// BackendServers
    var backendServers:[VserverGroupBackendServer?]?



    public override init(){
            super.init()
    }

    enum VserverGroupDetailCodingKeys: String, CodingKey {
        case cloudID
        case vserverGroupId
        case vserverGroupName
        case backendServers
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: VserverGroupDetailCodingKeys.self)
        if decoderContainer.contains(.cloudID)
        {
            self.cloudID = try decoderContainer.decode(String?.self, forKey: .cloudID)
        }
        if decoderContainer.contains(.vserverGroupId)
        {
            self.vserverGroupId = try decoderContainer.decode(String?.self, forKey: .vserverGroupId)
        }
        if decoderContainer.contains(.vserverGroupName)
        {
            self.vserverGroupName = try decoderContainer.decode(String?.self, forKey: .vserverGroupName)
        }
        if decoderContainer.contains(.backendServers)
        {
            self.backendServers = try decoderContainer.decode([VserverGroupBackendServer?]?.self, forKey: .backendServers)
        }
    }
}
public extension VserverGroupDetail{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: VserverGroupDetailCodingKeys.self)
         try encoderContainer.encode(cloudID, forKey: .cloudID)
         try encoderContainer.encode(vserverGroupId, forKey: .vserverGroupId)
         try encoderContainer.encode(vserverGroupName, forKey: .vserverGroupName)
         try encoderContainer.encode(backendServers, forKey: .backendServers)
    }
}
///  镜像信息
public class ImageInfo:NSObject,Codable{
    /// 镜像ID
    var id:String?
    /// 镜像名称
    var name:String?
    /// 镜像描述
    var descriptionValue:String?
    /// 镜像架构
    var architecture:String?
    /// 创建时间
    var createdTime:String?
    /// 镜像来源
    var imageSource:String?
    /// 镜像操作系统类型
    var osType:String?
    /// 操作系统平台
    var platform:String?
    /// 镜像复制和转换时的进度，仅显示数值，单位为百分比
    var progress:String?
    /// 镜像大小 单位MB
    var size:Int32?
    /// 状态
    var status:String?
    /// 云注册信息ID
    var cloudID:String?



    public override init(){
            super.init()
    }

    enum ImageInfoCodingKeys: String, CodingKey {
        case id
        case name
        case descriptionValue = "description"
        case architecture
        case createdTime
        case imageSource
        case osType
        case platform
        case progress
        case size
        case status
        case cloudID
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: ImageInfoCodingKeys.self)
        if decoderContainer.contains(.id)
        {
            self.id = try decoderContainer.decode(String?.self, forKey: .id)
        }
        if decoderContainer.contains(.name)
        {
            self.name = try decoderContainer.decode(String?.self, forKey: .name)
        }
        if decoderContainer.contains(.descriptionValue)
        {
            self.descriptionValue = try decoderContainer.decode(String?.self, forKey: .descriptionValue)
        }
        if decoderContainer.contains(.architecture)
        {
            self.architecture = try decoderContainer.decode(String?.self, forKey: .architecture)
        }
        if decoderContainer.contains(.createdTime)
        {
            self.createdTime = try decoderContainer.decode(String?.self, forKey: .createdTime)
        }
        if decoderContainer.contains(.imageSource)
        {
            self.imageSource = try decoderContainer.decode(String?.self, forKey: .imageSource)
        }
        if decoderContainer.contains(.osType)
        {
            self.osType = try decoderContainer.decode(String?.self, forKey: .osType)
        }
        if decoderContainer.contains(.platform)
        {
            self.platform = try decoderContainer.decode(String?.self, forKey: .platform)
        }
        if decoderContainer.contains(.progress)
        {
            self.progress = try decoderContainer.decode(String?.self, forKey: .progress)
        }
        if decoderContainer.contains(.size)
        {
            self.size = try decoderContainer.decode(Int32?.self, forKey: .size)
        }
        if decoderContainer.contains(.status)
        {
            self.status = try decoderContainer.decode(String?.self, forKey: .status)
        }
        if decoderContainer.contains(.cloudID)
        {
            self.cloudID = try decoderContainer.decode(String?.self, forKey: .cloudID)
        }
    }
}
public extension ImageInfo{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: ImageInfoCodingKeys.self)
         try encoderContainer.encode(id, forKey: .id)
         try encoderContainer.encode(name, forKey: .name)
         try encoderContainer.encode(descriptionValue, forKey: .descriptionValue)
         try encoderContainer.encode(architecture, forKey: .architecture)
         try encoderContainer.encode(createdTime, forKey: .createdTime)
         try encoderContainer.encode(imageSource, forKey: .imageSource)
         try encoderContainer.encode(osType, forKey: .osType)
         try encoderContainer.encode(platform, forKey: .platform)
         try encoderContainer.encode(progress, forKey: .progress)
         try encoderContainer.encode(size, forKey: .size)
         try encoderContainer.encode(status, forKey: .status)
         try encoderContainer.encode(cloudID, forKey: .cloudID)
    }
}
///  rdsSpecificationDisk
public class RdsSpecificationDisk:NSObject,Codable{
    /// 硬盘大小列表
    var list:[Int32?]?
    /// 硬盘最小值
    var min:Int32?
    /// 硬盘最大值
    var max:Int32?



    public override init(){
            super.init()
    }

    enum RdsSpecificationDiskCodingKeys: String, CodingKey {
        case list
        case min
        case max
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: RdsSpecificationDiskCodingKeys.self)
        if decoderContainer.contains(.list)
        {
            self.list = try decoderContainer.decode([Int32?]?.self, forKey: .list)
        }
        if decoderContainer.contains(.min)
        {
            self.min = try decoderContainer.decode(Int32?.self, forKey: .min)
        }
        if decoderContainer.contains(.max)
        {
            self.max = try decoderContainer.decode(Int32?.self, forKey: .max)
        }
    }
}
public extension RdsSpecificationDisk{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: RdsSpecificationDiskCodingKeys.self)
         try encoderContainer.encode(list, forKey: .list)
         try encoderContainer.encode(min, forKey: .min)
         try encoderContainer.encode(max, forKey: .max)
    }
}
///  rdsSpecification
public class RdsSpecification:NSObject,Codable{
    /// 规格编号
    var instanceClass:String?
    /// CPU核数
    var cpu:Int32?
    /// 内存大小
    var memoryGB:Int32?
    /// Disk
    var disk:RdsSpecificationDisk?



    public override init(){
            super.init()
    }

    enum RdsSpecificationCodingKeys: String, CodingKey {
        case instanceClass
        case cpu
        case memoryGB
        case disk
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: RdsSpecificationCodingKeys.self)
        if decoderContainer.contains(.instanceClass)
        {
            self.instanceClass = try decoderContainer.decode(String?.self, forKey: .instanceClass)
        }
        if decoderContainer.contains(.cpu)
        {
            self.cpu = try decoderContainer.decode(Int32?.self, forKey: .cpu)
        }
        if decoderContainer.contains(.memoryGB)
        {
            self.memoryGB = try decoderContainer.decode(Int32?.self, forKey: .memoryGB)
        }
        if decoderContainer.contains(.disk)
        {
            self.disk = try decoderContainer.decode(RdsSpecificationDisk?.self, forKey: .disk)
        }
    }
}
public extension RdsSpecification{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: RdsSpecificationCodingKeys.self)
         try encoderContainer.encode(instanceClass, forKey: .instanceClass)
         try encoderContainer.encode(cpu, forKey: .cpu)
         try encoderContainer.encode(memoryGB, forKey: .memoryGB)
         try encoderContainer.encode(disk, forKey: .disk)
    }
}
///  可用域信息
public class AzInfo:NSObject,Codable{
    /// 可用域 ID
    var zoneId:String?
    /// 名称
    var localName:String?



    public override init(){
            super.init()
    }

    enum AzInfoCodingKeys: String, CodingKey {
        case zoneId
        case localName
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: AzInfoCodingKeys.self)
        if decoderContainer.contains(.zoneId)
        {
            self.zoneId = try decoderContainer.decode(String?.self, forKey: .zoneId)
        }
        if decoderContainer.contains(.localName)
        {
            self.localName = try decoderContainer.decode(String?.self, forKey: .localName)
        }
    }
}
public extension AzInfo{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: AzInfoCodingKeys.self)
         try encoderContainer.encode(zoneId, forKey: .zoneId)
         try encoderContainer.encode(localName, forKey: .localName)
    }
}
///  地域信息
public class RegionInfo:NSObject,Codable{
    /// 地域 ID
    var regionId:String?
    /// 地域名称
    var localName:String?
    /// 供应商
    var vendor:String?



    public override init(){
            super.init()
    }

    enum RegionInfoCodingKeys: String, CodingKey {
        case regionId
        case localName
        case vendor
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: RegionInfoCodingKeys.self)
        if decoderContainer.contains(.regionId)
        {
            self.regionId = try decoderContainer.decode(String?.self, forKey: .regionId)
        }
        if decoderContainer.contains(.localName)
        {
            self.localName = try decoderContainer.decode(String?.self, forKey: .localName)
        }
        if decoderContainer.contains(.vendor)
        {
            self.vendor = try decoderContainer.decode(String?.self, forKey: .vendor)
        }
    }
}
public extension RegionInfo{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: RegionInfoCodingKeys.self)
         try encoderContainer.encode(regionId, forKey: .regionId)
         try encoderContainer.encode(localName, forKey: .localName)
         try encoderContainer.encode(vendor, forKey: .vendor)
    }
}
///  createRDSDB
public class CreateRDSDB:NSObject,Codable{
    /// 数据库名
    /// Required:true
    var name:String
    /// 字符集
    /// Required:true
    var characterSetName:String



    public  init(name:String,characterSetName:String){
             self.name = name
             self.characterSetName = characterSetName
    }

    enum CreateRDSDBCodingKeys: String, CodingKey {
        case name
        case characterSetName
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: CreateRDSDBCodingKeys.self)
        self.name = try decoderContainer.decode(String.self, forKey: .name)
        self.characterSetName = try decoderContainer.decode(String.self, forKey: .characterSetName)
    }
}
public extension CreateRDSDB{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: CreateRDSDBCodingKeys.self)
         try encoderContainer.encode(name, forKey: .name)
         try encoderContainer.encode(characterSetName, forKey: .characterSetName)
    }
}
///  RDS实例上的数据库信息
public class RdsDBInfo:NSObject,Codable{
    /// 数据库名称
    var name:String?
    /// 数据库状态
    var status:String?
    /// 字符集
    var characterSetName:String?
    /// AccountPrivileges
    var accountPrivileges:[RdsDBAccessPrivilege?]?
    /// 所属云提供商ID
    var cloudID:String?



    public override init(){
            super.init()
    }

    enum RdsDBInfoCodingKeys: String, CodingKey {
        case name
        case status
        case characterSetName
        case accountPrivileges
        case cloudID
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: RdsDBInfoCodingKeys.self)
        if decoderContainer.contains(.name)
        {
            self.name = try decoderContainer.decode(String?.self, forKey: .name)
        }
        if decoderContainer.contains(.status)
        {
            self.status = try decoderContainer.decode(String?.self, forKey: .status)
        }
        if decoderContainer.contains(.characterSetName)
        {
            self.characterSetName = try decoderContainer.decode(String?.self, forKey: .characterSetName)
        }
        if decoderContainer.contains(.accountPrivileges)
        {
            self.accountPrivileges = try decoderContainer.decode([RdsDBAccessPrivilege?]?.self, forKey: .accountPrivileges)
        }
        if decoderContainer.contains(.cloudID)
        {
            self.cloudID = try decoderContainer.decode(String?.self, forKey: .cloudID)
        }
    }
}
public extension RdsDBInfo{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: RdsDBInfoCodingKeys.self)
         try encoderContainer.encode(name, forKey: .name)
         try encoderContainer.encode(status, forKey: .status)
         try encoderContainer.encode(characterSetName, forKey: .characterSetName)
         try encoderContainer.encode(accountPrivileges, forKey: .accountPrivileges)
         try encoderContainer.encode(cloudID, forKey: .cloudID)
    }
}
///  RDS数据库上的账号权限
public class RdsDBAccessPrivilege:NSObject,Codable{
    /// 账号名称
    var accountName:String?
    /// 账号对数据库所具有的权限
    var privilege:String?
    /// 所属云提供商ID
    var cloudID:String?



    public override init(){
            super.init()
    }

    enum RdsDBAccessPrivilegeCodingKeys: String, CodingKey {
        case accountName
        case privilege
        case cloudID
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: RdsDBAccessPrivilegeCodingKeys.self)
        if decoderContainer.contains(.accountName)
        {
            self.accountName = try decoderContainer.decode(String?.self, forKey: .accountName)
        }
        if decoderContainer.contains(.privilege)
        {
            self.privilege = try decoderContainer.decode(String?.self, forKey: .privilege)
        }
        if decoderContainer.contains(.cloudID)
        {
            self.cloudID = try decoderContainer.decode(String?.self, forKey: .cloudID)
        }
    }
}
public extension RdsDBAccessPrivilege{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: RdsDBAccessPrivilegeCodingKeys.self)
         try encoderContainer.encode(accountName, forKey: .accountName)
         try encoderContainer.encode(privilege, forKey: .privilege)
         try encoderContainer.encode(cloudID, forKey: .cloudID)
    }
}
///  vpcSubnetItem
public class VpcSubnetItem:NSObject,Codable{
    /// Subnet
    var subnet:SubnetDesInfo?



    public override init(){
            super.init()
    }

    enum VpcSubnetItemCodingKeys: String, CodingKey {
        case subnet
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: VpcSubnetItemCodingKeys.self)
        if decoderContainer.contains(.subnet)
        {
            self.subnet = try decoderContainer.decode(SubnetDesInfo?.self, forKey: .subnet)
        }
    }
}
public extension VpcSubnetItem{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: VpcSubnetItemCodingKeys.self)
         try encoderContainer.encode(subnet, forKey: .subnet)
    }
}
///  vpcSubnetCollection
public class VpcSubnetCollection:NSObject,Codable{
    /// Subnets
    var subnets:[SubnetDesInfo?]?



    public override init(){
            super.init()
    }

    enum VpcSubnetCollectionCodingKeys: String, CodingKey {
        case subnets
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: VpcSubnetCollectionCodingKeys.self)
        if decoderContainer.contains(.subnets)
        {
            self.subnets = try decoderContainer.decode([SubnetDesInfo?]?.self, forKey: .subnets)
        }
    }
}
public extension VpcSubnetCollection{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: VpcSubnetCollectionCodingKeys.self)
         try encoderContainer.encode(subnets, forKey: .subnets)
    }
}
///  vpcCreateTask
public class VpcCreateTask:NSObject,Codable{
    /// Task
    var task:ResourceTFInfo?



    public override init(){
            super.init()
    }

    enum VpcCreateTaskCodingKeys: String, CodingKey {
        case task
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: VpcCreateTaskCodingKeys.self)
        if decoderContainer.contains(.task)
        {
            self.task = try decoderContainer.decode(ResourceTFInfo?.self, forKey: .task)
        }
    }
}
public extension VpcCreateTask{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: VpcCreateTaskCodingKeys.self)
         try encoderContainer.encode(task, forKey: .task)
    }
}
///  vpcCollection
public class VpcCollection:NSObject,Codable{
    /// Vpcs
    var vpcs:[VpcInfo?]?



    public override init(){
            super.init()
    }

    enum VpcCollectionCodingKeys: String, CodingKey {
        case vpcs
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: VpcCollectionCodingKeys.self)
        if decoderContainer.contains(.vpcs)
        {
            self.vpcs = try decoderContainer.decode([VpcInfo?]?.self, forKey: .vpcs)
        }
    }
}
public extension VpcCollection{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: VpcCollectionCodingKeys.self)
         try encoderContainer.encode(vpcs, forKey: .vpcs)
    }
}
///  vpcItem
public class VpcItem:NSObject,Codable{
    /// Vpc
    var vpc:VpcInfoDetail?



    public override init(){
            super.init()
    }

    enum VpcItemCodingKeys: String, CodingKey {
        case vpc
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: VpcItemCodingKeys.self)
        if decoderContainer.contains(.vpc)
        {
            self.vpc = try decoderContainer.decode(VpcInfoDetail?.self, forKey: .vpc)
        }
    }
}
public extension VpcItem{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: VpcItemCodingKeys.self)
         try encoderContainer.encode(vpc, forKey: .vpc)
    }
}
///  vmInstanceCollection
public class VmInstanceCollection:NSObject,Codable{
    /// Vms
    var vms:[VmInfo?]?



    public override init(){
            super.init()
    }

    enum VmInstanceCollectionCodingKeys: String, CodingKey {
        case vms
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: VmInstanceCollectionCodingKeys.self)
        if decoderContainer.contains(.vms)
        {
            self.vms = try decoderContainer.decode([VmInfo?]?.self, forKey: .vms)
        }
    }
}
public extension VmInstanceCollection{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: VmInstanceCollectionCodingKeys.self)
         try encoderContainer.encode(vms, forKey: .vms)
    }
}
///  vmInstanceItem
public class VmInstanceItem:NSObject,Codable{
    /// Vm
    var vm:VmInfoDetail?



    public override init(){
            super.init()
    }

    enum VmInstanceItemCodingKeys: String, CodingKey {
        case vm
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: VmInstanceItemCodingKeys.self)
        if decoderContainer.contains(.vm)
        {
            self.vm = try decoderContainer.decode(VmInfoDetail?.self, forKey: .vm)
        }
    }
}
public extension VmInstanceItem{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: VmInstanceItemCodingKeys.self)
         try encoderContainer.encode(vm, forKey: .vm)
    }
}
///  vmInstanceCreateTask
public class VmInstanceCreateTask:NSObject,Codable{
    /// Task
    var task:ResourceTFInfo?



    public override init(){
            super.init()
    }

    enum VmInstanceCreateTaskCodingKeys: String, CodingKey {
        case task
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: VmInstanceCreateTaskCodingKeys.self)
        if decoderContainer.contains(.task)
        {
            self.task = try decoderContainer.decode(ResourceTFInfo?.self, forKey: .task)
        }
    }
}
public extension VmInstanceCreateTask{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: VmInstanceCreateTaskCodingKeys.self)
         try encoderContainer.encode(task, forKey: .task)
    }
}
///  createRDSInstanceReq
public class CreateRDSInstanceReq:NSObject,Codable{
    /// Instance
    var instance:CreateRDSInstance?



    public override init(){
            super.init()
    }

    enum CreateRDSInstanceReqCodingKeys: String, CodingKey {
        case instance
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: CreateRDSInstanceReqCodingKeys.self)
        if decoderContainer.contains(.instance)
        {
            self.instance = try decoderContainer.decode(CreateRDSInstance?.self, forKey: .instance)
        }
    }
}
public extension CreateRDSInstanceReq{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: CreateRDSInstanceReqCodingKeys.self)
         try encoderContainer.encode(instance, forKey: .instance)
    }
}
///  vmKeypairCreateTask
public class VmKeypairCreateTask:NSObject,Codable{
    /// Tasks
    var tasks:[ResourceTFInfo?]?



    public override init(){
            super.init()
    }

    enum VmKeypairCreateTaskCodingKeys: String, CodingKey {
        case tasks
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: VmKeypairCreateTaskCodingKeys.self)
        if decoderContainer.contains(.tasks)
        {
            self.tasks = try decoderContainer.decode([ResourceTFInfo?]?.self, forKey: .tasks)
        }
    }
}
public extension VmKeypairCreateTask{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: VmKeypairCreateTaskCodingKeys.self)
         try encoderContainer.encode(tasks, forKey: .tasks)
    }
}
///  vmKeypairItem
public class VmKeypairItem:NSObject,Codable{
    /// Keypair
    var keypair:KeypairInfo?



    public override init(){
            super.init()
    }

    enum VmKeypairItemCodingKeys: String, CodingKey {
        case keypair
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: VmKeypairItemCodingKeys.self)
        if decoderContainer.contains(.keypair)
        {
            self.keypair = try decoderContainer.decode(KeypairInfo?.self, forKey: .keypair)
        }
    }
}
public extension VmKeypairItem{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: VmKeypairItemCodingKeys.self)
         try encoderContainer.encode(keypair, forKey: .keypair)
    }
}
///  vmKeypairCollection
public class VmKeypairCollection:NSObject,Codable{
    /// Keypairs
    var keypairs:[KeypairInfo?]?



    public override init(){
            super.init()
    }

    enum VmKeypairCollectionCodingKeys: String, CodingKey {
        case keypairs
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: VmKeypairCollectionCodingKeys.self)
        if decoderContainer.contains(.keypairs)
        {
            self.keypairs = try decoderContainer.decode([KeypairInfo?]?.self, forKey: .keypairs)
        }
    }
}
public extension VmKeypairCollection{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: VmKeypairCollectionCodingKeys.self)
         try encoderContainer.encode(keypairs, forKey: .keypairs)
    }
}
///  returnErrorInfo
public class ReturnErrorInfo:NSObject,Codable{
    /// 10位错误码；1-4服务码，5-7业务码，8-0错误码
    var code:String?
    /// 错误信息
    var msg:String?
    /// http协议状态码
    var httpStatus:Int32?
    /// PayloadInfo
    var payloadInfo:AnyObject?



    public override init(){
            super.init()
    }

    enum ReturnErrorInfoCodingKeys: String, CodingKey {
        case code
        case msg
        case httpStatus
        case payloadInfo
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: ReturnErrorInfoCodingKeys.self)
        if decoderContainer.contains(.code)
        {
            self.code = try decoderContainer.decode(String?.self, forKey: .code)
        }
        if decoderContainer.contains(.msg)
        {
            self.msg = try decoderContainer.decode(String?.self, forKey: .msg)
        }
        if decoderContainer.contains(.httpStatus)
        {
            self.httpStatus = try decoderContainer.decode(Int32?.self, forKey: .httpStatus)
        }
    }
}
public extension ReturnErrorInfo{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: ReturnErrorInfoCodingKeys.self)
         try encoderContainer.encode(code, forKey: .code)
         try encoderContainer.encode(msg, forKey: .msg)
         try encoderContainer.encode(httpStatus, forKey: .httpStatus)
    }
}
///  createChannel
public class CreateChannel:NSObject,Codable{
    /// Channel
    var channel:ChannelInfo?



    public override init(){
            super.init()
    }

    enum CreateChannelCodingKeys: String, CodingKey {
        case channel
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: CreateChannelCodingKeys.self)
        if decoderContainer.contains(.channel)
        {
            self.channel = try decoderContainer.decode(ChannelInfo?.self, forKey: .channel)
        }
    }
}
public extension CreateChannel{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: CreateChannelCodingKeys.self)
         try encoderContainer.encode(channel, forKey: .channel)
    }
}
///  error
public class Error:NSObject,Codable{
    /// Info
    var info:Info?
    /// Payload
    var payload:AnyObject?



    public override init(){
            super.init()
    }

    enum ErrorCodingKeys: String, CodingKey {
        case info
        case payload
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: ErrorCodingKeys.self)
        if decoderContainer.contains(.info)
        {
            self.info = try decoderContainer.decode(Info?.self, forKey: .info)
        }
    }
}
public extension Error{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: ErrorCodingKeys.self)
         try encoderContainer.encode(info, forKey: .info)
    }
}
///  createDatasource
public class CreateDatasource:NSObject,Codable{
    /// Datasource
    var datasource:DatasourceInfo?



    public override init(){
            super.init()
    }

    enum CreateDatasourceCodingKeys: String, CodingKey {
        case datasource
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: CreateDatasourceCodingKeys.self)
        if decoderContainer.contains(.datasource)
        {
            self.datasource = try decoderContainer.decode(DatasourceInfo?.self, forKey: .datasource)
        }
    }
}
public extension CreateDatasource{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: CreateDatasourceCodingKeys.self)
         try encoderContainer.encode(datasource, forKey: .datasource)
    }
}
///  returnError
public class ReturnError:NSObject,Codable{
    /// Error
    var error:Error?



    public override init(){
            super.init()
    }

    enum ReturnErrorCodingKeys: String, CodingKey {
        case error
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: ReturnErrorCodingKeys.self)
        if decoderContainer.contains(.error)
        {
            self.error = try decoderContainer.decode(Error?.self, forKey: .error)
        }
    }
}
public extension ReturnError{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: ReturnErrorCodingKeys.self)
         try encoderContainer.encode(error, forKey: .error)
    }
}
///  info
public class Info:NSObject,Codable{
    /// 10位错误码；1-4服务码，5-7业务码，8-0错误码
    var code:String?
    /// 错误信息
    var message:String?



    public override init(){
            super.init()
    }

    enum InfoCodingKeys: String, CodingKey {
        case code
        case message
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: InfoCodingKeys.self)
        if decoderContainer.contains(.code)
        {
            self.code = try decoderContainer.decode(String?.self, forKey: .code)
        }
        if decoderContainer.contains(.message)
        {
            self.message = try decoderContainer.decode(String?.self, forKey: .message)
        }
    }
}
public extension Info{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: InfoCodingKeys.self)
         try encoderContainer.encode(code, forKey: .code)
         try encoderContainer.encode(message, forKey: .message)
    }
}
///  vpcSecurityGroupCollection
public class VpcSecurityGroupCollection:NSObject,Codable{
    /// SecurityGroups
    var securityGroups:[SecurityGroupInfo?]?



    public override init(){
            super.init()
    }

    enum VpcSecurityGroupCollectionCodingKeys: String, CodingKey {
        case securityGroups
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: VpcSecurityGroupCollectionCodingKeys.self)
        if decoderContainer.contains(.securityGroups)
        {
            self.securityGroups = try decoderContainer.decode([SecurityGroupInfo?]?.self, forKey: .securityGroups)
        }
    }
}
public extension VpcSecurityGroupCollection{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: VpcSecurityGroupCollectionCodingKeys.self)
         try encoderContainer.encode(securityGroups, forKey: .securityGroups)
    }
}
///  vpcSecurityGroupItem
public class VpcSecurityGroupItem:NSObject,Codable{
    /// SecurityGroup
    var securityGroup:SecurityGroupDetail?



    public override init(){
            super.init()
    }

    enum VpcSecurityGroupItemCodingKeys: String, CodingKey {
        case securityGroup
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: VpcSecurityGroupItemCodingKeys.self)
        if decoderContainer.contains(.securityGroup)
        {
            self.securityGroup = try decoderContainer.decode(SecurityGroupDetail?.self, forKey: .securityGroup)
        }
    }
}
public extension VpcSecurityGroupItem{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: VpcSecurityGroupItemCodingKeys.self)
         try encoderContainer.encode(securityGroup, forKey: .securityGroup)
    }
}
///  vpcSecurityGroupCreateTask
public class VpcSecurityGroupCreateTask:NSObject,Codable{
    /// Task
    var task:ResourceTFInfo?



    public override init(){
            super.init()
    }

    enum VpcSecurityGroupCreateTaskCodingKeys: String, CodingKey {
        case task
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: VpcSecurityGroupCreateTaskCodingKeys.self)
        if decoderContainer.contains(.task)
        {
            self.task = try decoderContainer.decode(ResourceTFInfo?.self, forKey: .task)
        }
    }
}
public extension VpcSecurityGroupCreateTask{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: VpcSecurityGroupCreateTaskCodingKeys.self)
         try encoderContainer.encode(task, forKey: .task)
    }
}
///  createRDSAccountReq
public class CreateRDSAccountReq:NSObject,Codable{
    /// Account
    var account:CreateRDSAccount?



    public override init(){
            super.init()
    }

    enum CreateRDSAccountReqCodingKeys: String, CodingKey {
        case account
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: CreateRDSAccountReqCodingKeys.self)
        if decoderContainer.contains(.account)
        {
            self.account = try decoderContainer.decode(CreateRDSAccount?.self, forKey: .account)
        }
    }
}
public extension CreateRDSAccountReq{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: CreateRDSAccountReqCodingKeys.self)
         try encoderContainer.encode(account, forKey: .account)
    }
}
///  cloudInfoListResp
public class CloudInfoListResp:NSObject,Codable{
    /// Clouds
    var clouds:[CloudInfo?]?



    public override init(){
            super.init()
    }

    enum CloudInfoListRespCodingKeys: String, CodingKey {
        case clouds
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: CloudInfoListRespCodingKeys.self)
        if decoderContainer.contains(.clouds)
        {
            self.clouds = try decoderContainer.decode([CloudInfo?]?.self, forKey: .clouds)
        }
    }
}
public extension CloudInfoListResp{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: CloudInfoListRespCodingKeys.self)
         try encoderContainer.encode(clouds, forKey: .clouds)
    }
}
///  getUserCloudNotFoundResp
public class GetUserCloudNotFoundResp:NSObject,Codable{
    /// Error
    var error:AnyObject?



    public override init(){
            super.init()
    }

    enum GetUserCloudNotFoundRespCodingKeys: String, CodingKey {
        case error
    }


    required public init(from decoder: Decoder) throws {
    }
}
public extension GetUserCloudNotFoundResp{
    func encode(to encoder: Encoder) throws {
    }
}
///  userNotFoundResp
public class UserNotFoundResp:NSObject,Codable{
    /// Error
    var error:UserNotFoundException?



    public override init(){
            super.init()
    }

    enum UserNotFoundRespCodingKeys: String, CodingKey {
        case error
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: UserNotFoundRespCodingKeys.self)
        if decoderContainer.contains(.error)
        {
            self.error = try decoderContainer.decode(UserNotFoundException?.self, forKey: .error)
        }
    }
}
public extension UserNotFoundResp{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: UserNotFoundRespCodingKeys.self)
         try encoderContainer.encode(error, forKey: .error)
    }
}
///  payload1
public class Payload1:NSObject,Codable{
    /// Cloud
    /// Required:true
    var cloud:String



    public  init(cloud:String){
             self.cloud = cloud
    }

    enum Payload1CodingKeys: String, CodingKey {
        case cloud
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: Payload1CodingKeys.self)
        self.cloud = try decoderContainer.decode(String.self, forKey: .cloud)
    }
}
public extension Payload1{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: Payload1CodingKeys.self)
         try encoderContainer.encode(cloud, forKey: .cloud)
    }
}
///  cloudInfoResp
public class CloudInfoResp:NSObject,Codable{
    /// Cloud
    var cloud:CloudInfo?



    public override init(){
            super.init()
    }

    enum CloudInfoRespCodingKeys: String, CodingKey {
        case cloud
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: CloudInfoRespCodingKeys.self)
        if decoderContainer.contains(.cloud)
        {
            self.cloud = try decoderContainer.decode(CloudInfo?.self, forKey: .cloud)
        }
    }
}
public extension CloudInfoResp{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: CloudInfoRespCodingKeys.self)
         try encoderContainer.encode(cloud, forKey: .cloud)
    }
}
///  userNotFoundException
public class UserNotFoundException:NSObject,Codable{
    /// Message
    /// Required:true
    var message:String
    /// Code
    /// Required:true
    var code:Int32
    /// Payload
    /// Required:true
    var payload:Payload



    public  init(message:String,code:Int32,payload:Payload){
             self.message = message
             self.code = code
             self.payload = payload
    }

    enum UserNotFoundExceptionCodingKeys: String, CodingKey {
        case message
        case code
        case payload
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: UserNotFoundExceptionCodingKeys.self)
        self.message = try decoderContainer.decode(String.self, forKey: .message)
        self.code = try decoderContainer.decode(Int32.self, forKey: .code)
        self.payload = try decoderContainer.decode(Payload.self, forKey: .payload)
    }
}
public extension UserNotFoundException{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: UserNotFoundExceptionCodingKeys.self)
         try encoderContainer.encode(message, forKey: .message)
         try encoderContainer.encode(code, forKey: .code)
         try encoderContainer.encode(payload, forKey: .payload)
    }
}
///  payload
public class Payload:NSObject,Codable{
    /// Id
    /// Required:true
    var id:String



    public  init(id:String){
             self.id = id
    }

    enum PayloadCodingKeys: String, CodingKey {
        case id
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: PayloadCodingKeys.self)
        self.id = try decoderContainer.decode(String.self, forKey: .id)
    }
}
public extension Payload{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: PayloadCodingKeys.self)
         try encoderContainer.encode(id, forKey: .id)
    }
}
///  cloudNotFoundException
public class CloudNotFoundException:NSObject,Codable{
    /// Message
    /// Required:true
    var message:String
    /// Code
    /// Required:true
    var code:Int32
    /// Payload
    /// Required:true
    var payload:Payload1



    public  init(message:String,code:Int32,payload:Payload1){
             self.message = message
             self.code = code
             self.payload = payload
    }

    enum CloudNotFoundExceptionCodingKeys: String, CodingKey {
        case message
        case code
        case payload
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: CloudNotFoundExceptionCodingKeys.self)
        self.message = try decoderContainer.decode(String.self, forKey: .message)
        self.code = try decoderContainer.decode(Int32.self, forKey: .code)
        self.payload = try decoderContainer.decode(Payload1.self, forKey: .payload)
    }
}
public extension CloudNotFoundException{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: CloudNotFoundExceptionCodingKeys.self)
         try encoderContainer.encode(message, forKey: .message)
         try encoderContainer.encode(code, forKey: .code)
         try encoderContainer.encode(payload, forKey: .payload)
    }
}
///  vmInstanceTypeCollection
public class VmInstanceTypeCollection:NSObject,Codable{
    /// InstanceTypes
    var instanceTypes:[InstanceTypeInfo?]?



    public override init(){
            super.init()
    }

    enum VmInstanceTypeCollectionCodingKeys: String, CodingKey {
        case instanceTypes
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: VmInstanceTypeCollectionCodingKeys.self)
        if decoderContainer.contains(.instanceTypes)
        {
            self.instanceTypes = try decoderContainer.decode([InstanceTypeInfo?]?.self, forKey: .instanceTypes)
        }
    }
}
public extension VmInstanceTypeCollection{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: VmInstanceTypeCollectionCodingKeys.self)
         try encoderContainer.encode(instanceTypes, forKey: .instanceTypes)
    }
}
///  vpcEipCreateTask
public class VpcEipCreateTask:NSObject,Codable{
    /// Task
    var task:ResourceTFInfo?



    public override init(){
            super.init()
    }

    enum VpcEipCreateTaskCodingKeys: String, CodingKey {
        case task
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: VpcEipCreateTaskCodingKeys.self)
        if decoderContainer.contains(.task)
        {
            self.task = try decoderContainer.decode(ResourceTFInfo?.self, forKey: .task)
        }
    }
}
public extension VpcEipCreateTask{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: VpcEipCreateTaskCodingKeys.self)
         try encoderContainer.encode(task, forKey: .task)
    }
}
///  vpcEipItem
public class VpcEipItem:NSObject,Codable{
    /// EipAddress
    var eipAddress:EipAddress?



    public override init(){
            super.init()
    }

    enum VpcEipItemCodingKeys: String, CodingKey {
        case eipAddress
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: VpcEipItemCodingKeys.self)
        if decoderContainer.contains(.eipAddress)
        {
            self.eipAddress = try decoderContainer.decode(EipAddress?.self, forKey: .eipAddress)
        }
    }
}
public extension VpcEipItem{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: VpcEipItemCodingKeys.self)
         try encoderContainer.encode(eipAddress, forKey: .eipAddress)
    }
}
///  vpcEipCollection
public class VpcEipCollection:NSObject,Codable{
    /// EipAddresses
    var eipAddresses:[EipAddress?]?



    public override init(){
            super.init()
    }

    enum VpcEipCollectionCodingKeys: String, CodingKey {
        case eipAddresses
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: VpcEipCollectionCodingKeys.self)
        if decoderContainer.contains(.eipAddresses)
        {
            self.eipAddresses = try decoderContainer.decode([EipAddress?]?.self, forKey: .eipAddresses)
        }
    }
}
public extension VpcEipCollection{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: VpcEipCollectionCodingKeys.self)
         try encoderContainer.encode(eipAddresses, forKey: .eipAddresses)
    }
}
///  diskCreateTask
public class DiskCreateTask:NSObject,Codable{
    /// Task
    var task:ResourceTFInfo?



    public override init(){
            super.init()
    }

    enum DiskCreateTaskCodingKeys: String, CodingKey {
        case task
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: DiskCreateTaskCodingKeys.self)
        if decoderContainer.contains(.task)
        {
            self.task = try decoderContainer.decode(ResourceTFInfo?.self, forKey: .task)
        }
    }
}
public extension DiskCreateTask{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: DiskCreateTaskCodingKeys.self)
         try encoderContainer.encode(task, forKey: .task)
    }
}
///  diskCollection
public class DiskCollection:NSObject,Codable{
    /// Disks
    var disks:[CloudDataDisk?]?



    public override init(){
            super.init()
    }

    enum DiskCollectionCodingKeys: String, CodingKey {
        case disks
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: DiskCollectionCodingKeys.self)
        if decoderContainer.contains(.disks)
        {
            self.disks = try decoderContainer.decode([CloudDataDisk?]?.self, forKey: .disks)
        }
    }
}
public extension DiskCollection{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: DiskCollectionCodingKeys.self)
         try encoderContainer.encode(disks, forKey: .disks)
    }
}
///  diskItem
public class DiskItem:NSObject,Codable{
    /// Disk
    var disk:CloudDataDisk?



    public override init(){
            super.init()
    }

    enum DiskItemCodingKeys: String, CodingKey {
        case disk
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: DiskItemCodingKeys.self)
        if decoderContainer.contains(.disk)
        {
            self.disk = try decoderContainer.decode(CloudDataDisk?.self, forKey: .disk)
        }
    }
}
public extension DiskItem{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: DiskItemCodingKeys.self)
         try encoderContainer.encode(disk, forKey: .disk)
    }
}
///  vpcNetworkInterfaceItem
public class VpcNetworkInterfaceItem:NSObject,Codable{
    /// NetInterface
    var netInterface:NetInterfaceInfo?



    public override init(){
            super.init()
    }

    enum VpcNetworkInterfaceItemCodingKeys: String, CodingKey {
        case netInterface
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: VpcNetworkInterfaceItemCodingKeys.self)
        if decoderContainer.contains(.netInterface)
        {
            self.netInterface = try decoderContainer.decode(NetInterfaceInfo?.self, forKey: .netInterface)
        }
    }
}
public extension VpcNetworkInterfaceItem{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: VpcNetworkInterfaceItemCodingKeys.self)
         try encoderContainer.encode(netInterface, forKey: .netInterface)
    }
}
///  vpcNetworkInterfaceCollection
public class VpcNetworkInterfaceCollection:NSObject,Codable{
    /// NetInterfaces
    var netInterfaces:[NetInterfaceInfo?]?



    public override init(){
            super.init()
    }

    enum VpcNetworkInterfaceCollectionCodingKeys: String, CodingKey {
        case netInterfaces
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: VpcNetworkInterfaceCollectionCodingKeys.self)
        if decoderContainer.contains(.netInterfaces)
        {
            self.netInterfaces = try decoderContainer.decode([NetInterfaceInfo?]?.self, forKey: .netInterfaces)
        }
    }
}
public extension VpcNetworkInterfaceCollection{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: VpcNetworkInterfaceCollectionCodingKeys.self)
         try encoderContainer.encode(netInterfaces, forKey: .netInterfaces)
    }
}
///  vpcSlbCreateTask
public class VpcSlbCreateTask:NSObject,Codable{
    /// Task
    var task:ResourceTFInfo?



    public override init(){
            super.init()
    }

    enum VpcSlbCreateTaskCodingKeys: String, CodingKey {
        case task
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: VpcSlbCreateTaskCodingKeys.self)
        if decoderContainer.contains(.task)
        {
            self.task = try decoderContainer.decode(ResourceTFInfo?.self, forKey: .task)
        }
    }
}
public extension VpcSlbCreateTask{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: VpcSlbCreateTaskCodingKeys.self)
         try encoderContainer.encode(task, forKey: .task)
    }
}
///  vpcSlbCollection
public class VpcSlbCollection:NSObject,Codable{
    /// Slbs
    var slbs:[SlbInfo?]?



    public override init(){
            super.init()
    }

    enum VpcSlbCollectionCodingKeys: String, CodingKey {
        case slbs
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: VpcSlbCollectionCodingKeys.self)
        if decoderContainer.contains(.slbs)
        {
            self.slbs = try decoderContainer.decode([SlbInfo?]?.self, forKey: .slbs)
        }
    }
}
public extension VpcSlbCollection{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: VpcSlbCollectionCodingKeys.self)
         try encoderContainer.encode(slbs, forKey: .slbs)
    }
}
///  vpcSlbItem
public class VpcSlbItem:NSObject,Codable{
    /// Slb
    var slb:SlbInfoDetail?



    public override init(){
            super.init()
    }

    enum VpcSlbItemCodingKeys: String, CodingKey {
        case slb
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: VpcSlbItemCodingKeys.self)
        if decoderContainer.contains(.slb)
        {
            self.slb = try decoderContainer.decode(SlbInfoDetail?.self, forKey: .slb)
        }
    }
}
public extension VpcSlbItem{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: VpcSlbItemCodingKeys.self)
         try encoderContainer.encode(slb, forKey: .slb)
    }
}
///  vpcVServerGroupCollection
public class VpcVServerGroupCollection:NSObject,Codable{
    /// VserverGroups
    var vserverGroups:[VserverGroupInfo?]?



    public override init(){
            super.init()
    }

    enum VpcVServerGroupCollectionCodingKeys: String, CodingKey {
        case vserverGroups
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: VpcVServerGroupCollectionCodingKeys.self)
        if decoderContainer.contains(.vserverGroups)
        {
            self.vserverGroups = try decoderContainer.decode([VserverGroupInfo?]?.self, forKey: .vserverGroups)
        }
    }
}
public extension VpcVServerGroupCollection{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: VpcVServerGroupCollectionCodingKeys.self)
         try encoderContainer.encode(vserverGroups, forKey: .vserverGroups)
    }
}
///  vmImageCollection
public class VmImageCollection:NSObject,Codable{
    /// Images
    var images:[ImageInfo?]?



    public override init(){
            super.init()
    }

    enum VmImageCollectionCodingKeys: String, CodingKey {
        case images
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: VmImageCollectionCodingKeys.self)
        if decoderContainer.contains(.images)
        {
            self.images = try decoderContainer.decode([ImageInfo?]?.self, forKey: .images)
        }
    }
}
public extension VmImageCollection{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: VmImageCollectionCodingKeys.self)
         try encoderContainer.encode(images, forKey: .images)
    }
}

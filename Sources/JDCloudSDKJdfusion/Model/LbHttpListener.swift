/* Copyright 2018 JDCLOUD.COM

   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at

     http:#www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.

   
   

   
   Contact: 

   NOTE: This class is auto generated by the jdcloud code generator program.
 */


import Foundation

///  负载均衡监听器
@objc(LbHttpListener)
public class LbHttpListener:NSObject,Codable{
    /// 负载均衡实例前端使用的端口。
    var listenerPort:Int32?
    /// 负载均衡实例后端使用的端口。
    var backendServerPort:Int32?
    /// 当前监听的状态。
    var status:String?
    /// 调度算法。
    var scheduler:String?
    /// 绑定的服务器组ID。
    var vServerGroupId:String?
    /// 是否开启健康检查。
    var healthCheck:String?
    /// 否  健康检查使用的端口
    var healthCheckConnectPort:Int32?
    /// 否  健康检查连续成功多少次后，将后端服务器的健康检查状态由fail判定为success。取值：2-10
    var healthyThreshold:Int32?
    /// 否  健康检查连续失败多少次后，将后端服务器的健康检查状态由success判定为fail。取值：2-10
    var unhealthyThreshold:Int32?
    /// 否  接收来自运行状况检查的响应需要等待的时间。如果后端ECS在指定的时间内没有正确响应，则判定为健康检查失败。取值：1-300（秒）
    var healthCheckTimeout:Int32?
    /// 否  健康检查的时间间隔。取值：1-50（秒）
    var healthCheckInterval:Int32?
    /// 否  健康检查正常的HTTP状态码，多个状态码用逗号分隔。取值：http_2xx（默认值） | http_3xx | http_4xx | http_5xx
    var healthCheckHttpCode:String?



    public override init(){
            super.init()
    }

    enum LbHttpListenerCodingKeys: String, CodingKey {
        case listenerPort
        case backendServerPort
        case status
        case scheduler
        case vServerGroupId
        case healthCheck
        case healthCheckConnectPort
        case healthyThreshold
        case unhealthyThreshold
        case healthCheckTimeout
        case healthCheckInterval
        case healthCheckHttpCode
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: LbHttpListenerCodingKeys.self)
        if decoderContainer.contains(.listenerPort)
        {
            self.listenerPort = try decoderContainer.decode(Int32?.self, forKey: .listenerPort)
        }
        if decoderContainer.contains(.backendServerPort)
        {
            self.backendServerPort = try decoderContainer.decode(Int32?.self, forKey: .backendServerPort)
        }
        if decoderContainer.contains(.status)
        {
            self.status = try decoderContainer.decode(String?.self, forKey: .status)
        }
        if decoderContainer.contains(.scheduler)
        {
            self.scheduler = try decoderContainer.decode(String?.self, forKey: .scheduler)
        }
        if decoderContainer.contains(.vServerGroupId)
        {
            self.vServerGroupId = try decoderContainer.decode(String?.self, forKey: .vServerGroupId)
        }
        if decoderContainer.contains(.healthCheck)
        {
            self.healthCheck = try decoderContainer.decode(String?.self, forKey: .healthCheck)
        }
        if decoderContainer.contains(.healthCheckConnectPort)
        {
            self.healthCheckConnectPort = try decoderContainer.decode(Int32?.self, forKey: .healthCheckConnectPort)
        }
        if decoderContainer.contains(.healthyThreshold)
        {
            self.healthyThreshold = try decoderContainer.decode(Int32?.self, forKey: .healthyThreshold)
        }
        if decoderContainer.contains(.unhealthyThreshold)
        {
            self.unhealthyThreshold = try decoderContainer.decode(Int32?.self, forKey: .unhealthyThreshold)
        }
        if decoderContainer.contains(.healthCheckTimeout)
        {
            self.healthCheckTimeout = try decoderContainer.decode(Int32?.self, forKey: .healthCheckTimeout)
        }
        if decoderContainer.contains(.healthCheckInterval)
        {
            self.healthCheckInterval = try decoderContainer.decode(Int32?.self, forKey: .healthCheckInterval)
        }
        if decoderContainer.contains(.healthCheckHttpCode)
        {
            self.healthCheckHttpCode = try decoderContainer.decode(String?.self, forKey: .healthCheckHttpCode)
        }
    }
}
public extension LbHttpListener{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: LbHttpListenerCodingKeys.self)
         try encoderContainer.encode(listenerPort, forKey: .listenerPort)
         try encoderContainer.encode(backendServerPort, forKey: .backendServerPort)
         try encoderContainer.encode(status, forKey: .status)
         try encoderContainer.encode(scheduler, forKey: .scheduler)
         try encoderContainer.encode(vServerGroupId, forKey: .vServerGroupId)
         try encoderContainer.encode(healthCheck, forKey: .healthCheck)
         try encoderContainer.encode(healthCheckConnectPort, forKey: .healthCheckConnectPort)
         try encoderContainer.encode(healthyThreshold, forKey: .healthyThreshold)
         try encoderContainer.encode(unhealthyThreshold, forKey: .unhealthyThreshold)
         try encoderContainer.encode(healthCheckTimeout, forKey: .healthCheckTimeout)
         try encoderContainer.encode(healthCheckInterval, forKey: .healthCheckInterval)
         try encoderContainer.encode(healthCheckHttpCode, forKey: .healthCheckHttpCode)
    }
}

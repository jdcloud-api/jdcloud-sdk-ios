/* Copyright 2018 JDCLOUD.COM

   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at

     http:#www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.

   操作列表
   云解析OpenAPI操作列表接口

   OpenAPI spec version: v2
   Contact: 

   NOTE: This class is auto generated by the jdcloud code generator program.
 */


import Foundation
///  domainAdded
public class DomainAdded:NSObject,Codable{
    /// 域名的唯一ID
    var id:Int?
    /// 域名字符串
    var domainName:String?
    /// 创建时间，格式Unix timestamp，时间单位：毫秒
    var createTime:Int64?
    /// 过期时间，格式Unix timestamp，时间单位：毫秒
    var expirationDate:Int64?
    /// 套餐类型，免费:0 企业版:1 企业高级版:2
    var packId:Int?



    public override init(){
            super.init()
    }

    enum DomainAddedCodingKeys: String, CodingKey {
        case id
        case domainName
        case createTime
        case expirationDate
        case packId
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: DomainAddedCodingKeys.self)
        if decoderContainer.contains(.id)
        {
            self.id = try decoderContainer.decode(Int?.self, forKey: .id)
        }
        if decoderContainer.contains(.domainName)
        {
            self.domainName = try decoderContainer.decode(String?.self, forKey: .domainName)
        }
        if decoderContainer.contains(.createTime)
        {
            self.createTime = try decoderContainer.decode(Int64?.self, forKey: .createTime)
        }
        if decoderContainer.contains(.expirationDate)
        {
            self.expirationDate = try decoderContainer.decode(Int64?.self, forKey: .expirationDate)
        }
        if decoderContainer.contains(.packId)
        {
            self.packId = try decoderContainer.decode(Int?.self, forKey: .packId)
        }
    }
}
public extension DomainAdded{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: DomainAddedCodingKeys.self)
         try encoderContainer.encode(id, forKey: .id)
         try encoderContainer.encode(domainName, forKey: .domainName)
         try encoderContainer.encode(createTime, forKey: .createTime)
         try encoderContainer.encode(expirationDate, forKey: .expirationDate)
         try encoderContainer.encode(packId, forKey: .packId)
    }
}
///  domainInfo
public class DomainInfo:NSObject,Codable{
    /// 域名的唯一ID
    var id:Int?
    /// 域名字符串
    var domainName:String?
    /// 创建时间，格式Unix timestamp，时间单位：毫秒
    var createTime:Int64?
    /// 过期时间，格式Unix timestamp，时间单位：毫秒
    var expirationDate:Int64?
    /// 套餐类型，免费:0 企业版:1 企业高级版:2
    var packId:Int?
    /// 套餐的名字
    var packName:String?
    /// 解析的状态, 暂无解析:1，正常解析:2， 部分解析:3， 暂停解析:4 NS未修改:5，域名探测错误:7，域名未注册:8，注册局暂停解析:9
    var resolvingStatus:String?
    /// 创建者
    var creator:String?
    /// 是否是京东云资源
    var jcloudNs:Bool?
    /// 域名的锁定状态，0:未锁定， 1:已锁定
    var lockStatus:Int?
    /// 主域名当前的Nameserver列表
    var probeNsList:[String?]?
    /// 主域名应该设置的Nameserver列表
    var defNsList:[String?]?



    public override init(){
            super.init()
    }

    enum DomainInfoCodingKeys: String, CodingKey {
        case id
        case domainName
        case createTime
        case expirationDate
        case packId
        case packName
        case resolvingStatus
        case creator
        case jcloudNs
        case lockStatus
        case probeNsList
        case defNsList
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: DomainInfoCodingKeys.self)
        if decoderContainer.contains(.id)
        {
            self.id = try decoderContainer.decode(Int?.self, forKey: .id)
        }
        if decoderContainer.contains(.domainName)
        {
            self.domainName = try decoderContainer.decode(String?.self, forKey: .domainName)
        }
        if decoderContainer.contains(.createTime)
        {
            self.createTime = try decoderContainer.decode(Int64?.self, forKey: .createTime)
        }
        if decoderContainer.contains(.expirationDate)
        {
            self.expirationDate = try decoderContainer.decode(Int64?.self, forKey: .expirationDate)
        }
        if decoderContainer.contains(.packId)
        {
            self.packId = try decoderContainer.decode(Int?.self, forKey: .packId)
        }
        if decoderContainer.contains(.packName)
        {
            self.packName = try decoderContainer.decode(String?.self, forKey: .packName)
        }
        if decoderContainer.contains(.resolvingStatus)
        {
            self.resolvingStatus = try decoderContainer.decode(String?.self, forKey: .resolvingStatus)
        }
        if decoderContainer.contains(.creator)
        {
            self.creator = try decoderContainer.decode(String?.self, forKey: .creator)
        }
        if decoderContainer.contains(.jcloudNs)
        {
            self.jcloudNs = try decoderContainer.decode(Bool?.self, forKey: .jcloudNs)
        }
        if decoderContainer.contains(.lockStatus)
        {
            self.lockStatus = try decoderContainer.decode(Int?.self, forKey: .lockStatus)
        }
        if decoderContainer.contains(.probeNsList)
        {
            self.probeNsList = try decoderContainer.decode([String?]?.self, forKey: .probeNsList)
        }
        if decoderContainer.contains(.defNsList)
        {
            self.defNsList = try decoderContainer.decode([String?]?.self, forKey: .defNsList)
        }
    }
}
public extension DomainInfo{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: DomainInfoCodingKeys.self)
         try encoderContainer.encode(id, forKey: .id)
         try encoderContainer.encode(domainName, forKey: .domainName)
         try encoderContainer.encode(createTime, forKey: .createTime)
         try encoderContainer.encode(expirationDate, forKey: .expirationDate)
         try encoderContainer.encode(packId, forKey: .packId)
         try encoderContainer.encode(packName, forKey: .packName)
         try encoderContainer.encode(resolvingStatus, forKey: .resolvingStatus)
         try encoderContainer.encode(creator, forKey: .creator)
         try encoderContainer.encode(jcloudNs, forKey: .jcloudNs)
         try encoderContainer.encode(lockStatus, forKey: .lockStatus)
         try encoderContainer.encode(probeNsList, forKey: .probeNsList)
         try encoderContainer.encode(defNsList, forKey: .defNsList)
    }
}
///  notice
public class Notice:NSObject,Codable{
    /// 信息ID
    var id:Int?
    /// 信息的标题
    var title:String?
    /// 信息的详细URL
    var url:String?



    public override init(){
            super.init()
    }

    enum NoticeCodingKeys: String, CodingKey {
        case id
        case title
        case url
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: NoticeCodingKeys.self)
        if decoderContainer.contains(.id)
        {
            self.id = try decoderContainer.decode(Int?.self, forKey: .id)
        }
        if decoderContainer.contains(.title)
        {
            self.title = try decoderContainer.decode(String?.self, forKey: .title)
        }
        if decoderContainer.contains(.url)
        {
            self.url = try decoderContainer.decode(String?.self, forKey: .url)
        }
    }
}
public extension Notice{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: NoticeCodingKeys.self)
         try encoderContainer.encode(id, forKey: .id)
         try encoderContainer.encode(title, forKey: .title)
         try encoderContainer.encode(url, forKey: .url)
    }
}
///  monitorAlarmInfo
public class MonitorAlarmInfo:NSObject,Codable{
    /// 域名ID
    var domainId:Int?
    /// 子域名
    var subDomainName:String?
    /// 故障IP/域名
    var host:String?
    /// null
    var id:Int?
    /// 故障开始时间，格式Unix timestamp，时间单位：毫秒
    var startTime:Int64?
    /// 故障结束时间，格式Unix timestamp，时间单位：毫秒
    var endTime:Int64?



    public override init(){
            super.init()
    }

    enum MonitorAlarmInfoCodingKeys: String, CodingKey {
        case domainId
        case subDomainName
        case host
        case id
        case startTime
        case endTime
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: MonitorAlarmInfoCodingKeys.self)
        if decoderContainer.contains(.domainId)
        {
            self.domainId = try decoderContainer.decode(Int?.self, forKey: .domainId)
        }
        if decoderContainer.contains(.subDomainName)
        {
            self.subDomainName = try decoderContainer.decode(String?.self, forKey: .subDomainName)
        }
        if decoderContainer.contains(.host)
        {
            self.host = try decoderContainer.decode(String?.self, forKey: .host)
        }
        if decoderContainer.contains(.id)
        {
            self.id = try decoderContainer.decode(Int?.self, forKey: .id)
        }
        if decoderContainer.contains(.startTime)
        {
            self.startTime = try decoderContainer.decode(Int64?.self, forKey: .startTime)
        }
        if decoderContainer.contains(.endTime)
        {
            self.endTime = try decoderContainer.decode(Int64?.self, forKey: .endTime)
        }
    }
}
public extension MonitorAlarmInfo{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: MonitorAlarmInfoCodingKeys.self)
         try encoderContainer.encode(domainId, forKey: .domainId)
         try encoderContainer.encode(subDomainName, forKey: .subDomainName)
         try encoderContainer.encode(host, forKey: .host)
         try encoderContainer.encode(id, forKey: .id)
         try encoderContainer.encode(startTime, forKey: .startTime)
         try encoderContainer.encode(endTime, forKey: .endTime)
    }
}
///  backupAddressesInfo
public class BackupAddressesInfo:NSObject,Codable{
    /// 地址
    var address:String?
    /// 备用地址1的类型，1为ip 2为域名
    var type:Int?
    /// 备用地址1的状态，0正常，1异常
    var status:Int?



    public override init(){
            super.init()
    }

    enum BackupAddressesInfoCodingKeys: String, CodingKey {
        case address
        case type
        case status
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: BackupAddressesInfoCodingKeys.self)
        if decoderContainer.contains(.address)
        {
            self.address = try decoderContainer.decode(String?.self, forKey: .address)
        }
        if decoderContainer.contains(.type)
        {
            self.type = try decoderContainer.decode(Int?.self, forKey: .type)
        }
        if decoderContainer.contains(.status)
        {
            self.status = try decoderContainer.decode(Int?.self, forKey: .status)
        }
    }
}
public extension BackupAddressesInfo{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: BackupAddressesInfoCodingKeys.self)
         try encoderContainer.encode(address, forKey: .address)
         try encoderContainer.encode(type, forKey: .type)
         try encoderContainer.encode(status, forKey: .status)
    }
}
///  httpHeader
public class HttpHeader:NSObject,Codable{
    /// 头域名称
    /// Required:true
    var name:String
    /// 头域阈值
    /// Required:true
    var value:String



    public  init(name:String,value:String){
             self.name = name
             self.value = value
    }

    enum HttpHeaderCodingKeys: String, CodingKey {
        case name
        case value
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: HttpHeaderCodingKeys.self)
        self.name = try decoderContainer.decode(String.self, forKey: .name)
        self.value = try decoderContainer.decode(String.self, forKey: .value)
    }
}
public extension HttpHeader{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: HttpHeaderCodingKeys.self)
         try encoderContainer.encode(name, forKey: .name)
         try encoderContainer.encode(value, forKey: .value)
    }
}
///  updateMonitor
public class UpdateMonitor:NSObject,Codable{
    /// 连续几次触发报警
    /// Required:true
    var alarmLimit:Int
    /// 监控项ID
    /// Required:true
    var id:Int
    /// 备用地址1
    /// Required:true
    var ipBackup01:String
    /// 备用地址2
    /// Required:true
    var ipBackup02:String
    /// 备用地址列表，存在该参数时，可不填写参数备用地址1、备用地址2
    var backupAddressList:[String?]?
    /// 监控状况 开启监控:2，暂停监控:4
    /// Required:true
    var monitorEnable:Int
    /// 监控频率，单位秒
    /// Required:true
    var monitorFreq:Int
    /// 监控端口
    /// Required:true
    var monitorPort:Int
    /// 不做任何修改0，强制暂停解析记录1，自动切换到备用地址2
    /// Required:true
    var monitorRule:Int
    /// 监控路径
    /// Required:true
    var monitorUri:String
    /// 不发送邮件:0， 发送邮件:1
    /// Required:true
    var notifyEmailEnable:Int
    /// 不发送通知栏:0， 发送通知栏:1
    /// Required:true
    var notifyMsgBarEnable:Int
    /// 不发送短信:0， 发送短信:1
    var notifySmsEnable:Int?
    /// https 0，https 1
    /// Required:true
    var protocolValue:Int
    /// 0自动恢复 1手动恢复
    /// Required:true
    var stopRecoverRule:Int
    /// 0自动恢复至主host 1手动恢复至主host
    /// Required:true
    var switchRecoverRule:Int
    /// 探测请求携带自定义头域及其域值列表
    var requestHeaders:[HttpHeader?]?
    /// 探测响应Body体中包含的字符串
    var responseBodyMatch:String?
    /// 探测响应码范围列表
    var responseCodeRanges:[HttpResponseCodeRange?]?



    public  init(alarmLimit:Int,id:Int,ipBackup01:String,ipBackup02:String,monitorEnable:Int,monitorFreq:Int,monitorPort:Int,monitorRule:Int,monitorUri:String,notifyEmailEnable:Int,notifyMsgBarEnable:Int,protocolValue:Int,stopRecoverRule:Int,switchRecoverRule:Int){
             self.alarmLimit = alarmLimit
             self.id = id
             self.ipBackup01 = ipBackup01
             self.ipBackup02 = ipBackup02
             self.monitorEnable = monitorEnable
             self.monitorFreq = monitorFreq
             self.monitorPort = monitorPort
             self.monitorRule = monitorRule
             self.monitorUri = monitorUri
             self.notifyEmailEnable = notifyEmailEnable
             self.notifyMsgBarEnable = notifyMsgBarEnable
             self.protocolValue = protocolValue
             self.stopRecoverRule = stopRecoverRule
             self.switchRecoverRule = switchRecoverRule
    }

    enum UpdateMonitorCodingKeys: String, CodingKey {
        case alarmLimit
        case id
        case ipBackup01
        case ipBackup02
        case backupAddressList
        case monitorEnable
        case monitorFreq
        case monitorPort
        case monitorRule
        case monitorUri
        case notifyEmailEnable
        case notifyMsgBarEnable
        case notifySmsEnable
        case protocolValue = "protocol"
        case stopRecoverRule
        case switchRecoverRule
        case requestHeaders
        case responseBodyMatch
        case responseCodeRanges
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: UpdateMonitorCodingKeys.self)
        self.alarmLimit = try decoderContainer.decode(Int.self, forKey: .alarmLimit)
        self.id = try decoderContainer.decode(Int.self, forKey: .id)
        self.ipBackup01 = try decoderContainer.decode(String.self, forKey: .ipBackup01)
        self.ipBackup02 = try decoderContainer.decode(String.self, forKey: .ipBackup02)
        if decoderContainer.contains(.backupAddressList)
        {
            self.backupAddressList = try decoderContainer.decode([String?]?.self, forKey: .backupAddressList)
        }
        self.monitorEnable = try decoderContainer.decode(Int.self, forKey: .monitorEnable)
        self.monitorFreq = try decoderContainer.decode(Int.self, forKey: .monitorFreq)
        self.monitorPort = try decoderContainer.decode(Int.self, forKey: .monitorPort)
        self.monitorRule = try decoderContainer.decode(Int.self, forKey: .monitorRule)
        self.monitorUri = try decoderContainer.decode(String.self, forKey: .monitorUri)
        self.notifyEmailEnable = try decoderContainer.decode(Int.self, forKey: .notifyEmailEnable)
        self.notifyMsgBarEnable = try decoderContainer.decode(Int.self, forKey: .notifyMsgBarEnable)
        if decoderContainer.contains(.notifySmsEnable)
        {
            self.notifySmsEnable = try decoderContainer.decode(Int?.self, forKey: .notifySmsEnable)
        }
        self.protocolValue = try decoderContainer.decode(Int.self, forKey: .protocolValue)
        self.stopRecoverRule = try decoderContainer.decode(Int.self, forKey: .stopRecoverRule)
        self.switchRecoverRule = try decoderContainer.decode(Int.self, forKey: .switchRecoverRule)
        if decoderContainer.contains(.requestHeaders)
        {
            self.requestHeaders = try decoderContainer.decode([HttpHeader?]?.self, forKey: .requestHeaders)
        }
        if decoderContainer.contains(.responseBodyMatch)
        {
            self.responseBodyMatch = try decoderContainer.decode(String?.self, forKey: .responseBodyMatch)
        }
        if decoderContainer.contains(.responseCodeRanges)
        {
            self.responseCodeRanges = try decoderContainer.decode([HttpResponseCodeRange?]?.self, forKey: .responseCodeRanges)
        }
    }
}
public extension UpdateMonitor{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: UpdateMonitorCodingKeys.self)
         try encoderContainer.encode(alarmLimit, forKey: .alarmLimit)
         try encoderContainer.encode(id, forKey: .id)
         try encoderContainer.encode(ipBackup01, forKey: .ipBackup01)
         try encoderContainer.encode(ipBackup02, forKey: .ipBackup02)
         try encoderContainer.encode(backupAddressList, forKey: .backupAddressList)
         try encoderContainer.encode(monitorEnable, forKey: .monitorEnable)
         try encoderContainer.encode(monitorFreq, forKey: .monitorFreq)
         try encoderContainer.encode(monitorPort, forKey: .monitorPort)
         try encoderContainer.encode(monitorRule, forKey: .monitorRule)
         try encoderContainer.encode(monitorUri, forKey: .monitorUri)
         try encoderContainer.encode(notifyEmailEnable, forKey: .notifyEmailEnable)
         try encoderContainer.encode(notifyMsgBarEnable, forKey: .notifyMsgBarEnable)
         try encoderContainer.encode(notifySmsEnable, forKey: .notifySmsEnable)
         try encoderContainer.encode(protocolValue, forKey: .protocolValue)
         try encoderContainer.encode(stopRecoverRule, forKey: .stopRecoverRule)
         try encoderContainer.encode(switchRecoverRule, forKey: .switchRecoverRule)
         try encoderContainer.encode(requestHeaders, forKey: .requestHeaders)
         try encoderContainer.encode(responseBodyMatch, forKey: .responseBodyMatch)
         try encoderContainer.encode(responseCodeRanges, forKey: .responseCodeRanges)
    }
}
///  monitor
public class Monitor:NSObject,Codable{
    /// 连续几次触发报警
    var alarmLimit:Int?
    /// 现在是否可以恢复
    var canRecover:Bool?
    /// 现在是否可以切换
    var canSwitch:Bool?
    /// 机房探测点的集合
    var clusters:String?
    /// 主域名
    var domainName:String?
    /// 主机状态，0正常，1异常
    var hostStatus:Int?
    /// 监控对象
    var hostValue:String?
    /// 监控项ID
    var id:Int?
    /// 备用地址1
    var ipBackup01:String?
    /// 备用地址1的状态，0正常，1异常
    var ipBackup01Status:Int?
    /// 备用地址1的类型，1为ip 2为域名
    var ipBackup01Type:Int?
    /// 备用地址2
    var ipBackup02:String?
    /// 备用地址2的状态，0正常，1异常
    var ipBackup02Status:Int?
    /// 备用地址1的类型，1为ip 2为域名
    var ipBackup02Type:Int?
    /// 手动切换的地址
    var manualBackup:String?
    /// 手动切换的地址的状态，0正常，1异常
    var manualBackupStatus:Int?
    /// 手动切换的地址的类型，1为ip 2为域名
    var manualBackupType:Int?
    /// 监控状况 开启监控 2，暂停监控 4
    var monitorEnable:Int?
    /// 监控频率，单位秒
    var monitorFreq:Int?
    /// 监控端口
    var monitorPort:Int?
    /// 不做任何修改0，强制暂停解析记录1，自动切换到备用地址2
    var monitorRule:Int?
    /// 监控路径
    var monitorUri:String?
    /// 邮箱地址
    var notifyEmail:String?
    /// 不发送邮件0， 发送邮件1
    var notifyEmailEnable:Int?
    /// 不发送通知栏 0， 发送通知栏 1
    var notifyMsgBarEnable:Int?
    /// 手机号码
    var notifySms:String?
    /// 不发送短信 0， 发送短信 1
    var notifySmsEnable:Int?
    /// http协议:0，https协议:1
    var protocolValue:Int?
    /// 自动恢复:0 手动恢复:1
    var stopRecoverRule:Int?
    /// 子域名
    var subDomainName:String?
    /// 自动恢复至主host:0 手动恢复至主host:1
    var switchRecoverRule:Int?
    /// 1为A记录，2为CNAME
    var type:Int?
    /// 使用记录，host_value 0，ip_backup_01 1，ip_backup_02 2，cname_backup 3
    var usedType:Int?
    /// 备用地址及其状态列表
    var backupAddressList:[BackupAddressesInfo?]?
    /// 探测请求携带自定义头域及其域值列表
    var requestHeaders:[HttpHeader?]?
    /// 探测响应Body体中包含的字符串
    var responseBodyMatch:String?
    /// 探测响应码范围列表
    var responseCodeRanges:[HttpResponseCodeRange?]?
    /// 正在使用的有效解析地址
    var effectAddr:String?



    public override init(){
            super.init()
    }

    enum MonitorCodingKeys: String, CodingKey {
        case alarmLimit
        case canRecover
        case canSwitch
        case clusters
        case domainName
        case hostStatus
        case hostValue
        case id
        case ipBackup01
        case ipBackup01Status
        case ipBackup01Type
        case ipBackup02
        case ipBackup02Status
        case ipBackup02Type
        case manualBackup
        case manualBackupStatus
        case manualBackupType
        case monitorEnable
        case monitorFreq
        case monitorPort
        case monitorRule
        case monitorUri
        case notifyEmail
        case notifyEmailEnable
        case notifyMsgBarEnable
        case notifySms
        case notifySmsEnable
        case protocolValue = "protocol"
        case stopRecoverRule
        case subDomainName
        case switchRecoverRule
        case type
        case usedType
        case backupAddressList
        case requestHeaders
        case responseBodyMatch
        case responseCodeRanges
        case effectAddr
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: MonitorCodingKeys.self)
        if decoderContainer.contains(.alarmLimit)
        {
            self.alarmLimit = try decoderContainer.decode(Int?.self, forKey: .alarmLimit)
        }
        if decoderContainer.contains(.canRecover)
        {
            self.canRecover = try decoderContainer.decode(Bool?.self, forKey: .canRecover)
        }
        if decoderContainer.contains(.canSwitch)
        {
            self.canSwitch = try decoderContainer.decode(Bool?.self, forKey: .canSwitch)
        }
        if decoderContainer.contains(.clusters)
        {
            self.clusters = try decoderContainer.decode(String?.self, forKey: .clusters)
        }
        if decoderContainer.contains(.domainName)
        {
            self.domainName = try decoderContainer.decode(String?.self, forKey: .domainName)
        }
        if decoderContainer.contains(.hostStatus)
        {
            self.hostStatus = try decoderContainer.decode(Int?.self, forKey: .hostStatus)
        }
        if decoderContainer.contains(.hostValue)
        {
            self.hostValue = try decoderContainer.decode(String?.self, forKey: .hostValue)
        }
        if decoderContainer.contains(.id)
        {
            self.id = try decoderContainer.decode(Int?.self, forKey: .id)
        }
        if decoderContainer.contains(.ipBackup01)
        {
            self.ipBackup01 = try decoderContainer.decode(String?.self, forKey: .ipBackup01)
        }
        if decoderContainer.contains(.ipBackup01Status)
        {
            self.ipBackup01Status = try decoderContainer.decode(Int?.self, forKey: .ipBackup01Status)
        }
        if decoderContainer.contains(.ipBackup01Type)
        {
            self.ipBackup01Type = try decoderContainer.decode(Int?.self, forKey: .ipBackup01Type)
        }
        if decoderContainer.contains(.ipBackup02)
        {
            self.ipBackup02 = try decoderContainer.decode(String?.self, forKey: .ipBackup02)
        }
        if decoderContainer.contains(.ipBackup02Status)
        {
            self.ipBackup02Status = try decoderContainer.decode(Int?.self, forKey: .ipBackup02Status)
        }
        if decoderContainer.contains(.ipBackup02Type)
        {
            self.ipBackup02Type = try decoderContainer.decode(Int?.self, forKey: .ipBackup02Type)
        }
        if decoderContainer.contains(.manualBackup)
        {
            self.manualBackup = try decoderContainer.decode(String?.self, forKey: .manualBackup)
        }
        if decoderContainer.contains(.manualBackupStatus)
        {
            self.manualBackupStatus = try decoderContainer.decode(Int?.self, forKey: .manualBackupStatus)
        }
        if decoderContainer.contains(.manualBackupType)
        {
            self.manualBackupType = try decoderContainer.decode(Int?.self, forKey: .manualBackupType)
        }
        if decoderContainer.contains(.monitorEnable)
        {
            self.monitorEnable = try decoderContainer.decode(Int?.self, forKey: .monitorEnable)
        }
        if decoderContainer.contains(.monitorFreq)
        {
            self.monitorFreq = try decoderContainer.decode(Int?.self, forKey: .monitorFreq)
        }
        if decoderContainer.contains(.monitorPort)
        {
            self.monitorPort = try decoderContainer.decode(Int?.self, forKey: .monitorPort)
        }
        if decoderContainer.contains(.monitorRule)
        {
            self.monitorRule = try decoderContainer.decode(Int?.self, forKey: .monitorRule)
        }
        if decoderContainer.contains(.monitorUri)
        {
            self.monitorUri = try decoderContainer.decode(String?.self, forKey: .monitorUri)
        }
        if decoderContainer.contains(.notifyEmail)
        {
            self.notifyEmail = try decoderContainer.decode(String?.self, forKey: .notifyEmail)
        }
        if decoderContainer.contains(.notifyEmailEnable)
        {
            self.notifyEmailEnable = try decoderContainer.decode(Int?.self, forKey: .notifyEmailEnable)
        }
        if decoderContainer.contains(.notifyMsgBarEnable)
        {
            self.notifyMsgBarEnable = try decoderContainer.decode(Int?.self, forKey: .notifyMsgBarEnable)
        }
        if decoderContainer.contains(.notifySms)
        {
            self.notifySms = try decoderContainer.decode(String?.self, forKey: .notifySms)
        }
        if decoderContainer.contains(.notifySmsEnable)
        {
            self.notifySmsEnable = try decoderContainer.decode(Int?.self, forKey: .notifySmsEnable)
        }
        if decoderContainer.contains(.protocolValue)
        {
            self.protocolValue = try decoderContainer.decode(Int?.self, forKey: .protocolValue)
        }
        if decoderContainer.contains(.stopRecoverRule)
        {
            self.stopRecoverRule = try decoderContainer.decode(Int?.self, forKey: .stopRecoverRule)
        }
        if decoderContainer.contains(.subDomainName)
        {
            self.subDomainName = try decoderContainer.decode(String?.self, forKey: .subDomainName)
        }
        if decoderContainer.contains(.switchRecoverRule)
        {
            self.switchRecoverRule = try decoderContainer.decode(Int?.self, forKey: .switchRecoverRule)
        }
        if decoderContainer.contains(.type)
        {
            self.type = try decoderContainer.decode(Int?.self, forKey: .type)
        }
        if decoderContainer.contains(.usedType)
        {
            self.usedType = try decoderContainer.decode(Int?.self, forKey: .usedType)
        }
        if decoderContainer.contains(.backupAddressList)
        {
            self.backupAddressList = try decoderContainer.decode([BackupAddressesInfo?]?.self, forKey: .backupAddressList)
        }
        if decoderContainer.contains(.requestHeaders)
        {
            self.requestHeaders = try decoderContainer.decode([HttpHeader?]?.self, forKey: .requestHeaders)
        }
        if decoderContainer.contains(.responseBodyMatch)
        {
            self.responseBodyMatch = try decoderContainer.decode(String?.self, forKey: .responseBodyMatch)
        }
        if decoderContainer.contains(.responseCodeRanges)
        {
            self.responseCodeRanges = try decoderContainer.decode([HttpResponseCodeRange?]?.self, forKey: .responseCodeRanges)
        }
        if decoderContainer.contains(.effectAddr)
        {
            self.effectAddr = try decoderContainer.decode(String?.self, forKey: .effectAddr)
        }
    }
}
public extension Monitor{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: MonitorCodingKeys.self)
         try encoderContainer.encode(alarmLimit, forKey: .alarmLimit)
         try encoderContainer.encode(canRecover, forKey: .canRecover)
         try encoderContainer.encode(canSwitch, forKey: .canSwitch)
         try encoderContainer.encode(clusters, forKey: .clusters)
         try encoderContainer.encode(domainName, forKey: .domainName)
         try encoderContainer.encode(hostStatus, forKey: .hostStatus)
         try encoderContainer.encode(hostValue, forKey: .hostValue)
         try encoderContainer.encode(id, forKey: .id)
         try encoderContainer.encode(ipBackup01, forKey: .ipBackup01)
         try encoderContainer.encode(ipBackup01Status, forKey: .ipBackup01Status)
         try encoderContainer.encode(ipBackup01Type, forKey: .ipBackup01Type)
         try encoderContainer.encode(ipBackup02, forKey: .ipBackup02)
         try encoderContainer.encode(ipBackup02Status, forKey: .ipBackup02Status)
         try encoderContainer.encode(ipBackup02Type, forKey: .ipBackup02Type)
         try encoderContainer.encode(manualBackup, forKey: .manualBackup)
         try encoderContainer.encode(manualBackupStatus, forKey: .manualBackupStatus)
         try encoderContainer.encode(manualBackupType, forKey: .manualBackupType)
         try encoderContainer.encode(monitorEnable, forKey: .monitorEnable)
         try encoderContainer.encode(monitorFreq, forKey: .monitorFreq)
         try encoderContainer.encode(monitorPort, forKey: .monitorPort)
         try encoderContainer.encode(monitorRule, forKey: .monitorRule)
         try encoderContainer.encode(monitorUri, forKey: .monitorUri)
         try encoderContainer.encode(notifyEmail, forKey: .notifyEmail)
         try encoderContainer.encode(notifyEmailEnable, forKey: .notifyEmailEnable)
         try encoderContainer.encode(notifyMsgBarEnable, forKey: .notifyMsgBarEnable)
         try encoderContainer.encode(notifySms, forKey: .notifySms)
         try encoderContainer.encode(notifySmsEnable, forKey: .notifySmsEnable)
         try encoderContainer.encode(protocolValue, forKey: .protocolValue)
         try encoderContainer.encode(stopRecoverRule, forKey: .stopRecoverRule)
         try encoderContainer.encode(subDomainName, forKey: .subDomainName)
         try encoderContainer.encode(switchRecoverRule, forKey: .switchRecoverRule)
         try encoderContainer.encode(type, forKey: .type)
         try encoderContainer.encode(usedType, forKey: .usedType)
         try encoderContainer.encode(backupAddressList, forKey: .backupAddressList)
         try encoderContainer.encode(requestHeaders, forKey: .requestHeaders)
         try encoderContainer.encode(responseBodyMatch, forKey: .responseBodyMatch)
         try encoderContainer.encode(responseCodeRanges, forKey: .responseCodeRanges)
         try encoderContainer.encode(effectAddr, forKey: .effectAddr)
    }
}
///  httpResponseCodeRange
public class HttpResponseCodeRange:NSObject,Codable{
    /// 起始响应码
    /// Required:true
    var start:Int
    /// 终止响应码
    /// Required:true
    var end:Int



    public  init(start:Int,end:Int){
             self.start = start
             self.end = end
    }

    enum HttpResponseCodeRangeCodingKeys: String, CodingKey {
        case start
        case end
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: HttpResponseCodeRangeCodingKeys.self)
        self.start = try decoderContainer.decode(Int.self, forKey: .start)
        self.end = try decoderContainer.decode(Int.self, forKey: .end)
    }
}
public extension HttpResponseCodeRange{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: HttpResponseCodeRangeCodingKeys.self)
         try encoderContainer.encode(start, forKey: .start)
         try encoderContainer.encode(end, forKey: .end)
    }
}
///  a
public class A:NSObject,Codable{
    /// 返回的状态码
    var code:Int?
    /// 状态码相应的说明/错误说明
    var message:String?



    public override init(){
            super.init()
    }

    enum ACodingKeys: String, CodingKey {
        case code
        case message
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: ACodingKeys.self)
        if decoderContainer.contains(.code)
        {
            self.code = try decoderContainer.decode(Int?.self, forKey: .code)
        }
        if decoderContainer.contains(.message)
        {
            self.message = try decoderContainer.decode(String?.self, forKey: .message)
        }
    }
}
public extension A{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: ACodingKeys.self)
         try encoderContainer.encode(code, forKey: .code)
         try encoderContainer.encode(message, forKey: .message)
    }
}
///  nS
public class NS:NSObject,Codable{
    /// 京东NS服务器:0，非京东服务器:1
    var tag:Int?
    /// NS记录的值
    var server:String?



    public override init(){
            super.init()
    }

    enum NSCodingKeys: String, CodingKey {
        case tag
        case server
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: NSCodingKeys.self)
        if decoderContainer.contains(.tag)
        {
            self.tag = try decoderContainer.decode(Int?.self, forKey: .tag)
        }
        if decoderContainer.contains(.server)
        {
            self.server = try decoderContainer.decode(String?.self, forKey: .server)
        }
    }
}
public extension NS{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: NSCodingKeys.self)
         try encoderContainer.encode(tag, forKey: .tag)
         try encoderContainer.encode(server, forKey: .server)
    }
}
///  result
public class Result:NSObject,Codable{
    /// 返回的状态码
    var code:Int?
    /// 状态码相应的说明/错误说明
    var detail:String?



    public override init(){
            super.init()
    }

    enum ResultCodingKeys: String, CodingKey {
        case code
        case detail
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: ResultCodingKeys.self)
        if decoderContainer.contains(.code)
        {
            self.code = try decoderContainer.decode(Int?.self, forKey: .code)
        }
        if decoderContainer.contains(.detail)
        {
            self.detail = try decoderContainer.decode(String?.self, forKey: .detail)
        }
    }
}
public extension Result{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: ResultCodingKeys.self)
         try encoderContainer.encode(code, forKey: .code)
         try encoderContainer.encode(detail, forKey: .detail)
    }
}
///  subDomainExist
public class SubDomainExist:NSObject,Codable{
    /// 子域名
    var domain:String?
    /// 子域名的存在状态，1：存在，2：不存在，3：zone不存在
    var isExist:Int?



    public override init(){
            super.init()
    }

    enum SubDomainExistCodingKeys: String, CodingKey {
        case domain
        case isExist
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: SubDomainExistCodingKeys.self)
        if decoderContainer.contains(.domain)
        {
            self.domain = try decoderContainer.decode(String?.self, forKey: .domain)
        }
        if decoderContainer.contains(.isExist)
        {
            self.isExist = try decoderContainer.decode(Int?.self, forKey: .isExist)
        }
    }
}
public extension SubDomainExist{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: SubDomainExistCodingKeys.self)
         try encoderContainer.encode(domain, forKey: .domain)
         try encoderContainer.encode(isExist, forKey: .isExist)
    }
}
///  setRecords
public class SetRecords:NSObject,Codable{
    /// 解析记录的值
    /// Required:true
    var records:[String?]?
    /// 解析记录所在的解析线路，请调用describeViewTree接口获取。如果不传是默认线路。
    var views:[String?]?
    /// 解析记录的类型，支持A, AAAA, CNAME类型
    /// Required:true
    var type:String



    public  init(records:[String?]?,type:String){
             self.records = records
             self.type = type
    }

    enum SetRecordsCodingKeys: String, CodingKey {
        case records
        case views
        case type
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: SetRecordsCodingKeys.self)
        self.records = try decoderContainer.decode([String?]?.self, forKey: .records)
        if decoderContainer.contains(.views)
        {
            self.views = try decoderContainer.decode([String?]?.self, forKey: .views)
        }
        self.type = try decoderContainer.decode(String.self, forKey: .type)
    }
}
public extension SetRecords{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: SetRecordsCodingKeys.self)
         try encoderContainer.encode(records, forKey: .records)
         try encoderContainer.encode(views, forKey: .views)
         try encoderContainer.encode(type, forKey: .type)
    }
}
///  rRInfo
public class RRInfo:NSObject,Codable{
    /// 创建者
    var creator:String?
    /// 线路名称
    var viewName:String?
    /// 域名解析的唯一ID
    var id:Int?
    /// 主机记录
    var hostRecord:String?
    /// 解析记录的值
    var hostValue:String?
    /// 是否是京东云资源
    var jcloudRes:Bool?
    /// 优先级，只存在于MX, SRV解析记录类型
    var mxPriority:Int?
    /// 端口，只存在于SRV解析记录类型
    var port:Int?
    /// 解析记录的生存时间，单位：秒
    var ttl:Int?
    /// 解析记录的类型，请参考&lt;a href&#x3D;&quot;https://docs.jdcloud.com/cn/jd-cloud-dns/detailed-interpretation-of-parsed-records&quot;&gt;解析记录类型详解&lt;/a&gt;
    var type:String?
    /// 解析记录的权重
    var weight:Int?
    /// 解析线路的ID
    var viewValue:[Int?]?
    /// 解析记录的状态，正常解析:2，暂停解析:4
    var resolvingStatus:String?
    /// 解析记录更新的时间
    var updateTime:Int64?



    public override init(){
            super.init()
    }

    enum RRInfoCodingKeys: String, CodingKey {
        case creator
        case viewName
        case id
        case hostRecord
        case hostValue
        case jcloudRes
        case mxPriority
        case port
        case ttl
        case type
        case weight
        case viewValue
        case resolvingStatus
        case updateTime
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: RRInfoCodingKeys.self)
        if decoderContainer.contains(.creator)
        {
            self.creator = try decoderContainer.decode(String?.self, forKey: .creator)
        }
        if decoderContainer.contains(.viewName)
        {
            self.viewName = try decoderContainer.decode(String?.self, forKey: .viewName)
        }
        if decoderContainer.contains(.id)
        {
            self.id = try decoderContainer.decode(Int?.self, forKey: .id)
        }
        if decoderContainer.contains(.hostRecord)
        {
            self.hostRecord = try decoderContainer.decode(String?.self, forKey: .hostRecord)
        }
        if decoderContainer.contains(.hostValue)
        {
            self.hostValue = try decoderContainer.decode(String?.self, forKey: .hostValue)
        }
        if decoderContainer.contains(.jcloudRes)
        {
            self.jcloudRes = try decoderContainer.decode(Bool?.self, forKey: .jcloudRes)
        }
        if decoderContainer.contains(.mxPriority)
        {
            self.mxPriority = try decoderContainer.decode(Int?.self, forKey: .mxPriority)
        }
        if decoderContainer.contains(.port)
        {
            self.port = try decoderContainer.decode(Int?.self, forKey: .port)
        }
        if decoderContainer.contains(.ttl)
        {
            self.ttl = try decoderContainer.decode(Int?.self, forKey: .ttl)
        }
        if decoderContainer.contains(.type)
        {
            self.type = try decoderContainer.decode(String?.self, forKey: .type)
        }
        if decoderContainer.contains(.weight)
        {
            self.weight = try decoderContainer.decode(Int?.self, forKey: .weight)
        }
        if decoderContainer.contains(.viewValue)
        {
            self.viewValue = try decoderContainer.decode([Int?]?.self, forKey: .viewValue)
        }
        if decoderContainer.contains(.resolvingStatus)
        {
            self.resolvingStatus = try decoderContainer.decode(String?.self, forKey: .resolvingStatus)
        }
        if decoderContainer.contains(.updateTime)
        {
            self.updateTime = try decoderContainer.decode(Int64?.self, forKey: .updateTime)
        }
    }
}
public extension RRInfo{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: RRInfoCodingKeys.self)
         try encoderContainer.encode(creator, forKey: .creator)
         try encoderContainer.encode(viewName, forKey: .viewName)
         try encoderContainer.encode(id, forKey: .id)
         try encoderContainer.encode(hostRecord, forKey: .hostRecord)
         try encoderContainer.encode(hostValue, forKey: .hostValue)
         try encoderContainer.encode(jcloudRes, forKey: .jcloudRes)
         try encoderContainer.encode(mxPriority, forKey: .mxPriority)
         try encoderContainer.encode(port, forKey: .port)
         try encoderContainer.encode(ttl, forKey: .ttl)
         try encoderContainer.encode(type, forKey: .type)
         try encoderContainer.encode(weight, forKey: .weight)
         try encoderContainer.encode(viewValue, forKey: .viewValue)
         try encoderContainer.encode(resolvingStatus, forKey: .resolvingStatus)
         try encoderContainer.encode(updateTime, forKey: .updateTime)
    }
}
///  setlb
public class Setlb:NSObject,Codable{
    /// 解析记录的ID。在getLB接口中获取。
    /// Required:true
    var id:Int
    /// 此条解析记录的权重。A,AAAA类型的权重范围为：0-100，CNAME, JNAME类型的权重范围为：1-100。
    /// Required:true
    var weight:Int



    public  init(id:Int,weight:Int){
             self.id = id
             self.weight = weight
    }

    enum SetlbCodingKeys: String, CodingKey {
        case id
        case weight
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: SetlbCodingKeys.self)
        self.id = try decoderContainer.decode(Int.self, forKey: .id)
        self.weight = try decoderContainer.decode(Int.self, forKey: .weight)
    }
}
public extension Setlb{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: SetlbCodingKeys.self)
         try encoderContainer.encode(id, forKey: .id)
         try encoderContainer.encode(weight, forKey: .weight)
    }
}
///  records
public class Records:NSObject,Codable{
    /// 解析记录值
    /// Required:true
    var record:String
    /// 权重，A/AAAA权重范围：0-100、CNAME/JNAME权重范围：1-100。
    var weight:Int?
    /// 这条解析记录的TTL
    var ttl:Int?
    /// 优先级，只存在于MX类型的解析记录
    var prior:Int?
    /// 端口，只存在于SRV类型解析记录
    var port:Int?



    public  init(record:String){
             self.record = record
    }

    enum RecordsCodingKeys: String, CodingKey {
        case record
        case weight
        case ttl
        case prior
        case port
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: RecordsCodingKeys.self)
        self.record = try decoderContainer.decode(String.self, forKey: .record)
        if decoderContainer.contains(.weight)
        {
            self.weight = try decoderContainer.decode(Int?.self, forKey: .weight)
        }
        if decoderContainer.contains(.ttl)
        {
            self.ttl = try decoderContainer.decode(Int?.self, forKey: .ttl)
        }
        if decoderContainer.contains(.prior)
        {
            self.prior = try decoderContainer.decode(Int?.self, forKey: .prior)
        }
        if decoderContainer.contains(.port)
        {
            self.port = try decoderContainer.decode(Int?.self, forKey: .port)
        }
    }
}
public extension Records{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: RecordsCodingKeys.self)
         try encoderContainer.encode(record, forKey: .record)
         try encoderContainer.encode(weight, forKey: .weight)
         try encoderContainer.encode(ttl, forKey: .ttl)
         try encoderContainer.encode(prior, forKey: .prior)
         try encoderContainer.encode(port, forKey: .port)
    }
}
///  batchSetDNS
public class BatchSetDNS:NSObject,Codable{
    /// 主机记录
    /// Required:true
    var hostRecord:String
    /// 解析记录的值
    /// Required:true
    var hostValue:String
    /// 解析记录的ID, 如果是新增请填0，如果是更新，请使用describeResourceRecord接口查询解析记录ID。
    /// Required:true
    var id:Int
    /// 是否是京东云资源
    var jcloudRes:Bool?
    /// 优先级，只存在于MX, SRV解析记录类型
    var mxPriority:Int?
    /// 端口，只存在于SRV解析记录类型
    var port:Int?
    /// 解析记录的生存时间，单位：秒
    /// Required:true
    var ttl:Int
    /// 解析的类型，请参考&lt;a href&#x3D;&quot;https://docs.jdcloud.com/cn/jd-cloud-dns/detailed-interpretation-of-parsed-records&quot;&gt;解析记录类型详解&lt;/a&gt;
    /// Required:true
    var type:String
    /// 解析记录的权重，目前支持权重的有：A/AAAA/CNAME/JNAME，A/AAAA权重范围：0-100、CNAME/JNAME权重范围：1-100。
    var weight:Int?
    /// 解析线路的ID，请调用describeViewTree接口获取基础解析线路的ID，使用describeUserView接口获取自定义线路的ID。
    /// Required:true
    var viewValue:Int



    public  init(hostRecord:String,hostValue:String,id:Int,ttl:Int,type:String,viewValue:Int){
             self.hostRecord = hostRecord
             self.hostValue = hostValue
             self.id = id
             self.ttl = ttl
             self.type = type
             self.viewValue = viewValue
    }

    enum BatchSetDNSCodingKeys: String, CodingKey {
        case hostRecord
        case hostValue
        case id
        case jcloudRes
        case mxPriority
        case port
        case ttl
        case type
        case weight
        case viewValue
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: BatchSetDNSCodingKeys.self)
        self.hostRecord = try decoderContainer.decode(String.self, forKey: .hostRecord)
        self.hostValue = try decoderContainer.decode(String.self, forKey: .hostValue)
        self.id = try decoderContainer.decode(Int.self, forKey: .id)
        if decoderContainer.contains(.jcloudRes)
        {
            self.jcloudRes = try decoderContainer.decode(Bool?.self, forKey: .jcloudRes)
        }
        if decoderContainer.contains(.mxPriority)
        {
            self.mxPriority = try decoderContainer.decode(Int?.self, forKey: .mxPriority)
        }
        if decoderContainer.contains(.port)
        {
            self.port = try decoderContainer.decode(Int?.self, forKey: .port)
        }
        self.ttl = try decoderContainer.decode(Int.self, forKey: .ttl)
        self.type = try decoderContainer.decode(String.self, forKey: .type)
        if decoderContainer.contains(.weight)
        {
            self.weight = try decoderContainer.decode(Int?.self, forKey: .weight)
        }
        self.viewValue = try decoderContainer.decode(Int.self, forKey: .viewValue)
    }
}
public extension BatchSetDNS{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: BatchSetDNSCodingKeys.self)
         try encoderContainer.encode(hostRecord, forKey: .hostRecord)
         try encoderContainer.encode(hostValue, forKey: .hostValue)
         try encoderContainer.encode(id, forKey: .id)
         try encoderContainer.encode(jcloudRes, forKey: .jcloudRes)
         try encoderContainer.encode(mxPriority, forKey: .mxPriority)
         try encoderContainer.encode(port, forKey: .port)
         try encoderContainer.encode(ttl, forKey: .ttl)
         try encoderContainer.encode(type, forKey: .type)
         try encoderContainer.encode(weight, forKey: .weight)
         try encoderContainer.encode(viewValue, forKey: .viewValue)
    }
}
///  importDNS
public class ImportDNS:NSObject,Codable{
    /// 主机记录
    /// Required:true
    var hostRecord:String
    /// 解析记录的值
    /// Required:true
    var hostValue:String
    /// 解析记录的ID
    var id:Int?
    /// 是否是京东云资源
    var jcloudRes:Bool?
    /// 优先级，只存在于MX, SRV解析记录类型
    var mxPriority:Int?
    /// 端口，只存在于SRV解析记录类型
    var port:Int?
    /// 解析记录的生存时间，单位：秒
    /// Required:true
    var ttl:Int
    /// 解析的类型，请参考&lt;a href&#x3D;&quot;https://docs.jdcloud.com/cn/jd-cloud-dns/detailed-interpretation-of-parsed-records&quot;&gt;解析记录类型详解&lt;/a&gt;
    /// Required:true
    var type:String
    /// 解析记录的权重，目前支持权重的有：A/AAAA/CNAME/JNAME，A/AAAA权重范围：0-100、CNAME/JNAME权重范围：1-100。
    var weight:Int?
    /// 解析线路的ID，请调用describeViewTree接口获取基础解析线路的ID，使用describeUserView接口获取自定义线路的ID。
    /// Required:true
    var viewValue:Int



    public  init(hostRecord:String,hostValue:String,ttl:Int,type:String,viewValue:Int){
             self.hostRecord = hostRecord
             self.hostValue = hostValue
             self.ttl = ttl
             self.type = type
             self.viewValue = viewValue
    }

    enum ImportDNSCodingKeys: String, CodingKey {
        case hostRecord
        case hostValue
        case id
        case jcloudRes
        case mxPriority
        case port
        case ttl
        case type
        case weight
        case viewValue
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: ImportDNSCodingKeys.self)
        self.hostRecord = try decoderContainer.decode(String.self, forKey: .hostRecord)
        self.hostValue = try decoderContainer.decode(String.self, forKey: .hostValue)
        if decoderContainer.contains(.id)
        {
            self.id = try decoderContainer.decode(Int?.self, forKey: .id)
        }
        if decoderContainer.contains(.jcloudRes)
        {
            self.jcloudRes = try decoderContainer.decode(Bool?.self, forKey: .jcloudRes)
        }
        if decoderContainer.contains(.mxPriority)
        {
            self.mxPriority = try decoderContainer.decode(Int?.self, forKey: .mxPriority)
        }
        if decoderContainer.contains(.port)
        {
            self.port = try decoderContainer.decode(Int?.self, forKey: .port)
        }
        self.ttl = try decoderContainer.decode(Int.self, forKey: .ttl)
        self.type = try decoderContainer.decode(String.self, forKey: .type)
        if decoderContainer.contains(.weight)
        {
            self.weight = try decoderContainer.decode(Int?.self, forKey: .weight)
        }
        self.viewValue = try decoderContainer.decode(Int.self, forKey: .viewValue)
    }
}
public extension ImportDNS{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: ImportDNSCodingKeys.self)
         try encoderContainer.encode(hostRecord, forKey: .hostRecord)
         try encoderContainer.encode(hostValue, forKey: .hostValue)
         try encoderContainer.encode(id, forKey: .id)
         try encoderContainer.encode(jcloudRes, forKey: .jcloudRes)
         try encoderContainer.encode(mxPriority, forKey: .mxPriority)
         try encoderContainer.encode(port, forKey: .port)
         try encoderContainer.encode(ttl, forKey: .ttl)
         try encoderContainer.encode(type, forKey: .type)
         try encoderContainer.encode(weight, forKey: .weight)
         try encoderContainer.encode(viewValue, forKey: .viewValue)
    }
}
///  getlb
public class Getlb:NSObject,Codable{
    /// 负载均衡的解析记录的列表中解析记录是否是相同的权重 
      /// true: 均等负载 
      /// false: 按权重分配负载
      /// 
    var balance:Bool?
    /// 主机记录
    var record:String?
    /// 解析的类型
    var type:String?
    /// 解析线路的名称
    var viewName:String?
    /// 解析线路的ID
    var viewValue:Int?
    /// 负载均衡的解析记录的列表
    var items:[HostRRlb?]?



    public override init(){
            super.init()
    }

    enum GetlbCodingKeys: String, CodingKey {
        case balance
        case record
        case type
        case viewName
        case viewValue
        case items
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: GetlbCodingKeys.self)
        if decoderContainer.contains(.balance)
        {
            self.balance = try decoderContainer.decode(Bool?.self, forKey: .balance)
        }
        if decoderContainer.contains(.record)
        {
            self.record = try decoderContainer.decode(String?.self, forKey: .record)
        }
        if decoderContainer.contains(.type)
        {
            self.type = try decoderContainer.decode(String?.self, forKey: .type)
        }
        if decoderContainer.contains(.viewName)
        {
            self.viewName = try decoderContainer.decode(String?.self, forKey: .viewName)
        }
        if decoderContainer.contains(.viewValue)
        {
            self.viewValue = try decoderContainer.decode(Int?.self, forKey: .viewValue)
        }
        if decoderContainer.contains(.items)
        {
            self.items = try decoderContainer.decode([HostRRlb?]?.self, forKey: .items)
        }
    }
}
public extension Getlb{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: GetlbCodingKeys.self)
         try encoderContainer.encode(balance, forKey: .balance)
         try encoderContainer.encode(record, forKey: .record)
         try encoderContainer.encode(type, forKey: .type)
         try encoderContainer.encode(viewName, forKey: .viewName)
         try encoderContainer.encode(viewValue, forKey: .viewValue)
         try encoderContainer.encode(items, forKey: .items)
    }
}
///  updateRR
public class UpdateRR:NSObject,Codable{
    /// 主域名
    /// Required:true
    var domainName:String
    /// 主机记录
    /// Required:true
    var hostRecord:String
    /// 解析记录的值
    /// Required:true
    var hostValue:String
    /// 是否是京东云资源
    var jcloudRes:Bool?
    /// 优先级，只存在于MX, SRV解析记录类型
    var mxPriority:Int?
    /// 端口，只存在于SRV解析记录类型
    var port:Int?
    /// 解析记录的生存时间，单位：秒
    /// Required:true
    var ttl:Int
    /// 解析的类型，请参考&lt;a href&#x3D;&quot;https://docs.jdcloud.com/cn/jd-cloud-dns/detailed-interpretation-of-parsed-records&quot;&gt;解析记录类型详解&lt;/a&gt;
    /// Required:true
    var type:String
    /// 解析记录的权重，目前支持权重的有：A/AAAA/CNAME/JNAME，A/AAAA权重范围：0-100、CNAME/JNAME权重范围：1-100。
    var weight:Int?
    /// 解析线路的ID，请调用describeViewTree接口获取基础解析线路的ID，使用describeUserView接口获取自定义线路的ID。
    /// Required:true
    var viewValue:Int



    public  init(domainName:String,hostRecord:String,hostValue:String,ttl:Int,type:String,viewValue:Int){
             self.domainName = domainName
             self.hostRecord = hostRecord
             self.hostValue = hostValue
             self.ttl = ttl
             self.type = type
             self.viewValue = viewValue
    }

    enum UpdateRRCodingKeys: String, CodingKey {
        case domainName
        case hostRecord
        case hostValue
        case jcloudRes
        case mxPriority
        case port
        case ttl
        case type
        case weight
        case viewValue
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: UpdateRRCodingKeys.self)
        self.domainName = try decoderContainer.decode(String.self, forKey: .domainName)
        self.hostRecord = try decoderContainer.decode(String.self, forKey: .hostRecord)
        self.hostValue = try decoderContainer.decode(String.self, forKey: .hostValue)
        if decoderContainer.contains(.jcloudRes)
        {
            self.jcloudRes = try decoderContainer.decode(Bool?.self, forKey: .jcloudRes)
        }
        if decoderContainer.contains(.mxPriority)
        {
            self.mxPriority = try decoderContainer.decode(Int?.self, forKey: .mxPriority)
        }
        if decoderContainer.contains(.port)
        {
            self.port = try decoderContainer.decode(Int?.self, forKey: .port)
        }
        self.ttl = try decoderContainer.decode(Int.self, forKey: .ttl)
        self.type = try decoderContainer.decode(String.self, forKey: .type)
        if decoderContainer.contains(.weight)
        {
            self.weight = try decoderContainer.decode(Int?.self, forKey: .weight)
        }
        self.viewValue = try decoderContainer.decode(Int.self, forKey: .viewValue)
    }
}
public extension UpdateRR{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: UpdateRRCodingKeys.self)
         try encoderContainer.encode(domainName, forKey: .domainName)
         try encoderContainer.encode(hostRecord, forKey: .hostRecord)
         try encoderContainer.encode(hostValue, forKey: .hostValue)
         try encoderContainer.encode(jcloudRes, forKey: .jcloudRes)
         try encoderContainer.encode(mxPriority, forKey: .mxPriority)
         try encoderContainer.encode(port, forKey: .port)
         try encoderContainer.encode(ttl, forKey: .ttl)
         try encoderContainer.encode(type, forKey: .type)
         try encoderContainer.encode(weight, forKey: .weight)
         try encoderContainer.encode(viewValue, forKey: .viewValue)
    }
}
///  jdvpc
public class Jdvpc:NSObject,Codable{
    /// 京东云IP
    var ip:String?
    /// 是否绑定
    var binded:Bool?



    public override init(){
            super.init()
    }

    enum JdvpcCodingKeys: String, CodingKey {
        case ip
        case binded
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: JdvpcCodingKeys.self)
        if decoderContainer.contains(.ip)
        {
            self.ip = try decoderContainer.decode(String?.self, forKey: .ip)
        }
        if decoderContainer.contains(.binded)
        {
            self.binded = try decoderContainer.decode(Bool?.self, forKey: .binded)
        }
    }
}
public extension Jdvpc{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: JdvpcCodingKeys.self)
         try encoderContainer.encode(ip, forKey: .ip)
         try encoderContainer.encode(binded, forKey: .binded)
    }
}
///  setRR
public class SetRR:NSObject,Codable{
    /// 子域名
    /// Required:true
    var domain:String
    /// 要设置的解析记录数组
    /// Required:true
    var data:[SetRecords?]?



    public  init(domain:String,data:[SetRecords?]?){
             self.domain = domain
             self.data = data
    }

    enum SetRRCodingKeys: String, CodingKey {
        case domain
        case data
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: SetRRCodingKeys.self)
        self.domain = try decoderContainer.decode(String.self, forKey: .domain)
        self.data = try decoderContainer.decode([SetRecords?]?.self, forKey: .data)
    }
}
public extension SetRR{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: SetRRCodingKeys.self)
         try encoderContainer.encode(domain, forKey: .domain)
         try encoderContainer.encode(data, forKey: .data)
    }
}
///  addRR
public class AddRR:NSObject,Codable{
    /// 主机记录
    /// Required:true
    var hostRecord:String
    /// 解析记录的值
    /// Required:true
    var hostValue:String
    /// 是否是京东云资源
    var jcloudRes:Bool?
    /// 优先级，只存在于MX, SRV解析记录类型
    var mxPriority:Int?
    /// 端口，只存在于SRV解析记录类型
    var port:Int?
    /// 解析记录的生存时间，单位：秒
    /// Required:true
    var ttl:Int
    /// 解析的类型，请参考&lt;a href&#x3D;&quot;https://docs.jdcloud.com/cn/jd-cloud-dns/detailed-interpretation-of-parsed-records&quot;&gt;解析记录类型详解&lt;/a&gt;
    /// Required:true
    var type:String
    /// 解析记录的权重，目前支持权重的有：A/AAAA/CNAME/JNAME，A/AAAA权重范围：0-100、CNAME/JNAME权重范围：1-100。
    var weight:Int?
    /// 解析线路的ID，请调用describeViewTree接口获取基础解析线路的ID，使用describeUserView接口获取自定义线路的ID。
    /// Required:true
    var viewValue:Int



    public  init(hostRecord:String,hostValue:String,ttl:Int,type:String,viewValue:Int){
             self.hostRecord = hostRecord
             self.hostValue = hostValue
             self.ttl = ttl
             self.type = type
             self.viewValue = viewValue
    }

    enum AddRRCodingKeys: String, CodingKey {
        case hostRecord
        case hostValue
        case jcloudRes
        case mxPriority
        case port
        case ttl
        case type
        case weight
        case viewValue
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: AddRRCodingKeys.self)
        self.hostRecord = try decoderContainer.decode(String.self, forKey: .hostRecord)
        self.hostValue = try decoderContainer.decode(String.self, forKey: .hostValue)
        if decoderContainer.contains(.jcloudRes)
        {
            self.jcloudRes = try decoderContainer.decode(Bool?.self, forKey: .jcloudRes)
        }
        if decoderContainer.contains(.mxPriority)
        {
            self.mxPriority = try decoderContainer.decode(Int?.self, forKey: .mxPriority)
        }
        if decoderContainer.contains(.port)
        {
            self.port = try decoderContainer.decode(Int?.self, forKey: .port)
        }
        self.ttl = try decoderContainer.decode(Int.self, forKey: .ttl)
        self.type = try decoderContainer.decode(String.self, forKey: .type)
        if decoderContainer.contains(.weight)
        {
            self.weight = try decoderContainer.decode(Int?.self, forKey: .weight)
        }
        self.viewValue = try decoderContainer.decode(Int.self, forKey: .viewValue)
    }
}
public extension AddRR{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: AddRRCodingKeys.self)
         try encoderContainer.encode(hostRecord, forKey: .hostRecord)
         try encoderContainer.encode(hostValue, forKey: .hostValue)
         try encoderContainer.encode(jcloudRes, forKey: .jcloudRes)
         try encoderContainer.encode(mxPriority, forKey: .mxPriority)
         try encoderContainer.encode(port, forKey: .port)
         try encoderContainer.encode(ttl, forKey: .ttl)
         try encoderContainer.encode(type, forKey: .type)
         try encoderContainer.encode(weight, forKey: .weight)
         try encoderContainer.encode(viewValue, forKey: .viewValue)
    }
}
///  viewTree
public class ViewTree:NSObject,Codable{
    /// 此解析线路是否禁用
    var disabled:Bool?
    /// 解析线路的描述
    var label:String?
    /// 此数据是否是叶子节点
    var leaf:Bool?
    /// 解析线路ID
    var value:Int?
    /// 解析线路的名称，在使用viewName的参数处使用，如果为空表明此解析线路不能直接使用，请使用它的子线路。
    var viewName:String?
    /// Children
    var children:[ViewTree?]?



    public override init(){
            super.init()
    }

    enum ViewTreeCodingKeys: String, CodingKey {
        case disabled
        case label
        case leaf
        case value
        case viewName
        case children
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: ViewTreeCodingKeys.self)
        if decoderContainer.contains(.disabled)
        {
            self.disabled = try decoderContainer.decode(Bool?.self, forKey: .disabled)
        }
        if decoderContainer.contains(.label)
        {
            self.label = try decoderContainer.decode(String?.self, forKey: .label)
        }
        if decoderContainer.contains(.leaf)
        {
            self.leaf = try decoderContainer.decode(Bool?.self, forKey: .leaf)
        }
        if decoderContainer.contains(.value)
        {
            self.value = try decoderContainer.decode(Int?.self, forKey: .value)
        }
        if decoderContainer.contains(.viewName)
        {
            self.viewName = try decoderContainer.decode(String?.self, forKey: .viewName)
        }
        if decoderContainer.contains(.children)
        {
            self.children = try decoderContainer.decode([ViewTree?]?.self, forKey: .children)
        }
    }
}
public extension ViewTree{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: ViewTreeCodingKeys.self)
         try encoderContainer.encode(disabled, forKey: .disabled)
         try encoderContainer.encode(label, forKey: .label)
         try encoderContainer.encode(leaf, forKey: .leaf)
         try encoderContainer.encode(value, forKey: .value)
         try encoderContainer.encode(viewName, forKey: .viewName)
         try encoderContainer.encode(children, forKey: .children)
    }
}
///  rR
public class RR:NSObject,Codable{
    /// 域名解析的唯一ID
    var id:Int?
    /// 主机记录
    var hostRecord:String?
    /// 解析记录的值
    var hostValue:String?
    /// 是否是京东云资源
    var jcloudRes:Bool?
    /// 优先级，只存在于MX, SRV解析记录类型
    var mxPriority:Int?
    /// 端口，只存在于SRV解析记录类型
    var port:Int?
    /// 解析记录的生存时间，单位：秒
    var ttl:Int?
    /// 解析记录的类型，有A, AAAA, CNAME, JNAME, TXT, MX, CAA, NS, SRV, IMPLICIT_URL，EXPLICIT_URL几种记录类型
    var type:String?
    /// 解析记录的权重
    var weight:Int?
    /// 解析线路的ID
    var viewValue:[Int?]?



    public override init(){
            super.init()
    }

    enum RRCodingKeys: String, CodingKey {
        case id
        case hostRecord
        case hostValue
        case jcloudRes
        case mxPriority
        case port
        case ttl
        case type
        case weight
        case viewValue
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: RRCodingKeys.self)
        if decoderContainer.contains(.id)
        {
            self.id = try decoderContainer.decode(Int?.self, forKey: .id)
        }
        if decoderContainer.contains(.hostRecord)
        {
            self.hostRecord = try decoderContainer.decode(String?.self, forKey: .hostRecord)
        }
        if decoderContainer.contains(.hostValue)
        {
            self.hostValue = try decoderContainer.decode(String?.self, forKey: .hostValue)
        }
        if decoderContainer.contains(.jcloudRes)
        {
            self.jcloudRes = try decoderContainer.decode(Bool?.self, forKey: .jcloudRes)
        }
        if decoderContainer.contains(.mxPriority)
        {
            self.mxPriority = try decoderContainer.decode(Int?.self, forKey: .mxPriority)
        }
        if decoderContainer.contains(.port)
        {
            self.port = try decoderContainer.decode(Int?.self, forKey: .port)
        }
        if decoderContainer.contains(.ttl)
        {
            self.ttl = try decoderContainer.decode(Int?.self, forKey: .ttl)
        }
        if decoderContainer.contains(.type)
        {
            self.type = try decoderContainer.decode(String?.self, forKey: .type)
        }
        if decoderContainer.contains(.weight)
        {
            self.weight = try decoderContainer.decode(Int?.self, forKey: .weight)
        }
        if decoderContainer.contains(.viewValue)
        {
            self.viewValue = try decoderContainer.decode([Int?]?.self, forKey: .viewValue)
        }
    }
}
public extension RR{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: RRCodingKeys.self)
         try encoderContainer.encode(id, forKey: .id)
         try encoderContainer.encode(hostRecord, forKey: .hostRecord)
         try encoderContainer.encode(hostValue, forKey: .hostValue)
         try encoderContainer.encode(jcloudRes, forKey: .jcloudRes)
         try encoderContainer.encode(mxPriority, forKey: .mxPriority)
         try encoderContainer.encode(port, forKey: .port)
         try encoderContainer.encode(ttl, forKey: .ttl)
         try encoderContainer.encode(type, forKey: .type)
         try encoderContainer.encode(weight, forKey: .weight)
         try encoderContainer.encode(viewValue, forKey: .viewValue)
    }
}
///  hostRRlb
public class HostRRlb:NSObject,Codable{
    /// 解析记录的值
    var hostValue:String?
    /// 解析记录的ID
    var id:Int?
    /// 解析记录的权重
    var weight:Int?
    /// 此条记录在总均衡中的比率的100倍
    var rate:Double?



    public override init(){
            super.init()
    }

    enum HostRRlbCodingKeys: String, CodingKey {
        case hostValue
        case id
        case weight
        case rate
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: HostRRlbCodingKeys.self)
        if decoderContainer.contains(.hostValue)
        {
            self.hostValue = try decoderContainer.decode(String?.self, forKey: .hostValue)
        }
        if decoderContainer.contains(.id)
        {
            self.id = try decoderContainer.decode(Int?.self, forKey: .id)
        }
        if decoderContainer.contains(.weight)
        {
            self.weight = try decoderContainer.decode(Int?.self, forKey: .weight)
        }
        if decoderContainer.contains(.rate)
        {
            self.rate = try decoderContainer.decode(Double?.self, forKey: .rate)
        }
    }
}
public extension HostRRlb{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: HostRRlbCodingKeys.self)
         try encoderContainer.encode(hostValue, forKey: .hostValue)
         try encoderContainer.encode(id, forKey: .id)
         try encoderContainer.encode(weight, forKey: .weight)
         try encoderContainer.encode(rate, forKey: .rate)
    }
}
///  recordsReqs
public class RecordsReqs:NSObject,Codable{
    /// 解析记录的结构
    /// Required:true
    var records:[Records?]?
    /// 解析记录所在的解析线路，请调用describeViewTree接口获取。如果不传是默认线路。
    var views:[String?]?
    /// 解析记录的类型，支持A,CNAME,AAAA,JNAME
    /// Required:true
    var type:String



    public  init(records:[Records?]?,type:String){
             self.records = records
             self.type = type
    }

    enum RecordsReqsCodingKeys: String, CodingKey {
        case records
        case views
        case type
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: RecordsReqsCodingKeys.self)
        self.records = try decoderContainer.decode([Records?]?.self, forKey: .records)
        if decoderContainer.contains(.views)
        {
            self.views = try decoderContainer.decode([String?]?.self, forKey: .views)
        }
        self.type = try decoderContainer.decode(String.self, forKey: .type)
    }
}
public extension RecordsReqs{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: RecordsReqsCodingKeys.self)
         try encoderContainer.encode(records, forKey: .records)
         try encoderContainer.encode(views, forKey: .views)
         try encoderContainer.encode(type, forKey: .type)
    }
}
///  resourceRecordSetReqs
public class ResourceRecordSetReqs:NSObject,Codable{
    /// 子域名
    /// Required:true
    var domain:String
    /// 要设置的解析记录数组
    /// Required:true
    var data:[RecordsReqs?]?



    public  init(domain:String,data:[RecordsReqs?]?){
             self.domain = domain
             self.data = data
    }

    enum ResourceRecordSetReqsCodingKeys: String, CodingKey {
        case domain
        case data
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: ResourceRecordSetReqsCodingKeys.self)
        self.domain = try decoderContainer.decode(String.self, forKey: .domain)
        self.data = try decoderContainer.decode([RecordsReqs?]?.self, forKey: .data)
    }
}
public extension ResourceRecordSetReqs{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: ResourceRecordSetReqsCodingKeys.self)
         try encoderContainer.encode(domain, forKey: .domain)
         try encoderContainer.encode(data, forKey: .data)
    }
}
///  delView
public class DelView:NSObject,Codable{
    /// 主域名
    /// Required:true
    var domainName:String
    /// 自定义线路名称, 最多64个字节，允许：数字、字母、下划线，-，中文
    /// Required:true
    var viewName:String
    /// 自定义线路ID
    /// Required:true
    var viewId:Int



    public  init(domainName:String,viewName:String,viewId:Int){
             self.domainName = domainName
             self.viewName = viewName
             self.viewId = viewId
    }

    enum DelViewCodingKeys: String, CodingKey {
        case domainName
        case viewName
        case viewId
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: DelViewCodingKeys.self)
        self.domainName = try decoderContainer.decode(String.self, forKey: .domainName)
        self.viewName = try decoderContainer.decode(String.self, forKey: .viewName)
        self.viewId = try decoderContainer.decode(Int.self, forKey: .viewId)
    }
}
public extension DelView{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: DelViewCodingKeys.self)
         try encoderContainer.encode(domainName, forKey: .domainName)
         try encoderContainer.encode(viewName, forKey: .viewName)
         try encoderContainer.encode(viewId, forKey: .viewId)
    }
}
///  userViewInput
public class UserViewInput:NSObject,Codable{
    /// 自定义线路ID
    var viewId:Int?
    /// 自定义线路名称, 最多64个字节，允许：数字、字母、下划线，-，中文
    var viewName:String?
    /// 主域名ID
    var domainId:Int?
    /// 用户输入的IP段，IPV4支持1.1.1.1-2.2.2.2和CIDR格式，IPV6仅支持CIDR格式
    var ipRanges:[String?]?
    /// 是否删除，0:没有删除，1:已删除
    var isDelete:Int?
    /// 创建者
    var creator:String?
    /// 创建时间，格式Unix timestamp，时间单位：秒
    var createTime:Int?
    /// 更新者
    var updator:String?
    /// 更新时间，格式Unix timestamp，时间单位：秒
    var updateTime:Int?



    public override init(){
            super.init()
    }

    enum UserViewInputCodingKeys: String, CodingKey {
        case viewId
        case viewName
        case domainId
        case ipRanges
        case isDelete
        case creator
        case createTime
        case updator
        case updateTime
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: UserViewInputCodingKeys.self)
        if decoderContainer.contains(.viewId)
        {
            self.viewId = try decoderContainer.decode(Int?.self, forKey: .viewId)
        }
        if decoderContainer.contains(.viewName)
        {
            self.viewName = try decoderContainer.decode(String?.self, forKey: .viewName)
        }
        if decoderContainer.contains(.domainId)
        {
            self.domainId = try decoderContainer.decode(Int?.self, forKey: .domainId)
        }
        if decoderContainer.contains(.ipRanges)
        {
            self.ipRanges = try decoderContainer.decode([String?]?.self, forKey: .ipRanges)
        }
        if decoderContainer.contains(.isDelete)
        {
            self.isDelete = try decoderContainer.decode(Int?.self, forKey: .isDelete)
        }
        if decoderContainer.contains(.creator)
        {
            self.creator = try decoderContainer.decode(String?.self, forKey: .creator)
        }
        if decoderContainer.contains(.createTime)
        {
            self.createTime = try decoderContainer.decode(Int?.self, forKey: .createTime)
        }
        if decoderContainer.contains(.updator)
        {
            self.updator = try decoderContainer.decode(String?.self, forKey: .updator)
        }
        if decoderContainer.contains(.updateTime)
        {
            self.updateTime = try decoderContainer.decode(Int?.self, forKey: .updateTime)
        }
    }
}
public extension UserViewInput{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: UserViewInputCodingKeys.self)
         try encoderContainer.encode(viewId, forKey: .viewId)
         try encoderContainer.encode(viewName, forKey: .viewName)
         try encoderContainer.encode(domainId, forKey: .domainId)
         try encoderContainer.encode(ipRanges, forKey: .ipRanges)
         try encoderContainer.encode(isDelete, forKey: .isDelete)
         try encoderContainer.encode(creator, forKey: .creator)
         try encoderContainer.encode(createTime, forKey: .createTime)
         try encoderContainer.encode(updator, forKey: .updator)
         try encoderContainer.encode(updateTime, forKey: .updateTime)
    }
}
///  addViewIP
public class AddViewIP:NSObject,Codable{
    /// 自定义线路ID
    /// Required:true
    var viewId:Int
    /// 自定义线路名称, 最多64个字节，允许：数字、字母、下划线，-，中文
    /// Required:true
    var viewName:String
    /// 此线路需要添加的ip段。  
      /// IPv4地址段支持1.2.3.4-5.6.7.8和1.2.3.4/16两种格式。    
      /// IPv6地址段支持CIDR格式，例如：11:22:33:44:55::99/64
      /// 
    /// Required:true
    var ipRanges:[String?]?



    public  init(viewId:Int,viewName:String,ipRanges:[String?]?){
             self.viewId = viewId
             self.viewName = viewName
             self.ipRanges = ipRanges
    }

    enum AddViewIPCodingKeys: String, CodingKey {
        case viewId
        case viewName
        case ipRanges
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: AddViewIPCodingKeys.self)
        self.viewId = try decoderContainer.decode(Int.self, forKey: .viewId)
        self.viewName = try decoderContainer.decode(String.self, forKey: .viewName)
        self.ipRanges = try decoderContainer.decode([String?]?.self, forKey: .ipRanges)
    }
}
public extension AddViewIP{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: AddViewIPCodingKeys.self)
         try encoderContainer.encode(viewId, forKey: .viewId)
         try encoderContainer.encode(viewName, forKey: .viewName)
         try encoderContainer.encode(ipRanges, forKey: .ipRanges)
    }
}
///  delViewIP
public class DelViewIP:NSObject,Codable{
    /// 自定义线路ID
    /// Required:true
    var viewId:Int
    /// 自定义线路名称, 最多64个字节，允许：数字、字母、下划线，-，中文
    /// Required:true
    var viewName:String
    /// 此线路需要删除的ip段。  
      /// IPv4地址段支持1.2.3.4-5.6.7.8和1.2.3.4/16两种格式。    
      /// IPv6地址段支持CIDR格式，例如：11:22:33:44:55::99/64
      /// 
    /// Required:true
    var ipRanges:[String?]?



    public  init(viewId:Int,viewName:String,ipRanges:[String?]?){
             self.viewId = viewId
             self.viewName = viewName
             self.ipRanges = ipRanges
    }

    enum DelViewIPCodingKeys: String, CodingKey {
        case viewId
        case viewName
        case ipRanges
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: DelViewIPCodingKeys.self)
        self.viewId = try decoderContainer.decode(Int.self, forKey: .viewId)
        self.viewName = try decoderContainer.decode(String.self, forKey: .viewName)
        self.ipRanges = try decoderContainer.decode([String?]?.self, forKey: .ipRanges)
    }
}
public extension DelViewIP{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: DelViewIPCodingKeys.self)
         try encoderContainer.encode(viewId, forKey: .viewId)
         try encoderContainer.encode(viewName, forKey: .viewName)
         try encoderContainer.encode(ipRanges, forKey: .ipRanges)
    }
}
///  addView
public class AddView:NSObject,Codable{
    /// 主域名
    /// Required:true
    var domainName:String
    /// 自定义线路名称, 最多64个字节，允许：数字、字母、下划线，-，中文
    /// Required:true
    var viewName:String
    /// 用户输入的此线路的ip段。  
      /// IPv4地址段支持1.2.3.4-5.6.7.8和1.2.3.4/16两种格式。    
      /// IPv6地址段支持CIDR格式，例如：11:22:33:44:55::99/64
      /// 
    /// Required:true
    var ipRanges:[String?]?



    public  init(domainName:String,viewName:String,ipRanges:[String?]?){
             self.domainName = domainName
             self.viewName = viewName
             self.ipRanges = ipRanges
    }

    enum AddViewCodingKeys: String, CodingKey {
        case domainName
        case viewName
        case ipRanges
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: AddViewCodingKeys.self)
        self.domainName = try decoderContainer.decode(String.self, forKey: .domainName)
        self.viewName = try decoderContainer.decode(String.self, forKey: .viewName)
        self.ipRanges = try decoderContainer.decode([String?]?.self, forKey: .ipRanges)
    }
}
public extension AddView{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: AddViewCodingKeys.self)
         try encoderContainer.encode(domainName, forKey: .domainName)
         try encoderContainer.encode(viewName, forKey: .viewName)
         try encoderContainer.encode(ipRanges, forKey: .ipRanges)
    }
}
///  userview
public class Userview:NSObject,Codable{
    /// 自定义线路ID
    var viewId:Int?
    /// 自定义线路名称, 最多64个字节，允许：数字、字母、下划线，-，中文
    var viewName:String?
    /// 主域名ID
    var domainId:Int?
    /// 域名
    var domainName:String?
    /// 是否删除，0:没有删除，1:已删除
    var isDelete:Int?
    /// 创建者
    var creator:String?
    /// 创建时间，格式Unix timestamp，时间单位：秒
    var createTime:Int?
    /// 更新者
    var updator:String?
    /// 更新时间，格式Unix timestamp，时间单位：秒
    var updateTime:Int?



    public override init(){
            super.init()
    }

    enum UserviewCodingKeys: String, CodingKey {
        case viewId
        case viewName
        case domainId
        case domainName
        case isDelete
        case creator
        case createTime
        case updator
        case updateTime
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: UserviewCodingKeys.self)
        if decoderContainer.contains(.viewId)
        {
            self.viewId = try decoderContainer.decode(Int?.self, forKey: .viewId)
        }
        if decoderContainer.contains(.viewName)
        {
            self.viewName = try decoderContainer.decode(String?.self, forKey: .viewName)
        }
        if decoderContainer.contains(.domainId)
        {
            self.domainId = try decoderContainer.decode(Int?.self, forKey: .domainId)
        }
        if decoderContainer.contains(.domainName)
        {
            self.domainName = try decoderContainer.decode(String?.self, forKey: .domainName)
        }
        if decoderContainer.contains(.isDelete)
        {
            self.isDelete = try decoderContainer.decode(Int?.self, forKey: .isDelete)
        }
        if decoderContainer.contains(.creator)
        {
            self.creator = try decoderContainer.decode(String?.self, forKey: .creator)
        }
        if decoderContainer.contains(.createTime)
        {
            self.createTime = try decoderContainer.decode(Int?.self, forKey: .createTime)
        }
        if decoderContainer.contains(.updator)
        {
            self.updator = try decoderContainer.decode(String?.self, forKey: .updator)
        }
        if decoderContainer.contains(.updateTime)
        {
            self.updateTime = try decoderContainer.decode(Int?.self, forKey: .updateTime)
        }
    }
}
public extension Userview{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: UserviewCodingKeys.self)
         try encoderContainer.encode(viewId, forKey: .viewId)
         try encoderContainer.encode(viewName, forKey: .viewName)
         try encoderContainer.encode(domainId, forKey: .domainId)
         try encoderContainer.encode(domainName, forKey: .domainName)
         try encoderContainer.encode(isDelete, forKey: .isDelete)
         try encoderContainer.encode(creator, forKey: .creator)
         try encoderContainer.encode(createTime, forKey: .createTime)
         try encoderContainer.encode(updator, forKey: .updator)
         try encoderContainer.encode(updateTime, forKey: .updateTime)
    }
}
///  resourceInfo
public class ResourceInfo:NSObject,Codable{
    /// 实例id
    var resourceId:String?
    /// 实例名称
    var resourceName:String?
    /// 额外描述信息，包括可续费时长，套餐类型
    var remark:String?



    public override init(){
            super.init()
    }

    enum ResourceInfoCodingKeys: String, CodingKey {
        case resourceId
        case resourceName
        case remark
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: ResourceInfoCodingKeys.self)
        if decoderContainer.contains(.resourceId)
        {
            self.resourceId = try decoderContainer.decode(String?.self, forKey: .resourceId)
        }
        if decoderContainer.contains(.resourceName)
        {
            self.resourceName = try decoderContainer.decode(String?.self, forKey: .resourceName)
        }
        if decoderContainer.contains(.remark)
        {
            self.remark = try decoderContainer.decode(String?.self, forKey: .remark)
        }
    }
}
public extension ResourceInfo{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: ResourceInfoCodingKeys.self)
         try encoderContainer.encode(resourceId, forKey: .resourceId)
         try encoderContainer.encode(resourceName, forKey: .resourceName)
         try encoderContainer.encode(remark, forKey: .remark)
    }
}
///  actionlog
public class Actionlog:NSObject,Codable{
    /// 操作记录的ID
    var id:Int?
    /// 用户名
    var userPin:String?
    /// 操作的域名
    var domain:String?
    /// 操作类型：1新增 2修改 3删除
    var type:Int?
    /// 操作的详细情况
    var detail:String?
    /// 操作发生的时间
    var time:Int64?
    /// 操作的结果，成功true, 失败false
    var success:Bool?
    /// 操作失败的原因
    var failReason:String?
    /// 操作者的IP
    var clientIp:String?



    public override init(){
            super.init()
    }

    enum ActionlogCodingKeys: String, CodingKey {
        case id
        case userPin
        case domain
        case type
        case detail
        case time
        case success
        case failReason
        case clientIp
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: ActionlogCodingKeys.self)
        if decoderContainer.contains(.id)
        {
            self.id = try decoderContainer.decode(Int?.self, forKey: .id)
        }
        if decoderContainer.contains(.userPin)
        {
            self.userPin = try decoderContainer.decode(String?.self, forKey: .userPin)
        }
        if decoderContainer.contains(.domain)
        {
            self.domain = try decoderContainer.decode(String?.self, forKey: .domain)
        }
        if decoderContainer.contains(.type)
        {
            self.type = try decoderContainer.decode(Int?.self, forKey: .type)
        }
        if decoderContainer.contains(.detail)
        {
            self.detail = try decoderContainer.decode(String?.self, forKey: .detail)
        }
        if decoderContainer.contains(.time)
        {
            self.time = try decoderContainer.decode(Int64?.self, forKey: .time)
        }
        if decoderContainer.contains(.success)
        {
            self.success = try decoderContainer.decode(Bool?.self, forKey: .success)
        }
        if decoderContainer.contains(.failReason)
        {
            self.failReason = try decoderContainer.decode(String?.self, forKey: .failReason)
        }
        if decoderContainer.contains(.clientIp)
        {
            self.clientIp = try decoderContainer.decode(String?.self, forKey: .clientIp)
        }
    }
}
public extension Actionlog{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: ActionlogCodingKeys.self)
         try encoderContainer.encode(id, forKey: .id)
         try encoderContainer.encode(userPin, forKey: .userPin)
         try encoderContainer.encode(domain, forKey: .domain)
         try encoderContainer.encode(type, forKey: .type)
         try encoderContainer.encode(detail, forKey: .detail)
         try encoderContainer.encode(time, forKey: .time)
         try encoderContainer.encode(success, forKey: .success)
         try encoderContainer.encode(failReason, forKey: .failReason)
         try encoderContainer.encode(clientIp, forKey: .clientIp)
    }
}
///  resourceRemarkInfo
public class ResourceRemarkInfo:NSObject,Codable{
    /// 可续费时长，单位月
    var duration:String?
    /// 套餐类型
    var packType:String?



    public override init(){
            super.init()
    }

    enum ResourceRemarkInfoCodingKeys: String, CodingKey {
        case duration
        case packType
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: ResourceRemarkInfoCodingKeys.self)
        if decoderContainer.contains(.duration)
        {
            self.duration = try decoderContainer.decode(String?.self, forKey: .duration)
        }
        if decoderContainer.contains(.packType)
        {
            self.packType = try decoderContainer.decode(String?.self, forKey: .packType)
        }
    }
}
public extension ResourceRemarkInfo{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: ResourceRemarkInfoCodingKeys.self)
         try encoderContainer.encode(duration, forKey: .duration)
         try encoderContainer.encode(packType, forKey: .packType)
    }
}

/* Copyright 2018 JDCLOUD.COM

   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at

     http:#www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.

   JDCLOUD IAS Services API
   京东云联合登陆Api

   OpenAPI spec version: v1
   Contact: 

   NOTE: This class is auto generated by the jdcloud code generator program.
 */


import Foundation
import JDCloudSDKCore


///  运营后台查询app
public class AppsRequest:JdCloudRequest
{
    /// pin
    var pin:String

    /// appName
    var appName:String

    /// clientId
    var clientId:String

    /// multiTenant
    var multiTenant:Bool

    /// state
    var state:String

    /// scope
    var scope:String

    /// startTime
    var startTime:Int64

    /// endTime
    var endTime:Int64

    /// accountType
    var accountType:String

    /// pageIndex
    var pageIndex:Int

    /// pageSize
    var pageSize:Int

    /// offset
    var offset:Int


    public init(regionId: String,pin:String,appName:String,clientId:String,multiTenant:Bool,state:String,scope:String,startTime:Int64,endTime:Int64,accountType:String,pageIndex:Int,pageSize:Int,offset:Int){
        self.pin = pin
        self.appName = appName
        self.clientId = clientId
        self.multiTenant = multiTenant
        self.state = state
        self.scope = scope
        self.startTime = startTime
        self.endTime = endTime
        self.accountType = accountType
        self.pageIndex = pageIndex
        self.pageSize = pageSize
        self.offset = offset
        super.init(regionId: regionId)
    }


    enum AppsRequestRequestCodingKeys: String, CodingKey {
        case pin
        case appName
        case clientId
        case multiTenant
        case state
        case scope
        case startTime
        case endTime
        case accountType
        case pageIndex
        case pageSize
        case offset
    }

    public override func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: AppsRequestRequestCodingKeys.self)
        try encoderContainer.encode(pin, forKey: .pin)
        try encoderContainer.encode(appName, forKey: .appName)
        try encoderContainer.encode(clientId, forKey: .clientId)
        try encoderContainer.encode(multiTenant, forKey: .multiTenant)
        try encoderContainer.encode(state, forKey: .state)
        try encoderContainer.encode(scope, forKey: .scope)
        try encoderContainer.encode(startTime, forKey: .startTime)
        try encoderContainer.encode(endTime, forKey: .endTime)
        try encoderContainer.encode(accountType, forKey: .accountType)
        try encoderContainer.encode(pageIndex, forKey: .pageIndex)
        try encoderContainer.encode(pageSize, forKey: .pageSize)
        try encoderContainer.encode(offset, forKey: .offset)

    }
}

public class AppsResponse:NSObject,Codable
{
    var requestId:String?;

    var error:ServiceError?;

    var result:AppsResult?;

    enum AppsResponseCodingKeys: String, CodingKey {
        case requestId
        case error
        case result
    }

    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: AppsResponseCodingKeys.self)
        self.requestId = try decoderContainer.decodeIfPresent(String?.self, forKey: .requestId) ?? nil
        self.error = try decoderContainer.decodeIfPresent(ServiceError?.self, forKey: .error) ?? nil
        self.result = try decoderContainer.decodeIfPresent(AppsResult?.self, forKey: .result) ?? nil
    }
}

public extension AppsResponse{
        func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: AppsResponseCodingKeys.self)
        try encoderContainer.encode(requestId, forKey: .requestId)
        try encoderContainer.encode(error, forKey: .error)
        try encoderContainer.encode(result, forKey: .result)
    }
}    
/// 运营后台获取应用详情 
public class AppDetailResult:NSObject,JdCloudResult
{
    /// 应用
    var clientId:String?

    /// 应用名
    var clientName:String?

    /// tokenEndpointAuthMethod
    var tokenEndpointAuthMethod:String?

    /// grantTypes
    var grantTypes:String?

    /// responseTypes
    var responseTypes:String?

    /// redirectUris
    var redirectUris:String?

    /// clientUri
    var clientUri:String?

    /// logoUri
    var logoUri:String?

    /// tosUri
    var tosUri:String?

    /// policyUri
    var policyUri:String?

    /// scope
    var scope:String?

    /// jwksUri
    var jwksUri:String?

    /// jwks
    var jwks:String?

    /// contacts
    var contacts:String?

    /// extension
    var extensionValue:String?

    /// accessTokenValiditySeconds
    var accessTokenValiditySeconds:Int?

    /// refreshTokenValiditySeconds
    var refreshTokenValiditySeconds:Int?

    /// multiTenant
    var multiTenant:Bool?

    /// secretUpdateTime
    var secretUpdateTime:Int64?

    /// updateTime
    var updateTime:Int64?

    /// createTime
    var createTime:Int64?

    /// account
    var account:String?

    /// userType
    var userType:String?

    /// state
    var state:String?



    public override init(){
        super.init()
    }

    enum AppDetailResultCodingKeys: String, CodingKey {
        case clientId
        case clientName
        case tokenEndpointAuthMethod
        case grantTypes
        case responseTypes
        case redirectUris
        case clientUri
        case logoUri
        case tosUri
        case policyUri
        case scope
        case jwksUri
        case jwks
        case contacts
        case extensionValue = "extension"
        case accessTokenValiditySeconds
        case refreshTokenValiditySeconds
        case multiTenant
        case secretUpdateTime
        case updateTime
        case createTime
        case account
        case userType
        case state
    }

    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: AppDetailResultCodingKeys.self)
        if decoderContainer.contains(.clientId)
        {
            self.clientId = try decoderContainer.decode(String?.self, forKey: .clientId)
        }
        if decoderContainer.contains(.clientName)
        {
            self.clientName = try decoderContainer.decode(String?.self, forKey: .clientName)
        }
        if decoderContainer.contains(.tokenEndpointAuthMethod)
        {
            self.tokenEndpointAuthMethod = try decoderContainer.decode(String?.self, forKey: .tokenEndpointAuthMethod)
        }
        if decoderContainer.contains(.grantTypes)
        {
            self.grantTypes = try decoderContainer.decode(String?.self, forKey: .grantTypes)
        }
        if decoderContainer.contains(.responseTypes)
        {
            self.responseTypes = try decoderContainer.decode(String?.self, forKey: .responseTypes)
        }
        if decoderContainer.contains(.redirectUris)
        {
            self.redirectUris = try decoderContainer.decode(String?.self, forKey: .redirectUris)
        }
        if decoderContainer.contains(.clientUri)
        {
            self.clientUri = try decoderContainer.decode(String?.self, forKey: .clientUri)
        }
        if decoderContainer.contains(.logoUri)
        {
            self.logoUri = try decoderContainer.decode(String?.self, forKey: .logoUri)
        }
        if decoderContainer.contains(.tosUri)
        {
            self.tosUri = try decoderContainer.decode(String?.self, forKey: .tosUri)
        }
        if decoderContainer.contains(.policyUri)
        {
            self.policyUri = try decoderContainer.decode(String?.self, forKey: .policyUri)
        }
        if decoderContainer.contains(.scope)
        {
            self.scope = try decoderContainer.decode(String?.self, forKey: .scope)
        }
        if decoderContainer.contains(.jwksUri)
        {
            self.jwksUri = try decoderContainer.decode(String?.self, forKey: .jwksUri)
        }
        if decoderContainer.contains(.jwks)
        {
            self.jwks = try decoderContainer.decode(String?.self, forKey: .jwks)
        }
        if decoderContainer.contains(.contacts)
        {
            self.contacts = try decoderContainer.decode(String?.self, forKey: .contacts)
        }
        if decoderContainer.contains(.extensionValue)
        {
            self.extensionValue = try decoderContainer.decode(String?.self, forKey: .extensionValue)
        }
        if decoderContainer.contains(.accessTokenValiditySeconds)
        {
            self.accessTokenValiditySeconds = try decoderContainer.decode(Int?.self, forKey: .accessTokenValiditySeconds)
        }
        if decoderContainer.contains(.refreshTokenValiditySeconds)
        {
            self.refreshTokenValiditySeconds = try decoderContainer.decode(Int?.self, forKey: .refreshTokenValiditySeconds)
        }
        if decoderContainer.contains(.multiTenant)
        {
            self.multiTenant = try decoderContainer.decode(Bool?.self, forKey: .multiTenant)
        }
        if decoderContainer.contains(.secretUpdateTime)
        {
            self.secretUpdateTime = try decoderContainer.decode(Int64?.self, forKey: .secretUpdateTime)
        }
        if decoderContainer.contains(.updateTime)
        {
            self.updateTime = try decoderContainer.decode(Int64?.self, forKey: .updateTime)
        }
        if decoderContainer.contains(.createTime)
        {
            self.createTime = try decoderContainer.decode(Int64?.self, forKey: .createTime)
        }
        if decoderContainer.contains(.account)
        {
            self.account = try decoderContainer.decode(String?.self, forKey: .account)
        }
        if decoderContainer.contains(.userType)
        {
            self.userType = try decoderContainer.decode(String?.self, forKey: .userType)
        }
        if decoderContainer.contains(.state)
        {
            self.state = try decoderContainer.decode(String?.self, forKey: .state)
        }
    }
}
public extension AppDetailResult{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: AppDetailResultCodingKeys.self)
        try encoderContainer.encode(clientId, forKey: .clientId)
        try encoderContainer.encode(clientName, forKey: .clientName)
        try encoderContainer.encode(tokenEndpointAuthMethod, forKey: .tokenEndpointAuthMethod)
        try encoderContainer.encode(grantTypes, forKey: .grantTypes)
        try encoderContainer.encode(responseTypes, forKey: .responseTypes)
        try encoderContainer.encode(redirectUris, forKey: .redirectUris)
        try encoderContainer.encode(clientUri, forKey: .clientUri)
        try encoderContainer.encode(logoUri, forKey: .logoUri)
        try encoderContainer.encode(tosUri, forKey: .tosUri)
        try encoderContainer.encode(policyUri, forKey: .policyUri)
        try encoderContainer.encode(scope, forKey: .scope)
        try encoderContainer.encode(jwksUri, forKey: .jwksUri)
        try encoderContainer.encode(jwks, forKey: .jwks)
        try encoderContainer.encode(contacts, forKey: .contacts)
        try encoderContainer.encode(extensionValue, forKey: .extensionValue)
        try encoderContainer.encode(accessTokenValiditySeconds, forKey: .accessTokenValiditySeconds)
        try encoderContainer.encode(refreshTokenValiditySeconds, forKey: .refreshTokenValiditySeconds)
        try encoderContainer.encode(multiTenant, forKey: .multiTenant)
        try encoderContainer.encode(secretUpdateTime, forKey: .secretUpdateTime)
        try encoderContainer.encode(updateTime, forKey: .updateTime)
        try encoderContainer.encode(createTime, forKey: .createTime)
        try encoderContainer.encode(account, forKey: .account)
        try encoderContainer.encode(userType, forKey: .userType)
        try encoderContainer.encode(state, forKey: .state)
    }
}

///  运营后台获取应用状态
public class StateRequest:JdCloudRequest
{
}

public class StateResponse:NSObject,Codable
{
    var requestId:String?;

    var error:ServiceError?;

    var result:StateResult?;

    enum StateResponseCodingKeys: String, CodingKey {
        case requestId
        case error
        case result
    }

    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: StateResponseCodingKeys.self)
        self.requestId = try decoderContainer.decodeIfPresent(String?.self, forKey: .requestId) ?? nil
        self.error = try decoderContainer.decodeIfPresent(ServiceError?.self, forKey: .error) ?? nil
        self.result = try decoderContainer.decodeIfPresent(StateResult?.self, forKey: .result) ?? nil
    }
}

public extension StateResponse{
        func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: StateResponseCodingKeys.self)
        try encoderContainer.encode(requestId, forKey: .requestId)
        try encoderContainer.encode(error, forKey: .error)
        try encoderContainer.encode(result, forKey: .result)
    }
}    
/// 运营后台获取应用状态 
public class StateResult:NSObject,JdCloudResult
{
    /// States
    var states:[State?]?



    public override init(){
        super.init()
    }

    enum StateResultCodingKeys: String, CodingKey {
        case states
    }

    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: StateResultCodingKeys.self)
        if decoderContainer.contains(.states)
        {
            self.states = try decoderContainer.decode([State?]?.self, forKey: .states)
        }
    }
}
public extension StateResult{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: StateResultCodingKeys.self)
        try encoderContainer.encode(states, forKey: .states)
    }
}
/// 运营后台查询app 
public class AppsResult:NSObject,JdCloudResult
{
    /// Pagination
    var pagination:Pagination?

    /// Result
    var result:[AppQueryResultItem?]?



    public override init(){
        super.init()
    }

    enum AppsResultCodingKeys: String, CodingKey {
        case pagination
        case result
    }

    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: AppsResultCodingKeys.self)
        if decoderContainer.contains(.pagination)
        {
            self.pagination = try decoderContainer.decode(Pagination?.self, forKey: .pagination)
        }
        if decoderContainer.contains(.result)
        {
            self.result = try decoderContainer.decode([AppQueryResultItem?]?.self, forKey: .result)
        }
    }
}
public extension AppsResult{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: AppsResultCodingKeys.self)
        try encoderContainer.encode(pagination, forKey: .pagination)
        try encoderContainer.encode(result, forKey: .result)
    }
}

///  运营后台获取应用详情
public class AppDetailRequest:JdCloudRequest
{
    /// ClientId
    var clientId:String


    public init(regionId: String,clientId:String){
        self.clientId = clientId
        super.init(regionId: regionId)
    }


    enum AppDetailRequestRequestCodingKeys: String, CodingKey {
        case clientId
    }

    public override func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: AppDetailRequestRequestCodingKeys.self)
        try encoderContainer.encode(clientId, forKey: .clientId)

    }
}

public class AppDetailResponse:NSObject,Codable
{
    var requestId:String?;

    var error:ServiceError?;

    var result:AppDetailResult?;

    enum AppDetailResponseCodingKeys: String, CodingKey {
        case requestId
        case error
        case result
    }

    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: AppDetailResponseCodingKeys.self)
        self.requestId = try decoderContainer.decodeIfPresent(String?.self, forKey: .requestId) ?? nil
        self.error = try decoderContainer.decodeIfPresent(ServiceError?.self, forKey: .error) ?? nil
        self.result = try decoderContainer.decodeIfPresent(AppDetailResult?.self, forKey: .result) ?? nil
    }
}

public extension AppDetailResponse{
        func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: AppDetailResponseCodingKeys.self)
        try encoderContainer.encode(requestId, forKey: .requestId)
        try encoderContainer.encode(error, forKey: .error)
        try encoderContainer.encode(result, forKey: .result)
    }
}    

///  创建应用
public class CreateAppRequest:JdCloudRequest
{
    /// 应用名
    var clientName:String?

    /// 客户端认证方式&lt;br&gt; - none：不设置客户端密码（不推荐）&lt;br&gt; - client_secret_post：客户端必须设置密码，且该密码需要在OAuth2 Token Endpoint提供于请求的body&lt;br&gt; - client_secret_basic：客户端必须设置密码，且该密码需要在OAuth2 Token Endpoint提供于请求的header&lt;br&gt; 支持以下值：&lt;br&gt; （1）none&lt;br&gt; （2）client_secret_post&lt;br&gt; （3）client_secret_basic
    var tokenEndpointAuthMethod:String?

    /// 支持的OAuth类型：&lt;br&gt; - authorization_code：OAuth2授权码模式&lt;br&gt; - implicit：OAuth2隐式授权模式&lt;br&gt; - refresh_token：启用刷新令牌 支持以下值：&lt;br&gt; （1）authorization_code&lt;br&gt; （2）authorization_code,refresh_token&lt;br&gt; （3）authorization_code,implicit&lt;br&gt; （4）authorization_code,implicit,refresh_token&lt;br&gt; （5）implicit&lt;br&gt; 注：如果grantTypes指定了refresh_token，应用将可以使用刷新令牌；如果在创建应用时未指定，则应用不能使用刷新令牌；任何时候应用都可以调用“更新应用”接口更改grantTypes设置
    var grantTypes:String?

    /// 回调地址，最多4个，多个url之间用逗号,分隔，每个url长度不超过1000，url不支持#符号
    var redirectUris:String?

    /// 应用介绍地址，url不支持#符号
    var clientUri:String?

    /// 应用logo地址，url不支持#符号
    var logoUri:String?

    /// 应用服务协议地址，url不支持#符号
    var tosUri:String?

    /// 应用隐私政策地址，url不支持#符号
    var policyUri:String?

    /// OAuth scope范围，支持的值为：&lt;br/&gt; （1）openid：用OpenID Connect协议进行身份认证&lt;br/&gt; 指定scope为openid，并在Authorization Endpoint请求该scope，京东云将返回用户的OpenID令牌；如果在创建应用时未指明该值，则应用不能请求OpenID令牌；任何时候应用都可以调用“更新应用”更改该设置
    var scope:String?

    /// JWKS地址，url不支持#符号&lt;br/&gt;jwksUri和jwks传一个即可
    var jwksUri:String?

    /// JWKS
    var jwks:String?

    /// 应用联系信息
    var contacts:String?

    /// 应用扩展信息
    var extensionValue:String?

    /// 访问令牌有效期，值的范围为 600 秒到 6x3600&#x3D;21,600 秒，即10分钟-6小时
    var accessTokenValiditySeconds:Int?

    /// 刷新令牌有效期，值的范围为 30x24x3600&#x3D;2,592,000 秒到 365x24x3600&#x3D;31,536,000 秒，即30天-365天&lt;br/&gt;&lt;br/&gt; 注：当 GrantTypes 包含 refresh_token 时，refreshTokenValiditySeconds 为必传参数
    var refreshTokenValiditySeconds:Int?

    /// 是否为多租户应用&lt;br/&gt; &quot;false&quot;：该应用仅支持当前创建应用的租户访问，其他京东云租户无法访问&lt;br/&gt;        &quot;true&quot;：该应用支持其他京东云租户访问，但当前创建应用的租户不能访问
    var multiTenant:Bool?

    /// 应用的密码，支持8-255位长度的ASCII可打印字符，建议使用足够复杂的密码策略&lt;br/&gt;&lt;br/&gt;        注：当TokenEndpointAuthMethod不等于none时，secret为必传参数；反之，当指定了secret时，TokenEndpointAuthMethod不能等于none&lt;br/&gt;京东云将不可逆加密secret，因此您无法再次从京东云查看该密码，但您可以随时通过更新应用重新设置secret
    var secret:String?

    /// 能访问应用的账号类型，支持以下值：&lt;br/&gt; （1）root：支持主账号访问，子用户无法访问&lt;br/&gt; （2）sub：子用户账号，使用主账号不能访问&lt;br/&gt;&lt;br/&gt; 注：multiTenant和userType的组合指定了应用的用户人群，典型的应用场景如：&lt;br/&gt; （1）应用向当前租户下的子用户开放（2）应用向京东云其他租户主账号开放
    var userType:String?




    enum CreateAppRequestRequestCodingKeys: String, CodingKey {
        case clientName
        case tokenEndpointAuthMethod
        case grantTypes
        case redirectUris
        case clientUri
        case logoUri
        case tosUri
        case policyUri
        case scope
        case jwksUri
        case jwks
        case contacts
        case extensionValue = "extension"
        case accessTokenValiditySeconds
        case refreshTokenValiditySeconds
        case multiTenant
        case secret
        case userType
    }

    public override func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: CreateAppRequestRequestCodingKeys.self)
        try encoderContainer.encode(clientName, forKey: .clientName)
        try encoderContainer.encode(tokenEndpointAuthMethod, forKey: .tokenEndpointAuthMethod)
        try encoderContainer.encode(grantTypes, forKey: .grantTypes)
        try encoderContainer.encode(redirectUris, forKey: .redirectUris)
        try encoderContainer.encode(clientUri, forKey: .clientUri)
        try encoderContainer.encode(logoUri, forKey: .logoUri)
        try encoderContainer.encode(tosUri, forKey: .tosUri)
        try encoderContainer.encode(policyUri, forKey: .policyUri)
        try encoderContainer.encode(scope, forKey: .scope)
        try encoderContainer.encode(jwksUri, forKey: .jwksUri)
        try encoderContainer.encode(jwks, forKey: .jwks)
        try encoderContainer.encode(contacts, forKey: .contacts)
        try encoderContainer.encode(extensionValue, forKey: .extensionValue)
        try encoderContainer.encode(accessTokenValiditySeconds, forKey: .accessTokenValiditySeconds)
        try encoderContainer.encode(refreshTokenValiditySeconds, forKey: .refreshTokenValiditySeconds)
        try encoderContainer.encode(multiTenant, forKey: .multiTenant)
        try encoderContainer.encode(secret, forKey: .secret)
        try encoderContainer.encode(userType, forKey: .userType)

    }
}


///  更新应用（只传需要变更的参数，不传的参数不会更新）
public class UpdateAppRequest:JdCloudRequest
{
    /// 应用名
    var clientName:String?

    /// 客户端认证方式：&lt;br/&gt; none：不设置客户端密码（不推荐）&lt;br/&gt; client_secret_post：客户端必须设置密码，且该密码需要在OAuth2 Token Endpoint提供于请求的body&lt;br/&gt; client_secret_basic：客户端必须设置密码，且该密码需要在OAuth2 Token Endpoint提供于请求的header&lt;br/&gt;&lt;br/&gt; 支持以下值：&lt;br/&gt; （1）none&lt;br/&gt; （2）client_secret_post&lt;br/&gt; （3）client_secret_basic
    var tokenEndpointAuthMethod:String?

    /// 支持的OAuth类型：&lt;br/&gt; authorization_code：OAuth2授权码模式&lt;br/&gt; implicit：OAuth2隐式授权模式&lt;br/&gt; refresh_token：启用刷新令牌&lt;br/&gt;&lt;br/&gt; 支持以下值：&lt;br/&gt; （1）authorization_code&lt;br/&gt; （2）authorization_code,refresh_token&lt;br/&gt; （3）authorization_code,implicit&lt;br/&gt; （4）authorization_code,implicit,refresh_token&lt;br/&gt; （5）implicit&lt;br/&gt;&lt;br/&gt;        注：如果grantTypes指定了refresh_token，应用将可以使用刷新令牌；如果在创建应用时未指定，则应用不能使用刷新令牌；任何时候应用都可以调用“更新应用”接口更改grantTypes设置
    var grantTypes:String?

    /// 回调地址，最多4个，多个url之间用逗号,分隔，每个url长度不超过1000，url不支持#符号
    var redirectUris:String?

    /// 应用介绍地址，url不支持#符号
    var clientUri:String?

    /// 应用logo地址，url不支持#符号
    var logoUri:String?

    /// 应用服务协议地址，url不支持#符号
    var tosUri:String?

    /// 应用隐私政策地址，url不支持#符号
    var policyUri:String?

    /// OAuth scope范围，支持的值为：&lt;br/&gt; （1）openid：用OpenID Connect协议进行身份认证&lt;br/&gt; 指定scope为openid，并在Authorization Endpoint请求该scope，京东云将返回用户的OpenID令牌；如果在创建应用时未指明该值，则应用不能请求OpenID令牌；任何时候应用都可以调用“更新应用”更改该设置
    var scope:String?

    /// JWKS地址，url不支持#符号&lt;br/&gt; jwksUri和jwks传一个即可
    var jwksUri:String?

    /// JWKS
    var jwks:String?

    /// 应用联系信息
    var contacts:String?

    /// 应用扩展信息
    var extensionValue:String?

    /// 访问令牌有效期，值的范围为 600 秒到 6x3600&#x3D;21,600 秒，即10分钟-6小时
    var accessTokenValiditySeconds:Int?

    /// 刷新令牌有效期，值的范围为 30x24x3600&#x3D;2,592,000 秒到 365x24x3600&#x3D;31,536,000 秒，即30天-365天&lt;br/&gt;&lt;br/&gt; 注：当 GrantTypes 包含 refresh_token 时，refreshTokenValiditySeconds 为必传参数
    var refreshTokenValiditySeconds:Int?

    /// 是否为多租户应用&lt;br/&gt; &quot;false&quot;：该应用仅支持当前创建应用的租户访问，其他京东云租户无法访问&lt;br/&gt;        &quot;true&quot;：该应用支持其他京东云租户访问，但当前创建应用的租户不能访问
    var multiTenant:Bool?

    /// 应用的密码，支持8-255位长度的ASCII可打印字符，建议使用足够复杂的密码策略&lt;br/&gt;&lt;br/&gt; 注：当TokenEndpointAuthMethod不等于none时，secret为必传参数；反之，当指定了secret时，TokenEndpointAuthMethod不能等于none&lt;br/&gt; 京东云将不可逆加密secret，因此您无法再次从京东云查看该密码，但您可以随时通过更新应用重新设置secret
    var secret:String?

    /// 能访问应用的账号类型，支持以下值：&lt;br/&gt; （1）root：支持主账号访问，子用户无法访问&lt;br/&gt; （2）sub：子用户账号，使用主账号不能访问&lt;br/&gt;&lt;br/&gt; 注：multiTenant和userType的组合指定了应用的用户人群，典型的应用场景如：&lt;br/&gt; （1）应用向当前租户下的子用户开放（2）应用向京东云其他租户主账号开放
    var userType:String?

    /// 应用ID，应用创建时由京东云分配的16位数字ID
    var clientId:String


    public init(regionId: String,clientId:String){
        self.clientId = clientId
        super.init(regionId: regionId)
    }


    enum UpdateAppRequestRequestCodingKeys: String, CodingKey {
        case clientName
        case tokenEndpointAuthMethod
        case grantTypes
        case redirectUris
        case clientUri
        case logoUri
        case tosUri
        case policyUri
        case scope
        case jwksUri
        case jwks
        case contacts
        case extensionValue = "extension"
        case accessTokenValiditySeconds
        case refreshTokenValiditySeconds
        case multiTenant
        case secret
        case userType
        case clientId
    }

    public override func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: UpdateAppRequestRequestCodingKeys.self)
        try encoderContainer.encode(clientName, forKey: .clientName)
        try encoderContainer.encode(tokenEndpointAuthMethod, forKey: .tokenEndpointAuthMethod)
        try encoderContainer.encode(grantTypes, forKey: .grantTypes)
        try encoderContainer.encode(redirectUris, forKey: .redirectUris)
        try encoderContainer.encode(clientUri, forKey: .clientUri)
        try encoderContainer.encode(logoUri, forKey: .logoUri)
        try encoderContainer.encode(tosUri, forKey: .tosUri)
        try encoderContainer.encode(policyUri, forKey: .policyUri)
        try encoderContainer.encode(scope, forKey: .scope)
        try encoderContainer.encode(jwksUri, forKey: .jwksUri)
        try encoderContainer.encode(jwks, forKey: .jwks)
        try encoderContainer.encode(contacts, forKey: .contacts)
        try encoderContainer.encode(extensionValue, forKey: .extensionValue)
        try encoderContainer.encode(accessTokenValiditySeconds, forKey: .accessTokenValiditySeconds)
        try encoderContainer.encode(refreshTokenValiditySeconds, forKey: .refreshTokenValiditySeconds)
        try encoderContainer.encode(multiTenant, forKey: .multiTenant)
        try encoderContainer.encode(secret, forKey: .secret)
        try encoderContainer.encode(userType, forKey: .userType)
        try encoderContainer.encode(clientId, forKey: .clientId)

    }
}

/// 更新应用（只传需要变更的参数，不传的参数不会更新） 
public class UpdateAppResult:NSObject,JdCloudResult
{
    /// 应用ID，由京东云分配的16位数字ID
    var clientId:String?

    /// clientName参数值
    var clientName:String?

    /// tokenEndpointAuthMethod参数值
    var tokenEndpointAuthMethod:String?

    /// grantTypes参数值
    var grantTypes:String?

    /// 当grantTypes为authorization_code时，responseTypes为code；当grantTypes为implicit时，responseTypes为token
    var responseTypes:String?

    /// redirectUris参数值
    var redirectUris:String?

    /// clientUri参数值
    var clientUri:String?

    /// logoUri参数值
    var logoUri:String?

    /// tosUri参数值
    var tosUri:String?

    /// policyUri参数值
    var policyUri:String?

    /// scope参数值
    var scope:String?

    /// jwksUri参数值
    var jwksUri:String?

    /// jwks参数值
    var jwks:String?

    /// contacts参数值
    var contacts:String?

    /// extension参数值
    var extensionValue:String?

    /// accessTokenValiditySeconds参数值
    var accessTokenValiditySeconds:Int?

    /// refreshTokenValiditySeconds参数值
    var refreshTokenValiditySeconds:Int?

    /// multiTenant参数值
    var multiTenant:Bool?

    /// secretUpdateTime参数值
    var secretUpdateTime:Int64?

    /// updateTime参数值
    var updateTime:Int64?

    /// createTime参数值
    var createTime:Int64?

    /// 创建应用的账户用户名
    var account:String?

    /// userType参数值
    var userType:String?



    public override init(){
        super.init()
    }

    enum UpdateAppResultCodingKeys: String, CodingKey {
        case clientId
        case clientName
        case tokenEndpointAuthMethod
        case grantTypes
        case responseTypes
        case redirectUris
        case clientUri
        case logoUri
        case tosUri
        case policyUri
        case scope
        case jwksUri
        case jwks
        case contacts
        case extensionValue = "extension"
        case accessTokenValiditySeconds
        case refreshTokenValiditySeconds
        case multiTenant
        case secretUpdateTime
        case updateTime
        case createTime
        case account
        case userType
    }

    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: UpdateAppResultCodingKeys.self)
        if decoderContainer.contains(.clientId)
        {
            self.clientId = try decoderContainer.decode(String?.self, forKey: .clientId)
        }
        if decoderContainer.contains(.clientName)
        {
            self.clientName = try decoderContainer.decode(String?.self, forKey: .clientName)
        }
        if decoderContainer.contains(.tokenEndpointAuthMethod)
        {
            self.tokenEndpointAuthMethod = try decoderContainer.decode(String?.self, forKey: .tokenEndpointAuthMethod)
        }
        if decoderContainer.contains(.grantTypes)
        {
            self.grantTypes = try decoderContainer.decode(String?.self, forKey: .grantTypes)
        }
        if decoderContainer.contains(.responseTypes)
        {
            self.responseTypes = try decoderContainer.decode(String?.self, forKey: .responseTypes)
        }
        if decoderContainer.contains(.redirectUris)
        {
            self.redirectUris = try decoderContainer.decode(String?.self, forKey: .redirectUris)
        }
        if decoderContainer.contains(.clientUri)
        {
            self.clientUri = try decoderContainer.decode(String?.self, forKey: .clientUri)
        }
        if decoderContainer.contains(.logoUri)
        {
            self.logoUri = try decoderContainer.decode(String?.self, forKey: .logoUri)
        }
        if decoderContainer.contains(.tosUri)
        {
            self.tosUri = try decoderContainer.decode(String?.self, forKey: .tosUri)
        }
        if decoderContainer.contains(.policyUri)
        {
            self.policyUri = try decoderContainer.decode(String?.self, forKey: .policyUri)
        }
        if decoderContainer.contains(.scope)
        {
            self.scope = try decoderContainer.decode(String?.self, forKey: .scope)
        }
        if decoderContainer.contains(.jwksUri)
        {
            self.jwksUri = try decoderContainer.decode(String?.self, forKey: .jwksUri)
        }
        if decoderContainer.contains(.jwks)
        {
            self.jwks = try decoderContainer.decode(String?.self, forKey: .jwks)
        }
        if decoderContainer.contains(.contacts)
        {
            self.contacts = try decoderContainer.decode(String?.self, forKey: .contacts)
        }
        if decoderContainer.contains(.extensionValue)
        {
            self.extensionValue = try decoderContainer.decode(String?.self, forKey: .extensionValue)
        }
        if decoderContainer.contains(.accessTokenValiditySeconds)
        {
            self.accessTokenValiditySeconds = try decoderContainer.decode(Int?.self, forKey: .accessTokenValiditySeconds)
        }
        if decoderContainer.contains(.refreshTokenValiditySeconds)
        {
            self.refreshTokenValiditySeconds = try decoderContainer.decode(Int?.self, forKey: .refreshTokenValiditySeconds)
        }
        if decoderContainer.contains(.multiTenant)
        {
            self.multiTenant = try decoderContainer.decode(Bool?.self, forKey: .multiTenant)
        }
        if decoderContainer.contains(.secretUpdateTime)
        {
            self.secretUpdateTime = try decoderContainer.decode(Int64?.self, forKey: .secretUpdateTime)
        }
        if decoderContainer.contains(.updateTime)
        {
            self.updateTime = try decoderContainer.decode(Int64?.self, forKey: .updateTime)
        }
        if decoderContainer.contains(.createTime)
        {
            self.createTime = try decoderContainer.decode(Int64?.self, forKey: .createTime)
        }
        if decoderContainer.contains(.account)
        {
            self.account = try decoderContainer.decode(String?.self, forKey: .account)
        }
        if decoderContainer.contains(.userType)
        {
            self.userType = try decoderContainer.decode(String?.self, forKey: .userType)
        }
    }
}
public extension UpdateAppResult{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: UpdateAppResultCodingKeys.self)
        try encoderContainer.encode(clientId, forKey: .clientId)
        try encoderContainer.encode(clientName, forKey: .clientName)
        try encoderContainer.encode(tokenEndpointAuthMethod, forKey: .tokenEndpointAuthMethod)
        try encoderContainer.encode(grantTypes, forKey: .grantTypes)
        try encoderContainer.encode(responseTypes, forKey: .responseTypes)
        try encoderContainer.encode(redirectUris, forKey: .redirectUris)
        try encoderContainer.encode(clientUri, forKey: .clientUri)
        try encoderContainer.encode(logoUri, forKey: .logoUri)
        try encoderContainer.encode(tosUri, forKey: .tosUri)
        try encoderContainer.encode(policyUri, forKey: .policyUri)
        try encoderContainer.encode(scope, forKey: .scope)
        try encoderContainer.encode(jwksUri, forKey: .jwksUri)
        try encoderContainer.encode(jwks, forKey: .jwks)
        try encoderContainer.encode(contacts, forKey: .contacts)
        try encoderContainer.encode(extensionValue, forKey: .extensionValue)
        try encoderContainer.encode(accessTokenValiditySeconds, forKey: .accessTokenValiditySeconds)
        try encoderContainer.encode(refreshTokenValiditySeconds, forKey: .refreshTokenValiditySeconds)
        try encoderContainer.encode(multiTenant, forKey: .multiTenant)
        try encoderContainer.encode(secretUpdateTime, forKey: .secretUpdateTime)
        try encoderContainer.encode(updateTime, forKey: .updateTime)
        try encoderContainer.encode(createTime, forKey: .createTime)
        try encoderContainer.encode(account, forKey: .account)
        try encoderContainer.encode(userType, forKey: .userType)
    }
}
public class CreateAppResponse:NSObject,Codable
{
    var requestId:String?;

    var error:ServiceError?;

    var result:CreateAppResult?;

    enum CreateAppResponseCodingKeys: String, CodingKey {
        case requestId
        case error
        case result
    }

    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: CreateAppResponseCodingKeys.self)
        self.requestId = try decoderContainer.decodeIfPresent(String?.self, forKey: .requestId) ?? nil
        self.error = try decoderContainer.decodeIfPresent(ServiceError?.self, forKey: .error) ?? nil
        self.result = try decoderContainer.decodeIfPresent(CreateAppResult?.self, forKey: .result) ?? nil
    }
}

public extension CreateAppResponse{
        func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: CreateAppResponseCodingKeys.self)
        try encoderContainer.encode(requestId, forKey: .requestId)
        try encoderContainer.encode(error, forKey: .error)
        try encoderContainer.encode(result, forKey: .result)
    }
}    
public class UpdateAppResponse:NSObject,Codable
{
    var requestId:String?;

    var error:ServiceError?;

    var result:UpdateAppResult?;

    enum UpdateAppResponseCodingKeys: String, CodingKey {
        case requestId
        case error
        case result
    }

    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: UpdateAppResponseCodingKeys.self)
        self.requestId = try decoderContainer.decodeIfPresent(String?.self, forKey: .requestId) ?? nil
        self.error = try decoderContainer.decodeIfPresent(ServiceError?.self, forKey: .error) ?? nil
        self.result = try decoderContainer.decodeIfPresent(UpdateAppResult?.self, forKey: .result) ?? nil
    }
}

public extension UpdateAppResponse{
        func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: UpdateAppResponseCodingKeys.self)
        try encoderContainer.encode(requestId, forKey: .requestId)
        try encoderContainer.encode(error, forKey: .error)
        try encoderContainer.encode(result, forKey: .result)
    }
}    

///  删除应用
public class DeleteAppRequest:JdCloudRequest
{
    /// 应用ID，应用创建时由京东云分配的16位数字ID
    var clientId:String


    public init(regionId: String,clientId:String){
        self.clientId = clientId
        super.init(regionId: regionId)
    }


    enum DeleteAppRequestRequestCodingKeys: String, CodingKey {
        case clientId
    }

    public override func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: DeleteAppRequestRequestCodingKeys.self)
        try encoderContainer.encode(clientId, forKey: .clientId)

    }
}

/// 删除应用 
public class DeleteAppResult:NSObject,JdCloudResult
{
    /// 删除结果[1:删除成功,0:删除失败]
    var count:Int?



    public override init(){
        super.init()
    }

    enum DeleteAppResultCodingKeys: String, CodingKey {
        case count
    }

    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: DeleteAppResultCodingKeys.self)
        if decoderContainer.contains(.count)
        {
            self.count = try decoderContainer.decode(Int?.self, forKey: .count)
        }
    }
}
public extension DeleteAppResult{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: DeleteAppResultCodingKeys.self)
        try encoderContainer.encode(count, forKey: .count)
    }
}
/// 获取应用 
public class GetAppResult:NSObject,JdCloudResult
{
    /// 应用ID，由京东云分配的16位数字ID
    var clientId:String?

    /// 应用名
    var clientName:String?

    /// 客户端认证方式
    var tokenEndpointAuthMethod:String?

    /// 支持的OAuth类型
    var grantTypes:String?

    /// 当grantTypes为authorization_code时，responseTypes为code；当grantTypes为implicit时，responseTypes为token
    var responseTypes:String?

    /// 回调地址
    var redirectUris:String?

    /// 应用介绍地址
    var clientUri:String?

    /// 应用logo地址
    var logoUri:String?

    /// 应用服务协议地址
    var tosUri:String?

    /// 应用隐私条款地址
    var policyUri:String?

    /// OAuth scope授权范围
    var scope:String?

    /// JWKS地址
    var jwksUri:String?

    /// JWKS
    var jwks:String?

    /// 应用联系信息
    var contacts:String?

    /// 应用扩展信息
    var extensionValue:String?

    /// 访问令牌有效期
    var accessTokenValiditySeconds:Int?

    /// 刷新令牌有效期
    var refreshTokenValiditySeconds:Int?

    /// 是否为多租户应用
    var multiTenant:Bool?

    /// 应用密码更新时间
    var secretUpdateTime:Int64?

    /// 应用更新时间
    var updateTime:Int64?

    /// 应用创建时间
    var createTime:Int64?

    /// 创建应用的账户用户名
    var account:String?

    /// 允许登录应用的账号类型
    var userType:String?



    public override init(){
        super.init()
    }

    enum GetAppResultCodingKeys: String, CodingKey {
        case clientId
        case clientName
        case tokenEndpointAuthMethod
        case grantTypes
        case responseTypes
        case redirectUris
        case clientUri
        case logoUri
        case tosUri
        case policyUri
        case scope
        case jwksUri
        case jwks
        case contacts
        case extensionValue = "extension"
        case accessTokenValiditySeconds
        case refreshTokenValiditySeconds
        case multiTenant
        case secretUpdateTime
        case updateTime
        case createTime
        case account
        case userType
    }

    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: GetAppResultCodingKeys.self)
        if decoderContainer.contains(.clientId)
        {
            self.clientId = try decoderContainer.decode(String?.self, forKey: .clientId)
        }
        if decoderContainer.contains(.clientName)
        {
            self.clientName = try decoderContainer.decode(String?.self, forKey: .clientName)
        }
        if decoderContainer.contains(.tokenEndpointAuthMethod)
        {
            self.tokenEndpointAuthMethod = try decoderContainer.decode(String?.self, forKey: .tokenEndpointAuthMethod)
        }
        if decoderContainer.contains(.grantTypes)
        {
            self.grantTypes = try decoderContainer.decode(String?.self, forKey: .grantTypes)
        }
        if decoderContainer.contains(.responseTypes)
        {
            self.responseTypes = try decoderContainer.decode(String?.self, forKey: .responseTypes)
        }
        if decoderContainer.contains(.redirectUris)
        {
            self.redirectUris = try decoderContainer.decode(String?.self, forKey: .redirectUris)
        }
        if decoderContainer.contains(.clientUri)
        {
            self.clientUri = try decoderContainer.decode(String?.self, forKey: .clientUri)
        }
        if decoderContainer.contains(.logoUri)
        {
            self.logoUri = try decoderContainer.decode(String?.self, forKey: .logoUri)
        }
        if decoderContainer.contains(.tosUri)
        {
            self.tosUri = try decoderContainer.decode(String?.self, forKey: .tosUri)
        }
        if decoderContainer.contains(.policyUri)
        {
            self.policyUri = try decoderContainer.decode(String?.self, forKey: .policyUri)
        }
        if decoderContainer.contains(.scope)
        {
            self.scope = try decoderContainer.decode(String?.self, forKey: .scope)
        }
        if decoderContainer.contains(.jwksUri)
        {
            self.jwksUri = try decoderContainer.decode(String?.self, forKey: .jwksUri)
        }
        if decoderContainer.contains(.jwks)
        {
            self.jwks = try decoderContainer.decode(String?.self, forKey: .jwks)
        }
        if decoderContainer.contains(.contacts)
        {
            self.contacts = try decoderContainer.decode(String?.self, forKey: .contacts)
        }
        if decoderContainer.contains(.extensionValue)
        {
            self.extensionValue = try decoderContainer.decode(String?.self, forKey: .extensionValue)
        }
        if decoderContainer.contains(.accessTokenValiditySeconds)
        {
            self.accessTokenValiditySeconds = try decoderContainer.decode(Int?.self, forKey: .accessTokenValiditySeconds)
        }
        if decoderContainer.contains(.refreshTokenValiditySeconds)
        {
            self.refreshTokenValiditySeconds = try decoderContainer.decode(Int?.self, forKey: .refreshTokenValiditySeconds)
        }
        if decoderContainer.contains(.multiTenant)
        {
            self.multiTenant = try decoderContainer.decode(Bool?.self, forKey: .multiTenant)
        }
        if decoderContainer.contains(.secretUpdateTime)
        {
            self.secretUpdateTime = try decoderContainer.decode(Int64?.self, forKey: .secretUpdateTime)
        }
        if decoderContainer.contains(.updateTime)
        {
            self.updateTime = try decoderContainer.decode(Int64?.self, forKey: .updateTime)
        }
        if decoderContainer.contains(.createTime)
        {
            self.createTime = try decoderContainer.decode(Int64?.self, forKey: .createTime)
        }
        if decoderContainer.contains(.account)
        {
            self.account = try decoderContainer.decode(String?.self, forKey: .account)
        }
        if decoderContainer.contains(.userType)
        {
            self.userType = try decoderContainer.decode(String?.self, forKey: .userType)
        }
    }
}
public extension GetAppResult{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: GetAppResultCodingKeys.self)
        try encoderContainer.encode(clientId, forKey: .clientId)
        try encoderContainer.encode(clientName, forKey: .clientName)
        try encoderContainer.encode(tokenEndpointAuthMethod, forKey: .tokenEndpointAuthMethod)
        try encoderContainer.encode(grantTypes, forKey: .grantTypes)
        try encoderContainer.encode(responseTypes, forKey: .responseTypes)
        try encoderContainer.encode(redirectUris, forKey: .redirectUris)
        try encoderContainer.encode(clientUri, forKey: .clientUri)
        try encoderContainer.encode(logoUri, forKey: .logoUri)
        try encoderContainer.encode(tosUri, forKey: .tosUri)
        try encoderContainer.encode(policyUri, forKey: .policyUri)
        try encoderContainer.encode(scope, forKey: .scope)
        try encoderContainer.encode(jwksUri, forKey: .jwksUri)
        try encoderContainer.encode(jwks, forKey: .jwks)
        try encoderContainer.encode(contacts, forKey: .contacts)
        try encoderContainer.encode(extensionValue, forKey: .extensionValue)
        try encoderContainer.encode(accessTokenValiditySeconds, forKey: .accessTokenValiditySeconds)
        try encoderContainer.encode(refreshTokenValiditySeconds, forKey: .refreshTokenValiditySeconds)
        try encoderContainer.encode(multiTenant, forKey: .multiTenant)
        try encoderContainer.encode(secretUpdateTime, forKey: .secretUpdateTime)
        try encoderContainer.encode(updateTime, forKey: .updateTime)
        try encoderContainer.encode(createTime, forKey: .createTime)
        try encoderContainer.encode(account, forKey: .account)
        try encoderContainer.encode(userType, forKey: .userType)
    }
}
public class DeleteAppResponse:NSObject,Codable
{
    var requestId:String?;

    var error:ServiceError?;

    var result:DeleteAppResult?;

    enum DeleteAppResponseCodingKeys: String, CodingKey {
        case requestId
        case error
        case result
    }

    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: DeleteAppResponseCodingKeys.self)
        self.requestId = try decoderContainer.decodeIfPresent(String?.self, forKey: .requestId) ?? nil
        self.error = try decoderContainer.decodeIfPresent(ServiceError?.self, forKey: .error) ?? nil
        self.result = try decoderContainer.decodeIfPresent(DeleteAppResult?.self, forKey: .result) ?? nil
    }
}

public extension DeleteAppResponse{
        func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: DeleteAppResponseCodingKeys.self)
        try encoderContainer.encode(requestId, forKey: .requestId)
        try encoderContainer.encode(error, forKey: .error)
        try encoderContainer.encode(result, forKey: .result)
    }
}    
/// 获取账户下所有应用 
public class GetAppsResult:NSObject,JdCloudResult
{
    /// 应用组
    var apps:[ApplicationRes?]?



    public override init(){
        super.init()
    }

    enum GetAppsResultCodingKeys: String, CodingKey {
        case apps
    }

    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: GetAppsResultCodingKeys.self)
        if decoderContainer.contains(.apps)
        {
            self.apps = try decoderContainer.decode([ApplicationRes?]?.self, forKey: .apps)
        }
    }
}
public extension GetAppsResult{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: GetAppsResultCodingKeys.self)
        try encoderContainer.encode(apps, forKey: .apps)
    }
}
public class GetAppResponse:NSObject,Codable
{
    var requestId:String?;

    var error:ServiceError?;

    var result:GetAppResult?;

    enum GetAppResponseCodingKeys: String, CodingKey {
        case requestId
        case error
        case result
    }

    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: GetAppResponseCodingKeys.self)
        self.requestId = try decoderContainer.decodeIfPresent(String?.self, forKey: .requestId) ?? nil
        self.error = try decoderContainer.decodeIfPresent(ServiceError?.self, forKey: .error) ?? nil
        self.result = try decoderContainer.decodeIfPresent(GetAppResult?.self, forKey: .result) ?? nil
    }
}

public extension GetAppResponse{
        func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: GetAppResponseCodingKeys.self)
        try encoderContainer.encode(requestId, forKey: .requestId)
        try encoderContainer.encode(error, forKey: .error)
        try encoderContainer.encode(result, forKey: .result)
    }
}    
/// 创建应用 
public class CreateAppResult:NSObject,JdCloudResult
{
    /// 应用ID，由京东云分配的16位数字ID
    var clientId:String?

    /// clientName参数值
    var clientName:String?

    /// tokenEndpointAuthMethod参数值
    var tokenEndpointAuthMethod:String?

    /// grantTypes参数值
    var grantTypes:String?

    /// 当grantTypes为authorization_code时，responseTypes为code；当grantTypes为implicit时，responseTypes为token
    var responseTypes:String?

    /// redirectUris参数值
    var redirectUris:String?

    /// clientUri参数值
    var clientUri:String?

    /// logoUri参数值
    var logoUri:String?

    /// tosUri参数值
    var tosUri:String?

    /// policyUri参数值
    var policyUri:String?

    /// scope参数值
    var scope:String?

    /// jwksUri参数值
    var jwksUri:String?

    /// jwks参数值
    var jwks:String?

    /// contacts参数值
    var contacts:String?

    /// extension参数值
    var extensionValue:String?

    /// accessTokenValiditySeconds参数值
    var accessTokenValiditySeconds:Int?

    /// refreshTokenValiditySeconds参数值
    var refreshTokenValiditySeconds:Int?

    /// multiTenant参数值
    var multiTenant:Bool?

    /// secretUpdateTime参数值
    var secretUpdateTime:Int64?

    /// updateTime参数值
    var updateTime:Int64?

    /// createTime参数值
    var createTime:Int64?

    /// 创建应用的账户用户名
    var account:String?

    /// userType参数值
    var userType:String?



    public override init(){
        super.init()
    }

    enum CreateAppResultCodingKeys: String, CodingKey {
        case clientId
        case clientName
        case tokenEndpointAuthMethod
        case grantTypes
        case responseTypes
        case redirectUris
        case clientUri
        case logoUri
        case tosUri
        case policyUri
        case scope
        case jwksUri
        case jwks
        case contacts
        case extensionValue = "extension"
        case accessTokenValiditySeconds
        case refreshTokenValiditySeconds
        case multiTenant
        case secretUpdateTime
        case updateTime
        case createTime
        case account
        case userType
    }

    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: CreateAppResultCodingKeys.self)
        if decoderContainer.contains(.clientId)
        {
            self.clientId = try decoderContainer.decode(String?.self, forKey: .clientId)
        }
        if decoderContainer.contains(.clientName)
        {
            self.clientName = try decoderContainer.decode(String?.self, forKey: .clientName)
        }
        if decoderContainer.contains(.tokenEndpointAuthMethod)
        {
            self.tokenEndpointAuthMethod = try decoderContainer.decode(String?.self, forKey: .tokenEndpointAuthMethod)
        }
        if decoderContainer.contains(.grantTypes)
        {
            self.grantTypes = try decoderContainer.decode(String?.self, forKey: .grantTypes)
        }
        if decoderContainer.contains(.responseTypes)
        {
            self.responseTypes = try decoderContainer.decode(String?.self, forKey: .responseTypes)
        }
        if decoderContainer.contains(.redirectUris)
        {
            self.redirectUris = try decoderContainer.decode(String?.self, forKey: .redirectUris)
        }
        if decoderContainer.contains(.clientUri)
        {
            self.clientUri = try decoderContainer.decode(String?.self, forKey: .clientUri)
        }
        if decoderContainer.contains(.logoUri)
        {
            self.logoUri = try decoderContainer.decode(String?.self, forKey: .logoUri)
        }
        if decoderContainer.contains(.tosUri)
        {
            self.tosUri = try decoderContainer.decode(String?.self, forKey: .tosUri)
        }
        if decoderContainer.contains(.policyUri)
        {
            self.policyUri = try decoderContainer.decode(String?.self, forKey: .policyUri)
        }
        if decoderContainer.contains(.scope)
        {
            self.scope = try decoderContainer.decode(String?.self, forKey: .scope)
        }
        if decoderContainer.contains(.jwksUri)
        {
            self.jwksUri = try decoderContainer.decode(String?.self, forKey: .jwksUri)
        }
        if decoderContainer.contains(.jwks)
        {
            self.jwks = try decoderContainer.decode(String?.self, forKey: .jwks)
        }
        if decoderContainer.contains(.contacts)
        {
            self.contacts = try decoderContainer.decode(String?.self, forKey: .contacts)
        }
        if decoderContainer.contains(.extensionValue)
        {
            self.extensionValue = try decoderContainer.decode(String?.self, forKey: .extensionValue)
        }
        if decoderContainer.contains(.accessTokenValiditySeconds)
        {
            self.accessTokenValiditySeconds = try decoderContainer.decode(Int?.self, forKey: .accessTokenValiditySeconds)
        }
        if decoderContainer.contains(.refreshTokenValiditySeconds)
        {
            self.refreshTokenValiditySeconds = try decoderContainer.decode(Int?.self, forKey: .refreshTokenValiditySeconds)
        }
        if decoderContainer.contains(.multiTenant)
        {
            self.multiTenant = try decoderContainer.decode(Bool?.self, forKey: .multiTenant)
        }
        if decoderContainer.contains(.secretUpdateTime)
        {
            self.secretUpdateTime = try decoderContainer.decode(Int64?.self, forKey: .secretUpdateTime)
        }
        if decoderContainer.contains(.updateTime)
        {
            self.updateTime = try decoderContainer.decode(Int64?.self, forKey: .updateTime)
        }
        if decoderContainer.contains(.createTime)
        {
            self.createTime = try decoderContainer.decode(Int64?.self, forKey: .createTime)
        }
        if decoderContainer.contains(.account)
        {
            self.account = try decoderContainer.decode(String?.self, forKey: .account)
        }
        if decoderContainer.contains(.userType)
        {
            self.userType = try decoderContainer.decode(String?.self, forKey: .userType)
        }
    }
}
public extension CreateAppResult{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: CreateAppResultCodingKeys.self)
        try encoderContainer.encode(clientId, forKey: .clientId)
        try encoderContainer.encode(clientName, forKey: .clientName)
        try encoderContainer.encode(tokenEndpointAuthMethod, forKey: .tokenEndpointAuthMethod)
        try encoderContainer.encode(grantTypes, forKey: .grantTypes)
        try encoderContainer.encode(responseTypes, forKey: .responseTypes)
        try encoderContainer.encode(redirectUris, forKey: .redirectUris)
        try encoderContainer.encode(clientUri, forKey: .clientUri)
        try encoderContainer.encode(logoUri, forKey: .logoUri)
        try encoderContainer.encode(tosUri, forKey: .tosUri)
        try encoderContainer.encode(policyUri, forKey: .policyUri)
        try encoderContainer.encode(scope, forKey: .scope)
        try encoderContainer.encode(jwksUri, forKey: .jwksUri)
        try encoderContainer.encode(jwks, forKey: .jwks)
        try encoderContainer.encode(contacts, forKey: .contacts)
        try encoderContainer.encode(extensionValue, forKey: .extensionValue)
        try encoderContainer.encode(accessTokenValiditySeconds, forKey: .accessTokenValiditySeconds)
        try encoderContainer.encode(refreshTokenValiditySeconds, forKey: .refreshTokenValiditySeconds)
        try encoderContainer.encode(multiTenant, forKey: .multiTenant)
        try encoderContainer.encode(secretUpdateTime, forKey: .secretUpdateTime)
        try encoderContainer.encode(updateTime, forKey: .updateTime)
        try encoderContainer.encode(createTime, forKey: .createTime)
        try encoderContainer.encode(account, forKey: .account)
        try encoderContainer.encode(userType, forKey: .userType)
    }
}
public class GetAppsResponse:NSObject,Codable
{
    var requestId:String?;

    var error:ServiceError?;

    var result:GetAppsResult?;

    enum GetAppsResponseCodingKeys: String, CodingKey {
        case requestId
        case error
        case result
    }

    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: GetAppsResponseCodingKeys.self)
        self.requestId = try decoderContainer.decodeIfPresent(String?.self, forKey: .requestId) ?? nil
        self.error = try decoderContainer.decodeIfPresent(ServiceError?.self, forKey: .error) ?? nil
        self.result = try decoderContainer.decodeIfPresent(GetAppsResult?.self, forKey: .result) ?? nil
    }
}

public extension GetAppsResponse{
        func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: GetAppsResponseCodingKeys.self)
        try encoderContainer.encode(requestId, forKey: .requestId)
        try encoderContainer.encode(error, forKey: .error)
        try encoderContainer.encode(result, forKey: .result)
    }
}    

///  获取应用
public class GetAppRequest:JdCloudRequest
{
    /// 应用ID，应用创建时由京东云分配的16位数字ID
    var clientId:String


    public init(regionId: String,clientId:String){
        self.clientId = clientId
        super.init(regionId: regionId)
    }


    enum GetAppRequestRequestCodingKeys: String, CodingKey {
        case clientId
    }

    public override func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: GetAppRequestRequestCodingKeys.self)
        try encoderContainer.encode(clientId, forKey: .clientId)

    }
}


///  获取账户下所有应用
public class GetAppsRequest:JdCloudRequest
{
}


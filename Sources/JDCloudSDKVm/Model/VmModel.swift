/* Copyright 2018 JDCLOUD.COM

   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at

     http:#www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.

   镜像
   关于主机镜像操作的相关接口

   OpenAPI spec version: v1
   Contact: 

   NOTE: This class is auto generated by the jdcloud code generator program.
 */


import Foundation
import JDCloudSDKCharge
import JDCloudSDKVpc
import JDCloudSDKDisk
///  instanceTemplateNetworkInterfaceAttachmentSpec
public class InstanceTemplateNetworkInterfaceAttachmentSpec:NSObject,Codable{
    /// 设备Index；主网卡的index必须为1；当前仅支持主网卡
    var deviceIndex:Int?
    /// 指明删除实例时是否删除网卡，默认true；当前只能是true
    var autoDelete:Bool?
    /// 网卡接口规范；此字段当前必填
    /// Required:true
    var networkInterface:InstanceTemplateNetworkInterfaceSpec



    public  init(networkInterface:InstanceTemplateNetworkInterfaceSpec){
             self.networkInterface = networkInterface
    }

    enum InstanceTemplateNetworkInterfaceAttachmentSpecCodingKeys: String, CodingKey {
        case deviceIndex
        case autoDelete
        case networkInterface
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: InstanceTemplateNetworkInterfaceAttachmentSpecCodingKeys.self)
        if decoderContainer.contains(.deviceIndex)
        {
            self.deviceIndex = try decoderContainer.decode(Int?.self, forKey: .deviceIndex)
        }
        if decoderContainer.contains(.autoDelete)
        {
            self.autoDelete = try decoderContainer.decode(Bool?.self, forKey: .autoDelete)
        }
        self.networkInterface = try decoderContainer.decode(InstanceTemplateNetworkInterfaceSpec.self, forKey: .networkInterface)
    }
}
public extension InstanceTemplateNetworkInterfaceAttachmentSpec{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: InstanceTemplateNetworkInterfaceAttachmentSpecCodingKeys.self)
         try encoderContainer.encode(deviceIndex, forKey: .deviceIndex)
         try encoderContainer.encode(autoDelete, forKey: .autoDelete)
         try encoderContainer.encode(networkInterface, forKey: .networkInterface)
    }
}
///  ag
public class Ag:NSObject,Codable{
    /// 高可用组名称
    var name:String?
    /// 高可用组id
    var id:String?



    public override init(){
            super.init()
    }

    enum AgCodingKeys: String, CodingKey {
        case name
        case id
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: AgCodingKeys.self)
        if decoderContainer.contains(.name)
        {
            self.name = try decoderContainer.decode(String?.self, forKey: .name)
        }
        if decoderContainer.contains(.id)
        {
            self.id = try decoderContainer.decode(String?.self, forKey: .id)
        }
    }
}
public extension Ag{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: AgCodingKeys.self)
         try encoderContainer.encode(name, forKey: .name)
         try encoderContainer.encode(id, forKey: .id)
    }
}
///  instanceTemplateNetworkInterfaceAttachment
public class InstanceTemplateNetworkInterfaceAttachment:NSObject,Codable{
    /// 设备Index；主网卡的index必须为1；当前仅支持主网卡
    var deviceIndex:Int?
    /// 指明删除实例时是否删除网卡，默认true；当前只能是true
    var autoDelete:Bool?
    /// 网卡接口规范；此字段当前必填
    /// Required:true
    var networkInterface:InstanceTemplateNetworkInterface



    public  init(networkInterface:InstanceTemplateNetworkInterface){
             self.networkInterface = networkInterface
    }

    enum InstanceTemplateNetworkInterfaceAttachmentCodingKeys: String, CodingKey {
        case deviceIndex
        case autoDelete
        case networkInterface
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: InstanceTemplateNetworkInterfaceAttachmentCodingKeys.self)
        if decoderContainer.contains(.deviceIndex)
        {
            self.deviceIndex = try decoderContainer.decode(Int?.self, forKey: .deviceIndex)
        }
        if decoderContainer.contains(.autoDelete)
        {
            self.autoDelete = try decoderContainer.decode(Bool?.self, forKey: .autoDelete)
        }
        self.networkInterface = try decoderContainer.decode(InstanceTemplateNetworkInterface.self, forKey: .networkInterface)
    }
}
public extension InstanceTemplateNetworkInterfaceAttachment{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: InstanceTemplateNetworkInterfaceAttachmentCodingKeys.self)
         try encoderContainer.encode(deviceIndex, forKey: .deviceIndex)
         try encoderContainer.encode(autoDelete, forKey: .autoDelete)
         try encoderContainer.encode(networkInterface, forKey: .networkInterface)
    }
}
///  instanceTemplateElasticIp
public class InstanceTemplateElasticIp:NSObject,Codable{
    /// 弹性公网IP的限速（单位：MB）
    /// Required:true
    var bandwidthMbps:Int
    /// IP服务商，取值为BGP,nonBGP
    var provider:String?
    /// 计费类型，支持按带宽计费(bandwith)，按流量计费(flow)
    /// Required:true
    var chargeMode:String



    public  init(bandwidthMbps:Int,chargeMode:String){
             self.bandwidthMbps = bandwidthMbps
             self.chargeMode = chargeMode
    }

    enum InstanceTemplateElasticIpCodingKeys: String, CodingKey {
        case bandwidthMbps
        case provider
        case chargeMode
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: InstanceTemplateElasticIpCodingKeys.self)
        self.bandwidthMbps = try decoderContainer.decode(Int.self, forKey: .bandwidthMbps)
        if decoderContainer.contains(.provider)
        {
            self.provider = try decoderContainer.decode(String?.self, forKey: .provider)
        }
        self.chargeMode = try decoderContainer.decode(String.self, forKey: .chargeMode)
    }
}
public extension InstanceTemplateElasticIp{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: InstanceTemplateElasticIpCodingKeys.self)
         try encoderContainer.encode(bandwidthMbps, forKey: .bandwidthMbps)
         try encoderContainer.encode(provider, forKey: .provider)
         try encoderContainer.encode(chargeMode, forKey: .chargeMode)
    }
}
///  instanceTemplateNetworkInterfaceSpec
public class InstanceTemplateNetworkInterfaceSpec:NSObject,Codable{
    /// 子网ID
    /// Required:true
    var subnetId:String
    /// 安全组ID列表
    var securityGroups:[String?]?
    /// PortSecurity，取值为0或者1，默认为1
    var sanityCheck:Int?



    public  init(subnetId:String){
             self.subnetId = subnetId
    }

    enum InstanceTemplateNetworkInterfaceSpecCodingKeys: String, CodingKey {
        case subnetId
        case securityGroups
        case sanityCheck
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: InstanceTemplateNetworkInterfaceSpecCodingKeys.self)
        self.subnetId = try decoderContainer.decode(String.self, forKey: .subnetId)
        if decoderContainer.contains(.securityGroups)
        {
            self.securityGroups = try decoderContainer.decode([String?]?.self, forKey: .securityGroups)
        }
        if decoderContainer.contains(.sanityCheck)
        {
            self.sanityCheck = try decoderContainer.decode(Int?.self, forKey: .sanityCheck)
        }
    }
}
public extension InstanceTemplateNetworkInterfaceSpec{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: InstanceTemplateNetworkInterfaceSpecCodingKeys.self)
         try encoderContainer.encode(subnetId, forKey: .subnetId)
         try encoderContainer.encode(securityGroups, forKey: .securityGroups)
         try encoderContainer.encode(sanityCheck, forKey: .sanityCheck)
    }
}
///  instanceTemplateDiskAttachmentSpec
public class InstanceTemplateDiskAttachmentSpec:NSObject,Codable{
    /// 磁盘分类，取值为本地盘(local)或者数据盘(cloud)。
      /// 系统盘支持本地盘(local)或者云硬盘(cloud)。系统盘选择local类型，必须使用localDisk类型的镜像；同理系统盘选择cloud类型，必须使用cloudDisk类型的镜像。
      /// 数据盘仅支持云硬盘(cloud)。
      /// 
    var diskCategory:String?
    /// 随云主机一起删除，删除主机时自动删除此磁盘，默认为true，本地盘(local)不能更改此值。
      /// 如果云主机中的数据盘(cloud)是包年包月计费方式，此参数不生效。
      /// 如果云主机中的数据盘(cloud)是共享型数据盘，此参数不生效。
      /// 
    var autoDelete:Bool?
    /// 数据盘规格
    var cloudDiskSpec:InstanceTemplateDiskSpec?
    /// 数据盘逻辑挂载点，取值范围：vda,vdb,vdc,vdd,vde,vdf,vdg,vdh,vdi,vmj,vdk,vdl,vdm
    var deviceName:String?
    /// 排除设备，使用此参数noDevice配合deviceName一起使用。
      /// 创建模板：如deviceName:vdb、noDevice:true，则表示镜像中的数据盘vdb不参与创建主机。
      /// 
    var noDevice:Bool?



    public override init(){
            super.init()
    }

    enum InstanceTemplateDiskAttachmentSpecCodingKeys: String, CodingKey {
        case diskCategory
        case autoDelete
        case cloudDiskSpec
        case deviceName
        case noDevice
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: InstanceTemplateDiskAttachmentSpecCodingKeys.self)
        if decoderContainer.contains(.diskCategory)
        {
            self.diskCategory = try decoderContainer.decode(String?.self, forKey: .diskCategory)
        }
        if decoderContainer.contains(.autoDelete)
        {
            self.autoDelete = try decoderContainer.decode(Bool?.self, forKey: .autoDelete)
        }
        if decoderContainer.contains(.cloudDiskSpec)
        {
            self.cloudDiskSpec = try decoderContainer.decode(InstanceTemplateDiskSpec?.self, forKey: .cloudDiskSpec)
        }
        if decoderContainer.contains(.deviceName)
        {
            self.deviceName = try decoderContainer.decode(String?.self, forKey: .deviceName)
        }
        if decoderContainer.contains(.noDevice)
        {
            self.noDevice = try decoderContainer.decode(Bool?.self, forKey: .noDevice)
        }
    }
}
public extension InstanceTemplateDiskAttachmentSpec{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: InstanceTemplateDiskAttachmentSpecCodingKeys.self)
         try encoderContainer.encode(diskCategory, forKey: .diskCategory)
         try encoderContainer.encode(autoDelete, forKey: .autoDelete)
         try encoderContainer.encode(cloudDiskSpec, forKey: .cloudDiskSpec)
         try encoderContainer.encode(deviceName, forKey: .deviceName)
         try encoderContainer.encode(noDevice, forKey: .noDevice)
    }
}
///  instanceTemplate
public class InstanceTemplate:NSObject,Codable{
    /// 启动模板ID
    var id:String?
    /// 启动模板名称
    var name:String?
    /// 启动模板描述
    var descriptionValue:String?
    /// 启动模板的数据
    var instanceTemplateData:InstanceTemplateData?
    /// 关联的高可用组(ag)信息
    var ags:[Ag?]?
    /// 创建时间
    var createdTime:String?



    public override init(){
            super.init()
    }

    enum InstanceTemplateCodingKeys: String, CodingKey {
        case id
        case name
        case descriptionValue = "description"
        case instanceTemplateData
        case ags
        case createdTime
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: InstanceTemplateCodingKeys.self)
        if decoderContainer.contains(.id)
        {
            self.id = try decoderContainer.decode(String?.self, forKey: .id)
        }
        if decoderContainer.contains(.name)
        {
            self.name = try decoderContainer.decode(String?.self, forKey: .name)
        }
        if decoderContainer.contains(.descriptionValue)
        {
            self.descriptionValue = try decoderContainer.decode(String?.self, forKey: .descriptionValue)
        }
        if decoderContainer.contains(.instanceTemplateData)
        {
            self.instanceTemplateData = try decoderContainer.decode(InstanceTemplateData?.self, forKey: .instanceTemplateData)
        }
        if decoderContainer.contains(.ags)
        {
            self.ags = try decoderContainer.decode([Ag?]?.self, forKey: .ags)
        }
        if decoderContainer.contains(.createdTime)
        {
            self.createdTime = try decoderContainer.decode(String?.self, forKey: .createdTime)
        }
    }
}
public extension InstanceTemplate{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: InstanceTemplateCodingKeys.self)
         try encoderContainer.encode(id, forKey: .id)
         try encoderContainer.encode(name, forKey: .name)
         try encoderContainer.encode(descriptionValue, forKey: .descriptionValue)
         try encoderContainer.encode(instanceTemplateData, forKey: .instanceTemplateData)
         try encoderContainer.encode(ags, forKey: .ags)
         try encoderContainer.encode(createdTime, forKey: .createdTime)
    }
}
///  instanceTemplateNetworkInterface
public class InstanceTemplateNetworkInterface:NSObject,Codable{
    /// 子网ID
    /// Required:true
    var subnetId:String
    /// 安全组ID列表
    var securityGroups:[String?]?
    /// PortSecurity，取值为0或者1，默认为1
    var sanityCheck:Int?



    public  init(subnetId:String){
             self.subnetId = subnetId
    }

    enum InstanceTemplateNetworkInterfaceCodingKeys: String, CodingKey {
        case subnetId
        case securityGroups
        case sanityCheck
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: InstanceTemplateNetworkInterfaceCodingKeys.self)
        self.subnetId = try decoderContainer.decode(String.self, forKey: .subnetId)
        if decoderContainer.contains(.securityGroups)
        {
            self.securityGroups = try decoderContainer.decode([String?]?.self, forKey: .securityGroups)
        }
        if decoderContainer.contains(.sanityCheck)
        {
            self.sanityCheck = try decoderContainer.decode(Int?.self, forKey: .sanityCheck)
        }
    }
}
public extension InstanceTemplateNetworkInterface{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: InstanceTemplateNetworkInterfaceCodingKeys.self)
         try encoderContainer.encode(subnetId, forKey: .subnetId)
         try encoderContainer.encode(securityGroups, forKey: .securityGroups)
         try encoderContainer.encode(sanityCheck, forKey: .sanityCheck)
    }
}
///  instanceTemplateSpec
public class InstanceTemplateSpec:NSObject,Codable{
    /// 实例规格，可查询&lt;a href&#x3D;&quot;http://docs.jdcloud.com/virtual-machines/api/describeinstancetypes&quot;&gt;DescribeInstanceTypes&lt;/a&gt;接口获得指定地域或可用区的规格信息。
    /// Required:true
    var instanceType:String
    /// 镜像ID，可查询&lt;a href&#x3D;&quot;http://docs.jdcloud.com/virtual-machines/api/describeimages&quot;&gt;DescribeImages&lt;/a&gt;接口获得指定地域的镜像信息。
    /// Required:true
    var imageId:String
    /// 密码，&lt;a href&#x3D;&quot;http://docs.jdcloud.com/virtual-machines/api/general_parameters&quot;&gt;参考公共参数规范&lt;/a&gt;。
    var password:String?
    /// 密钥对名称；当前只支持一个
    var keyNames:[String?]?
    /// 主网卡主IP关联的弹性IP规格
    var elasticIp:InstanceTemplateElasticIpSpec?
    /// 主网卡配置信息
    /// Required:true
    var primaryNetworkInterface:InstanceTemplateNetworkInterfaceAttachmentSpec
    /// 系统盘配置信息
    /// Required:true
    var systemDisk:InstanceTemplateDiskAttachmentSpec
    /// 数据盘配置信息
    var dataDisks:[InstanceTemplateDiskAttachmentSpec?]?



    public  init(instanceType:String,imageId:String,primaryNetworkInterface:InstanceTemplateNetworkInterfaceAttachmentSpec,systemDisk:InstanceTemplateDiskAttachmentSpec){
             self.instanceType = instanceType
             self.imageId = imageId
             self.primaryNetworkInterface = primaryNetworkInterface
             self.systemDisk = systemDisk
    }

    enum InstanceTemplateSpecCodingKeys: String, CodingKey {
        case instanceType
        case imageId
        case password
        case keyNames
        case elasticIp
        case primaryNetworkInterface
        case systemDisk
        case dataDisks
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: InstanceTemplateSpecCodingKeys.self)
        self.instanceType = try decoderContainer.decode(String.self, forKey: .instanceType)
        self.imageId = try decoderContainer.decode(String.self, forKey: .imageId)
        if decoderContainer.contains(.password)
        {
            self.password = try decoderContainer.decode(String?.self, forKey: .password)
        }
        if decoderContainer.contains(.keyNames)
        {
            self.keyNames = try decoderContainer.decode([String?]?.self, forKey: .keyNames)
        }
        if decoderContainer.contains(.elasticIp)
        {
            self.elasticIp = try decoderContainer.decode(InstanceTemplateElasticIpSpec?.self, forKey: .elasticIp)
        }
        self.primaryNetworkInterface = try decoderContainer.decode(InstanceTemplateNetworkInterfaceAttachmentSpec.self, forKey: .primaryNetworkInterface)
        self.systemDisk = try decoderContainer.decode(InstanceTemplateDiskAttachmentSpec.self, forKey: .systemDisk)
        if decoderContainer.contains(.dataDisks)
        {
            self.dataDisks = try decoderContainer.decode([InstanceTemplateDiskAttachmentSpec?]?.self, forKey: .dataDisks)
        }
    }
}
public extension InstanceTemplateSpec{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: InstanceTemplateSpecCodingKeys.self)
         try encoderContainer.encode(instanceType, forKey: .instanceType)
         try encoderContainer.encode(imageId, forKey: .imageId)
         try encoderContainer.encode(password, forKey: .password)
         try encoderContainer.encode(keyNames, forKey: .keyNames)
         try encoderContainer.encode(elasticIp, forKey: .elasticIp)
         try encoderContainer.encode(primaryNetworkInterface, forKey: .primaryNetworkInterface)
         try encoderContainer.encode(systemDisk, forKey: .systemDisk)
         try encoderContainer.encode(dataDisks, forKey: .dataDisks)
    }
}
///  instanceTemplateDiskSpec
public class InstanceTemplateDiskSpec:NSObject,Codable{
    /// 云硬盘类型，取值为ssd、premium-hdd、hdd.std1、ssd.gp1、ssd.io1
    var diskType:String?
    /// 云硬盘大小，单位为 GiB；ssd 类型取值范围[20,1000]GB，步长为10G，premium-hdd 类型取值范围[20,3000]GB，步长为10G，hdd.std1、ssd.gp1、ssd.io1 类型取值范围[20-16000]GB，步长为10GB
    var diskSizeGB:Int?
    /// 用于创建云硬盘的快照ID
    var snapshotId:String?



    public override init(){
            super.init()
    }

    enum InstanceTemplateDiskSpecCodingKeys: String, CodingKey {
        case diskType
        case diskSizeGB
        case snapshotId
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: InstanceTemplateDiskSpecCodingKeys.self)
        if decoderContainer.contains(.diskType)
        {
            self.diskType = try decoderContainer.decode(String?.self, forKey: .diskType)
        }
        if decoderContainer.contains(.diskSizeGB)
        {
            self.diskSizeGB = try decoderContainer.decode(Int?.self, forKey: .diskSizeGB)
        }
        if decoderContainer.contains(.snapshotId)
        {
            self.snapshotId = try decoderContainer.decode(String?.self, forKey: .snapshotId)
        }
    }
}
public extension InstanceTemplateDiskSpec{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: InstanceTemplateDiskSpecCodingKeys.self)
         try encoderContainer.encode(diskType, forKey: .diskType)
         try encoderContainer.encode(diskSizeGB, forKey: .diskSizeGB)
         try encoderContainer.encode(snapshotId, forKey: .snapshotId)
    }
}
///  instanceTemplateElasticIpSpec
public class InstanceTemplateElasticIpSpec:NSObject,Codable{
    /// 弹性公网IP的限速（单位：MB）
    /// Required:true
    var bandwidthMbps:Int
    /// IP服务商，取值为BGP,nonBGP
    var provider:String?
    /// 计费类型，支持按带宽计费(bandwith)，按流量计费(flow)
    /// Required:true
    var chargeMode:String



    public  init(bandwidthMbps:Int,chargeMode:String){
             self.bandwidthMbps = bandwidthMbps
             self.chargeMode = chargeMode
    }

    enum InstanceTemplateElasticIpSpecCodingKeys: String, CodingKey {
        case bandwidthMbps
        case provider
        case chargeMode
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: InstanceTemplateElasticIpSpecCodingKeys.self)
        self.bandwidthMbps = try decoderContainer.decode(Int.self, forKey: .bandwidthMbps)
        if decoderContainer.contains(.provider)
        {
            self.provider = try decoderContainer.decode(String?.self, forKey: .provider)
        }
        self.chargeMode = try decoderContainer.decode(String.self, forKey: .chargeMode)
    }
}
public extension InstanceTemplateElasticIpSpec{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: InstanceTemplateElasticIpSpecCodingKeys.self)
         try encoderContainer.encode(bandwidthMbps, forKey: .bandwidthMbps)
         try encoderContainer.encode(provider, forKey: .provider)
         try encoderContainer.encode(chargeMode, forKey: .chargeMode)
    }
}
///  instanceTemplateData
public class InstanceTemplateData:NSObject,Codable{
    /// 实例规格
    var instanceType:String?
    /// 主网卡所属VPC的ID
    var vpcId:String?
    /// 镜像ID
    var imageId:String?
    /// 启动模板中是否包含自定义密码，true：包含密码，false：不包含密码
    var includePassword:Bool?
    /// 系统盘信息
    var systemDisk:InstanceTemplateDiskAttachment?
    /// 数据盘信息，本地盘(local类型)做系统盘的云主机可挂载8块数据盘，云硬盘(cloud类型)做系统盘的云主机可挂载7块数据盘。
    var dataDisks:[InstanceTemplateDiskAttachment?]?
    /// 主网卡信息
    var primaryNetworkInterface:InstanceTemplateNetworkInterfaceAttachment?
    /// 主网卡主IP关联的弹性IP规格
    var elasticIp:InstanceTemplateElasticIp?
    /// 密钥对名称；当前只支持一个
    var keyNames:[String?]?



    public override init(){
            super.init()
    }

    enum InstanceTemplateDataCodingKeys: String, CodingKey {
        case instanceType
        case vpcId
        case imageId
        case includePassword
        case systemDisk
        case dataDisks
        case primaryNetworkInterface
        case elasticIp
        case keyNames
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: InstanceTemplateDataCodingKeys.self)
        if decoderContainer.contains(.instanceType)
        {
            self.instanceType = try decoderContainer.decode(String?.self, forKey: .instanceType)
        }
        if decoderContainer.contains(.vpcId)
        {
            self.vpcId = try decoderContainer.decode(String?.self, forKey: .vpcId)
        }
        if decoderContainer.contains(.imageId)
        {
            self.imageId = try decoderContainer.decode(String?.self, forKey: .imageId)
        }
        if decoderContainer.contains(.includePassword)
        {
            self.includePassword = try decoderContainer.decode(Bool?.self, forKey: .includePassword)
        }
        if decoderContainer.contains(.systemDisk)
        {
            self.systemDisk = try decoderContainer.decode(InstanceTemplateDiskAttachment?.self, forKey: .systemDisk)
        }
        if decoderContainer.contains(.dataDisks)
        {
            self.dataDisks = try decoderContainer.decode([InstanceTemplateDiskAttachment?]?.self, forKey: .dataDisks)
        }
        if decoderContainer.contains(.primaryNetworkInterface)
        {
            self.primaryNetworkInterface = try decoderContainer.decode(InstanceTemplateNetworkInterfaceAttachment?.self, forKey: .primaryNetworkInterface)
        }
        if decoderContainer.contains(.elasticIp)
        {
            self.elasticIp = try decoderContainer.decode(InstanceTemplateElasticIp?.self, forKey: .elasticIp)
        }
        if decoderContainer.contains(.keyNames)
        {
            self.keyNames = try decoderContainer.decode([String?]?.self, forKey: .keyNames)
        }
    }
}
public extension InstanceTemplateData{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: InstanceTemplateDataCodingKeys.self)
         try encoderContainer.encode(instanceType, forKey: .instanceType)
         try encoderContainer.encode(vpcId, forKey: .vpcId)
         try encoderContainer.encode(imageId, forKey: .imageId)
         try encoderContainer.encode(includePassword, forKey: .includePassword)
         try encoderContainer.encode(systemDisk, forKey: .systemDisk)
         try encoderContainer.encode(dataDisks, forKey: .dataDisks)
         try encoderContainer.encode(primaryNetworkInterface, forKey: .primaryNetworkInterface)
         try encoderContainer.encode(elasticIp, forKey: .elasticIp)
         try encoderContainer.encode(keyNames, forKey: .keyNames)
    }
}
///  instanceTemplateDiskAttachment
public class InstanceTemplateDiskAttachment:NSObject,Codable{
    /// 磁盘分类，取值为本地盘(local)或者数据盘(cloud)。
      /// 系统盘支持本地盘(local)或者云硬盘(cloud)。系统盘选择local类型，必须使用localDisk类型的镜像；同理系统盘选择cloud类型，必须使用cloudDisk类型的镜像。
      /// 数据盘仅支持云硬盘(cloud)。
      /// 
    var diskCategory:String?
    /// 随云主机一起删除，删除主机时自动删除此磁盘，默认为true，本地盘(local)不能更改此值。
      /// 如果云主机中的数据盘(cloud)是包年包月计费方式，此参数不生效。
      /// 如果云主机中的数据盘(cloud)是共享型数据盘，此参数不生效。
      /// 
    var autoDelete:Bool?
    /// 数据盘配置
    var instanceTemplateDisk:InstanceTemplateDisk?
    /// 数据盘逻辑挂载点，取值范围：vda,vdb,vdc,vdd,vde,vdf,vdg,vdh,vdi,vmj,vdk,vdl,vdm。系统盘不需要使用，数据盘时才能够使用。
    var deviceName:String?
    /// 排除设备，使用此参数noDevice配合deviceName一起使用。
      /// 创建整机镜像：如deviceName:vdb、noDevice:true，则表示云主机中的数据盘vdb不参与创建镜像。
      /// 创建模板：如deviceName:vdb、noDevice:true，则表示镜像中的数据盘vdb不参与创建主机。
      /// 创建主机：如deviceName:vdb、noDevice:true，则表示镜像中的数据盘vdb，或者模板(使用模板创建主机)中的数据盘vdb不参与创建主机。
      /// 
    var noDevice:Bool?



    public override init(){
            super.init()
    }

    enum InstanceTemplateDiskAttachmentCodingKeys: String, CodingKey {
        case diskCategory
        case autoDelete
        case instanceTemplateDisk
        case deviceName
        case noDevice
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: InstanceTemplateDiskAttachmentCodingKeys.self)
        if decoderContainer.contains(.diskCategory)
        {
            self.diskCategory = try decoderContainer.decode(String?.self, forKey: .diskCategory)
        }
        if decoderContainer.contains(.autoDelete)
        {
            self.autoDelete = try decoderContainer.decode(Bool?.self, forKey: .autoDelete)
        }
        if decoderContainer.contains(.instanceTemplateDisk)
        {
            self.instanceTemplateDisk = try decoderContainer.decode(InstanceTemplateDisk?.self, forKey: .instanceTemplateDisk)
        }
        if decoderContainer.contains(.deviceName)
        {
            self.deviceName = try decoderContainer.decode(String?.self, forKey: .deviceName)
        }
        if decoderContainer.contains(.noDevice)
        {
            self.noDevice = try decoderContainer.decode(Bool?.self, forKey: .noDevice)
        }
    }
}
public extension InstanceTemplateDiskAttachment{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: InstanceTemplateDiskAttachmentCodingKeys.self)
         try encoderContainer.encode(diskCategory, forKey: .diskCategory)
         try encoderContainer.encode(autoDelete, forKey: .autoDelete)
         try encoderContainer.encode(instanceTemplateDisk, forKey: .instanceTemplateDisk)
         try encoderContainer.encode(deviceName, forKey: .deviceName)
         try encoderContainer.encode(noDevice, forKey: .noDevice)
    }
}
///  instanceTemplateDisk
public class InstanceTemplateDisk:NSObject,Codable{
    /// 云硬盘类型，取值为 ssd、premium-hdd、hdd.std1、ssd.gp1、ssd.io1
    var diskType:String?
    /// 云硬盘大小，单位为 GiB；ssd 类型取值范围[20,1000]GB，步长为10G，premium-hdd 类型取值范围[20,3000]GB，步长为10G，hdd.std1、ssd.gp1、ssd.io1 类型取值范围[20-16000]GB，步长为10GB
    var diskSizeGB:Int?
    /// 用于创建云硬盘的快照ID
    var snapshotId:String?



    public override init(){
            super.init()
    }

    enum InstanceTemplateDiskCodingKeys: String, CodingKey {
        case diskType
        case diskSizeGB
        case snapshotId
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: InstanceTemplateDiskCodingKeys.self)
        if decoderContainer.contains(.diskType)
        {
            self.diskType = try decoderContainer.decode(String?.self, forKey: .diskType)
        }
        if decoderContainer.contains(.diskSizeGB)
        {
            self.diskSizeGB = try decoderContainer.decode(Int?.self, forKey: .diskSizeGB)
        }
        if decoderContainer.contains(.snapshotId)
        {
            self.snapshotId = try decoderContainer.decode(String?.self, forKey: .snapshotId)
        }
    }
}
public extension InstanceTemplateDisk{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: InstanceTemplateDiskCodingKeys.self)
         try encoderContainer.encode(diskType, forKey: .diskType)
         try encoderContainer.encode(diskSizeGB, forKey: .diskSizeGB)
         try encoderContainer.encode(snapshotId, forKey: .snapshotId)
    }
}
///  quota
public class Quota:NSObject,Codable{
    /// 资源类型[instance，keypair，image，instanceTemplate]
    var resourceType:String?
    /// 配额上限
    var limit:Int?
    /// 已用配额
    var used:Int?



    public override init(){
            super.init()
    }

    enum QuotaCodingKeys: String, CodingKey {
        case resourceType
        case limit
        case used
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: QuotaCodingKeys.self)
        if decoderContainer.contains(.resourceType)
        {
            self.resourceType = try decoderContainer.decode(String?.self, forKey: .resourceType)
        }
        if decoderContainer.contains(.limit)
        {
            self.limit = try decoderContainer.decode(Int?.self, forKey: .limit)
        }
        if decoderContainer.contains(.used)
        {
            self.used = try decoderContainer.decode(Int?.self, forKey: .used)
        }
    }
}
public extension Quota{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: QuotaCodingKeys.self)
         try encoderContainer.encode(resourceType, forKey: .resourceType)
         try encoderContainer.encode(limit, forKey: .limit)
         try encoderContainer.encode(used, forKey: .used)
    }
}
///  instanceType
public class InstanceType:NSObject,Codable{
    /// 实例规格类型
    var family:String?
    /// 实例规格，比如g.b1.2xlarge
    var instanceTypeValue:String?
    /// cpu个数
    var cpu:Int?
    /// 内存大小
    var memoryMB:Int?
    /// 支持弹性网卡的数量
    var nicLimit:Int?
    /// 描述
    var desc:String?
    /// 规格状态
    var state:[InstanceTypeState?]?
    /// Gpu配置
    var gpu:Gpu?
    /// 本地缓存盘配置，目前只有Gpu规格上才有
    var localDisks:[LocalDisk?]?



    public override init(){
            super.init()
    }

    enum InstanceTypeCodingKeys: String, CodingKey {
        case family
        case instanceTypeValue = "instanceType"
        case cpu
        case memoryMB
        case nicLimit
        case desc
        case state
        case gpu
        case localDisks
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: InstanceTypeCodingKeys.self)
        if decoderContainer.contains(.family)
        {
            self.family = try decoderContainer.decode(String?.self, forKey: .family)
        }
        if decoderContainer.contains(.instanceTypeValue)
        {
            self.instanceTypeValue = try decoderContainer.decode(String?.self, forKey: .instanceTypeValue)
        }
        if decoderContainer.contains(.cpu)
        {
            self.cpu = try decoderContainer.decode(Int?.self, forKey: .cpu)
        }
        if decoderContainer.contains(.memoryMB)
        {
            self.memoryMB = try decoderContainer.decode(Int?.self, forKey: .memoryMB)
        }
        if decoderContainer.contains(.nicLimit)
        {
            self.nicLimit = try decoderContainer.decode(Int?.self, forKey: .nicLimit)
        }
        if decoderContainer.contains(.desc)
        {
            self.desc = try decoderContainer.decode(String?.self, forKey: .desc)
        }
        if decoderContainer.contains(.state)
        {
            self.state = try decoderContainer.decode([InstanceTypeState?]?.self, forKey: .state)
        }
        if decoderContainer.contains(.gpu)
        {
            self.gpu = try decoderContainer.decode(Gpu?.self, forKey: .gpu)
        }
        if decoderContainer.contains(.localDisks)
        {
            self.localDisks = try decoderContainer.decode([LocalDisk?]?.self, forKey: .localDisks)
        }
    }
}
public extension InstanceType{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: InstanceTypeCodingKeys.self)
         try encoderContainer.encode(family, forKey: .family)
         try encoderContainer.encode(instanceTypeValue, forKey: .instanceTypeValue)
         try encoderContainer.encode(cpu, forKey: .cpu)
         try encoderContainer.encode(memoryMB, forKey: .memoryMB)
         try encoderContainer.encode(nicLimit, forKey: .nicLimit)
         try encoderContainer.encode(desc, forKey: .desc)
         try encoderContainer.encode(state, forKey: .state)
         try encoderContainer.encode(gpu, forKey: .gpu)
         try encoderContainer.encode(localDisks, forKey: .localDisks)
    }
}
///  描述实例的本地磁盘
public class LocalDisk:NSObject,Codable{
    /// 磁盘类型，取值范围{ssd、premium-hdd、hdd.std1、ssd.gp1、ssd.io1}
    var diskType:String?
    /// 磁盘大小
    var diskSizeGB:Int?



    public override init(){
            super.init()
    }

    enum LocalDiskCodingKeys: String, CodingKey {
        case diskType
        case diskSizeGB
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: LocalDiskCodingKeys.self)
        if decoderContainer.contains(.diskType)
        {
            self.diskType = try decoderContainer.decode(String?.self, forKey: .diskType)
        }
        if decoderContainer.contains(.diskSizeGB)
        {
            self.diskSizeGB = try decoderContainer.decode(Int?.self, forKey: .diskSizeGB)
        }
    }
}
public extension LocalDisk{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: LocalDiskCodingKeys.self)
         try encoderContainer.encode(diskType, forKey: .diskType)
         try encoderContainer.encode(diskSizeGB, forKey: .diskSizeGB)
    }
}
///  描述实例类型Gpu信息
public class Gpu:NSObject,Codable{
    /// GPU型号
    var model:String?
    /// GPU数量
    var number:Int?



    public override init(){
            super.init()
    }

    enum GpuCodingKeys: String, CodingKey {
        case model
        case number
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: GpuCodingKeys.self)
        if decoderContainer.contains(.model)
        {
            self.model = try decoderContainer.decode(String?.self, forKey: .model)
        }
        if decoderContainer.contains(.number)
        {
            self.number = try decoderContainer.decode(Int?.self, forKey: .number)
        }
    }
}
public extension Gpu{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: GpuCodingKeys.self)
         try encoderContainer.encode(model, forKey: .model)
         try encoderContainer.encode(number, forKey: .number)
    }
}
///  instanceTypeState
public class InstanceTypeState:NSObject,Codable{
    /// 可用区
    var az:String?
    /// 可售卖情况，true:可售卖、false:已售罄不可用
    var inStock:Bool?



    public override init(){
            super.init()
    }

    enum InstanceTypeStateCodingKeys: String, CodingKey {
        case az
        case inStock
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: InstanceTypeStateCodingKeys.self)
        if decoderContainer.contains(.az)
        {
            self.az = try decoderContainer.decode(String?.self, forKey: .az)
        }
        if decoderContainer.contains(.inStock)
        {
            self.inStock = try decoderContainer.decode(Bool?.self, forKey: .inStock)
        }
    }
}
public extension InstanceTypeState{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: InstanceTypeStateCodingKeys.self)
         try encoderContainer.encode(az, forKey: .az)
         try encoderContainer.encode(inStock, forKey: .inStock)
    }
}
///  keypair
public class Keypair:NSObject,Codable{
    /// 密钥对名称
    var keyName:String?
    /// 密钥对的指纹，根据 RFC4716 定义的公钥指纹格式，采用 MD5 信息摘要算法。
    var keyFingerprint:String?
    /// 创建时间
    var createTime:String?



    public override init(){
            super.init()
    }

    enum KeypairCodingKeys: String, CodingKey {
        case keyName
        case keyFingerprint
        case createTime
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: KeypairCodingKeys.self)
        if decoderContainer.contains(.keyName)
        {
            self.keyName = try decoderContainer.decode(String?.self, forKey: .keyName)
        }
        if decoderContainer.contains(.keyFingerprint)
        {
            self.keyFingerprint = try decoderContainer.decode(String?.self, forKey: .keyFingerprint)
        }
        if decoderContainer.contains(.createTime)
        {
            self.createTime = try decoderContainer.decode(String?.self, forKey: .createTime)
        }
    }
}
public extension Keypair{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: KeypairCodingKeys.self)
         try encoderContainer.encode(keyName, forKey: .keyName)
         try encoderContainer.encode(keyFingerprint, forKey: .keyFingerprint)
         try encoderContainer.encode(createTime, forKey: .createTime)
    }
}
///  userSysDisk
public class UserSysDisk:NSObject,Codable{
    /// 用户pin
    var pin:String?
    /// 地域
    var region:String?
    /// 系统类型
    var systemType:String?
    /// 默认本地盘系统盘大小
    var systemDiskSize:Int?



    public override init(){
            super.init()
    }

    enum UserSysDiskCodingKeys: String, CodingKey {
        case pin
        case region
        case systemType
        case systemDiskSize
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: UserSysDiskCodingKeys.self)
        if decoderContainer.contains(.pin)
        {
            self.pin = try decoderContainer.decode(String?.self, forKey: .pin)
        }
        if decoderContainer.contains(.region)
        {
            self.region = try decoderContainer.decode(String?.self, forKey: .region)
        }
        if decoderContainer.contains(.systemType)
        {
            self.systemType = try decoderContainer.decode(String?.self, forKey: .systemType)
        }
        if decoderContainer.contains(.systemDiskSize)
        {
            self.systemDiskSize = try decoderContainer.decode(Int?.self, forKey: .systemDiskSize)
        }
    }
}
public extension UserSysDisk{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: UserSysDiskCodingKeys.self)
         try encoderContainer.encode(pin, forKey: .pin)
         try encoderContainer.encode(region, forKey: .region)
         try encoderContainer.encode(systemType, forKey: .systemType)
         try encoderContainer.encode(systemDiskSize, forKey: .systemDiskSize)
    }
}
///  instanceNetworkInterfaceAttachmentSpec
public class InstanceNetworkInterfaceAttachmentSpec:NSObject,Codable{
    /// 网卡设备Index，主网卡只能是1
    var deviceIndex:Int?
    /// 网卡接口规范
    var networkInterface:NetworkInterfaceSpec?



    public override init(){
            super.init()
    }

    enum InstanceNetworkInterfaceAttachmentSpecCodingKeys: String, CodingKey {
        case deviceIndex
        case networkInterface
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: InstanceNetworkInterfaceAttachmentSpecCodingKeys.self)
        if decoderContainer.contains(.deviceIndex)
        {
            self.deviceIndex = try decoderContainer.decode(Int?.self, forKey: .deviceIndex)
        }
        if decoderContainer.contains(.networkInterface)
        {
            self.networkInterface = try decoderContainer.decode(NetworkInterfaceSpec?.self, forKey: .networkInterface)
        }
    }
}
public extension InstanceNetworkInterfaceAttachmentSpec{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: InstanceNetworkInterfaceAttachmentSpecCodingKeys.self)
         try encoderContainer.encode(deviceIndex, forKey: .deviceIndex)
         try encoderContainer.encode(networkInterface, forKey: .networkInterface)
    }
}
///  instanceNetworkAttribute
public class InstanceNetworkAttribute:NSObject,Codable{
    /// 弹性网卡ID
    var networkInterfaceId:String?
    /// 随主机自动删除，默认为False
    var autoDelete:Bool?



    public override init(){
            super.init()
    }

    enum InstanceNetworkAttributeCodingKeys: String, CodingKey {
        case networkInterfaceId
        case autoDelete
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: InstanceNetworkAttributeCodingKeys.self)
        if decoderContainer.contains(.networkInterfaceId)
        {
            self.networkInterfaceId = try decoderContainer.decode(String?.self, forKey: .networkInterfaceId)
        }
        if decoderContainer.contains(.autoDelete)
        {
            self.autoDelete = try decoderContainer.decode(Bool?.self, forKey: .autoDelete)
        }
    }
}
public extension InstanceNetworkAttribute{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: InstanceNetworkAttributeCodingKeys.self)
         try encoderContainer.encode(networkInterfaceId, forKey: .networkInterfaceId)
         try encoderContainer.encode(autoDelete, forKey: .autoDelete)
    }
}
///  instanceNetworkInterfaceAttachment
public class InstanceNetworkInterfaceAttachment:NSObject,Codable{
    /// 设备Index
    var deviceIndex:Int?
    /// 指明删除实例时是否删除网卡，默认true；当前只能是true
    var autoDelete:Bool?
    /// 网卡接口规范
    var networkInterface:InstanceNetworkInterface?



    public override init(){
            super.init()
    }

    enum InstanceNetworkInterfaceAttachmentCodingKeys: String, CodingKey {
        case deviceIndex
        case autoDelete
        case networkInterface
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: InstanceNetworkInterfaceAttachmentCodingKeys.self)
        if decoderContainer.contains(.deviceIndex)
        {
            self.deviceIndex = try decoderContainer.decode(Int?.self, forKey: .deviceIndex)
        }
        if decoderContainer.contains(.autoDelete)
        {
            self.autoDelete = try decoderContainer.decode(Bool?.self, forKey: .autoDelete)
        }
        if decoderContainer.contains(.networkInterface)
        {
            self.networkInterface = try decoderContainer.decode(InstanceNetworkInterface?.self, forKey: .networkInterface)
        }
    }
}
public extension InstanceNetworkInterfaceAttachment{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: InstanceNetworkInterfaceAttachmentCodingKeys.self)
         try encoderContainer.encode(deviceIndex, forKey: .deviceIndex)
         try encoderContainer.encode(autoDelete, forKey: .autoDelete)
         try encoderContainer.encode(networkInterface, forKey: .networkInterface)
    }
}
///  instanceStatus
public class InstanceStatus:NSObject,Codable{
    /// 云主机ID
    var instanceId:String?
    /// &lt;a href&#x3D;&quot;http://docs.jdcloud.com/virtual-machines/api/vm_status&quot;&gt;参考云主机状态&lt;/a&gt;
    var status:String?



    public override init(){
            super.init()
    }

    enum InstanceStatusCodingKeys: String, CodingKey {
        case instanceId
        case status
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: InstanceStatusCodingKeys.self)
        if decoderContainer.contains(.instanceId)
        {
            self.instanceId = try decoderContainer.decode(String?.self, forKey: .instanceId)
        }
        if decoderContainer.contains(.status)
        {
            self.status = try decoderContainer.decode(String?.self, forKey: .status)
        }
    }
}
public extension InstanceStatus{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: InstanceStatusCodingKeys.self)
         try encoderContainer.encode(instanceId, forKey: .instanceId)
         try encoderContainer.encode(status, forKey: .status)
    }
}
///  描述实例绑定的安全组
public class SecurityGroupSimple:NSObject,Codable{
    /// 安全组ID
    var groupId:String?
    /// 安全组名称
    var groupName:String?



    public override init(){
            super.init()
    }

    enum SecurityGroupSimpleCodingKeys: String, CodingKey {
        case groupId
        case groupName
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: SecurityGroupSimpleCodingKeys.self)
        if decoderContainer.contains(.groupId)
        {
            self.groupId = try decoderContainer.decode(String?.self, forKey: .groupId)
        }
        if decoderContainer.contains(.groupName)
        {
            self.groupName = try decoderContainer.decode(String?.self, forKey: .groupName)
        }
    }
}
public extension SecurityGroupSimple{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: SecurityGroupSimpleCodingKeys.self)
         try encoderContainer.encode(groupId, forKey: .groupId)
         try encoderContainer.encode(groupName, forKey: .groupName)
    }
}
///  instanceDiskAttachmentSpec
public class InstanceDiskAttachmentSpec:NSObject,Codable{
    /// 磁盘分类，取值为本地盘(local)或者云硬盘(cloud)。
      /// 系统盘支持本地盘(local)或者云硬盘(cloud)。系统盘选择local类型，必须使用localDisk类型的镜像；同理系统盘选择cloud类型，必须使用cloudDisk类型的镜像。
      /// 数据盘仅支持云硬盘(cloud)。
      /// 
    var diskCategory:String?
    /// 是否随云主机一起删除，即删除主机时是否自动删除此磁盘，默认为true，本地盘(local)不能更改此值。
      /// 如果云主机中的数据盘(cloud)是包年包月计费方式，此参数不生效。
      /// 如果云主机中的数据盘(cloud)是共享型数据盘，此参数不生效。
      /// 
    var autoDelete:Bool?
    /// 数据盘配置
    var cloudDiskSpec:DiskSpec?
    /// 数据盘逻辑挂载点，取值范围：vda,vdb,vdc,vdd,vde,vdf,vdg,vdh,vdi,vmj,vdk,vdl,vdm
    var deviceName:String?
    /// 排除设备，使用此参数noDevice配合deviceName一起使用。
      /// 创建整机镜像：如deviceName:vdb、noDevice:true，则表示云主机中的数据盘vdb不参与创建镜像。
      /// 创建模板：如deviceName:vdb、noDevice:true，则表示镜像中的数据盘vdb不参与创建主机。
      /// 创建主机：如deviceName:vdb、noDevice:true，则表示镜像中的数据盘vdb，或者模板(使用模板创建主机)中的数据盘vdb不参与创建主机。
      /// 
    var noDevice:Bool?



    public override init(){
            super.init()
    }

    enum InstanceDiskAttachmentSpecCodingKeys: String, CodingKey {
        case diskCategory
        case autoDelete
        case cloudDiskSpec
        case deviceName
        case noDevice
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: InstanceDiskAttachmentSpecCodingKeys.self)
        if decoderContainer.contains(.diskCategory)
        {
            self.diskCategory = try decoderContainer.decode(String?.self, forKey: .diskCategory)
        }
        if decoderContainer.contains(.autoDelete)
        {
            self.autoDelete = try decoderContainer.decode(Bool?.self, forKey: .autoDelete)
        }
        if decoderContainer.contains(.cloudDiskSpec)
        {
            self.cloudDiskSpec = try decoderContainer.decode(DiskSpec?.self, forKey: .cloudDiskSpec)
        }
        if decoderContainer.contains(.deviceName)
        {
            self.deviceName = try decoderContainer.decode(String?.self, forKey: .deviceName)
        }
        if decoderContainer.contains(.noDevice)
        {
            self.noDevice = try decoderContainer.decode(Bool?.self, forKey: .noDevice)
        }
    }
}
public extension InstanceDiskAttachmentSpec{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: InstanceDiskAttachmentSpecCodingKeys.self)
         try encoderContainer.encode(diskCategory, forKey: .diskCategory)
         try encoderContainer.encode(autoDelete, forKey: .autoDelete)
         try encoderContainer.encode(cloudDiskSpec, forKey: .cloudDiskSpec)
         try encoderContainer.encode(deviceName, forKey: .deviceName)
         try encoderContainer.encode(noDevice, forKey: .noDevice)
    }
}
///  instanceDiskAttachment
public class InstanceDiskAttachment:NSObject,Codable{
    /// 磁盘分类，取值为本地盘(local)或者数据盘(cloud)。
      /// 系统盘支持本地盘(local)或者云硬盘(cloud)。系统盘选择local类型，必须使用localDisk类型的镜像；同理系统盘选择cloud类型，必须使用cloudDisk类型的镜像。
      /// 数据盘仅支持云硬盘(cloud)。
      /// 
    var diskCategory:String?
    /// 随云主机一起删除，删除主机时自动删除此磁盘，默认为true，本地盘(local)不能更改此值。
      /// 如果云主机中的数据盘(cloud)是包年包月计费方式，此参数不生效。
      /// 如果云主机中的数据盘(cloud)是共享型数据盘，此参数不生效。
      /// 
    var autoDelete:Bool?
    /// 本地磁盘配置
    var localDisk:LocalDisk?
    /// 云硬盘配置
    var cloudDisk:Disk?
    /// 数据盘逻辑挂载点，取值范围：vda,vdb,vdc,vdd,vde,vdf,vdg,vdh,vdi,vmj,vdk,vdl,vdm
    var deviceName:String?
    /// 数据盘挂载状态，取值范围：attaching,detaching,attached,detached,error_attach,error_detach
    var status:String?



    public override init(){
            super.init()
    }

    enum InstanceDiskAttachmentCodingKeys: String, CodingKey {
        case diskCategory
        case autoDelete
        case localDisk
        case cloudDisk
        case deviceName
        case status
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: InstanceDiskAttachmentCodingKeys.self)
        if decoderContainer.contains(.diskCategory)
        {
            self.diskCategory = try decoderContainer.decode(String?.self, forKey: .diskCategory)
        }
        if decoderContainer.contains(.autoDelete)
        {
            self.autoDelete = try decoderContainer.decode(Bool?.self, forKey: .autoDelete)
        }
        if decoderContainer.contains(.localDisk)
        {
            self.localDisk = try decoderContainer.decode(LocalDisk?.self, forKey: .localDisk)
        }
        if decoderContainer.contains(.cloudDisk)
        {
            self.cloudDisk = try decoderContainer.decode(Disk?.self, forKey: .cloudDisk)
        }
        if decoderContainer.contains(.deviceName)
        {
            self.deviceName = try decoderContainer.decode(String?.self, forKey: .deviceName)
        }
        if decoderContainer.contains(.status)
        {
            self.status = try decoderContainer.decode(String?.self, forKey: .status)
        }
    }
}
public extension InstanceDiskAttachment{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: InstanceDiskAttachmentCodingKeys.self)
         try encoderContainer.encode(diskCategory, forKey: .diskCategory)
         try encoderContainer.encode(autoDelete, forKey: .autoDelete)
         try encoderContainer.encode(localDisk, forKey: .localDisk)
         try encoderContainer.encode(cloudDisk, forKey: .cloudDisk)
         try encoderContainer.encode(deviceName, forKey: .deviceName)
         try encoderContainer.encode(status, forKey: .status)
    }
}
///  instancePrivateIpAddress
public class InstancePrivateIpAddress:NSObject,Codable{
    /// 云主机ID
    var instanceId:String?
    /// 主网卡内网主IP地址
    var privateIpAddress:String?



    public override init(){
            super.init()
    }

    enum InstancePrivateIpAddressCodingKeys: String, CodingKey {
        case instanceId
        case privateIpAddress
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: InstancePrivateIpAddressCodingKeys.self)
        if decoderContainer.contains(.instanceId)
        {
            self.instanceId = try decoderContainer.decode(String?.self, forKey: .instanceId)
        }
        if decoderContainer.contains(.privateIpAddress)
        {
            self.privateIpAddress = try decoderContainer.decode(String?.self, forKey: .privateIpAddress)
        }
    }
}
public extension InstancePrivateIpAddress{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: InstancePrivateIpAddressCodingKeys.self)
         try encoderContainer.encode(instanceId, forKey: .instanceId)
         try encoderContainer.encode(privateIpAddress, forKey: .privateIpAddress)
    }
}
///  instanceSpec
public class InstanceSpec:NSObject,Codable{
    /// 高可用组Id。指定了此参数后，只能通过高可用组关联的实例模板创建虚机，并且实例模板中的参数不可覆盖替换。实例模板以外的参数还可以指定。
    var agId:String?
    /// 实例模板id，如果没有使用高可用组，那么对于实例模板中没有的信息，需要使用创建虚机的参数进行补充，或者选择覆盖启动模板中的参数。
    var instanceTemplateId:String?
    /// 云主机所属的可用区。
    var az:String?
    /// 实例规格。可查询&lt;a href&#x3D;&quot;http://docs.jdcloud.com/virtual-machines/api/describeinstancetypes&quot;&gt;DescribeInstanceTypes&lt;/a&gt;接口获得指定地域或可用区的规格信息。
    var instanceType:String?
    /// 镜像ID。可查询&lt;a href&#x3D;&quot;http://docs.jdcloud.com/virtual-machines/api/describeimages&quot;&gt;DescribeImages&lt;/a&gt;接口获得指定地域的镜像信息。
    var imageId:String?
    /// 云主机名称，&lt;a href&#x3D;&quot;http://docs.jdcloud.com/virtual-machines/api/general_parameters&quot;&gt;参考公共参数规范&lt;/a&gt;。
    /// Required:true
    var name:String
    /// 密码，&lt;a href&#x3D;&quot;http://docs.jdcloud.com/virtual-machines/api/general_parameters&quot;&gt;参考公共参数规范&lt;/a&gt;。
    var password:String?
    /// 密钥对名称，当前只支持传入一个。
    var keyNames:[String?]?
    /// 主网卡主IP关联的弹性IP规格
    var elasticIp:ElasticIpSpec?
    /// 主网卡配置信息
    var primaryNetworkInterface:InstanceNetworkInterfaceAttachmentSpec?
    /// 系统盘配置信息
    var systemDisk:InstanceDiskAttachmentSpec?
    /// 数据盘配置信息，本地盘(local类型)做系统盘的云主机可挂载8块数据盘，云硬盘(cloud类型)做系统盘的云主机可挂载7块数据盘。
    var dataDisks:[InstanceDiskAttachmentSpec?]?
    /// 计费配置
      /// 云主机不支持按用量方式计费，默认为按配置计费。
      /// 打包创建数据盘的情况下，数据盘的计费方式只能与云主机保持一致。
      /// 打包创建弹性公网IP的情况下，若公网IP的计费方式没有指定为按用量计费，那么公网IP计费方式只能与云主机保持一致。
      /// 
    var charge:ChargeSpec?
    /// 元数据信息，目前只支持传入一个key为&quot;launch-script&quot;，表示首次启动脚本。value为base64格式。
      /// launch-script：linux系统支持bash和python，编码前须分别以 #!/bin/bash 和 #!/usr/bin/env python 作为内容首行;
      /// launch-script：windows系统支持bat和powershell，编码前须分别以 &lt;cmd&gt;&lt;/cmd&gt; 和 &lt;powershell&gt;&lt;/powershell&gt; 作为内容首、尾行。
      /// 
    var userdata:[Userdata?]?
    /// 主机描述，&lt;a href&#x3D;&quot;http://docs.jdcloud.com/virtual-machines/api/general_parameters&quot;&gt;参考公共参数规范&lt;/a&gt;。
    var descriptionValue:String?
    /// 不使用模板中的密码。
      /// 仅当不使用Ag，并且使用了模板，并且password参数为空时，此参数(值为true)生效。
      /// 若使用模板创建虚机时，又指定了password参数时，此参数无效，以新指定的为准。
      /// 
    var noPassword:Bool?
    /// 不使用模板中的密钥。
      /// 仅当不使用Ag，并且使用了模板，并且keynames参数为空时，此参数(值为true)生效。
      /// 若使用模板创建虚机时，又指定了keynames参数时，此参数无效，以新指定的为准。
      /// 
    var noKeyNames:Bool?
    /// 不使用模板中的弹性公网IP。
      /// 仅当不使用Ag，并且使用了模板，并且elasticIp参数为空时，此参数(值为true)生效。
      /// 若使用模板创建虚机时，又指定了elasticIp参数时，此参数无效，以新指定的为准。
      /// 
    var noElasticIp:Bool?
    /// 用户普通标签集合
    var userTags:[Tag?]?



    public  init(name:String){
             self.name = name
    }

    enum InstanceSpecCodingKeys: String, CodingKey {
        case agId
        case instanceTemplateId
        case az
        case instanceType
        case imageId
        case name
        case password
        case keyNames
        case elasticIp
        case primaryNetworkInterface
        case systemDisk
        case dataDisks
        case charge
        case userdata
        case descriptionValue = "description"
        case noPassword
        case noKeyNames
        case noElasticIp
        case userTags
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: InstanceSpecCodingKeys.self)
        if decoderContainer.contains(.agId)
        {
            self.agId = try decoderContainer.decode(String?.self, forKey: .agId)
        }
        if decoderContainer.contains(.instanceTemplateId)
        {
            self.instanceTemplateId = try decoderContainer.decode(String?.self, forKey: .instanceTemplateId)
        }
        if decoderContainer.contains(.az)
        {
            self.az = try decoderContainer.decode(String?.self, forKey: .az)
        }
        if decoderContainer.contains(.instanceType)
        {
            self.instanceType = try decoderContainer.decode(String?.self, forKey: .instanceType)
        }
        if decoderContainer.contains(.imageId)
        {
            self.imageId = try decoderContainer.decode(String?.self, forKey: .imageId)
        }
        self.name = try decoderContainer.decode(String.self, forKey: .name)
        if decoderContainer.contains(.password)
        {
            self.password = try decoderContainer.decode(String?.self, forKey: .password)
        }
        if decoderContainer.contains(.keyNames)
        {
            self.keyNames = try decoderContainer.decode([String?]?.self, forKey: .keyNames)
        }
        if decoderContainer.contains(.elasticIp)
        {
            self.elasticIp = try decoderContainer.decode(ElasticIpSpec?.self, forKey: .elasticIp)
        }
        if decoderContainer.contains(.primaryNetworkInterface)
        {
            self.primaryNetworkInterface = try decoderContainer.decode(InstanceNetworkInterfaceAttachmentSpec?.self, forKey: .primaryNetworkInterface)
        }
        if decoderContainer.contains(.systemDisk)
        {
            self.systemDisk = try decoderContainer.decode(InstanceDiskAttachmentSpec?.self, forKey: .systemDisk)
        }
        if decoderContainer.contains(.dataDisks)
        {
            self.dataDisks = try decoderContainer.decode([InstanceDiskAttachmentSpec?]?.self, forKey: .dataDisks)
        }
        if decoderContainer.contains(.charge)
        {
            self.charge = try decoderContainer.decode(ChargeSpec?.self, forKey: .charge)
        }
        if decoderContainer.contains(.userdata)
        {
            self.userdata = try decoderContainer.decode([Userdata?]?.self, forKey: .userdata)
        }
        if decoderContainer.contains(.descriptionValue)
        {
            self.descriptionValue = try decoderContainer.decode(String?.self, forKey: .descriptionValue)
        }
        if decoderContainer.contains(.noPassword)
        {
            self.noPassword = try decoderContainer.decode(Bool?.self, forKey: .noPassword)
        }
        if decoderContainer.contains(.noKeyNames)
        {
            self.noKeyNames = try decoderContainer.decode(Bool?.self, forKey: .noKeyNames)
        }
        if decoderContainer.contains(.noElasticIp)
        {
            self.noElasticIp = try decoderContainer.decode(Bool?.self, forKey: .noElasticIp)
        }
        if decoderContainer.contains(.userTags)
        {
            self.userTags = try decoderContainer.decode([Tag?]?.self, forKey: .userTags)
        }
    }
}
public extension InstanceSpec{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: InstanceSpecCodingKeys.self)
         try encoderContainer.encode(agId, forKey: .agId)
         try encoderContainer.encode(instanceTemplateId, forKey: .instanceTemplateId)
         try encoderContainer.encode(az, forKey: .az)
         try encoderContainer.encode(instanceType, forKey: .instanceType)
         try encoderContainer.encode(imageId, forKey: .imageId)
         try encoderContainer.encode(name, forKey: .name)
         try encoderContainer.encode(password, forKey: .password)
         try encoderContainer.encode(keyNames, forKey: .keyNames)
         try encoderContainer.encode(elasticIp, forKey: .elasticIp)
         try encoderContainer.encode(primaryNetworkInterface, forKey: .primaryNetworkInterface)
         try encoderContainer.encode(systemDisk, forKey: .systemDisk)
         try encoderContainer.encode(dataDisks, forKey: .dataDisks)
         try encoderContainer.encode(charge, forKey: .charge)
         try encoderContainer.encode(userdata, forKey: .userdata)
         try encoderContainer.encode(descriptionValue, forKey: .descriptionValue)
         try encoderContainer.encode(noPassword, forKey: .noPassword)
         try encoderContainer.encode(noKeyNames, forKey: .noKeyNames)
         try encoderContainer.encode(noElasticIp, forKey: .noElasticIp)
         try encoderContainer.encode(userTags, forKey: .userTags)
    }
}
///  userdata
public class Userdata:NSObject,Codable{
    /// 键
    var key:String?
    /// 值
    var value:String?



    public override init(){
            super.init()
    }

    enum UserdataCodingKeys: String, CodingKey {
        case key
        case value
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: UserdataCodingKeys.self)
        if decoderContainer.contains(.key)
        {
            self.key = try decoderContainer.decode(String?.self, forKey: .key)
        }
        if decoderContainer.contains(.value)
        {
            self.value = try decoderContainer.decode(String?.self, forKey: .value)
        }
    }
}
public extension Userdata{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: UserdataCodingKeys.self)
         try encoderContainer.encode(key, forKey: .key)
         try encoderContainer.encode(value, forKey: .value)
    }
}
///  instanceDiskAttribute
public class InstanceDiskAttribute:NSObject,Codable{
    /// 云硬盘ID
    var diskId:String?
    /// 随云主机一起删除，删除主机时自动删除此磁盘，默认为false，本地盘(local)不能更改此值。
      /// 如果云主机中的数据盘(cloud)是包年包月计费方式，此参数不生效。
      /// 如果云主机中的数据盘(cloud)是共享型数据盘，此参数不生效。
      /// 
    var autoDelete:Bool?



    public override init(){
            super.init()
    }

    enum InstanceDiskAttributeCodingKeys: String, CodingKey {
        case diskId
        case autoDelete
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: InstanceDiskAttributeCodingKeys.self)
        if decoderContainer.contains(.diskId)
        {
            self.diskId = try decoderContainer.decode(String?.self, forKey: .diskId)
        }
        if decoderContainer.contains(.autoDelete)
        {
            self.autoDelete = try decoderContainer.decode(Bool?.self, forKey: .autoDelete)
        }
    }
}
public extension InstanceDiskAttribute{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: InstanceDiskAttributeCodingKeys.self)
         try encoderContainer.encode(diskId, forKey: .diskId)
         try encoderContainer.encode(autoDelete, forKey: .autoDelete)
    }
}
///  instanceNetworkInterface
public class InstanceNetworkInterface:NSObject,Codable{
    /// 弹性网卡ID
    var networkInterfaceId:String?
    /// 以太网地址
    var macAddress:String?
    /// 虚拟网络ID
    var vpcId:String?
    /// 子网ID
    var subnetId:String?
    /// SecurityGroups
    var securityGroups:[SecurityGroupSimple?]?
    /// 源和目标IP地址校验，取值为0或者1
    var sanityCheck:Int?
    /// 网卡主IP
    var primaryIp:NetworkInterfacePrivateIp?
    /// 网卡辅IP
    var secondaryIps:[NetworkInterfacePrivateIp?]?



    public override init(){
            super.init()
    }

    enum InstanceNetworkInterfaceCodingKeys: String, CodingKey {
        case networkInterfaceId
        case macAddress
        case vpcId
        case subnetId
        case securityGroups
        case sanityCheck
        case primaryIp
        case secondaryIps
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: InstanceNetworkInterfaceCodingKeys.self)
        if decoderContainer.contains(.networkInterfaceId)
        {
            self.networkInterfaceId = try decoderContainer.decode(String?.self, forKey: .networkInterfaceId)
        }
        if decoderContainer.contains(.macAddress)
        {
            self.macAddress = try decoderContainer.decode(String?.self, forKey: .macAddress)
        }
        if decoderContainer.contains(.vpcId)
        {
            self.vpcId = try decoderContainer.decode(String?.self, forKey: .vpcId)
        }
        if decoderContainer.contains(.subnetId)
        {
            self.subnetId = try decoderContainer.decode(String?.self, forKey: .subnetId)
        }
        if decoderContainer.contains(.securityGroups)
        {
            self.securityGroups = try decoderContainer.decode([SecurityGroupSimple?]?.self, forKey: .securityGroups)
        }
        if decoderContainer.contains(.sanityCheck)
        {
            self.sanityCheck = try decoderContainer.decode(Int?.self, forKey: .sanityCheck)
        }
        if decoderContainer.contains(.primaryIp)
        {
            self.primaryIp = try decoderContainer.decode(NetworkInterfacePrivateIp?.self, forKey: .primaryIp)
        }
        if decoderContainer.contains(.secondaryIps)
        {
            self.secondaryIps = try decoderContainer.decode([NetworkInterfacePrivateIp?]?.self, forKey: .secondaryIps)
        }
    }
}
public extension InstanceNetworkInterface{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: InstanceNetworkInterfaceCodingKeys.self)
         try encoderContainer.encode(networkInterfaceId, forKey: .networkInterfaceId)
         try encoderContainer.encode(macAddress, forKey: .macAddress)
         try encoderContainer.encode(vpcId, forKey: .vpcId)
         try encoderContainer.encode(subnetId, forKey: .subnetId)
         try encoderContainer.encode(securityGroups, forKey: .securityGroups)
         try encoderContainer.encode(sanityCheck, forKey: .sanityCheck)
         try encoderContainer.encode(primaryIp, forKey: .primaryIp)
         try encoderContainer.encode(secondaryIps, forKey: .secondaryIps)
    }
}
///  instance
public class Instance:NSObject,Codable{
    /// 云主机ID
    var instanceId:String?
    /// 云主机名称
    var instanceName:String?
    /// 实例规格
    var instanceType:String?
    /// 主网卡所属VPC的ID
    var vpcId:String?
    /// 主网卡所属子网的ID
    var subnetId:String?
    /// 主网卡主IP地址
    var privateIpAddress:String?
    /// 主网卡主IP绑定弹性IP的ID
    var elasticIpId:String?
    /// 主网卡主IP绑定弹性IP的地址
    var elasticIpAddress:String?
    /// 云主机状态，&lt;a href&#x3D;&quot;http://docs.jdcloud.com/virtual-machines/api/vm_status&quot;&gt;参考云主机状态&lt;/a&gt;
    var status:String?
    /// 云主机描述
    var descriptionValue:String?
    /// 镜像ID
    var imageId:String?
    /// 系统盘配置
    var systemDisk:InstanceDiskAttachment?
    /// 数据盘配置
    var dataDisks:[InstanceDiskAttachment?]?
    /// 主网卡配置
    var primaryNetworkInterface:InstanceNetworkInterfaceAttachment?
    /// 辅助网卡配置
    var secondaryNetworkInterfaces:[InstanceNetworkInterfaceAttachment?]?
    /// 创建时间
    var launchTime:String?
    /// 云主机所在可用区
    var az:String?
    /// 密钥对名称
    var keyNames:[String?]?
    /// 计费信息
    var charge:Charge?
    /// 高可用组，如果创建云主机使用了高可用组，此处可展示高可用组名称
    var ag:Ag?
    /// 高可用组中的错误域
    var faultDomain:String?
    /// Tag信息
    var tags:[Tag?]?



    public override init(){
            super.init()
    }

    enum InstanceCodingKeys: String, CodingKey {
        case instanceId
        case instanceName
        case instanceType
        case vpcId
        case subnetId
        case privateIpAddress
        case elasticIpId
        case elasticIpAddress
        case status
        case descriptionValue = "description"
        case imageId
        case systemDisk
        case dataDisks
        case primaryNetworkInterface
        case secondaryNetworkInterfaces
        case launchTime
        case az
        case keyNames
        case charge
        case ag
        case faultDomain
        case tags
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: InstanceCodingKeys.self)
        if decoderContainer.contains(.instanceId)
        {
            self.instanceId = try decoderContainer.decode(String?.self, forKey: .instanceId)
        }
        if decoderContainer.contains(.instanceName)
        {
            self.instanceName = try decoderContainer.decode(String?.self, forKey: .instanceName)
        }
        if decoderContainer.contains(.instanceType)
        {
            self.instanceType = try decoderContainer.decode(String?.self, forKey: .instanceType)
        }
        if decoderContainer.contains(.vpcId)
        {
            self.vpcId = try decoderContainer.decode(String?.self, forKey: .vpcId)
        }
        if decoderContainer.contains(.subnetId)
        {
            self.subnetId = try decoderContainer.decode(String?.self, forKey: .subnetId)
        }
        if decoderContainer.contains(.privateIpAddress)
        {
            self.privateIpAddress = try decoderContainer.decode(String?.self, forKey: .privateIpAddress)
        }
        if decoderContainer.contains(.elasticIpId)
        {
            self.elasticIpId = try decoderContainer.decode(String?.self, forKey: .elasticIpId)
        }
        if decoderContainer.contains(.elasticIpAddress)
        {
            self.elasticIpAddress = try decoderContainer.decode(String?.self, forKey: .elasticIpAddress)
        }
        if decoderContainer.contains(.status)
        {
            self.status = try decoderContainer.decode(String?.self, forKey: .status)
        }
        if decoderContainer.contains(.descriptionValue)
        {
            self.descriptionValue = try decoderContainer.decode(String?.self, forKey: .descriptionValue)
        }
        if decoderContainer.contains(.imageId)
        {
            self.imageId = try decoderContainer.decode(String?.self, forKey: .imageId)
        }
        if decoderContainer.contains(.systemDisk)
        {
            self.systemDisk = try decoderContainer.decode(InstanceDiskAttachment?.self, forKey: .systemDisk)
        }
        if decoderContainer.contains(.dataDisks)
        {
            self.dataDisks = try decoderContainer.decode([InstanceDiskAttachment?]?.self, forKey: .dataDisks)
        }
        if decoderContainer.contains(.primaryNetworkInterface)
        {
            self.primaryNetworkInterface = try decoderContainer.decode(InstanceNetworkInterfaceAttachment?.self, forKey: .primaryNetworkInterface)
        }
        if decoderContainer.contains(.secondaryNetworkInterfaces)
        {
            self.secondaryNetworkInterfaces = try decoderContainer.decode([InstanceNetworkInterfaceAttachment?]?.self, forKey: .secondaryNetworkInterfaces)
        }
        if decoderContainer.contains(.launchTime)
        {
            self.launchTime = try decoderContainer.decode(String?.self, forKey: .launchTime)
        }
        if decoderContainer.contains(.az)
        {
            self.az = try decoderContainer.decode(String?.self, forKey: .az)
        }
        if decoderContainer.contains(.keyNames)
        {
            self.keyNames = try decoderContainer.decode([String?]?.self, forKey: .keyNames)
        }
        if decoderContainer.contains(.charge)
        {
            self.charge = try decoderContainer.decode(Charge?.self, forKey: .charge)
        }
        if decoderContainer.contains(.ag)
        {
            self.ag = try decoderContainer.decode(Ag?.self, forKey: .ag)
        }
        if decoderContainer.contains(.faultDomain)
        {
            self.faultDomain = try decoderContainer.decode(String?.self, forKey: .faultDomain)
        }
        if decoderContainer.contains(.tags)
        {
            self.tags = try decoderContainer.decode([Tag?]?.self, forKey: .tags)
        }
    }
}
public extension Instance{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: InstanceCodingKeys.self)
         try encoderContainer.encode(instanceId, forKey: .instanceId)
         try encoderContainer.encode(instanceName, forKey: .instanceName)
         try encoderContainer.encode(instanceType, forKey: .instanceType)
         try encoderContainer.encode(vpcId, forKey: .vpcId)
         try encoderContainer.encode(subnetId, forKey: .subnetId)
         try encoderContainer.encode(privateIpAddress, forKey: .privateIpAddress)
         try encoderContainer.encode(elasticIpId, forKey: .elasticIpId)
         try encoderContainer.encode(elasticIpAddress, forKey: .elasticIpAddress)
         try encoderContainer.encode(status, forKey: .status)
         try encoderContainer.encode(descriptionValue, forKey: .descriptionValue)
         try encoderContainer.encode(imageId, forKey: .imageId)
         try encoderContainer.encode(systemDisk, forKey: .systemDisk)
         try encoderContainer.encode(dataDisks, forKey: .dataDisks)
         try encoderContainer.encode(primaryNetworkInterface, forKey: .primaryNetworkInterface)
         try encoderContainer.encode(secondaryNetworkInterfaces, forKey: .secondaryNetworkInterfaces)
         try encoderContainer.encode(launchTime, forKey: .launchTime)
         try encoderContainer.encode(az, forKey: .az)
         try encoderContainer.encode(keyNames, forKey: .keyNames)
         try encoderContainer.encode(charge, forKey: .charge)
         try encoderContainer.encode(ag, forKey: .ag)
         try encoderContainer.encode(faultDomain, forKey: .faultDomain)
         try encoderContainer.encode(tags, forKey: .tags)
    }
}
///  copyImage
public class CopyImage:NSObject,Codable{
    /// 复制后的目标镜像ID
    var destinationImageId:String?
    /// 源镜像ID
    var sourceImageId:String?



    public override init(){
            super.init()
    }

    enum CopyImageCodingKeys: String, CodingKey {
        case destinationImageId
        case sourceImageId
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: CopyImageCodingKeys.self)
        if decoderContainer.contains(.destinationImageId)
        {
            self.destinationImageId = try decoderContainer.decode(String?.self, forKey: .destinationImageId)
        }
        if decoderContainer.contains(.sourceImageId)
        {
            self.sourceImageId = try decoderContainer.decode(String?.self, forKey: .sourceImageId)
        }
    }
}
public extension CopyImage{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: CopyImageCodingKeys.self)
         try encoderContainer.encode(destinationImageId, forKey: .destinationImageId)
         try encoderContainer.encode(sourceImageId, forKey: .sourceImageId)
    }
}
///  imageInstanceTypeConstraint
public class ImageInstanceTypeConstraint:NSObject,Codable{
    /// 限制类型。取值：excludes：不支持的实例类型；includes：支持的实例类型。
    var constraintsType:String?
    /// 实例规格列表
    var instanceTypes:[String?]?



    public override init(){
            super.init()
    }

    enum ImageInstanceTypeConstraintCodingKeys: String, CodingKey {
        case constraintsType
        case instanceTypes
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: ImageInstanceTypeConstraintCodingKeys.self)
        if decoderContainer.contains(.constraintsType)
        {
            self.constraintsType = try decoderContainer.decode(String?.self, forKey: .constraintsType)
        }
        if decoderContainer.contains(.instanceTypes)
        {
            self.instanceTypes = try decoderContainer.decode([String?]?.self, forKey: .instanceTypes)
        }
    }
}
public extension ImageInstanceTypeConstraint{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: ImageInstanceTypeConstraintCodingKeys.self)
         try encoderContainer.encode(constraintsType, forKey: .constraintsType)
         try encoderContainer.encode(instanceTypes, forKey: .instanceTypes)
    }
}
///  taskInfo
public class TaskInfo:NSObject,Codable{
    /// 任务id
    var taskId:Int?
    /// 任务操作类型
    var action:String?
    /// 任务状态，pending,running,failed,finished
    var taskStatus:String?
    /// 任务进度，0-100
    var progress:Int?
    /// 额外信息
    var message:String?
    /// 任务创建时间
    var createdTime:String?
    /// 任务完成时间
    var finishedTime:String?



    public override init(){
            super.init()
    }

    enum TaskInfoCodingKeys: String, CodingKey {
        case taskId
        case action
        case taskStatus
        case progress
        case message
        case createdTime
        case finishedTime
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: TaskInfoCodingKeys.self)
        if decoderContainer.contains(.taskId)
        {
            self.taskId = try decoderContainer.decode(Int?.self, forKey: .taskId)
        }
        if decoderContainer.contains(.action)
        {
            self.action = try decoderContainer.decode(String?.self, forKey: .action)
        }
        if decoderContainer.contains(.taskStatus)
        {
            self.taskStatus = try decoderContainer.decode(String?.self, forKey: .taskStatus)
        }
        if decoderContainer.contains(.progress)
        {
            self.progress = try decoderContainer.decode(Int?.self, forKey: .progress)
        }
        if decoderContainer.contains(.message)
        {
            self.message = try decoderContainer.decode(String?.self, forKey: .message)
        }
        if decoderContainer.contains(.createdTime)
        {
            self.createdTime = try decoderContainer.decode(String?.self, forKey: .createdTime)
        }
        if decoderContainer.contains(.finishedTime)
        {
            self.finishedTime = try decoderContainer.decode(String?.self, forKey: .finishedTime)
        }
    }
}
public extension TaskInfo{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: TaskInfoCodingKeys.self)
         try encoderContainer.encode(taskId, forKey: .taskId)
         try encoderContainer.encode(action, forKey: .action)
         try encoderContainer.encode(taskStatus, forKey: .taskStatus)
         try encoderContainer.encode(progress, forKey: .progress)
         try encoderContainer.encode(message, forKey: .message)
         try encoderContainer.encode(createdTime, forKey: .createdTime)
         try encoderContainer.encode(finishedTime, forKey: .finishedTime)
    }
}
///  image
public class Image:NSObject,Codable{
    /// 镜像ID
    var imageId:String?
    /// 镜像名称
    var name:String?
    /// 镜像的操作系统发行版。取值：Ubuntu,CentOS,Windows Server
    var platform:String?
    /// 镜像的操作系统版本。
    var osVersion:String?
    /// 镜像架构。取值：i386,x86_64
    var architecture:String?
    /// 镜像系统盘大小
    var systemDiskSizeGB:Int?
    /// 镜像来源。取值：jcloud：官方镜像；marketplace：镜像市场镜像；self：用户自己的镜像；shared：其他用户分享的镜像
    var imageSource:String?
    /// 镜像的操作系统类型。取值：windows,linux
    var osType:String?
    /// &lt;a href&#x3D;&quot;http://docs.jdcloud.com/virtual-machines/api/image_status&quot;&gt;参考镜像状态&lt;/a&gt;
    var status:String?
    /// 创建时间
    var createTime:String?
    /// 镜像文件实际大小
    var sizeMB:Int?
    /// 镜像描述
    var desc:String?
    /// 该镜像所有者的用户PIN
    var ownerPin:String?
    /// 镜像的使用权限，取值：all（所有人可用）， specifiedUsers（共享用户可用），ownerOnly（镜像所有者自己可用）
    var launchPermission:String?
    /// 镜像系统盘配置
    var systemDisk:InstanceDiskAttachment?
    /// 镜像数据盘映射信息
    var dataDisks:[InstanceDiskAttachment?]?
    /// 创建云盘系统盘所使用的云硬盘快照ID。系统盘类型为本地盘的镜像，此参数为空。
    var snapshotId:String?
    /// 镜像支持的系统盘类型。取值：localDisk：本地盘系统盘；cloudDisk：云盘系统盘。
    var rootDeviceType:String?
    /// 镜像复制和转换时的进度，仅显示数值，单位为百分比
    var progress:String?



    public override init(){
            super.init()
    }

    enum ImageCodingKeys: String, CodingKey {
        case imageId
        case name
        case platform
        case osVersion
        case architecture
        case systemDiskSizeGB
        case imageSource
        case osType
        case status
        case createTime
        case sizeMB
        case desc
        case ownerPin
        case launchPermission
        case systemDisk
        case dataDisks
        case snapshotId
        case rootDeviceType
        case progress
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: ImageCodingKeys.self)
        if decoderContainer.contains(.imageId)
        {
            self.imageId = try decoderContainer.decode(String?.self, forKey: .imageId)
        }
        if decoderContainer.contains(.name)
        {
            self.name = try decoderContainer.decode(String?.self, forKey: .name)
        }
        if decoderContainer.contains(.platform)
        {
            self.platform = try decoderContainer.decode(String?.self, forKey: .platform)
        }
        if decoderContainer.contains(.osVersion)
        {
            self.osVersion = try decoderContainer.decode(String?.self, forKey: .osVersion)
        }
        if decoderContainer.contains(.architecture)
        {
            self.architecture = try decoderContainer.decode(String?.self, forKey: .architecture)
        }
        if decoderContainer.contains(.systemDiskSizeGB)
        {
            self.systemDiskSizeGB = try decoderContainer.decode(Int?.self, forKey: .systemDiskSizeGB)
        }
        if decoderContainer.contains(.imageSource)
        {
            self.imageSource = try decoderContainer.decode(String?.self, forKey: .imageSource)
        }
        if decoderContainer.contains(.osType)
        {
            self.osType = try decoderContainer.decode(String?.self, forKey: .osType)
        }
        if decoderContainer.contains(.status)
        {
            self.status = try decoderContainer.decode(String?.self, forKey: .status)
        }
        if decoderContainer.contains(.createTime)
        {
            self.createTime = try decoderContainer.decode(String?.self, forKey: .createTime)
        }
        if decoderContainer.contains(.sizeMB)
        {
            self.sizeMB = try decoderContainer.decode(Int?.self, forKey: .sizeMB)
        }
        if decoderContainer.contains(.desc)
        {
            self.desc = try decoderContainer.decode(String?.self, forKey: .desc)
        }
        if decoderContainer.contains(.ownerPin)
        {
            self.ownerPin = try decoderContainer.decode(String?.self, forKey: .ownerPin)
        }
        if decoderContainer.contains(.launchPermission)
        {
            self.launchPermission = try decoderContainer.decode(String?.self, forKey: .launchPermission)
        }
        if decoderContainer.contains(.systemDisk)
        {
            self.systemDisk = try decoderContainer.decode(InstanceDiskAttachment?.self, forKey: .systemDisk)
        }
        if decoderContainer.contains(.dataDisks)
        {
            self.dataDisks = try decoderContainer.decode([InstanceDiskAttachment?]?.self, forKey: .dataDisks)
        }
        if decoderContainer.contains(.snapshotId)
        {
            self.snapshotId = try decoderContainer.decode(String?.self, forKey: .snapshotId)
        }
        if decoderContainer.contains(.rootDeviceType)
        {
            self.rootDeviceType = try decoderContainer.decode(String?.self, forKey: .rootDeviceType)
        }
        if decoderContainer.contains(.progress)
        {
            self.progress = try decoderContainer.decode(String?.self, forKey: .progress)
        }
    }
}
public extension Image{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: ImageCodingKeys.self)
         try encoderContainer.encode(imageId, forKey: .imageId)
         try encoderContainer.encode(name, forKey: .name)
         try encoderContainer.encode(platform, forKey: .platform)
         try encoderContainer.encode(osVersion, forKey: .osVersion)
         try encoderContainer.encode(architecture, forKey: .architecture)
         try encoderContainer.encode(systemDiskSizeGB, forKey: .systemDiskSizeGB)
         try encoderContainer.encode(imageSource, forKey: .imageSource)
         try encoderContainer.encode(osType, forKey: .osType)
         try encoderContainer.encode(status, forKey: .status)
         try encoderContainer.encode(createTime, forKey: .createTime)
         try encoderContainer.encode(sizeMB, forKey: .sizeMB)
         try encoderContainer.encode(desc, forKey: .desc)
         try encoderContainer.encode(ownerPin, forKey: .ownerPin)
         try encoderContainer.encode(launchPermission, forKey: .launchPermission)
         try encoderContainer.encode(systemDisk, forKey: .systemDisk)
         try encoderContainer.encode(dataDisks, forKey: .dataDisks)
         try encoderContainer.encode(snapshotId, forKey: .snapshotId)
         try encoderContainer.encode(rootDeviceType, forKey: .rootDeviceType)
         try encoderContainer.encode(progress, forKey: .progress)
    }
}
///  imageConstraint
public class ImageConstraint:NSObject,Codable{
    /// 镜像ID
    var imageId:String?
    /// 使用镜像创建实例的规格限制
    var imageInstanceTypeConstraint:ImageInstanceTypeConstraint?



    public override init(){
            super.init()
    }

    enum ImageConstraintCodingKeys: String, CodingKey {
        case imageId
        case imageInstanceTypeConstraint
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: ImageConstraintCodingKeys.self)
        if decoderContainer.contains(.imageId)
        {
            self.imageId = try decoderContainer.decode(String?.self, forKey: .imageId)
        }
        if decoderContainer.contains(.imageInstanceTypeConstraint)
        {
            self.imageInstanceTypeConstraint = try decoderContainer.decode(ImageInstanceTypeConstraint?.self, forKey: .imageInstanceTypeConstraint)
        }
    }
}
public extension ImageConstraint{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: ImageConstraintCodingKeys.self)
         try encoderContainer.encode(imageId, forKey: .imageId)
         try encoderContainer.encode(imageInstanceTypeConstraint, forKey: .imageInstanceTypeConstraint)
    }
}
///  tagFilter
public class TagFilter:NSObject,Codable{
    /// Tag键
    var key:String?
    /// Tag值
    var values:[String?]?



    public override init(){
            super.init()
    }

    enum TagFilterCodingKeys: String, CodingKey {
        case key
        case values
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: TagFilterCodingKeys.self)
        if decoderContainer.contains(.key)
        {
            self.key = try decoderContainer.decode(String?.self, forKey: .key)
        }
        if decoderContainer.contains(.values)
        {
            self.values = try decoderContainer.decode([String?]?.self, forKey: .values)
        }
    }
}
public extension TagFilter{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: TagFilterCodingKeys.self)
         try encoderContainer.encode(key, forKey: .key)
         try encoderContainer.encode(values, forKey: .values)
    }
}

/* Copyright 2018 JDCLOUD.COM

   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at

     http:#www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.

   Live-Video
   直播管理API

   OpenAPI spec version: v1
   Contact: 

   NOTE: This class is auto generated by the jdcloud code generator program.
 */


import Foundation
///  onlineStreamInfo
public class OnlineStreamInfo:NSObject,Codable{
    /// 推流域名
    var publishDomain:String?
    /// 应用名称
    var appName:String?
    /// 流名称
    var streamName:String?
    /// 推流时间
      /// - UTC时间
      ///   格式:yyyy-MM-dd&#39;T&#39;HH:mm:ss&#39;Z&#39;
      ///   示例:2018-10-21T10:00:00Z
      /// 
    var publishTime:String?
    /// 推流地址
    var publishUrl:String?



    public override init(){
            super.init()
    }

    enum OnlineStreamInfoCodingKeys: String, CodingKey {
        case publishDomain
        case appName
        case streamName
        case publishTime
        case publishUrl
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: OnlineStreamInfoCodingKeys.self)
        if decoderContainer.contains(.publishDomain)
        {
            self.publishDomain = try decoderContainer.decode(String?.self, forKey: .publishDomain)
        }
        if decoderContainer.contains(.appName)
        {
            self.appName = try decoderContainer.decode(String?.self, forKey: .appName)
        }
        if decoderContainer.contains(.streamName)
        {
            self.streamName = try decoderContainer.decode(String?.self, forKey: .streamName)
        }
        if decoderContainer.contains(.publishTime)
        {
            self.publishTime = try decoderContainer.decode(String?.self, forKey: .publishTime)
        }
        if decoderContainer.contains(.publishUrl)
        {
            self.publishUrl = try decoderContainer.decode(String?.self, forKey: .publishUrl)
        }
    }
}
public extension OnlineStreamInfo{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: OnlineStreamInfoCodingKeys.self)
         try encoderContainer.encode(publishDomain, forKey: .publishDomain)
         try encoderContainer.encode(appName, forKey: .appName)
         try encoderContainer.encode(streamName, forKey: .streamName)
         try encoderContainer.encode(publishTime, forKey: .publishTime)
         try encoderContainer.encode(publishUrl, forKey: .publishUrl)
    }
}
///  liveStreamPublishInfo
public class LiveStreamPublishInfo:NSObject,Codable{
    /// 推流域名
    var publishDomain:String?
    /// 应用名称
    var appName:String?
    /// 流名称
    var streamName:String?
    /// 推流开始时间
      /// - UTC时间
      ///   格式:yyyy-MM-dd&#39;T&#39;HH:mm:ss&#39;Z&#39;
      /// 
    var publishUpTime:String?
    /// 推流结束时刻
      /// - UTC时间
      ///   格式:yyyy-MM-dd&#39;T&#39;HH:mm:ss&#39;Z&#39;
      /// 
    var publishDownTime:String?



    public override init(){
            super.init()
    }

    enum LiveStreamPublishInfoCodingKeys: String, CodingKey {
        case publishDomain
        case appName
        case streamName
        case publishUpTime
        case publishDownTime
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: LiveStreamPublishInfoCodingKeys.self)
        if decoderContainer.contains(.publishDomain)
        {
            self.publishDomain = try decoderContainer.decode(String?.self, forKey: .publishDomain)
        }
        if decoderContainer.contains(.appName)
        {
            self.appName = try decoderContainer.decode(String?.self, forKey: .appName)
        }
        if decoderContainer.contains(.streamName)
        {
            self.streamName = try decoderContainer.decode(String?.self, forKey: .streamName)
        }
        if decoderContainer.contains(.publishUpTime)
        {
            self.publishUpTime = try decoderContainer.decode(String?.self, forKey: .publishUpTime)
        }
        if decoderContainer.contains(.publishDownTime)
        {
            self.publishDownTime = try decoderContainer.decode(String?.self, forKey: .publishDownTime)
        }
    }
}
public extension LiveStreamPublishInfo{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: LiveStreamPublishInfoCodingKeys.self)
         try encoderContainer.encode(publishDomain, forKey: .publishDomain)
         try encoderContainer.encode(appName, forKey: .appName)
         try encoderContainer.encode(streamName, forKey: .streamName)
         try encoderContainer.encode(publishUpTime, forKey: .publishUpTime)
         try encoderContainer.encode(publishDownTime, forKey: .publishDownTime)
    }
}
///  manageQueryStreamInfo
public class ManageQueryStreamInfo:NSObject,Codable{
    /// 推流域名
    var publishDomain:String?
    /// 应用名称
    var appName:String?
    /// 流名称
    var streamName:String?
    /// 推流开始时间
      /// - UTC时间
      ///   格式:yyyy-MM-dd&#39;T&#39;HH:mm:ss&#39;Z&#39;
      ///   示例:2018-10-21T10:00:00Z
      /// 
    var publishStartTime:String?
    /// 推流结束时间
      /// - UTC时间
      ///   格式:yyyy-MM-dd&#39;T&#39;HH:mm:ss&#39;Z&#39;
      ///   示例:2018-10-21T10:00:00Z
      /// 
    var publishEndTime:String?
    /// 推流地址
    var publishUrl:String?
    /// 流状态：
      /// - living-在线流
      /// - stop-历史流
      /// - forbid-禁用流
      /// 
    var status:String?



    public override init(){
            super.init()
    }

    enum ManageQueryStreamInfoCodingKeys: String, CodingKey {
        case publishDomain
        case appName
        case streamName
        case publishStartTime
        case publishEndTime
        case publishUrl
        case status
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: ManageQueryStreamInfoCodingKeys.self)
        if decoderContainer.contains(.publishDomain)
        {
            self.publishDomain = try decoderContainer.decode(String?.self, forKey: .publishDomain)
        }
        if decoderContainer.contains(.appName)
        {
            self.appName = try decoderContainer.decode(String?.self, forKey: .appName)
        }
        if decoderContainer.contains(.streamName)
        {
            self.streamName = try decoderContainer.decode(String?.self, forKey: .streamName)
        }
        if decoderContainer.contains(.publishStartTime)
        {
            self.publishStartTime = try decoderContainer.decode(String?.self, forKey: .publishStartTime)
        }
        if decoderContainer.contains(.publishEndTime)
        {
            self.publishEndTime = try decoderContainer.decode(String?.self, forKey: .publishEndTime)
        }
        if decoderContainer.contains(.publishUrl)
        {
            self.publishUrl = try decoderContainer.decode(String?.self, forKey: .publishUrl)
        }
        if decoderContainer.contains(.status)
        {
            self.status = try decoderContainer.decode(String?.self, forKey: .status)
        }
    }
}
public extension ManageQueryStreamInfo{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: ManageQueryStreamInfoCodingKeys.self)
         try encoderContainer.encode(publishDomain, forKey: .publishDomain)
         try encoderContainer.encode(appName, forKey: .appName)
         try encoderContainer.encode(streamName, forKey: .streamName)
         try encoderContainer.encode(publishStartTime, forKey: .publishStartTime)
         try encoderContainer.encode(publishEndTime, forKey: .publishEndTime)
         try encoderContainer.encode(publishUrl, forKey: .publishUrl)
         try encoderContainer.encode(status, forKey: .status)
    }
}
///  pornCountStatisticResult
public class PornCountStatisticResult:NSObject,Codable{
    /// 时间点
      /// 
    var startTime:String?
    /// 时间点
      /// 
    var endTime:String?
    /// Data
    var data:PornCountStatisticData?



    public override init(){
            super.init()
    }

    enum PornCountStatisticResultCodingKeys: String, CodingKey {
        case startTime
        case endTime
        case data
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: PornCountStatisticResultCodingKeys.self)
        if decoderContainer.contains(.startTime)
        {
            self.startTime = try decoderContainer.decode(String?.self, forKey: .startTime)
        }
        if decoderContainer.contains(.endTime)
        {
            self.endTime = try decoderContainer.decode(String?.self, forKey: .endTime)
        }
        if decoderContainer.contains(.data)
        {
            self.data = try decoderContainer.decode(PornCountStatisticData?.self, forKey: .data)
        }
    }
}
public extension PornCountStatisticResult{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: PornCountStatisticResultCodingKeys.self)
         try encoderContainer.encode(startTime, forKey: .startTime)
         try encoderContainer.encode(endTime, forKey: .endTime)
         try encoderContainer.encode(data, forKey: .data)
    }
}
///  bandwidthStatisticResult
public class BandwidthStatisticResult:NSObject,Codable{
    /// 时间点
      /// 
    var startTime:String?
    /// 时间点
      /// 
    var endTime:String?
    /// Data
    var data:BandwidthStatisticResultData?



    public override init(){
            super.init()
    }

    enum BandwidthStatisticResultCodingKeys: String, CodingKey {
        case startTime
        case endTime
        case data
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: BandwidthStatisticResultCodingKeys.self)
        if decoderContainer.contains(.startTime)
        {
            self.startTime = try decoderContainer.decode(String?.self, forKey: .startTime)
        }
        if decoderContainer.contains(.endTime)
        {
            self.endTime = try decoderContainer.decode(String?.self, forKey: .endTime)
        }
        if decoderContainer.contains(.data)
        {
            self.data = try decoderContainer.decode(BandwidthStatisticResultData?.self, forKey: .data)
        }
    }
}
public extension BandwidthStatisticResult{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: BandwidthStatisticResultCodingKeys.self)
         try encoderContainer.encode(startTime, forKey: .startTime)
         try encoderContainer.encode(endTime, forKey: .endTime)
         try encoderContainer.encode(data, forKey: .data)
    }
}
///  playDataStatisticResultData
public class PlayDataStatisticResultData:NSObject,Codable{
    /// 带宽，单位：bps
      /// 
    var avgbandwidth:Int64?
    /// 带宽峰值时间点，单位：秒
      /// 
    var maxavgbandwidthtime:Int64?
    /// PV
      /// 
    var pv:Int64?
    /// 流量，单位:Byte
      /// 
    var flow:Int64?
    /// 在线人数
      /// 
    var playercount:Int64?



    public override init(){
            super.init()
    }

    enum PlayDataStatisticResultDataCodingKeys: String, CodingKey {
        case avgbandwidth
        case maxavgbandwidthtime
        case pv
        case flow
        case playercount
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: PlayDataStatisticResultDataCodingKeys.self)
        if decoderContainer.contains(.avgbandwidth)
        {
            self.avgbandwidth = try decoderContainer.decode(Int64?.self, forKey: .avgbandwidth)
        }
        if decoderContainer.contains(.maxavgbandwidthtime)
        {
            self.maxavgbandwidthtime = try decoderContainer.decode(Int64?.self, forKey: .maxavgbandwidthtime)
        }
        if decoderContainer.contains(.pv)
        {
            self.pv = try decoderContainer.decode(Int64?.self, forKey: .pv)
        }
        if decoderContainer.contains(.flow)
        {
            self.flow = try decoderContainer.decode(Int64?.self, forKey: .flow)
        }
        if decoderContainer.contains(.playercount)
        {
            self.playercount = try decoderContainer.decode(Int64?.self, forKey: .playercount)
        }
    }
}
public extension PlayDataStatisticResultData{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: PlayDataStatisticResultDataCodingKeys.self)
         try encoderContainer.encode(avgbandwidth, forKey: .avgbandwidth)
         try encoderContainer.encode(maxavgbandwidthtime, forKey: .maxavgbandwidthtime)
         try encoderContainer.encode(pv, forKey: .pv)
         try encoderContainer.encode(flow, forKey: .flow)
         try encoderContainer.encode(playercount, forKey: .playercount)
    }
}
///  snapshotCountStatisticData
public class SnapshotCountStatisticData:NSObject,Codable{
    /// 截图张数
      /// - 单位: 张
      /// 
    var count:Int?



    public override init(){
            super.init()
    }

    enum SnapshotCountStatisticDataCodingKeys: String, CodingKey {
        case count
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: SnapshotCountStatisticDataCodingKeys.self)
        if decoderContainer.contains(.count)
        {
            self.count = try decoderContainer.decode(Int?.self, forKey: .count)
        }
    }
}
public extension SnapshotCountStatisticData{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: SnapshotCountStatisticDataCodingKeys.self)
         try encoderContainer.encode(count, forKey: .count)
    }
}
///  bandwidthStatisticResultData
public class BandwidthStatisticResultData:NSObject,Codable{
    /// 带宽，单位：bps
      /// 
    var value:Int64?
    /// 带宽峰值时间点，单位：秒
      /// 
    var maxValueTime:Int64?



    public override init(){
            super.init()
    }

    enum BandwidthStatisticResultDataCodingKeys: String, CodingKey {
        case value
        case maxValueTime
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: BandwidthStatisticResultDataCodingKeys.self)
        if decoderContainer.contains(.value)
        {
            self.value = try decoderContainer.decode(Int64?.self, forKey: .value)
        }
        if decoderContainer.contains(.maxValueTime)
        {
            self.maxValueTime = try decoderContainer.decode(Int64?.self, forKey: .maxValueTime)
        }
    }
}
public extension BandwidthStatisticResultData{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: BandwidthStatisticResultDataCodingKeys.self)
         try encoderContainer.encode(value, forKey: .value)
         try encoderContainer.encode(maxValueTime, forKey: .maxValueTime)
    }
}
///  playDataStatisticResult
public class PlayDataStatisticResult:NSObject,Codable{
    /// 时间点
      /// 
    var startTime:String?
    /// 时间点
      /// 
    var endTime:String?
    /// Data
    var data:PlayDataStatisticResultData?



    public override init(){
            super.init()
    }

    enum PlayDataStatisticResultCodingKeys: String, CodingKey {
        case startTime
        case endTime
        case data
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: PlayDataStatisticResultCodingKeys.self)
        if decoderContainer.contains(.startTime)
        {
            self.startTime = try decoderContainer.decode(String?.self, forKey: .startTime)
        }
        if decoderContainer.contains(.endTime)
        {
            self.endTime = try decoderContainer.decode(String?.self, forKey: .endTime)
        }
        if decoderContainer.contains(.data)
        {
            self.data = try decoderContainer.decode(PlayDataStatisticResultData?.self, forKey: .data)
        }
    }
}
public extension PlayDataStatisticResult{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: PlayDataStatisticResultCodingKeys.self)
         try encoderContainer.encode(startTime, forKey: .startTime)
         try encoderContainer.encode(endTime, forKey: .endTime)
         try encoderContainer.encode(data, forKey: .data)
    }
}
///  recordDetail
public class RecordDetail:NSObject,Codable{
    /// 格式
      ///   mp4
      ///   flv
      ///   ts
      /// 
    var format:String?
    /// 时长:
      /// - 单位: 分钟
      /// - 精确两位小数
      /// 
    var duration:Double?



    public override init(){
            super.init()
    }

    enum RecordDetailCodingKeys: String, CodingKey {
        case format
        case duration
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: RecordDetailCodingKeys.self)
        if decoderContainer.contains(.format)
        {
            self.format = try decoderContainer.decode(String?.self, forKey: .format)
        }
        if decoderContainer.contains(.duration)
        {
            self.duration = try decoderContainer.decode(Double?.self, forKey: .duration)
        }
    }
}
public extension RecordDetail{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: RecordDetailCodingKeys.self)
         try encoderContainer.encode(format, forKey: .format)
         try encoderContainer.encode(duration, forKey: .duration)
    }
}
///  pornCountStatisticData
public class PornCountStatisticData:NSObject,Codable{
    /// 鉴黄张数
      /// - 单位: 张
      /// 
    var count:Int?



    public override init(){
            super.init()
    }

    enum PornCountStatisticDataCodingKeys: String, CodingKey {
        case count
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: PornCountStatisticDataCodingKeys.self)
        if decoderContainer.contains(.count)
        {
            self.count = try decoderContainer.decode(Int?.self, forKey: .count)
        }
    }
}
public extension PornCountStatisticData{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: PornCountStatisticDataCodingKeys.self)
         try encoderContainer.encode(count, forKey: .count)
    }
}
///  fileStorageStatisticResult
public class FileStorageStatisticResult:NSObject,Codable{
    /// 时间点
      /// 
    var startTime:String?
    /// 时间点
      /// 
    var endTime:String?
    /// Data
    var data:FileStorageStatisticData?



    public override init(){
            super.init()
    }

    enum FileStorageStatisticResultCodingKeys: String, CodingKey {
        case startTime
        case endTime
        case data
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: FileStorageStatisticResultCodingKeys.self)
        if decoderContainer.contains(.startTime)
        {
            self.startTime = try decoderContainer.decode(String?.self, forKey: .startTime)
        }
        if decoderContainer.contains(.endTime)
        {
            self.endTime = try decoderContainer.decode(String?.self, forKey: .endTime)
        }
        if decoderContainer.contains(.data)
        {
            self.data = try decoderContainer.decode(FileStorageStatisticData?.self, forKey: .data)
        }
    }
}
public extension FileStorageStatisticResult{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: FileStorageStatisticResultCodingKeys.self)
         try encoderContainer.encode(startTime, forKey: .startTime)
         try encoderContainer.encode(endTime, forKey: .endTime)
         try encoderContainer.encode(data, forKey: .data)
    }
}
///  transcodeDurationStatisticResult
public class TranscodeDurationStatisticResult:NSObject,Codable{
    /// 时间点
      /// 
    var startTime:String?
    /// 时间点
      /// 
    var endTime:String?
    /// Data
    var data:TranscodeDurationStatisticData?



    public override init(){
            super.init()
    }

    enum TranscodeDurationStatisticResultCodingKeys: String, CodingKey {
        case startTime
        case endTime
        case data
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: TranscodeDurationStatisticResultCodingKeys.self)
        if decoderContainer.contains(.startTime)
        {
            self.startTime = try decoderContainer.decode(String?.self, forKey: .startTime)
        }
        if decoderContainer.contains(.endTime)
        {
            self.endTime = try decoderContainer.decode(String?.self, forKey: .endTime)
        }
        if decoderContainer.contains(.data)
        {
            self.data = try decoderContainer.decode(TranscodeDurationStatisticData?.self, forKey: .data)
        }
    }
}
public extension TranscodeDurationStatisticResult{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: TranscodeDurationStatisticResultCodingKeys.self)
         try encoderContainer.encode(startTime, forKey: .startTime)
         try encoderContainer.encode(endTime, forKey: .endTime)
         try encoderContainer.encode(data, forKey: .data)
    }
}
///  fileStorageStatisticData
public class FileStorageStatisticData:NSObject,Codable{
    /// 存储空间，单位：B
      /// 
    var size:Int64?



    public override init(){
            super.init()
    }

    enum FileStorageStatisticDataCodingKeys: String, CodingKey {
        case size
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: FileStorageStatisticDataCodingKeys.self)
        if decoderContainer.contains(.size)
        {
            self.size = try decoderContainer.decode(Int64?.self, forKey: .size)
        }
    }
}
public extension FileStorageStatisticData{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: FileStorageStatisticDataCodingKeys.self)
         try encoderContainer.encode(size, forKey: .size)
    }
}
///  snapshotCountStatisticResult
public class SnapshotCountStatisticResult:NSObject,Codable{
    /// 时间点
      /// 
    var startTime:String?
    /// 时间点
      /// 
    var endTime:String?
    /// Data
    var data:SnapshotCountStatisticData?



    public override init(){
            super.init()
    }

    enum SnapshotCountStatisticResultCodingKeys: String, CodingKey {
        case startTime
        case endTime
        case data
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: SnapshotCountStatisticResultCodingKeys.self)
        if decoderContainer.contains(.startTime)
        {
            self.startTime = try decoderContainer.decode(String?.self, forKey: .startTime)
        }
        if decoderContainer.contains(.endTime)
        {
            self.endTime = try decoderContainer.decode(String?.self, forKey: .endTime)
        }
        if decoderContainer.contains(.data)
        {
            self.data = try decoderContainer.decode(SnapshotCountStatisticData?.self, forKey: .data)
        }
    }
}
public extension SnapshotCountStatisticResult{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: SnapshotCountStatisticResultCodingKeys.self)
         try encoderContainer.encode(startTime, forKey: .startTime)
         try encoderContainer.encode(endTime, forKey: .endTime)
         try encoderContainer.encode(data, forKey: .data)
    }
}
///  transcodeDurationStatisticData
public class TranscodeDurationStatisticData:NSObject,Codable{
    /// 时长，单位：秒
      /// 
    var duration:String?



    public override init(){
            super.init()
    }

    enum TranscodeDurationStatisticDataCodingKeys: String, CodingKey {
        case duration
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: TranscodeDurationStatisticDataCodingKeys.self)
        if decoderContainer.contains(.duration)
        {
            self.duration = try decoderContainer.decode(String?.self, forKey: .duration)
        }
    }
}
public extension TranscodeDurationStatisticData{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: TranscodeDurationStatisticDataCodingKeys.self)
         try encoderContainer.encode(duration, forKey: .duration)
    }
}
///  trafficStatisticResult
public class TrafficStatisticResult:NSObject,Codable{
    /// 时间点
      /// 
    var startTime:String?
    /// 时间点
      /// 
    var endTime:String?
    /// Data
    var data:TrafficStatisticResultData?



    public override init(){
            super.init()
    }

    enum TrafficStatisticResultCodingKeys: String, CodingKey {
        case startTime
        case endTime
        case data
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: TrafficStatisticResultCodingKeys.self)
        if decoderContainer.contains(.startTime)
        {
            self.startTime = try decoderContainer.decode(String?.self, forKey: .startTime)
        }
        if decoderContainer.contains(.endTime)
        {
            self.endTime = try decoderContainer.decode(String?.self, forKey: .endTime)
        }
        if decoderContainer.contains(.data)
        {
            self.data = try decoderContainer.decode(TrafficStatisticResultData?.self, forKey: .data)
        }
    }
}
public extension TrafficStatisticResult{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: TrafficStatisticResultCodingKeys.self)
         try encoderContainer.encode(startTime, forKey: .startTime)
         try encoderContainer.encode(endTime, forKey: .endTime)
         try encoderContainer.encode(data, forKey: .data)
    }
}
///  trafficStatisticResultData
public class TrafficStatisticResultData:NSObject,Codable{
    /// 流量，单位:Byte
      /// 
    var value:Int64?



    public override init(){
            super.init()
    }

    enum TrafficStatisticResultDataCodingKeys: String, CodingKey {
        case value
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: TrafficStatisticResultDataCodingKeys.self)
        if decoderContainer.contains(.value)
        {
            self.value = try decoderContainer.decode(Int64?.self, forKey: .value)
        }
    }
}
public extension TrafficStatisticResultData{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: TrafficStatisticResultDataCodingKeys.self)
         try encoderContainer.encode(value, forKey: .value)
    }
}
///  recordData
public class RecordData:NSObject,Codable{
    /// 推流域名
    var publishDomain:String?
    /// 应用名称
    var appName:String?
    /// 流名称
    var streamName:String?
    /// 日期:
      /// - yyyyMMdd
      /// - 示例: 20190308
      /// 
    var date:String?
    /// 录制时长:
      /// - 单位: 分钟
      /// - 精确两位小数
      /// 
    var total:Double?
    /// 明细
    var detail:[RecordDetail?]?



    public override init(){
            super.init()
    }

    enum RecordDataCodingKeys: String, CodingKey {
        case publishDomain
        case appName
        case streamName
        case date
        case total
        case detail
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: RecordDataCodingKeys.self)
        if decoderContainer.contains(.publishDomain)
        {
            self.publishDomain = try decoderContainer.decode(String?.self, forKey: .publishDomain)
        }
        if decoderContainer.contains(.appName)
        {
            self.appName = try decoderContainer.decode(String?.self, forKey: .appName)
        }
        if decoderContainer.contains(.streamName)
        {
            self.streamName = try decoderContainer.decode(String?.self, forKey: .streamName)
        }
        if decoderContainer.contains(.date)
        {
            self.date = try decoderContainer.decode(String?.self, forKey: .date)
        }
        if decoderContainer.contains(.total)
        {
            self.total = try decoderContainer.decode(Double?.self, forKey: .total)
        }
        if decoderContainer.contains(.detail)
        {
            self.detail = try decoderContainer.decode([RecordDetail?]?.self, forKey: .detail)
        }
    }
}
public extension RecordData{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: RecordDataCodingKeys.self)
         try encoderContainer.encode(publishDomain, forKey: .publishDomain)
         try encoderContainer.encode(appName, forKey: .appName)
         try encoderContainer.encode(streamName, forKey: .streamName)
         try encoderContainer.encode(date, forKey: .date)
         try encoderContainer.encode(total, forKey: .total)
         try encoderContainer.encode(detail, forKey: .detail)
    }
}
///  liveStatisticGroupByStreamResult
public class LiveStatisticGroupByStreamResult:NSObject,Codable{
    /// 起始时间点，UTC时间，格式：yyyy-MM-dd&#39;T&#39;HH:mm:ss&#39;Z&#39;
      /// 
    var startTime:String?
    /// 结束时间点，UTC时间，格式：yyyy-MM-dd&#39;T&#39;HH:mm:ss&#39;Z&#39;
      /// 
    var endTime:String?
    /// Data
    var data:[LiveStatisticGroupByStreamResultData?]?



    public override init(){
            super.init()
    }

    enum LiveStatisticGroupByStreamResultCodingKeys: String, CodingKey {
        case startTime
        case endTime
        case data
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: LiveStatisticGroupByStreamResultCodingKeys.self)
        if decoderContainer.contains(.startTime)
        {
            self.startTime = try decoderContainer.decode(String?.self, forKey: .startTime)
        }
        if decoderContainer.contains(.endTime)
        {
            self.endTime = try decoderContainer.decode(String?.self, forKey: .endTime)
        }
        if decoderContainer.contains(.data)
        {
            self.data = try decoderContainer.decode([LiveStatisticGroupByStreamResultData?]?.self, forKey: .data)
        }
    }
}
public extension LiveStatisticGroupByStreamResult{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: LiveStatisticGroupByStreamResultCodingKeys.self)
         try encoderContainer.encode(startTime, forKey: .startTime)
         try encoderContainer.encode(endTime, forKey: .endTime)
         try encoderContainer.encode(data, forKey: .data)
    }
}
///  liveStatisticGroupByAreaResultData
public class LiveStatisticGroupByAreaResultData:NSObject,Codable{
    /// 地域
      /// 
    var area:String?
    /// 在线人数
      /// 
    var playerCount:Int64?
    /// 带宽，单位：bps
      /// 
    var bandwidth:Int64?
    /// 带宽峰值时间点，单位：秒
      /// 
    var maxBandwidthtime:Int64?
    /// 流量，单位:Byte
      /// 
    var flow:Int64?



    public override init(){
            super.init()
    }

    enum LiveStatisticGroupByAreaResultDataCodingKeys: String, CodingKey {
        case area
        case playerCount
        case bandwidth
        case maxBandwidthtime
        case flow
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: LiveStatisticGroupByAreaResultDataCodingKeys.self)
        if decoderContainer.contains(.area)
        {
            self.area = try decoderContainer.decode(String?.self, forKey: .area)
        }
        if decoderContainer.contains(.playerCount)
        {
            self.playerCount = try decoderContainer.decode(Int64?.self, forKey: .playerCount)
        }
        if decoderContainer.contains(.bandwidth)
        {
            self.bandwidth = try decoderContainer.decode(Int64?.self, forKey: .bandwidth)
        }
        if decoderContainer.contains(.maxBandwidthtime)
        {
            self.maxBandwidthtime = try decoderContainer.decode(Int64?.self, forKey: .maxBandwidthtime)
        }
        if decoderContainer.contains(.flow)
        {
            self.flow = try decoderContainer.decode(Int64?.self, forKey: .flow)
        }
    }
}
public extension LiveStatisticGroupByAreaResultData{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: LiveStatisticGroupByAreaResultDataCodingKeys.self)
         try encoderContainer.encode(area, forKey: .area)
         try encoderContainer.encode(playerCount, forKey: .playerCount)
         try encoderContainer.encode(bandwidth, forKey: .bandwidth)
         try encoderContainer.encode(maxBandwidthtime, forKey: .maxBandwidthtime)
         try encoderContainer.encode(flow, forKey: .flow)
    }
}
///  liveStatisticGroupByAreaIspResultData
public class LiveStatisticGroupByAreaIspResultData:NSObject,Codable{
    /// 地域
      /// 
    var area:String?
    /// IspData
    var ispData:[LiveStatisticGroupByAreaIspResultIspData?]?



    public override init(){
            super.init()
    }

    enum LiveStatisticGroupByAreaIspResultDataCodingKeys: String, CodingKey {
        case area
        case ispData
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: LiveStatisticGroupByAreaIspResultDataCodingKeys.self)
        if decoderContainer.contains(.area)
        {
            self.area = try decoderContainer.decode(String?.self, forKey: .area)
        }
        if decoderContainer.contains(.ispData)
        {
            self.ispData = try decoderContainer.decode([LiveStatisticGroupByAreaIspResultIspData?]?.self, forKey: .ispData)
        }
    }
}
public extension LiveStatisticGroupByAreaIspResultData{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: LiveStatisticGroupByAreaIspResultDataCodingKeys.self)
         try encoderContainer.encode(area, forKey: .area)
         try encoderContainer.encode(ispData, forKey: .ispData)
    }
}
///  liveStatisticGroupByAreaIspResult
public class LiveStatisticGroupByAreaIspResult:NSObject,Codable{
    /// 起始时间点，UTC时间，格式：yyyy-MM-dd&#39;T&#39;HH:mm:ss&#39;Z&#39;
      /// 
    var startTime:String?
    /// 结束时间点，UTC时间，格式：yyyy-MM-dd&#39;T&#39;HH:mm:ss&#39;Z&#39;
      /// 
    var endTime:String?
    /// Data
    var data:LiveStatisticGroupByAreaIspResultData?



    public override init(){
            super.init()
    }

    enum LiveStatisticGroupByAreaIspResultCodingKeys: String, CodingKey {
        case startTime
        case endTime
        case data
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: LiveStatisticGroupByAreaIspResultCodingKeys.self)
        if decoderContainer.contains(.startTime)
        {
            self.startTime = try decoderContainer.decode(String?.self, forKey: .startTime)
        }
        if decoderContainer.contains(.endTime)
        {
            self.endTime = try decoderContainer.decode(String?.self, forKey: .endTime)
        }
        if decoderContainer.contains(.data)
        {
            self.data = try decoderContainer.decode(LiveStatisticGroupByAreaIspResultData?.self, forKey: .data)
        }
    }
}
public extension LiveStatisticGroupByAreaIspResult{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: LiveStatisticGroupByAreaIspResultCodingKeys.self)
         try encoderContainer.encode(startTime, forKey: .startTime)
         try encoderContainer.encode(endTime, forKey: .endTime)
         try encoderContainer.encode(data, forKey: .data)
    }
}
///  liveStatisticGroupByStreamResultData
public class LiveStatisticGroupByStreamResultData:NSObject,Codable{
    /// 流名称
      /// 
    var streamName:String?
    /// 在线人数
      /// 
    var playerCount:Int64?
    /// 带宽，单位：bps
      /// 
    var bandwidth:Int64?
    /// 带宽峰值时间点，单位：秒
      /// 
    var maxBandwidthtime:Int64?
    /// 流量，单位:Byte
      /// 
    var flow:Int64?



    public override init(){
            super.init()
    }

    enum LiveStatisticGroupByStreamResultDataCodingKeys: String, CodingKey {
        case streamName
        case playerCount
        case bandwidth
        case maxBandwidthtime
        case flow
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: LiveStatisticGroupByStreamResultDataCodingKeys.self)
        if decoderContainer.contains(.streamName)
        {
            self.streamName = try decoderContainer.decode(String?.self, forKey: .streamName)
        }
        if decoderContainer.contains(.playerCount)
        {
            self.playerCount = try decoderContainer.decode(Int64?.self, forKey: .playerCount)
        }
        if decoderContainer.contains(.bandwidth)
        {
            self.bandwidth = try decoderContainer.decode(Int64?.self, forKey: .bandwidth)
        }
        if decoderContainer.contains(.maxBandwidthtime)
        {
            self.maxBandwidthtime = try decoderContainer.decode(Int64?.self, forKey: .maxBandwidthtime)
        }
        if decoderContainer.contains(.flow)
        {
            self.flow = try decoderContainer.decode(Int64?.self, forKey: .flow)
        }
    }
}
public extension LiveStatisticGroupByStreamResultData{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: LiveStatisticGroupByStreamResultDataCodingKeys.self)
         try encoderContainer.encode(streamName, forKey: .streamName)
         try encoderContainer.encode(playerCount, forKey: .playerCount)
         try encoderContainer.encode(bandwidth, forKey: .bandwidth)
         try encoderContainer.encode(maxBandwidthtime, forKey: .maxBandwidthtime)
         try encoderContainer.encode(flow, forKey: .flow)
    }
}
///  liveStatisticGroupByAreaIspResultIspData
public class LiveStatisticGroupByAreaIspResultIspData:NSObject,Codable{
    /// 运营商
      /// 
    var isp:String?
    /// 在线人数
      /// 
    var playerCount:Int64?
    /// 带宽，单位：bps
      /// 
    var bandwidth:Int64?
    /// 带宽峰值时间点，单位：秒
      /// 
    var maxBandwidthtime:Int64?
    /// 流量，单位:Byte
    var flow:Int64?



    public override init(){
            super.init()
    }

    enum LiveStatisticGroupByAreaIspResultIspDataCodingKeys: String, CodingKey {
        case isp
        case playerCount
        case bandwidth
        case maxBandwidthtime
        case flow
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: LiveStatisticGroupByAreaIspResultIspDataCodingKeys.self)
        if decoderContainer.contains(.isp)
        {
            self.isp = try decoderContainer.decode(String?.self, forKey: .isp)
        }
        if decoderContainer.contains(.playerCount)
        {
            self.playerCount = try decoderContainer.decode(Int64?.self, forKey: .playerCount)
        }
        if decoderContainer.contains(.bandwidth)
        {
            self.bandwidth = try decoderContainer.decode(Int64?.self, forKey: .bandwidth)
        }
        if decoderContainer.contains(.maxBandwidthtime)
        {
            self.maxBandwidthtime = try decoderContainer.decode(Int64?.self, forKey: .maxBandwidthtime)
        }
        if decoderContainer.contains(.flow)
        {
            self.flow = try decoderContainer.decode(Int64?.self, forKey: .flow)
        }
    }
}
public extension LiveStatisticGroupByAreaIspResultIspData{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: LiveStatisticGroupByAreaIspResultIspDataCodingKeys.self)
         try encoderContainer.encode(isp, forKey: .isp)
         try encoderContainer.encode(playerCount, forKey: .playerCount)
         try encoderContainer.encode(bandwidth, forKey: .bandwidth)
         try encoderContainer.encode(maxBandwidthtime, forKey: .maxBandwidthtime)
         try encoderContainer.encode(flow, forKey: .flow)
    }
}
///  liveStatisticGroupByAreaResult
public class LiveStatisticGroupByAreaResult:NSObject,Codable{
    /// 起始时间点，UTC时间，格式：yyyy-MM-dd&#39;T&#39;HH:mm:ss&#39;Z&#39;
      /// 
    var startTime:String?
    /// 结束时间点，UTC时间，格式：yyyy-MM-dd&#39;T&#39;HH:mm:ss&#39;Z&#39;
      /// 
    var endTime:String?
    /// Data
    var data:[LiveStatisticGroupByAreaResultData?]?



    public override init(){
            super.init()
    }

    enum LiveStatisticGroupByAreaResultCodingKeys: String, CodingKey {
        case startTime
        case endTime
        case data
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: LiveStatisticGroupByAreaResultCodingKeys.self)
        if decoderContainer.contains(.startTime)
        {
            self.startTime = try decoderContainer.decode(String?.self, forKey: .startTime)
        }
        if decoderContainer.contains(.endTime)
        {
            self.endTime = try decoderContainer.decode(String?.self, forKey: .endTime)
        }
        if decoderContainer.contains(.data)
        {
            self.data = try decoderContainer.decode([LiveStatisticGroupByAreaResultData?]?.self, forKey: .data)
        }
    }
}
public extension LiveStatisticGroupByAreaResult{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: LiveStatisticGroupByAreaResultCodingKeys.self)
         try encoderContainer.encode(startTime, forKey: .startTime)
         try encoderContainer.encode(endTime, forKey: .endTime)
         try encoderContainer.encode(data, forKey: .data)
    }
}
///  recordFile
public class RecordFile:NSObject,Codable{
    /// 录制文件ID
      /// 
    var fileId:String?
    /// 文件格式
      /// 
    var format:String?
    /// 视频宽度
      /// - 单位: 像素
      /// 
    var width:Int?
    /// 视频高度
      /// - 单位: 像素
      /// 
    var height:Int?
    /// 录制开始时间
      /// 
    var startTime:String?
    /// 录制结束时间
      /// 
    var endTime:String?
    /// 视频时长，单位：毫秒
      /// 
    var duration:Int?
    /// 文件大小，单位：B
      /// 
    var size:Int?
    /// 码率
      /// 
    var bitrate:Int?
    /// 帧率
      /// 
    var fps:Int?
    /// 文件地址
      /// 
    var fileUrl:String?
    /// 创建时间
      /// 
    var createTime:String?



    public override init(){
            super.init()
    }

    enum RecordFileCodingKeys: String, CodingKey {
        case fileId
        case format
        case width
        case height
        case startTime
        case endTime
        case duration
        case size
        case bitrate
        case fps
        case fileUrl
        case createTime
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: RecordFileCodingKeys.self)
        if decoderContainer.contains(.fileId)
        {
            self.fileId = try decoderContainer.decode(String?.self, forKey: .fileId)
        }
        if decoderContainer.contains(.format)
        {
            self.format = try decoderContainer.decode(String?.self, forKey: .format)
        }
        if decoderContainer.contains(.width)
        {
            self.width = try decoderContainer.decode(Int?.self, forKey: .width)
        }
        if decoderContainer.contains(.height)
        {
            self.height = try decoderContainer.decode(Int?.self, forKey: .height)
        }
        if decoderContainer.contains(.startTime)
        {
            self.startTime = try decoderContainer.decode(String?.self, forKey: .startTime)
        }
        if decoderContainer.contains(.endTime)
        {
            self.endTime = try decoderContainer.decode(String?.self, forKey: .endTime)
        }
        if decoderContainer.contains(.duration)
        {
            self.duration = try decoderContainer.decode(Int?.self, forKey: .duration)
        }
        if decoderContainer.contains(.size)
        {
            self.size = try decoderContainer.decode(Int?.self, forKey: .size)
        }
        if decoderContainer.contains(.bitrate)
        {
            self.bitrate = try decoderContainer.decode(Int?.self, forKey: .bitrate)
        }
        if decoderContainer.contains(.fps)
        {
            self.fps = try decoderContainer.decode(Int?.self, forKey: .fps)
        }
        if decoderContainer.contains(.fileUrl)
        {
            self.fileUrl = try decoderContainer.decode(String?.self, forKey: .fileUrl)
        }
        if decoderContainer.contains(.createTime)
        {
            self.createTime = try decoderContainer.decode(String?.self, forKey: .createTime)
        }
    }
}
public extension RecordFile{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: RecordFileCodingKeys.self)
         try encoderContainer.encode(fileId, forKey: .fileId)
         try encoderContainer.encode(format, forKey: .format)
         try encoderContainer.encode(width, forKey: .width)
         try encoderContainer.encode(height, forKey: .height)
         try encoderContainer.encode(startTime, forKey: .startTime)
         try encoderContainer.encode(endTime, forKey: .endTime)
         try encoderContainer.encode(duration, forKey: .duration)
         try encoderContainer.encode(size, forKey: .size)
         try encoderContainer.encode(bitrate, forKey: .bitrate)
         try encoderContainer.encode(fps, forKey: .fps)
         try encoderContainer.encode(fileUrl, forKey: .fileUrl)
         try encoderContainer.encode(createTime, forKey: .createTime)
    }
}
///  timeshiftPlayDomain
public class TimeshiftPlayDomain:NSObject,Codable{
    /// 播放域名
    var playDomain:String?
    /// 直播时移状态:
      ///   on: 开启
      ///   off: 关闭
      /// 
    var timeshiftStatus:String?
    /// 播放域名类型:
      ///   normal: 普通播放域名(时移播放域名)
      /// 
    var playType:String?



    public override init(){
            super.init()
    }

    enum TimeshiftPlayDomainCodingKeys: String, CodingKey {
        case playDomain
        case timeshiftStatus
        case playType
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: TimeshiftPlayDomainCodingKeys.self)
        if decoderContainer.contains(.playDomain)
        {
            self.playDomain = try decoderContainer.decode(String?.self, forKey: .playDomain)
        }
        if decoderContainer.contains(.timeshiftStatus)
        {
            self.timeshiftStatus = try decoderContainer.decode(String?.self, forKey: .timeshiftStatus)
        }
        if decoderContainer.contains(.playType)
        {
            self.playType = try decoderContainer.decode(String?.self, forKey: .playType)
        }
    }
}
public extension TimeshiftPlayDomain{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: TimeshiftPlayDomainCodingKeys.self)
         try encoderContainer.encode(playDomain, forKey: .playDomain)
         try encoderContainer.encode(timeshiftStatus, forKey: .timeshiftStatus)
         try encoderContainer.encode(playType, forKey: .playType)
    }
}
///  timeshiftPublishDomain
public class TimeshiftPublishDomain:NSObject,Codable{
    /// 推流域名
    var publishDomain:String?



    public override init(){
            super.init()
    }

    enum TimeshiftPublishDomainCodingKeys: String, CodingKey {
        case publishDomain
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: TimeshiftPublishDomainCodingKeys.self)
        if decoderContainer.contains(.publishDomain)
        {
            self.publishDomain = try decoderContainer.decode(String?.self, forKey: .publishDomain)
        }
    }
}
public extension TimeshiftPublishDomain{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: TimeshiftPublishDomainCodingKeys.self)
         try encoderContainer.encode(publishDomain, forKey: .publishDomain)
    }
}
///  timeshiftConfig
public class TimeshiftConfig:NSObject,Codable{
    /// 推流域名集合
    var publishDomains:[TimeshiftPublishDomain?]?
    /// 播放域名集合
    var playDomains:[TimeshiftPlayDomain?]?



    public override init(){
            super.init()
    }

    enum TimeshiftConfigCodingKeys: String, CodingKey {
        case publishDomains
        case playDomains
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: TimeshiftConfigCodingKeys.self)
        if decoderContainer.contains(.publishDomains)
        {
            self.publishDomains = try decoderContainer.decode([TimeshiftPublishDomain?]?.self, forKey: .publishDomains)
        }
        if decoderContainer.contains(.playDomains)
        {
            self.playDomains = try decoderContainer.decode([TimeshiftPlayDomain?]?.self, forKey: .playDomains)
        }
    }
}
public extension TimeshiftConfig{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: TimeshiftConfigCodingKeys.self)
         try encoderContainer.encode(publishDomains, forKey: .publishDomains)
         try encoderContainer.encode(playDomains, forKey: .playDomains)
    }
}
///  liveRecordConfig
public class LiveRecordConfig:NSObject,Codable{
    /// 推流域名
    var publishDomain:String?
    /// 应用名称
    var appName:String?
    /// 流名称
    var streamName:String?
    /// RecordConfig
    var recordConfig:String?



    public override init(){
            super.init()
    }

    enum LiveRecordConfigCodingKeys: String, CodingKey {
        case publishDomain
        case appName
        case streamName
        case recordConfig
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: LiveRecordConfigCodingKeys.self)
        if decoderContainer.contains(.publishDomain)
        {
            self.publishDomain = try decoderContainer.decode(String?.self, forKey: .publishDomain)
        }
        if decoderContainer.contains(.appName)
        {
            self.appName = try decoderContainer.decode(String?.self, forKey: .appName)
        }
        if decoderContainer.contains(.streamName)
        {
            self.streamName = try decoderContainer.decode(String?.self, forKey: .streamName)
        }
        if decoderContainer.contains(.recordConfig)
        {
            self.recordConfig = try decoderContainer.decode(String?.self, forKey: .recordConfig)
        }
    }
}
public extension LiveRecordConfig{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: LiveRecordConfigCodingKeys.self)
         try encoderContainer.encode(publishDomain, forKey: .publishDomain)
         try encoderContainer.encode(appName, forKey: .appName)
         try encoderContainer.encode(streamName, forKey: .streamName)
         try encoderContainer.encode(recordConfig, forKey: .recordConfig)
    }
}
///  templateBinding
public class TemplateBinding:NSObject,Codable{
    /// 推流域名
    var publishDomain:String?
    /// 应用名称
    var appName:String?
    /// 流名称
    var streamName:String?
    /// 模板
    var template:String?



    public override init(){
            super.init()
    }

    enum TemplateBindingCodingKeys: String, CodingKey {
        case publishDomain
        case appName
        case streamName
        case template
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: TemplateBindingCodingKeys.self)
        if decoderContainer.contains(.publishDomain)
        {
            self.publishDomain = try decoderContainer.decode(String?.self, forKey: .publishDomain)
        }
        if decoderContainer.contains(.appName)
        {
            self.appName = try decoderContainer.decode(String?.self, forKey: .appName)
        }
        if decoderContainer.contains(.streamName)
        {
            self.streamName = try decoderContainer.decode(String?.self, forKey: .streamName)
        }
        if decoderContainer.contains(.template)
        {
            self.template = try decoderContainer.decode(String?.self, forKey: .template)
        }
    }
}
public extension TemplateBinding{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: TemplateBindingCodingKeys.self)
         try encoderContainer.encode(publishDomain, forKey: .publishDomain)
         try encoderContainer.encode(appName, forKey: .appName)
         try encoderContainer.encode(streamName, forKey: .streamName)
         try encoderContainer.encode(template, forKey: .template)
    }
}
///  filter
public class Filter:NSObject,Codable{
    /// 过滤器属性名
    /// Required:true
    var name:String
    /// 过滤器操作符，默认值为 eq
    var operatorValue:String?
    /// 过滤器属性值
    /// Required:true
    var values:[String?]?



    public  init(name:String,values:[String?]?){
             self.name = name
             self.values = values
    }

    enum FilterCodingKeys: String, CodingKey {
        case name
        case operatorValue = "operator"
        case values
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: FilterCodingKeys.self)
        self.name = try decoderContainer.decode(String.self, forKey: .name)
        if decoderContainer.contains(.operatorValue)
        {
            self.operatorValue = try decoderContainer.decode(String?.self, forKey: .operatorValue)
        }
        self.values = try decoderContainer.decode([String?]?.self, forKey: .values)
    }
}
public extension Filter{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: FilterCodingKeys.self)
         try encoderContainer.encode(name, forKey: .name)
         try encoderContainer.encode(operatorValue, forKey: .operatorValue)
         try encoderContainer.encode(values, forKey: .values)
    }
}
///  domainTemplateConfig
public class DomainTemplateConfig:NSObject,Codable{
    /// 应用名称
    var appName:String?
    /// 流名称
    var streamName:String?
    /// 模板ID
    var templateId:Int64?
    /// 模板名称
    var templateName:String?
    /// 录制周期
    var recordPeriod:Int?
    /// 录制格式
    var recordFileType:Int?
    /// 创建时间
    var createTime:String?



    public override init(){
            super.init()
    }

    enum DomainTemplateConfigCodingKeys: String, CodingKey {
        case appName
        case streamName
        case templateId
        case templateName
        case recordPeriod
        case recordFileType
        case createTime
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: DomainTemplateConfigCodingKeys.self)
        if decoderContainer.contains(.appName)
        {
            self.appName = try decoderContainer.decode(String?.self, forKey: .appName)
        }
        if decoderContainer.contains(.streamName)
        {
            self.streamName = try decoderContainer.decode(String?.self, forKey: .streamName)
        }
        if decoderContainer.contains(.templateId)
        {
            self.templateId = try decoderContainer.decode(Int64?.self, forKey: .templateId)
        }
        if decoderContainer.contains(.templateName)
        {
            self.templateName = try decoderContainer.decode(String?.self, forKey: .templateName)
        }
        if decoderContainer.contains(.recordPeriod)
        {
            self.recordPeriod = try decoderContainer.decode(Int?.self, forKey: .recordPeriod)
        }
        if decoderContainer.contains(.recordFileType)
        {
            self.recordFileType = try decoderContainer.decode(Int?.self, forKey: .recordFileType)
        }
        if decoderContainer.contains(.createTime)
        {
            self.createTime = try decoderContainer.decode(String?.self, forKey: .createTime)
        }
    }
}
public extension DomainTemplateConfig{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: DomainTemplateConfigCodingKeys.self)
         try encoderContainer.encode(appName, forKey: .appName)
         try encoderContainer.encode(streamName, forKey: .streamName)
         try encoderContainer.encode(templateId, forKey: .templateId)
         try encoderContainer.encode(templateName, forKey: .templateName)
         try encoderContainer.encode(recordPeriod, forKey: .recordPeriod)
         try encoderContainer.encode(recordFileType, forKey: .recordFileType)
         try encoderContainer.encode(createTime, forKey: .createTime)
    }
}
///  recordTime
public class RecordTime:NSObject,Codable{
    /// 开始时间
      /// - UTC时间
      ///   格式: yyyy-MM-dd&#39;T&#39;HH:mm:ss&#39;Z&#39;
      ///   示例: 2018-10-21T10:00:00Z
      /// 
    /// Required:true
    var startTime:String
    /// 结束时间
      /// - UTC时间
      ///   格式: yyyy-MM-dd&#39;T&#39;HH:mm:ss&#39;Z&#39;
      ///   示例: 2018-10-21T10:00:00Z
      /// 
    /// Required:true
    var endTime:String



    public  init(startTime:String,endTime:String){
             self.startTime = startTime
             self.endTime = endTime
    }

    enum RecordTimeCodingKeys: String, CodingKey {
        case startTime
        case endTime
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: RecordTimeCodingKeys.self)
        self.startTime = try decoderContainer.decode(String.self, forKey: .startTime)
        self.endTime = try decoderContainer.decode(String.self, forKey: .endTime)
    }
}
public extension RecordTime{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: RecordTimeCodingKeys.self)
         try encoderContainer.encode(startTime, forKey: .startTime)
         try encoderContainer.encode(endTime, forKey: .endTime)
    }
}
///  recordTemplate
public class RecordTemplate:NSObject,Codable{
    /// 自动录制周期
      /// - 取值:[15,360]
      /// - 单位: 分钟
      /// 
    var recordPeriod:Int?
    /// 存储桶
    var saveBucket:String?
    /// 存储地址
    var saveEndpoint:String?
    /// 录制文件格式
      /// - 取值: ts,flv,mp4 (多种类型之前用;隔开)
      /// - 不区分大小写
      /// 
    var recordFileType:String?
    /// 录制模板
      /// - 取值要求：数字、大小写字母或短横线(&quot;-&quot;),
      ///           首尾不能有特殊字符(&quot;-&quot;)
      /// - &lt;b&gt;注意: 不能与已定义命名重复&lt;/b&gt;
      /// 
    var template:String?



    public override init(){
            super.init()
    }

    enum RecordTemplateCodingKeys: String, CodingKey {
        case recordPeriod
        case saveBucket
        case saveEndpoint
        case recordFileType
        case template
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: RecordTemplateCodingKeys.self)
        if decoderContainer.contains(.recordPeriod)
        {
            self.recordPeriod = try decoderContainer.decode(Int?.self, forKey: .recordPeriod)
        }
        if decoderContainer.contains(.saveBucket)
        {
            self.saveBucket = try decoderContainer.decode(String?.self, forKey: .saveBucket)
        }
        if decoderContainer.contains(.saveEndpoint)
        {
            self.saveEndpoint = try decoderContainer.decode(String?.self, forKey: .saveEndpoint)
        }
        if decoderContainer.contains(.recordFileType)
        {
            self.recordFileType = try decoderContainer.decode(String?.self, forKey: .recordFileType)
        }
        if decoderContainer.contains(.template)
        {
            self.template = try decoderContainer.decode(String?.self, forKey: .template)
        }
    }
}
public extension RecordTemplate{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: RecordTemplateCodingKeys.self)
         try encoderContainer.encode(recordPeriod, forKey: .recordPeriod)
         try encoderContainer.encode(saveBucket, forKey: .saveBucket)
         try encoderContainer.encode(saveEndpoint, forKey: .saveEndpoint)
         try encoderContainer.encode(recordFileType, forKey: .recordFileType)
         try encoderContainer.encode(template, forKey: .template)
    }
}
///  snapshotConfig
public class SnapshotConfig:NSObject,Codable{
    /// 推流域名
    var publishDomain:String?
    /// 应用名称
    var appName:String?
    /// 流名称
    var streamName:String?
    /// SnapshotConfigValue
    var snapshotConfigValue:[String?]?



    public override init(){
            super.init()
    }

    enum SnapshotConfigCodingKeys: String, CodingKey {
        case publishDomain
        case appName
        case streamName
        case snapshotConfigValue = "snapshotConfig"
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: SnapshotConfigCodingKeys.self)
        if decoderContainer.contains(.publishDomain)
        {
            self.publishDomain = try decoderContainer.decode(String?.self, forKey: .publishDomain)
        }
        if decoderContainer.contains(.appName)
        {
            self.appName = try decoderContainer.decode(String?.self, forKey: .appName)
        }
        if decoderContainer.contains(.streamName)
        {
            self.streamName = try decoderContainer.decode(String?.self, forKey: .streamName)
        }
        if decoderContainer.contains(.snapshotConfigValue)
        {
            self.snapshotConfigValue = try decoderContainer.decode([String?]?.self, forKey: .snapshotConfigValue)
        }
    }
}
public extension SnapshotConfig{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: SnapshotConfigCodingKeys.self)
         try encoderContainer.encode(publishDomain, forKey: .publishDomain)
         try encoderContainer.encode(appName, forKey: .appName)
         try encoderContainer.encode(streamName, forKey: .streamName)
         try encoderContainer.encode(snapshotConfigValue, forKey: .snapshotConfigValue)
    }
}
///  snapshotTemplate
public class SnapshotTemplate:NSObject,Codable{
    /// 截图格式
      /// 
    var format:String?
    /// 截图宽度
      /// - 单位: 像素
      /// 
    var width:Int?
    /// 截图高度
      /// - 单位: 像素
      /// 
    var height:Int?
    /// 截图与设定的宽高不匹配时的处理规则
      ///   1: 拉伸
      ///   2: 留黑
      ///   3: 留白
      ///   4: 高斯模糊
      /// 
    var fillType:Int?
    /// 截图周期
      /// - 单位: 秒
      /// 
    var snapshotInterval:Int?
    /// 存储模式
      ///   1: 覆盖
      ///   2: 顺序编号存储
      /// 
    var saveMode:Int?
    /// 存储桶
    var saveBucket:String?
    /// 存储地址
    var saveEndpoint:String?
    /// 截图模板自定义名称
      /// 
    var template:String?



    public override init(){
            super.init()
    }

    enum SnapshotTemplateCodingKeys: String, CodingKey {
        case format
        case width
        case height
        case fillType
        case snapshotInterval
        case saveMode
        case saveBucket
        case saveEndpoint
        case template
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: SnapshotTemplateCodingKeys.self)
        if decoderContainer.contains(.format)
        {
            self.format = try decoderContainer.decode(String?.self, forKey: .format)
        }
        if decoderContainer.contains(.width)
        {
            self.width = try decoderContainer.decode(Int?.self, forKey: .width)
        }
        if decoderContainer.contains(.height)
        {
            self.height = try decoderContainer.decode(Int?.self, forKey: .height)
        }
        if decoderContainer.contains(.fillType)
        {
            self.fillType = try decoderContainer.decode(Int?.self, forKey: .fillType)
        }
        if decoderContainer.contains(.snapshotInterval)
        {
            self.snapshotInterval = try decoderContainer.decode(Int?.self, forKey: .snapshotInterval)
        }
        if decoderContainer.contains(.saveMode)
        {
            self.saveMode = try decoderContainer.decode(Int?.self, forKey: .saveMode)
        }
        if decoderContainer.contains(.saveBucket)
        {
            self.saveBucket = try decoderContainer.decode(String?.self, forKey: .saveBucket)
        }
        if decoderContainer.contains(.saveEndpoint)
        {
            self.saveEndpoint = try decoderContainer.decode(String?.self, forKey: .saveEndpoint)
        }
        if decoderContainer.contains(.template)
        {
            self.template = try decoderContainer.decode(String?.self, forKey: .template)
        }
    }
}
public extension SnapshotTemplate{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: SnapshotTemplateCodingKeys.self)
         try encoderContainer.encode(format, forKey: .format)
         try encoderContainer.encode(width, forKey: .width)
         try encoderContainer.encode(height, forKey: .height)
         try encoderContainer.encode(fillType, forKey: .fillType)
         try encoderContainer.encode(snapshotInterval, forKey: .snapshotInterval)
         try encoderContainer.encode(saveMode, forKey: .saveMode)
         try encoderContainer.encode(saveBucket, forKey: .saveBucket)
         try encoderContainer.encode(saveEndpoint, forKey: .saveEndpoint)
         try encoderContainer.encode(template, forKey: .template)
    }
}
///  snapshot
public class Snapshot:NSObject,Codable{
    /// 截图ID
      /// 
    var imgId:String?
    /// 截图格式
      /// 
    var format:String?
    /// 截图宽度
      /// - 单位: 像素
      /// 
    var width:Int?
    /// 截图高度
      /// - 单位: 像素
      /// 
    var height:Int?
    /// 截图时间点
      /// 
    var snapshotTime:String?
    /// 截图文件大小
      /// 
    var size:Int?
    /// 截图地址
      /// 
    var imgUrl:String?



    public override init(){
            super.init()
    }

    enum SnapshotCodingKeys: String, CodingKey {
        case imgId
        case format
        case width
        case height
        case snapshotTime
        case size
        case imgUrl
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: SnapshotCodingKeys.self)
        if decoderContainer.contains(.imgId)
        {
            self.imgId = try decoderContainer.decode(String?.self, forKey: .imgId)
        }
        if decoderContainer.contains(.format)
        {
            self.format = try decoderContainer.decode(String?.self, forKey: .format)
        }
        if decoderContainer.contains(.width)
        {
            self.width = try decoderContainer.decode(Int?.self, forKey: .width)
        }
        if decoderContainer.contains(.height)
        {
            self.height = try decoderContainer.decode(Int?.self, forKey: .height)
        }
        if decoderContainer.contains(.snapshotTime)
        {
            self.snapshotTime = try decoderContainer.decode(String?.self, forKey: .snapshotTime)
        }
        if decoderContainer.contains(.size)
        {
            self.size = try decoderContainer.decode(Int?.self, forKey: .size)
        }
        if decoderContainer.contains(.imgUrl)
        {
            self.imgUrl = try decoderContainer.decode(String?.self, forKey: .imgUrl)
        }
    }
}
public extension Snapshot{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: SnapshotCodingKeys.self)
         try encoderContainer.encode(imgId, forKey: .imgId)
         try encoderContainer.encode(format, forKey: .format)
         try encoderContainer.encode(width, forKey: .width)
         try encoderContainer.encode(height, forKey: .height)
         try encoderContainer.encode(snapshotTime, forKey: .snapshotTime)
         try encoderContainer.encode(size, forKey: .size)
         try encoderContainer.encode(imgUrl, forKey: .imgUrl)
    }
}
///  修改质检模板请求信息
public class UpdateQualityDetectionTemplateRequestObject:NSObject,Codable{
    /// 模板名称。长度不超过128个字符。UTF-8编码
      /// 
    /// Required:true
    var template:String
    /// 检测项列表。取值范围：
      ///   BlackScreen - 黑屏
      ///   PureColor - 纯色
      ///   ColorCast - 偏色
      ///   FrozenFrame - 静帧
      ///   Brightness - 亮度
      ///   Contrast - 对比度
      /// 
    var modules:[String?]?



    public  init(template:String){
             self.template = template
    }

    enum UpdateQualityDetectionTemplateRequestObjectCodingKeys: String, CodingKey {
        case template
        case modules
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: UpdateQualityDetectionTemplateRequestObjectCodingKeys.self)
        self.template = try decoderContainer.decode(String.self, forKey: .template)
        if decoderContainer.contains(.modules)
        {
            self.modules = try decoderContainer.decode([String?]?.self, forKey: .modules)
        }
    }
}
public extension UpdateQualityDetectionTemplateRequestObject{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: UpdateQualityDetectionTemplateRequestObjectCodingKeys.self)
         try encoderContainer.encode(template, forKey: .template)
         try encoderContainer.encode(modules, forKey: .modules)
    }
}
///  创建质检模板请求信息
public class CreateQualityDetectionTemplateRequestObject:NSObject,Codable{
    /// 模板名称。长度不超过128个字符。UTF-8编码
      /// 
    /// Required:true
    var template:String
    /// 检测项列表。取值范围：
      ///   BlackScreen - 黑屏
      ///   PureColor - 纯色
      ///   ColorCast - 偏色
      ///   FrozenFrame - 静帧
      ///   Brightness - 亮度
      ///   Contrast - 对比度
      /// 
    /// Required:true
    var modules:[String?]?



    public  init(template:String,modules:[String?]?){
             self.template = template
             self.modules = modules
    }

    enum CreateQualityDetectionTemplateRequestObjectCodingKeys: String, CodingKey {
        case template
        case modules
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: CreateQualityDetectionTemplateRequestObjectCodingKeys.self)
        self.template = try decoderContainer.decode(String.self, forKey: .template)
        self.modules = try decoderContainer.decode([String?]?.self, forKey: .modules)
    }
}
public extension CreateQualityDetectionTemplateRequestObject{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: CreateQualityDetectionTemplateRequestObjectCodingKeys.self)
         try encoderContainer.encode(template, forKey: .template)
         try encoderContainer.encode(modules, forKey: .modules)
    }
}
///  qualityDetectionTemplate
public class QualityDetectionTemplate:NSObject,Codable{
    /// 模板名称
      /// 
    var template:String?
    /// 检测项列表
      /// 
    var modules:String?



    public override init(){
            super.init()
    }

    enum QualityDetectionTemplateCodingKeys: String, CodingKey {
        case template
        case modules
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: QualityDetectionTemplateCodingKeys.self)
        if decoderContainer.contains(.template)
        {
            self.template = try decoderContainer.decode(String?.self, forKey: .template)
        }
        if decoderContainer.contains(.modules)
        {
            self.modules = try decoderContainer.decode(String?.self, forKey: .modules)
        }
    }
}
public extension QualityDetectionTemplate{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: QualityDetectionTemplateCodingKeys.self)
         try encoderContainer.encode(template, forKey: .template)
         try encoderContainer.encode(modules, forKey: .modules)
    }
}
///  userBucket
public class UserBucket:NSObject,Codable{
    /// Bucket名称
    var name:String?



    public override init(){
            super.init()
    }

    enum UserBucketCodingKeys: String, CodingKey {
        case name
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: UserBucketCodingKeys.self)
        if decoderContainer.contains(.name)
        {
            self.name = try decoderContainer.decode(String?.self, forKey: .name)
        }
    }
}
public extension UserBucket{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: UserBucketCodingKeys.self)
         try encoderContainer.encode(name, forKey: .name)
    }
}
///  publishStreamInfoData
public class PublishStreamInfoData:NSObject,Codable{
    /// 流名称
      /// 
    var streamName:String?
    /// 帧率
      /// 
    var fps:String?
    /// 码率，单位：bps
      /// 
    var bitrate:String?
    /// CDN上行节点IP列表
      /// 
    var pushEdgeNodeIps:[String?]?
    /// 主播IP列表
      /// 
    var anchorIps:[String?]?
    /// Flv观看带宽
      /// 
    var flvBandWidth:Int64?
    /// Flv观看人数
      /// 
    var flvPlayerCount:Int64?
    /// Hls观看带宽
      /// 
    var hlsBandWidth:Int64?
    /// Hls观看人数
      /// 
    var hlsPlayerCount:Int64?



    public override init(){
            super.init()
    }

    enum PublishStreamInfoDataCodingKeys: String, CodingKey {
        case streamName
        case fps
        case bitrate
        case pushEdgeNodeIps
        case anchorIps
        case flvBandWidth
        case flvPlayerCount
        case hlsBandWidth
        case hlsPlayerCount
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: PublishStreamInfoDataCodingKeys.self)
        if decoderContainer.contains(.streamName)
        {
            self.streamName = try decoderContainer.decode(String?.self, forKey: .streamName)
        }
        if decoderContainer.contains(.fps)
        {
            self.fps = try decoderContainer.decode(String?.self, forKey: .fps)
        }
        if decoderContainer.contains(.bitrate)
        {
            self.bitrate = try decoderContainer.decode(String?.self, forKey: .bitrate)
        }
        if decoderContainer.contains(.pushEdgeNodeIps)
        {
            self.pushEdgeNodeIps = try decoderContainer.decode([String?]?.self, forKey: .pushEdgeNodeIps)
        }
        if decoderContainer.contains(.anchorIps)
        {
            self.anchorIps = try decoderContainer.decode([String?]?.self, forKey: .anchorIps)
        }
        if decoderContainer.contains(.flvBandWidth)
        {
            self.flvBandWidth = try decoderContainer.decode(Int64?.self, forKey: .flvBandWidth)
        }
        if decoderContainer.contains(.flvPlayerCount)
        {
            self.flvPlayerCount = try decoderContainer.decode(Int64?.self, forKey: .flvPlayerCount)
        }
        if decoderContainer.contains(.hlsBandWidth)
        {
            self.hlsBandWidth = try decoderContainer.decode(Int64?.self, forKey: .hlsBandWidth)
        }
        if decoderContainer.contains(.hlsPlayerCount)
        {
            self.hlsPlayerCount = try decoderContainer.decode(Int64?.self, forKey: .hlsPlayerCount)
        }
    }
}
public extension PublishStreamInfoData{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: PublishStreamInfoDataCodingKeys.self)
         try encoderContainer.encode(streamName, forKey: .streamName)
         try encoderContainer.encode(fps, forKey: .fps)
         try encoderContainer.encode(bitrate, forKey: .bitrate)
         try encoderContainer.encode(pushEdgeNodeIps, forKey: .pushEdgeNodeIps)
         try encoderContainer.encode(anchorIps, forKey: .anchorIps)
         try encoderContainer.encode(flvBandWidth, forKey: .flvBandWidth)
         try encoderContainer.encode(flvPlayerCount, forKey: .flvPlayerCount)
         try encoderContainer.encode(hlsBandWidth, forKey: .hlsBandWidth)
         try encoderContainer.encode(hlsPlayerCount, forKey: .hlsPlayerCount)
    }
}
///  domainsLogResultData
public class DomainsLogResultData:NSObject,Codable{
    /// 文件名称
      /// 
    var fileName:String?
    /// 下载地址
      /// 
    var logUrl:String?
    /// 文件md5
      /// 
    var md5:String?
    /// 文件大小，单位：Byte
      /// 
    var size:Int64?
    /// 开始时间，UTC时间格式
      /// 
    var startTime:String?
    /// 结束时间，UTC时间格式
      /// 
    var endTime:String?



    public override init(){
            super.init()
    }

    enum DomainsLogResultDataCodingKeys: String, CodingKey {
        case fileName
        case logUrl
        case md5
        case size
        case startTime
        case endTime
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: DomainsLogResultDataCodingKeys.self)
        if decoderContainer.contains(.fileName)
        {
            self.fileName = try decoderContainer.decode(String?.self, forKey: .fileName)
        }
        if decoderContainer.contains(.logUrl)
        {
            self.logUrl = try decoderContainer.decode(String?.self, forKey: .logUrl)
        }
        if decoderContainer.contains(.md5)
        {
            self.md5 = try decoderContainer.decode(String?.self, forKey: .md5)
        }
        if decoderContainer.contains(.size)
        {
            self.size = try decoderContainer.decode(Int64?.self, forKey: .size)
        }
        if decoderContainer.contains(.startTime)
        {
            self.startTime = try decoderContainer.decode(String?.self, forKey: .startTime)
        }
        if decoderContainer.contains(.endTime)
        {
            self.endTime = try decoderContainer.decode(String?.self, forKey: .endTime)
        }
    }
}
public extension DomainsLogResultData{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: DomainsLogResultDataCodingKeys.self)
         try encoderContainer.encode(fileName, forKey: .fileName)
         try encoderContainer.encode(logUrl, forKey: .logUrl)
         try encoderContainer.encode(md5, forKey: .md5)
         try encoderContainer.encode(size, forKey: .size)
         try encoderContainer.encode(startTime, forKey: .startTime)
         try encoderContainer.encode(endTime, forKey: .endTime)
    }
}
///  domainsLogResult
public class DomainsLogResult:NSObject,Codable{
    /// 域名
      /// 
    var domain:String?
    /// LogList
    var logList:[DomainsLogResultData?]?



    public override init(){
            super.init()
    }

    enum DomainsLogResultCodingKeys: String, CodingKey {
        case domain
        case logList
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: DomainsLogResultCodingKeys.self)
        if decoderContainer.contains(.domain)
        {
            self.domain = try decoderContainer.decode(String?.self, forKey: .domain)
        }
        if decoderContainer.contains(.logList)
        {
            self.logList = try decoderContainer.decode([DomainsLogResultData?]?.self, forKey: .logList)
        }
    }
}
public extension DomainsLogResult{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: DomainsLogResultCodingKeys.self)
         try encoderContainer.encode(domain, forKey: .domain)
         try encoderContainer.encode(logList, forKey: .logList)
    }
}
///  publishStreamInfoResult
public class PublishStreamInfoResult:NSObject,Codable{
    /// 起始时间点，UTC时间，格式：yyyy-MM-dd&#39;T&#39;HH:mm:ss&#39;Z&#39;
      /// 
    var startTime:String?
    /// 结束时间点，UTC时间，格式：yyyy-MM-dd&#39;T&#39;HH:mm:ss&#39;Z&#39;
      /// 
    var endTime:String?
    /// Data
    var data:PublishStreamInfoData?



    public override init(){
            super.init()
    }

    enum PublishStreamInfoResultCodingKeys: String, CodingKey {
        case startTime
        case endTime
        case data
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: PublishStreamInfoResultCodingKeys.self)
        if decoderContainer.contains(.startTime)
        {
            self.startTime = try decoderContainer.decode(String?.self, forKey: .startTime)
        }
        if decoderContainer.contains(.endTime)
        {
            self.endTime = try decoderContainer.decode(String?.self, forKey: .endTime)
        }
        if decoderContainer.contains(.data)
        {
            self.data = try decoderContainer.decode(PublishStreamInfoData?.self, forKey: .data)
        }
    }
}
public extension PublishStreamInfoResult{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: PublishStreamInfoResultCodingKeys.self)
         try encoderContainer.encode(startTime, forKey: .startTime)
         try encoderContainer.encode(endTime, forKey: .endTime)
         try encoderContainer.encode(data, forKey: .data)
    }
}
///  liveStreamPlayerRankingResult
public class LiveStreamPlayerRankingResult:NSObject,Codable{
    /// 起始时间点，UTC时间，格式：yyyy-MM-dd&#39;T&#39;HH:mm:ss&#39;Z&#39;
      /// 
    var startTime:String?
    /// 结束时间点，UTC时间，格式：yyyy-MM-dd&#39;T&#39;HH:mm:ss&#39;Z&#39;
      /// 
    var endTime:String?
    /// 排行
      /// 
    var ranking:Int64?
    /// 流名称
      /// 
    var streamName:String?
    /// 观众数量
      /// 
    var playerCount:Int64?



    public override init(){
            super.init()
    }

    enum LiveStreamPlayerRankingResultCodingKeys: String, CodingKey {
        case startTime
        case endTime
        case ranking
        case streamName
        case playerCount
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: LiveStreamPlayerRankingResultCodingKeys.self)
        if decoderContainer.contains(.startTime)
        {
            self.startTime = try decoderContainer.decode(String?.self, forKey: .startTime)
        }
        if decoderContainer.contains(.endTime)
        {
            self.endTime = try decoderContainer.decode(String?.self, forKey: .endTime)
        }
        if decoderContainer.contains(.ranking)
        {
            self.ranking = try decoderContainer.decode(Int64?.self, forKey: .ranking)
        }
        if decoderContainer.contains(.streamName)
        {
            self.streamName = try decoderContainer.decode(String?.self, forKey: .streamName)
        }
        if decoderContainer.contains(.playerCount)
        {
            self.playerCount = try decoderContainer.decode(Int64?.self, forKey: .playerCount)
        }
    }
}
public extension LiveStreamPlayerRankingResult{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: LiveStreamPlayerRankingResultCodingKeys.self)
         try encoderContainer.encode(startTime, forKey: .startTime)
         try encoderContainer.encode(endTime, forKey: .endTime)
         try encoderContainer.encode(ranking, forKey: .ranking)
         try encoderContainer.encode(streamName, forKey: .streamName)
         try encoderContainer.encode(playerCount, forKey: .playerCount)
    }
}
///  rankingUrlResultRankData
public class RankingUrlResultRankData:NSObject,Codable{
    /// 独立访问数
      /// 
    var uv:Int64?
    /// 带宽，单位：bps
      /// 
    var bandwidth:Int64?
    /// 访问次数
      /// 
    var pv:Int64?
    /// 流量，单位：Byte
    var flow:Int64?



    public override init(){
            super.init()
    }

    enum RankingUrlResultRankDataCodingKeys: String, CodingKey {
        case uv
        case bandwidth
        case pv
        case flow
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: RankingUrlResultRankDataCodingKeys.self)
        if decoderContainer.contains(.uv)
        {
            self.uv = try decoderContainer.decode(Int64?.self, forKey: .uv)
        }
        if decoderContainer.contains(.bandwidth)
        {
            self.bandwidth = try decoderContainer.decode(Int64?.self, forKey: .bandwidth)
        }
        if decoderContainer.contains(.pv)
        {
            self.pv = try decoderContainer.decode(Int64?.self, forKey: .pv)
        }
        if decoderContainer.contains(.flow)
        {
            self.flow = try decoderContainer.decode(Int64?.self, forKey: .flow)
        }
    }
}
public extension RankingUrlResultRankData{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: RankingUrlResultRankDataCodingKeys.self)
         try encoderContainer.encode(uv, forKey: .uv)
         try encoderContainer.encode(bandwidth, forKey: .bandwidth)
         try encoderContainer.encode(pv, forKey: .pv)
         try encoderContainer.encode(flow, forKey: .flow)
    }
}
///  publishOnlineStreamResultData
public class PublishOnlineStreamResultData:NSObject,Codable{
    /// APP名称
      /// 
    var appName:String?
    /// 流名称
      /// 
    var streamName:String?
    /// 客户端ip
      /// 
    var clientIp:String?
    /// 边缘节点ip
      /// 
    var serverIp:String?
    /// 帧率
      /// 
    var frameRate:Double?
    /// 丢帧率
      /// 
    var frameLossRate:Double?
    /// 最近活跃时间
      /// 
    var lastActive:Int64?
    /// 实时帧率
      /// 
    var realFps:Double?
    /// 上传速度  单位：KB/s
      /// 
    var uploadSpeed:Int64?
    /// 视频codec，取值：
      /// - VideoAVC &#x3D; 7
      /// - VideoHEVC &#x3D; 12
      /// 
    var videoCodec:Int64?
    /// 视频码率 单位：KB/s
      /// 
    var videoDataRate:Int64?
    /// 音频codec，取值：
      /// - AudioReserved1 &#x3D; 16
      /// - AudioDisabled &#x3D; 17
      /// - AudioLinearPCMPlatformEndian &#x3D; 0
      /// - AudioADPCM &#x3D; 1
      /// - AudioMP3 &#x3D; 2
      /// - AudioLinearPCMLittleEndian &#x3D; 3
      /// - AudioNellymoser16kHzMono &#x3D; 4
      /// - AudioNellymoser8kHzMono &#x3D; 5
      /// - AudioNellymoser &#x3D; 6
      /// - AudioReservedG711AlawLogarithmicPCM &#x3D; 7
      /// - AudioReservedG711MuLawLogarithmicPCM &#x3D; 8
      /// - AudioReserved &#x3D; 9
      /// - AudioAAC &#x3D; 10
      /// - AudioSpeex &#x3D; 11
      /// - AudioReservedMP3_8kHz &#x3D; 14
      /// - AudioReservedDeviceSpecificSound &#x3D; 15
      /// 
    var audioCodec:Int64?



    public override init(){
            super.init()
    }

    enum PublishOnlineStreamResultDataCodingKeys: String, CodingKey {
        case appName
        case streamName
        case clientIp
        case serverIp
        case frameRate
        case frameLossRate
        case lastActive
        case realFps
        case uploadSpeed
        case videoCodec
        case videoDataRate
        case audioCodec
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: PublishOnlineStreamResultDataCodingKeys.self)
        if decoderContainer.contains(.appName)
        {
            self.appName = try decoderContainer.decode(String?.self, forKey: .appName)
        }
        if decoderContainer.contains(.streamName)
        {
            self.streamName = try decoderContainer.decode(String?.self, forKey: .streamName)
        }
        if decoderContainer.contains(.clientIp)
        {
            self.clientIp = try decoderContainer.decode(String?.self, forKey: .clientIp)
        }
        if decoderContainer.contains(.serverIp)
        {
            self.serverIp = try decoderContainer.decode(String?.self, forKey: .serverIp)
        }
        if decoderContainer.contains(.frameRate)
        {
            self.frameRate = try decoderContainer.decode(Double?.self, forKey: .frameRate)
        }
        if decoderContainer.contains(.frameLossRate)
        {
            self.frameLossRate = try decoderContainer.decode(Double?.self, forKey: .frameLossRate)
        }
        if decoderContainer.contains(.lastActive)
        {
            self.lastActive = try decoderContainer.decode(Int64?.self, forKey: .lastActive)
        }
        if decoderContainer.contains(.realFps)
        {
            self.realFps = try decoderContainer.decode(Double?.self, forKey: .realFps)
        }
        if decoderContainer.contains(.uploadSpeed)
        {
            self.uploadSpeed = try decoderContainer.decode(Int64?.self, forKey: .uploadSpeed)
        }
        if decoderContainer.contains(.videoCodec)
        {
            self.videoCodec = try decoderContainer.decode(Int64?.self, forKey: .videoCodec)
        }
        if decoderContainer.contains(.videoDataRate)
        {
            self.videoDataRate = try decoderContainer.decode(Int64?.self, forKey: .videoDataRate)
        }
        if decoderContainer.contains(.audioCodec)
        {
            self.audioCodec = try decoderContainer.decode(Int64?.self, forKey: .audioCodec)
        }
    }
}
public extension PublishOnlineStreamResultData{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: PublishOnlineStreamResultDataCodingKeys.self)
         try encoderContainer.encode(appName, forKey: .appName)
         try encoderContainer.encode(streamName, forKey: .streamName)
         try encoderContainer.encode(clientIp, forKey: .clientIp)
         try encoderContainer.encode(serverIp, forKey: .serverIp)
         try encoderContainer.encode(frameRate, forKey: .frameRate)
         try encoderContainer.encode(frameLossRate, forKey: .frameLossRate)
         try encoderContainer.encode(lastActive, forKey: .lastActive)
         try encoderContainer.encode(realFps, forKey: .realFps)
         try encoderContainer.encode(uploadSpeed, forKey: .uploadSpeed)
         try encoderContainer.encode(videoCodec, forKey: .videoCodec)
         try encoderContainer.encode(videoDataRate, forKey: .videoDataRate)
         try encoderContainer.encode(audioCodec, forKey: .audioCodec)
    }
}
///  liveStreamUserNumResult
public class LiveStreamUserNumResult:NSObject,Codable{
    /// 起始时间点，UTC时间，格式：yyyy-MM-dd&#39;T&#39;HH:mm:ss&#39;Z&#39;
      /// 
    var startTime:String?
    /// 结束时间点，UTC时间，格式：yyyy-MM-dd&#39;T&#39;HH:mm:ss&#39;Z&#39;
      /// 
    var endTime:String?
    /// Data
    var data:LiveStreamUserNumResultData?



    public override init(){
            super.init()
    }

    enum LiveStreamUserNumResultCodingKeys: String, CodingKey {
        case startTime
        case endTime
        case data
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: LiveStreamUserNumResultCodingKeys.self)
        if decoderContainer.contains(.startTime)
        {
            self.startTime = try decoderContainer.decode(String?.self, forKey: .startTime)
        }
        if decoderContainer.contains(.endTime)
        {
            self.endTime = try decoderContainer.decode(String?.self, forKey: .endTime)
        }
        if decoderContainer.contains(.data)
        {
            self.data = try decoderContainer.decode(LiveStreamUserNumResultData?.self, forKey: .data)
        }
    }
}
public extension LiveStreamUserNumResult{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: LiveStreamUserNumResultCodingKeys.self)
         try encoderContainer.encode(startTime, forKey: .startTime)
         try encoderContainer.encode(endTime, forKey: .endTime)
         try encoderContainer.encode(data, forKey: .data)
    }
}
///  liveStreamUserNumResultData
public class LiveStreamUserNumResultData:NSObject,Codable{
    /// 人数
      /// 
    var count:Int64?



    public override init(){
            super.init()
    }

    enum LiveStreamUserNumResultDataCodingKeys: String, CodingKey {
        case count
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: LiveStreamUserNumResultDataCodingKeys.self)
        if decoderContainer.contains(.count)
        {
            self.count = try decoderContainer.decode(Int64?.self, forKey: .count)
        }
    }
}
public extension LiveStreamUserNumResultData{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: LiveStreamUserNumResultDataCodingKeys.self)
         try encoderContainer.encode(count, forKey: .count)
    }
}
///  liveTranscodeStreamResult
public class LiveTranscodeStreamResult:NSObject,Codable{
    /// 流名称
      /// 
    var streamName:String?
    /// 流状态
      /// 
    var status:String?



    public override init(){
            super.init()
    }

    enum LiveTranscodeStreamResultCodingKeys: String, CodingKey {
        case streamName
        case status
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: LiveTranscodeStreamResultCodingKeys.self)
        if decoderContainer.contains(.streamName)
        {
            self.streamName = try decoderContainer.decode(String?.self, forKey: .streamName)
        }
        if decoderContainer.contains(.status)
        {
            self.status = try decoderContainer.decode(String?.self, forKey: .status)
        }
    }
}
public extension LiveTranscodeStreamResult{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: LiveTranscodeStreamResultCodingKeys.self)
         try encoderContainer.encode(streamName, forKey: .streamName)
         try encoderContainer.encode(status, forKey: .status)
    }
}
///  rankingUrlResultData
public class RankingUrlResultData:NSObject,Codable{
    /// URL
      /// 
    var url:String?
    /// 排行序号
      /// 
    var rank:Int?
    /// 文件md5
      /// 
    var md5:String?
    /// 排行依据字段对应的数值
      /// 
    var value:Int64?
    /// Data
    var data:[RankingUrlResultRankData?]?



    public override init(){
            super.init()
    }

    enum RankingUrlResultDataCodingKeys: String, CodingKey {
        case url
        case rank
        case md5
        case value
        case data
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: RankingUrlResultDataCodingKeys.self)
        if decoderContainer.contains(.url)
        {
            self.url = try decoderContainer.decode(String?.self, forKey: .url)
        }
        if decoderContainer.contains(.rank)
        {
            self.rank = try decoderContainer.decode(Int?.self, forKey: .rank)
        }
        if decoderContainer.contains(.md5)
        {
            self.md5 = try decoderContainer.decode(String?.self, forKey: .md5)
        }
        if decoderContainer.contains(.value)
        {
            self.value = try decoderContainer.decode(Int64?.self, forKey: .value)
        }
        if decoderContainer.contains(.data)
        {
            self.data = try decoderContainer.decode([RankingUrlResultRankData?]?.self, forKey: .data)
        }
    }
}
public extension RankingUrlResultData{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: RankingUrlResultDataCodingKeys.self)
         try encoderContainer.encode(url, forKey: .url)
         try encoderContainer.encode(rank, forKey: .rank)
         try encoderContainer.encode(md5, forKey: .md5)
         try encoderContainer.encode(value, forKey: .value)
         try encoderContainer.encode(data, forKey: .data)
    }
}
///  rankingUrlResult
public class RankingUrlResult:NSObject,Codable{
    /// RankingList
    var rankingList:[RankingUrlResultData?]?



    public override init(){
            super.init()
    }

    enum RankingUrlResultCodingKeys: String, CodingKey {
        case rankingList
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: RankingUrlResultCodingKeys.self)
        if decoderContainer.contains(.rankingList)
        {
            self.rankingList = try decoderContainer.decode([RankingUrlResultData?]?.self, forKey: .rankingList)
        }
    }
}
public extension RankingUrlResult{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: RankingUrlResultCodingKeys.self)
         try encoderContainer.encode(rankingList, forKey: .rankingList)
    }
}
///  templateConfig
public class TemplateConfig:NSObject,Codable{
    /// 推流域名
    var publishDomain:String?
    /// 应用名称
    var appName:String?
    /// 流名称
    var streamName:String?
    /// TranscodeConfig
    var transcodeConfig:[String?]?



    public override init(){
            super.init()
    }

    enum TemplateConfigCodingKeys: String, CodingKey {
        case publishDomain
        case appName
        case streamName
        case transcodeConfig
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: TemplateConfigCodingKeys.self)
        if decoderContainer.contains(.publishDomain)
        {
            self.publishDomain = try decoderContainer.decode(String?.self, forKey: .publishDomain)
        }
        if decoderContainer.contains(.appName)
        {
            self.appName = try decoderContainer.decode(String?.self, forKey: .appName)
        }
        if decoderContainer.contains(.streamName)
        {
            self.streamName = try decoderContainer.decode(String?.self, forKey: .streamName)
        }
        if decoderContainer.contains(.transcodeConfig)
        {
            self.transcodeConfig = try decoderContainer.decode([String?]?.self, forKey: .transcodeConfig)
        }
    }
}
public extension TemplateConfig{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: TemplateConfigCodingKeys.self)
         try encoderContainer.encode(publishDomain, forKey: .publishDomain)
         try encoderContainer.encode(appName, forKey: .appName)
         try encoderContainer.encode(streamName, forKey: .streamName)
         try encoderContainer.encode(transcodeConfig, forKey: .transcodeConfig)
    }
}
///  transcodeInfo
public class TranscodeInfo:NSObject,Codable{
    /// 视频编码格式
      ///   - 取值：h264,h265，默认h264
      /// 
    var videoCodec:String?
    /// 转码输出的码率值:
      ///   - 取值: [128,15000]
      ///   - 单位: kpbs
      /// 
    var videoCodeRate:Int?
    /// 转码输出的帧率值:
      ///   - 取值：[1,30]
      /// 
    var videoFrameRate:String?
    /// 转码输出视频宽度:
      ///   - 取值: [128,4096]
      ///   - 等比: 如果只填写一个参数,则按参数比例调节输出转码视频
      ///   - 随源: 如果两个参数都不填写，则按照源比例输出转码视频
      /// 
    var width:Int?
    /// 转码输出视频高度:
      ///   - 取值: [128,4096]
      ///   - 等比: 如果只填写一个参数,则按参数比例调节输出转码视频
      ///   - 随源: 如果两个参数都不填写，则按照源比例输出转码视频
      /// 
    var height:Int?
    /// 转码模板自定义名称:
      ///   - 自定义模板: 枚举类型校验，忽略大小写，自动删除空格,
      ///               取值要求：数字、大小写字母或短横线(&quot;-&quot;),
      ///               首尾不能有特殊字符(&quot;-&quot;)
      ///   - 注意: 不能与标准的转码模板和已定义命名重复
      /// 
    var template:String?
    /// 转码模板名称
      /// 
    var templateName:String?
    /// 转码输出音频编码格式:
      ///   - 取值: aac、mp3
      ///   - 不区分大小写
      /// 
    var audioCodec:String?
    /// 转码输出音频格式:
      ///   - 取值: aac_lc，aac_low，aac_he，aac_he_v2
      ///   - 不区分大小写
      /// 
    var audioFormat:String?
    /// 转码输出音频采样率:
      ///   - 取值: [44100,48000]
      /// 
    var audioSampleRate:Int?
    /// 转码输出音频通道数:
      ///   - 1  单声道
      ///   - 2  双声道
      /// 
    var audioChannel:Int?
    /// 转码输出音频码率:
      ///   - 取值: [16,128]
      ///   - 单位: kbps
      /// 
    var audioCodeRate:Int?
    /// 京享超清
      /// - 取值: jdchd-1.0,off
      /// 
    var jdchd:String?
    /// 舒适音频
      /// - 取值: on,off
      /// 
    var audioComfort:String?



    public override init(){
            super.init()
    }

    enum TranscodeInfoCodingKeys: String, CodingKey {
        case videoCodec
        case videoCodeRate
        case videoFrameRate
        case width
        case height
        case template
        case templateName
        case audioCodec
        case audioFormat
        case audioSampleRate
        case audioChannel
        case audioCodeRate
        case jdchd
        case audioComfort
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: TranscodeInfoCodingKeys.self)
        if decoderContainer.contains(.videoCodec)
        {
            self.videoCodec = try decoderContainer.decode(String?.self, forKey: .videoCodec)
        }
        if decoderContainer.contains(.videoCodeRate)
        {
            self.videoCodeRate = try decoderContainer.decode(Int?.self, forKey: .videoCodeRate)
        }
        if decoderContainer.contains(.videoFrameRate)
        {
            self.videoFrameRate = try decoderContainer.decode(String?.self, forKey: .videoFrameRate)
        }
        if decoderContainer.contains(.width)
        {
            self.width = try decoderContainer.decode(Int?.self, forKey: .width)
        }
        if decoderContainer.contains(.height)
        {
            self.height = try decoderContainer.decode(Int?.self, forKey: .height)
        }
        if decoderContainer.contains(.template)
        {
            self.template = try decoderContainer.decode(String?.self, forKey: .template)
        }
        if decoderContainer.contains(.templateName)
        {
            self.templateName = try decoderContainer.decode(String?.self, forKey: .templateName)
        }
        if decoderContainer.contains(.audioCodec)
        {
            self.audioCodec = try decoderContainer.decode(String?.self, forKey: .audioCodec)
        }
        if decoderContainer.contains(.audioFormat)
        {
            self.audioFormat = try decoderContainer.decode(String?.self, forKey: .audioFormat)
        }
        if decoderContainer.contains(.audioSampleRate)
        {
            self.audioSampleRate = try decoderContainer.decode(Int?.self, forKey: .audioSampleRate)
        }
        if decoderContainer.contains(.audioChannel)
        {
            self.audioChannel = try decoderContainer.decode(Int?.self, forKey: .audioChannel)
        }
        if decoderContainer.contains(.audioCodeRate)
        {
            self.audioCodeRate = try decoderContainer.decode(Int?.self, forKey: .audioCodeRate)
        }
        if decoderContainer.contains(.jdchd)
        {
            self.jdchd = try decoderContainer.decode(String?.self, forKey: .jdchd)
        }
        if decoderContainer.contains(.audioComfort)
        {
            self.audioComfort = try decoderContainer.decode(String?.self, forKey: .audioComfort)
        }
    }
}
public extension TranscodeInfo{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: TranscodeInfoCodingKeys.self)
         try encoderContainer.encode(videoCodec, forKey: .videoCodec)
         try encoderContainer.encode(videoCodeRate, forKey: .videoCodeRate)
         try encoderContainer.encode(videoFrameRate, forKey: .videoFrameRate)
         try encoderContainer.encode(width, forKey: .width)
         try encoderContainer.encode(height, forKey: .height)
         try encoderContainer.encode(template, forKey: .template)
         try encoderContainer.encode(templateName, forKey: .templateName)
         try encoderContainer.encode(audioCodec, forKey: .audioCodec)
         try encoderContainer.encode(audioFormat, forKey: .audioFormat)
         try encoderContainer.encode(audioSampleRate, forKey: .audioSampleRate)
         try encoderContainer.encode(audioChannel, forKey: .audioChannel)
         try encoderContainer.encode(audioCodeRate, forKey: .audioCodeRate)
         try encoderContainer.encode(jdchd, forKey: .jdchd)
         try encoderContainer.encode(audioComfort, forKey: .audioComfort)
    }
}
///  p2pPlayDomain
public class P2pPlayDomain:NSObject,Codable{
    /// 播放域名
    var playDomain:String?
    /// 直播P2P状态:
      ///   on: 开启
      ///   off: 关闭
      /// 
    var p2pStatus:String?
    /// 播放域名类型:
      ///   normal: 普通播放域名
      /// 
    var playType:String?



    public override init(){
            super.init()
    }

    enum P2pPlayDomainCodingKeys: String, CodingKey {
        case playDomain
        case p2pStatus
        case playType
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: P2pPlayDomainCodingKeys.self)
        if decoderContainer.contains(.playDomain)
        {
            self.playDomain = try decoderContainer.decode(String?.self, forKey: .playDomain)
        }
        if decoderContainer.contains(.p2pStatus)
        {
            self.p2pStatus = try decoderContainer.decode(String?.self, forKey: .p2pStatus)
        }
        if decoderContainer.contains(.playType)
        {
            self.playType = try decoderContainer.decode(String?.self, forKey: .playType)
        }
    }
}
public extension P2pPlayDomain{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: P2pPlayDomainCodingKeys.self)
         try encoderContainer.encode(playDomain, forKey: .playDomain)
         try encoderContainer.encode(p2pStatus, forKey: .p2pStatus)
         try encoderContainer.encode(playType, forKey: .playType)
    }
}
///  p2pRequestBody
public class P2pRequestBody:NSObject,Codable{
    /// 播放域名
    var playDomain:String?



    public override init(){
            super.init()
    }

    enum P2pRequestBodyCodingKeys: String, CodingKey {
        case playDomain
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: P2pRequestBodyCodingKeys.self)
        if decoderContainer.contains(.playDomain)
        {
            self.playDomain = try decoderContainer.decode(String?.self, forKey: .playDomain)
        }
    }
}
public extension P2pRequestBody{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: P2pRequestBodyCodingKeys.self)
         try encoderContainer.encode(playDomain, forKey: .playDomain)
    }
}
///  p2pResultObject
public class P2pResultObject:NSObject,Codable{
    /// 当前页码
    var pageNumber:Int?
    /// 每页数量
    var pageSize:Int?
    /// 查询总数
    var totalCount:Int?
    /// P2P配置集合
    var p2pConfigs:[P2pConfigs?]?



    public override init(){
            super.init()
    }

    enum P2pResultObjectCodingKeys: String, CodingKey {
        case pageNumber
        case pageSize
        case totalCount
        case p2pConfigs
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: P2pResultObjectCodingKeys.self)
        if decoderContainer.contains(.pageNumber)
        {
            self.pageNumber = try decoderContainer.decode(Int?.self, forKey: .pageNumber)
        }
        if decoderContainer.contains(.pageSize)
        {
            self.pageSize = try decoderContainer.decode(Int?.self, forKey: .pageSize)
        }
        if decoderContainer.contains(.totalCount)
        {
            self.totalCount = try decoderContainer.decode(Int?.self, forKey: .totalCount)
        }
        if decoderContainer.contains(.p2pConfigs)
        {
            self.p2pConfigs = try decoderContainer.decode([P2pConfigs?]?.self, forKey: .p2pConfigs)
        }
    }
}
public extension P2pResultObject{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: P2pResultObjectCodingKeys.self)
         try encoderContainer.encode(pageNumber, forKey: .pageNumber)
         try encoderContainer.encode(pageSize, forKey: .pageSize)
         try encoderContainer.encode(totalCount, forKey: .totalCount)
         try encoderContainer.encode(p2pConfigs, forKey: .p2pConfigs)
    }
}
///  p2pConfigs
public class P2pConfigs:NSObject,Codable{
    /// 推流域名集合
    var publishDomains:[P2pPublishDomain?]?
    /// 播放域名集合
    var playDomains:[P2pPlayDomain?]?



    public override init(){
            super.init()
    }

    enum P2pConfigsCodingKeys: String, CodingKey {
        case publishDomains
        case playDomains
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: P2pConfigsCodingKeys.self)
        if decoderContainer.contains(.publishDomains)
        {
            self.publishDomains = try decoderContainer.decode([P2pPublishDomain?]?.self, forKey: .publishDomains)
        }
        if decoderContainer.contains(.playDomains)
        {
            self.playDomains = try decoderContainer.decode([P2pPlayDomain?]?.self, forKey: .playDomains)
        }
    }
}
public extension P2pConfigs{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: P2pConfigsCodingKeys.self)
         try encoderContainer.encode(publishDomains, forKey: .publishDomains)
         try encoderContainer.encode(playDomains, forKey: .playDomains)
    }
}
///  p2pPublishDomain
public class P2pPublishDomain:NSObject,Codable{
    /// 推流域名
    var publishDomain:String?



    public override init(){
            super.init()
    }

    enum P2pPublishDomainCodingKeys: String, CodingKey {
        case publishDomain
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: P2pPublishDomainCodingKeys.self)
        if decoderContainer.contains(.publishDomain)
        {
            self.publishDomain = try decoderContainer.decode(String?.self, forKey: .publishDomain)
        }
    }
}
public extension P2pPublishDomain{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: P2pPublishDomainCodingKeys.self)
         try encoderContainer.encode(publishDomain, forKey: .publishDomain)
    }
}
///  app
public class App:NSObject,Codable{
    /// 应用名称
    var appName:String?
    /// 应用状态
      ///   online: 开启
      ///   offline: 关闭
      /// 
    var appStatus:String?
    /// 应用创建时间
      /// - UTC时间
      ///   格式: yyyy-MM-dd&#39;T&#39;HH:mm:ss&#39;Z&#39;
      /// 
    var createTime:String?
    /// 更新时间
    var updateTime:String?



    public override init(){
            super.init()
    }

    enum AppCodingKeys: String, CodingKey {
        case appName
        case appStatus
        case createTime
        case updateTime
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: AppCodingKeys.self)
        if decoderContainer.contains(.appName)
        {
            self.appName = try decoderContainer.decode(String?.self, forKey: .appName)
        }
        if decoderContainer.contains(.appStatus)
        {
            self.appStatus = try decoderContainer.decode(String?.self, forKey: .appStatus)
        }
        if decoderContainer.contains(.createTime)
        {
            self.createTime = try decoderContainer.decode(String?.self, forKey: .createTime)
        }
        if decoderContainer.contains(.updateTime)
        {
            self.updateTime = try decoderContainer.decode(String?.self, forKey: .updateTime)
        }
    }
}
public extension App{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: AppCodingKeys.self)
         try encoderContainer.encode(appName, forKey: .appName)
         try encoderContainer.encode(appStatus, forKey: .appStatus)
         try encoderContainer.encode(createTime, forKey: .createTime)
         try encoderContainer.encode(updateTime, forKey: .updateTime)
    }
}
///  watermarkTemplate
public class WatermarkTemplate:NSObject,Codable{
    /// 水印位置
      /// - 取值范围：左上：1，右上：3， 左下：7，右下：9，默认：1
      /// 
    var position:Int?
    /// 偏移量单位
      /// - 取值: percent,pixel
      /// 
    var offsetUnit:String?
    /// x轴偏移量
      /// 
    var offSetX:Int?
    /// y轴偏移量
      /// 
    var offSetY:Int?
    /// 水印大小单位
      /// - 取值: percent,pixel
      /// 
    var sizeUnit:String?
    /// 水印宽度
      /// 
    var width:Int?
    /// 水印高度
      /// 
    var height:Int?
    /// 水印地址
      /// 
    var url:String?
    /// 水印模板自定义名称
      /// 
    var template:String?



    public override init(){
            super.init()
    }

    enum WatermarkTemplateCodingKeys: String, CodingKey {
        case position
        case offsetUnit
        case offSetX
        case offSetY
        case sizeUnit
        case width
        case height
        case url
        case template
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: WatermarkTemplateCodingKeys.self)
        if decoderContainer.contains(.position)
        {
            self.position = try decoderContainer.decode(Int?.self, forKey: .position)
        }
        if decoderContainer.contains(.offsetUnit)
        {
            self.offsetUnit = try decoderContainer.decode(String?.self, forKey: .offsetUnit)
        }
        if decoderContainer.contains(.offSetX)
        {
            self.offSetX = try decoderContainer.decode(Int?.self, forKey: .offSetX)
        }
        if decoderContainer.contains(.offSetY)
        {
            self.offSetY = try decoderContainer.decode(Int?.self, forKey: .offSetY)
        }
        if decoderContainer.contains(.sizeUnit)
        {
            self.sizeUnit = try decoderContainer.decode(String?.self, forKey: .sizeUnit)
        }
        if decoderContainer.contains(.width)
        {
            self.width = try decoderContainer.decode(Int?.self, forKey: .width)
        }
        if decoderContainer.contains(.height)
        {
            self.height = try decoderContainer.decode(Int?.self, forKey: .height)
        }
        if decoderContainer.contains(.url)
        {
            self.url = try decoderContainer.decode(String?.self, forKey: .url)
        }
        if decoderContainer.contains(.template)
        {
            self.template = try decoderContainer.decode(String?.self, forKey: .template)
        }
    }
}
public extension WatermarkTemplate{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: WatermarkTemplateCodingKeys.self)
         try encoderContainer.encode(position, forKey: .position)
         try encoderContainer.encode(offsetUnit, forKey: .offsetUnit)
         try encoderContainer.encode(offSetX, forKey: .offSetX)
         try encoderContainer.encode(offSetY, forKey: .offSetY)
         try encoderContainer.encode(sizeUnit, forKey: .sizeUnit)
         try encoderContainer.encode(width, forKey: .width)
         try encoderContainer.encode(height, forKey: .height)
         try encoderContainer.encode(url, forKey: .url)
         try encoderContainer.encode(template, forKey: .template)
    }
}
///  liveStreamRecordConfig
public class LiveStreamRecordConfig:NSObject,Codable{
    /// 推流域名
    var publishDomain:String?
    /// 应用名称
    var appName:String?
    /// 流名称
    var streamName:String?
    /// 水印模板集合
    var watermarkConfig:[String?]?



    public override init(){
            super.init()
    }

    enum LiveStreamRecordConfigCodingKeys: String, CodingKey {
        case publishDomain
        case appName
        case streamName
        case watermarkConfig
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: LiveStreamRecordConfigCodingKeys.self)
        if decoderContainer.contains(.publishDomain)
        {
            self.publishDomain = try decoderContainer.decode(String?.self, forKey: .publishDomain)
        }
        if decoderContainer.contains(.appName)
        {
            self.appName = try decoderContainer.decode(String?.self, forKey: .appName)
        }
        if decoderContainer.contains(.streamName)
        {
            self.streamName = try decoderContainer.decode(String?.self, forKey: .streamName)
        }
        if decoderContainer.contains(.watermarkConfig)
        {
            self.watermarkConfig = try decoderContainer.decode([String?]?.self, forKey: .watermarkConfig)
        }
    }
}
public extension LiveStreamRecordConfig{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: LiveStreamRecordConfigCodingKeys.self)
         try encoderContainer.encode(publishDomain, forKey: .publishDomain)
         try encoderContainer.encode(appName, forKey: .appName)
         try encoderContainer.encode(streamName, forKey: .streamName)
         try encoderContainer.encode(watermarkConfig, forKey: .watermarkConfig)
    }
}
///  restartConfig
public class RestartConfig:NSObject,Codable{
    /// 推流域名集合
    var publishDomains:[RestartPublishDomain?]?
    /// 播放域名集合
    var playDomains:[RestartPlayDomain?]?



    public override init(){
            super.init()
    }

    enum RestartConfigCodingKeys: String, CodingKey {
        case publishDomains
        case playDomains
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: RestartConfigCodingKeys.self)
        if decoderContainer.contains(.publishDomains)
        {
            self.publishDomains = try decoderContainer.decode([RestartPublishDomain?]?.self, forKey: .publishDomains)
        }
        if decoderContainer.contains(.playDomains)
        {
            self.playDomains = try decoderContainer.decode([RestartPlayDomain?]?.self, forKey: .playDomains)
        }
    }
}
public extension RestartConfig{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: RestartConfigCodingKeys.self)
         try encoderContainer.encode(publishDomains, forKey: .publishDomains)
         try encoderContainer.encode(playDomains, forKey: .playDomains)
    }
}
///  restartPlayDomain
public class RestartPlayDomain:NSObject,Codable{
    /// 播放域名
    var playDomain:String?
    /// 直播回看状态:
      ///   on: 开启
      ///   off: 关闭
      /// 
    var restartStatus:String?
    /// 播放域名类型:
      ///   normal: 普通播放域名(时移播放域名)
      ///   restart: 回看播放域名
    var playType:String?



    public override init(){
            super.init()
    }

    enum RestartPlayDomainCodingKeys: String, CodingKey {
        case playDomain
        case restartStatus
        case playType
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: RestartPlayDomainCodingKeys.self)
        if decoderContainer.contains(.playDomain)
        {
            self.playDomain = try decoderContainer.decode(String?.self, forKey: .playDomain)
        }
        if decoderContainer.contains(.restartStatus)
        {
            self.restartStatus = try decoderContainer.decode(String?.self, forKey: .restartStatus)
        }
        if decoderContainer.contains(.playType)
        {
            self.playType = try decoderContainer.decode(String?.self, forKey: .playType)
        }
    }
}
public extension RestartPlayDomain{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: RestartPlayDomainCodingKeys.self)
         try encoderContainer.encode(playDomain, forKey: .playDomain)
         try encoderContainer.encode(restartStatus, forKey: .restartStatus)
         try encoderContainer.encode(playType, forKey: .playType)
    }
}
///  restartPublishDomain
public class RestartPublishDomain:NSObject,Codable{
    /// 推流域名
    var publishDomain:String?



    public override init(){
            super.init()
    }

    enum RestartPublishDomainCodingKeys: String, CodingKey {
        case publishDomain
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: RestartPublishDomainCodingKeys.self)
        if decoderContainer.contains(.publishDomain)
        {
            self.publishDomain = try decoderContainer.decode(String?.self, forKey: .publishDomain)
        }
    }
}
public extension RestartPublishDomain{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: RestartPublishDomainCodingKeys.self)
         try encoderContainer.encode(publishDomain, forKey: .publishDomain)
    }
}
///  playDomain
public class PlayDomain:NSObject,Codable{
    /// 播放域名
    var playDomainValue:String?
    /// 播放域名Cname
    var playDomainCname:String?
    /// 直播域名状态
      ///   online: 启用
      ///   offline: 停用
      ///   configuring: 配置中
      ///   configure_failed: 配置失败
      ///   checking: 正在审核
      ///   check_failed: 审核失败
      /// 
    var domainStatus:String?
    /// 播放域名类型
      ///   normal: 普通播放域名
      ///   restart: 回看域名
      /// 
    var playType:String?
    /// 域名创建时间
      /// - UTC时间
      ///   格式: yyyy-MM-dd&#39;T&#39;HH:mm:ss&#39;Z&#39;
      /// 
    var createTime:String?
    /// 域名更新时间
      /// - UTC时间
      ///   格式: yyyy-MM-dd&#39;T&#39;HH:mm:ss&#39;Z&#39;
      /// 
    var updateTime:String?



    public override init(){
            super.init()
    }

    enum PlayDomainCodingKeys: String, CodingKey {
        case playDomainValue = "playDomain"
        case playDomainCname
        case domainStatus
        case playType
        case createTime
        case updateTime
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: PlayDomainCodingKeys.self)
        if decoderContainer.contains(.playDomainValue)
        {
            self.playDomainValue = try decoderContainer.decode(String?.self, forKey: .playDomainValue)
        }
        if decoderContainer.contains(.playDomainCname)
        {
            self.playDomainCname = try decoderContainer.decode(String?.self, forKey: .playDomainCname)
        }
        if decoderContainer.contains(.domainStatus)
        {
            self.domainStatus = try decoderContainer.decode(String?.self, forKey: .domainStatus)
        }
        if decoderContainer.contains(.playType)
        {
            self.playType = try decoderContainer.decode(String?.self, forKey: .playType)
        }
        if decoderContainer.contains(.createTime)
        {
            self.createTime = try decoderContainer.decode(String?.self, forKey: .createTime)
        }
        if decoderContainer.contains(.updateTime)
        {
            self.updateTime = try decoderContainer.decode(String?.self, forKey: .updateTime)
        }
    }
}
public extension PlayDomain{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: PlayDomainCodingKeys.self)
         try encoderContainer.encode(playDomainValue, forKey: .playDomainValue)
         try encoderContainer.encode(playDomainCname, forKey: .playDomainCname)
         try encoderContainer.encode(domainStatus, forKey: .domainStatus)
         try encoderContainer.encode(playType, forKey: .playType)
         try encoderContainer.encode(createTime, forKey: .createTime)
         try encoderContainer.encode(updateTime, forKey: .updateTime)
    }
}
///  domainDetails
public class DomainDetails:NSObject,Codable{
    /// 推流域名集合
    var publishDomains:[PublishDomain?]?
    /// 播放域名集合
    var playDomains:[PlayDomain?]?



    public override init(){
            super.init()
    }

    enum DomainDetailsCodingKeys: String, CodingKey {
        case publishDomains
        case playDomains
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: DomainDetailsCodingKeys.self)
        if decoderContainer.contains(.publishDomains)
        {
            self.publishDomains = try decoderContainer.decode([PublishDomain?]?.self, forKey: .publishDomains)
        }
        if decoderContainer.contains(.playDomains)
        {
            self.playDomains = try decoderContainer.decode([PlayDomain?]?.self, forKey: .playDomains)
        }
    }
}
public extension DomainDetails{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: DomainDetailsCodingKeys.self)
         try encoderContainer.encode(publishDomains, forKey: .publishDomains)
         try encoderContainer.encode(playDomains, forKey: .playDomains)
    }
}
///  publishDomain
public class PublishDomain:NSObject,Codable{
    /// 推流域名
    var publishDomainValue:String?
    /// 推流域名Cname
    var publishDomainCname:String?
    /// 直播域名状态
      ///   online: 启用
      ///   offline: 停用
      ///   configuring: 配置中
      ///   configure_failed: 配置失败
      ///   checking: 正在审核
      ///   check_failed: 审核失败
      /// 
    var domainStatus:String?
    /// 域名创建时间
      /// - UTC时间
      ///   格式: yyyy-MM-dd&#39;T&#39;HH:mm:ss&#39;Z&#39;
      /// 
    var createTime:String?
    /// 域名更新时间
      /// - UTC时间
      ///   格式: yyyy-MM-dd&#39;T&#39;HH:mm:ss&#39;Z&#39;
      /// 
    var updateTime:String?



    public override init(){
            super.init()
    }

    enum PublishDomainCodingKeys: String, CodingKey {
        case publishDomainValue = "publishDomain"
        case publishDomainCname
        case domainStatus
        case createTime
        case updateTime
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: PublishDomainCodingKeys.self)
        if decoderContainer.contains(.publishDomainValue)
        {
            self.publishDomainValue = try decoderContainer.decode(String?.self, forKey: .publishDomainValue)
        }
        if decoderContainer.contains(.publishDomainCname)
        {
            self.publishDomainCname = try decoderContainer.decode(String?.self, forKey: .publishDomainCname)
        }
        if decoderContainer.contains(.domainStatus)
        {
            self.domainStatus = try decoderContainer.decode(String?.self, forKey: .domainStatus)
        }
        if decoderContainer.contains(.createTime)
        {
            self.createTime = try decoderContainer.decode(String?.self, forKey: .createTime)
        }
        if decoderContainer.contains(.updateTime)
        {
            self.updateTime = try decoderContainer.decode(String?.self, forKey: .updateTime)
        }
    }
}
public extension PublishDomain{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: PublishDomainCodingKeys.self)
         try encoderContainer.encode(publishDomainValue, forKey: .publishDomainValue)
         try encoderContainer.encode(publishDomainCname, forKey: .publishDomainCname)
         try encoderContainer.encode(domainStatus, forKey: .domainStatus)
         try encoderContainer.encode(createTime, forKey: .createTime)
         try encoderContainer.encode(updateTime, forKey: .updateTime)
    }
}
///  qualityDetectionConfig
public class QualityDetectionConfig:NSObject,Codable{
    /// 推流域名
    var publishDomain:String?
    /// 应用名称
    var appName:String?
    /// 流名称
    var streamName:String?
    /// QualityDetectionConfigValue
    var qualityDetectionConfigValue:[String?]?



    public override init(){
            super.init()
    }

    enum QualityDetectionConfigCodingKeys: String, CodingKey {
        case publishDomain
        case appName
        case streamName
        case qualityDetectionConfigValue = "qualityDetectionConfig"
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: QualityDetectionConfigCodingKeys.self)
        if decoderContainer.contains(.publishDomain)
        {
            self.publishDomain = try decoderContainer.decode(String?.self, forKey: .publishDomain)
        }
        if decoderContainer.contains(.appName)
        {
            self.appName = try decoderContainer.decode(String?.self, forKey: .appName)
        }
        if decoderContainer.contains(.streamName)
        {
            self.streamName = try decoderContainer.decode(String?.self, forKey: .streamName)
        }
        if decoderContainer.contains(.qualityDetectionConfigValue)
        {
            self.qualityDetectionConfigValue = try decoderContainer.decode([String?]?.self, forKey: .qualityDetectionConfigValue)
        }
    }
}
public extension QualityDetectionConfig{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: QualityDetectionConfigCodingKeys.self)
         try encoderContainer.encode(publishDomain, forKey: .publishDomain)
         try encoderContainer.encode(appName, forKey: .appName)
         try encoderContainer.encode(streamName, forKey: .streamName)
         try encoderContainer.encode(qualityDetectionConfigValue, forKey: .qualityDetectionConfigValue)
    }
}
///  sort
public class Sort:NSObject,Codable{
    /// 排序属性名
    var name:String?
    /// 排序方向
    var direction:String?



    public override init(){
            super.init()
    }

    enum SortCodingKeys: String, CodingKey {
        case name
        case direction
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: SortCodingKeys.self)
        if decoderContainer.contains(.name)
        {
            self.name = try decoderContainer.decode(String?.self, forKey: .name)
        }
        if decoderContainer.contains(.direction)
        {
            self.direction = try decoderContainer.decode(String?.self, forKey: .direction)
        }
    }
}
public extension Sort{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: SortCodingKeys.self)
         try encoderContainer.encode(name, forKey: .name)
         try encoderContainer.encode(direction, forKey: .direction)
    }
}
///  file
public class File:NSObject,Codable{
    /// 推流域名
    var publishDomain:String?
    /// 应用名称
    var appName:String?
    /// 流名称
    var streamName:String?
    /// 开始时间
      /// - UTC时间
      ///   格式:yyyy-MM-dd&#39;T&#39;HH:mm:ss&#39;Z&#39;
      ///   示例:2018-10-21T10:00:00Z
      /// 
    var startTime:String?
    /// 结束时间
      /// - UTC时间
      ///   格式:yyyy-MM-dd&#39;T&#39;HH:mm:ss&#39;Z&#39;
      ///   示例:2018-10-21T10:00:00Z
      /// 
    var endTime:String?
    /// 录制时长
    var duration:Int64?
    /// 视频高
    var height:Int?
    /// 视频宽
    var width:Int?
    /// OSSBucket的名称
    var ossBucket:String?
    /// OSSEndpoint域名
    var ossEndpoint:String?
    /// OSSObject
    var ossObject:String?



    public override init(){
            super.init()
    }

    enum FileCodingKeys: String, CodingKey {
        case publishDomain
        case appName
        case streamName
        case startTime
        case endTime
        case duration
        case height
        case width
        case ossBucket
        case ossEndpoint
        case ossObject
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: FileCodingKeys.self)
        if decoderContainer.contains(.publishDomain)
        {
            self.publishDomain = try decoderContainer.decode(String?.self, forKey: .publishDomain)
        }
        if decoderContainer.contains(.appName)
        {
            self.appName = try decoderContainer.decode(String?.self, forKey: .appName)
        }
        if decoderContainer.contains(.streamName)
        {
            self.streamName = try decoderContainer.decode(String?.self, forKey: .streamName)
        }
        if decoderContainer.contains(.startTime)
        {
            self.startTime = try decoderContainer.decode(String?.self, forKey: .startTime)
        }
        if decoderContainer.contains(.endTime)
        {
            self.endTime = try decoderContainer.decode(String?.self, forKey: .endTime)
        }
        if decoderContainer.contains(.duration)
        {
            self.duration = try decoderContainer.decode(Int64?.self, forKey: .duration)
        }
        if decoderContainer.contains(.height)
        {
            self.height = try decoderContainer.decode(Int?.self, forKey: .height)
        }
        if decoderContainer.contains(.width)
        {
            self.width = try decoderContainer.decode(Int?.self, forKey: .width)
        }
        if decoderContainer.contains(.ossBucket)
        {
            self.ossBucket = try decoderContainer.decode(String?.self, forKey: .ossBucket)
        }
        if decoderContainer.contains(.ossEndpoint)
        {
            self.ossEndpoint = try decoderContainer.decode(String?.self, forKey: .ossEndpoint)
        }
        if decoderContainer.contains(.ossObject)
        {
            self.ossObject = try decoderContainer.decode(String?.self, forKey: .ossObject)
        }
    }
}
public extension File{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: FileCodingKeys.self)
         try encoderContainer.encode(publishDomain, forKey: .publishDomain)
         try encoderContainer.encode(appName, forKey: .appName)
         try encoderContainer.encode(streamName, forKey: .streamName)
         try encoderContainer.encode(startTime, forKey: .startTime)
         try encoderContainer.encode(endTime, forKey: .endTime)
         try encoderContainer.encode(duration, forKey: .duration)
         try encoderContainer.encode(height, forKey: .height)
         try encoderContainer.encode(width, forKey: .width)
         try encoderContainer.encode(ossBucket, forKey: .ossBucket)
         try encoderContainer.encode(ossEndpoint, forKey: .ossEndpoint)
         try encoderContainer.encode(ossObject, forKey: .ossObject)
    }
}
///  recordApp
public class RecordApp:NSObject,Codable{
    /// 应用名称
    var appName:String?
    /// 自动录制周期
    var recordConfig:String?



    public override init(){
            super.init()
    }

    enum RecordAppCodingKeys: String, CodingKey {
        case appName
        case recordConfig
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: RecordAppCodingKeys.self)
        if decoderContainer.contains(.appName)
        {
            self.appName = try decoderContainer.decode(String?.self, forKey: .appName)
        }
        if decoderContainer.contains(.recordConfig)
        {
            self.recordConfig = try decoderContainer.decode(String?.self, forKey: .recordConfig)
        }
    }
}
public extension RecordApp{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: RecordAppCodingKeys.self)
         try encoderContainer.encode(appName, forKey: .appName)
         try encoderContainer.encode(recordConfig, forKey: .recordConfig)
    }
}
///  streamInfo
public class StreamInfo:NSObject,Codable{
    /// 推流域名
    var publishDomain:String?
    /// 应用名称
    var appName:String?
    /// 流名称
    var streamName:String?
    /// 流状态
      ///   on: 推流中
      ///   off: 推流中断
      /// 
    var status:String?



    public override init(){
            super.init()
    }

    enum StreamInfoCodingKeys: String, CodingKey {
        case publishDomain
        case appName
        case streamName
        case status
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: StreamInfoCodingKeys.self)
        if decoderContainer.contains(.publishDomain)
        {
            self.publishDomain = try decoderContainer.decode(String?.self, forKey: .publishDomain)
        }
        if decoderContainer.contains(.appName)
        {
            self.appName = try decoderContainer.decode(String?.self, forKey: .appName)
        }
        if decoderContainer.contains(.streamName)
        {
            self.streamName = try decoderContainer.decode(String?.self, forKey: .streamName)
        }
        if decoderContainer.contains(.status)
        {
            self.status = try decoderContainer.decode(String?.self, forKey: .status)
        }
    }
}
public extension StreamInfo{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: StreamInfoCodingKeys.self)
         try encoderContainer.encode(publishDomain, forKey: .publishDomain)
         try encoderContainer.encode(appName, forKey: .appName)
         try encoderContainer.encode(streamName, forKey: .streamName)
         try encoderContainer.encode(status, forKey: .status)
    }
}
///  notifyInfo
public class NotifyInfo:NSObject,Codable{
    /// 您的加速域名
    var publishDomain:String?
    /// 回调地址
    var notifyUrl:String?



    public override init(){
            super.init()
    }

    enum NotifyInfoCodingKeys: String, CodingKey {
        case publishDomain
        case notifyUrl
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: NotifyInfoCodingKeys.self)
        if decoderContainer.contains(.publishDomain)
        {
            self.publishDomain = try decoderContainer.decode(String?.self, forKey: .publishDomain)
        }
        if decoderContainer.contains(.notifyUrl)
        {
            self.notifyUrl = try decoderContainer.decode(String?.self, forKey: .notifyUrl)
        }
    }
}
public extension NotifyInfo{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: NotifyInfoCodingKeys.self)
         try encoderContainer.encode(publishDomain, forKey: .publishDomain)
         try encoderContainer.encode(notifyUrl, forKey: .notifyUrl)
    }
}

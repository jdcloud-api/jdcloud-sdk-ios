/* Copyright 2018 JDCLOUD.COM

   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at

     http:#www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.

   Live-Video
   直播管理API

   OpenAPI spec version: v1
   Contact: 

   NOTE: This class is auto generated by the jdcloud code generator program.
 */


import Foundation
import JDCloudSDKCore

/// 查询用户自定义转码模板详情
      ///       /// - 查询用户自定义转码模板详情
      ///       /// - 系统标准转码模板
      ///       ///       ld (h.264/640*360/15f)
      ///       ///       sd (h.264/960*540/24f)
      ///       ///       hd (h.264/1280*720/25f)
      ///       ///       shd (h.264/1920*1080/30f)
      ///       ///       ld-265 (h.265/640*360/15f)
      ///       ///       sd-265 (h.265/960*540/24f)
      ///       ///       hd-265 (h.265/1280*720/25f)
      ///       ///       shd-265 (h.265/1920*1080/30f)
      ///       /// 
@objc(DescribeCustomLiveStreamTranscodeTemplateResult)
public class DescribeCustomLiveStreamTranscodeTemplateResult:NSObject,JdCloudResult
{
    /// 视频编码格式，取值：h264,h265，默认h264
      /// 
    var videoCodec:String?

    /// 转码输出的码率值
      /// - 单位: kpbs
      /// 
    var videoCodeRate:Int?

    /// 转码输出的帧率值
      /// 
    var videoFrameRate:String?

    /// 转码输出视频宽度
      /// 
    var width:Int?

    /// 转码输出视频高度
      /// 
    var height:Int?

    /// 转码模板
      /// 
    var template:String?

    /// 转码输出音频编码格式
      /// 
    var audioCodec:String?

    /// 转码输出音频格式
      /// 
    var audioFormat:String?

    /// 转码输出音频采样率
      /// 
    var audioSampleRate:Int?

    /// 转码输出音频通道数
      ///   1: 单声道
      ///   2: 双声道
      /// 
    var audioChannel:Int?

    /// 转码输出音频码率
      /// - 单位: kbps
      /// 
    var audioCodeRate:Int?

    /// 京享超清
      /// - 取值: jdchd-1.0,off
      /// 
    var jdchd:String?

    /// 舒适音频
      /// - 取值: on,off
      /// 
    var audioComfort:String?



    public override init(){
        super.init()
    }

    enum DescribeCustomLiveStreamTranscodeTemplateResultCodingKeys: String, CodingKey {
        case videoCodec
        case videoCodeRate
        case videoFrameRate
        case width
        case height
        case template
        case audioCodec
        case audioFormat
        case audioSampleRate
        case audioChannel
        case audioCodeRate
        case jdchd
        case audioComfort
    }

    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: DescribeCustomLiveStreamTranscodeTemplateResultCodingKeys.self)
        if decoderContainer.contains(.videoCodec)
        {
            self.videoCodec = try decoderContainer.decode(String?.self, forKey: .videoCodec)
        }
        if decoderContainer.contains(.videoCodeRate)
        {
            self.videoCodeRate = try decoderContainer.decode(Int?.self, forKey: .videoCodeRate)
        }
        if decoderContainer.contains(.videoFrameRate)
        {
            self.videoFrameRate = try decoderContainer.decode(String?.self, forKey: .videoFrameRate)
        }
        if decoderContainer.contains(.width)
        {
            self.width = try decoderContainer.decode(Int?.self, forKey: .width)
        }
        if decoderContainer.contains(.height)
        {
            self.height = try decoderContainer.decode(Int?.self, forKey: .height)
        }
        if decoderContainer.contains(.template)
        {
            self.template = try decoderContainer.decode(String?.self, forKey: .template)
        }
        if decoderContainer.contains(.audioCodec)
        {
            self.audioCodec = try decoderContainer.decode(String?.self, forKey: .audioCodec)
        }
        if decoderContainer.contains(.audioFormat)
        {
            self.audioFormat = try decoderContainer.decode(String?.self, forKey: .audioFormat)
        }
        if decoderContainer.contains(.audioSampleRate)
        {
            self.audioSampleRate = try decoderContainer.decode(Int?.self, forKey: .audioSampleRate)
        }
        if decoderContainer.contains(.audioChannel)
        {
            self.audioChannel = try decoderContainer.decode(Int?.self, forKey: .audioChannel)
        }
        if decoderContainer.contains(.audioCodeRate)
        {
            self.audioCodeRate = try decoderContainer.decode(Int?.self, forKey: .audioCodeRate)
        }
        if decoderContainer.contains(.jdchd)
        {
            self.jdchd = try decoderContainer.decode(String?.self, forKey: .jdchd)
        }
        if decoderContainer.contains(.audioComfort)
        {
            self.audioComfort = try decoderContainer.decode(String?.self, forKey: .audioComfort)
        }
    }
}
public extension DescribeCustomLiveStreamTranscodeTemplateResult{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: DescribeCustomLiveStreamTranscodeTemplateResultCodingKeys.self)
        try encoderContainer.encode(videoCodec, forKey: .videoCodec)
        try encoderContainer.encode(videoCodeRate, forKey: .videoCodeRate)
        try encoderContainer.encode(videoFrameRate, forKey: .videoFrameRate)
        try encoderContainer.encode(width, forKey: .width)
        try encoderContainer.encode(height, forKey: .height)
        try encoderContainer.encode(template, forKey: .template)
        try encoderContainer.encode(audioCodec, forKey: .audioCodec)
        try encoderContainer.encode(audioFormat, forKey: .audioFormat)
        try encoderContainer.encode(audioSampleRate, forKey: .audioSampleRate)
        try encoderContainer.encode(audioChannel, forKey: .audioChannel)
        try encoderContainer.encode(audioCodeRate, forKey: .audioCodeRate)
        try encoderContainer.encode(jdchd, forKey: .jdchd)
        try encoderContainer.encode(audioComfort, forKey: .audioComfort)
    }
}

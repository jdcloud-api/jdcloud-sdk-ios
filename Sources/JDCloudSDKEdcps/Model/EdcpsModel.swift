/* Copyright 2018 JDCLOUD.COM

   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at

     http:#www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.

   分布式云物理服务器
   分布式云物理服务器地域操作相关的接口

   OpenAPI spec version: v1
   Contact: 

   NOTE: This class is auto generated by the jdcloud code generator program.
 */


import Foundation
import JDCloudSDKCharge
///  aliasIpInfo
public class AliasIpInfo:NSObject,Codable{
    /// 主CIDR或次要CIDR id
    var id:String?
    /// cidr段
    var cidr:String?



    public override init(){
            super.init()
    }

    enum AliasIpInfoCodingKeys: String, CodingKey {
        case id
        case cidr
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: AliasIpInfoCodingKeys.self)
        if decoderContainer.contains(.id)
        {
            self.id = try decoderContainer.decode(String?.self, forKey: .id)
        }
        if decoderContainer.contains(.cidr)
        {
            self.cidr = try decoderContainer.decode(String?.self, forKey: .cidr)
        }
    }
}
public extension AliasIpInfo{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: AliasIpInfoCodingKeys.self)
         try encoderContainer.encode(id, forKey: .id)
         try encoderContainer.encode(cidr, forKey: .cidr)
    }
}
///  aliasIp
public class AliasIp:NSObject,Codable{
    /// 实例ID
    var instanceId:String?
    /// 地域
    var region:String?
    /// 可用区
    var az:String?
    /// 子网ID
    var subnetId:String?
    /// 次要cidr ID
    var secondaryCidrId:String?
    /// 别名IP ID
    var aliasIpId:String?
    /// cidr段
    var cidr:String?



    public override init(){
            super.init()
    }

    enum AliasIpCodingKeys: String, CodingKey {
        case instanceId
        case region
        case az
        case subnetId
        case secondaryCidrId
        case aliasIpId
        case cidr
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: AliasIpCodingKeys.self)
        if decoderContainer.contains(.instanceId)
        {
            self.instanceId = try decoderContainer.decode(String?.self, forKey: .instanceId)
        }
        if decoderContainer.contains(.region)
        {
            self.region = try decoderContainer.decode(String?.self, forKey: .region)
        }
        if decoderContainer.contains(.az)
        {
            self.az = try decoderContainer.decode(String?.self, forKey: .az)
        }
        if decoderContainer.contains(.subnetId)
        {
            self.subnetId = try decoderContainer.decode(String?.self, forKey: .subnetId)
        }
        if decoderContainer.contains(.secondaryCidrId)
        {
            self.secondaryCidrId = try decoderContainer.decode(String?.self, forKey: .secondaryCidrId)
        }
        if decoderContainer.contains(.aliasIpId)
        {
            self.aliasIpId = try decoderContainer.decode(String?.self, forKey: .aliasIpId)
        }
        if decoderContainer.contains(.cidr)
        {
            self.cidr = try decoderContainer.decode(String?.self, forKey: .cidr)
        }
    }
}
public extension AliasIp{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: AliasIpCodingKeys.self)
         try encoderContainer.encode(instanceId, forKey: .instanceId)
         try encoderContainer.encode(region, forKey: .region)
         try encoderContainer.encode(az, forKey: .az)
         try encoderContainer.encode(subnetId, forKey: .subnetId)
         try encoderContainer.encode(secondaryCidrId, forKey: .secondaryCidrId)
         try encoderContainer.encode(aliasIpId, forKey: .aliasIpId)
         try encoderContainer.encode(cidr, forKey: .cidr)
    }
}
///  aliasIpSpec
public class AliasIpSpec:NSObject,Codable{
    /// 实例ID
    var instanceId:String?
    /// 别名ip配置
    var aliasIps:[AliasIpInfo?]?



    public override init(){
            super.init()
    }

    enum AliasIpSpecCodingKeys: String, CodingKey {
        case instanceId
        case aliasIps
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: AliasIpSpecCodingKeys.self)
        if decoderContainer.contains(.instanceId)
        {
            self.instanceId = try decoderContainer.decode(String?.self, forKey: .instanceId)
        }
        if decoderContainer.contains(.aliasIps)
        {
            self.aliasIps = try decoderContainer.decode([AliasIpInfo?]?.self, forKey: .aliasIps)
        }
    }
}
public extension AliasIpSpec{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: AliasIpSpecCodingKeys.self)
         try encoderContainer.encode(instanceId, forKey: .instanceId)
         try encoderContainer.encode(aliasIps, forKey: .aliasIps)
    }
}
///  aliasIpSuccessInfo
public class AliasIpSuccessInfo:NSObject,Codable{
    /// 别名IP id
    var aliasIpId:String?
    /// cidr段
    var cidr:String?



    public override init(){
            super.init()
    }

    enum AliasIpSuccessInfoCodingKeys: String, CodingKey {
        case aliasIpId
        case cidr
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: AliasIpSuccessInfoCodingKeys.self)
        if decoderContainer.contains(.aliasIpId)
        {
            self.aliasIpId = try decoderContainer.decode(String?.self, forKey: .aliasIpId)
        }
        if decoderContainer.contains(.cidr)
        {
            self.cidr = try decoderContainer.decode(String?.self, forKey: .cidr)
        }
    }
}
public extension AliasIpSuccessInfo{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: AliasIpSuccessInfoCodingKeys.self)
         try encoderContainer.encode(aliasIpId, forKey: .aliasIpId)
         try encoderContainer.encode(cidr, forKey: .cidr)
    }
}
///  aliasIpErrorInfo
public class AliasIpErrorInfo:NSObject,Codable{
    /// cidr段
    var cidr:String?
    /// 错误信息
    var message:String?



    public override init(){
            super.init()
    }

    enum AliasIpErrorInfoCodingKeys: String, CodingKey {
        case cidr
        case message
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: AliasIpErrorInfoCodingKeys.self)
        if decoderContainer.contains(.cidr)
        {
            self.cidr = try decoderContainer.decode(String?.self, forKey: .cidr)
        }
        if decoderContainer.contains(.message)
        {
            self.message = try decoderContainer.decode(String?.self, forKey: .message)
        }
    }
}
public extension AliasIpErrorInfo{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: AliasIpErrorInfoCodingKeys.self)
         try encoderContainer.encode(cidr, forKey: .cidr)
         try encoderContainer.encode(message, forKey: .message)
    }
}
///  subnet
public class Subnet:NSObject,Codable{
    /// 地域代码, 如cn-east-tz1
    var region:String?
    /// 可用区, 如cn-east-tz1a
    var az:String?
    /// 子网ID
    var subnetId:String?
    /// 子网名称
    var name:String?
    /// 子网CIDR
    var cidr:String?
    /// 私有网络Id
    var vpcId:String?
    /// 私有网络名称
    var vpcName:String?
    /// 可用ip数量
    var availableIpCount:Int?
    /// 总ip数量
    var totalIpCount:Int?
    /// 网络类型
    var networkType:String?
    /// 描述
    var descriptionValue:String?
    /// 创建时间
    var createTime:String?



    public override init(){
            super.init()
    }

    enum SubnetCodingKeys: String, CodingKey {
        case region
        case az
        case subnetId
        case name
        case cidr
        case vpcId
        case vpcName
        case availableIpCount
        case totalIpCount
        case networkType
        case descriptionValue = "description"
        case createTime
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: SubnetCodingKeys.self)
        if decoderContainer.contains(.region)
        {
            self.region = try decoderContainer.decode(String?.self, forKey: .region)
        }
        if decoderContainer.contains(.az)
        {
            self.az = try decoderContainer.decode(String?.self, forKey: .az)
        }
        if decoderContainer.contains(.subnetId)
        {
            self.subnetId = try decoderContainer.decode(String?.self, forKey: .subnetId)
        }
        if decoderContainer.contains(.name)
        {
            self.name = try decoderContainer.decode(String?.self, forKey: .name)
        }
        if decoderContainer.contains(.cidr)
        {
            self.cidr = try decoderContainer.decode(String?.self, forKey: .cidr)
        }
        if decoderContainer.contains(.vpcId)
        {
            self.vpcId = try decoderContainer.decode(String?.self, forKey: .vpcId)
        }
        if decoderContainer.contains(.vpcName)
        {
            self.vpcName = try decoderContainer.decode(String?.self, forKey: .vpcName)
        }
        if decoderContainer.contains(.availableIpCount)
        {
            self.availableIpCount = try decoderContainer.decode(Int?.self, forKey: .availableIpCount)
        }
        if decoderContainer.contains(.totalIpCount)
        {
            self.totalIpCount = try decoderContainer.decode(Int?.self, forKey: .totalIpCount)
        }
        if decoderContainer.contains(.networkType)
        {
            self.networkType = try decoderContainer.decode(String?.self, forKey: .networkType)
        }
        if decoderContainer.contains(.descriptionValue)
        {
            self.descriptionValue = try decoderContainer.decode(String?.self, forKey: .descriptionValue)
        }
        if decoderContainer.contains(.createTime)
        {
            self.createTime = try decoderContainer.decode(String?.self, forKey: .createTime)
        }
    }
}
public extension Subnet{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: SubnetCodingKeys.self)
         try encoderContainer.encode(region, forKey: .region)
         try encoderContainer.encode(az, forKey: .az)
         try encoderContainer.encode(subnetId, forKey: .subnetId)
         try encoderContainer.encode(name, forKey: .name)
         try encoderContainer.encode(cidr, forKey: .cidr)
         try encoderContainer.encode(vpcId, forKey: .vpcId)
         try encoderContainer.encode(vpcName, forKey: .vpcName)
         try encoderContainer.encode(availableIpCount, forKey: .availableIpCount)
         try encoderContainer.encode(totalIpCount, forKey: .totalIpCount)
         try encoderContainer.encode(networkType, forKey: .networkType)
         try encoderContainer.encode(descriptionValue, forKey: .descriptionValue)
         try encoderContainer.encode(createTime, forKey: .createTime)
    }
}
///  subnetSpec
public class SubnetSpec:NSObject,Codable{
    /// 可用区, 如 cn-east-tz1a
    /// Required:true
    var az:String
    /// 私有网络ID
    /// Required:true
    var vpcId:String
    /// 子网的网络范围
    /// Required:true
    var cidr:String
    /// 子网的次要cidr
    var secondaryCidr:String?
    /// 子网的次要cidr名称
    var secondaryCidrName:String?
    /// 名称
    /// Required:true
    var name:String
    /// 描述
    /// Required:true
    var descriptionValue:String



    public  init(az:String,vpcId:String,cidr:String,name:String,descriptionValue:String){
             self.az = az
             self.vpcId = vpcId
             self.cidr = cidr
             self.name = name
             self.descriptionValue = descriptionValue
    }

    enum SubnetSpecCodingKeys: String, CodingKey {
        case az
        case vpcId
        case cidr
        case secondaryCidr
        case secondaryCidrName
        case name
        case descriptionValue = "description"
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: SubnetSpecCodingKeys.self)
        self.az = try decoderContainer.decode(String.self, forKey: .az)
        self.vpcId = try decoderContainer.decode(String.self, forKey: .vpcId)
        self.cidr = try decoderContainer.decode(String.self, forKey: .cidr)
        if decoderContainer.contains(.secondaryCidr)
        {
            self.secondaryCidr = try decoderContainer.decode(String?.self, forKey: .secondaryCidr)
        }
        if decoderContainer.contains(.secondaryCidrName)
        {
            self.secondaryCidrName = try decoderContainer.decode(String?.self, forKey: .secondaryCidrName)
        }
        self.name = try decoderContainer.decode(String.self, forKey: .name)
        self.descriptionValue = try decoderContainer.decode(String.self, forKey: .descriptionValue)
    }
}
public extension SubnetSpec{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: SubnetSpecCodingKeys.self)
         try encoderContainer.encode(az, forKey: .az)
         try encoderContainer.encode(vpcId, forKey: .vpcId)
         try encoderContainer.encode(cidr, forKey: .cidr)
         try encoderContainer.encode(secondaryCidr, forKey: .secondaryCidr)
         try encoderContainer.encode(secondaryCidrName, forKey: .secondaryCidrName)
         try encoderContainer.encode(name, forKey: .name)
         try encoderContainer.encode(descriptionValue, forKey: .descriptionValue)
    }
}
///  elasticIpSpec
public class ElasticIpSpec:NSObject,Codable{
    /// 带宽, 范围[1,10240] 单位Mbps
    /// Required:true
    var bandwidth:Int
    /// 额外上行带宽, 范围[0,10240] 单位Mbps
    var extraUplinkBandwidth:Int?
    /// 购买数量
    /// Required:true
    var count:Int
    /// 计费配置
    /// Required:true
    var charge:ChargeSpec



    public  init(bandwidth:Int,count:Int,charge:ChargeSpec){
             self.bandwidth = bandwidth
             self.count = count
             self.charge = charge
    }

    enum ElasticIpSpecCodingKeys: String, CodingKey {
        case bandwidth
        case extraUplinkBandwidth
        case count
        case charge
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: ElasticIpSpecCodingKeys.self)
        self.bandwidth = try decoderContainer.decode(Int.self, forKey: .bandwidth)
        if decoderContainer.contains(.extraUplinkBandwidth)
        {
            self.extraUplinkBandwidth = try decoderContainer.decode(Int?.self, forKey: .extraUplinkBandwidth)
        }
        self.count = try decoderContainer.decode(Int.self, forKey: .count)
        self.charge = try decoderContainer.decode(ChargeSpec.self, forKey: .charge)
    }
}
public extension ElasticIpSpec{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: ElasticIpSpecCodingKeys.self)
         try encoderContainer.encode(bandwidth, forKey: .bandwidth)
         try encoderContainer.encode(extraUplinkBandwidth, forKey: .extraUplinkBandwidth)
         try encoderContainer.encode(count, forKey: .count)
         try encoderContainer.encode(charge, forKey: .charge)
    }
}
///  elasticIp
public class ElasticIp:NSObject,Codable{
    /// 地域代码, 如cn-east-tz1
    var region:String?
    /// 弹性公网IPID
    var elasticIpId:String?
    /// 弹性公网IP
    var elasticIpValue:String?
    /// 带宽, 单位Mbps
    var bandwidth:Int?
    /// 额外上行带宽, 单位Mbps
    var extraUplinkBandwidth:Int?
    /// 链路类型
    var lineType:String?
    /// 状态
    var status:String?
    /// 实例类型
    var instanceType:String?
    /// 实例ID
    var instanceId:String?
    /// 创建时间
    var createTime:String?
    /// 别名IP id
    var aliasIpId:String?
    /// 计费信息
    var charge:Charge?



    public override init(){
            super.init()
    }

    enum ElasticIpCodingKeys: String, CodingKey {
        case region
        case elasticIpId
        case elasticIpValue = "elasticIp"
        case bandwidth
        case extraUplinkBandwidth
        case lineType
        case status
        case instanceType
        case instanceId
        case createTime
        case aliasIpId
        case charge
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: ElasticIpCodingKeys.self)
        if decoderContainer.contains(.region)
        {
            self.region = try decoderContainer.decode(String?.self, forKey: .region)
        }
        if decoderContainer.contains(.elasticIpId)
        {
            self.elasticIpId = try decoderContainer.decode(String?.self, forKey: .elasticIpId)
        }
        if decoderContainer.contains(.elasticIpValue)
        {
            self.elasticIpValue = try decoderContainer.decode(String?.self, forKey: .elasticIpValue)
        }
        if decoderContainer.contains(.bandwidth)
        {
            self.bandwidth = try decoderContainer.decode(Int?.self, forKey: .bandwidth)
        }
        if decoderContainer.contains(.extraUplinkBandwidth)
        {
            self.extraUplinkBandwidth = try decoderContainer.decode(Int?.self, forKey: .extraUplinkBandwidth)
        }
        if decoderContainer.contains(.lineType)
        {
            self.lineType = try decoderContainer.decode(String?.self, forKey: .lineType)
        }
        if decoderContainer.contains(.status)
        {
            self.status = try decoderContainer.decode(String?.self, forKey: .status)
        }
        if decoderContainer.contains(.instanceType)
        {
            self.instanceType = try decoderContainer.decode(String?.self, forKey: .instanceType)
        }
        if decoderContainer.contains(.instanceId)
        {
            self.instanceId = try decoderContainer.decode(String?.self, forKey: .instanceId)
        }
        if decoderContainer.contains(.createTime)
        {
            self.createTime = try decoderContainer.decode(String?.self, forKey: .createTime)
        }
        if decoderContainer.contains(.aliasIpId)
        {
            self.aliasIpId = try decoderContainer.decode(String?.self, forKey: .aliasIpId)
        }
        if decoderContainer.contains(.charge)
        {
            self.charge = try decoderContainer.decode(Charge?.self, forKey: .charge)
        }
    }
}
public extension ElasticIp{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: ElasticIpCodingKeys.self)
         try encoderContainer.encode(region, forKey: .region)
         try encoderContainer.encode(elasticIpId, forKey: .elasticIpId)
         try encoderContainer.encode(elasticIpValue, forKey: .elasticIpValue)
         try encoderContainer.encode(bandwidth, forKey: .bandwidth)
         try encoderContainer.encode(extraUplinkBandwidth, forKey: .extraUplinkBandwidth)
         try encoderContainer.encode(lineType, forKey: .lineType)
         try encoderContainer.encode(status, forKey: .status)
         try encoderContainer.encode(instanceType, forKey: .instanceType)
         try encoderContainer.encode(instanceId, forKey: .instanceId)
         try encoderContainer.encode(createTime, forKey: .createTime)
         try encoderContainer.encode(aliasIpId, forKey: .aliasIpId)
         try encoderContainer.encode(charge, forKey: .charge)
    }
}
///  lineType
public class LineType:NSObject,Codable{
    /// 链路类型
    var lineTypeValue:String?
    /// 地域
    var region:String?



    public override init(){
            super.init()
    }

    enum LineTypeCodingKeys: String, CodingKey {
        case lineTypeValue = "lineType"
        case region
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: LineTypeCodingKeys.self)
        if decoderContainer.contains(.lineTypeValue)
        {
            self.lineTypeValue = try decoderContainer.decode(String?.self, forKey: .lineTypeValue)
        }
        if decoderContainer.contains(.region)
        {
            self.region = try decoderContainer.decode(String?.self, forKey: .region)
        }
    }
}
public extension LineType{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: LineTypeCodingKeys.self)
         try encoderContainer.encode(lineTypeValue, forKey: .lineTypeValue)
         try encoderContainer.encode(region, forKey: .region)
    }
}
///  keypair
public class Keypair:NSObject,Codable{
    /// 密钥对id
    var keypairId:String?
    /// 地域
    var region:String?
    /// 密钥对名称
    var name:String?
    /// 公钥
    var publicKey:String?
    /// 指纹
    var fingerPrint:String?
    /// 创建时间
    var createTime:String?
    /// 更新时间
    var updateTime:String?



    public override init(){
            super.init()
    }

    enum KeypairCodingKeys: String, CodingKey {
        case keypairId
        case region
        case name
        case publicKey
        case fingerPrint
        case createTime
        case updateTime
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: KeypairCodingKeys.self)
        if decoderContainer.contains(.keypairId)
        {
            self.keypairId = try decoderContainer.decode(String?.self, forKey: .keypairId)
        }
        if decoderContainer.contains(.region)
        {
            self.region = try decoderContainer.decode(String?.self, forKey: .region)
        }
        if decoderContainer.contains(.name)
        {
            self.name = try decoderContainer.decode(String?.self, forKey: .name)
        }
        if decoderContainer.contains(.publicKey)
        {
            self.publicKey = try decoderContainer.decode(String?.self, forKey: .publicKey)
        }
        if decoderContainer.contains(.fingerPrint)
        {
            self.fingerPrint = try decoderContainer.decode(String?.self, forKey: .fingerPrint)
        }
        if decoderContainer.contains(.createTime)
        {
            self.createTime = try decoderContainer.decode(String?.self, forKey: .createTime)
        }
        if decoderContainer.contains(.updateTime)
        {
            self.updateTime = try decoderContainer.decode(String?.self, forKey: .updateTime)
        }
    }
}
public extension Keypair{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: KeypairCodingKeys.self)
         try encoderContainer.encode(keypairId, forKey: .keypairId)
         try encoderContainer.encode(region, forKey: .region)
         try encoderContainer.encode(name, forKey: .name)
         try encoderContainer.encode(publicKey, forKey: .publicKey)
         try encoderContainer.encode(fingerPrint, forKey: .fingerPrint)
         try encoderContainer.encode(createTime, forKey: .createTime)
         try encoderContainer.encode(updateTime, forKey: .updateTime)
    }
}
///  secondaryCidrSpec
public class SecondaryCidrSpec:NSObject,Codable{
    /// 子网ID
    var subnetId:String?
    /// 子网的次要CIDR
    var cidr:String?
    /// 名称
    var name:String?



    public override init(){
            super.init()
    }

    enum SecondaryCidrSpecCodingKeys: String, CodingKey {
        case subnetId
        case cidr
        case name
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: SecondaryCidrSpecCodingKeys.self)
        if decoderContainer.contains(.subnetId)
        {
            self.subnetId = try decoderContainer.decode(String?.self, forKey: .subnetId)
        }
        if decoderContainer.contains(.cidr)
        {
            self.cidr = try decoderContainer.decode(String?.self, forKey: .cidr)
        }
        if decoderContainer.contains(.name)
        {
            self.name = try decoderContainer.decode(String?.self, forKey: .name)
        }
    }
}
public extension SecondaryCidrSpec{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: SecondaryCidrSpecCodingKeys.self)
         try encoderContainer.encode(subnetId, forKey: .subnetId)
         try encoderContainer.encode(cidr, forKey: .cidr)
         try encoderContainer.encode(name, forKey: .name)
    }
}
///  secondaryCidr
public class SecondaryCidr:NSObject,Codable{
    /// 次要cidr的ID
    var secondaryCidrId:String?
    /// 次要cidr
    var cidr:String?
    /// 地域代码, 如cn-east-tz1
    var region:String?
    /// 可用区, 如cn-east-tz1a
    var az:String?
    /// 子网ID
    var subnetId:String?
    /// 次要cidr名称
    var name:String?
    /// 私有网络Id
    var vpcId:String?
    /// 私有网络名称
    var vpcName:String?
    /// 可用ip数量
    var availableIpCount:Int?
    /// 总ip数量
    var totalIpCount:Int?



    public override init(){
            super.init()
    }

    enum SecondaryCidrCodingKeys: String, CodingKey {
        case secondaryCidrId
        case cidr
        case region
        case az
        case subnetId
        case name
        case vpcId
        case vpcName
        case availableIpCount
        case totalIpCount
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: SecondaryCidrCodingKeys.self)
        if decoderContainer.contains(.secondaryCidrId)
        {
            self.secondaryCidrId = try decoderContainer.decode(String?.self, forKey: .secondaryCidrId)
        }
        if decoderContainer.contains(.cidr)
        {
            self.cidr = try decoderContainer.decode(String?.self, forKey: .cidr)
        }
        if decoderContainer.contains(.region)
        {
            self.region = try decoderContainer.decode(String?.self, forKey: .region)
        }
        if decoderContainer.contains(.az)
        {
            self.az = try decoderContainer.decode(String?.self, forKey: .az)
        }
        if decoderContainer.contains(.subnetId)
        {
            self.subnetId = try decoderContainer.decode(String?.self, forKey: .subnetId)
        }
        if decoderContainer.contains(.name)
        {
            self.name = try decoderContainer.decode(String?.self, forKey: .name)
        }
        if decoderContainer.contains(.vpcId)
        {
            self.vpcId = try decoderContainer.decode(String?.self, forKey: .vpcId)
        }
        if decoderContainer.contains(.vpcName)
        {
            self.vpcName = try decoderContainer.decode(String?.self, forKey: .vpcName)
        }
        if decoderContainer.contains(.availableIpCount)
        {
            self.availableIpCount = try decoderContainer.decode(Int?.self, forKey: .availableIpCount)
        }
        if decoderContainer.contains(.totalIpCount)
        {
            self.totalIpCount = try decoderContainer.decode(Int?.self, forKey: .totalIpCount)
        }
    }
}
public extension SecondaryCidr{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: SecondaryCidrCodingKeys.self)
         try encoderContainer.encode(secondaryCidrId, forKey: .secondaryCidrId)
         try encoderContainer.encode(cidr, forKey: .cidr)
         try encoderContainer.encode(region, forKey: .region)
         try encoderContainer.encode(az, forKey: .az)
         try encoderContainer.encode(subnetId, forKey: .subnetId)
         try encoderContainer.encode(name, forKey: .name)
         try encoderContainer.encode(vpcId, forKey: .vpcId)
         try encoderContainer.encode(vpcName, forKey: .vpcName)
         try encoderContainer.encode(availableIpCount, forKey: .availableIpCount)
         try encoderContainer.encode(totalIpCount, forKey: .totalIpCount)
    }
}
///  raid
public class Raid:NSObject,Codable{
    /// 磁盘类型, 如 system/data
    var volumeType:String?
    /// 设备详情
    var volumeDetail:String?
    /// RAID类型ID
    var raidTypeId:String?
    /// RAID类型, 如 NORAID, RAID0, RAID1
    var raidType:String?
    /// 云物理服务器类型, 如 edcps.c.normal1
    var deviceType:String?
    /// RAID类型描述
    var descriptionValue:String?



    public override init(){
            super.init()
    }

    enum RaidCodingKeys: String, CodingKey {
        case volumeType
        case volumeDetail
        case raidTypeId
        case raidType
        case deviceType
        case descriptionValue = "description"
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: RaidCodingKeys.self)
        if decoderContainer.contains(.volumeType)
        {
            self.volumeType = try decoderContainer.decode(String?.self, forKey: .volumeType)
        }
        if decoderContainer.contains(.volumeDetail)
        {
            self.volumeDetail = try decoderContainer.decode(String?.self, forKey: .volumeDetail)
        }
        if decoderContainer.contains(.raidTypeId)
        {
            self.raidTypeId = try decoderContainer.decode(String?.self, forKey: .raidTypeId)
        }
        if decoderContainer.contains(.raidType)
        {
            self.raidType = try decoderContainer.decode(String?.self, forKey: .raidType)
        }
        if decoderContainer.contains(.deviceType)
        {
            self.deviceType = try decoderContainer.decode(String?.self, forKey: .deviceType)
        }
        if decoderContainer.contains(.descriptionValue)
        {
            self.descriptionValue = try decoderContainer.decode(String?.self, forKey: .descriptionValue)
        }
    }
}
public extension Raid{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: RaidCodingKeys.self)
         try encoderContainer.encode(volumeType, forKey: .volumeType)
         try encoderContainer.encode(volumeDetail, forKey: .volumeDetail)
         try encoderContainer.encode(raidTypeId, forKey: .raidTypeId)
         try encoderContainer.encode(raidType, forKey: .raidType)
         try encoderContainer.encode(deviceType, forKey: .deviceType)
         try encoderContainer.encode(descriptionValue, forKey: .descriptionValue)
    }
}
///  deviceType
public class DeviceType:NSObject,Codable{
    /// 实例类型, 如 edcps.c.normal1
    var deviceTypeValue:String?
    /// 实例类型名称, 如 边缘标准计算型Ⅰ
    var name:String?
    /// 实例所属规格系列，如 计算、存储、GPU
    var family:String?
    /// 区域代码, 如 cn-east-tz1
    var region:String?
    /// CPU概要描述
    var cpuConcise:String?
    /// CPU详细信息
    var cpuDetail:String?
    /// 内存概要信息
    var memConcise:String?
    /// 内存详细信息
    var memDetail:String?
    /// 网口概要信息
    var ifConcise:String?
    /// 网口详细信息
    var ifDetail:String?
    /// GPU概要信息
    var gpuConcise:String?
    /// GPU详细信息
    var gpuDetail:String?
    /// 系统盘数量
    var systemDiskAmount:Int?
    /// 系统盘单盘大小（GB）
    var systemDiskSize:Int?
    /// 系统盘规格
    var systemDiskModel:String?
    /// 数据盘数量
    var dataDiskAmount:Int?
    /// 数据盘单盘大小（GB）
    var dataDiskSize:Int?
    /// 数据盘规格
    var dataDiskModel:String?
    /// 售罄状态
    var isSoldOut:Bool?



    public override init(){
            super.init()
    }

    enum DeviceTypeCodingKeys: String, CodingKey {
        case deviceTypeValue = "deviceType"
        case name
        case family
        case region
        case cpuConcise
        case cpuDetail
        case memConcise
        case memDetail
        case ifConcise
        case ifDetail
        case gpuConcise
        case gpuDetail
        case systemDiskAmount
        case systemDiskSize
        case systemDiskModel
        case dataDiskAmount
        case dataDiskSize
        case dataDiskModel
        case isSoldOut
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: DeviceTypeCodingKeys.self)
        if decoderContainer.contains(.deviceTypeValue)
        {
            self.deviceTypeValue = try decoderContainer.decode(String?.self, forKey: .deviceTypeValue)
        }
        if decoderContainer.contains(.name)
        {
            self.name = try decoderContainer.decode(String?.self, forKey: .name)
        }
        if decoderContainer.contains(.family)
        {
            self.family = try decoderContainer.decode(String?.self, forKey: .family)
        }
        if decoderContainer.contains(.region)
        {
            self.region = try decoderContainer.decode(String?.self, forKey: .region)
        }
        if decoderContainer.contains(.cpuConcise)
        {
            self.cpuConcise = try decoderContainer.decode(String?.self, forKey: .cpuConcise)
        }
        if decoderContainer.contains(.cpuDetail)
        {
            self.cpuDetail = try decoderContainer.decode(String?.self, forKey: .cpuDetail)
        }
        if decoderContainer.contains(.memConcise)
        {
            self.memConcise = try decoderContainer.decode(String?.self, forKey: .memConcise)
        }
        if decoderContainer.contains(.memDetail)
        {
            self.memDetail = try decoderContainer.decode(String?.self, forKey: .memDetail)
        }
        if decoderContainer.contains(.ifConcise)
        {
            self.ifConcise = try decoderContainer.decode(String?.self, forKey: .ifConcise)
        }
        if decoderContainer.contains(.ifDetail)
        {
            self.ifDetail = try decoderContainer.decode(String?.self, forKey: .ifDetail)
        }
        if decoderContainer.contains(.gpuConcise)
        {
            self.gpuConcise = try decoderContainer.decode(String?.self, forKey: .gpuConcise)
        }
        if decoderContainer.contains(.gpuDetail)
        {
            self.gpuDetail = try decoderContainer.decode(String?.self, forKey: .gpuDetail)
        }
        if decoderContainer.contains(.systemDiskAmount)
        {
            self.systemDiskAmount = try decoderContainer.decode(Int?.self, forKey: .systemDiskAmount)
        }
        if decoderContainer.contains(.systemDiskSize)
        {
            self.systemDiskSize = try decoderContainer.decode(Int?.self, forKey: .systemDiskSize)
        }
        if decoderContainer.contains(.systemDiskModel)
        {
            self.systemDiskModel = try decoderContainer.decode(String?.self, forKey: .systemDiskModel)
        }
        if decoderContainer.contains(.dataDiskAmount)
        {
            self.dataDiskAmount = try decoderContainer.decode(Int?.self, forKey: .dataDiskAmount)
        }
        if decoderContainer.contains(.dataDiskSize)
        {
            self.dataDiskSize = try decoderContainer.decode(Int?.self, forKey: .dataDiskSize)
        }
        if decoderContainer.contains(.dataDiskModel)
        {
            self.dataDiskModel = try decoderContainer.decode(String?.self, forKey: .dataDiskModel)
        }
        if decoderContainer.contains(.isSoldOut)
        {
            self.isSoldOut = try decoderContainer.decode(Bool?.self, forKey: .isSoldOut)
        }
    }
}
public extension DeviceType{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: DeviceTypeCodingKeys.self)
         try encoderContainer.encode(deviceTypeValue, forKey: .deviceTypeValue)
         try encoderContainer.encode(name, forKey: .name)
         try encoderContainer.encode(family, forKey: .family)
         try encoderContainer.encode(region, forKey: .region)
         try encoderContainer.encode(cpuConcise, forKey: .cpuConcise)
         try encoderContainer.encode(cpuDetail, forKey: .cpuDetail)
         try encoderContainer.encode(memConcise, forKey: .memConcise)
         try encoderContainer.encode(memDetail, forKey: .memDetail)
         try encoderContainer.encode(ifConcise, forKey: .ifConcise)
         try encoderContainer.encode(ifDetail, forKey: .ifDetail)
         try encoderContainer.encode(gpuConcise, forKey: .gpuConcise)
         try encoderContainer.encode(gpuDetail, forKey: .gpuDetail)
         try encoderContainer.encode(systemDiskAmount, forKey: .systemDiskAmount)
         try encoderContainer.encode(systemDiskSize, forKey: .systemDiskSize)
         try encoderContainer.encode(systemDiskModel, forKey: .systemDiskModel)
         try encoderContainer.encode(dataDiskAmount, forKey: .dataDiskAmount)
         try encoderContainer.encode(dataDiskSize, forKey: .dataDiskSize)
         try encoderContainer.encode(dataDiskModel, forKey: .dataDiskModel)
         try encoderContainer.encode(isSoldOut, forKey: .isSoldOut)
    }
}
///  os
public class Os:NSObject,Codable{
    /// 操作系统系统类型ID
    var osTypeId:String?
    /// 操作系统系统名称, 如 Ubuntu 16.04(x86_64)
    var osName:String?
    /// 操作系统类型, 如 ubuntu/centos
    var osType:String?
    /// 操作系统版本, 如 14.04/16.04
    var osVersion:String?
    /// 实例类型, 如 edcps.c.normal1
    var deviceType:String?



    public override init(){
            super.init()
    }

    enum OsCodingKeys: String, CodingKey {
        case osTypeId
        case osName
        case osType
        case osVersion
        case deviceType
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: OsCodingKeys.self)
        if decoderContainer.contains(.osTypeId)
        {
            self.osTypeId = try decoderContainer.decode(String?.self, forKey: .osTypeId)
        }
        if decoderContainer.contains(.osName)
        {
            self.osName = try decoderContainer.decode(String?.self, forKey: .osName)
        }
        if decoderContainer.contains(.osType)
        {
            self.osType = try decoderContainer.decode(String?.self, forKey: .osType)
        }
        if decoderContainer.contains(.osVersion)
        {
            self.osVersion = try decoderContainer.decode(String?.self, forKey: .osVersion)
        }
        if decoderContainer.contains(.deviceType)
        {
            self.deviceType = try decoderContainer.decode(String?.self, forKey: .deviceType)
        }
    }
}
public extension Os{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: OsCodingKeys.self)
         try encoderContainer.encode(osTypeId, forKey: .osTypeId)
         try encoderContainer.encode(osName, forKey: .osName)
         try encoderContainer.encode(osType, forKey: .osType)
         try encoderContainer.encode(osVersion, forKey: .osVersion)
         try encoderContainer.encode(deviceType, forKey: .deviceType)
    }
}
///  instance
public class Instance:NSObject,Codable{
    /// 云物理服务器实例ID
    var instanceId:String?
    /// 区域代码, 如 cn-east-tz1
    var region:String?
    /// 可用区, 如 cn-east-tz1a
    var az:String?
    /// 实例类型, 如 edcps.c.normal1
    var deviceType:String?
    /// 云物理服务器名称
    var name:String?
    /// 云物理服务器描述
    var descriptionValue:String?
    /// 云物理服务器生命周期状态
    var status:String?
    /// 是否启用外网, 如 yes/no
    var enableInternet:String?
    /// 是否启用IPv6, 如 yes/no
    var enableIpv6:String?
    /// 带宽, 单位Mbps
    var bandwidth:Int?
    /// 额外上行带宽, 单位Mbps
    var extraUplinkBandwidth:Int?
    /// 镜像类型, 如 standard
    var imageType:String?
    /// 操作系统类型ID
    var osTypeId:String?
    /// 操作系统名称
    var osName:String?
    /// 操作系统类型, 如 ubuntu/centos
    var osType:String?
    /// 操作系统版本, 如 16.04
    var osVersion:String?
    /// 系统盘RAID类型ID
    var sysRaidTypeId:String?
    /// 系统盘RAID类型, 如 NORAID, RAID0, RAID1
    var sysRaidType:String?
    /// 数据盘RAID类型ID
    var dataRaidTypeId:String?
    /// 数据盘RAID类型, 如 NORAID, RAID0, RAID1
    var dataRaidType:String?
    /// 网络类型, 如 basic, vpc
    var networkType:String?
    /// 私有网络ID
    var vpcId:String?
    /// 私有网络名称
    var vpcName:String?
    /// 子网编号
    var subnetId:String?
    /// 子网名称
    var subnetName:String?
    /// 内网IP
    var privateIp:String?
    /// 外网链路类型, 如 bgp
    var lineType:String?
    /// 弹性公网IPID
    var elasticIpId:String?
    /// 公网IP
    var publicIp:String?
    /// 公网IPv6
    var publicIpv6:String?
    /// 密钥对id
    var keypairId:String?
    /// agent状态
    var agentStatus:String?
    /// 计费信息
    var charge:Charge?



    public override init(){
            super.init()
    }

    enum InstanceCodingKeys: String, CodingKey {
        case instanceId
        case region
        case az
        case deviceType
        case name
        case descriptionValue = "description"
        case status
        case enableInternet
        case enableIpv6
        case bandwidth
        case extraUplinkBandwidth
        case imageType
        case osTypeId
        case osName
        case osType
        case osVersion
        case sysRaidTypeId
        case sysRaidType
        case dataRaidTypeId
        case dataRaidType
        case networkType
        case vpcId
        case vpcName
        case subnetId
        case subnetName
        case privateIp
        case lineType
        case elasticIpId
        case publicIp
        case publicIpv6
        case keypairId
        case agentStatus
        case charge
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: InstanceCodingKeys.self)
        if decoderContainer.contains(.instanceId)
        {
            self.instanceId = try decoderContainer.decode(String?.self, forKey: .instanceId)
        }
        if decoderContainer.contains(.region)
        {
            self.region = try decoderContainer.decode(String?.self, forKey: .region)
        }
        if decoderContainer.contains(.az)
        {
            self.az = try decoderContainer.decode(String?.self, forKey: .az)
        }
        if decoderContainer.contains(.deviceType)
        {
            self.deviceType = try decoderContainer.decode(String?.self, forKey: .deviceType)
        }
        if decoderContainer.contains(.name)
        {
            self.name = try decoderContainer.decode(String?.self, forKey: .name)
        }
        if decoderContainer.contains(.descriptionValue)
        {
            self.descriptionValue = try decoderContainer.decode(String?.self, forKey: .descriptionValue)
        }
        if decoderContainer.contains(.status)
        {
            self.status = try decoderContainer.decode(String?.self, forKey: .status)
        }
        if decoderContainer.contains(.enableInternet)
        {
            self.enableInternet = try decoderContainer.decode(String?.self, forKey: .enableInternet)
        }
        if decoderContainer.contains(.enableIpv6)
        {
            self.enableIpv6 = try decoderContainer.decode(String?.self, forKey: .enableIpv6)
        }
        if decoderContainer.contains(.bandwidth)
        {
            self.bandwidth = try decoderContainer.decode(Int?.self, forKey: .bandwidth)
        }
        if decoderContainer.contains(.extraUplinkBandwidth)
        {
            self.extraUplinkBandwidth = try decoderContainer.decode(Int?.self, forKey: .extraUplinkBandwidth)
        }
        if decoderContainer.contains(.imageType)
        {
            self.imageType = try decoderContainer.decode(String?.self, forKey: .imageType)
        }
        if decoderContainer.contains(.osTypeId)
        {
            self.osTypeId = try decoderContainer.decode(String?.self, forKey: .osTypeId)
        }
        if decoderContainer.contains(.osName)
        {
            self.osName = try decoderContainer.decode(String?.self, forKey: .osName)
        }
        if decoderContainer.contains(.osType)
        {
            self.osType = try decoderContainer.decode(String?.self, forKey: .osType)
        }
        if decoderContainer.contains(.osVersion)
        {
            self.osVersion = try decoderContainer.decode(String?.self, forKey: .osVersion)
        }
        if decoderContainer.contains(.sysRaidTypeId)
        {
            self.sysRaidTypeId = try decoderContainer.decode(String?.self, forKey: .sysRaidTypeId)
        }
        if decoderContainer.contains(.sysRaidType)
        {
            self.sysRaidType = try decoderContainer.decode(String?.self, forKey: .sysRaidType)
        }
        if decoderContainer.contains(.dataRaidTypeId)
        {
            self.dataRaidTypeId = try decoderContainer.decode(String?.self, forKey: .dataRaidTypeId)
        }
        if decoderContainer.contains(.dataRaidType)
        {
            self.dataRaidType = try decoderContainer.decode(String?.self, forKey: .dataRaidType)
        }
        if decoderContainer.contains(.networkType)
        {
            self.networkType = try decoderContainer.decode(String?.self, forKey: .networkType)
        }
        if decoderContainer.contains(.vpcId)
        {
            self.vpcId = try decoderContainer.decode(String?.self, forKey: .vpcId)
        }
        if decoderContainer.contains(.vpcName)
        {
            self.vpcName = try decoderContainer.decode(String?.self, forKey: .vpcName)
        }
        if decoderContainer.contains(.subnetId)
        {
            self.subnetId = try decoderContainer.decode(String?.self, forKey: .subnetId)
        }
        if decoderContainer.contains(.subnetName)
        {
            self.subnetName = try decoderContainer.decode(String?.self, forKey: .subnetName)
        }
        if decoderContainer.contains(.privateIp)
        {
            self.privateIp = try decoderContainer.decode(String?.self, forKey: .privateIp)
        }
        if decoderContainer.contains(.lineType)
        {
            self.lineType = try decoderContainer.decode(String?.self, forKey: .lineType)
        }
        if decoderContainer.contains(.elasticIpId)
        {
            self.elasticIpId = try decoderContainer.decode(String?.self, forKey: .elasticIpId)
        }
        if decoderContainer.contains(.publicIp)
        {
            self.publicIp = try decoderContainer.decode(String?.self, forKey: .publicIp)
        }
        if decoderContainer.contains(.publicIpv6)
        {
            self.publicIpv6 = try decoderContainer.decode(String?.self, forKey: .publicIpv6)
        }
        if decoderContainer.contains(.keypairId)
        {
            self.keypairId = try decoderContainer.decode(String?.self, forKey: .keypairId)
        }
        if decoderContainer.contains(.agentStatus)
        {
            self.agentStatus = try decoderContainer.decode(String?.self, forKey: .agentStatus)
        }
        if decoderContainer.contains(.charge)
        {
            self.charge = try decoderContainer.decode(Charge?.self, forKey: .charge)
        }
    }
}
public extension Instance{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: InstanceCodingKeys.self)
         try encoderContainer.encode(instanceId, forKey: .instanceId)
         try encoderContainer.encode(region, forKey: .region)
         try encoderContainer.encode(az, forKey: .az)
         try encoderContainer.encode(deviceType, forKey: .deviceType)
         try encoderContainer.encode(name, forKey: .name)
         try encoderContainer.encode(descriptionValue, forKey: .descriptionValue)
         try encoderContainer.encode(status, forKey: .status)
         try encoderContainer.encode(enableInternet, forKey: .enableInternet)
         try encoderContainer.encode(enableIpv6, forKey: .enableIpv6)
         try encoderContainer.encode(bandwidth, forKey: .bandwidth)
         try encoderContainer.encode(extraUplinkBandwidth, forKey: .extraUplinkBandwidth)
         try encoderContainer.encode(imageType, forKey: .imageType)
         try encoderContainer.encode(osTypeId, forKey: .osTypeId)
         try encoderContainer.encode(osName, forKey: .osName)
         try encoderContainer.encode(osType, forKey: .osType)
         try encoderContainer.encode(osVersion, forKey: .osVersion)
         try encoderContainer.encode(sysRaidTypeId, forKey: .sysRaidTypeId)
         try encoderContainer.encode(sysRaidType, forKey: .sysRaidType)
         try encoderContainer.encode(dataRaidTypeId, forKey: .dataRaidTypeId)
         try encoderContainer.encode(dataRaidType, forKey: .dataRaidType)
         try encoderContainer.encode(networkType, forKey: .networkType)
         try encoderContainer.encode(vpcId, forKey: .vpcId)
         try encoderContainer.encode(vpcName, forKey: .vpcName)
         try encoderContainer.encode(subnetId, forKey: .subnetId)
         try encoderContainer.encode(subnetName, forKey: .subnetName)
         try encoderContainer.encode(privateIp, forKey: .privateIp)
         try encoderContainer.encode(lineType, forKey: .lineType)
         try encoderContainer.encode(elasticIpId, forKey: .elasticIpId)
         try encoderContainer.encode(publicIp, forKey: .publicIp)
         try encoderContainer.encode(publicIpv6, forKey: .publicIpv6)
         try encoderContainer.encode(keypairId, forKey: .keypairId)
         try encoderContainer.encode(agentStatus, forKey: .agentStatus)
         try encoderContainer.encode(charge, forKey: .charge)
    }
}
///  renewalResource
public class RenewalResource:NSObject,Codable{
    /// 资源ID
    var resourceId:String?
    /// 资源名称
    var resourceName:String?
    /// 备注
    var remark:String?
    /// 绑定资源列表
    var bind:[RenewalResource?]?



    public override init(){
            super.init()
    }

    enum RenewalResourceCodingKeys: String, CodingKey {
        case resourceId
        case resourceName
        case remark
        case bind
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: RenewalResourceCodingKeys.self)
        if decoderContainer.contains(.resourceId)
        {
            self.resourceId = try decoderContainer.decode(String?.self, forKey: .resourceId)
        }
        if decoderContainer.contains(.resourceName)
        {
            self.resourceName = try decoderContainer.decode(String?.self, forKey: .resourceName)
        }
        if decoderContainer.contains(.remark)
        {
            self.remark = try decoderContainer.decode(String?.self, forKey: .remark)
        }
        if decoderContainer.contains(.bind)
        {
            self.bind = try decoderContainer.decode([RenewalResource?]?.self, forKey: .bind)
        }
    }
}
public extension RenewalResource{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: RenewalResourceCodingKeys.self)
         try encoderContainer.encode(resourceId, forKey: .resourceId)
         try encoderContainer.encode(resourceName, forKey: .resourceName)
         try encoderContainer.encode(remark, forKey: .remark)
         try encoderContainer.encode(bind, forKey: .bind)
    }
}
///  instanceSpec
public class InstanceSpec:NSObject,Codable{
    /// 可用区, 如 cn-east-tz1
    /// Required:true
    var az:String
    /// 实例类型, 如 edcps.c.normal1
    /// Required:true
    var deviceType:String
    /// 主机名
    var hostname:String?
    /// 镜像类型, 取值范围：standard
    /// Required:true
    var imageType:String
    /// 操作系统类型ID
    /// Required:true
    var osTypeId:String
    /// 系统盘RAID类型ID
    /// Required:true
    var sysRaidTypeId:String
    /// 数据盘RAID类型ID
    /// Required:true
    var dataRaidTypeId:String
    /// 子网编号
    var subnetId:String?
    /// 是否启用外网，取值范围：yes、no
    var enableInternet:String?
    /// 网络类型，取值范围：vpc
    /// Required:true
    var networkType:String
    /// 网络CIDR
    var cidr:String?
    /// 内网IP
    var privateIp:String?
    /// 外网链路类型, 目前支持联通un、电信ct、移动cm
    var lineType:String?
    /// 外网带宽, 范围[1,10240] 单位Mbps
    var bandwidth:Int?
    /// 额外上行带宽, 范围[0,10240] 单位Mbps
    var extraUplinkBandwidth:Int?
    /// 云物理服务器名称
    /// Required:true
    var name:String
    /// 云物理服务器描述
    var descriptionValue:String?
    /// 密码，不传值会随机生成密码
    var password:String?
    /// 购买数量
    /// Required:true
    var count:Int
    /// 可执行脚本Base64编码后的内容，支持shell和python脚本
    var userData:String?
    /// 密钥对id
    var keypairId:String?
    /// 计费配置
    /// Required:true
    var charge:ChargeSpec
    /// 别名ip配置
    var aliasIps:[AliasIpInfo?]?



    public  init(az:String,deviceType:String,imageType:String,osTypeId:String,sysRaidTypeId:String,dataRaidTypeId:String,networkType:String,name:String,count:Int,charge:ChargeSpec){
             self.az = az
             self.deviceType = deviceType
             self.imageType = imageType
             self.osTypeId = osTypeId
             self.sysRaidTypeId = sysRaidTypeId
             self.dataRaidTypeId = dataRaidTypeId
             self.networkType = networkType
             self.name = name
             self.count = count
             self.charge = charge
    }

    enum InstanceSpecCodingKeys: String, CodingKey {
        case az
        case deviceType
        case hostname
        case imageType
        case osTypeId
        case sysRaidTypeId
        case dataRaidTypeId
        case subnetId
        case enableInternet
        case networkType
        case cidr
        case privateIp
        case lineType
        case bandwidth
        case extraUplinkBandwidth
        case name
        case descriptionValue = "description"
        case password
        case count
        case userData
        case keypairId
        case charge
        case aliasIps
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: InstanceSpecCodingKeys.self)
        self.az = try decoderContainer.decode(String.self, forKey: .az)
        self.deviceType = try decoderContainer.decode(String.self, forKey: .deviceType)
        if decoderContainer.contains(.hostname)
        {
            self.hostname = try decoderContainer.decode(String?.self, forKey: .hostname)
        }
        self.imageType = try decoderContainer.decode(String.self, forKey: .imageType)
        self.osTypeId = try decoderContainer.decode(String.self, forKey: .osTypeId)
        self.sysRaidTypeId = try decoderContainer.decode(String.self, forKey: .sysRaidTypeId)
        self.dataRaidTypeId = try decoderContainer.decode(String.self, forKey: .dataRaidTypeId)
        if decoderContainer.contains(.subnetId)
        {
            self.subnetId = try decoderContainer.decode(String?.self, forKey: .subnetId)
        }
        if decoderContainer.contains(.enableInternet)
        {
            self.enableInternet = try decoderContainer.decode(String?.self, forKey: .enableInternet)
        }
        self.networkType = try decoderContainer.decode(String.self, forKey: .networkType)
        if decoderContainer.contains(.cidr)
        {
            self.cidr = try decoderContainer.decode(String?.self, forKey: .cidr)
        }
        if decoderContainer.contains(.privateIp)
        {
            self.privateIp = try decoderContainer.decode(String?.self, forKey: .privateIp)
        }
        if decoderContainer.contains(.lineType)
        {
            self.lineType = try decoderContainer.decode(String?.self, forKey: .lineType)
        }
        if decoderContainer.contains(.bandwidth)
        {
            self.bandwidth = try decoderContainer.decode(Int?.self, forKey: .bandwidth)
        }
        if decoderContainer.contains(.extraUplinkBandwidth)
        {
            self.extraUplinkBandwidth = try decoderContainer.decode(Int?.self, forKey: .extraUplinkBandwidth)
        }
        self.name = try decoderContainer.decode(String.self, forKey: .name)
        if decoderContainer.contains(.descriptionValue)
        {
            self.descriptionValue = try decoderContainer.decode(String?.self, forKey: .descriptionValue)
        }
        if decoderContainer.contains(.password)
        {
            self.password = try decoderContainer.decode(String?.self, forKey: .password)
        }
        self.count = try decoderContainer.decode(Int.self, forKey: .count)
        if decoderContainer.contains(.userData)
        {
            self.userData = try decoderContainer.decode(String?.self, forKey: .userData)
        }
        if decoderContainer.contains(.keypairId)
        {
            self.keypairId = try decoderContainer.decode(String?.self, forKey: .keypairId)
        }
        self.charge = try decoderContainer.decode(ChargeSpec.self, forKey: .charge)
        if decoderContainer.contains(.aliasIps)
        {
            self.aliasIps = try decoderContainer.decode([AliasIpInfo?]?.self, forKey: .aliasIps)
        }
    }
}
public extension InstanceSpec{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: InstanceSpecCodingKeys.self)
         try encoderContainer.encode(az, forKey: .az)
         try encoderContainer.encode(deviceType, forKey: .deviceType)
         try encoderContainer.encode(hostname, forKey: .hostname)
         try encoderContainer.encode(imageType, forKey: .imageType)
         try encoderContainer.encode(osTypeId, forKey: .osTypeId)
         try encoderContainer.encode(sysRaidTypeId, forKey: .sysRaidTypeId)
         try encoderContainer.encode(dataRaidTypeId, forKey: .dataRaidTypeId)
         try encoderContainer.encode(subnetId, forKey: .subnetId)
         try encoderContainer.encode(enableInternet, forKey: .enableInternet)
         try encoderContainer.encode(networkType, forKey: .networkType)
         try encoderContainer.encode(cidr, forKey: .cidr)
         try encoderContainer.encode(privateIp, forKey: .privateIp)
         try encoderContainer.encode(lineType, forKey: .lineType)
         try encoderContainer.encode(bandwidth, forKey: .bandwidth)
         try encoderContainer.encode(extraUplinkBandwidth, forKey: .extraUplinkBandwidth)
         try encoderContainer.encode(name, forKey: .name)
         try encoderContainer.encode(descriptionValue, forKey: .descriptionValue)
         try encoderContainer.encode(password, forKey: .password)
         try encoderContainer.encode(count, forKey: .count)
         try encoderContainer.encode(userData, forKey: .userData)
         try encoderContainer.encode(keypairId, forKey: .keypairId)
         try encoderContainer.encode(charge, forKey: .charge)
         try encoderContainer.encode(aliasIps, forKey: .aliasIps)
    }
}
///  reinstallInstanceSpec
public class ReinstallInstanceSpec:NSObject,Codable{
    /// 可用区, 如cn-east-tz1a
    /// Required:true
    var az:String
    /// 镜像类型, 取值范围：standard
    /// Required:true
    var imageType:String
    /// 操作系统类型ID
    /// Required:true
    var osTypeId:String
    /// 系统盘RAID类型ID
    /// Required:true
    var sysRaidTypeId:String
    /// 是否保留数据盘数据, 取值为：yes、no
    /// Required:true
    var keepData:String
    /// 数据盘RAID类型ID
    /// Required:true
    var dataRaidTypeId:String
    /// 密码
    /// Required:true
    var password:String
    /// 主机名
    var hostname:String?
    /// 可执行脚本Base64编码后的内容，支持shell和python脚本
    var userData:String?
    /// 密钥对id
    var keypairId:String?



    public  init(az:String,imageType:String,osTypeId:String,sysRaidTypeId:String,keepData:String,dataRaidTypeId:String,password:String){
             self.az = az
             self.imageType = imageType
             self.osTypeId = osTypeId
             self.sysRaidTypeId = sysRaidTypeId
             self.keepData = keepData
             self.dataRaidTypeId = dataRaidTypeId
             self.password = password
    }

    enum ReinstallInstanceSpecCodingKeys: String, CodingKey {
        case az
        case imageType
        case osTypeId
        case sysRaidTypeId
        case keepData
        case dataRaidTypeId
        case password
        case hostname
        case userData
        case keypairId
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: ReinstallInstanceSpecCodingKeys.self)
        self.az = try decoderContainer.decode(String.self, forKey: .az)
        self.imageType = try decoderContainer.decode(String.self, forKey: .imageType)
        self.osTypeId = try decoderContainer.decode(String.self, forKey: .osTypeId)
        self.sysRaidTypeId = try decoderContainer.decode(String.self, forKey: .sysRaidTypeId)
        self.keepData = try decoderContainer.decode(String.self, forKey: .keepData)
        self.dataRaidTypeId = try decoderContainer.decode(String.self, forKey: .dataRaidTypeId)
        self.password = try decoderContainer.decode(String.self, forKey: .password)
        if decoderContainer.contains(.hostname)
        {
            self.hostname = try decoderContainer.decode(String?.self, forKey: .hostname)
        }
        if decoderContainer.contains(.userData)
        {
            self.userData = try decoderContainer.decode(String?.self, forKey: .userData)
        }
        if decoderContainer.contains(.keypairId)
        {
            self.keypairId = try decoderContainer.decode(String?.self, forKey: .keypairId)
        }
    }
}
public extension ReinstallInstanceSpec{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: ReinstallInstanceSpecCodingKeys.self)
         try encoderContainer.encode(az, forKey: .az)
         try encoderContainer.encode(imageType, forKey: .imageType)
         try encoderContainer.encode(osTypeId, forKey: .osTypeId)
         try encoderContainer.encode(sysRaidTypeId, forKey: .sysRaidTypeId)
         try encoderContainer.encode(keepData, forKey: .keepData)
         try encoderContainer.encode(dataRaidTypeId, forKey: .dataRaidTypeId)
         try encoderContainer.encode(password, forKey: .password)
         try encoderContainer.encode(hostname, forKey: .hostname)
         try encoderContainer.encode(userData, forKey: .userData)
         try encoderContainer.encode(keypairId, forKey: .keypairId)
    }
}
///  resourceStock
public class ResourceStock:NSObject,Codable{
    /// 实例类型, 如 edcps.c.normal1
    var deviceType:String?
    /// 区域代码, 如 cn-east-tz1
    var region:String?
    /// 可用库存
    var available:Int?



    public override init(){
            super.init()
    }

    enum ResourceStockCodingKeys: String, CodingKey {
        case deviceType
        case region
        case available
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: ResourceStockCodingKeys.self)
        if decoderContainer.contains(.deviceType)
        {
            self.deviceType = try decoderContainer.decode(String?.self, forKey: .deviceType)
        }
        if decoderContainer.contains(.region)
        {
            self.region = try decoderContainer.decode(String?.self, forKey: .region)
        }
        if decoderContainer.contains(.available)
        {
            self.available = try decoderContainer.decode(Int?.self, forKey: .available)
        }
    }
}
public extension ResourceStock{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: ResourceStockCodingKeys.self)
         try encoderContainer.encode(deviceType, forKey: .deviceType)
         try encoderContainer.encode(region, forKey: .region)
         try encoderContainer.encode(available, forKey: .available)
    }
}
///  vpcSpec
public class VpcSpec:NSObject,Codable{
    /// 私有网络范围
    /// Required:true
    var cidr:String
    /// 名称
    /// Required:true
    var name:String
    /// 描述
    /// Required:true
    var descriptionValue:String



    public  init(cidr:String,name:String,descriptionValue:String){
             self.cidr = cidr
             self.name = name
             self.descriptionValue = descriptionValue
    }

    enum VpcSpecCodingKeys: String, CodingKey {
        case cidr
        case name
        case descriptionValue = "description"
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: VpcSpecCodingKeys.self)
        self.cidr = try decoderContainer.decode(String.self, forKey: .cidr)
        self.name = try decoderContainer.decode(String.self, forKey: .name)
        self.descriptionValue = try decoderContainer.decode(String.self, forKey: .descriptionValue)
    }
}
public extension VpcSpec{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: VpcSpecCodingKeys.self)
         try encoderContainer.encode(cidr, forKey: .cidr)
         try encoderContainer.encode(name, forKey: .name)
         try encoderContainer.encode(descriptionValue, forKey: .descriptionValue)
    }
}
///  vpc
public class Vpc:NSObject,Codable{
    /// 地域代码, 如cn-east-tz1
    var region:String?
    /// 私有网络ID
    var vpcId:String?
    /// 私有网络名称
    var name:String?
    /// 私有网络CIDR
    var cidr:String?
    /// 描述
    var descriptionValue:String?
    /// 创建时间
    var createTime:String?



    public override init(){
            super.init()
    }

    enum VpcCodingKeys: String, CodingKey {
        case region
        case vpcId
        case name
        case cidr
        case descriptionValue = "description"
        case createTime
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: VpcCodingKeys.self)
        if decoderContainer.contains(.region)
        {
            self.region = try decoderContainer.decode(String?.self, forKey: .region)
        }
        if decoderContainer.contains(.vpcId)
        {
            self.vpcId = try decoderContainer.decode(String?.self, forKey: .vpcId)
        }
        if decoderContainer.contains(.name)
        {
            self.name = try decoderContainer.decode(String?.self, forKey: .name)
        }
        if decoderContainer.contains(.cidr)
        {
            self.cidr = try decoderContainer.decode(String?.self, forKey: .cidr)
        }
        if decoderContainer.contains(.descriptionValue)
        {
            self.descriptionValue = try decoderContainer.decode(String?.self, forKey: .descriptionValue)
        }
        if decoderContainer.contains(.createTime)
        {
            self.createTime = try decoderContainer.decode(String?.self, forKey: .createTime)
        }
    }
}
public extension Vpc{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: VpcCodingKeys.self)
         try encoderContainer.encode(region, forKey: .region)
         try encoderContainer.encode(vpcId, forKey: .vpcId)
         try encoderContainer.encode(name, forKey: .name)
         try encoderContainer.encode(cidr, forKey: .cidr)
         try encoderContainer.encode(descriptionValue, forKey: .descriptionValue)
         try encoderContainer.encode(createTime, forKey: .createTime)
    }
}
///  az
public class Az:NSObject,Codable{
    /// 地域代码，如 cn-east-tz1
    var region:String?
    /// 可用区代码，如 cn-east-tz1a
    var azValue:String?
    /// 可用区名称
    var azName:String?



    public override init(){
            super.init()
    }

    enum AzCodingKeys: String, CodingKey {
        case region
        case azValue = "az"
        case azName
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: AzCodingKeys.self)
        if decoderContainer.contains(.region)
        {
            self.region = try decoderContainer.decode(String?.self, forKey: .region)
        }
        if decoderContainer.contains(.azValue)
        {
            self.azValue = try decoderContainer.decode(String?.self, forKey: .azValue)
        }
        if decoderContainer.contains(.azName)
        {
            self.azName = try decoderContainer.decode(String?.self, forKey: .azName)
        }
    }
}
public extension Az{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: AzCodingKeys.self)
         try encoderContainer.encode(region, forKey: .region)
         try encoderContainer.encode(azValue, forKey: .azValue)
         try encoderContainer.encode(azName, forKey: .azName)
    }
}
///  region
public class Region:NSObject,Codable{
    /// 地域代码, 如 cn-east-tz1
    var regionValue:String?
    /// 地域名称，如 华东-台州
    var regionName:String?
    /// 可用区列表
    var azs:[Az?]?



    public override init(){
            super.init()
    }

    enum RegionCodingKeys: String, CodingKey {
        case regionValue = "region"
        case regionName
        case azs
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: RegionCodingKeys.self)
        if decoderContainer.contains(.regionValue)
        {
            self.regionValue = try decoderContainer.decode(String?.self, forKey: .regionValue)
        }
        if decoderContainer.contains(.regionName)
        {
            self.regionName = try decoderContainer.decode(String?.self, forKey: .regionName)
        }
        if decoderContainer.contains(.azs)
        {
            self.azs = try decoderContainer.decode([Az?]?.self, forKey: .azs)
        }
    }
}
public extension Region{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: RegionCodingKeys.self)
         try encoderContainer.encode(regionValue, forKey: .regionValue)
         try encoderContainer.encode(regionName, forKey: .regionName)
         try encoderContainer.encode(azs, forKey: .azs)
    }
}

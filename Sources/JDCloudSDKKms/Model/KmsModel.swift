/* Copyright 2018 JDCLOUD.COM

   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at

     http:#www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.

   Key Management Service
   基于硬件保护密钥的安全数据托管服务

   OpenAPI spec version: v1
   Contact: 

   NOTE: This class is auto generated by the jdcloud code generator program.
 */


import Foundation
///  secretTimeCfg
public class SecretTimeCfg:NSObject,Codable{
    /// 激活时间，默认为当前时间，采用ISO8601标准，格式为: YYYY-MM-DDTHH:mm:ssZ
    /// Required:true
    var startTime:String
    /// 到期时间，默认为永久不到期，采用ISO8601标准，格式为: YYYY-MM-DDTHH:mm:ssZ
    /// Required:true
    var expireTime:String



    public  init(startTime:String,expireTime:String){
             self.startTime = startTime
             self.expireTime = expireTime
    }

    enum SecretTimeCfgCodingKeys: String, CodingKey {
        case startTime
        case expireTime
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: SecretTimeCfgCodingKeys.self)
        self.startTime = try decoderContainer.decode(String.self, forKey: .startTime)
        self.expireTime = try decoderContainer.decode(String.self, forKey: .expireTime)
    }
}
public extension SecretTimeCfg{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: SecretTimeCfgCodingKeys.self)
         try encoderContainer.encode(startTime, forKey: .startTime)
         try encoderContainer.encode(expireTime, forKey: .expireTime)
    }
}
///  secretVersionCfg
public class SecretVersionCfg:NSObject,Codable{
    /// secret内容
    /// Required:true
    var secretData:String
    /// 机密数据有效时间段配置
    /// Required:true
    var secretTimeCfg:SecretTimeCfg



    public  init(secretData:String,secretTimeCfg:SecretTimeCfg){
             self.secretData = secretData
             self.secretTimeCfg = secretTimeCfg
    }

    enum SecretVersionCfgCodingKeys: String, CodingKey {
        case secretData
        case secretTimeCfg
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: SecretVersionCfgCodingKeys.self)
        self.secretData = try decoderContainer.decode(String.self, forKey: .secretData)
        self.secretTimeCfg = try decoderContainer.decode(SecretTimeCfg.self, forKey: .secretTimeCfg)
    }
}
public extension SecretVersionCfg{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: SecretVersionCfgCodingKeys.self)
         try encoderContainer.encode(secretData, forKey: .secretData)
         try encoderContainer.encode(secretTimeCfg, forKey: .secretTimeCfg)
    }
}
///  secretDescCfg
public class SecretDescCfg:NSObject,Codable{
    /// secret名称，默认为&quot;&quot;
    /// Required:true
    var secretName:String
    /// secret描述，默认为&quot;&quot;
    /// Required:true
    var secretDesc:String



    public  init(secretName:String,secretDesc:String){
             self.secretName = secretName
             self.secretDesc = secretDesc
    }

    enum SecretDescCfgCodingKeys: String, CodingKey {
        case secretName
        case secretDesc
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: SecretDescCfgCodingKeys.self)
        self.secretName = try decoderContainer.decode(String.self, forKey: .secretName)
        self.secretDesc = try decoderContainer.decode(String.self, forKey: .secretDesc)
    }
}
public extension SecretDescCfg{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: SecretDescCfgCodingKeys.self)
         try encoderContainer.encode(secretName, forKey: .secretName)
         try encoderContainer.encode(secretDesc, forKey: .secretDesc)
    }
}
///  secretInfo
public class SecretInfo:NSObject,Codable{
    /// SecretID
    /// Required:true
    var secretId:String
    /// Secret名称
    /// Required:true
    var secretName:String
    /// Secret用途描述
    /// Required:true
    var secretDesc:String
    /// Secret当前状态: 0: 已启用、1: 已禁用
    /// Required:true
    var secretStatus:Int
    /// Secret创建时间，采用ISO8601标准，格式为: YYYY-MM-DDTHH:mm:ssZ
    /// Required:true
    var createTime:String



    public  init(secretId:String,secretName:String,secretDesc:String,secretStatus:Int,createTime:String){
             self.secretId = secretId
             self.secretName = secretName
             self.secretDesc = secretDesc
             self.secretStatus = secretStatus
             self.createTime = createTime
    }

    enum SecretInfoCodingKeys: String, CodingKey {
        case secretId
        case secretName
        case secretDesc
        case secretStatus
        case createTime
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: SecretInfoCodingKeys.self)
        self.secretId = try decoderContainer.decode(String.self, forKey: .secretId)
        self.secretName = try decoderContainer.decode(String.self, forKey: .secretName)
        self.secretDesc = try decoderContainer.decode(String.self, forKey: .secretDesc)
        self.secretStatus = try decoderContainer.decode(Int.self, forKey: .secretStatus)
        self.createTime = try decoderContainer.decode(String.self, forKey: .createTime)
    }
}
public extension SecretInfo{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: SecretInfoCodingKeys.self)
         try encoderContainer.encode(secretId, forKey: .secretId)
         try encoderContainer.encode(secretName, forKey: .secretName)
         try encoderContainer.encode(secretDesc, forKey: .secretDesc)
         try encoderContainer.encode(secretStatus, forKey: .secretStatus)
         try encoderContainer.encode(createTime, forKey: .createTime)
    }
}
///  secretVersionItem
public class SecretVersionItem:NSObject,Codable{
    /// 版本标识
    /// Required:true
    var secretVersion:String
    /// Secret当前状态: 0: 已启用、1: 已禁用
    /// Required:true
    var secretStatus:Int
    /// Secret激活时间，采用ISO8601标准，格式为: YYYY-MM-DDTHH:mm:ssZ
    /// Required:true
    var startTime:String
    /// 到期时间，采用ISO8601标准，格式为: YYYY-MM-DDTHH:mm:ssZ
    /// Required:true
    var expireTime:String
    /// 密钥的内容
    /// Required:true
    var secretData:String



    public  init(secretVersion:String,secretStatus:Int,startTime:String,expireTime:String,secretData:String){
             self.secretVersion = secretVersion
             self.secretStatus = secretStatus
             self.startTime = startTime
             self.expireTime = expireTime
             self.secretData = secretData
    }

    enum SecretVersionItemCodingKeys: String, CodingKey {
        case secretVersion
        case secretStatus
        case startTime
        case expireTime
        case secretData
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: SecretVersionItemCodingKeys.self)
        self.secretVersion = try decoderContainer.decode(String.self, forKey: .secretVersion)
        self.secretStatus = try decoderContainer.decode(Int.self, forKey: .secretStatus)
        self.startTime = try decoderContainer.decode(String.self, forKey: .startTime)
        self.expireTime = try decoderContainer.decode(String.self, forKey: .expireTime)
        self.secretData = try decoderContainer.decode(String.self, forKey: .secretData)
    }
}
public extension SecretVersionItem{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: SecretVersionItemCodingKeys.self)
         try encoderContainer.encode(secretVersion, forKey: .secretVersion)
         try encoderContainer.encode(secretStatus, forKey: .secretStatus)
         try encoderContainer.encode(startTime, forKey: .startTime)
         try encoderContainer.encode(expireTime, forKey: .expireTime)
         try encoderContainer.encode(secretData, forKey: .secretData)
    }
}
///  secretDetail
public class SecretDetail:NSObject,Codable{
    /// 密钥的基本信息
    /// Required:true
    var secretInfo:SecretInfo
    /// Secret版本的个数
    /// Required:true
    var secretVersionCount:Int
    /// Secret版本详情的列表
    /// Required:true
    var secretVersionList:[SecretVersionItem?]?



    public  init(secretInfo:SecretInfo,secretVersionCount:Int,secretVersionList:[SecretVersionItem?]?){
             self.secretInfo = secretInfo
             self.secretVersionCount = secretVersionCount
             self.secretVersionList = secretVersionList
    }

    enum SecretDetailCodingKeys: String, CodingKey {
        case secretInfo
        case secretVersionCount
        case secretVersionList
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: SecretDetailCodingKeys.self)
        self.secretInfo = try decoderContainer.decode(SecretInfo.self, forKey: .secretInfo)
        self.secretVersionCount = try decoderContainer.decode(Int.self, forKey: .secretVersionCount)
        self.secretVersionList = try decoderContainer.decode([SecretVersionItem?]?.self, forKey: .secretVersionList)
    }
}
public extension SecretDetail{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: SecretDetailCodingKeys.self)
         try encoderContainer.encode(secretInfo, forKey: .secretInfo)
         try encoderContainer.encode(secretVersionCount, forKey: .secretVersionCount)
         try encoderContainer.encode(secretVersionList, forKey: .secretVersionList)
    }
}
///  secretCfg
public class SecretCfg:NSObject,Codable{
    /// 机密数据描述信息配置
    /// Required:true
    var secretDescCfg:SecretDescCfg
    /// 机密数据有效时间段配置
    /// Required:true
    var secretTimeCfg:SecretTimeCfg
    /// secret内容
    /// Required:true
    var secretData:String



    public  init(secretDescCfg:SecretDescCfg,secretTimeCfg:SecretTimeCfg,secretData:String){
             self.secretDescCfg = secretDescCfg
             self.secretTimeCfg = secretTimeCfg
             self.secretData = secretData
    }

    enum SecretCfgCodingKeys: String, CodingKey {
        case secretDescCfg
        case secretTimeCfg
        case secretData
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: SecretCfgCodingKeys.self)
        self.secretDescCfg = try decoderContainer.decode(SecretDescCfg.self, forKey: .secretDescCfg)
        self.secretTimeCfg = try decoderContainer.decode(SecretTimeCfg.self, forKey: .secretTimeCfg)
        self.secretData = try decoderContainer.decode(String.self, forKey: .secretData)
    }
}
public extension SecretCfg{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: SecretCfgCodingKeys.self)
         try encoderContainer.encode(secretDescCfg, forKey: .secretDescCfg)
         try encoderContainer.encode(secretTimeCfg, forKey: .secretTimeCfg)
         try encoderContainer.encode(secretData, forKey: .secretData)
    }
}
///  keyDetail
public class KeyDetail:NSObject,Codable{
    /// KeyID
    /// Required:true
    var keyId:String
    /// Key名称
    /// Required:true
    var keyName:String
    /// 轮换周期
    var rotationCycle:Int?
    /// Key版本的个数
    /// Required:true
    var keyVersionCount:Int
    /// Key版本详情的列表
    /// Required:true
    var keyVersionList:[KeyVersionItem?]?



    public  init(keyId:String,keyName:String,keyVersionCount:Int,keyVersionList:[KeyVersionItem?]?){
             self.keyId = keyId
             self.keyName = keyName
             self.keyVersionCount = keyVersionCount
             self.keyVersionList = keyVersionList
    }

    enum KeyDetailCodingKeys: String, CodingKey {
        case keyId
        case keyName
        case rotationCycle
        case keyVersionCount
        case keyVersionList
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: KeyDetailCodingKeys.self)
        self.keyId = try decoderContainer.decode(String.self, forKey: .keyId)
        self.keyName = try decoderContainer.decode(String.self, forKey: .keyName)
        if decoderContainer.contains(.rotationCycle)
        {
            self.rotationCycle = try decoderContainer.decode(Int?.self, forKey: .rotationCycle)
        }
        self.keyVersionCount = try decoderContainer.decode(Int.self, forKey: .keyVersionCount)
        self.keyVersionList = try decoderContainer.decode([KeyVersionItem?]?.self, forKey: .keyVersionList)
    }
}
public extension KeyDetail{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: KeyDetailCodingKeys.self)
         try encoderContainer.encode(keyId, forKey: .keyId)
         try encoderContainer.encode(keyName, forKey: .keyName)
         try encoderContainer.encode(rotationCycle, forKey: .rotationCycle)
         try encoderContainer.encode(keyVersionCount, forKey: .keyVersionCount)
         try encoderContainer.encode(keyVersionList, forKey: .keyVersionList)
    }
}
///  keyRotateCfg
public class KeyRotateCfg:NSObject,Codable{
    /// 是否自动轮换，默认为false
    /// Required:true
    var autoRotate:Bool
    /// 自动轮换周期，单位为（天），默认为0（永不轮换）
    /// Required:true
    var rotationCycle:Int



    public  init(autoRotate:Bool,rotationCycle:Int){
             self.autoRotate = autoRotate
             self.rotationCycle = rotationCycle
    }

    enum KeyRotateCfgCodingKeys: String, CodingKey {
        case autoRotate
        case rotationCycle
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: KeyRotateCfgCodingKeys.self)
        self.autoRotate = try decoderContainer.decode(Bool.self, forKey: .autoRotate)
        self.rotationCycle = try decoderContainer.decode(Int.self, forKey: .rotationCycle)
    }
}
public extension KeyRotateCfg{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: KeyRotateCfgCodingKeys.self)
         try encoderContainer.encode(autoRotate, forKey: .autoRotate)
         try encoderContainer.encode(rotationCycle, forKey: .rotationCycle)
    }
}
///  keyDescCfg
public class KeyDescCfg:NSObject,Codable{
    /// key名称，默认为&quot;&quot;
    /// Required:true
    var keyName:String
    /// key描述，默认为&quot;&quot;
    /// Required:true
    var keyDesc:String
    /// 密钥类型： 1: rsa-2048, 0: aes-256，default: aes-256
    var keyType:Int?



    public  init(keyName:String,keyDesc:String){
             self.keyName = keyName
             self.keyDesc = keyDesc
    }

    enum KeyDescCfgCodingKeys: String, CodingKey {
        case keyName
        case keyDesc
        case keyType
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: KeyDescCfgCodingKeys.self)
        self.keyName = try decoderContainer.decode(String.self, forKey: .keyName)
        self.keyDesc = try decoderContainer.decode(String.self, forKey: .keyDesc)
        if decoderContainer.contains(.keyType)
        {
            self.keyType = try decoderContainer.decode(Int?.self, forKey: .keyType)
        }
    }
}
public extension KeyDescCfg{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: KeyDescCfgCodingKeys.self)
         try encoderContainer.encode(keyName, forKey: .keyName)
         try encoderContainer.encode(keyDesc, forKey: .keyDesc)
         try encoderContainer.encode(keyType, forKey: .keyType)
    }
}
///  keyCfg
public class KeyCfg:NSObject,Codable{
    /// 密钥描述配置
    /// Required:true
    var keyDescCfg:KeyDescCfg
    /// 对称密钥的轮换配置；非对称密钥的操作，不支持该配置
    /// Required:true
    var keyRotateCfg:KeyRotateCfg



    public  init(keyDescCfg:KeyDescCfg,keyRotateCfg:KeyRotateCfg){
             self.keyDescCfg = keyDescCfg
             self.keyRotateCfg = keyRotateCfg
    }

    enum KeyCfgCodingKeys: String, CodingKey {
        case keyDescCfg
        case keyRotateCfg
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: KeyCfgCodingKeys.self)
        self.keyDescCfg = try decoderContainer.decode(KeyDescCfg.self, forKey: .keyDescCfg)
        self.keyRotateCfg = try decoderContainer.decode(KeyRotateCfg.self, forKey: .keyRotateCfg)
    }
}
public extension KeyCfg{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: KeyCfgCodingKeys.self)
         try encoderContainer.encode(keyDescCfg, forKey: .keyDescCfg)
         try encoderContainer.encode(keyRotateCfg, forKey: .keyRotateCfg)
    }
}
///  keyVersionItem
public class KeyVersionItem:NSObject,Codable{
    /// 版本号
    /// Required:true
    var keyVersion:String
    /// 创建时间，采用ISO8601标准，格式为: YYYY-MM-DDTHH:mm:ssZ
    /// Required:true
    var createTime:String
    /// Key当前状态: 0:已启用、1:已禁用、2:计划删除
    /// Required:true
    var keyStatus:Int
    /// 计划删除的时间，采用ISO8601标准，格式为: YYYY-MM-DDTHH:mm:ssZ
    /// Required:true
    var deleteTime:String



    public  init(keyVersion:String,createTime:String,keyStatus:Int,deleteTime:String){
             self.keyVersion = keyVersion
             self.createTime = createTime
             self.keyStatus = keyStatus
             self.deleteTime = deleteTime
    }

    enum KeyVersionItemCodingKeys: String, CodingKey {
        case keyVersion
        case createTime
        case keyStatus
        case deleteTime
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: KeyVersionItemCodingKeys.self)
        self.keyVersion = try decoderContainer.decode(String.self, forKey: .keyVersion)
        self.createTime = try decoderContainer.decode(String.self, forKey: .createTime)
        self.keyStatus = try decoderContainer.decode(Int.self, forKey: .keyStatus)
        self.deleteTime = try decoderContainer.decode(String.self, forKey: .deleteTime)
    }
}
public extension KeyVersionItem{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: KeyVersionItemCodingKeys.self)
         try encoderContainer.encode(keyVersion, forKey: .keyVersion)
         try encoderContainer.encode(createTime, forKey: .createTime)
         try encoderContainer.encode(keyStatus, forKey: .keyStatus)
         try encoderContainer.encode(deleteTime, forKey: .deleteTime)
    }
}
///  keyInfo
public class KeyInfo:NSObject,Codable{
    /// KeyID
    /// Required:true
    var keyId:String
    /// Key名称
    /// Required:true
    var keyName:String
    /// Key当前状态: 0:已启用、1:已禁用、2:计划删除
    /// Required:true
    var keyStatus:Int
    /// Key创建时间，采用ISO8601标准，格式为: YYYY-MM-DDTHH:mm:ssZ
    /// Required:true
    var createTime:String
    /// Key的用途
    /// Required:true
    var keyDesc:String
    /// Key的轮换周期，为0则永久不轮换
    /// Required:true
    var rotationCycle:Int
    /// 计划删除的时间，采用ISO8601标准，格式为: YYYY-MM-DDTHH:mm:ssZ
    /// Required:true
    var deleteTime:String



    public  init(keyId:String,keyName:String,keyStatus:Int,createTime:String,keyDesc:String,rotationCycle:Int,deleteTime:String){
             self.keyId = keyId
             self.keyName = keyName
             self.keyStatus = keyStatus
             self.createTime = createTime
             self.keyDesc = keyDesc
             self.rotationCycle = rotationCycle
             self.deleteTime = deleteTime
    }

    enum KeyInfoCodingKeys: String, CodingKey {
        case keyId
        case keyName
        case keyStatus
        case createTime
        case keyDesc
        case rotationCycle
        case deleteTime
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: KeyInfoCodingKeys.self)
        self.keyId = try decoderContainer.decode(String.self, forKey: .keyId)
        self.keyName = try decoderContainer.decode(String.self, forKey: .keyName)
        self.keyStatus = try decoderContainer.decode(Int.self, forKey: .keyStatus)
        self.createTime = try decoderContainer.decode(String.self, forKey: .createTime)
        self.keyDesc = try decoderContainer.decode(String.self, forKey: .keyDesc)
        self.rotationCycle = try decoderContainer.decode(Int.self, forKey: .rotationCycle)
        self.deleteTime = try decoderContainer.decode(String.self, forKey: .deleteTime)
    }
}
public extension KeyInfo{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: KeyInfoCodingKeys.self)
         try encoderContainer.encode(keyId, forKey: .keyId)
         try encoderContainer.encode(keyName, forKey: .keyName)
         try encoderContainer.encode(keyStatus, forKey: .keyStatus)
         try encoderContainer.encode(createTime, forKey: .createTime)
         try encoderContainer.encode(keyDesc, forKey: .keyDesc)
         try encoderContainer.encode(rotationCycle, forKey: .rotationCycle)
         try encoderContainer.encode(deleteTime, forKey: .deleteTime)
    }
}

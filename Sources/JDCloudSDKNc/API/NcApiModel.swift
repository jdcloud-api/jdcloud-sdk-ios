/* Copyright 2018 JDCLOUD.COM

   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at

     http:#www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.

   镜像仓库认证信息
   关于镜像仓库认证信息的相关接口

   OpenAPI spec version: v1
   Contact: 

   NOTE: This class is auto generated by the jdcloud code generator program.
 */


import Foundation
import JDCloudSDKCore
    import JDCloudSDKCommon

/// 查询资源的配额，支持：原生容器 pod 和 secret.
      ///       ///  
public class DescribeQuotaResult:NSObject,JdCloudResult
{
    /// Quota
    var quota:Quota?



    public override init(){
        super.init()
    }

    enum DescribeQuotaResultCodingKeys: String, CodingKey {
        case quota
    }

    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: DescribeQuotaResultCodingKeys.self)
        if decoderContainer.contains(.quota)
        {
            self.quota = try decoderContainer.decode(Quota?.self, forKey: .quota)
        }
    }
}
public extension DescribeQuotaResult{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: DescribeQuotaResultCodingKeys.self)
        try encoderContainer.encode(quota, forKey: .quota)
    }
}
public class DescribeQuotaResponse:NSObject,Codable
{
    var requestId:String?;

    var error:ServiceError?;

    var result:DescribeQuotaResult?;

    enum DescribeQuotaResponseCodingKeys: String, CodingKey {
        case requestId
        case error
        case result
    }

    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: DescribeQuotaResponseCodingKeys.self)
        self.requestId = try decoderContainer.decodeIfPresent(String?.self, forKey: .requestId) ?? nil
        self.error = try decoderContainer.decodeIfPresent(ServiceError?.self, forKey: .error) ?? nil
        self.result = try decoderContainer.decodeIfPresent(DescribeQuotaResult?.self, forKey: .result) ?? nil
    }
}

public extension DescribeQuotaResponse{
        func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: DescribeQuotaResponseCodingKeys.self)
        try encoderContainer.encode(requestId, forKey: .requestId)
        try encoderContainer.encode(error, forKey: .error)
        try encoderContainer.encode(result, forKey: .result)
    }
}    

///  查询资源的配额，支持：原生容器 pod 和 secret.
      ///       /// 
public class DescribeQuotaRequest:JdCloudRequest
{
    /// resourceType - 资源类型，支持 [container, pod, secret]
      /// 
    var resourceType:String


    public init(regionId: String,resourceType:String){
        self.resourceType = resourceType
        super.init(regionId: regionId)
    }


    enum DescribeQuotaRequestRequestCodingKeys: String, CodingKey {
        case resourceType
    }

    public override func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: DescribeQuotaRequestRequestCodingKeys.self)
        try encoderContainer.encode(resourceType, forKey: .resourceType)

    }
}

/// 批量查询原生容器的详细信息&lt;br&gt;
      ///       /// 此接口支持分页查询，默认每页20条。
      ///       ///  
public class DescribeContainersResult:NSObject,JdCloudResult
{
    /// Containers
    var containers:[Container?]?

    /// TotalCount
    var totalCount:Double?



    public override init(){
        super.init()
    }

    enum DescribeContainersResultCodingKeys: String, CodingKey {
        case containers
        case totalCount
    }

    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: DescribeContainersResultCodingKeys.self)
        if decoderContainer.contains(.containers)
        {
            self.containers = try decoderContainer.decode([Container?]?.self, forKey: .containers)
        }
        if decoderContainer.contains(.totalCount)
        {
            self.totalCount = try decoderContainer.decode(Double?.self, forKey: .totalCount)
        }
    }
}
public extension DescribeContainersResult{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: DescribeContainersResultCodingKeys.self)
        try encoderContainer.encode(containers, forKey: .containers)
        try encoderContainer.encode(totalCount, forKey: .totalCount)
    }
}
public class StartContainerResponse:NSObject,Codable
{
    var requestId:String?;

    var error:ServiceError?;

    var result:StartContainerResult?;

    enum StartContainerResponseCodingKeys: String, CodingKey {
        case requestId
        case error
        case result
    }

    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: StartContainerResponseCodingKeys.self)
        self.requestId = try decoderContainer.decodeIfPresent(String?.self, forKey: .requestId) ?? nil
        self.error = try decoderContainer.decodeIfPresent(ServiceError?.self, forKey: .error) ?? nil
        self.result = try decoderContainer.decodeIfPresent(StartContainerResult?.self, forKey: .result) ?? nil
    }
}

public extension StartContainerResponse{
        func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: StartContainerResponseCodingKeys.self)
        try encoderContainer.encode(requestId, forKey: .requestId)
        try encoderContainer.encode(error, forKey: .error)
        try encoderContainer.encode(result, forKey: .result)
    }
}    

///  批量查询原生容器的详细信息&lt;br&gt;
      ///       /// 此接口支持分页查询，默认每页20条。
      ///       /// 
public class DescribeContainersRequest:JdCloudRequest
{
    /// 页码；默认为1
    var pageNumber:Int?

    /// 分页大小；默认为20；取值范围[10, 100]
    var pageSize:Int?

    /// containerId - 实例ID，精确匹配，支持多个
      /// privateIpAddress - 主网卡IP地址，模糊匹配，支持单个
      /// az - 可用区，精确匹配，支持多个
      /// vpcId - 私有网络ID，精确匹配，支持多个
      /// status - 容器状态，精确匹配，支持多个
      /// name - 实例名称，模糊匹配，支持单个
      /// subnetId - 镜像ID，模糊匹配，支持单个
      /// 
    var filters:[Filter?]?




    enum DescribeContainersRequestRequestCodingKeys: String, CodingKey {
        case pageNumber
        case pageSize
        case filters
    }

    public override func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: DescribeContainersRequestRequestCodingKeys.self)
        try encoderContainer.encode(pageNumber, forKey: .pageNumber)
        try encoderContainer.encode(pageSize, forKey: .pageSize)
        try encoderContainer.encode(filters, forKey: .filters)

    }
}

/// 启动处于关闭状态的单个容器，处在任务执行中的容器无法启动。&lt;br&gt;
      ///       /// 容器实例或其绑定的云盘已欠费时，容器将无法正常启动。&lt;br&gt;
      ///       ///  
public class StartContainerResult:NSObject,JdCloudResult
{
}

///  启动处于关闭状态的单个容器，处在任务执行中的容器无法启动。&lt;br&gt;
      ///       /// 容器实例或其绑定的云盘已欠费时，容器将无法正常启动。&lt;br&gt;
      ///       /// 
public class StartContainerRequest:JdCloudRequest
{
    /// Container ID
    var containerId:String


    public init(regionId: String,containerId:String){
        self.containerId = containerId
        super.init(regionId: regionId)
    }


    enum StartContainerRequestRequestCodingKeys: String, CodingKey {
        case containerId
    }

    public override func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: StartContainerRequestRequestCodingKeys.self)
        try encoderContainer.encode(containerId, forKey: .containerId)

    }
}

/// 查询一台原生容器的详细信息
      ///       ///  
public class DescribeContainerResult:NSObject,JdCloudResult
{
    /// Container
    var container:Container?



    public override init(){
        super.init()
    }

    enum DescribeContainerResultCodingKeys: String, CodingKey {
        case container
    }

    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: DescribeContainerResultCodingKeys.self)
        if decoderContainer.contains(.container)
        {
            self.container = try decoderContainer.decode(Container?.self, forKey: .container)
        }
    }
}
public extension DescribeContainerResult{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: DescribeContainerResultCodingKeys.self)
        try encoderContainer.encode(container, forKey: .container)
    }
}
/// 容器状态必须为 stopped、running 或 error状态。 &lt;br&gt;
      ///       /// 按量付费的实例，如不主动删除将一直运行，不再使用的实例，可通过本接口主动停用。&lt;br&gt;
      ///       /// 只能支持主动删除按量计费类型的实例。包年包月过期的容器也可以删除，其它的情况还请发工单系统。计费状态异常的容器无法删除。
      ///       ///  
public class DeleteContainerResult:NSObject,JdCloudResult
{
}
/// 停止处于运行状态的单个实例，处于任务执行中的容器无法启动。
      ///       ///  
public class StopContainerResult:NSObject,JdCloudResult
{
}
public class DeleteContainerResponse:NSObject,Codable
{
    var requestId:String?;

    var error:ServiceError?;

    var result:DeleteContainerResult?;

    enum DeleteContainerResponseCodingKeys: String, CodingKey {
        case requestId
        case error
        case result
    }

    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: DeleteContainerResponseCodingKeys.self)
        self.requestId = try decoderContainer.decodeIfPresent(String?.self, forKey: .requestId) ?? nil
        self.error = try decoderContainer.decodeIfPresent(ServiceError?.self, forKey: .error) ?? nil
        self.result = try decoderContainer.decodeIfPresent(DeleteContainerResult?.self, forKey: .result) ?? nil
    }
}

public extension DeleteContainerResponse{
        func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: DeleteContainerResponseCodingKeys.self)
        try encoderContainer.encode(requestId, forKey: .requestId)
        try encoderContainer.encode(error, forKey: .error)
        try encoderContainer.encode(result, forKey: .result)
    }
}    

///  容器状态必须为 stopped、running 或 error状态。 &lt;br&gt;
      ///       /// 按量付费的实例，如不主动删除将一直运行，不再使用的实例，可通过本接口主动停用。&lt;br&gt;
      ///       /// 只能支持主动删除按量计费类型的实例。包年包月过期的容器也可以删除，其它的情况还请发工单系统。计费状态异常的容器无法删除。
      ///       /// 
public class DeleteContainerRequest:JdCloudRequest
{
    /// Container ID
    var containerId:String


    public init(regionId: String,containerId:String){
        self.containerId = containerId
        super.init(regionId: regionId)
    }


    enum DeleteContainerRequestRequestCodingKeys: String, CodingKey {
        case containerId
    }

    public override func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: DeleteContainerRequestRequestCodingKeys.self)
        try encoderContainer.encode(containerId, forKey: .containerId)

    }
}

/// 容器解绑公网 IP，解绑的是主网卡、主内网 IP 对应的弹性 IP.
      ///       ///  
public class DisassociateElasticIpResult:NSObject,JdCloudResult
{
}
public class DescribeContainerResponse:NSObject,Codable
{
    var requestId:String?;

    var error:ServiceError?;

    var result:DescribeContainerResult?;

    enum DescribeContainerResponseCodingKeys: String, CodingKey {
        case requestId
        case error
        case result
    }

    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: DescribeContainerResponseCodingKeys.self)
        self.requestId = try decoderContainer.decodeIfPresent(String?.self, forKey: .requestId) ?? nil
        self.error = try decoderContainer.decodeIfPresent(ServiceError?.self, forKey: .error) ?? nil
        self.result = try decoderContainer.decodeIfPresent(DescribeContainerResult?.self, forKey: .result) ?? nil
    }
}

public extension DescribeContainerResponse{
        func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: DescribeContainerResponseCodingKeys.self)
        try encoderContainer.encode(requestId, forKey: .requestId)
        try encoderContainer.encode(error, forKey: .error)
        try encoderContainer.encode(result, forKey: .result)
    }
}    
public class StopContainerResponse:NSObject,Codable
{
    var requestId:String?;

    var error:ServiceError?;

    var result:StopContainerResult?;

    enum StopContainerResponseCodingKeys: String, CodingKey {
        case requestId
        case error
        case result
    }

    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: StopContainerResponseCodingKeys.self)
        self.requestId = try decoderContainer.decodeIfPresent(String?.self, forKey: .requestId) ?? nil
        self.error = try decoderContainer.decodeIfPresent(ServiceError?.self, forKey: .error) ?? nil
        self.result = try decoderContainer.decodeIfPresent(StopContainerResult?.self, forKey: .result) ?? nil
    }
}

public extension StopContainerResponse{
        func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: StopContainerResponseCodingKeys.self)
        try encoderContainer.encode(requestId, forKey: .requestId)
        try encoderContainer.encode(error, forKey: .error)
        try encoderContainer.encode(result, forKey: .result)
    }
}    

///  容器绑定弹性公网 IP，绑定的是主网卡、主内网IP对应的弹性IP. &lt;br&gt;
      ///       /// 一台云主机只能绑定一个弹性公网 IP(主网卡)，若主网卡已存在弹性公网IP，会返回错误。&lt;br&gt;
      ///       /// 如果是黑名单中的用户，会返回错误。
      ///       /// 
public class AssociateElasticIpRequest:JdCloudRequest
{
    /// 弹性IP ID
    var elasticIpId:String

    /// Container ID
    var containerId:String


    public init(regionId: String,elasticIpId:String,containerId:String){
        self.elasticIpId = elasticIpId
        self.containerId = containerId
        super.init(regionId: regionId)
    }


    enum AssociateElasticIpRequestRequestCodingKeys: String, CodingKey {
        case elasticIpId
        case containerId
    }

    public override func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: AssociateElasticIpRequestRequestCodingKeys.self)
        try encoderContainer.encode(elasticIpId, forKey: .elasticIpId)
        try encoderContainer.encode(containerId, forKey: .containerId)

    }
}

public class AssociateElasticIpResponse:NSObject,Codable
{
    var requestId:String?;

    var error:ServiceError?;

    var result:AssociateElasticIpResult?;

    enum AssociateElasticIpResponseCodingKeys: String, CodingKey {
        case requestId
        case error
        case result
    }

    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: AssociateElasticIpResponseCodingKeys.self)
        self.requestId = try decoderContainer.decodeIfPresent(String?.self, forKey: .requestId) ?? nil
        self.error = try decoderContainer.decodeIfPresent(ServiceError?.self, forKey: .error) ?? nil
        self.result = try decoderContainer.decodeIfPresent(AssociateElasticIpResult?.self, forKey: .result) ?? nil
    }
}

public extension AssociateElasticIpResponse{
        func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: AssociateElasticIpResponseCodingKeys.self)
        try encoderContainer.encode(requestId, forKey: .requestId)
        try encoderContainer.encode(error, forKey: .error)
        try encoderContainer.encode(result, forKey: .result)
    }
}    
/// 修改容器的 名称 和 描述。
      ///       ///  
public class ModifyContainerAttributeResult:NSObject,JdCloudResult
{
}
/// 容器绑定弹性公网 IP，绑定的是主网卡、主内网IP对应的弹性IP. &lt;br&gt;
      ///       /// 一台云主机只能绑定一个弹性公网 IP(主网卡)，若主网卡已存在弹性公网IP，会返回错误。&lt;br&gt;
      ///       /// 如果是黑名单中的用户，会返回错误。
      ///       ///  
public class AssociateElasticIpResult:NSObject,JdCloudResult
{
}
public class CreateContainersResponse:NSObject,Codable
{
    var requestId:String?;

    var error:ServiceError?;

    var result:CreateContainersResult?;

    enum CreateContainersResponseCodingKeys: String, CodingKey {
        case requestId
        case error
        case result
    }

    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: CreateContainersResponseCodingKeys.self)
        self.requestId = try decoderContainer.decodeIfPresent(String?.self, forKey: .requestId) ?? nil
        self.error = try decoderContainer.decodeIfPresent(ServiceError?.self, forKey: .error) ?? nil
        self.result = try decoderContainer.decodeIfPresent(CreateContainersResult?.self, forKey: .result) ?? nil
    }
}

public extension CreateContainersResponse{
        func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: CreateContainersResponseCodingKeys.self)
        try encoderContainer.encode(requestId, forKey: .requestId)
        try encoderContainer.encode(error, forKey: .error)
        try encoderContainer.encode(result, forKey: .result)
    }
}    

///  查询一台原生容器的详细信息
      ///       /// 
public class DescribeContainerRequest:JdCloudRequest
{
    /// Container ID
    var containerId:String


    public init(regionId: String,containerId:String){
        self.containerId = containerId
        super.init(regionId: regionId)
    }


    enum DescribeContainerRequestRequestCodingKeys: String, CodingKey {
        case containerId
    }

    public override func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: DescribeContainerRequestRequestCodingKeys.self)
        try encoderContainer.encode(containerId, forKey: .containerId)

    }
}

/// 创建一台或多台指定配置容器。
      ///       /// - 创建容器需要通过实名认证
      ///       /// - 镜像
      ///       ///     - 容器的镜像通过镜像名称来确定
      ///       ///     - nginx:tag 或 mysql/mysql-server:tag 这样命名的镜像表示 docker hub 官方镜像
      ///       ///     - container-registry/image:tag 这样命名的镜像表示私有仓储的镜像
      ///       ///     - 私有仓储必须兼容 docker registry 认证机制，并通过 secret 来保存机密信息
      ///       /// - hostname 规范
      ///       ///     - 支持两种方式：以标签方式书写或以完整主机名方式书写
      ///       ///     - 标签规范
      ///       ///         - 0-9，a-z(不分大小写)和 -（减号），其他的都是无效的字符串
      ///       ///         - 不能以减号开始，也不能以减号结尾
      ///       ///         - 最小1个字符，最大63个字符
      ///       ///     - 完整的主机名由一系列标签与点连接组成
      ///       ///         - 标签与标签之间使用“.”(点)进行连接
      ///       ///         - 不能以“.”(点)开始，也不能以“.”(点)结尾
      ///       ///         - 整个主机名（包括标签以及分隔点“.”）最多有63个ASCII字符
      ///       /// - 网络配置
      ///       ///     - 指定主网卡配置信息
      ///       ///         - 必须指定一个子网
      ///       ///         - 一台云主机创建时必须指定一个安全组，至多指定 5 个安全组
      ///       ///         - 可以指定 elasticIp 规格来约束创建的弹性 IP，带宽取值范围 [1-200]Mbps，步进 1Mbps
      ///       ///         - 可以指定网卡的主 IP(primaryIpAddress)，该 IP 需要在子网 IP 范围内且未被占用，指定子网 IP 时 maxCount 只能为1
      ///       ///         - 安全组 securityGroup 需与子网 Subnet 在同一个私有网络 VPC 内
      ///       ///         - 主网卡 deviceIndex 设置为 1
      ///       /// - 存储
      ///       ///     - volume 分为 root volume 和 data volume，root volume 的挂载目录是 /，data volume 的挂载目录可以随意指定
      ///       ///     - volume 的底层存储介质当前只支持 cloud 类别，也就是云硬盘
      ///       ///     - 系统盘
      ///       ///         - 云硬盘类型可以选择 ssd、premium-hdd
      ///       ///         - 磁盘大小
      ///       ///             - ssd：范围 [10, 100]GB，步长为 10G
      ///       ///             - premium-hdd：范围 [20, 1000]GB，步长为 10G
      ///       ///         - 自动删除
      ///       ///             - 云盘默认跟随容器实例自动删除，如果是包年包月的数据盘或共享型数据盘，此参数不生效
      ///       ///         - 可以选择已存在的云硬盘
      ///       ///     - 数据盘
      ///       ///         - 云硬盘类型可以选择 ssd、premium-hdd
      ///       ///         - 磁盘大小
      ///       ///             - ssd：范围[20,1000]GB，步长为10G
      ///       ///             - premium-hdd：范围[20,3000]GB，步长为10G
      ///       ///         - 自动删除
      ///       ///             - 默认自动删除
      ///       ///         - 可以选择已存在的云硬盘
      ///       ///         - 单个容器最多可以挂载 7 个 data volume
      ///       /// - 计费
      ///       ///   - 弹性IP的计费模式，如果选择按用量类型可以单独设置，其它计费模式都以主机为准
      ///       ///   - 云硬盘的计费模式以主机为准
      ///       /// - 容器日志
      ///       ///     - 默认在本地分配10MB的存储空间，自动 rotate
      ///       /// - 其他
      ///       ///     - 创建完成后，容器状态为running
      ///       ///     - maxCount 为最大努力，不保证一定能达到 maxCount
      ///       ///  
public class CreateContainersResult:NSObject,JdCloudResult
{
    /// ContainerIds
    var containerIds:[String?]?



    public override init(){
        super.init()
    }

    enum CreateContainersResultCodingKeys: String, CodingKey {
        case containerIds
    }

    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: CreateContainersResultCodingKeys.self)
        if decoderContainer.contains(.containerIds)
        {
            self.containerIds = try decoderContainer.decode([String?]?.self, forKey: .containerIds)
        }
    }
}
public extension CreateContainersResult{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: CreateContainersResultCodingKeys.self)
        try encoderContainer.encode(containerIds, forKey: .containerIds)
    }
}
/// 查询单个容器日志
      ///       ///  
public class GetLogsResult:NSObject,JdCloudResult
{
    /// Logs
    var logs:Logs?



    public override init(){
        super.init()
    }

    enum GetLogsResultCodingKeys: String, CodingKey {
        case logs
    }

    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: GetLogsResultCodingKeys.self)
        if decoderContainer.contains(.logs)
        {
            self.logs = try decoderContainer.decode(Logs?.self, forKey: .logs)
        }
    }
}
public extension GetLogsResult{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: GetLogsResultCodingKeys.self)
        try encoderContainer.encode(logs, forKey: .logs)
    }
}

///  创建一台或多台指定配置容器。
      ///       /// - 创建容器需要通过实名认证
      ///       /// - 镜像
      ///       ///     - 容器的镜像通过镜像名称来确定
      ///       ///     - nginx:tag 或 mysql/mysql-server:tag 这样命名的镜像表示 docker hub 官方镜像
      ///       ///     - container-registry/image:tag 这样命名的镜像表示私有仓储的镜像
      ///       ///     - 私有仓储必须兼容 docker registry 认证机制，并通过 secret 来保存机密信息
      ///       /// - hostname 规范
      ///       ///     - 支持两种方式：以标签方式书写或以完整主机名方式书写
      ///       ///     - 标签规范
      ///       ///         - 0-9，a-z(不分大小写)和 -（减号），其他的都是无效的字符串
      ///       ///         - 不能以减号开始，也不能以减号结尾
      ///       ///         - 最小1个字符，最大63个字符
      ///       ///     - 完整的主机名由一系列标签与点连接组成
      ///       ///         - 标签与标签之间使用“.”(点)进行连接
      ///       ///         - 不能以“.”(点)开始，也不能以“.”(点)结尾
      ///       ///         - 整个主机名（包括标签以及分隔点“.”）最多有63个ASCII字符
      ///       /// - 网络配置
      ///       ///     - 指定主网卡配置信息
      ///       ///         - 必须指定一个子网
      ///       ///         - 一台云主机创建时必须指定一个安全组，至多指定 5 个安全组
      ///       ///         - 可以指定 elasticIp 规格来约束创建的弹性 IP，带宽取值范围 [1-200]Mbps，步进 1Mbps
      ///       ///         - 可以指定网卡的主 IP(primaryIpAddress)，该 IP 需要在子网 IP 范围内且未被占用，指定子网 IP 时 maxCount 只能为1
      ///       ///         - 安全组 securityGroup 需与子网 Subnet 在同一个私有网络 VPC 内
      ///       ///         - 主网卡 deviceIndex 设置为 1
      ///       /// - 存储
      ///       ///     - volume 分为 root volume 和 data volume，root volume 的挂载目录是 /，data volume 的挂载目录可以随意指定
      ///       ///     - volume 的底层存储介质当前只支持 cloud 类别，也就是云硬盘
      ///       ///     - 系统盘
      ///       ///         - 云硬盘类型可以选择 ssd、premium-hdd
      ///       ///         - 磁盘大小
      ///       ///             - ssd：范围 [10, 100]GB，步长为 10G
      ///       ///             - premium-hdd：范围 [20, 1000]GB，步长为 10G
      ///       ///         - 自动删除
      ///       ///             - 云盘默认跟随容器实例自动删除，如果是包年包月的数据盘或共享型数据盘，此参数不生效
      ///       ///         - 可以选择已存在的云硬盘
      ///       ///     - 数据盘
      ///       ///         - 云硬盘类型可以选择 ssd、premium-hdd
      ///       ///         - 磁盘大小
      ///       ///             - ssd：范围[20,1000]GB，步长为10G
      ///       ///             - premium-hdd：范围[20,3000]GB，步长为10G
      ///       ///         - 自动删除
      ///       ///             - 默认自动删除
      ///       ///         - 可以选择已存在的云硬盘
      ///       ///         - 单个容器最多可以挂载 7 个 data volume
      ///       /// - 计费
      ///       ///   - 弹性IP的计费模式，如果选择按用量类型可以单独设置，其它计费模式都以主机为准
      ///       ///   - 云硬盘的计费模式以主机为准
      ///       /// - 容器日志
      ///       ///     - 默认在本地分配10MB的存储空间，自动 rotate
      ///       /// - 其他
      ///       ///     - 创建完成后，容器状态为running
      ///       ///     - maxCount 为最大努力，不保证一定能达到 maxCount
      ///       /// 
public class CreateContainersRequest:JdCloudRequest
{
    /// 创建容器规格
    var containerSpec:ContainerSpec?

    /// 购买实例数量；取值范围：[1,100]
    var maxCount:Int?




    enum CreateContainersRequestRequestCodingKeys: String, CodingKey {
        case containerSpec
        case maxCount
    }

    public override func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: CreateContainersRequestRequestCodingKeys.self)
        try encoderContainer.encode(containerSpec, forKey: .containerSpec)
        try encoderContainer.encode(maxCount, forKey: .maxCount)

    }
}


///  容器解绑公网 IP，解绑的是主网卡、主内网 IP 对应的弹性 IP.
      ///       /// 
public class DisassociateElasticIpRequest:JdCloudRequest
{
    /// 弹性IP ID
    var elasticIpId:String

    /// Container ID
    var containerId:String


    public init(regionId: String,elasticIpId:String,containerId:String){
        self.elasticIpId = elasticIpId
        self.containerId = containerId
        super.init(regionId: regionId)
    }


    enum DisassociateElasticIpRequestRequestCodingKeys: String, CodingKey {
        case elasticIpId
        case containerId
    }

    public override func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: DisassociateElasticIpRequestRequestCodingKeys.self)
        try encoderContainer.encode(elasticIpId, forKey: .elasticIpId)
        try encoderContainer.encode(containerId, forKey: .containerId)

    }
}

public class GetLogsResponse:NSObject,Codable
{
    var requestId:String?;

    var error:ServiceError?;

    var result:GetLogsResult?;

    enum GetLogsResponseCodingKeys: String, CodingKey {
        case requestId
        case error
        case result
    }

    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: GetLogsResponseCodingKeys.self)
        self.requestId = try decoderContainer.decodeIfPresent(String?.self, forKey: .requestId) ?? nil
        self.error = try decoderContainer.decodeIfPresent(ServiceError?.self, forKey: .error) ?? nil
        self.result = try decoderContainer.decodeIfPresent(GetLogsResult?.self, forKey: .result) ?? nil
    }
}

public extension GetLogsResponse{
        func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: GetLogsResponseCodingKeys.self)
        try encoderContainer.encode(requestId, forKey: .requestId)
        try encoderContainer.encode(error, forKey: .error)
        try encoderContainer.encode(result, forKey: .result)
    }
}    

///  修改容器的 名称 和 描述。
      ///       /// 
public class ModifyContainerAttributeRequest:JdCloudRequest
{
    /// 容器名称
    var name:String?

    /// 容器描述；和description必须要指定一个
    var descriptionValue:String?

    /// Container ID
    var containerId:String


    public init(regionId: String,containerId:String){
        self.containerId = containerId
        super.init(regionId: regionId)
    }


    enum ModifyContainerAttributeRequestRequestCodingKeys: String, CodingKey {
        case name
        case descriptionValue = "description"
        case containerId
    }

    public override func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: ModifyContainerAttributeRequestRequestCodingKeys.self)
        try encoderContainer.encode(name, forKey: .name)
        try encoderContainer.encode(descriptionValue, forKey: .descriptionValue)
        try encoderContainer.encode(containerId, forKey: .containerId)

    }
}

public class ModifyContainerAttributeResponse:NSObject,Codable
{
    var requestId:String?;

    var error:ServiceError?;

    var result:ModifyContainerAttributeResult?;

    enum ModifyContainerAttributeResponseCodingKeys: String, CodingKey {
        case requestId
        case error
        case result
    }

    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: ModifyContainerAttributeResponseCodingKeys.self)
        self.requestId = try decoderContainer.decodeIfPresent(String?.self, forKey: .requestId) ?? nil
        self.error = try decoderContainer.decodeIfPresent(ServiceError?.self, forKey: .error) ?? nil
        self.result = try decoderContainer.decodeIfPresent(ModifyContainerAttributeResult?.self, forKey: .result) ?? nil
    }
}

public extension ModifyContainerAttributeResponse{
        func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: ModifyContainerAttributeResponseCodingKeys.self)
        try encoderContainer.encode(requestId, forKey: .requestId)
        try encoderContainer.encode(error, forKey: .error)
        try encoderContainer.encode(result, forKey: .result)
    }
}    
public class DisassociateElasticIpResponse:NSObject,Codable
{
    var requestId:String?;

    var error:ServiceError?;

    var result:DisassociateElasticIpResult?;

    enum DisassociateElasticIpResponseCodingKeys: String, CodingKey {
        case requestId
        case error
        case result
    }

    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: DisassociateElasticIpResponseCodingKeys.self)
        self.requestId = try decoderContainer.decodeIfPresent(String?.self, forKey: .requestId) ?? nil
        self.error = try decoderContainer.decodeIfPresent(ServiceError?.self, forKey: .error) ?? nil
        self.result = try decoderContainer.decodeIfPresent(DisassociateElasticIpResult?.self, forKey: .result) ?? nil
    }
}

public extension DisassociateElasticIpResponse{
        func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: DisassociateElasticIpResponseCodingKeys.self)
        try encoderContainer.encode(requestId, forKey: .requestId)
        try encoderContainer.encode(error, forKey: .error)
        try encoderContainer.encode(result, forKey: .result)
    }
}    

///  查询单个容器日志
      ///       /// 
public class GetLogsRequest:JdCloudRequest
{
    /// 返回日志文件中倒数 tailLines 行，如不指定，默认从容器启动时或 sinceSeconds 指定的时间读取。
      /// 
    var tailLines:Int?

    /// 返回相对于当前时间之前sinceSeconds之内的日志。
      /// 
    var sinceSeconds:Int?

    /// 限制返回的日志文件内容字节数，取值范围 [1-4]KB，最大 4KB.
      /// 
    var limitBytes:Int?

    /// Container ID
    var containerId:String


    public init(regionId: String,containerId:String){
        self.containerId = containerId
        super.init(regionId: regionId)
    }


    enum GetLogsRequestRequestCodingKeys: String, CodingKey {
        case tailLines
        case sinceSeconds
        case limitBytes
        case containerId
    }

    public override func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: GetLogsRequestRequestCodingKeys.self)
        try encoderContainer.encode(tailLines, forKey: .tailLines)
        try encoderContainer.encode(sinceSeconds, forKey: .sinceSeconds)
        try encoderContainer.encode(limitBytes, forKey: .limitBytes)
        try encoderContainer.encode(containerId, forKey: .containerId)

    }
}

public class DescribeContainersResponse:NSObject,Codable
{
    var requestId:String?;

    var error:ServiceError?;

    var result:DescribeContainersResult?;

    enum DescribeContainersResponseCodingKeys: String, CodingKey {
        case requestId
        case error
        case result
    }

    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: DescribeContainersResponseCodingKeys.self)
        self.requestId = try decoderContainer.decodeIfPresent(String?.self, forKey: .requestId) ?? nil
        self.error = try decoderContainer.decodeIfPresent(ServiceError?.self, forKey: .error) ?? nil
        self.result = try decoderContainer.decodeIfPresent(DescribeContainersResult?.self, forKey: .result) ?? nil
    }
}

public extension DescribeContainersResponse{
        func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: DescribeContainersResponseCodingKeys.self)
        try encoderContainer.encode(requestId, forKey: .requestId)
        try encoderContainer.encode(error, forKey: .error)
        try encoderContainer.encode(result, forKey: .result)
    }
}    

///  停止处于运行状态的单个实例，处于任务执行中的容器无法启动。
      ///       /// 
public class StopContainerRequest:JdCloudRequest
{
    /// Container ID
    var containerId:String


    public init(regionId: String,containerId:String){
        self.containerId = containerId
        super.init(regionId: regionId)
    }


    enum StopContainerRequestRequestCodingKeys: String, CodingKey {
        case containerId
    }

    public override func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: StopContainerRequestRequestCodingKeys.self)
        try encoderContainer.encode(containerId, forKey: .containerId)

    }
}


///  创建一个 secret，用于存放镜像仓库机密相关信息。
      ///       /// 
public class CreateSecretRequest:JdCloudRequest
{
    /// 机密数据名称，不能重复
      /// 
    var name:String

    /// 机密数据的类型，目前仅支持：docker-registry 类型，用来和docker registry认证的类型。
      /// 
    var secretType:String

    /// 机密的数据。&lt;br&gt;
      /// key 的有效字符包括字母、数字、-、_和.； &lt;br&gt;
      /// value 是 Base64 编码的字符串，不能包含换行符（在 linux 下使用 base64 -w 0选项），每个value长度上限为4KB，整个data的长度不能超过256KB; &lt;br&gt;
      /// 必须包含server、username、password 字段，email 字段是可选的。&lt;br&gt;
      /// 
    var data:DockerRegistryData?


    public init(regionId: String,name:String,secretType:String){
        self.name = name
        self.secretType = secretType
        super.init(regionId: regionId)
    }


    enum CreateSecretRequestRequestCodingKeys: String, CodingKey {
        case name
        case secretType
        case data
    }

    public override func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: CreateSecretRequestRequestCodingKeys.self)
        try encoderContainer.encode(name, forKey: .name)
        try encoderContainer.encode(secretType, forKey: .secretType)
        try encoderContainer.encode(data, forKey: .data)

    }
}

public class DescribeSecretsResponse:NSObject,Codable
{
    var requestId:String?;

    var error:ServiceError?;

    var result:DescribeSecretsResult?;

    enum DescribeSecretsResponseCodingKeys: String, CodingKey {
        case requestId
        case error
        case result
    }

    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: DescribeSecretsResponseCodingKeys.self)
        self.requestId = try decoderContainer.decodeIfPresent(String?.self, forKey: .requestId) ?? nil
        self.error = try decoderContainer.decodeIfPresent(ServiceError?.self, forKey: .error) ?? nil
        self.result = try decoderContainer.decodeIfPresent(DescribeSecretsResult?.self, forKey: .result) ?? nil
    }
}

public extension DescribeSecretsResponse{
        func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: DescribeSecretsResponseCodingKeys.self)
        try encoderContainer.encode(requestId, forKey: .requestId)
        try encoderContainer.encode(error, forKey: .error)
        try encoderContainer.encode(result, forKey: .result)
    }
}    
public class DeleteSecretResponse:NSObject,Codable
{
    var requestId:String?;

    var error:ServiceError?;

    var result:DeleteSecretResult?;

    enum DeleteSecretResponseCodingKeys: String, CodingKey {
        case requestId
        case error
        case result
    }

    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: DeleteSecretResponseCodingKeys.self)
        self.requestId = try decoderContainer.decodeIfPresent(String?.self, forKey: .requestId) ?? nil
        self.error = try decoderContainer.decodeIfPresent(ServiceError?.self, forKey: .error) ?? nil
        self.result = try decoderContainer.decodeIfPresent(DeleteSecretResult?.self, forKey: .result) ?? nil
    }
}

public extension DeleteSecretResponse{
        func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: DeleteSecretResponseCodingKeys.self)
        try encoderContainer.encode(requestId, forKey: .requestId)
        try encoderContainer.encode(error, forKey: .error)
        try encoderContainer.encode(result, forKey: .result)
    }
}    

///  删除单个 secret
      ///       /// 
public class DeleteSecretRequest:JdCloudRequest
{
    /// Secret Name
    var name:String


    public init(regionId: String,name:String){
        self.name = name
        super.init(regionId: regionId)
    }


    enum DeleteSecretRequestRequestCodingKeys: String, CodingKey {
        case name
    }

    public override func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: DeleteSecretRequestRequestCodingKeys.self)
        try encoderContainer.encode(name, forKey: .name)

    }
}

/// 创建一个 secret，用于存放镜像仓库机密相关信息。
      ///       ///  
public class CreateSecretResult:NSObject,JdCloudResult
{
    /// SecretName
    var secretName:String?



    public override init(){
        super.init()
    }

    enum CreateSecretResultCodingKeys: String, CodingKey {
        case secretName
    }

    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: CreateSecretResultCodingKeys.self)
        if decoderContainer.contains(.secretName)
        {
            self.secretName = try decoderContainer.decode(String?.self, forKey: .secretName)
        }
    }
}
public extension CreateSecretResult{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: CreateSecretResultCodingKeys.self)
        try encoderContainer.encode(secretName, forKey: .secretName)
    }
}

///  查询单个 secret 详情
      ///       /// 
public class DescribeSecretRequest:JdCloudRequest
{
    /// Secret Name
    var name:String


    public init(regionId: String,name:String){
        self.name = name
        super.init(regionId: regionId)
    }


    enum DescribeSecretRequestRequestCodingKeys: String, CodingKey {
        case name
    }

    public override func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: DescribeSecretRequestRequestCodingKeys.self)
        try encoderContainer.encode(name, forKey: .name)

    }
}

/// 查询 secret 列表。&lt;br&gt; 
      ///       /// 此接口支持分页查询，默认每页20条。
      ///       ///  
public class DescribeSecretsResult:NSObject,JdCloudResult
{
    /// Secrets
    var secrets:[Secret?]?

    /// TotalCount
    var totalCount:Double?



    public override init(){
        super.init()
    }

    enum DescribeSecretsResultCodingKeys: String, CodingKey {
        case secrets
        case totalCount
    }

    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: DescribeSecretsResultCodingKeys.self)
        if decoderContainer.contains(.secrets)
        {
            self.secrets = try decoderContainer.decode([Secret?]?.self, forKey: .secrets)
        }
        if decoderContainer.contains(.totalCount)
        {
            self.totalCount = try decoderContainer.decode(Double?.self, forKey: .totalCount)
        }
    }
}
public extension DescribeSecretsResult{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: DescribeSecretsResultCodingKeys.self)
        try encoderContainer.encode(secrets, forKey: .secrets)
        try encoderContainer.encode(totalCount, forKey: .totalCount)
    }
}
public class CreateSecretResponse:NSObject,Codable
{
    var requestId:String?;

    var error:ServiceError?;

    var result:CreateSecretResult?;

    enum CreateSecretResponseCodingKeys: String, CodingKey {
        case requestId
        case error
        case result
    }

    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: CreateSecretResponseCodingKeys.self)
        self.requestId = try decoderContainer.decodeIfPresent(String?.self, forKey: .requestId) ?? nil
        self.error = try decoderContainer.decodeIfPresent(ServiceError?.self, forKey: .error) ?? nil
        self.result = try decoderContainer.decodeIfPresent(CreateSecretResult?.self, forKey: .result) ?? nil
    }
}

public extension CreateSecretResponse{
        func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: CreateSecretResponseCodingKeys.self)
        try encoderContainer.encode(requestId, forKey: .requestId)
        try encoderContainer.encode(error, forKey: .error)
        try encoderContainer.encode(result, forKey: .result)
    }
}    
/// 查询单个 secret 详情
      ///       ///  
public class DescribeSecretResult:NSObject,JdCloudResult
{
    /// Secret
    var secret:Secret?



    public override init(){
        super.init()
    }

    enum DescribeSecretResultCodingKeys: String, CodingKey {
        case secret
    }

    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: DescribeSecretResultCodingKeys.self)
        if decoderContainer.contains(.secret)
        {
            self.secret = try decoderContainer.decode(Secret?.self, forKey: .secret)
        }
    }
}
public extension DescribeSecretResult{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: DescribeSecretResultCodingKeys.self)
        try encoderContainer.encode(secret, forKey: .secret)
    }
}
/// 删除单个 secret
      ///       ///  
public class DeleteSecretResult:NSObject,JdCloudResult
{
}

///  查询 secret 列表。&lt;br&gt; 
      ///       /// 此接口支持分页查询，默认每页20条。
      ///       /// 
public class DescribeSecretsRequest:JdCloudRequest
{
    /// 页码；默认为1
    var pageNumber:Int?

    /// 分页大小；默认为20；取值范围[10, 100]
    var pageSize:Int?

    /// name - secret名称，支持模糊搜索
      /// 
    var filters:[Filter?]?




    enum DescribeSecretsRequestRequestCodingKeys: String, CodingKey {
        case pageNumber
        case pageSize
        case filters
    }

    public override func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: DescribeSecretsRequestRequestCodingKeys.self)
        try encoderContainer.encode(pageNumber, forKey: .pageNumber)
        try encoderContainer.encode(pageSize, forKey: .pageSize)
        try encoderContainer.encode(filters, forKey: .filters)

    }
}

public class DescribeSecretResponse:NSObject,Codable
{
    var requestId:String?;

    var error:ServiceError?;

    var result:DescribeSecretResult?;

    enum DescribeSecretResponseCodingKeys: String, CodingKey {
        case requestId
        case error
        case result
    }

    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: DescribeSecretResponseCodingKeys.self)
        self.requestId = try decoderContainer.decodeIfPresent(String?.self, forKey: .requestId) ?? nil
        self.error = try decoderContainer.decodeIfPresent(ServiceError?.self, forKey: .error) ?? nil
        self.result = try decoderContainer.decodeIfPresent(DescribeSecretResult?.self, forKey: .result) ?? nil
    }
}

public extension DescribeSecretResponse{
        func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: DescribeSecretResponseCodingKeys.self)
        try encoderContainer.encode(requestId, forKey: .requestId)
        try encoderContainer.encode(error, forKey: .error)
        try encoderContainer.encode(result, forKey: .result)
    }
}    

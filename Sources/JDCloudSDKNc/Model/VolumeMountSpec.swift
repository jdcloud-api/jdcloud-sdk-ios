/* Copyright 2018 JDCLOUD.COM

   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at

     http:#www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.

   
   

   
   Contact: 

   NOTE: This class is auto generated by the jdcloud code generator program.
 */


import Foundation
import JDCloudSDKDisk

///  磁盘分类  cloud： 基于云硬盘的卷  root volume只能是cloud类型
@objc(VolumeMountSpec)
public class VolumeMountSpec:NSObject,Codable{
    /// 磁盘分类 cloud： 基于云硬盘的卷 root volume只能是cloud类型
    /// Required:true
    var category:String
    /// 自动删除，删除容器时自动删除此volume，默认为True；只支持磁盘是云硬盘的场景
    var autoDelete:Bool?
    /// 容器内的挂载目录；root volume不需要指定，挂载目录是（/）；data volume必须指定；必须是绝对路径，不能包含(:)
    var mountPath:String?
    /// 只读，默认false；只针对data volume有效；root volume为false，也就是可读可写
    var readOnly:Bool?
    /// 云硬盘规格；随容器自动创建的云硬盘，不会对磁盘分区，只会格式化文件系统
    var cloudDiskSpec:DiskSpec?
    /// 云硬盘ID；如果使用已有的云硬盘，必须指定partion和fsType
    var cloudDiskId:String?
    /// 指定volume文件系统类型，目前支持[xfs, ext4]；如果新创建的盘，不指定文件系统类型默认格式化成xfs
    var fsType:String?
    /// 随容器自动创建的新盘，会自动格式化成指定的文件系统类型；挂载已有的盘，默认不会格式化，只会按照指定的fsType去挂载；如果希望格式化，必须设置此字段为true
    var formatVolume:Bool?



    public  init(category:String){
             self.category = category
    }

    enum VolumeMountSpecCodingKeys: String, CodingKey {
        case category
        case autoDelete
        case mountPath
        case readOnly
        case cloudDiskSpec
        case cloudDiskId
        case fsType
        case formatVolume
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: VolumeMountSpecCodingKeys.self)
        self.category = try decoderContainer.decode(String.self, forKey: .category)
        if decoderContainer.contains(.autoDelete)
        {
            self.autoDelete = try decoderContainer.decode(Bool?.self, forKey: .autoDelete)
        }
        if decoderContainer.contains(.mountPath)
        {
            self.mountPath = try decoderContainer.decode(String?.self, forKey: .mountPath)
        }
        if decoderContainer.contains(.readOnly)
        {
            self.readOnly = try decoderContainer.decode(Bool?.self, forKey: .readOnly)
        }
        if decoderContainer.contains(.cloudDiskSpec)
        {
            self.cloudDiskSpec = try decoderContainer.decode(DiskSpec?.self, forKey: .cloudDiskSpec)
        }
        if decoderContainer.contains(.cloudDiskId)
        {
            self.cloudDiskId = try decoderContainer.decode(String?.self, forKey: .cloudDiskId)
        }
        if decoderContainer.contains(.fsType)
        {
            self.fsType = try decoderContainer.decode(String?.self, forKey: .fsType)
        }
        if decoderContainer.contains(.formatVolume)
        {
            self.formatVolume = try decoderContainer.decode(Bool?.self, forKey: .formatVolume)
        }
    }
}
public extension VolumeMountSpec{
    public func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: VolumeMountSpecCodingKeys.self)
         try encoderContainer.encode(category, forKey: .category)
         try encoderContainer.encode(autoDelete, forKey: .autoDelete)
         try encoderContainer.encode(mountPath, forKey: .mountPath)
         try encoderContainer.encode(readOnly, forKey: .readOnly)
         try encoderContainer.encode(cloudDiskSpec, forKey: .cloudDiskSpec)
         try encoderContainer.encode(cloudDiskId, forKey: .cloudDiskId)
         try encoderContainer.encode(fsType, forKey: .fsType)
         try encoderContainer.encode(formatVolume, forKey: .formatVolume)
    }
}

/* Copyright 2018 JDCLOUD.COM

   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at

     http:#www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.

   Send-Message-Related-APIs
   短信发送相关API

   OpenAPI spec version: v1
   Contact: 

   NOTE: This class is auto generated by the jdcloud code generator program.
 */


import Foundation
///  replyResp
public class ReplyResp:NSObject,Codable{
    /// 应用Id
    var appId:String?
    /// 签名Id
    var signId:String?
    /// 手机号
    var phoneNum:String?
    /// 回复时间（yyyy-MM-dd HH:mm:ss)
    var dataTime:String?
    /// 回复内容
    var content:String?



    public override init(){
            super.init()
    }

    enum ReplyRespCodingKeys: String, CodingKey {
        case appId
        case signId
        case phoneNum
        case dataTime
        case content
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: ReplyRespCodingKeys.self)
        if decoderContainer.contains(.appId)
        {
            self.appId = try decoderContainer.decode(String?.self, forKey: .appId)
        }
        if decoderContainer.contains(.signId)
        {
            self.signId = try decoderContainer.decode(String?.self, forKey: .signId)
        }
        if decoderContainer.contains(.phoneNum)
        {
            self.phoneNum = try decoderContainer.decode(String?.self, forKey: .phoneNum)
        }
        if decoderContainer.contains(.dataTime)
        {
            self.dataTime = try decoderContainer.decode(String?.self, forKey: .dataTime)
        }
        if decoderContainer.contains(.content)
        {
            self.content = try decoderContainer.decode(String?.self, forKey: .content)
        }
    }
}
public extension ReplyResp{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: ReplyRespCodingKeys.self)
         try encoderContainer.encode(appId, forKey: .appId)
         try encoderContainer.encode(signId, forKey: .signId)
         try encoderContainer.encode(phoneNum, forKey: .phoneNum)
         try encoderContainer.encode(dataTime, forKey: .dataTime)
         try encoderContainer.encode(content, forKey: .content)
    }
}
///  batchSendResp
public class BatchSendResp:NSObject,Codable{
    /// 本次发送请求的序列号
    var sequenceNumber:String?



    public override init(){
            super.init()
    }

    enum BatchSendRespCodingKeys: String, CodingKey {
        case sequenceNumber
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: BatchSendRespCodingKeys.self)
        if decoderContainer.contains(.sequenceNumber)
        {
            self.sequenceNumber = try decoderContainer.decode(String?.self, forKey: .sequenceNumber)
        }
    }
}
public extension BatchSendResp{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: BatchSendRespCodingKeys.self)
         try encoderContainer.encode(sequenceNumber, forKey: .sequenceNumber)
    }
}
///  statusReportResp
public class StatusReportResp:NSObject,Codable{
    /// 手机号
    var phoneNum:String?
    /// 发送短信的序列号
    var sequenceNumber:String?
    /// 短信发送时间（yyyy-MM-dd HH:mm:ss)
    var sendTime:String?
    /// 接收到回执的时间（yyyy-MM-dd HH:mm:ss)
    var reportTime:String?
    /// 发送状态
    var status:Int?
    /// 错误码
    var code:String?
    /// 长短信拆分序号（短短信直接返回1)
    var splitNum:Int?



    public override init(){
            super.init()
    }

    enum StatusReportRespCodingKeys: String, CodingKey {
        case phoneNum
        case sequenceNumber
        case sendTime
        case reportTime
        case status
        case code
        case splitNum
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: StatusReportRespCodingKeys.self)
        if decoderContainer.contains(.phoneNum)
        {
            self.phoneNum = try decoderContainer.decode(String?.self, forKey: .phoneNum)
        }
        if decoderContainer.contains(.sequenceNumber)
        {
            self.sequenceNumber = try decoderContainer.decode(String?.self, forKey: .sequenceNumber)
        }
        if decoderContainer.contains(.sendTime)
        {
            self.sendTime = try decoderContainer.decode(String?.self, forKey: .sendTime)
        }
        if decoderContainer.contains(.reportTime)
        {
            self.reportTime = try decoderContainer.decode(String?.self, forKey: .reportTime)
        }
        if decoderContainer.contains(.status)
        {
            self.status = try decoderContainer.decode(Int?.self, forKey: .status)
        }
        if decoderContainer.contains(.code)
        {
            self.code = try decoderContainer.decode(String?.self, forKey: .code)
        }
        if decoderContainer.contains(.splitNum)
        {
            self.splitNum = try decoderContainer.decode(Int?.self, forKey: .splitNum)
        }
    }
}
public extension StatusReportResp{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: StatusReportRespCodingKeys.self)
         try encoderContainer.encode(phoneNum, forKey: .phoneNum)
         try encoderContainer.encode(sequenceNumber, forKey: .sequenceNumber)
         try encoderContainer.encode(sendTime, forKey: .sendTime)
         try encoderContainer.encode(reportTime, forKey: .reportTime)
         try encoderContainer.encode(status, forKey: .status)
         try encoderContainer.encode(code, forKey: .code)
         try encoderContainer.encode(splitNum, forKey: .splitNum)
    }
}
///  sendBatchSms
public class SendBatchSms:NSObject,Codable{
    /// 请求状态
    var status:Bool?
    /// 错误码
    var code:String?
    /// 错误消息
    var message:String?



    public override init(){
            super.init()
    }

    enum SendBatchSmsCodingKeys: String, CodingKey {
        case status
        case code
        case message
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: SendBatchSmsCodingKeys.self)
        if decoderContainer.contains(.status)
        {
            self.status = try decoderContainer.decode(Bool?.self, forKey: .status)
        }
        if decoderContainer.contains(.code)
        {
            self.code = try decoderContainer.decode(String?.self, forKey: .code)
        }
        if decoderContainer.contains(.message)
        {
            self.message = try decoderContainer.decode(String?.self, forKey: .message)
        }
    }
}
public extension SendBatchSms{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: SendBatchSmsCodingKeys.self)
         try encoderContainer.encode(status, forKey: .status)
         try encoderContainer.encode(code, forKey: .code)
         try encoderContainer.encode(message, forKey: .message)
    }
}
///  mtSms
public class MtSms:NSObject,Codable{
    /// 用户pin
    var pin:String?
    /// 扩展码
    var expandNum:String?
    /// 手机号
    var mobileNum:String?
    /// 应用ID
    var appId:String?
    /// 套餐包ID
    var packageId:String?
    /// 签名ID
    var signId:String?
    /// 模板ID
    var templateId:String?
    /// 消息内容
    var msgContent:String?
    /// 批次ID
    var orderId:String?
    /// 错误码
    var code:Int?
    /// 流水号
    var receiptNum:String?
    /// 拆分标识
    var splitFlag:String?
    /// 发送状态
    var status:String?
    /// 类型
    var type:String?



    public override init(){
            super.init()
    }

    enum MtSmsCodingKeys: String, CodingKey {
        case pin
        case expandNum
        case mobileNum
        case appId
        case packageId
        case signId
        case templateId
        case msgContent
        case orderId
        case code
        case receiptNum
        case splitFlag
        case status
        case type
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: MtSmsCodingKeys.self)
        if decoderContainer.contains(.pin)
        {
            self.pin = try decoderContainer.decode(String?.self, forKey: .pin)
        }
        if decoderContainer.contains(.expandNum)
        {
            self.expandNum = try decoderContainer.decode(String?.self, forKey: .expandNum)
        }
        if decoderContainer.contains(.mobileNum)
        {
            self.mobileNum = try decoderContainer.decode(String?.self, forKey: .mobileNum)
        }
        if decoderContainer.contains(.appId)
        {
            self.appId = try decoderContainer.decode(String?.self, forKey: .appId)
        }
        if decoderContainer.contains(.packageId)
        {
            self.packageId = try decoderContainer.decode(String?.self, forKey: .packageId)
        }
        if decoderContainer.contains(.signId)
        {
            self.signId = try decoderContainer.decode(String?.self, forKey: .signId)
        }
        if decoderContainer.contains(.templateId)
        {
            self.templateId = try decoderContainer.decode(String?.self, forKey: .templateId)
        }
        if decoderContainer.contains(.msgContent)
        {
            self.msgContent = try decoderContainer.decode(String?.self, forKey: .msgContent)
        }
        if decoderContainer.contains(.orderId)
        {
            self.orderId = try decoderContainer.decode(String?.self, forKey: .orderId)
        }
        if decoderContainer.contains(.code)
        {
            self.code = try decoderContainer.decode(Int?.self, forKey: .code)
        }
        if decoderContainer.contains(.receiptNum)
        {
            self.receiptNum = try decoderContainer.decode(String?.self, forKey: .receiptNum)
        }
        if decoderContainer.contains(.splitFlag)
        {
            self.splitFlag = try decoderContainer.decode(String?.self, forKey: .splitFlag)
        }
        if decoderContainer.contains(.status)
        {
            self.status = try decoderContainer.decode(String?.self, forKey: .status)
        }
        if decoderContainer.contains(.type)
        {
            self.type = try decoderContainer.decode(String?.self, forKey: .type)
        }
    }
}
public extension MtSms{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: MtSmsCodingKeys.self)
         try encoderContainer.encode(pin, forKey: .pin)
         try encoderContainer.encode(expandNum, forKey: .expandNum)
         try encoderContainer.encode(mobileNum, forKey: .mobileNum)
         try encoderContainer.encode(appId, forKey: .appId)
         try encoderContainer.encode(packageId, forKey: .packageId)
         try encoderContainer.encode(signId, forKey: .signId)
         try encoderContainer.encode(templateId, forKey: .templateId)
         try encoderContainer.encode(msgContent, forKey: .msgContent)
         try encoderContainer.encode(orderId, forKey: .orderId)
         try encoderContainer.encode(code, forKey: .code)
         try encoderContainer.encode(receiptNum, forKey: .receiptNum)
         try encoderContainer.encode(splitFlag, forKey: .splitFlag)
         try encoderContainer.encode(status, forKey: .status)
         try encoderContainer.encode(type, forKey: .type)
    }
}
///  pullMtMsgByMobile
public class PullMtMsgByMobile:NSObject,Codable{
    /// 总量
    var total:Int?
    /// 本次拉取的数量
    var size:Int?
    /// 发送信息明细列表
    var detailList:[MtSms?]?



    public override init(){
            super.init()
    }

    enum PullMtMsgByMobileCodingKeys: String, CodingKey {
        case total
        case size
        case detailList
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: PullMtMsgByMobileCodingKeys.self)
        if decoderContainer.contains(.total)
        {
            self.total = try decoderContainer.decode(Int?.self, forKey: .total)
        }
        if decoderContainer.contains(.size)
        {
            self.size = try decoderContainer.decode(Int?.self, forKey: .size)
        }
        if decoderContainer.contains(.detailList)
        {
            self.detailList = try decoderContainer.decode([MtSms?]?.self, forKey: .detailList)
        }
    }
}
public extension PullMtMsgByMobile{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: PullMtMsgByMobileCodingKeys.self)
         try encoderContainer.encode(total, forKey: .total)
         try encoderContainer.encode(size, forKey: .size)
         try encoderContainer.encode(detailList, forKey: .detailList)
    }
}

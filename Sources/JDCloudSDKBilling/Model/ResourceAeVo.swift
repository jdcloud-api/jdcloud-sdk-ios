/* Copyright 2018 JDCLOUD.COM

   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at

     http:#www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.

   
   

   
   Contact: 

   NOTE: This class is auto generated by the jdcloud code generator program.
 */


import Foundation

///  resourceAeVo
@objc(ResourceAeVo)
public class ResourceAeVo:NSObject,Codable{
    /// 自增主键
    var id:Int?
    /// 站点标识1:中国 2:国际
    var site:Int?
    /// 应用编码
    var appCode:String?
    /// 地域
    var region:String?
    /// 服务编码
    var serviceCode:String?
    /// 配置项
    var formula:String?
    /// 用户pin
    var pin:String?
    /// 资源ID
    var resourceId:String?
    /// 计费类型
    var billingType:Int?
    /// 账单ID
    var subBillId:Int?
    /// 状态 0:无 1:正常 2:欠费, 3:因欠费而停机, 4:欠费删除资源, 6:已删除但已不欠费, 7:欠费延期，8:删除并且欠费，9:欠费删除数据，12:已过期, 13:因过期而停机, 14:过期删除资源, 17:过期延期 19:过期删除数据23:管理员停服，24:管理员删除,34:用户删除,35:退款删除
    var state:Int?
    /// 首次欠费时间（各欠费状态）或过期时间（各过期状态）
    var stateTime:String?
    /// 变成此状态的原因.0:无 1:账单欠费, 2:资源过期 ,3:加入、移出白名单 ,4:补扣款成功, 5:规则修改,6:续费 7:管理员操作,8:用户操作
    var op:Int?
    /// 是否为最后状态记录
    var isLastRecord:Int?
    /// 本条记录生成时刻、进入当前state的时刻
    var createTime:String?
    /// 修改时间
    var updateTime:String?
    /// 资源预计释放时间
    var toDeleteTime:String?
    /// CapState
    var capState:Int?



    public override init(){
            super.init()
    }

    enum ResourceAeVoCodingKeys: String, CodingKey {
        case id
        case site
        case appCode
        case region
        case serviceCode
        case formula
        case pin
        case resourceId
        case billingType
        case subBillId
        case state
        case stateTime
        case op
        case isLastRecord
        case createTime
        case updateTime
        case toDeleteTime
        case capState
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: ResourceAeVoCodingKeys.self)
        if decoderContainer.contains(.id)
        {
            self.id = try decoderContainer.decode(Int?.self, forKey: .id)
        }
        if decoderContainer.contains(.site)
        {
            self.site = try decoderContainer.decode(Int?.self, forKey: .site)
        }
        if decoderContainer.contains(.appCode)
        {
            self.appCode = try decoderContainer.decode(String?.self, forKey: .appCode)
        }
        if decoderContainer.contains(.region)
        {
            self.region = try decoderContainer.decode(String?.self, forKey: .region)
        }
        if decoderContainer.contains(.serviceCode)
        {
            self.serviceCode = try decoderContainer.decode(String?.self, forKey: .serviceCode)
        }
        if decoderContainer.contains(.formula)
        {
            self.formula = try decoderContainer.decode(String?.self, forKey: .formula)
        }
        if decoderContainer.contains(.pin)
        {
            self.pin = try decoderContainer.decode(String?.self, forKey: .pin)
        }
        if decoderContainer.contains(.resourceId)
        {
            self.resourceId = try decoderContainer.decode(String?.self, forKey: .resourceId)
        }
        if decoderContainer.contains(.billingType)
        {
            self.billingType = try decoderContainer.decode(Int?.self, forKey: .billingType)
        }
        if decoderContainer.contains(.subBillId)
        {
            self.subBillId = try decoderContainer.decode(Int?.self, forKey: .subBillId)
        }
        if decoderContainer.contains(.state)
        {
            self.state = try decoderContainer.decode(Int?.self, forKey: .state)
        }
        if decoderContainer.contains(.stateTime)
        {
            self.stateTime = try decoderContainer.decode(String?.self, forKey: .stateTime)
        }
        if decoderContainer.contains(.op)
        {
            self.op = try decoderContainer.decode(Int?.self, forKey: .op)
        }
        if decoderContainer.contains(.isLastRecord)
        {
            self.isLastRecord = try decoderContainer.decode(Int?.self, forKey: .isLastRecord)
        }
        if decoderContainer.contains(.createTime)
        {
            self.createTime = try decoderContainer.decode(String?.self, forKey: .createTime)
        }
        if decoderContainer.contains(.updateTime)
        {
            self.updateTime = try decoderContainer.decode(String?.self, forKey: .updateTime)
        }
        if decoderContainer.contains(.toDeleteTime)
        {
            self.toDeleteTime = try decoderContainer.decode(String?.self, forKey: .toDeleteTime)
        }
        if decoderContainer.contains(.capState)
        {
            self.capState = try decoderContainer.decode(Int?.self, forKey: .capState)
        }
    }
}
public extension ResourceAeVo{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: ResourceAeVoCodingKeys.self)
         try encoderContainer.encode(id, forKey: .id)
         try encoderContainer.encode(site, forKey: .site)
         try encoderContainer.encode(appCode, forKey: .appCode)
         try encoderContainer.encode(region, forKey: .region)
         try encoderContainer.encode(serviceCode, forKey: .serviceCode)
         try encoderContainer.encode(formula, forKey: .formula)
         try encoderContainer.encode(pin, forKey: .pin)
         try encoderContainer.encode(resourceId, forKey: .resourceId)
         try encoderContainer.encode(billingType, forKey: .billingType)
         try encoderContainer.encode(subBillId, forKey: .subBillId)
         try encoderContainer.encode(state, forKey: .state)
         try encoderContainer.encode(stateTime, forKey: .stateTime)
         try encoderContainer.encode(op, forKey: .op)
         try encoderContainer.encode(isLastRecord, forKey: .isLastRecord)
         try encoderContainer.encode(createTime, forKey: .createTime)
         try encoderContainer.encode(updateTime, forKey: .updateTime)
         try encoderContainer.encode(toDeleteTime, forKey: .toDeleteTime)
         try encoderContainer.encode(capState, forKey: .capState)
    }
}

/* Copyright 2018 JDCLOUD.COM

   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at

     http:#www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.

   Consumption Management APIs
   消费管理API接口

   OpenAPI spec version: v1
   Contact: 

   NOTE: This class is auto generated by the jdcloud code generator program.
 */


import Foundation
///  resourceAeVo
public class ResourceAeVo:NSObject,Codable{
    /// 自增主键
    var id:Int?
    /// 站点标识1:中国 2:国际
    var site:Int?
    /// 应用编码
    var appCode:String?
    /// 地域
    var region:String?
    /// 服务编码
    var serviceCode:String?
    /// 配置项
    var formula:String?
    /// 用户pin
    var pin:String?
    /// 资源ID
    var resourceId:String?
    /// 计费类型
    var billingType:Int?
    /// 账单ID
    var subBillId:Int?
    /// 状态 0:无 1:正常 2:欠费, 3:因欠费而停机, 4:欠费删除资源, 6:已删除但已不欠费, 7:欠费延期，8:删除并且欠费，9:欠费删除数据，12:已过期, 13:因过期而停机, 14:过期删除资源, 17:过期延期 19:过期删除数据23:管理员停服，24:管理员删除,34:用户删除,35:退款删除
    var state:Int?
    /// 首次欠费时间（各欠费状态）或过期时间（各过期状态）
    var stateTime:String?
    /// 变成此状态的原因.0:无 1:账单欠费, 2:资源过期 ,3:加入、移出白名单 ,4:补扣款成功, 5:规则修改,6:续费 7:管理员操作,8:用户操作
    var op:Int?
    /// 是否为最后状态记录
    var isLastRecord:Int?
    /// 本条记录生成时刻、进入当前state的时刻
    var createTime:String?
    /// 修改时间
    var updateTime:String?
    /// 资源预计释放时间
    var toDeleteTime:String?
    /// CapState
    var capState:Int?



    public override init(){
            super.init()
    }

    enum ResourceAeVoCodingKeys: String, CodingKey {
        case id
        case site
        case appCode
        case region
        case serviceCode
        case formula
        case pin
        case resourceId
        case billingType
        case subBillId
        case state
        case stateTime
        case op
        case isLastRecord
        case createTime
        case updateTime
        case toDeleteTime
        case capState
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: ResourceAeVoCodingKeys.self)
        if decoderContainer.contains(.id)
        {
            self.id = try decoderContainer.decode(Int?.self, forKey: .id)
        }
        if decoderContainer.contains(.site)
        {
            self.site = try decoderContainer.decode(Int?.self, forKey: .site)
        }
        if decoderContainer.contains(.appCode)
        {
            self.appCode = try decoderContainer.decode(String?.self, forKey: .appCode)
        }
        if decoderContainer.contains(.region)
        {
            self.region = try decoderContainer.decode(String?.self, forKey: .region)
        }
        if decoderContainer.contains(.serviceCode)
        {
            self.serviceCode = try decoderContainer.decode(String?.self, forKey: .serviceCode)
        }
        if decoderContainer.contains(.formula)
        {
            self.formula = try decoderContainer.decode(String?.self, forKey: .formula)
        }
        if decoderContainer.contains(.pin)
        {
            self.pin = try decoderContainer.decode(String?.self, forKey: .pin)
        }
        if decoderContainer.contains(.resourceId)
        {
            self.resourceId = try decoderContainer.decode(String?.self, forKey: .resourceId)
        }
        if decoderContainer.contains(.billingType)
        {
            self.billingType = try decoderContainer.decode(Int?.self, forKey: .billingType)
        }
        if decoderContainer.contains(.subBillId)
        {
            self.subBillId = try decoderContainer.decode(Int?.self, forKey: .subBillId)
        }
        if decoderContainer.contains(.state)
        {
            self.state = try decoderContainer.decode(Int?.self, forKey: .state)
        }
        if decoderContainer.contains(.stateTime)
        {
            self.stateTime = try decoderContainer.decode(String?.self, forKey: .stateTime)
        }
        if decoderContainer.contains(.op)
        {
            self.op = try decoderContainer.decode(Int?.self, forKey: .op)
        }
        if decoderContainer.contains(.isLastRecord)
        {
            self.isLastRecord = try decoderContainer.decode(Int?.self, forKey: .isLastRecord)
        }
        if decoderContainer.contains(.createTime)
        {
            self.createTime = try decoderContainer.decode(String?.self, forKey: .createTime)
        }
        if decoderContainer.contains(.updateTime)
        {
            self.updateTime = try decoderContainer.decode(String?.self, forKey: .updateTime)
        }
        if decoderContainer.contains(.toDeleteTime)
        {
            self.toDeleteTime = try decoderContainer.decode(String?.self, forKey: .toDeleteTime)
        }
        if decoderContainer.contains(.capState)
        {
            self.capState = try decoderContainer.decode(Int?.self, forKey: .capState)
        }
    }
}
public extension ResourceAeVo{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: ResourceAeVoCodingKeys.self)
         try encoderContainer.encode(id, forKey: .id)
         try encoderContainer.encode(site, forKey: .site)
         try encoderContainer.encode(appCode, forKey: .appCode)
         try encoderContainer.encode(region, forKey: .region)
         try encoderContainer.encode(serviceCode, forKey: .serviceCode)
         try encoderContainer.encode(formula, forKey: .formula)
         try encoderContainer.encode(pin, forKey: .pin)
         try encoderContainer.encode(resourceId, forKey: .resourceId)
         try encoderContainer.encode(billingType, forKey: .billingType)
         try encoderContainer.encode(subBillId, forKey: .subBillId)
         try encoderContainer.encode(state, forKey: .state)
         try encoderContainer.encode(stateTime, forKey: .stateTime)
         try encoderContainer.encode(op, forKey: .op)
         try encoderContainer.encode(isLastRecord, forKey: .isLastRecord)
         try encoderContainer.encode(createTime, forKey: .createTime)
         try encoderContainer.encode(updateTime, forKey: .updateTime)
         try encoderContainer.encode(toDeleteTime, forKey: .toDeleteTime)
         try encoderContainer.encode(capState, forKey: .capState)
    }
}
///  pagination
public class Pagination:NSObject,Codable{
    /// 当前页
    var currPageNo:Int?
    /// 页数
    var numberPages:Int?
    /// 每页记录数
    var numberRecords:Int?
    /// 页面大小
    var pageSize:Int?
    /// 起始页
    var startIndex:Int?



    public override init(){
            super.init()
    }

    enum PaginationCodingKeys: String, CodingKey {
        case currPageNo
        case numberPages
        case numberRecords
        case pageSize
        case startIndex
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: PaginationCodingKeys.self)
        if decoderContainer.contains(.currPageNo)
        {
            self.currPageNo = try decoderContainer.decode(Int?.self, forKey: .currPageNo)
        }
        if decoderContainer.contains(.numberPages)
        {
            self.numberPages = try decoderContainer.decode(Int?.self, forKey: .numberPages)
        }
        if decoderContainer.contains(.numberRecords)
        {
            self.numberRecords = try decoderContainer.decode(Int?.self, forKey: .numberRecords)
        }
        if decoderContainer.contains(.pageSize)
        {
            self.pageSize = try decoderContainer.decode(Int?.self, forKey: .pageSize)
        }
        if decoderContainer.contains(.startIndex)
        {
            self.startIndex = try decoderContainer.decode(Int?.self, forKey: .startIndex)
        }
    }
}
public extension Pagination{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: PaginationCodingKeys.self)
         try encoderContainer.encode(currPageNo, forKey: .currPageNo)
         try encoderContainer.encode(numberPages, forKey: .numberPages)
         try encoderContainer.encode(numberRecords, forKey: .numberRecords)
         try encoderContainer.encode(pageSize, forKey: .pageSize)
         try encoderContainer.encode(startIndex, forKey: .startIndex)
    }
}
///  resourceOrderStatusResultItem
public class ResourceOrderStatusResultItem:NSObject,Codable{
    /// 资源id
    var resourceId:String?
    /// 计费类型 1:按配置 2:按用量 3:包年包月 4:一次性
    var billingType:Int?
    /// 资源状态 1:正常 2:停服 3:删除
    var status:Int?
    /// 用户pin
    var pin:String?
    /// 资源区域
    var region:String?
    /// 操作时间
    var updateTime:String?



    public override init(){
            super.init()
    }

    enum ResourceOrderStatusResultItemCodingKeys: String, CodingKey {
        case resourceId
        case billingType
        case status
        case pin
        case region
        case updateTime
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: ResourceOrderStatusResultItemCodingKeys.self)
        if decoderContainer.contains(.resourceId)
        {
            self.resourceId = try decoderContainer.decode(String?.self, forKey: .resourceId)
        }
        if decoderContainer.contains(.billingType)
        {
            self.billingType = try decoderContainer.decode(Int?.self, forKey: .billingType)
        }
        if decoderContainer.contains(.status)
        {
            self.status = try decoderContainer.decode(Int?.self, forKey: .status)
        }
        if decoderContainer.contains(.pin)
        {
            self.pin = try decoderContainer.decode(String?.self, forKey: .pin)
        }
        if decoderContainer.contains(.region)
        {
            self.region = try decoderContainer.decode(String?.self, forKey: .region)
        }
        if decoderContainer.contains(.updateTime)
        {
            self.updateTime = try decoderContainer.decode(String?.self, forKey: .updateTime)
        }
    }
}
public extension ResourceOrderStatusResultItem{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: ResourceOrderStatusResultItemCodingKeys.self)
         try encoderContainer.encode(resourceId, forKey: .resourceId)
         try encoderContainer.encode(billingType, forKey: .billingType)
         try encoderContainer.encode(status, forKey: .status)
         try encoderContainer.encode(pin, forKey: .pin)
         try encoderContainer.encode(region, forKey: .region)
         try encoderContainer.encode(updateTime, forKey: .updateTime)
    }
}
///  resourceOrderQueryCondition
public class ResourceOrderQueryCondition:NSObject,Codable{
    /// 主键id
    var id:Int?
    /// 用户pin
    var pin:String?
    /// 资源id
    var resourceId:String?
    /// appCode
    var appCode:String?
    /// 产品码列表
    var serviceCodeList:[String?]?
    /// 地域
    var region:String?
    /// 网络类型 0: non-BGP, 1: BGP
    var networkOperator:Int?
    /// 计费类型 1:按配置 2:按用量 3:包年包月
    var billingType:Int?
    /// resourceIdList
    var resourceIdList:[String?]?
    /// &gt;0: 订单还有几天到期; &#x3D;&#x3D;0: 订单已经到期; &lt;0: 不管是否到期
    var expireInDays:Int?
    /// isOnTrial
    var isOnTrial:Int?
    /// 站点信息 0:中国 1:国际
    var site:Int?
    /// 资源状态 1:正常 2:停服 3:删除
    var status:Int?
    /// 计费状态 0:停止计费 1:计费中
    var billingStatus:Int?
    /// 1、内部计算，使用getExpiringOrderCount时使用，不用传值 默认为-1mybatis筛选时不会关注 2、selectResourceOrderForTask定时任务查询列表时使用，停服天数，必须大于0
    var expiringInDays:Int?
    /// billingTypeList
    var billingTypeList:[Double?]?
    /// 交易单号列表
    var transactionNos:[String?]?
    /// OpTypes
    var opTypes:[Double?]?
    /// 开始时间
    var startTime:String?
    /// 结束时间
    var endTime:String?
    /// 服务编码
    var serviceCode:String?
    /// statusList
    var statusList:[Double?]?
    /// excludeResources
    var excludeResources:[String?]?
    /// orderByClaus
    var orderByClaus:String?
    /// 专有云节点的code（节点云查询使用）
    var node:String?
    /// 部门（节点云查询使用）
    var departmentId:Int?
    /// PinList
    var pinList:[String?]?
    /// 是否是专有云 1:是  其他不是
    var isSpecial:Int?
    /// 节点信息
    var nodeCode:String?
    /// 超时时间，暂时不用
    var timeout:Int?
    /// 当前页序号
    var pageIndex:Int?
    /// 每页结果数量
    var pageSize:Int?
    /// Offset
    var offset:Int?



    public override init(){
            super.init()
    }

    enum ResourceOrderQueryConditionCodingKeys: String, CodingKey {
        case id
        case pin
        case resourceId
        case appCode
        case serviceCodeList
        case region
        case networkOperator
        case billingType
        case resourceIdList
        case expireInDays
        case isOnTrial
        case site
        case status
        case billingStatus
        case expiringInDays
        case billingTypeList
        case transactionNos
        case opTypes
        case startTime
        case endTime
        case serviceCode
        case statusList
        case excludeResources
        case orderByClaus
        case node
        case departmentId
        case pinList
        case isSpecial
        case nodeCode
        case timeout
        case pageIndex
        case pageSize
        case offset
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: ResourceOrderQueryConditionCodingKeys.self)
        if decoderContainer.contains(.id)
        {
            self.id = try decoderContainer.decode(Int?.self, forKey: .id)
        }
        if decoderContainer.contains(.pin)
        {
            self.pin = try decoderContainer.decode(String?.self, forKey: .pin)
        }
        if decoderContainer.contains(.resourceId)
        {
            self.resourceId = try decoderContainer.decode(String?.self, forKey: .resourceId)
        }
        if decoderContainer.contains(.appCode)
        {
            self.appCode = try decoderContainer.decode(String?.self, forKey: .appCode)
        }
        if decoderContainer.contains(.serviceCodeList)
        {
            self.serviceCodeList = try decoderContainer.decode([String?]?.self, forKey: .serviceCodeList)
        }
        if decoderContainer.contains(.region)
        {
            self.region = try decoderContainer.decode(String?.self, forKey: .region)
        }
        if decoderContainer.contains(.networkOperator)
        {
            self.networkOperator = try decoderContainer.decode(Int?.self, forKey: .networkOperator)
        }
        if decoderContainer.contains(.billingType)
        {
            self.billingType = try decoderContainer.decode(Int?.self, forKey: .billingType)
        }
        if decoderContainer.contains(.resourceIdList)
        {
            self.resourceIdList = try decoderContainer.decode([String?]?.self, forKey: .resourceIdList)
        }
        if decoderContainer.contains(.expireInDays)
        {
            self.expireInDays = try decoderContainer.decode(Int?.self, forKey: .expireInDays)
        }
        if decoderContainer.contains(.isOnTrial)
        {
            self.isOnTrial = try decoderContainer.decode(Int?.self, forKey: .isOnTrial)
        }
        if decoderContainer.contains(.site)
        {
            self.site = try decoderContainer.decode(Int?.self, forKey: .site)
        }
        if decoderContainer.contains(.status)
        {
            self.status = try decoderContainer.decode(Int?.self, forKey: .status)
        }
        if decoderContainer.contains(.billingStatus)
        {
            self.billingStatus = try decoderContainer.decode(Int?.self, forKey: .billingStatus)
        }
        if decoderContainer.contains(.expiringInDays)
        {
            self.expiringInDays = try decoderContainer.decode(Int?.self, forKey: .expiringInDays)
        }
        if decoderContainer.contains(.billingTypeList)
        {
            self.billingTypeList = try decoderContainer.decode([Double?]?.self, forKey: .billingTypeList)
        }
        if decoderContainer.contains(.transactionNos)
        {
            self.transactionNos = try decoderContainer.decode([String?]?.self, forKey: .transactionNos)
        }
        if decoderContainer.contains(.opTypes)
        {
            self.opTypes = try decoderContainer.decode([Double?]?.self, forKey: .opTypes)
        }
        if decoderContainer.contains(.startTime)
        {
            self.startTime = try decoderContainer.decode(String?.self, forKey: .startTime)
        }
        if decoderContainer.contains(.endTime)
        {
            self.endTime = try decoderContainer.decode(String?.self, forKey: .endTime)
        }
        if decoderContainer.contains(.serviceCode)
        {
            self.serviceCode = try decoderContainer.decode(String?.self, forKey: .serviceCode)
        }
        if decoderContainer.contains(.statusList)
        {
            self.statusList = try decoderContainer.decode([Double?]?.self, forKey: .statusList)
        }
        if decoderContainer.contains(.excludeResources)
        {
            self.excludeResources = try decoderContainer.decode([String?]?.self, forKey: .excludeResources)
        }
        if decoderContainer.contains(.orderByClaus)
        {
            self.orderByClaus = try decoderContainer.decode(String?.self, forKey: .orderByClaus)
        }
        if decoderContainer.contains(.node)
        {
            self.node = try decoderContainer.decode(String?.self, forKey: .node)
        }
        if decoderContainer.contains(.departmentId)
        {
            self.departmentId = try decoderContainer.decode(Int?.self, forKey: .departmentId)
        }
        if decoderContainer.contains(.pinList)
        {
            self.pinList = try decoderContainer.decode([String?]?.self, forKey: .pinList)
        }
        if decoderContainer.contains(.isSpecial)
        {
            self.isSpecial = try decoderContainer.decode(Int?.self, forKey: .isSpecial)
        }
        if decoderContainer.contains(.nodeCode)
        {
            self.nodeCode = try decoderContainer.decode(String?.self, forKey: .nodeCode)
        }
        if decoderContainer.contains(.timeout)
        {
            self.timeout = try decoderContainer.decode(Int?.self, forKey: .timeout)
        }
        if decoderContainer.contains(.pageIndex)
        {
            self.pageIndex = try decoderContainer.decode(Int?.self, forKey: .pageIndex)
        }
        if decoderContainer.contains(.pageSize)
        {
            self.pageSize = try decoderContainer.decode(Int?.self, forKey: .pageSize)
        }
        if decoderContainer.contains(.offset)
        {
            self.offset = try decoderContainer.decode(Int?.self, forKey: .offset)
        }
    }
}
public extension ResourceOrderQueryCondition{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: ResourceOrderQueryConditionCodingKeys.self)
         try encoderContainer.encode(id, forKey: .id)
         try encoderContainer.encode(pin, forKey: .pin)
         try encoderContainer.encode(resourceId, forKey: .resourceId)
         try encoderContainer.encode(appCode, forKey: .appCode)
         try encoderContainer.encode(serviceCodeList, forKey: .serviceCodeList)
         try encoderContainer.encode(region, forKey: .region)
         try encoderContainer.encode(networkOperator, forKey: .networkOperator)
         try encoderContainer.encode(billingType, forKey: .billingType)
         try encoderContainer.encode(resourceIdList, forKey: .resourceIdList)
         try encoderContainer.encode(expireInDays, forKey: .expireInDays)
         try encoderContainer.encode(isOnTrial, forKey: .isOnTrial)
         try encoderContainer.encode(site, forKey: .site)
         try encoderContainer.encode(status, forKey: .status)
         try encoderContainer.encode(billingStatus, forKey: .billingStatus)
         try encoderContainer.encode(expiringInDays, forKey: .expiringInDays)
         try encoderContainer.encode(billingTypeList, forKey: .billingTypeList)
         try encoderContainer.encode(transactionNos, forKey: .transactionNos)
         try encoderContainer.encode(opTypes, forKey: .opTypes)
         try encoderContainer.encode(startTime, forKey: .startTime)
         try encoderContainer.encode(endTime, forKey: .endTime)
         try encoderContainer.encode(serviceCode, forKey: .serviceCode)
         try encoderContainer.encode(statusList, forKey: .statusList)
         try encoderContainer.encode(excludeResources, forKey: .excludeResources)
         try encoderContainer.encode(orderByClaus, forKey: .orderByClaus)
         try encoderContainer.encode(node, forKey: .node)
         try encoderContainer.encode(departmentId, forKey: .departmentId)
         try encoderContainer.encode(pinList, forKey: .pinList)
         try encoderContainer.encode(isSpecial, forKey: .isSpecial)
         try encoderContainer.encode(nodeCode, forKey: .nodeCode)
         try encoderContainer.encode(timeout, forKey: .timeout)
         try encoderContainer.encode(pageIndex, forKey: .pageIndex)
         try encoderContainer.encode(pageSize, forKey: .pageSize)
         try encoderContainer.encode(offset, forKey: .offset)
    }
}
///  resourceOrderStatusCondition
public class ResourceOrderStatusCondition:NSObject,Codable{
    /// 站点信息 0:中国 1:国际
    var site:Int?
    /// 服务编码
    /// Required:true
    var serviceCode:String
    /// 资源状态 1:正常 2:停服 3:删除
    var status:Int?
    /// 资源id列表
    /// Required:true
    var resourceIdList:[String?]?
    /// 当前页序号
    var pageIndex:Int?
    /// 每页结果数量
    var pageSize:Int?



    public  init(serviceCode:String,resourceIdList:[String?]?){
             self.serviceCode = serviceCode
             self.resourceIdList = resourceIdList
    }

    enum ResourceOrderStatusConditionCodingKeys: String, CodingKey {
        case site
        case serviceCode
        case status
        case resourceIdList
        case pageIndex
        case pageSize
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: ResourceOrderStatusConditionCodingKeys.self)
        if decoderContainer.contains(.site)
        {
            self.site = try decoderContainer.decode(Int?.self, forKey: .site)
        }
        self.serviceCode = try decoderContainer.decode(String.self, forKey: .serviceCode)
        if decoderContainer.contains(.status)
        {
            self.status = try decoderContainer.decode(Int?.self, forKey: .status)
        }
        self.resourceIdList = try decoderContainer.decode([String?]?.self, forKey: .resourceIdList)
        if decoderContainer.contains(.pageIndex)
        {
            self.pageIndex = try decoderContainer.decode(Int?.self, forKey: .pageIndex)
        }
        if decoderContainer.contains(.pageSize)
        {
            self.pageSize = try decoderContainer.decode(Int?.self, forKey: .pageSize)
        }
    }
}
public extension ResourceOrderStatusCondition{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: ResourceOrderStatusConditionCodingKeys.self)
         try encoderContainer.encode(site, forKey: .site)
         try encoderContainer.encode(serviceCode, forKey: .serviceCode)
         try encoderContainer.encode(status, forKey: .status)
         try encoderContainer.encode(resourceIdList, forKey: .resourceIdList)
         try encoderContainer.encode(pageIndex, forKey: .pageIndex)
         try encoderContainer.encode(pageSize, forKey: .pageSize)
    }
}
///  formula
public class Formula:NSObject,Codable{
    /// 计费项别名
    var key:String?
    /// 用量
    var value:Double?
    /// 单位
    var unit:String?
    /// 计费项数量
    var number:Double?



    public override init(){
            super.init()
    }

    enum FormulaCodingKeys: String, CodingKey {
        case key
        case value
        case unit
        case number
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: FormulaCodingKeys.self)
        if decoderContainer.contains(.key)
        {
            self.key = try decoderContainer.decode(String?.self, forKey: .key)
        }
        if decoderContainer.contains(.value)
        {
            self.value = try decoderContainer.decode(Double?.self, forKey: .value)
        }
        if decoderContainer.contains(.unit)
        {
            self.unit = try decoderContainer.decode(String?.self, forKey: .unit)
        }
        if decoderContainer.contains(.number)
        {
            self.number = try decoderContainer.decode(Double?.self, forKey: .number)
        }
    }
}
public extension Formula{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: FormulaCodingKeys.self)
         try encoderContainer.encode(key, forKey: .key)
         try encoderContainer.encode(value, forKey: .value)
         try encoderContainer.encode(unit, forKey: .unit)
         try encoderContainer.encode(number, forKey: .number)
    }
}
///  resourceOrderStatusVo
public class ResourceOrderStatusVo:NSObject,Codable{
    /// 资源id
    /// Required:true
    var resourceId:String
    /// 用户pin
    /// Required:true
    var pin:String
    /// 资源状态 1:正常 2:停服 3:删除
    var status:Int?
    /// 计费状态 0:停止计费 1:计费中
    var billingStatus:Int?
    /// 计费类型 1:按配置 2:按用量 3:包年包月
    var billingType:Int?
    /// 结束时间
    var endTime:String?
    /// billingType兼容交易系统字段
    var chargeMode:Int?
    /// timeSpan兼容交易系统字段
    var chargeDuration:Int?
    /// timeUnit兼容交易系统字段
    var chargeUnit:Int?
    /// 站点信息 0:中国 1:国际  10:专有云
    var site:Int?
    /// 操作时间
    var operateTime:String?



    public  init(resourceId:String,pin:String){
             self.resourceId = resourceId
             self.pin = pin
    }

    enum ResourceOrderStatusVoCodingKeys: String, CodingKey {
        case resourceId
        case pin
        case status
        case billingStatus
        case billingType
        case endTime
        case chargeMode
        case chargeDuration
        case chargeUnit
        case site
        case operateTime
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: ResourceOrderStatusVoCodingKeys.self)
        self.resourceId = try decoderContainer.decode(String.self, forKey: .resourceId)
        self.pin = try decoderContainer.decode(String.self, forKey: .pin)
        if decoderContainer.contains(.status)
        {
            self.status = try decoderContainer.decode(Int?.self, forKey: .status)
        }
        if decoderContainer.contains(.billingStatus)
        {
            self.billingStatus = try decoderContainer.decode(Int?.self, forKey: .billingStatus)
        }
        if decoderContainer.contains(.billingType)
        {
            self.billingType = try decoderContainer.decode(Int?.self, forKey: .billingType)
        }
        if decoderContainer.contains(.endTime)
        {
            self.endTime = try decoderContainer.decode(String?.self, forKey: .endTime)
        }
        if decoderContainer.contains(.chargeMode)
        {
            self.chargeMode = try decoderContainer.decode(Int?.self, forKey: .chargeMode)
        }
        if decoderContainer.contains(.chargeDuration)
        {
            self.chargeDuration = try decoderContainer.decode(Int?.self, forKey: .chargeDuration)
        }
        if decoderContainer.contains(.chargeUnit)
        {
            self.chargeUnit = try decoderContainer.decode(Int?.self, forKey: .chargeUnit)
        }
        if decoderContainer.contains(.site)
        {
            self.site = try decoderContainer.decode(Int?.self, forKey: .site)
        }
        if decoderContainer.contains(.operateTime)
        {
            self.operateTime = try decoderContainer.decode(String?.self, forKey: .operateTime)
        }
    }
}
public extension ResourceOrderStatusVo{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: ResourceOrderStatusVoCodingKeys.self)
         try encoderContainer.encode(resourceId, forKey: .resourceId)
         try encoderContainer.encode(pin, forKey: .pin)
         try encoderContainer.encode(status, forKey: .status)
         try encoderContainer.encode(billingStatus, forKey: .billingStatus)
         try encoderContainer.encode(billingType, forKey: .billingType)
         try encoderContainer.encode(endTime, forKey: .endTime)
         try encoderContainer.encode(chargeMode, forKey: .chargeMode)
         try encoderContainer.encode(chargeDuration, forKey: .chargeDuration)
         try encoderContainer.encode(chargeUnit, forKey: .chargeUnit)
         try encoderContainer.encode(site, forKey: .site)
         try encoderContainer.encode(operateTime, forKey: .operateTime)
    }
}
///  resourceOrderVo
public class ResourceOrderVo:NSObject,Codable{
    /// 主键id
    var id:Int?
    /// 交易单唯一标识
    var transactionNo:String?
    /// 资源id
    var resourceId:String?
    /// 计费类型 1:按配置 2:按用量 3:包年包月 4:一次性
    var billingType:Int?
    /// 时长类型 1:小时 2:天 3:月 4:年
    var timeUnit:Int?
    /// 时长字段，与timeUnit字段构成具体时长
    var timeSpan:Int?
    /// 资源状态 1:正常 2:停服 3:删除
    var status:Int?
    /// 计费状态 0:停止计费 1:计费中
    var billingStatus:Int?
    /// 网络类型0:无 1: non-BGP, 2: BGP
    var networkOperator:Int?
    /// 用户pin
    var pin:String?
    /// 应用码
    var appCode:String?
    /// 服务码
    var serviceCode:String?
    /// 站点标识0:中国 1:国际
    var site:Int?
    /// 资源区域
    var region:String?
    /// 配置信息
    var formula:[Formula?]?
    /// 否为试用资源 0:非试用 1:试用
    var isOnTrial:Int?
    /// 开始时间
    var startTime:String?
    /// 结束时间
    var endTime:String?
    /// 创建时间
    var createTime:String?
    /// 支付时间
    var payTime:String?
    /// formula转换成字符串
    var formulaStr:String?
    /// billingType兼容交易系统字段
    var chargeMode:Int?
    /// timeSpan兼容交易系统字段
    var chargeDuration:Int?
    /// timeUnit兼容交易系统字段
    var chargeUnit:Int?
    /// 欠费过期状态
    var aeStatus:Int?
    /// 欠费、过期资源释放时间
    var releasingTime:String?
    /// 交易单模块sourceId 计费不关心
    var sourceId:String?
    /// 计费开始时间 续费时本次续费周期开始时间
    var billingStartTime:String?
    /// 最新价格map
    var priceMap:PriceMap?
    /// 价格快照
    var priceSnapshot:String?
    /// 订单折扣前总价
    var price:Double?
    /// 折扣后订单价格
    var discountedPrice:Double?
    /// 即将到期天数
    var expiringDays:Int?
    /// 计费类型描述 例如:按配置、包年包月
    var billingCategoryDescription:String?
    /// 计费详情描述 例如:按配置、包年包月（一年）
    var descriptionValue:String?
    /// refundNo
    var refundNo:String?
    /// 计费类型单号
    var billingTypeName:String?
    /// 促销明细
    var favorableInfo:String?
    /// 资源名
    var resourceName:String?
    /// 变配明细（1-升配，2-降配，3-调整配置,4-续费,5-续费升配,6-续费降配,7-配置转包年包月）
    var processType:Int?
    /// 资源申请人
    var applicant:String?
    /// 计费模式  1.停服停止计费  2.关机停止计费
    var billingMode:Int?
    /// 启服、停服、停止计费时间
    var operateTime:String?



    public override init(){
            super.init()
    }

    enum ResourceOrderVoCodingKeys: String, CodingKey {
        case id
        case transactionNo
        case resourceId
        case billingType
        case timeUnit
        case timeSpan
        case status
        case billingStatus
        case networkOperator
        case pin
        case appCode
        case serviceCode
        case site
        case region
        case formula
        case isOnTrial
        case startTime
        case endTime
        case createTime
        case payTime
        case formulaStr
        case chargeMode
        case chargeDuration
        case chargeUnit
        case aeStatus
        case releasingTime
        case sourceId
        case billingStartTime
        case priceMap
        case priceSnapshot
        case price
        case discountedPrice
        case expiringDays
        case billingCategoryDescription
        case descriptionValue = "description"
        case refundNo
        case billingTypeName
        case favorableInfo
        case resourceName
        case processType
        case applicant
        case billingMode
        case operateTime
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: ResourceOrderVoCodingKeys.self)
        if decoderContainer.contains(.id)
        {
            self.id = try decoderContainer.decode(Int?.self, forKey: .id)
        }
        if decoderContainer.contains(.transactionNo)
        {
            self.transactionNo = try decoderContainer.decode(String?.self, forKey: .transactionNo)
        }
        if decoderContainer.contains(.resourceId)
        {
            self.resourceId = try decoderContainer.decode(String?.self, forKey: .resourceId)
        }
        if decoderContainer.contains(.billingType)
        {
            self.billingType = try decoderContainer.decode(Int?.self, forKey: .billingType)
        }
        if decoderContainer.contains(.timeUnit)
        {
            self.timeUnit = try decoderContainer.decode(Int?.self, forKey: .timeUnit)
        }
        if decoderContainer.contains(.timeSpan)
        {
            self.timeSpan = try decoderContainer.decode(Int?.self, forKey: .timeSpan)
        }
        if decoderContainer.contains(.status)
        {
            self.status = try decoderContainer.decode(Int?.self, forKey: .status)
        }
        if decoderContainer.contains(.billingStatus)
        {
            self.billingStatus = try decoderContainer.decode(Int?.self, forKey: .billingStatus)
        }
        if decoderContainer.contains(.networkOperator)
        {
            self.networkOperator = try decoderContainer.decode(Int?.self, forKey: .networkOperator)
        }
        if decoderContainer.contains(.pin)
        {
            self.pin = try decoderContainer.decode(String?.self, forKey: .pin)
        }
        if decoderContainer.contains(.appCode)
        {
            self.appCode = try decoderContainer.decode(String?.self, forKey: .appCode)
        }
        if decoderContainer.contains(.serviceCode)
        {
            self.serviceCode = try decoderContainer.decode(String?.self, forKey: .serviceCode)
        }
        if decoderContainer.contains(.site)
        {
            self.site = try decoderContainer.decode(Int?.self, forKey: .site)
        }
        if decoderContainer.contains(.region)
        {
            self.region = try decoderContainer.decode(String?.self, forKey: .region)
        }
        if decoderContainer.contains(.formula)
        {
            self.formula = try decoderContainer.decode([Formula?]?.self, forKey: .formula)
        }
        if decoderContainer.contains(.isOnTrial)
        {
            self.isOnTrial = try decoderContainer.decode(Int?.self, forKey: .isOnTrial)
        }
        if decoderContainer.contains(.startTime)
        {
            self.startTime = try decoderContainer.decode(String?.self, forKey: .startTime)
        }
        if decoderContainer.contains(.endTime)
        {
            self.endTime = try decoderContainer.decode(String?.self, forKey: .endTime)
        }
        if decoderContainer.contains(.createTime)
        {
            self.createTime = try decoderContainer.decode(String?.self, forKey: .createTime)
        }
        if decoderContainer.contains(.payTime)
        {
            self.payTime = try decoderContainer.decode(String?.self, forKey: .payTime)
        }
        if decoderContainer.contains(.formulaStr)
        {
            self.formulaStr = try decoderContainer.decode(String?.self, forKey: .formulaStr)
        }
        if decoderContainer.contains(.chargeMode)
        {
            self.chargeMode = try decoderContainer.decode(Int?.self, forKey: .chargeMode)
        }
        if decoderContainer.contains(.chargeDuration)
        {
            self.chargeDuration = try decoderContainer.decode(Int?.self, forKey: .chargeDuration)
        }
        if decoderContainer.contains(.chargeUnit)
        {
            self.chargeUnit = try decoderContainer.decode(Int?.self, forKey: .chargeUnit)
        }
        if decoderContainer.contains(.aeStatus)
        {
            self.aeStatus = try decoderContainer.decode(Int?.self, forKey: .aeStatus)
        }
        if decoderContainer.contains(.releasingTime)
        {
            self.releasingTime = try decoderContainer.decode(String?.self, forKey: .releasingTime)
        }
        if decoderContainer.contains(.sourceId)
        {
            self.sourceId = try decoderContainer.decode(String?.self, forKey: .sourceId)
        }
        if decoderContainer.contains(.billingStartTime)
        {
            self.billingStartTime = try decoderContainer.decode(String?.self, forKey: .billingStartTime)
        }
        if decoderContainer.contains(.priceMap)
        {
            self.priceMap = try decoderContainer.decode(PriceMap?.self, forKey: .priceMap)
        }
        if decoderContainer.contains(.priceSnapshot)
        {
            self.priceSnapshot = try decoderContainer.decode(String?.self, forKey: .priceSnapshot)
        }
        if decoderContainer.contains(.price)
        {
            self.price = try decoderContainer.decode(Double?.self, forKey: .price)
        }
        if decoderContainer.contains(.discountedPrice)
        {
            self.discountedPrice = try decoderContainer.decode(Double?.self, forKey: .discountedPrice)
        }
        if decoderContainer.contains(.expiringDays)
        {
            self.expiringDays = try decoderContainer.decode(Int?.self, forKey: .expiringDays)
        }
        if decoderContainer.contains(.billingCategoryDescription)
        {
            self.billingCategoryDescription = try decoderContainer.decode(String?.self, forKey: .billingCategoryDescription)
        }
        if decoderContainer.contains(.descriptionValue)
        {
            self.descriptionValue = try decoderContainer.decode(String?.self, forKey: .descriptionValue)
        }
        if decoderContainer.contains(.refundNo)
        {
            self.refundNo = try decoderContainer.decode(String?.self, forKey: .refundNo)
        }
        if decoderContainer.contains(.billingTypeName)
        {
            self.billingTypeName = try decoderContainer.decode(String?.self, forKey: .billingTypeName)
        }
        if decoderContainer.contains(.favorableInfo)
        {
            self.favorableInfo = try decoderContainer.decode(String?.self, forKey: .favorableInfo)
        }
        if decoderContainer.contains(.resourceName)
        {
            self.resourceName = try decoderContainer.decode(String?.self, forKey: .resourceName)
        }
        if decoderContainer.contains(.processType)
        {
            self.processType = try decoderContainer.decode(Int?.self, forKey: .processType)
        }
        if decoderContainer.contains(.applicant)
        {
            self.applicant = try decoderContainer.decode(String?.self, forKey: .applicant)
        }
        if decoderContainer.contains(.billingMode)
        {
            self.billingMode = try decoderContainer.decode(Int?.self, forKey: .billingMode)
        }
        if decoderContainer.contains(.operateTime)
        {
            self.operateTime = try decoderContainer.decode(String?.self, forKey: .operateTime)
        }
    }
}
public extension ResourceOrderVo{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: ResourceOrderVoCodingKeys.self)
         try encoderContainer.encode(id, forKey: .id)
         try encoderContainer.encode(transactionNo, forKey: .transactionNo)
         try encoderContainer.encode(resourceId, forKey: .resourceId)
         try encoderContainer.encode(billingType, forKey: .billingType)
         try encoderContainer.encode(timeUnit, forKey: .timeUnit)
         try encoderContainer.encode(timeSpan, forKey: .timeSpan)
         try encoderContainer.encode(status, forKey: .status)
         try encoderContainer.encode(billingStatus, forKey: .billingStatus)
         try encoderContainer.encode(networkOperator, forKey: .networkOperator)
         try encoderContainer.encode(pin, forKey: .pin)
         try encoderContainer.encode(appCode, forKey: .appCode)
         try encoderContainer.encode(serviceCode, forKey: .serviceCode)
         try encoderContainer.encode(site, forKey: .site)
         try encoderContainer.encode(region, forKey: .region)
         try encoderContainer.encode(formula, forKey: .formula)
         try encoderContainer.encode(isOnTrial, forKey: .isOnTrial)
         try encoderContainer.encode(startTime, forKey: .startTime)
         try encoderContainer.encode(endTime, forKey: .endTime)
         try encoderContainer.encode(createTime, forKey: .createTime)
         try encoderContainer.encode(payTime, forKey: .payTime)
         try encoderContainer.encode(formulaStr, forKey: .formulaStr)
         try encoderContainer.encode(chargeMode, forKey: .chargeMode)
         try encoderContainer.encode(chargeDuration, forKey: .chargeDuration)
         try encoderContainer.encode(chargeUnit, forKey: .chargeUnit)
         try encoderContainer.encode(aeStatus, forKey: .aeStatus)
         try encoderContainer.encode(releasingTime, forKey: .releasingTime)
         try encoderContainer.encode(sourceId, forKey: .sourceId)
         try encoderContainer.encode(billingStartTime, forKey: .billingStartTime)
         try encoderContainer.encode(priceMap, forKey: .priceMap)
         try encoderContainer.encode(priceSnapshot, forKey: .priceSnapshot)
         try encoderContainer.encode(price, forKey: .price)
         try encoderContainer.encode(discountedPrice, forKey: .discountedPrice)
         try encoderContainer.encode(expiringDays, forKey: .expiringDays)
         try encoderContainer.encode(billingCategoryDescription, forKey: .billingCategoryDescription)
         try encoderContainer.encode(descriptionValue, forKey: .descriptionValue)
         try encoderContainer.encode(refundNo, forKey: .refundNo)
         try encoderContainer.encode(billingTypeName, forKey: .billingTypeName)
         try encoderContainer.encode(favorableInfo, forKey: .favorableInfo)
         try encoderContainer.encode(resourceName, forKey: .resourceName)
         try encoderContainer.encode(processType, forKey: .processType)
         try encoderContainer.encode(applicant, forKey: .applicant)
         try encoderContainer.encode(billingMode, forKey: .billingMode)
         try encoderContainer.encode(operateTime, forKey: .operateTime)
    }
}
///  ebsSeperateBillVoRequest
public class EbsSeperateBillVoRequest:NSObject,Codable{
    /// 核算分摊账单列表
    var ebsSeperateBillVoList:[EbsSeperateBillVo?]?



    public override init(){
            super.init()
    }

    enum EbsSeperateBillVoRequestCodingKeys: String, CodingKey {
        case ebsSeperateBillVoList
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: EbsSeperateBillVoRequestCodingKeys.self)
        if decoderContainer.contains(.ebsSeperateBillVoList)
        {
            self.ebsSeperateBillVoList = try decoderContainer.decode([EbsSeperateBillVo?]?.self, forKey: .ebsSeperateBillVoList)
        }
    }
}
public extension EbsSeperateBillVoRequest{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: EbsSeperateBillVoRequestCodingKeys.self)
         try encoderContainer.encode(ebsSeperateBillVoList, forKey: .ebsSeperateBillVoList)
    }
}
///  ebsBillVo
public class EbsBillVo:NSObject,Codable{
    /// 用户pin
    var pin:String?
    /// 数据源ID
    var dataSourceId:String?
    /// 业务线
    var appCode:String?
    /// 产品线
    var serviceCode:String?
    /// 费用时间
    var chargeTime:String?
    /// 支付金额
    var payFee:Double?
    /// 计费类型
    var billingType:Int?
    /// 开始时间
    var startTime:String?
    /// 结束时间
    var endTime:String?
    /// 采购价格
    var purchasePrice:Double?
    /// 供应商
    var supplier:String?
    /// 核算组织
    var org:String?
    /// 用费分组
    var userGroup:Int?
    /// 域名订单ID
    var domainOrderId:String?
    /// 交易方名称
    var traderName:String?
    /// 订单类型
    var orderType:String?
    /// 税率
    var taxRate:Double?
    /// 部门
    var deptNo:String?
    /// 返回编码0成功
    var code:Int?
    /// 返回消息
    var message:String?



    public override init(){
            super.init()
    }

    enum EbsBillVoCodingKeys: String, CodingKey {
        case pin
        case dataSourceId
        case appCode
        case serviceCode
        case chargeTime
        case payFee
        case billingType
        case startTime
        case endTime
        case purchasePrice
        case supplier
        case org
        case userGroup
        case domainOrderId
        case traderName
        case orderType
        case taxRate
        case deptNo
        case code
        case message
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: EbsBillVoCodingKeys.self)
        if decoderContainer.contains(.pin)
        {
            self.pin = try decoderContainer.decode(String?.self, forKey: .pin)
        }
        if decoderContainer.contains(.dataSourceId)
        {
            self.dataSourceId = try decoderContainer.decode(String?.self, forKey: .dataSourceId)
        }
        if decoderContainer.contains(.appCode)
        {
            self.appCode = try decoderContainer.decode(String?.self, forKey: .appCode)
        }
        if decoderContainer.contains(.serviceCode)
        {
            self.serviceCode = try decoderContainer.decode(String?.self, forKey: .serviceCode)
        }
        if decoderContainer.contains(.chargeTime)
        {
            self.chargeTime = try decoderContainer.decode(String?.self, forKey: .chargeTime)
        }
        if decoderContainer.contains(.payFee)
        {
            self.payFee = try decoderContainer.decode(Double?.self, forKey: .payFee)
        }
        if decoderContainer.contains(.billingType)
        {
            self.billingType = try decoderContainer.decode(Int?.self, forKey: .billingType)
        }
        if decoderContainer.contains(.startTime)
        {
            self.startTime = try decoderContainer.decode(String?.self, forKey: .startTime)
        }
        if decoderContainer.contains(.endTime)
        {
            self.endTime = try decoderContainer.decode(String?.self, forKey: .endTime)
        }
        if decoderContainer.contains(.purchasePrice)
        {
            self.purchasePrice = try decoderContainer.decode(Double?.self, forKey: .purchasePrice)
        }
        if decoderContainer.contains(.supplier)
        {
            self.supplier = try decoderContainer.decode(String?.self, forKey: .supplier)
        }
        if decoderContainer.contains(.org)
        {
            self.org = try decoderContainer.decode(String?.self, forKey: .org)
        }
        if decoderContainer.contains(.userGroup)
        {
            self.userGroup = try decoderContainer.decode(Int?.self, forKey: .userGroup)
        }
        if decoderContainer.contains(.domainOrderId)
        {
            self.domainOrderId = try decoderContainer.decode(String?.self, forKey: .domainOrderId)
        }
        if decoderContainer.contains(.traderName)
        {
            self.traderName = try decoderContainer.decode(String?.self, forKey: .traderName)
        }
        if decoderContainer.contains(.orderType)
        {
            self.orderType = try decoderContainer.decode(String?.self, forKey: .orderType)
        }
        if decoderContainer.contains(.taxRate)
        {
            self.taxRate = try decoderContainer.decode(Double?.self, forKey: .taxRate)
        }
        if decoderContainer.contains(.deptNo)
        {
            self.deptNo = try decoderContainer.decode(String?.self, forKey: .deptNo)
        }
        if decoderContainer.contains(.code)
        {
            self.code = try decoderContainer.decode(Int?.self, forKey: .code)
        }
        if decoderContainer.contains(.message)
        {
            self.message = try decoderContainer.decode(String?.self, forKey: .message)
        }
    }
}
public extension EbsBillVo{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: EbsBillVoCodingKeys.self)
         try encoderContainer.encode(pin, forKey: .pin)
         try encoderContainer.encode(dataSourceId, forKey: .dataSourceId)
         try encoderContainer.encode(appCode, forKey: .appCode)
         try encoderContainer.encode(serviceCode, forKey: .serviceCode)
         try encoderContainer.encode(chargeTime, forKey: .chargeTime)
         try encoderContainer.encode(payFee, forKey: .payFee)
         try encoderContainer.encode(billingType, forKey: .billingType)
         try encoderContainer.encode(startTime, forKey: .startTime)
         try encoderContainer.encode(endTime, forKey: .endTime)
         try encoderContainer.encode(purchasePrice, forKey: .purchasePrice)
         try encoderContainer.encode(supplier, forKey: .supplier)
         try encoderContainer.encode(org, forKey: .org)
         try encoderContainer.encode(userGroup, forKey: .userGroup)
         try encoderContainer.encode(domainOrderId, forKey: .domainOrderId)
         try encoderContainer.encode(traderName, forKey: .traderName)
         try encoderContainer.encode(orderType, forKey: .orderType)
         try encoderContainer.encode(taxRate, forKey: .taxRate)
         try encoderContainer.encode(deptNo, forKey: .deptNo)
         try encoderContainer.encode(code, forKey: .code)
         try encoderContainer.encode(message, forKey: .message)
    }
}
///  ebsSeperateBillVo
public class EbsSeperateBillVo:NSObject,Codable{
    /// 用户pin
    var pin:String?
    /// 数据源ID
    var dataSourceId:String?
    /// 业务线
    var appCode:String?
    /// 费用时间
    var chargeTime:String?
    /// 总金额
    var totalFee:Double?
    /// 分摊金额
    var seperateFee:Double?
    /// 核算组织
    var org:String?
    /// 用户分组
    var userGroup:Int?
    /// 交易方名称
    var traderName:String?
    /// 订单类型
    var orderType:String?
    /// 成本金额
    var costFee:Double?
    /// 税率
    var taxRate:Double?
    /// 部门
    var deptNo:String?
    /// 部门
    var sourceId:String?
    /// 返回编码0成功
    var code:Int?
    /// 返回消息
    var message:String?



    public override init(){
            super.init()
    }

    enum EbsSeperateBillVoCodingKeys: String, CodingKey {
        case pin
        case dataSourceId
        case appCode
        case chargeTime
        case totalFee
        case seperateFee
        case org
        case userGroup
        case traderName
        case orderType
        case costFee
        case taxRate
        case deptNo
        case sourceId
        case code
        case message
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: EbsSeperateBillVoCodingKeys.self)
        if decoderContainer.contains(.pin)
        {
            self.pin = try decoderContainer.decode(String?.self, forKey: .pin)
        }
        if decoderContainer.contains(.dataSourceId)
        {
            self.dataSourceId = try decoderContainer.decode(String?.self, forKey: .dataSourceId)
        }
        if decoderContainer.contains(.appCode)
        {
            self.appCode = try decoderContainer.decode(String?.self, forKey: .appCode)
        }
        if decoderContainer.contains(.chargeTime)
        {
            self.chargeTime = try decoderContainer.decode(String?.self, forKey: .chargeTime)
        }
        if decoderContainer.contains(.totalFee)
        {
            self.totalFee = try decoderContainer.decode(Double?.self, forKey: .totalFee)
        }
        if decoderContainer.contains(.seperateFee)
        {
            self.seperateFee = try decoderContainer.decode(Double?.self, forKey: .seperateFee)
        }
        if decoderContainer.contains(.org)
        {
            self.org = try decoderContainer.decode(String?.self, forKey: .org)
        }
        if decoderContainer.contains(.userGroup)
        {
            self.userGroup = try decoderContainer.decode(Int?.self, forKey: .userGroup)
        }
        if decoderContainer.contains(.traderName)
        {
            self.traderName = try decoderContainer.decode(String?.self, forKey: .traderName)
        }
        if decoderContainer.contains(.orderType)
        {
            self.orderType = try decoderContainer.decode(String?.self, forKey: .orderType)
        }
        if decoderContainer.contains(.costFee)
        {
            self.costFee = try decoderContainer.decode(Double?.self, forKey: .costFee)
        }
        if decoderContainer.contains(.taxRate)
        {
            self.taxRate = try decoderContainer.decode(Double?.self, forKey: .taxRate)
        }
        if decoderContainer.contains(.deptNo)
        {
            self.deptNo = try decoderContainer.decode(String?.self, forKey: .deptNo)
        }
        if decoderContainer.contains(.sourceId)
        {
            self.sourceId = try decoderContainer.decode(String?.self, forKey: .sourceId)
        }
        if decoderContainer.contains(.code)
        {
            self.code = try decoderContainer.decode(Int?.self, forKey: .code)
        }
        if decoderContainer.contains(.message)
        {
            self.message = try decoderContainer.decode(String?.self, forKey: .message)
        }
    }
}
public extension EbsSeperateBillVo{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: EbsSeperateBillVoCodingKeys.self)
         try encoderContainer.encode(pin, forKey: .pin)
         try encoderContainer.encode(dataSourceId, forKey: .dataSourceId)
         try encoderContainer.encode(appCode, forKey: .appCode)
         try encoderContainer.encode(chargeTime, forKey: .chargeTime)
         try encoderContainer.encode(totalFee, forKey: .totalFee)
         try encoderContainer.encode(seperateFee, forKey: .seperateFee)
         try encoderContainer.encode(org, forKey: .org)
         try encoderContainer.encode(userGroup, forKey: .userGroup)
         try encoderContainer.encode(traderName, forKey: .traderName)
         try encoderContainer.encode(orderType, forKey: .orderType)
         try encoderContainer.encode(costFee, forKey: .costFee)
         try encoderContainer.encode(taxRate, forKey: .taxRate)
         try encoderContainer.encode(deptNo, forKey: .deptNo)
         try encoderContainer.encode(sourceId, forKey: .sourceId)
         try encoderContainer.encode(code, forKey: .code)
         try encoderContainer.encode(message, forKey: .message)
    }
}
///  ebsBillVoRequest
public class EbsBillVoRequest:NSObject,Codable{
    /// 核算账单列表
    var ebsBillVoList:[EbsBillVo?]?



    public override init(){
            super.init()
    }

    enum EbsBillVoRequestCodingKeys: String, CodingKey {
        case ebsBillVoList
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: EbsBillVoRequestCodingKeys.self)
        if decoderContainer.contains(.ebsBillVoList)
        {
            self.ebsBillVoList = try decoderContainer.decode([EbsBillVo?]?.self, forKey: .ebsBillVoList)
        }
    }
}
public extension EbsBillVoRequest{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: EbsBillVoRequestCodingKeys.self)
         try encoderContainer.encode(ebsBillVoList, forKey: .ebsBillVoList)
    }
}
///  orderPriceDetail
public class OrderPriceDetail:NSObject,Codable{
    /// 折扣前总价
    var price:Double?
    /// 四位小数价格
    var priceScale4:Double?
    /// 折扣金额
    var discount:Double?
    /// 折扣后订单金额
    var discountedPrice:Double?
    /// 订单原价 包年时 一年原价为12个月价格，totalPrice为10个月价格
    var originalPrice:Double?
    /// 资源id
    var resourceId:String?
    /// 业务线
    var appCode:String?
    /// 产品线
    var serviceCode:String?
    /// 站点  0:主站  其他:专有云
    var site:Int?
    /// 地域
    var region:String?
    /// 计费类型1:按配置2:按用量3:包年包月
    var billingType:Int?
    /// 时长
    var timeSpan:Int?
    /// 时长类型 1:小时2:天3:月4:年
    var timeUnit:Int?
    /// 网络类型 0:non1:非BGP2:BGP
    var networkOperator:Int?
    /// 配置信息
    var formula:[Formula?]?
    /// FavorableInfo转成json后的字符串
    var favorableInfo:String?
    /// 价格快照
    var priceSnapShot:String?
    /// 用户pin
    var pin:String?
    /// 自然单列表
    var taskId:String?
    /// 开始时间
    var startTime:String?
    /// 结束时间
    var endTime:String?
    /// 变配明细（1-升配补差价，2-降配延时，3-临时升配）
    var processType:Int?
    /// 交易单模块sourceId
    var sourceId:String?



    public override init(){
            super.init()
    }

    enum OrderPriceDetailCodingKeys: String, CodingKey {
        case price
        case priceScale4
        case discount
        case discountedPrice
        case originalPrice
        case resourceId
        case appCode
        case serviceCode
        case site
        case region
        case billingType
        case timeSpan
        case timeUnit
        case networkOperator
        case formula
        case favorableInfo
        case priceSnapShot
        case pin
        case taskId
        case startTime
        case endTime
        case processType
        case sourceId
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: OrderPriceDetailCodingKeys.self)
        if decoderContainer.contains(.price)
        {
            self.price = try decoderContainer.decode(Double?.self, forKey: .price)
        }
        if decoderContainer.contains(.priceScale4)
        {
            self.priceScale4 = try decoderContainer.decode(Double?.self, forKey: .priceScale4)
        }
        if decoderContainer.contains(.discount)
        {
            self.discount = try decoderContainer.decode(Double?.self, forKey: .discount)
        }
        if decoderContainer.contains(.discountedPrice)
        {
            self.discountedPrice = try decoderContainer.decode(Double?.self, forKey: .discountedPrice)
        }
        if decoderContainer.contains(.originalPrice)
        {
            self.originalPrice = try decoderContainer.decode(Double?.self, forKey: .originalPrice)
        }
        if decoderContainer.contains(.resourceId)
        {
            self.resourceId = try decoderContainer.decode(String?.self, forKey: .resourceId)
        }
        if decoderContainer.contains(.appCode)
        {
            self.appCode = try decoderContainer.decode(String?.self, forKey: .appCode)
        }
        if decoderContainer.contains(.serviceCode)
        {
            self.serviceCode = try decoderContainer.decode(String?.self, forKey: .serviceCode)
        }
        if decoderContainer.contains(.site)
        {
            self.site = try decoderContainer.decode(Int?.self, forKey: .site)
        }
        if decoderContainer.contains(.region)
        {
            self.region = try decoderContainer.decode(String?.self, forKey: .region)
        }
        if decoderContainer.contains(.billingType)
        {
            self.billingType = try decoderContainer.decode(Int?.self, forKey: .billingType)
        }
        if decoderContainer.contains(.timeSpan)
        {
            self.timeSpan = try decoderContainer.decode(Int?.self, forKey: .timeSpan)
        }
        if decoderContainer.contains(.timeUnit)
        {
            self.timeUnit = try decoderContainer.decode(Int?.self, forKey: .timeUnit)
        }
        if decoderContainer.contains(.networkOperator)
        {
            self.networkOperator = try decoderContainer.decode(Int?.self, forKey: .networkOperator)
        }
        if decoderContainer.contains(.formula)
        {
            self.formula = try decoderContainer.decode([Formula?]?.self, forKey: .formula)
        }
        if decoderContainer.contains(.favorableInfo)
        {
            self.favorableInfo = try decoderContainer.decode(String?.self, forKey: .favorableInfo)
        }
        if decoderContainer.contains(.priceSnapShot)
        {
            self.priceSnapShot = try decoderContainer.decode(String?.self, forKey: .priceSnapShot)
        }
        if decoderContainer.contains(.pin)
        {
            self.pin = try decoderContainer.decode(String?.self, forKey: .pin)
        }
        if decoderContainer.contains(.taskId)
        {
            self.taskId = try decoderContainer.decode(String?.self, forKey: .taskId)
        }
        if decoderContainer.contains(.startTime)
        {
            self.startTime = try decoderContainer.decode(String?.self, forKey: .startTime)
        }
        if decoderContainer.contains(.endTime)
        {
            self.endTime = try decoderContainer.decode(String?.self, forKey: .endTime)
        }
        if decoderContainer.contains(.processType)
        {
            self.processType = try decoderContainer.decode(Int?.self, forKey: .processType)
        }
        if decoderContainer.contains(.sourceId)
        {
            self.sourceId = try decoderContainer.decode(String?.self, forKey: .sourceId)
        }
    }
}
public extension OrderPriceDetail{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: OrderPriceDetailCodingKeys.self)
         try encoderContainer.encode(price, forKey: .price)
         try encoderContainer.encode(priceScale4, forKey: .priceScale4)
         try encoderContainer.encode(discount, forKey: .discount)
         try encoderContainer.encode(discountedPrice, forKey: .discountedPrice)
         try encoderContainer.encode(originalPrice, forKey: .originalPrice)
         try encoderContainer.encode(resourceId, forKey: .resourceId)
         try encoderContainer.encode(appCode, forKey: .appCode)
         try encoderContainer.encode(serviceCode, forKey: .serviceCode)
         try encoderContainer.encode(site, forKey: .site)
         try encoderContainer.encode(region, forKey: .region)
         try encoderContainer.encode(billingType, forKey: .billingType)
         try encoderContainer.encode(timeSpan, forKey: .timeSpan)
         try encoderContainer.encode(timeUnit, forKey: .timeUnit)
         try encoderContainer.encode(networkOperator, forKey: .networkOperator)
         try encoderContainer.encode(formula, forKey: .formula)
         try encoderContainer.encode(favorableInfo, forKey: .favorableInfo)
         try encoderContainer.encode(priceSnapShot, forKey: .priceSnapShot)
         try encoderContainer.encode(pin, forKey: .pin)
         try encoderContainer.encode(taskId, forKey: .taskId)
         try encoderContainer.encode(startTime, forKey: .startTime)
         try encoderContainer.encode(endTime, forKey: .endTime)
         try encoderContainer.encode(processType, forKey: .processType)
         try encoderContainer.encode(sourceId, forKey: .sourceId)
    }
}
///  orderCompensateFeeVo
public class OrderCompensateFeeVo:NSObject,Codable{
    /// 用户pin
    var pin:String?
    /// 应用码
    var appCode:String?
    /// 服务码
    var serviceCode:String?
    /// 资源id
    var resourceId:String?
    /// 资源区域
    var region:String?
    /// 开始时间
    var startTime:String?
    /// 结束时间
    var endTime:String?
    /// 计算总价
    var totalFee:Double?
    /// 计费类型 1:按配置 2:按用量 3:包年包月 4:一次性
    var billingType:Int?



    public override init(){
            super.init()
    }

    enum OrderCompensateFeeVoCodingKeys: String, CodingKey {
        case pin
        case appCode
        case serviceCode
        case resourceId
        case region
        case startTime
        case endTime
        case totalFee
        case billingType
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: OrderCompensateFeeVoCodingKeys.self)
        if decoderContainer.contains(.pin)
        {
            self.pin = try decoderContainer.decode(String?.self, forKey: .pin)
        }
        if decoderContainer.contains(.appCode)
        {
            self.appCode = try decoderContainer.decode(String?.self, forKey: .appCode)
        }
        if decoderContainer.contains(.serviceCode)
        {
            self.serviceCode = try decoderContainer.decode(String?.self, forKey: .serviceCode)
        }
        if decoderContainer.contains(.resourceId)
        {
            self.resourceId = try decoderContainer.decode(String?.self, forKey: .resourceId)
        }
        if decoderContainer.contains(.region)
        {
            self.region = try decoderContainer.decode(String?.self, forKey: .region)
        }
        if decoderContainer.contains(.startTime)
        {
            self.startTime = try decoderContainer.decode(String?.self, forKey: .startTime)
        }
        if decoderContainer.contains(.endTime)
        {
            self.endTime = try decoderContainer.decode(String?.self, forKey: .endTime)
        }
        if decoderContainer.contains(.totalFee)
        {
            self.totalFee = try decoderContainer.decode(Double?.self, forKey: .totalFee)
        }
        if decoderContainer.contains(.billingType)
        {
            self.billingType = try decoderContainer.decode(Int?.self, forKey: .billingType)
        }
    }
}
public extension OrderCompensateFeeVo{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: OrderCompensateFeeVoCodingKeys.self)
         try encoderContainer.encode(pin, forKey: .pin)
         try encoderContainer.encode(appCode, forKey: .appCode)
         try encoderContainer.encode(serviceCode, forKey: .serviceCode)
         try encoderContainer.encode(resourceId, forKey: .resourceId)
         try encoderContainer.encode(region, forKey: .region)
         try encoderContainer.encode(startTime, forKey: .startTime)
         try encoderContainer.encode(endTime, forKey: .endTime)
         try encoderContainer.encode(totalFee, forKey: .totalFee)
         try encoderContainer.encode(billingType, forKey: .billingType)
    }
}
///  orderPriceProtocol
public class OrderPriceProtocol:NSObject,Codable{
    /// 资源id
    var resourceId:String?
    /// 业务线
    var appCode:String?
    /// 产品线
    var serviceCode:String?
    /// 站点信息 0：主站  其他：专有云
    var site:Int?
    /// 地域
    var region:String?
    /// 计费类型 1:按配置 2:按用量 3:包年包月
    var billingType:Int?
    /// 时长
    var timeSpan:Int?
    /// 时长类型 0:无(非包年包月) 1:小时 2:天 3:月 4:年
    var timeUnit:Int?
    /// 网络类型 0:non 1:非BGP  2:BGP
    var networkOperator:Int?
    /// 计算公式（配置细项）
    var formula:[Formula?]?
    /// 配置细项
    var formulaStr:String?
    /// 用户pin
    var pin:String?
    /// 具体商品数量，默认为1
    var count:Int?
    /// 订单开始时间
    var startTime:String?
    /// 临时升配结束时间,临时升配时必传
    var endTime:String?
    /// 自然单列表
    var taskId:String?
    /// 交易单模块sourceId
    var sourceId:String?



    public override init(){
            super.init()
    }

    enum OrderPriceProtocolCodingKeys: String, CodingKey {
        case resourceId
        case appCode
        case serviceCode
        case site
        case region
        case billingType
        case timeSpan
        case timeUnit
        case networkOperator
        case formula
        case formulaStr
        case pin
        case count
        case startTime
        case endTime
        case taskId
        case sourceId
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: OrderPriceProtocolCodingKeys.self)
        if decoderContainer.contains(.resourceId)
        {
            self.resourceId = try decoderContainer.decode(String?.self, forKey: .resourceId)
        }
        if decoderContainer.contains(.appCode)
        {
            self.appCode = try decoderContainer.decode(String?.self, forKey: .appCode)
        }
        if decoderContainer.contains(.serviceCode)
        {
            self.serviceCode = try decoderContainer.decode(String?.self, forKey: .serviceCode)
        }
        if decoderContainer.contains(.site)
        {
            self.site = try decoderContainer.decode(Int?.self, forKey: .site)
        }
        if decoderContainer.contains(.region)
        {
            self.region = try decoderContainer.decode(String?.self, forKey: .region)
        }
        if decoderContainer.contains(.billingType)
        {
            self.billingType = try decoderContainer.decode(Int?.self, forKey: .billingType)
        }
        if decoderContainer.contains(.timeSpan)
        {
            self.timeSpan = try decoderContainer.decode(Int?.self, forKey: .timeSpan)
        }
        if decoderContainer.contains(.timeUnit)
        {
            self.timeUnit = try decoderContainer.decode(Int?.self, forKey: .timeUnit)
        }
        if decoderContainer.contains(.networkOperator)
        {
            self.networkOperator = try decoderContainer.decode(Int?.self, forKey: .networkOperator)
        }
        if decoderContainer.contains(.formula)
        {
            self.formula = try decoderContainer.decode([Formula?]?.self, forKey: .formula)
        }
        if decoderContainer.contains(.formulaStr)
        {
            self.formulaStr = try decoderContainer.decode(String?.self, forKey: .formulaStr)
        }
        if decoderContainer.contains(.pin)
        {
            self.pin = try decoderContainer.decode(String?.self, forKey: .pin)
        }
        if decoderContainer.contains(.count)
        {
            self.count = try decoderContainer.decode(Int?.self, forKey: .count)
        }
        if decoderContainer.contains(.startTime)
        {
            self.startTime = try decoderContainer.decode(String?.self, forKey: .startTime)
        }
        if decoderContainer.contains(.endTime)
        {
            self.endTime = try decoderContainer.decode(String?.self, forKey: .endTime)
        }
        if decoderContainer.contains(.taskId)
        {
            self.taskId = try decoderContainer.decode(String?.self, forKey: .taskId)
        }
        if decoderContainer.contains(.sourceId)
        {
            self.sourceId = try decoderContainer.decode(String?.self, forKey: .sourceId)
        }
    }
}
public extension OrderPriceProtocol{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: OrderPriceProtocolCodingKeys.self)
         try encoderContainer.encode(resourceId, forKey: .resourceId)
         try encoderContainer.encode(appCode, forKey: .appCode)
         try encoderContainer.encode(serviceCode, forKey: .serviceCode)
         try encoderContainer.encode(site, forKey: .site)
         try encoderContainer.encode(region, forKey: .region)
         try encoderContainer.encode(billingType, forKey: .billingType)
         try encoderContainer.encode(timeSpan, forKey: .timeSpan)
         try encoderContainer.encode(timeUnit, forKey: .timeUnit)
         try encoderContainer.encode(networkOperator, forKey: .networkOperator)
         try encoderContainer.encode(formula, forKey: .formula)
         try encoderContainer.encode(formulaStr, forKey: .formulaStr)
         try encoderContainer.encode(pin, forKey: .pin)
         try encoderContainer.encode(count, forKey: .count)
         try encoderContainer.encode(startTime, forKey: .startTime)
         try encoderContainer.encode(endTime, forKey: .endTime)
         try encoderContainer.encode(taskId, forKey: .taskId)
         try encoderContainer.encode(sourceId, forKey: .sourceId)
    }
}
///  resourceTagVo
public class ResourceTagVo:NSObject,Codable{
    /// 标签键
    var tagKey:String?
    /// 标签值
    var tagValue:String?



    public override init(){
            super.init()
    }

    enum ResourceTagVoCodingKeys: String, CodingKey {
        case tagKey
        case tagValue
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: ResourceTagVoCodingKeys.self)
        if decoderContainer.contains(.tagKey)
        {
            self.tagKey = try decoderContainer.decode(String?.self, forKey: .tagKey)
        }
        if decoderContainer.contains(.tagValue)
        {
            self.tagValue = try decoderContainer.decode(String?.self, forKey: .tagValue)
        }
    }
}
public extension ResourceTagVo{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: ResourceTagVoCodingKeys.self)
         try encoderContainer.encode(tagKey, forKey: .tagKey)
         try encoderContainer.encode(tagValue, forKey: .tagValue)
    }
}
///  billSummary
public class BillSummary:NSObject,Codable{
    /// 用户pin
    var pin:String?
    /// appCode
    var appCode:String?
    /// 产品线代码名称
    var appCodeName:String?
    /// serviceCode
    var serviceCode:String?
    /// 产品代码名称
    var serviceCodeName:String?
    /// 计费类型
    var billingType:Int?
    /// 计费类型描述
    var billingTypeName:String?
    /// 资源id
    var resourceId:String?
    /// 资源名称
    var resourceName:String?
    /// 区域
    var region:String?
    /// 费用类型
    var actionTypeName:String?
    /// 规格
    var formula:String?
    /// 计费开始时间
    var startTime:String?
    /// 计费结束时间
    var endTime:String?
    /// 账单生成时间
    var billTime:String?
    /// 账单总额
    var totalFee:Double?
    /// 优惠金额
    var discountFee:Double?
    /// 优惠后总价金额
    var realTotalFee:Double?
    /// 代金券支付金额
    var cashCouponPayFee:Double?
    /// 余额支付金额
    var balancePayFee:Double?
    /// 现金支付金额
    var cashPayFee:Double?
    /// 欠费金额
    var arrearFee:Double?
    /// 标签明细
    var tagDetails:[ResourceTagVo?]?



    public override init(){
            super.init()
    }

    enum BillSummaryCodingKeys: String, CodingKey {
        case pin
        case appCode
        case appCodeName
        case serviceCode
        case serviceCodeName
        case billingType
        case billingTypeName
        case resourceId
        case resourceName
        case region
        case actionTypeName
        case formula
        case startTime
        case endTime
        case billTime
        case totalFee
        case discountFee
        case realTotalFee
        case cashCouponPayFee
        case balancePayFee
        case cashPayFee
        case arrearFee
        case tagDetails
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: BillSummaryCodingKeys.self)
        if decoderContainer.contains(.pin)
        {
            self.pin = try decoderContainer.decode(String?.self, forKey: .pin)
        }
        if decoderContainer.contains(.appCode)
        {
            self.appCode = try decoderContainer.decode(String?.self, forKey: .appCode)
        }
        if decoderContainer.contains(.appCodeName)
        {
            self.appCodeName = try decoderContainer.decode(String?.self, forKey: .appCodeName)
        }
        if decoderContainer.contains(.serviceCode)
        {
            self.serviceCode = try decoderContainer.decode(String?.self, forKey: .serviceCode)
        }
        if decoderContainer.contains(.serviceCodeName)
        {
            self.serviceCodeName = try decoderContainer.decode(String?.self, forKey: .serviceCodeName)
        }
        if decoderContainer.contains(.billingType)
        {
            self.billingType = try decoderContainer.decode(Int?.self, forKey: .billingType)
        }
        if decoderContainer.contains(.billingTypeName)
        {
            self.billingTypeName = try decoderContainer.decode(String?.self, forKey: .billingTypeName)
        }
        if decoderContainer.contains(.resourceId)
        {
            self.resourceId = try decoderContainer.decode(String?.self, forKey: .resourceId)
        }
        if decoderContainer.contains(.resourceName)
        {
            self.resourceName = try decoderContainer.decode(String?.self, forKey: .resourceName)
        }
        if decoderContainer.contains(.region)
        {
            self.region = try decoderContainer.decode(String?.self, forKey: .region)
        }
        if decoderContainer.contains(.actionTypeName)
        {
            self.actionTypeName = try decoderContainer.decode(String?.self, forKey: .actionTypeName)
        }
        if decoderContainer.contains(.formula)
        {
            self.formula = try decoderContainer.decode(String?.self, forKey: .formula)
        }
        if decoderContainer.contains(.startTime)
        {
            self.startTime = try decoderContainer.decode(String?.self, forKey: .startTime)
        }
        if decoderContainer.contains(.endTime)
        {
            self.endTime = try decoderContainer.decode(String?.self, forKey: .endTime)
        }
        if decoderContainer.contains(.billTime)
        {
            self.billTime = try decoderContainer.decode(String?.self, forKey: .billTime)
        }
        if decoderContainer.contains(.totalFee)
        {
            self.totalFee = try decoderContainer.decode(Double?.self, forKey: .totalFee)
        }
        if decoderContainer.contains(.discountFee)
        {
            self.discountFee = try decoderContainer.decode(Double?.self, forKey: .discountFee)
        }
        if decoderContainer.contains(.realTotalFee)
        {
            self.realTotalFee = try decoderContainer.decode(Double?.self, forKey: .realTotalFee)
        }
        if decoderContainer.contains(.cashCouponPayFee)
        {
            self.cashCouponPayFee = try decoderContainer.decode(Double?.self, forKey: .cashCouponPayFee)
        }
        if decoderContainer.contains(.balancePayFee)
        {
            self.balancePayFee = try decoderContainer.decode(Double?.self, forKey: .balancePayFee)
        }
        if decoderContainer.contains(.cashPayFee)
        {
            self.cashPayFee = try decoderContainer.decode(Double?.self, forKey: .cashPayFee)
        }
        if decoderContainer.contains(.arrearFee)
        {
            self.arrearFee = try decoderContainer.decode(Double?.self, forKey: .arrearFee)
        }
        if decoderContainer.contains(.tagDetails)
        {
            self.tagDetails = try decoderContainer.decode([ResourceTagVo?]?.self, forKey: .tagDetails)
        }
    }
}
public extension BillSummary{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: BillSummaryCodingKeys.self)
         try encoderContainer.encode(pin, forKey: .pin)
         try encoderContainer.encode(appCode, forKey: .appCode)
         try encoderContainer.encode(appCodeName, forKey: .appCodeName)
         try encoderContainer.encode(serviceCode, forKey: .serviceCode)
         try encoderContainer.encode(serviceCodeName, forKey: .serviceCodeName)
         try encoderContainer.encode(billingType, forKey: .billingType)
         try encoderContainer.encode(billingTypeName, forKey: .billingTypeName)
         try encoderContainer.encode(resourceId, forKey: .resourceId)
         try encoderContainer.encode(resourceName, forKey: .resourceName)
         try encoderContainer.encode(region, forKey: .region)
         try encoderContainer.encode(actionTypeName, forKey: .actionTypeName)
         try encoderContainer.encode(formula, forKey: .formula)
         try encoderContainer.encode(startTime, forKey: .startTime)
         try encoderContainer.encode(endTime, forKey: .endTime)
         try encoderContainer.encode(billTime, forKey: .billTime)
         try encoderContainer.encode(totalFee, forKey: .totalFee)
         try encoderContainer.encode(discountFee, forKey: .discountFee)
         try encoderContainer.encode(realTotalFee, forKey: .realTotalFee)
         try encoderContainer.encode(cashCouponPayFee, forKey: .cashCouponPayFee)
         try encoderContainer.encode(balancePayFee, forKey: .balancePayFee)
         try encoderContainer.encode(cashPayFee, forKey: .cashPayFee)
         try encoderContainer.encode(arrearFee, forKey: .arrearFee)
         try encoderContainer.encode(tagDetails, forKey: .tagDetails)
    }
}
///  consumptionProduct
public class ConsumptionProduct:NSObject,Codable{
    /// appCode
    var appCode:String?
    /// appCodeName
    var appCodeName:String?
    /// serviceCode
    var serviceCode:String?
    /// serviceCodeName
    var serviceCodeName:String?
    /// 优惠后金额
    var actualFee:Double?
    /// 现金支付
    var cashPayFee:Double?
    /// 余额支付
    var balancePayFee:Double?
    /// 代金券支付金额
    var cashCouponPayFee:Double?
    /// 欠费金额
    var arrearFee:Double?
    /// ProductDetails
    var productDetails:[Consumption?]?
    /// ProductDetailList
    var productDetailList:ProductDetailList?
    /// 分组显示值
    var groupTagValue:String?



    public override init(){
            super.init()
    }

    enum ConsumptionProductCodingKeys: String, CodingKey {
        case appCode
        case appCodeName
        case serviceCode
        case serviceCodeName
        case actualFee
        case cashPayFee
        case balancePayFee
        case cashCouponPayFee
        case arrearFee
        case productDetails
        case productDetailList
        case groupTagValue
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: ConsumptionProductCodingKeys.self)
        if decoderContainer.contains(.appCode)
        {
            self.appCode = try decoderContainer.decode(String?.self, forKey: .appCode)
        }
        if decoderContainer.contains(.appCodeName)
        {
            self.appCodeName = try decoderContainer.decode(String?.self, forKey: .appCodeName)
        }
        if decoderContainer.contains(.serviceCode)
        {
            self.serviceCode = try decoderContainer.decode(String?.self, forKey: .serviceCode)
        }
        if decoderContainer.contains(.serviceCodeName)
        {
            self.serviceCodeName = try decoderContainer.decode(String?.self, forKey: .serviceCodeName)
        }
        if decoderContainer.contains(.actualFee)
        {
            self.actualFee = try decoderContainer.decode(Double?.self, forKey: .actualFee)
        }
        if decoderContainer.contains(.cashPayFee)
        {
            self.cashPayFee = try decoderContainer.decode(Double?.self, forKey: .cashPayFee)
        }
        if decoderContainer.contains(.balancePayFee)
        {
            self.balancePayFee = try decoderContainer.decode(Double?.self, forKey: .balancePayFee)
        }
        if decoderContainer.contains(.cashCouponPayFee)
        {
            self.cashCouponPayFee = try decoderContainer.decode(Double?.self, forKey: .cashCouponPayFee)
        }
        if decoderContainer.contains(.arrearFee)
        {
            self.arrearFee = try decoderContainer.decode(Double?.self, forKey: .arrearFee)
        }
        if decoderContainer.contains(.productDetails)
        {
            self.productDetails = try decoderContainer.decode([Consumption?]?.self, forKey: .productDetails)
        }
        if decoderContainer.contains(.productDetailList)
        {
            self.productDetailList = try decoderContainer.decode(ProductDetailList?.self, forKey: .productDetailList)
        }
        if decoderContainer.contains(.groupTagValue)
        {
            self.groupTagValue = try decoderContainer.decode(String?.self, forKey: .groupTagValue)
        }
    }
}
public extension ConsumptionProduct{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: ConsumptionProductCodingKeys.self)
         try encoderContainer.encode(appCode, forKey: .appCode)
         try encoderContainer.encode(appCodeName, forKey: .appCodeName)
         try encoderContainer.encode(serviceCode, forKey: .serviceCode)
         try encoderContainer.encode(serviceCodeName, forKey: .serviceCodeName)
         try encoderContainer.encode(actualFee, forKey: .actualFee)
         try encoderContainer.encode(cashPayFee, forKey: .cashPayFee)
         try encoderContainer.encode(balancePayFee, forKey: .balancePayFee)
         try encoderContainer.encode(cashCouponPayFee, forKey: .cashCouponPayFee)
         try encoderContainer.encode(arrearFee, forKey: .arrearFee)
         try encoderContainer.encode(productDetails, forKey: .productDetails)
         try encoderContainer.encode(productDetailList, forKey: .productDetailList)
         try encoderContainer.encode(groupTagValue, forKey: .groupTagValue)
    }
}
///  consumeBillQueryResultItem
public class ConsumeBillQueryResultItem:NSObject,Codable{
    /// 账单id
    var billId:Double?
    /// 用户pin
    var pin:String?
    /// appCode
    var appCode:String?
    /// appCodeName
    var appCodeName:String?
    /// serviceCode
    var serviceCode:String?
    /// serviceCodeName
    var serviceCodeName:String?
    /// 资源id
    var resourceId:String?
    /// 计费类型
    var billingType:Int?
    /// 计费类型描述
    var billingTypeName:String?
    /// 账单开始时间
    var billStart:String?
    /// 账单结束时间
    var billEnd:String?
    /// 结算时间
    var settleTime:String?
    /// 账单日期
    var billTime:String?
    /// 账单金额
    var billFee:Double?
    /// 账单总额
    var totalFee:Double?
    /// 现金支付金额
    var cashPayFee:Double?
    /// 代金券支付金额
    var cashCouponPayFee:Double?
    /// 余额支付金额
    var balancePayFee:Double?
    /// 折扣金额
    var discountFee:Double?
    /// 欠费金额
    var arrearFee:Double?
    /// 支付状态
    var payState:Int?
    /// 创建时间
    var createTime:String?
    /// 新老计费标识（1:老计费   2：新计费）
    var systemType:Int?
    /// 区域
    var region:String?
    /// 规格
    var formula:String?
    /// 规格
    var formulaStr:String?
    /// 标签明细
    var tagDetails:[ResourceTagVo?]?



    public override init(){
            super.init()
    }

    enum ConsumeBillQueryResultItemCodingKeys: String, CodingKey {
        case billId
        case pin
        case appCode
        case appCodeName
        case serviceCode
        case serviceCodeName
        case resourceId
        case billingType
        case billingTypeName
        case billStart
        case billEnd
        case settleTime
        case billTime
        case billFee
        case totalFee
        case cashPayFee
        case cashCouponPayFee
        case balancePayFee
        case discountFee
        case arrearFee
        case payState
        case createTime
        case systemType
        case region
        case formula
        case formulaStr
        case tagDetails
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: ConsumeBillQueryResultItemCodingKeys.self)
        if decoderContainer.contains(.billId)
        {
            self.billId = try decoderContainer.decode(Double?.self, forKey: .billId)
        }
        if decoderContainer.contains(.pin)
        {
            self.pin = try decoderContainer.decode(String?.self, forKey: .pin)
        }
        if decoderContainer.contains(.appCode)
        {
            self.appCode = try decoderContainer.decode(String?.self, forKey: .appCode)
        }
        if decoderContainer.contains(.appCodeName)
        {
            self.appCodeName = try decoderContainer.decode(String?.self, forKey: .appCodeName)
        }
        if decoderContainer.contains(.serviceCode)
        {
            self.serviceCode = try decoderContainer.decode(String?.self, forKey: .serviceCode)
        }
        if decoderContainer.contains(.serviceCodeName)
        {
            self.serviceCodeName = try decoderContainer.decode(String?.self, forKey: .serviceCodeName)
        }
        if decoderContainer.contains(.resourceId)
        {
            self.resourceId = try decoderContainer.decode(String?.self, forKey: .resourceId)
        }
        if decoderContainer.contains(.billingType)
        {
            self.billingType = try decoderContainer.decode(Int?.self, forKey: .billingType)
        }
        if decoderContainer.contains(.billingTypeName)
        {
            self.billingTypeName = try decoderContainer.decode(String?.self, forKey: .billingTypeName)
        }
        if decoderContainer.contains(.billStart)
        {
            self.billStart = try decoderContainer.decode(String?.self, forKey: .billStart)
        }
        if decoderContainer.contains(.billEnd)
        {
            self.billEnd = try decoderContainer.decode(String?.self, forKey: .billEnd)
        }
        if decoderContainer.contains(.settleTime)
        {
            self.settleTime = try decoderContainer.decode(String?.self, forKey: .settleTime)
        }
        if decoderContainer.contains(.billTime)
        {
            self.billTime = try decoderContainer.decode(String?.self, forKey: .billTime)
        }
        if decoderContainer.contains(.billFee)
        {
            self.billFee = try decoderContainer.decode(Double?.self, forKey: .billFee)
        }
        if decoderContainer.contains(.totalFee)
        {
            self.totalFee = try decoderContainer.decode(Double?.self, forKey: .totalFee)
        }
        if decoderContainer.contains(.cashPayFee)
        {
            self.cashPayFee = try decoderContainer.decode(Double?.self, forKey: .cashPayFee)
        }
        if decoderContainer.contains(.cashCouponPayFee)
        {
            self.cashCouponPayFee = try decoderContainer.decode(Double?.self, forKey: .cashCouponPayFee)
        }
        if decoderContainer.contains(.balancePayFee)
        {
            self.balancePayFee = try decoderContainer.decode(Double?.self, forKey: .balancePayFee)
        }
        if decoderContainer.contains(.discountFee)
        {
            self.discountFee = try decoderContainer.decode(Double?.self, forKey: .discountFee)
        }
        if decoderContainer.contains(.arrearFee)
        {
            self.arrearFee = try decoderContainer.decode(Double?.self, forKey: .arrearFee)
        }
        if decoderContainer.contains(.payState)
        {
            self.payState = try decoderContainer.decode(Int?.self, forKey: .payState)
        }
        if decoderContainer.contains(.createTime)
        {
            self.createTime = try decoderContainer.decode(String?.self, forKey: .createTime)
        }
        if decoderContainer.contains(.systemType)
        {
            self.systemType = try decoderContainer.decode(Int?.self, forKey: .systemType)
        }
        if decoderContainer.contains(.region)
        {
            self.region = try decoderContainer.decode(String?.self, forKey: .region)
        }
        if decoderContainer.contains(.formula)
        {
            self.formula = try decoderContainer.decode(String?.self, forKey: .formula)
        }
        if decoderContainer.contains(.formulaStr)
        {
            self.formulaStr = try decoderContainer.decode(String?.self, forKey: .formulaStr)
        }
        if decoderContainer.contains(.tagDetails)
        {
            self.tagDetails = try decoderContainer.decode([ResourceTagVo?]?.self, forKey: .tagDetails)
        }
    }
}
public extension ConsumeBillQueryResultItem{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: ConsumeBillQueryResultItemCodingKeys.self)
         try encoderContainer.encode(billId, forKey: .billId)
         try encoderContainer.encode(pin, forKey: .pin)
         try encoderContainer.encode(appCode, forKey: .appCode)
         try encoderContainer.encode(appCodeName, forKey: .appCodeName)
         try encoderContainer.encode(serviceCode, forKey: .serviceCode)
         try encoderContainer.encode(serviceCodeName, forKey: .serviceCodeName)
         try encoderContainer.encode(resourceId, forKey: .resourceId)
         try encoderContainer.encode(billingType, forKey: .billingType)
         try encoderContainer.encode(billingTypeName, forKey: .billingTypeName)
         try encoderContainer.encode(billStart, forKey: .billStart)
         try encoderContainer.encode(billEnd, forKey: .billEnd)
         try encoderContainer.encode(settleTime, forKey: .settleTime)
         try encoderContainer.encode(billTime, forKey: .billTime)
         try encoderContainer.encode(billFee, forKey: .billFee)
         try encoderContainer.encode(totalFee, forKey: .totalFee)
         try encoderContainer.encode(cashPayFee, forKey: .cashPayFee)
         try encoderContainer.encode(cashCouponPayFee, forKey: .cashCouponPayFee)
         try encoderContainer.encode(balancePayFee, forKey: .balancePayFee)
         try encoderContainer.encode(discountFee, forKey: .discountFee)
         try encoderContainer.encode(arrearFee, forKey: .arrearFee)
         try encoderContainer.encode(payState, forKey: .payState)
         try encoderContainer.encode(createTime, forKey: .createTime)
         try encoderContainer.encode(systemType, forKey: .systemType)
         try encoderContainer.encode(region, forKey: .region)
         try encoderContainer.encode(formula, forKey: .formula)
         try encoderContainer.encode(formulaStr, forKey: .formulaStr)
         try encoderContainer.encode(tagDetails, forKey: .tagDetails)
    }
}
///  consumeRecord
public class ConsumeRecord:NSObject,Codable{
    /// 消费记录数据库唯一id
    var id:Double?
    /// 消费记录id
    var billingRecordId:Int?
    /// appCode
    var appCode:String?
    /// serviceCode
    var serviceCode:String?
    /// 区域
    var region:String?
    /// 资源id
    var resourceId:String?
    /// 用户pin
    var pin:String?
    /// 规格
    var formula:String?
    /// 计费类型
    var billingType:Int?
    /// 价格快照
    var priceSnapShot:String?
    /// 开始时间
    var startTime:String?
    /// 结束时间
    var endTime:String?
    /// 创建日期
    var createTime:String?
    /// 账单金额
    var billFee:Double?
    /// 账单金额保留小数点后2位
    var billFee2:Double?
    /// 折扣金额
    var discountFee:Double?
    /// 优惠券id
    var couponId:String?
    /// 优惠金额
    var couponFee:Double?
    /// 交易单号
    var transactionNo:String?
    /// null
    var isBillGenerated:Int?
    /// 子账单id
    var subBillId:Double?
    /// 退款单号
    var refundNo:String?
    /// 优惠后金额
    var actualFee:Double?
    /// 规格名称
    var formulaName:String?



    public override init(){
            super.init()
    }

    enum ConsumeRecordCodingKeys: String, CodingKey {
        case id
        case billingRecordId
        case appCode
        case serviceCode
        case region
        case resourceId
        case pin
        case formula
        case billingType
        case priceSnapShot
        case startTime
        case endTime
        case createTime
        case billFee
        case billFee2
        case discountFee
        case couponId
        case couponFee
        case transactionNo
        case isBillGenerated
        case subBillId
        case refundNo
        case actualFee
        case formulaName
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: ConsumeRecordCodingKeys.self)
        if decoderContainer.contains(.id)
        {
            self.id = try decoderContainer.decode(Double?.self, forKey: .id)
        }
        if decoderContainer.contains(.billingRecordId)
        {
            self.billingRecordId = try decoderContainer.decode(Int?.self, forKey: .billingRecordId)
        }
        if decoderContainer.contains(.appCode)
        {
            self.appCode = try decoderContainer.decode(String?.self, forKey: .appCode)
        }
        if decoderContainer.contains(.serviceCode)
        {
            self.serviceCode = try decoderContainer.decode(String?.self, forKey: .serviceCode)
        }
        if decoderContainer.contains(.region)
        {
            self.region = try decoderContainer.decode(String?.self, forKey: .region)
        }
        if decoderContainer.contains(.resourceId)
        {
            self.resourceId = try decoderContainer.decode(String?.self, forKey: .resourceId)
        }
        if decoderContainer.contains(.pin)
        {
            self.pin = try decoderContainer.decode(String?.self, forKey: .pin)
        }
        if decoderContainer.contains(.formula)
        {
            self.formula = try decoderContainer.decode(String?.self, forKey: .formula)
        }
        if decoderContainer.contains(.billingType)
        {
            self.billingType = try decoderContainer.decode(Int?.self, forKey: .billingType)
        }
        if decoderContainer.contains(.priceSnapShot)
        {
            self.priceSnapShot = try decoderContainer.decode(String?.self, forKey: .priceSnapShot)
        }
        if decoderContainer.contains(.startTime)
        {
            self.startTime = try decoderContainer.decode(String?.self, forKey: .startTime)
        }
        if decoderContainer.contains(.endTime)
        {
            self.endTime = try decoderContainer.decode(String?.self, forKey: .endTime)
        }
        if decoderContainer.contains(.createTime)
        {
            self.createTime = try decoderContainer.decode(String?.self, forKey: .createTime)
        }
        if decoderContainer.contains(.billFee)
        {
            self.billFee = try decoderContainer.decode(Double?.self, forKey: .billFee)
        }
        if decoderContainer.contains(.billFee2)
        {
            self.billFee2 = try decoderContainer.decode(Double?.self, forKey: .billFee2)
        }
        if decoderContainer.contains(.discountFee)
        {
            self.discountFee = try decoderContainer.decode(Double?.self, forKey: .discountFee)
        }
        if decoderContainer.contains(.couponId)
        {
            self.couponId = try decoderContainer.decode(String?.self, forKey: .couponId)
        }
        if decoderContainer.contains(.couponFee)
        {
            self.couponFee = try decoderContainer.decode(Double?.self, forKey: .couponFee)
        }
        if decoderContainer.contains(.transactionNo)
        {
            self.transactionNo = try decoderContainer.decode(String?.self, forKey: .transactionNo)
        }
        if decoderContainer.contains(.isBillGenerated)
        {
            self.isBillGenerated = try decoderContainer.decode(Int?.self, forKey: .isBillGenerated)
        }
        if decoderContainer.contains(.subBillId)
        {
            self.subBillId = try decoderContainer.decode(Double?.self, forKey: .subBillId)
        }
        if decoderContainer.contains(.refundNo)
        {
            self.refundNo = try decoderContainer.decode(String?.self, forKey: .refundNo)
        }
        if decoderContainer.contains(.actualFee)
        {
            self.actualFee = try decoderContainer.decode(Double?.self, forKey: .actualFee)
        }
        if decoderContainer.contains(.formulaName)
        {
            self.formulaName = try decoderContainer.decode(String?.self, forKey: .formulaName)
        }
    }
}
public extension ConsumeRecord{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: ConsumeRecordCodingKeys.self)
         try encoderContainer.encode(id, forKey: .id)
         try encoderContainer.encode(billingRecordId, forKey: .billingRecordId)
         try encoderContainer.encode(appCode, forKey: .appCode)
         try encoderContainer.encode(serviceCode, forKey: .serviceCode)
         try encoderContainer.encode(region, forKey: .region)
         try encoderContainer.encode(resourceId, forKey: .resourceId)
         try encoderContainer.encode(pin, forKey: .pin)
         try encoderContainer.encode(formula, forKey: .formula)
         try encoderContainer.encode(billingType, forKey: .billingType)
         try encoderContainer.encode(priceSnapShot, forKey: .priceSnapShot)
         try encoderContainer.encode(startTime, forKey: .startTime)
         try encoderContainer.encode(endTime, forKey: .endTime)
         try encoderContainer.encode(createTime, forKey: .createTime)
         try encoderContainer.encode(billFee, forKey: .billFee)
         try encoderContainer.encode(billFee2, forKey: .billFee2)
         try encoderContainer.encode(discountFee, forKey: .discountFee)
         try encoderContainer.encode(couponId, forKey: .couponId)
         try encoderContainer.encode(couponFee, forKey: .couponFee)
         try encoderContainer.encode(transactionNo, forKey: .transactionNo)
         try encoderContainer.encode(isBillGenerated, forKey: .isBillGenerated)
         try encoderContainer.encode(subBillId, forKey: .subBillId)
         try encoderContainer.encode(refundNo, forKey: .refundNo)
         try encoderContainer.encode(actualFee, forKey: .actualFee)
         try encoderContainer.encode(formulaName, forKey: .formulaName)
    }
}
///  consumption
public class Consumption:NSObject,Codable{
    /// 计费类型
    var billingType:Int?
    /// 支付类型
    var payType:Int?
    /// 优惠后金额
    var actualFee:Double?
    /// 现金支付
    var cashPayFee:Double?
    /// 余额支付
    var balancePayFee:Double?
    /// 优惠券支付金额
    var cashCouponPayFee:Double?
    /// 欠费金额
    var arrearFee:Double?
    /// 分组显示值
    var groupTagValue:String?



    public override init(){
            super.init()
    }

    enum ConsumptionCodingKeys: String, CodingKey {
        case billingType
        case payType
        case actualFee
        case cashPayFee
        case balancePayFee
        case cashCouponPayFee
        case arrearFee
        case groupTagValue
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: ConsumptionCodingKeys.self)
        if decoderContainer.contains(.billingType)
        {
            self.billingType = try decoderContainer.decode(Int?.self, forKey: .billingType)
        }
        if decoderContainer.contains(.payType)
        {
            self.payType = try decoderContainer.decode(Int?.self, forKey: .payType)
        }
        if decoderContainer.contains(.actualFee)
        {
            self.actualFee = try decoderContainer.decode(Double?.self, forKey: .actualFee)
        }
        if decoderContainer.contains(.cashPayFee)
        {
            self.cashPayFee = try decoderContainer.decode(Double?.self, forKey: .cashPayFee)
        }
        if decoderContainer.contains(.balancePayFee)
        {
            self.balancePayFee = try decoderContainer.decode(Double?.self, forKey: .balancePayFee)
        }
        if decoderContainer.contains(.cashCouponPayFee)
        {
            self.cashCouponPayFee = try decoderContainer.decode(Double?.self, forKey: .cashCouponPayFee)
        }
        if decoderContainer.contains(.arrearFee)
        {
            self.arrearFee = try decoderContainer.decode(Double?.self, forKey: .arrearFee)
        }
        if decoderContainer.contains(.groupTagValue)
        {
            self.groupTagValue = try decoderContainer.decode(String?.self, forKey: .groupTagValue)
        }
    }
}
public extension Consumption{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: ConsumptionCodingKeys.self)
         try encoderContainer.encode(billingType, forKey: .billingType)
         try encoderContainer.encode(payType, forKey: .payType)
         try encoderContainer.encode(actualFee, forKey: .actualFee)
         try encoderContainer.encode(cashPayFee, forKey: .cashPayFee)
         try encoderContainer.encode(balancePayFee, forKey: .balancePayFee)
         try encoderContainer.encode(cashCouponPayFee, forKey: .cashCouponPayFee)
         try encoderContainer.encode(arrearFee, forKey: .arrearFee)
         try encoderContainer.encode(groupTagValue, forKey: .groupTagValue)
    }
}
///  resourceBillQueryResultItem
public class ResourceBillQueryResultItem:NSObject,Codable{
    /// 账单id
    var billId:Double?
    /// 用户pin
    var pin:String?
    /// appCode
    var appCode:String?
    /// serviceCode
    var serviceCode:String?
    /// serviceCodeName
    var serviceCodeName:String?
    /// 计费类型
    var billingType:Int?
    /// 计费类型描述
    var billingTypeName:String?
    /// 资源id
    var resourceId:String?
    /// 区域
    var region:String?
    /// 区域名称
    var regionName:String?
    /// 账单开始时间
    var billStartTime:String?
    /// 账单结束时间
    var billEndTime:String?
    /// 开始时间
    var startTime:String?
    /// 结束时间
    var endTime:String?
    /// 总金额
    var totalFee:Double?
    /// 现金支付金额
    var cashPayFee:Double?
    /// 代金券支付金额
    var cashCouponPayFee:Double?
    /// 余额支付金额
    var balancePayFee:Double?
    /// 欠费金额
    var arrearFee:Double?
    /// 时间
    var timeSpan:Int?
    /// 时间单位
    var timeUnit:Int?
    /// 1：新购 2：续费 3：配置变更
    var opTypeName:String?
    /// 时间
    var timeSpanName:String?
    /// 时间单位名称 1：小时 2：天 3：月 4：年
    var timeUnitName:String?
    /// 结算日期
    var settleTime:String?
    /// 1：老计费 2：新计费
    var systemType:Int?
    /// 资源名称
    var resourceName:String?
    /// 标签明细
    var tagDetails:[ResourceTagVo?]?



    public override init(){
            super.init()
    }

    enum ResourceBillQueryResultItemCodingKeys: String, CodingKey {
        case billId
        case pin
        case appCode
        case serviceCode
        case serviceCodeName
        case billingType
        case billingTypeName
        case resourceId
        case region
        case regionName
        case billStartTime
        case billEndTime
        case startTime
        case endTime
        case totalFee
        case cashPayFee
        case cashCouponPayFee
        case balancePayFee
        case arrearFee
        case timeSpan
        case timeUnit
        case opTypeName
        case timeSpanName
        case timeUnitName
        case settleTime
        case systemType
        case resourceName
        case tagDetails
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: ResourceBillQueryResultItemCodingKeys.self)
        if decoderContainer.contains(.billId)
        {
            self.billId = try decoderContainer.decode(Double?.self, forKey: .billId)
        }
        if decoderContainer.contains(.pin)
        {
            self.pin = try decoderContainer.decode(String?.self, forKey: .pin)
        }
        if decoderContainer.contains(.appCode)
        {
            self.appCode = try decoderContainer.decode(String?.self, forKey: .appCode)
        }
        if decoderContainer.contains(.serviceCode)
        {
            self.serviceCode = try decoderContainer.decode(String?.self, forKey: .serviceCode)
        }
        if decoderContainer.contains(.serviceCodeName)
        {
            self.serviceCodeName = try decoderContainer.decode(String?.self, forKey: .serviceCodeName)
        }
        if decoderContainer.contains(.billingType)
        {
            self.billingType = try decoderContainer.decode(Int?.self, forKey: .billingType)
        }
        if decoderContainer.contains(.billingTypeName)
        {
            self.billingTypeName = try decoderContainer.decode(String?.self, forKey: .billingTypeName)
        }
        if decoderContainer.contains(.resourceId)
        {
            self.resourceId = try decoderContainer.decode(String?.self, forKey: .resourceId)
        }
        if decoderContainer.contains(.region)
        {
            self.region = try decoderContainer.decode(String?.self, forKey: .region)
        }
        if decoderContainer.contains(.regionName)
        {
            self.regionName = try decoderContainer.decode(String?.self, forKey: .regionName)
        }
        if decoderContainer.contains(.billStartTime)
        {
            self.billStartTime = try decoderContainer.decode(String?.self, forKey: .billStartTime)
        }
        if decoderContainer.contains(.billEndTime)
        {
            self.billEndTime = try decoderContainer.decode(String?.self, forKey: .billEndTime)
        }
        if decoderContainer.contains(.startTime)
        {
            self.startTime = try decoderContainer.decode(String?.self, forKey: .startTime)
        }
        if decoderContainer.contains(.endTime)
        {
            self.endTime = try decoderContainer.decode(String?.self, forKey: .endTime)
        }
        if decoderContainer.contains(.totalFee)
        {
            self.totalFee = try decoderContainer.decode(Double?.self, forKey: .totalFee)
        }
        if decoderContainer.contains(.cashPayFee)
        {
            self.cashPayFee = try decoderContainer.decode(Double?.self, forKey: .cashPayFee)
        }
        if decoderContainer.contains(.cashCouponPayFee)
        {
            self.cashCouponPayFee = try decoderContainer.decode(Double?.self, forKey: .cashCouponPayFee)
        }
        if decoderContainer.contains(.balancePayFee)
        {
            self.balancePayFee = try decoderContainer.decode(Double?.self, forKey: .balancePayFee)
        }
        if decoderContainer.contains(.arrearFee)
        {
            self.arrearFee = try decoderContainer.decode(Double?.self, forKey: .arrearFee)
        }
        if decoderContainer.contains(.timeSpan)
        {
            self.timeSpan = try decoderContainer.decode(Int?.self, forKey: .timeSpan)
        }
        if decoderContainer.contains(.timeUnit)
        {
            self.timeUnit = try decoderContainer.decode(Int?.self, forKey: .timeUnit)
        }
        if decoderContainer.contains(.opTypeName)
        {
            self.opTypeName = try decoderContainer.decode(String?.self, forKey: .opTypeName)
        }
        if decoderContainer.contains(.timeSpanName)
        {
            self.timeSpanName = try decoderContainer.decode(String?.self, forKey: .timeSpanName)
        }
        if decoderContainer.contains(.timeUnitName)
        {
            self.timeUnitName = try decoderContainer.decode(String?.self, forKey: .timeUnitName)
        }
        if decoderContainer.contains(.settleTime)
        {
            self.settleTime = try decoderContainer.decode(String?.self, forKey: .settleTime)
        }
        if decoderContainer.contains(.systemType)
        {
            self.systemType = try decoderContainer.decode(Int?.self, forKey: .systemType)
        }
        if decoderContainer.contains(.resourceName)
        {
            self.resourceName = try decoderContainer.decode(String?.self, forKey: .resourceName)
        }
        if decoderContainer.contains(.tagDetails)
        {
            self.tagDetails = try decoderContainer.decode([ResourceTagVo?]?.self, forKey: .tagDetails)
        }
    }
}
public extension ResourceBillQueryResultItem{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: ResourceBillQueryResultItemCodingKeys.self)
         try encoderContainer.encode(billId, forKey: .billId)
         try encoderContainer.encode(pin, forKey: .pin)
         try encoderContainer.encode(appCode, forKey: .appCode)
         try encoderContainer.encode(serviceCode, forKey: .serviceCode)
         try encoderContainer.encode(serviceCodeName, forKey: .serviceCodeName)
         try encoderContainer.encode(billingType, forKey: .billingType)
         try encoderContainer.encode(billingTypeName, forKey: .billingTypeName)
         try encoderContainer.encode(resourceId, forKey: .resourceId)
         try encoderContainer.encode(region, forKey: .region)
         try encoderContainer.encode(regionName, forKey: .regionName)
         try encoderContainer.encode(billStartTime, forKey: .billStartTime)
         try encoderContainer.encode(billEndTime, forKey: .billEndTime)
         try encoderContainer.encode(startTime, forKey: .startTime)
         try encoderContainer.encode(endTime, forKey: .endTime)
         try encoderContainer.encode(totalFee, forKey: .totalFee)
         try encoderContainer.encode(cashPayFee, forKey: .cashPayFee)
         try encoderContainer.encode(cashCouponPayFee, forKey: .cashCouponPayFee)
         try encoderContainer.encode(balancePayFee, forKey: .balancePayFee)
         try encoderContainer.encode(arrearFee, forKey: .arrearFee)
         try encoderContainer.encode(timeSpan, forKey: .timeSpan)
         try encoderContainer.encode(timeUnit, forKey: .timeUnit)
         try encoderContainer.encode(opTypeName, forKey: .opTypeName)
         try encoderContainer.encode(timeSpanName, forKey: .timeSpanName)
         try encoderContainer.encode(timeUnitName, forKey: .timeUnitName)
         try encoderContainer.encode(settleTime, forKey: .settleTime)
         try encoderContainer.encode(systemType, forKey: .systemType)
         try encoderContainer.encode(resourceName, forKey: .resourceName)
         try encoderContainer.encode(tagDetails, forKey: .tagDetails)
    }
}
///  billStatisticsInfoVo
public class BillStatisticsInfoVo:NSObject,Codable{
    /// 总金额
    var totalFee:Double?
    /// 现金支付金额
    var cashPayFee:Double?
    /// 优惠券支付金额
    var cashCouponPayFee:Double?
    /// 余额支付金额
    var balancePayFee:Double?
    /// 欠费金额
    var arrearFee:Double?
    /// 账单金额
    var billFee:Double?
    /// 折扣金额
    var discountFee:Double?



    public override init(){
            super.init()
    }

    enum BillStatisticsInfoVoCodingKeys: String, CodingKey {
        case totalFee
        case cashPayFee
        case cashCouponPayFee
        case balancePayFee
        case arrearFee
        case billFee
        case discountFee
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: BillStatisticsInfoVoCodingKeys.self)
        if decoderContainer.contains(.totalFee)
        {
            self.totalFee = try decoderContainer.decode(Double?.self, forKey: .totalFee)
        }
        if decoderContainer.contains(.cashPayFee)
        {
            self.cashPayFee = try decoderContainer.decode(Double?.self, forKey: .cashPayFee)
        }
        if decoderContainer.contains(.cashCouponPayFee)
        {
            self.cashCouponPayFee = try decoderContainer.decode(Double?.self, forKey: .cashCouponPayFee)
        }
        if decoderContainer.contains(.balancePayFee)
        {
            self.balancePayFee = try decoderContainer.decode(Double?.self, forKey: .balancePayFee)
        }
        if decoderContainer.contains(.arrearFee)
        {
            self.arrearFee = try decoderContainer.decode(Double?.self, forKey: .arrearFee)
        }
        if decoderContainer.contains(.billFee)
        {
            self.billFee = try decoderContainer.decode(Double?.self, forKey: .billFee)
        }
        if decoderContainer.contains(.discountFee)
        {
            self.discountFee = try decoderContainer.decode(Double?.self, forKey: .discountFee)
        }
    }
}
public extension BillStatisticsInfoVo{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: BillStatisticsInfoVoCodingKeys.self)
         try encoderContainer.encode(totalFee, forKey: .totalFee)
         try encoderContainer.encode(cashPayFee, forKey: .cashPayFee)
         try encoderContainer.encode(cashCouponPayFee, forKey: .cashCouponPayFee)
         try encoderContainer.encode(balancePayFee, forKey: .balancePayFee)
         try encoderContainer.encode(arrearFee, forKey: .arrearFee)
         try encoderContainer.encode(billFee, forKey: .billFee)
         try encoderContainer.encode(discountFee, forKey: .discountFee)
    }
}
///  billQueryCondition
public class BillQueryCondition:NSObject,Codable{
    /// 查询类别   1：资源账单   2：消费记录
    var queryType:Int?
    /// 用户pin
    var pin:String?
    /// 应用码
    var appCode:String?
    /// 服务码
    var serviceCode:String?
    /// 付费类型
    var billingType:Int?
    /// 付费类型
    var payType:Int?
    /// 付费状态
    var payState:Int?
    /// 1: 按账期 2：按消费时间
    var timeType:Int?
    /// 开始时间
    var startTime:String?
    /// 结束时间
    var endTime:String?
    /// IgnoreZero
    var ignoreZero:Int?
    /// 资源ID
    var resourceId:String?
    /// 站点
    var site:Int?
    /// 角色
    var role:Int?
    /// 区域
    var region:String?



    public override init(){
            super.init()
    }

    enum BillQueryConditionCodingKeys: String, CodingKey {
        case queryType
        case pin
        case appCode
        case serviceCode
        case billingType
        case payType
        case payState
        case timeType
        case startTime
        case endTime
        case ignoreZero
        case resourceId
        case site
        case role
        case region
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: BillQueryConditionCodingKeys.self)
        if decoderContainer.contains(.queryType)
        {
            self.queryType = try decoderContainer.decode(Int?.self, forKey: .queryType)
        }
        if decoderContainer.contains(.pin)
        {
            self.pin = try decoderContainer.decode(String?.self, forKey: .pin)
        }
        if decoderContainer.contains(.appCode)
        {
            self.appCode = try decoderContainer.decode(String?.self, forKey: .appCode)
        }
        if decoderContainer.contains(.serviceCode)
        {
            self.serviceCode = try decoderContainer.decode(String?.self, forKey: .serviceCode)
        }
        if decoderContainer.contains(.billingType)
        {
            self.billingType = try decoderContainer.decode(Int?.self, forKey: .billingType)
        }
        if decoderContainer.contains(.payType)
        {
            self.payType = try decoderContainer.decode(Int?.self, forKey: .payType)
        }
        if decoderContainer.contains(.payState)
        {
            self.payState = try decoderContainer.decode(Int?.self, forKey: .payState)
        }
        if decoderContainer.contains(.timeType)
        {
            self.timeType = try decoderContainer.decode(Int?.self, forKey: .timeType)
        }
        if decoderContainer.contains(.startTime)
        {
            self.startTime = try decoderContainer.decode(String?.self, forKey: .startTime)
        }
        if decoderContainer.contains(.endTime)
        {
            self.endTime = try decoderContainer.decode(String?.self, forKey: .endTime)
        }
        if decoderContainer.contains(.ignoreZero)
        {
            self.ignoreZero = try decoderContainer.decode(Int?.self, forKey: .ignoreZero)
        }
        if decoderContainer.contains(.resourceId)
        {
            self.resourceId = try decoderContainer.decode(String?.self, forKey: .resourceId)
        }
        if decoderContainer.contains(.site)
        {
            self.site = try decoderContainer.decode(Int?.self, forKey: .site)
        }
        if decoderContainer.contains(.role)
        {
            self.role = try decoderContainer.decode(Int?.self, forKey: .role)
        }
        if decoderContainer.contains(.region)
        {
            self.region = try decoderContainer.decode(String?.self, forKey: .region)
        }
    }
}
public extension BillQueryCondition{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: BillQueryConditionCodingKeys.self)
         try encoderContainer.encode(queryType, forKey: .queryType)
         try encoderContainer.encode(pin, forKey: .pin)
         try encoderContainer.encode(appCode, forKey: .appCode)
         try encoderContainer.encode(serviceCode, forKey: .serviceCode)
         try encoderContainer.encode(billingType, forKey: .billingType)
         try encoderContainer.encode(payType, forKey: .payType)
         try encoderContainer.encode(payState, forKey: .payState)
         try encoderContainer.encode(timeType, forKey: .timeType)
         try encoderContainer.encode(startTime, forKey: .startTime)
         try encoderContainer.encode(endTime, forKey: .endTime)
         try encoderContainer.encode(ignoreZero, forKey: .ignoreZero)
         try encoderContainer.encode(resourceId, forKey: .resourceId)
         try encoderContainer.encode(site, forKey: .site)
         try encoderContainer.encode(role, forKey: .role)
         try encoderContainer.encode(region, forKey: .region)
    }
}
///  arrearInfoVo
public class ArrearInfoVo:NSObject,Codable{
    /// 用户pin
    var pin:String?
    /// 欠费金额
    var arrearFee:Double?
    /// 首次欠费时间
    var firstArrearDate:String?
    /// 欠费天数
    var arrearDays:Int?



    public override init(){
            super.init()
    }

    enum ArrearInfoVoCodingKeys: String, CodingKey {
        case pin
        case arrearFee
        case firstArrearDate
        case arrearDays
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: ArrearInfoVoCodingKeys.self)
        if decoderContainer.contains(.pin)
        {
            self.pin = try decoderContainer.decode(String?.self, forKey: .pin)
        }
        if decoderContainer.contains(.arrearFee)
        {
            self.arrearFee = try decoderContainer.decode(Double?.self, forKey: .arrearFee)
        }
        if decoderContainer.contains(.firstArrearDate)
        {
            self.firstArrearDate = try decoderContainer.decode(String?.self, forKey: .firstArrearDate)
        }
        if decoderContainer.contains(.arrearDays)
        {
            self.arrearDays = try decoderContainer.decode(Int?.self, forKey: .arrearDays)
        }
    }
}
public extension ArrearInfoVo{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: ArrearInfoVoCodingKeys.self)
         try encoderContainer.encode(pin, forKey: .pin)
         try encoderContainer.encode(arrearFee, forKey: .arrearFee)
         try encoderContainer.encode(firstArrearDate, forKey: .firstArrearDate)
         try encoderContainer.encode(arrearDays, forKey: .arrearDays)
    }
}
///  最新价格map
public class PriceMap:NSObject,Codable{
    /// Key
    var key:String?
    /// Value
    var value:Double?



    public override init(){
            super.init()
    }

    enum PriceMapCodingKeys: String, CodingKey {
        case key
        case value
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: PriceMapCodingKeys.self)
        if decoderContainer.contains(.key)
        {
            self.key = try decoderContainer.decode(String?.self, forKey: .key)
        }
        if decoderContainer.contains(.value)
        {
            self.value = try decoderContainer.decode(Double?.self, forKey: .value)
        }
    }
}
public extension PriceMap{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: PriceMapCodingKeys.self)
         try encoderContainer.encode(key, forKey: .key)
         try encoderContainer.encode(value, forKey: .value)
    }
}
///  productDetailList
public class ProductDetailList:NSObject,Codable{
    /// Key
    var key:Int?
    /// Values
    var values:Pagination?



    public override init(){
            super.init()
    }

    enum ProductDetailListCodingKeys: String, CodingKey {
        case key
        case values
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: ProductDetailListCodingKeys.self)
        if decoderContainer.contains(.key)
        {
            self.key = try decoderContainer.decode(Int?.self, forKey: .key)
        }
        if decoderContainer.contains(.values)
        {
            self.values = try decoderContainer.decode(Pagination?.self, forKey: .values)
        }
    }
}
public extension ProductDetailList{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: ProductDetailListCodingKeys.self)
         try encoderContainer.encode(key, forKey: .key)
         try encoderContainer.encode(values, forKey: .values)
    }
}
///  tags
public class Tags:NSObject,Codable{
    /// Key
    var key:String?
    /// Value
    var value:String?



    public override init(){
            super.init()
    }

    enum TagsCodingKeys: String, CodingKey {
        case key
        case value
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: TagsCodingKeys.self)
        if decoderContainer.contains(.key)
        {
            self.key = try decoderContainer.decode(String?.self, forKey: .key)
        }
        if decoderContainer.contains(.value)
        {
            self.value = try decoderContainer.decode(String?.self, forKey: .value)
        }
    }
}
public extension Tags{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: TagsCodingKeys.self)
         try encoderContainer.encode(key, forKey: .key)
         try encoderContainer.encode(value, forKey: .value)
    }
}
///  compatibleBill
public class CompatibleBill:NSObject,Codable{
    /// 账单ID
    var billId:Double?
    /// 用户pin
    var pin:String?
    /// 站点
    var site:Int?
    /// 区域
    var region:String?
    /// appCode
    var appCode:String?
    /// appCodeName
    var appCodeName:String?
    /// serviceCode
    var serviceCode:String?
    /// serviceCodeName
    var serviceCodeName:String?
    /// 资源id
    var resourceId:String?
    /// 计费类型
    var billingType:Int?
    /// 计费类型描述
    var billingTypeName:String?
    /// 规格
    var formula:String?
    /// 规格
    var formulaStr:String?
    /// 开始时间
    var startTime:String?
    /// 结束时间
    var endTime:String?
    /// 创建时间
    var createTime:String?
    /// 账单金额
    var billFee:Double?
    /// 账单金额（保留小数点后2位）
    var billFee2:Double?
    /// 折扣金额
    var discountFee:Double?
    /// 代金券id
    var couponId:String?
    /// 优惠券金额
    var couponFee:Double?
    /// 优惠后金额
    var actualFee:Double?
    /// 代金券金额
    var cashCouponFee:Double?
    /// 余额支付金额
    var balancePayFee:Double?
    /// 现金支付金额
    var cashPayFee:Double?
    /// 欠费金额
    var arrearFee:Double?
    /// 支付状态
    var paySate:Int?
    /// 1:老计费   2：新计费
    var systemType:Int?
    /// 资源名称
    var resourceName:String?



    public override init(){
            super.init()
    }

    enum CompatibleBillCodingKeys: String, CodingKey {
        case billId
        case pin
        case site
        case region
        case appCode
        case appCodeName
        case serviceCode
        case serviceCodeName
        case resourceId
        case billingType
        case billingTypeName
        case formula
        case formulaStr
        case startTime
        case endTime
        case createTime
        case billFee
        case billFee2
        case discountFee
        case couponId
        case couponFee
        case actualFee
        case cashCouponFee
        case balancePayFee
        case cashPayFee
        case arrearFee
        case paySate
        case systemType
        case resourceName
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: CompatibleBillCodingKeys.self)
        if decoderContainer.contains(.billId)
        {
            self.billId = try decoderContainer.decode(Double?.self, forKey: .billId)
        }
        if decoderContainer.contains(.pin)
        {
            self.pin = try decoderContainer.decode(String?.self, forKey: .pin)
        }
        if decoderContainer.contains(.site)
        {
            self.site = try decoderContainer.decode(Int?.self, forKey: .site)
        }
        if decoderContainer.contains(.region)
        {
            self.region = try decoderContainer.decode(String?.self, forKey: .region)
        }
        if decoderContainer.contains(.appCode)
        {
            self.appCode = try decoderContainer.decode(String?.self, forKey: .appCode)
        }
        if decoderContainer.contains(.appCodeName)
        {
            self.appCodeName = try decoderContainer.decode(String?.self, forKey: .appCodeName)
        }
        if decoderContainer.contains(.serviceCode)
        {
            self.serviceCode = try decoderContainer.decode(String?.self, forKey: .serviceCode)
        }
        if decoderContainer.contains(.serviceCodeName)
        {
            self.serviceCodeName = try decoderContainer.decode(String?.self, forKey: .serviceCodeName)
        }
        if decoderContainer.contains(.resourceId)
        {
            self.resourceId = try decoderContainer.decode(String?.self, forKey: .resourceId)
        }
        if decoderContainer.contains(.billingType)
        {
            self.billingType = try decoderContainer.decode(Int?.self, forKey: .billingType)
        }
        if decoderContainer.contains(.billingTypeName)
        {
            self.billingTypeName = try decoderContainer.decode(String?.self, forKey: .billingTypeName)
        }
        if decoderContainer.contains(.formula)
        {
            self.formula = try decoderContainer.decode(String?.self, forKey: .formula)
        }
        if decoderContainer.contains(.formulaStr)
        {
            self.formulaStr = try decoderContainer.decode(String?.self, forKey: .formulaStr)
        }
        if decoderContainer.contains(.startTime)
        {
            self.startTime = try decoderContainer.decode(String?.self, forKey: .startTime)
        }
        if decoderContainer.contains(.endTime)
        {
            self.endTime = try decoderContainer.decode(String?.self, forKey: .endTime)
        }
        if decoderContainer.contains(.createTime)
        {
            self.createTime = try decoderContainer.decode(String?.self, forKey: .createTime)
        }
        if decoderContainer.contains(.billFee)
        {
            self.billFee = try decoderContainer.decode(Double?.self, forKey: .billFee)
        }
        if decoderContainer.contains(.billFee2)
        {
            self.billFee2 = try decoderContainer.decode(Double?.self, forKey: .billFee2)
        }
        if decoderContainer.contains(.discountFee)
        {
            self.discountFee = try decoderContainer.decode(Double?.self, forKey: .discountFee)
        }
        if decoderContainer.contains(.couponId)
        {
            self.couponId = try decoderContainer.decode(String?.self, forKey: .couponId)
        }
        if decoderContainer.contains(.couponFee)
        {
            self.couponFee = try decoderContainer.decode(Double?.self, forKey: .couponFee)
        }
        if decoderContainer.contains(.actualFee)
        {
            self.actualFee = try decoderContainer.decode(Double?.self, forKey: .actualFee)
        }
        if decoderContainer.contains(.cashCouponFee)
        {
            self.cashCouponFee = try decoderContainer.decode(Double?.self, forKey: .cashCouponFee)
        }
        if decoderContainer.contains(.balancePayFee)
        {
            self.balancePayFee = try decoderContainer.decode(Double?.self, forKey: .balancePayFee)
        }
        if decoderContainer.contains(.cashPayFee)
        {
            self.cashPayFee = try decoderContainer.decode(Double?.self, forKey: .cashPayFee)
        }
        if decoderContainer.contains(.arrearFee)
        {
            self.arrearFee = try decoderContainer.decode(Double?.self, forKey: .arrearFee)
        }
        if decoderContainer.contains(.paySate)
        {
            self.paySate = try decoderContainer.decode(Int?.self, forKey: .paySate)
        }
        if decoderContainer.contains(.systemType)
        {
            self.systemType = try decoderContainer.decode(Int?.self, forKey: .systemType)
        }
        if decoderContainer.contains(.resourceName)
        {
            self.resourceName = try decoderContainer.decode(String?.self, forKey: .resourceName)
        }
    }
}
public extension CompatibleBill{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: CompatibleBillCodingKeys.self)
         try encoderContainer.encode(billId, forKey: .billId)
         try encoderContainer.encode(pin, forKey: .pin)
         try encoderContainer.encode(site, forKey: .site)
         try encoderContainer.encode(region, forKey: .region)
         try encoderContainer.encode(appCode, forKey: .appCode)
         try encoderContainer.encode(appCodeName, forKey: .appCodeName)
         try encoderContainer.encode(serviceCode, forKey: .serviceCode)
         try encoderContainer.encode(serviceCodeName, forKey: .serviceCodeName)
         try encoderContainer.encode(resourceId, forKey: .resourceId)
         try encoderContainer.encode(billingType, forKey: .billingType)
         try encoderContainer.encode(billingTypeName, forKey: .billingTypeName)
         try encoderContainer.encode(formula, forKey: .formula)
         try encoderContainer.encode(formulaStr, forKey: .formulaStr)
         try encoderContainer.encode(startTime, forKey: .startTime)
         try encoderContainer.encode(endTime, forKey: .endTime)
         try encoderContainer.encode(createTime, forKey: .createTime)
         try encoderContainer.encode(billFee, forKey: .billFee)
         try encoderContainer.encode(billFee2, forKey: .billFee2)
         try encoderContainer.encode(discountFee, forKey: .discountFee)
         try encoderContainer.encode(couponId, forKey: .couponId)
         try encoderContainer.encode(couponFee, forKey: .couponFee)
         try encoderContainer.encode(actualFee, forKey: .actualFee)
         try encoderContainer.encode(cashCouponFee, forKey: .cashCouponFee)
         try encoderContainer.encode(balancePayFee, forKey: .balancePayFee)
         try encoderContainer.encode(cashPayFee, forKey: .cashPayFee)
         try encoderContainer.encode(arrearFee, forKey: .arrearFee)
         try encoderContainer.encode(paySate, forKey: .paySate)
         try encoderContainer.encode(systemType, forKey: .systemType)
         try encoderContainer.encode(resourceName, forKey: .resourceName)
    }
}
///  orderPrice
public class OrderPrice:NSObject,Codable{
    /// 折扣前总价
    var totalPrice:Double?
    /// 折扣前总价4位
    var totalPriceScale4:Double?
    /// 折扣后订单价格
    var discountedTotalPrice:Double?
    /// 总折扣金额
    var totalDiscount:Double?
    /// 计算完价格后的详细订单列表
    var list:[OrderPriceDetail?]?
    /// 订单原价 包年时 一年原价为12个月价格，totalPrice为10个月价格
    var totalOriginalPrice:Double?
    /// 参与优惠的明细
    var favorableInfos:Int?
    /// 备注
    var remark:Int?



    public override init(){
            super.init()
    }

    enum OrderPriceCodingKeys: String, CodingKey {
        case totalPrice
        case totalPriceScale4
        case discountedTotalPrice
        case totalDiscount
        case list
        case totalOriginalPrice
        case favorableInfos
        case remark
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: OrderPriceCodingKeys.self)
        if decoderContainer.contains(.totalPrice)
        {
            self.totalPrice = try decoderContainer.decode(Double?.self, forKey: .totalPrice)
        }
        if decoderContainer.contains(.totalPriceScale4)
        {
            self.totalPriceScale4 = try decoderContainer.decode(Double?.self, forKey: .totalPriceScale4)
        }
        if decoderContainer.contains(.discountedTotalPrice)
        {
            self.discountedTotalPrice = try decoderContainer.decode(Double?.self, forKey: .discountedTotalPrice)
        }
        if decoderContainer.contains(.totalDiscount)
        {
            self.totalDiscount = try decoderContainer.decode(Double?.self, forKey: .totalDiscount)
        }
        if decoderContainer.contains(.list)
        {
            self.list = try decoderContainer.decode([OrderPriceDetail?]?.self, forKey: .list)
        }
        if decoderContainer.contains(.totalOriginalPrice)
        {
            self.totalOriginalPrice = try decoderContainer.decode(Double?.self, forKey: .totalOriginalPrice)
        }
        if decoderContainer.contains(.favorableInfos)
        {
            self.favorableInfos = try decoderContainer.decode(Int?.self, forKey: .favorableInfos)
        }
        if decoderContainer.contains(.remark)
        {
            self.remark = try decoderContainer.decode(Int?.self, forKey: .remark)
        }
    }
}
public extension OrderPrice{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: OrderPriceCodingKeys.self)
         try encoderContainer.encode(totalPrice, forKey: .totalPrice)
         try encoderContainer.encode(totalPriceScale4, forKey: .totalPriceScale4)
         try encoderContainer.encode(discountedTotalPrice, forKey: .discountedTotalPrice)
         try encoderContainer.encode(totalDiscount, forKey: .totalDiscount)
         try encoderContainer.encode(list, forKey: .list)
         try encoderContainer.encode(totalOriginalPrice, forKey: .totalOriginalPrice)
         try encoderContainer.encode(favorableInfos, forKey: .favorableInfos)
         try encoderContainer.encode(remark, forKey: .remark)
    }
}

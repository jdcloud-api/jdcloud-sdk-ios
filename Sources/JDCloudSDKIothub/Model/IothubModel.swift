/* Copyright 2018 JDCLOUD.COM

   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at

     http:#www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.

   Product
   关于产品基本信息操作的相关接口

   OpenAPI spec version: v2
   Contact: 

   NOTE: This class is auto generated by the jdcloud code generator program.
 */


import Foundation
///  productProperty
public class ProductProperty:NSObject,Codable{
    /// 名称, 1~30个字符，仅支持英文字母、数字、下划线“_”及中划线“-”，必须英文字母及数字开头结尾
    /// Required:true
    var name:String
    /// 描述, 0-50个字符
    var descriptionValue:String?
    /// 数据类型，string:字符串，bool:布尔，float:单精度浮点数，double:双精度浮点数，int32:整型，enum:枚举
    /// Required:true
    var dataType:String
    /// 单位, 0-10个字符
    var unit:String?
    /// 单位名称, 0-10个字符
    var unitName:String?
    /// 参数最小值(int32, float, double类型时,必填)
      /// 整型取值范围：-2的31次方 ~2的31次方-1
      /// 单精度浮点取值范围：-2的128次方+1 ~2的128次方-1,最多7位小数
      /// 双精度浮点取值范围：-2的1023次方+1 ~2的1023次方-1,最多14位小数
      /// 
    var min:Double?
    /// 参数最大值(int32, float, double类型时,必填)
      /// 最大值必须大于最小值
      /// 整型取值范围：-2的31次方 ~2的31次方-1
      /// 单精度浮点取值范围：-2的128次方+1 ~2的128次方-1,最多7位小数
      /// 双精度浮点取值范围：-2的1023次方+1 ~2的1023次方-1,最多14位小数
      /// 
    var max:Double?
    /// 参数步长(int32, float, double类型时,必填)
      /// 整型取值范围：0 ~2的31次方-1
      /// 单精度浮点取值范围：0 ~2的128次方-1,最多7位小数
      /// 双精度浮点取值范围：0~2的1023次方-1,最多14位小数
      /// 
    var step:Double?
    /// 参数长度(string类型特有时,必填)
      /// 取值范围:1-256之间的整数)
      /// 
    var length:Int?
    /// 枚举定义信息(enum、bool类型时,必填)
      /// 布尔值名称：不可为空，支持汉字、英文字母、数字。长度为1-10个字符
      /// 枚举值:为字符型，0~99。至少包括两个枚举值。输入“0”时，仅支持1位。其他数字不支持以0开头
      /// 枚举值名称：不可为空，支持汉字、英文字母、数字。长度为1-10个字符
      /// 枚举类型格式如:{10:&quot;on&quot;,10:&quot;off&quot;}
      /// 布尔类型格式如:{&quot;True&quot;:&quot;12&quot;,&quot;False&quot;:&quot;22&quot;}
    var enumInfo:AnyObject?



    public  init(name:String,dataType:String){
             self.name = name
             self.dataType = dataType
    }

    enum ProductPropertyCodingKeys: String, CodingKey {
        case name
        case descriptionValue = "description"
        case dataType
        case unit
        case unitName
        case min
        case max
        case step
        case length
        case enumInfo
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: ProductPropertyCodingKeys.self)
        self.name = try decoderContainer.decode(String.self, forKey: .name)
        if decoderContainer.contains(.descriptionValue)
        {
            self.descriptionValue = try decoderContainer.decode(String?.self, forKey: .descriptionValue)
        }
        self.dataType = try decoderContainer.decode(String.self, forKey: .dataType)
        if decoderContainer.contains(.unit)
        {
            self.unit = try decoderContainer.decode(String?.self, forKey: .unit)
        }
        if decoderContainer.contains(.unitName)
        {
            self.unitName = try decoderContainer.decode(String?.self, forKey: .unitName)
        }
        if decoderContainer.contains(.min)
        {
            self.min = try decoderContainer.decode(Double?.self, forKey: .min)
        }
        if decoderContainer.contains(.max)
        {
            self.max = try decoderContainer.decode(Double?.self, forKey: .max)
        }
        if decoderContainer.contains(.step)
        {
            self.step = try decoderContainer.decode(Double?.self, forKey: .step)
        }
        if decoderContainer.contains(.length)
        {
            self.length = try decoderContainer.decode(Int?.self, forKey: .length)
        }
    }
}
public extension ProductProperty{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: ProductPropertyCodingKeys.self)
         try encoderContainer.encode(name, forKey: .name)
         try encoderContainer.encode(descriptionValue, forKey: .descriptionValue)
         try encoderContainer.encode(dataType, forKey: .dataType)
         try encoderContainer.encode(unit, forKey: .unit)
         try encoderContainer.encode(unitName, forKey: .unitName)
         try encoderContainer.encode(min, forKey: .min)
         try encoderContainer.encode(max, forKey: .max)
         try encoderContainer.encode(step, forKey: .step)
         try encoderContainer.encode(length, forKey: .length)
    }
}
///  ruleBaseInfo
public class RuleBaseInfo:NSObject,Codable{
    /// 规则Id
    var id:String?
    /// 规则名称
    var name:String?
    /// 规则说明
    var desc:String?
    /// 状态，停止:disable,启动:enable
    var status:String?
    /// 创建时间，精确到毫秒
    var createdTime:String?



    public override init(){
            super.init()
    }

    enum RuleBaseInfoCodingKeys: String, CodingKey {
        case id
        case name
        case desc
        case status
        case createdTime
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: RuleBaseInfoCodingKeys.self)
        if decoderContainer.contains(.id)
        {
            self.id = try decoderContainer.decode(String?.self, forKey: .id)
        }
        if decoderContainer.contains(.name)
        {
            self.name = try decoderContainer.decode(String?.self, forKey: .name)
        }
        if decoderContainer.contains(.desc)
        {
            self.desc = try decoderContainer.decode(String?.self, forKey: .desc)
        }
        if decoderContainer.contains(.status)
        {
            self.status = try decoderContainer.decode(String?.self, forKey: .status)
        }
        if decoderContainer.contains(.createdTime)
        {
            self.createdTime = try decoderContainer.decode(String?.self, forKey: .createdTime)
        }
    }
}
public extension RuleBaseInfo{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: RuleBaseInfoCodingKeys.self)
         try encoderContainer.encode(id, forKey: .id)
         try encoderContainer.encode(name, forKey: .name)
         try encoderContainer.encode(desc, forKey: .desc)
         try encoderContainer.encode(status, forKey: .status)
         try encoderContainer.encode(createdTime, forKey: .createdTime)
    }
}
///  action
public class Action:NSObject,Codable{
    /// ActionId
    var actionId:String?
    /// 动作类型，包括：handle（数据处理）、forward（转发数据）和failure（转发失败）
    var actionType:String?
    /// 操作类型,包括：JCQ、JsScript、Kafka、RabbitMq、RDS和ES
    var operationType:String?
    /// 规则动作的配置信息, Configuration是JSONObject格式，会根据不同的规则动作，形成不同的JSONObject格式，即不同的配置信息格式。
    var configuration:AnyObject?



    public override init(){
            super.init()
    }

    enum ActionCodingKeys: String, CodingKey {
        case actionId
        case actionType
        case operationType
        case configuration
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: ActionCodingKeys.self)
        if decoderContainer.contains(.actionId)
        {
            self.actionId = try decoderContainer.decode(String?.self, forKey: .actionId)
        }
        if decoderContainer.contains(.actionType)
        {
            self.actionType = try decoderContainer.decode(String?.self, forKey: .actionType)
        }
        if decoderContainer.contains(.operationType)
        {
            self.operationType = try decoderContainer.decode(String?.self, forKey: .operationType)
        }
    }
}
public extension Action{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: ActionCodingKeys.self)
         try encoderContainer.encode(actionId, forKey: .actionId)
         try encoderContainer.encode(actionType, forKey: .actionType)
         try encoderContainer.encode(operationType, forKey: .operationType)
    }
}
///  proxys
public class Proxys:NSObject,Codable{
    /// IoT Hub Proxy实例编号
    var proxyId:String?
    /// Proxy对应的用户Pin
    var userPin:String?
    /// IoT Hub Proxy实例创建时间
    var createTime:Int?
    /// IoT Hub Proxy下执行的规则数量
    var totalRuleNums:Int?



    public override init(){
            super.init()
    }

    enum ProxysCodingKeys: String, CodingKey {
        case proxyId
        case userPin
        case createTime
        case totalRuleNums
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: ProxysCodingKeys.self)
        if decoderContainer.contains(.proxyId)
        {
            self.proxyId = try decoderContainer.decode(String?.self, forKey: .proxyId)
        }
        if decoderContainer.contains(.userPin)
        {
            self.userPin = try decoderContainer.decode(String?.self, forKey: .userPin)
        }
        if decoderContainer.contains(.createTime)
        {
            self.createTime = try decoderContainer.decode(Int?.self, forKey: .createTime)
        }
        if decoderContainer.contains(.totalRuleNums)
        {
            self.totalRuleNums = try decoderContainer.decode(Int?.self, forKey: .totalRuleNums)
        }
    }
}
public extension Proxys{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: ProxysCodingKeys.self)
         try encoderContainer.encode(proxyId, forKey: .proxyId)
         try encoderContainer.encode(userPin, forKey: .userPin)
         try encoderContainer.encode(createTime, forKey: .createTime)
         try encoderContainer.encode(totalRuleNums, forKey: .totalRuleNums)
    }
}
///  rules
public class Rules:NSObject,Codable{
    /// 规则编号
    var ruleId:String?
    /// 0-正常规则，1-异常规则
    var ruleType:Int?
    /// 用户填写的规则信息
    var ruleInfo:String?
    /// 用户规则映射的jcq信息
    var jcqInfo:String?



    public override init(){
            super.init()
    }

    enum RulesCodingKeys: String, CodingKey {
        case ruleId
        case ruleType
        case ruleInfo
        case jcqInfo
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: RulesCodingKeys.self)
        if decoderContainer.contains(.ruleId)
        {
            self.ruleId = try decoderContainer.decode(String?.self, forKey: .ruleId)
        }
        if decoderContainer.contains(.ruleType)
        {
            self.ruleType = try decoderContainer.decode(Int?.self, forKey: .ruleType)
        }
        if decoderContainer.contains(.ruleInfo)
        {
            self.ruleInfo = try decoderContainer.decode(String?.self, forKey: .ruleInfo)
        }
        if decoderContainer.contains(.jcqInfo)
        {
            self.jcqInfo = try decoderContainer.decode(String?.self, forKey: .jcqInfo)
        }
    }
}
public extension Rules{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: RulesCodingKeys.self)
         try encoderContainer.encode(ruleId, forKey: .ruleId)
         try encoderContainer.encode(ruleType, forKey: .ruleType)
         try encoderContainer.encode(ruleInfo, forKey: .ruleInfo)
         try encoderContainer.encode(jcqInfo, forKey: .jcqInfo)
    }
}
///  pageinfoVO
public class PageinfoVO:NSObject,Codable{
    /// 每页显示条数
    var pageSize:Int?
    /// 当前页数
    var nowPage:Int?
    /// 总记录数
    var totalSize:Int?
    /// 总页数
    var totalPage:Int?



    public override init(){
            super.init()
    }

    enum PageinfoVOCodingKeys: String, CodingKey {
        case pageSize
        case nowPage
        case totalSize
        case totalPage
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: PageinfoVOCodingKeys.self)
        if decoderContainer.contains(.pageSize)
        {
            self.pageSize = try decoderContainer.decode(Int?.self, forKey: .pageSize)
        }
        if decoderContainer.contains(.nowPage)
        {
            self.nowPage = try decoderContainer.decode(Int?.self, forKey: .nowPage)
        }
        if decoderContainer.contains(.totalSize)
        {
            self.totalSize = try decoderContainer.decode(Int?.self, forKey: .totalSize)
        }
        if decoderContainer.contains(.totalPage)
        {
            self.totalPage = try decoderContainer.decode(Int?.self, forKey: .totalPage)
        }
    }
}
public extension PageinfoVO{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: PageinfoVOCodingKeys.self)
         try encoderContainer.encode(pageSize, forKey: .pageSize)
         try encoderContainer.encode(nowPage, forKey: .nowPage)
         try encoderContainer.encode(totalSize, forKey: .totalSize)
         try encoderContainer.encode(totalPage, forKey: .totalPage)
    }
}
///  proxyDetails
public class ProxyDetails:NSObject,Codable{
    /// IoT Hub Proxy实例编号
    var proxyId:String?
    /// Proxy对应的用户Pin
    var userPin:String?
    /// IoT Hub Proxy实例创建时间
    var createTime:Int?
    /// IoT Hub Proxy所在区域编号
    var regionId:String?
    /// IoT Hub Proxy所在区域名称
    var regionName:String?
    /// IoT Hub Proxy所在可用区编号
    var azId:String?
    /// IoT Hub Proxy所在可用区名称
    var azName:String?
    /// IoT Hub Proxy所在VPC编号
    var vpcId:String?
    /// IoT Hub Proxy所在VPC名称
    var vpcName:String?
    /// IoT Hub Proxy所在subnet编号
    var subnetId:String?
    /// IoT Hub Proxy所在subnet名称
    var subnetName:String?
    /// 内部创建JCQ对应的accessKey
    var jcqAccessKey:String?
    /// 内部创建JCQ对应的Secret Access Key
    var jcqSecretAccessKey:String?
    /// 内部创建JCQ对应的ConsumerGroup
    var jcqConsumerGroupId:String?
    /// 内部创建JCQ对应的endpoint
    var jcqEndpoint:String?
    /// 当前Proxy中负责处理的规则总数
    var totalRuleNums:String?



    public override init(){
            super.init()
    }

    enum ProxyDetailsCodingKeys: String, CodingKey {
        case proxyId
        case userPin
        case createTime
        case regionId
        case regionName
        case azId
        case azName
        case vpcId
        case vpcName
        case subnetId
        case subnetName
        case jcqAccessKey
        case jcqSecretAccessKey
        case jcqConsumerGroupId
        case jcqEndpoint
        case totalRuleNums
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: ProxyDetailsCodingKeys.self)
        if decoderContainer.contains(.proxyId)
        {
            self.proxyId = try decoderContainer.decode(String?.self, forKey: .proxyId)
        }
        if decoderContainer.contains(.userPin)
        {
            self.userPin = try decoderContainer.decode(String?.self, forKey: .userPin)
        }
        if decoderContainer.contains(.createTime)
        {
            self.createTime = try decoderContainer.decode(Int?.self, forKey: .createTime)
        }
        if decoderContainer.contains(.regionId)
        {
            self.regionId = try decoderContainer.decode(String?.self, forKey: .regionId)
        }
        if decoderContainer.contains(.regionName)
        {
            self.regionName = try decoderContainer.decode(String?.self, forKey: .regionName)
        }
        if decoderContainer.contains(.azId)
        {
            self.azId = try decoderContainer.decode(String?.self, forKey: .azId)
        }
        if decoderContainer.contains(.azName)
        {
            self.azName = try decoderContainer.decode(String?.self, forKey: .azName)
        }
        if decoderContainer.contains(.vpcId)
        {
            self.vpcId = try decoderContainer.decode(String?.self, forKey: .vpcId)
        }
        if decoderContainer.contains(.vpcName)
        {
            self.vpcName = try decoderContainer.decode(String?.self, forKey: .vpcName)
        }
        if decoderContainer.contains(.subnetId)
        {
            self.subnetId = try decoderContainer.decode(String?.self, forKey: .subnetId)
        }
        if decoderContainer.contains(.subnetName)
        {
            self.subnetName = try decoderContainer.decode(String?.self, forKey: .subnetName)
        }
        if decoderContainer.contains(.jcqAccessKey)
        {
            self.jcqAccessKey = try decoderContainer.decode(String?.self, forKey: .jcqAccessKey)
        }
        if decoderContainer.contains(.jcqSecretAccessKey)
        {
            self.jcqSecretAccessKey = try decoderContainer.decode(String?.self, forKey: .jcqSecretAccessKey)
        }
        if decoderContainer.contains(.jcqConsumerGroupId)
        {
            self.jcqConsumerGroupId = try decoderContainer.decode(String?.self, forKey: .jcqConsumerGroupId)
        }
        if decoderContainer.contains(.jcqEndpoint)
        {
            self.jcqEndpoint = try decoderContainer.decode(String?.self, forKey: .jcqEndpoint)
        }
        if decoderContainer.contains(.totalRuleNums)
        {
            self.totalRuleNums = try decoderContainer.decode(String?.self, forKey: .totalRuleNums)
        }
    }
}
public extension ProxyDetails{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: ProxyDetailsCodingKeys.self)
         try encoderContainer.encode(proxyId, forKey: .proxyId)
         try encoderContainer.encode(userPin, forKey: .userPin)
         try encoderContainer.encode(createTime, forKey: .createTime)
         try encoderContainer.encode(regionId, forKey: .regionId)
         try encoderContainer.encode(regionName, forKey: .regionName)
         try encoderContainer.encode(azId, forKey: .azId)
         try encoderContainer.encode(azName, forKey: .azName)
         try encoderContainer.encode(vpcId, forKey: .vpcId)
         try encoderContainer.encode(vpcName, forKey: .vpcName)
         try encoderContainer.encode(subnetId, forKey: .subnetId)
         try encoderContainer.encode(subnetName, forKey: .subnetName)
         try encoderContainer.encode(jcqAccessKey, forKey: .jcqAccessKey)
         try encoderContainer.encode(jcqSecretAccessKey, forKey: .jcqSecretAccessKey)
         try encoderContainer.encode(jcqConsumerGroupId, forKey: .jcqConsumerGroupId)
         try encoderContainer.encode(jcqEndpoint, forKey: .jcqEndpoint)
         try encoderContainer.encode(totalRuleNums, forKey: .totalRuleNums)
    }
}
///  userDetails
public class UserDetails:NSObject,Codable{
    /// 用户Pin
    var userPin:String?
    /// 所在区名称
    var regionName:String?
    /// 用户状态 [1-运行中，2-欠费停服，3-停服删除]
    var userStatus:Int?
    /// 开通时间
    var signTime:Int?
    /// 计费类型
    var chargeType:String?
    /// 产品总数
    var productNum:Int?
    /// 设备总数
    var deviceNum:Int?
    /// 在线设备数
    var onDevices:Int?
    /// 设备连接总时长
    var maxOnlineTime:Int?
    /// 总消息数
    var totalMessages:Int?



    public override init(){
            super.init()
    }

    enum UserDetailsCodingKeys: String, CodingKey {
        case userPin
        case regionName
        case userStatus
        case signTime
        case chargeType
        case productNum
        case deviceNum
        case onDevices
        case maxOnlineTime
        case totalMessages
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: UserDetailsCodingKeys.self)
        if decoderContainer.contains(.userPin)
        {
            self.userPin = try decoderContainer.decode(String?.self, forKey: .userPin)
        }
        if decoderContainer.contains(.regionName)
        {
            self.regionName = try decoderContainer.decode(String?.self, forKey: .regionName)
        }
        if decoderContainer.contains(.userStatus)
        {
            self.userStatus = try decoderContainer.decode(Int?.self, forKey: .userStatus)
        }
        if decoderContainer.contains(.signTime)
        {
            self.signTime = try decoderContainer.decode(Int?.self, forKey: .signTime)
        }
        if decoderContainer.contains(.chargeType)
        {
            self.chargeType = try decoderContainer.decode(String?.self, forKey: .chargeType)
        }
        if decoderContainer.contains(.productNum)
        {
            self.productNum = try decoderContainer.decode(Int?.self, forKey: .productNum)
        }
        if decoderContainer.contains(.deviceNum)
        {
            self.deviceNum = try decoderContainer.decode(Int?.self, forKey: .deviceNum)
        }
        if decoderContainer.contains(.onDevices)
        {
            self.onDevices = try decoderContainer.decode(Int?.self, forKey: .onDevices)
        }
        if decoderContainer.contains(.maxOnlineTime)
        {
            self.maxOnlineTime = try decoderContainer.decode(Int?.self, forKey: .maxOnlineTime)
        }
        if decoderContainer.contains(.totalMessages)
        {
            self.totalMessages = try decoderContainer.decode(Int?.self, forKey: .totalMessages)
        }
    }
}
public extension UserDetails{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: UserDetailsCodingKeys.self)
         try encoderContainer.encode(userPin, forKey: .userPin)
         try encoderContainer.encode(regionName, forKey: .regionName)
         try encoderContainer.encode(userStatus, forKey: .userStatus)
         try encoderContainer.encode(signTime, forKey: .signTime)
         try encoderContainer.encode(chargeType, forKey: .chargeType)
         try encoderContainer.encode(productNum, forKey: .productNum)
         try encoderContainer.encode(deviceNum, forKey: .deviceNum)
         try encoderContainer.encode(onDevices, forKey: .onDevices)
         try encoderContainer.encode(maxOnlineTime, forKey: .maxOnlineTime)
         try encoderContainer.encode(totalMessages, forKey: .totalMessages)
    }
}
///  productAbility
public class ProductAbility:NSObject,Codable{
    /// 功能唯一标识
    /// Required:true
    var abilityId:String
    /// 名称
    /// Required:true
    var abilityName:String
    /// 类型,0:属性,1:事件,2:服务
    /// Required:true
    var abilityType:Int
    /// 描述
    var abilityDescription:String?
    /// 读写性,read_only:只读,read_write:读写
    var accessMode:String?
    /// 数据类型
    var abilityDataType:String?
    /// 数据定义
    var abilityDataSpec:String?
    /// 是否为自定义功能,false:否,true:是
    /// Required:true
    var customized:Bool
    /// 创建时间,时间为东八区(UTC/GMT+08:00)
    /// Required:true
    var createdTime:Int64



    public  init(abilityId:String,abilityName:String,abilityType:Int,customized:Bool,createdTime:Int64){
             self.abilityId = abilityId
             self.abilityName = abilityName
             self.abilityType = abilityType
             self.customized = customized
             self.createdTime = createdTime
    }

    enum ProductAbilityCodingKeys: String, CodingKey {
        case abilityId
        case abilityName
        case abilityType
        case abilityDescription
        case accessMode
        case abilityDataType
        case abilityDataSpec
        case customized
        case createdTime
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: ProductAbilityCodingKeys.self)
        self.abilityId = try decoderContainer.decode(String.self, forKey: .abilityId)
        self.abilityName = try decoderContainer.decode(String.self, forKey: .abilityName)
        self.abilityType = try decoderContainer.decode(Int.self, forKey: .abilityType)
        if decoderContainer.contains(.abilityDescription)
        {
            self.abilityDescription = try decoderContainer.decode(String?.self, forKey: .abilityDescription)
        }
        if decoderContainer.contains(.accessMode)
        {
            self.accessMode = try decoderContainer.decode(String?.self, forKey: .accessMode)
        }
        if decoderContainer.contains(.abilityDataType)
        {
            self.abilityDataType = try decoderContainer.decode(String?.self, forKey: .abilityDataType)
        }
        if decoderContainer.contains(.abilityDataSpec)
        {
            self.abilityDataSpec = try decoderContainer.decode(String?.self, forKey: .abilityDataSpec)
        }
        self.customized = try decoderContainer.decode(Bool.self, forKey: .customized)
        self.createdTime = try decoderContainer.decode(Int64.self, forKey: .createdTime)
    }
}
public extension ProductAbility{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: ProductAbilityCodingKeys.self)
         try encoderContainer.encode(abilityId, forKey: .abilityId)
         try encoderContainer.encode(abilityName, forKey: .abilityName)
         try encoderContainer.encode(abilityType, forKey: .abilityType)
         try encoderContainer.encode(abilityDescription, forKey: .abilityDescription)
         try encoderContainer.encode(accessMode, forKey: .accessMode)
         try encoderContainer.encode(abilityDataType, forKey: .abilityDataType)
         try encoderContainer.encode(abilityDataSpec, forKey: .abilityDataSpec)
         try encoderContainer.encode(customized, forKey: .customized)
         try encoderContainer.encode(createdTime, forKey: .createdTime)
    }
}
///  monitorIotHubInstance
public class MonitorIotHubInstance:NSObject,Codable{
    /// 实例Id
    var instanceId:String?
    /// 用户PIN
    var userPin:String?
    /// 开通时间
    var createdTime:Int64?
    /// 公网域名
    var pubDomain:String?



    public override init(){
            super.init()
    }

    enum MonitorIotHubInstanceCodingKeys: String, CodingKey {
        case instanceId
        case userPin
        case createdTime
        case pubDomain
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: MonitorIotHubInstanceCodingKeys.self)
        if decoderContainer.contains(.instanceId)
        {
            self.instanceId = try decoderContainer.decode(String?.self, forKey: .instanceId)
        }
        if decoderContainer.contains(.userPin)
        {
            self.userPin = try decoderContainer.decode(String?.self, forKey: .userPin)
        }
        if decoderContainer.contains(.createdTime)
        {
            self.createdTime = try decoderContainer.decode(Int64?.self, forKey: .createdTime)
        }
        if decoderContainer.contains(.pubDomain)
        {
            self.pubDomain = try decoderContainer.decode(String?.self, forKey: .pubDomain)
        }
    }
}
public extension MonitorIotHubInstance{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: MonitorIotHubInstanceCodingKeys.self)
         try encoderContainer.encode(instanceId, forKey: .instanceId)
         try encoderContainer.encode(userPin, forKey: .userPin)
         try encoderContainer.encode(createdTime, forKey: .createdTime)
         try encoderContainer.encode(pubDomain, forKey: .pubDomain)
    }
}
///  regionInfo
public class RegionInfo:NSObject,Codable{
    /// region编号
    var regionId:String?
    /// region名称
    var regionName:String?
    /// AZ集合
    var azInfo:[Azs?]?



    public override init(){
            super.init()
    }

    enum RegionInfoCodingKeys: String, CodingKey {
        case regionId
        case regionName
        case azInfo
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: RegionInfoCodingKeys.self)
        if decoderContainer.contains(.regionId)
        {
            self.regionId = try decoderContainer.decode(String?.self, forKey: .regionId)
        }
        if decoderContainer.contains(.regionName)
        {
            self.regionName = try decoderContainer.decode(String?.self, forKey: .regionName)
        }
        if decoderContainer.contains(.azInfo)
        {
            self.azInfo = try decoderContainer.decode([Azs?]?.self, forKey: .azInfo)
        }
    }
}
public extension RegionInfo{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: RegionInfoCodingKeys.self)
         try encoderContainer.encode(regionId, forKey: .regionId)
         try encoderContainer.encode(regionName, forKey: .regionName)
         try encoderContainer.encode(azInfo, forKey: .azInfo)
    }
}
///  azs
public class Azs:NSObject,Codable{
    /// az编号
    var azId:String?
    /// az名称
    var azName:String?



    public override init(){
            super.init()
    }

    enum AzsCodingKeys: String, CodingKey {
        case azId
        case azName
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: AzsCodingKeys.self)
        if decoderContainer.contains(.azId)
        {
            self.azId = try decoderContainer.decode(String?.self, forKey: .azId)
        }
        if decoderContainer.contains(.azName)
        {
            self.azName = try decoderContainer.decode(String?.self, forKey: .azName)
        }
    }
}
public extension Azs{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: AzsCodingKeys.self)
         try encoderContainer.encode(azId, forKey: .azId)
         try encoderContainer.encode(azName, forKey: .azName)
    }
}
///  monthDuration
public class MonthDuration:NSObject,Codable{
    /// 日期
    var durationMonth:String?
    /// 时长(分钟)
    var durationValue:Int64?



    public override init(){
            super.init()
    }

    enum MonthDurationCodingKeys: String, CodingKey {
        case durationMonth
        case durationValue
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: MonthDurationCodingKeys.self)
        if decoderContainer.contains(.durationMonth)
        {
            self.durationMonth = try decoderContainer.decode(String?.self, forKey: .durationMonth)
        }
        if decoderContainer.contains(.durationValue)
        {
            self.durationValue = try decoderContainer.decode(Int64?.self, forKey: .durationValue)
        }
    }
}
public extension MonthDuration{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: MonthDurationCodingKeys.self)
         try encoderContainer.encode(durationMonth, forKey: .durationMonth)
         try encoderContainer.encode(durationValue, forKey: .durationValue)
    }
}
///  monthMessage
public class MonthMessage:NSObject,Codable{
    /// 日期
    var messageMonth:String?
    /// 时长(分钟)
    var messageValue:Int64?



    public override init(){
            super.init()
    }

    enum MonthMessageCodingKeys: String, CodingKey {
        case messageMonth
        case messageValue
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: MonthMessageCodingKeys.self)
        if decoderContainer.contains(.messageMonth)
        {
            self.messageMonth = try decoderContainer.decode(String?.self, forKey: .messageMonth)
        }
        if decoderContainer.contains(.messageValue)
        {
            self.messageValue = try decoderContainer.decode(Int64?.self, forKey: .messageValue)
        }
    }
}
public extension MonthMessage{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: MonthMessageCodingKeys.self)
         try encoderContainer.encode(messageMonth, forKey: .messageMonth)
         try encoderContainer.encode(messageValue, forKey: .messageValue)
    }
}
///  service
public class Service:NSObject,Codable{
    /// 服务名称
    var name:String?
    /// 服务ID
    var serviceId:String?
    /// 服务描述
    var descriptionValue:String?
    /// 服务入参,object的key为参数名称，value为参数值
    var input:AnyObject?
    /// 服务出参,object的key为参数名称，value为参数值
    var output:AnyObject?
    /// 结果码200:成功,400:参数错误
    var code:Int?
    /// 创建时间
    var createdTime:Int64?



    public override init(){
            super.init()
    }

    enum ServiceCodingKeys: String, CodingKey {
        case name
        case serviceId
        case descriptionValue = "description"
        case input
        case output
        case code
        case createdTime
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: ServiceCodingKeys.self)
        if decoderContainer.contains(.name)
        {
            self.name = try decoderContainer.decode(String?.self, forKey: .name)
        }
        if decoderContainer.contains(.serviceId)
        {
            self.serviceId = try decoderContainer.decode(String?.self, forKey: .serviceId)
        }
        if decoderContainer.contains(.descriptionValue)
        {
            self.descriptionValue = try decoderContainer.decode(String?.self, forKey: .descriptionValue)
        }
        if decoderContainer.contains(.code)
        {
            self.code = try decoderContainer.decode(Int?.self, forKey: .code)
        }
        if decoderContainer.contains(.createdTime)
        {
            self.createdTime = try decoderContainer.decode(Int64?.self, forKey: .createdTime)
        }
    }
}
public extension Service{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: ServiceCodingKeys.self)
         try encoderContainer.encode(name, forKey: .name)
         try encoderContainer.encode(serviceId, forKey: .serviceId)
         try encoderContainer.encode(descriptionValue, forKey: .descriptionValue)
         try encoderContainer.encode(code, forKey: .code)
         try encoderContainer.encode(createdTime, forKey: .createdTime)
    }
}
///  deviceVO
public class DeviceVO:NSObject,Codable{
    /// 设备ID
    var deviceId:String?
    /// 设备名称
    var deviceName:String?
    /// 父级设备Id
    var parentId:String?
    /// 设备类型，同产品类型，0-普通设备，1-网关，2-Edge
    var deviceType:String?
    /// 设备状态，0-未激活，1-激活离线，2-激活在线
    var status:Int?
    /// 产品Key
    var productKey:String?
    /// 设备标识符
    var identifier:String?
    /// 设备秘钥
    var secret:String?
    /// 设备描述
    var descriptionValue:String?
    /// 激活时间
    var activatedTime:Int64?
    /// 最后连接时间
    var lastConnectedTime:Int64?
    /// 注册时间
    var createdTime:Int64?
    /// 修改时间
    var updatedTime:Int64?
    /// 产品秘钥
    var productSecret:String?
    /// 产品名称
    var productName:String?
    /// 设备型号
    var model:String?
    /// 设备厂商
    var manufacturer:String?
    /// 是否开启动态注册,0:关闭,1:开启，开启动态注册的设备认证类型为一型一密，否则为一机一密
    var dynamicRegister:Int?



    public override init(){
            super.init()
    }

    enum DeviceVOCodingKeys: String, CodingKey {
        case deviceId
        case deviceName
        case parentId
        case deviceType
        case status
        case productKey
        case identifier
        case secret
        case descriptionValue = "description"
        case activatedTime
        case lastConnectedTime
        case createdTime
        case updatedTime
        case productSecret
        case productName
        case model
        case manufacturer
        case dynamicRegister
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: DeviceVOCodingKeys.self)
        if decoderContainer.contains(.deviceId)
        {
            self.deviceId = try decoderContainer.decode(String?.self, forKey: .deviceId)
        }
        if decoderContainer.contains(.deviceName)
        {
            self.deviceName = try decoderContainer.decode(String?.self, forKey: .deviceName)
        }
        if decoderContainer.contains(.parentId)
        {
            self.parentId = try decoderContainer.decode(String?.self, forKey: .parentId)
        }
        if decoderContainer.contains(.deviceType)
        {
            self.deviceType = try decoderContainer.decode(String?.self, forKey: .deviceType)
        }
        if decoderContainer.contains(.status)
        {
            self.status = try decoderContainer.decode(Int?.self, forKey: .status)
        }
        if decoderContainer.contains(.productKey)
        {
            self.productKey = try decoderContainer.decode(String?.self, forKey: .productKey)
        }
        if decoderContainer.contains(.identifier)
        {
            self.identifier = try decoderContainer.decode(String?.self, forKey: .identifier)
        }
        if decoderContainer.contains(.secret)
        {
            self.secret = try decoderContainer.decode(String?.self, forKey: .secret)
        }
        if decoderContainer.contains(.descriptionValue)
        {
            self.descriptionValue = try decoderContainer.decode(String?.self, forKey: .descriptionValue)
        }
        if decoderContainer.contains(.activatedTime)
        {
            self.activatedTime = try decoderContainer.decode(Int64?.self, forKey: .activatedTime)
        }
        if decoderContainer.contains(.lastConnectedTime)
        {
            self.lastConnectedTime = try decoderContainer.decode(Int64?.self, forKey: .lastConnectedTime)
        }
        if decoderContainer.contains(.createdTime)
        {
            self.createdTime = try decoderContainer.decode(Int64?.self, forKey: .createdTime)
        }
        if decoderContainer.contains(.updatedTime)
        {
            self.updatedTime = try decoderContainer.decode(Int64?.self, forKey: .updatedTime)
        }
        if decoderContainer.contains(.productSecret)
        {
            self.productSecret = try decoderContainer.decode(String?.self, forKey: .productSecret)
        }
        if decoderContainer.contains(.productName)
        {
            self.productName = try decoderContainer.decode(String?.self, forKey: .productName)
        }
        if decoderContainer.contains(.model)
        {
            self.model = try decoderContainer.decode(String?.self, forKey: .model)
        }
        if decoderContainer.contains(.manufacturer)
        {
            self.manufacturer = try decoderContainer.decode(String?.self, forKey: .manufacturer)
        }
        if decoderContainer.contains(.dynamicRegister)
        {
            self.dynamicRegister = try decoderContainer.decode(Int?.self, forKey: .dynamicRegister)
        }
    }
}
public extension DeviceVO{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: DeviceVOCodingKeys.self)
         try encoderContainer.encode(deviceId, forKey: .deviceId)
         try encoderContainer.encode(deviceName, forKey: .deviceName)
         try encoderContainer.encode(parentId, forKey: .parentId)
         try encoderContainer.encode(deviceType, forKey: .deviceType)
         try encoderContainer.encode(status, forKey: .status)
         try encoderContainer.encode(productKey, forKey: .productKey)
         try encoderContainer.encode(identifier, forKey: .identifier)
         try encoderContainer.encode(secret, forKey: .secret)
         try encoderContainer.encode(descriptionValue, forKey: .descriptionValue)
         try encoderContainer.encode(activatedTime, forKey: .activatedTime)
         try encoderContainer.encode(lastConnectedTime, forKey: .lastConnectedTime)
         try encoderContainer.encode(createdTime, forKey: .createdTime)
         try encoderContainer.encode(updatedTime, forKey: .updatedTime)
         try encoderContainer.encode(productSecret, forKey: .productSecret)
         try encoderContainer.encode(productName, forKey: .productName)
         try encoderContainer.encode(model, forKey: .model)
         try encoderContainer.encode(manufacturer, forKey: .manufacturer)
         try encoderContainer.encode(dynamicRegister, forKey: .dynamicRegister)
    }
}
///  deviceCredential
public class DeviceCredential:NSObject,Codable{
    /// 设备Id
    var deviceId:String?
    /// 设备名称
    var deviceName:String?
    /// 设备鉴权标识
    var identifier:String?
    /// 设备秘钥
    var secret:String?
    /// 所属产品
    var productKey:String?



    public override init(){
            super.init()
    }

    enum DeviceCredentialCodingKeys: String, CodingKey {
        case deviceId
        case deviceName
        case identifier
        case secret
        case productKey
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: DeviceCredentialCodingKeys.self)
        if decoderContainer.contains(.deviceId)
        {
            self.deviceId = try decoderContainer.decode(String?.self, forKey: .deviceId)
        }
        if decoderContainer.contains(.deviceName)
        {
            self.deviceName = try decoderContainer.decode(String?.self, forKey: .deviceName)
        }
        if decoderContainer.contains(.identifier)
        {
            self.identifier = try decoderContainer.decode(String?.self, forKey: .identifier)
        }
        if decoderContainer.contains(.secret)
        {
            self.secret = try decoderContainer.decode(String?.self, forKey: .secret)
        }
        if decoderContainer.contains(.productKey)
        {
            self.productKey = try decoderContainer.decode(String?.self, forKey: .productKey)
        }
    }
}
public extension DeviceCredential{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: DeviceCredentialCodingKeys.self)
         try encoderContainer.encode(deviceId, forKey: .deviceId)
         try encoderContainer.encode(deviceName, forKey: .deviceName)
         try encoderContainer.encode(identifier, forKey: .identifier)
         try encoderContainer.encode(secret, forKey: .secret)
         try encoderContainer.encode(productKey, forKey: .productKey)
    }
}
///  topicList
public class TopicList:NSObject,Codable{
    /// topic
    var topic:String?
    /// 权限
    var authority:String?
    /// 描述
    var descripton:String?



    public override init(){
            super.init()
    }

    enum TopicListCodingKeys: String, CodingKey {
        case topic
        case authority
        case descripton
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: TopicListCodingKeys.self)
        if decoderContainer.contains(.topic)
        {
            self.topic = try decoderContainer.decode(String?.self, forKey: .topic)
        }
        if decoderContainer.contains(.authority)
        {
            self.authority = try decoderContainer.decode(String?.self, forKey: .authority)
        }
        if decoderContainer.contains(.descripton)
        {
            self.descripton = try decoderContainer.decode(String?.self, forKey: .descripton)
        }
    }
}
public extension TopicList{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: TopicListCodingKeys.self)
         try encoderContainer.encode(topic, forKey: .topic)
         try encoderContainer.encode(authority, forKey: .authority)
         try encoderContainer.encode(descripton, forKey: .descripton)
    }
}
///  deviceBatch
public class DeviceBatch:NSObject,Codable{
    /// 批次Id
    var batchId:String?
    /// 批次编号
    var batchNumber:String?
    /// 批次大小
    var batchSize:Int?
    /// 产品名称
    var productName:String?
    /// 添加方式
    var autoGenerated:Int?
    /// 下载链接
    var registerResultUrl:String?
    /// 生成时间
    var createdTime:Int64?



    public override init(){
            super.init()
    }

    enum DeviceBatchCodingKeys: String, CodingKey {
        case batchId
        case batchNumber
        case batchSize
        case productName
        case autoGenerated
        case registerResultUrl
        case createdTime
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: DeviceBatchCodingKeys.self)
        if decoderContainer.contains(.batchId)
        {
            self.batchId = try decoderContainer.decode(String?.self, forKey: .batchId)
        }
        if decoderContainer.contains(.batchNumber)
        {
            self.batchNumber = try decoderContainer.decode(String?.self, forKey: .batchNumber)
        }
        if decoderContainer.contains(.batchSize)
        {
            self.batchSize = try decoderContainer.decode(Int?.self, forKey: .batchSize)
        }
        if decoderContainer.contains(.productName)
        {
            self.productName = try decoderContainer.decode(String?.self, forKey: .productName)
        }
        if decoderContainer.contains(.autoGenerated)
        {
            self.autoGenerated = try decoderContainer.decode(Int?.self, forKey: .autoGenerated)
        }
        if decoderContainer.contains(.registerResultUrl)
        {
            self.registerResultUrl = try decoderContainer.decode(String?.self, forKey: .registerResultUrl)
        }
        if decoderContainer.contains(.createdTime)
        {
            self.createdTime = try decoderContainer.decode(Int64?.self, forKey: .createdTime)
        }
    }
}
public extension DeviceBatch{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: DeviceBatchCodingKeys.self)
         try encoderContainer.encode(batchId, forKey: .batchId)
         try encoderContainer.encode(batchNumber, forKey: .batchNumber)
         try encoderContainer.encode(batchSize, forKey: .batchSize)
         try encoderContainer.encode(productName, forKey: .productName)
         try encoderContainer.encode(autoGenerated, forKey: .autoGenerated)
         try encoderContainer.encode(registerResultUrl, forKey: .registerResultUrl)
         try encoderContainer.encode(createdTime, forKey: .createdTime)
    }
}
///  event
public class Event:NSObject,Codable{
    /// 事件名称
    var name:String?
    /// 事件ID
    var eventId:String?
    /// 事件类型
    var eventType:String?
    /// 输出参数,object的key为参数名称，value为参数值
    var output:AnyObject?
    /// 产生时间
    var createdTime:Int64?



    public override init(){
            super.init()
    }

    enum EventCodingKeys: String, CodingKey {
        case name
        case eventId
        case eventType
        case output
        case createdTime
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: EventCodingKeys.self)
        if decoderContainer.contains(.name)
        {
            self.name = try decoderContainer.decode(String?.self, forKey: .name)
        }
        if decoderContainer.contains(.eventId)
        {
            self.eventId = try decoderContainer.decode(String?.self, forKey: .eventId)
        }
        if decoderContainer.contains(.eventType)
        {
            self.eventType = try decoderContainer.decode(String?.self, forKey: .eventType)
        }
        if decoderContainer.contains(.createdTime)
        {
            self.createdTime = try decoderContainer.decode(Int64?.self, forKey: .createdTime)
        }
    }
}
public extension Event{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: EventCodingKeys.self)
         try encoderContainer.encode(name, forKey: .name)
         try encoderContainer.encode(eventId, forKey: .eventId)
         try encoderContainer.encode(eventType, forKey: .eventType)
         try encoderContainer.encode(createdTime, forKey: .createdTime)
    }
}
///  sharedUserPage
public class SharedUserPage:NSObject,Codable{
    /// 总用户数
    var totalSize:Int?
    /// 总页数
    var totalPage:Int?
    /// 每页条数
    var pageSize:Int?
    /// 当前页
    var nowPage:Int?
    /// 用户信息列表
    var users:[SharedUsers?]?



    public override init(){
            super.init()
    }

    enum SharedUserPageCodingKeys: String, CodingKey {
        case totalSize
        case totalPage
        case pageSize
        case nowPage
        case users
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: SharedUserPageCodingKeys.self)
        if decoderContainer.contains(.totalSize)
        {
            self.totalSize = try decoderContainer.decode(Int?.self, forKey: .totalSize)
        }
        if decoderContainer.contains(.totalPage)
        {
            self.totalPage = try decoderContainer.decode(Int?.self, forKey: .totalPage)
        }
        if decoderContainer.contains(.pageSize)
        {
            self.pageSize = try decoderContainer.decode(Int?.self, forKey: .pageSize)
        }
        if decoderContainer.contains(.nowPage)
        {
            self.nowPage = try decoderContainer.decode(Int?.self, forKey: .nowPage)
        }
        if decoderContainer.contains(.users)
        {
            self.users = try decoderContainer.decode([SharedUsers?]?.self, forKey: .users)
        }
    }
}
public extension SharedUserPage{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: SharedUserPageCodingKeys.self)
         try encoderContainer.encode(totalSize, forKey: .totalSize)
         try encoderContainer.encode(totalPage, forKey: .totalPage)
         try encoderContainer.encode(pageSize, forKey: .pageSize)
         try encoderContainer.encode(nowPage, forKey: .nowPage)
         try encoderContainer.encode(users, forKey: .users)
    }
}
///  sharedUsers
public class SharedUsers:NSObject,Codable{
    /// 用户Pin信息
    var userPin:Int?
    /// 用户对应的资源编号
    var sourceId:Int?
    /// 用户所属region
    var regionName:Int?
    /// 用户开通时间
    var createTime:Int?
    /// 租户状态[1-正常使用，2-欠费停服，3-软删除保护期]
    var tenantStatus:Int?
    /// 在线设备数
    var onDevices:Int?
    /// 日消息条数
    var dailyMessages:Int?
    /// 总消息条数
    var totalMessages:Int?



    public override init(){
            super.init()
    }

    enum SharedUsersCodingKeys: String, CodingKey {
        case userPin
        case sourceId
        case regionName
        case createTime
        case tenantStatus
        case onDevices
        case dailyMessages
        case totalMessages
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: SharedUsersCodingKeys.self)
        if decoderContainer.contains(.userPin)
        {
            self.userPin = try decoderContainer.decode(Int?.self, forKey: .userPin)
        }
        if decoderContainer.contains(.sourceId)
        {
            self.sourceId = try decoderContainer.decode(Int?.self, forKey: .sourceId)
        }
        if decoderContainer.contains(.regionName)
        {
            self.regionName = try decoderContainer.decode(Int?.self, forKey: .regionName)
        }
        if decoderContainer.contains(.createTime)
        {
            self.createTime = try decoderContainer.decode(Int?.self, forKey: .createTime)
        }
        if decoderContainer.contains(.tenantStatus)
        {
            self.tenantStatus = try decoderContainer.decode(Int?.self, forKey: .tenantStatus)
        }
        if decoderContainer.contains(.onDevices)
        {
            self.onDevices = try decoderContainer.decode(Int?.self, forKey: .onDevices)
        }
        if decoderContainer.contains(.dailyMessages)
        {
            self.dailyMessages = try decoderContainer.decode(Int?.self, forKey: .dailyMessages)
        }
        if decoderContainer.contains(.totalMessages)
        {
            self.totalMessages = try decoderContainer.decode(Int?.self, forKey: .totalMessages)
        }
    }
}
public extension SharedUsers{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: SharedUsersCodingKeys.self)
         try encoderContainer.encode(userPin, forKey: .userPin)
         try encoderContainer.encode(sourceId, forKey: .sourceId)
         try encoderContainer.encode(regionName, forKey: .regionName)
         try encoderContainer.encode(createTime, forKey: .createTime)
         try encoderContainer.encode(tenantStatus, forKey: .tenantStatus)
         try encoderContainer.encode(onDevices, forKey: .onDevices)
         try encoderContainer.encode(dailyMessages, forKey: .dailyMessages)
         try encoderContainer.encode(totalMessages, forKey: .totalMessages)
    }
}
///  instanceinfoVO
public class InstanceinfoVO:NSObject,Codable{
    /// IoT Hub实例编号
    var instanceId:String?
    /// IoT Hub实例名称
    var name:String?
    /// IoT Hub实例所属子网编号
    var subnetId:String?
    /// IoT Hub实例所属子网名称
    var subnetName:String?
    /// IoT Hub实例所属VPC编号
    var vpcId:String?
    /// IoT Hub实例所属VPC名称
    var vpcName:String?
    /// IoT Hub实例所属可用区名称[格式为可用区名称1@可用区名称2]
    var azName:String?
    /// IoT Hub实例提供的公网域名
    var pubDomain:String?
    /// IoT Hub实例提供的内网域名
    var priDomain:String?
    /// IoT Hub实例状态
      /// PREPARING-准备资源 |
      /// BUILDING-创建中 |
      /// RUNNING-运行中 |
      /// SUSPENDING-暂停使用
      /// 
    var instanceStatus:String?
    /// 100以内的进度条数值
    var progressValue:Int?
    /// IoT Hub实例创建时间
    var createTime:Int?
    /// IoT Hub实例到期时间
    var endTime:Int?
    /// IoT Hub实例描述
    var descriptionValue:String?
    /// IoT Hub实例所属Region编号
    var regionId:String?
    /// IoT Hub实例所属Region名称
    var regionName:String?
    /// 支持最大在线设备数量
    var maxDevices:Int?
    /// 最大支持消息数量
    var maxMessages:Int?



    public override init(){
            super.init()
    }

    enum InstanceinfoVOCodingKeys: String, CodingKey {
        case instanceId
        case name
        case subnetId
        case subnetName
        case vpcId
        case vpcName
        case azName
        case pubDomain
        case priDomain
        case instanceStatus
        case progressValue
        case createTime
        case endTime
        case descriptionValue = "description"
        case regionId
        case regionName
        case maxDevices
        case maxMessages
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: InstanceinfoVOCodingKeys.self)
        if decoderContainer.contains(.instanceId)
        {
            self.instanceId = try decoderContainer.decode(String?.self, forKey: .instanceId)
        }
        if decoderContainer.contains(.name)
        {
            self.name = try decoderContainer.decode(String?.self, forKey: .name)
        }
        if decoderContainer.contains(.subnetId)
        {
            self.subnetId = try decoderContainer.decode(String?.self, forKey: .subnetId)
        }
        if decoderContainer.contains(.subnetName)
        {
            self.subnetName = try decoderContainer.decode(String?.self, forKey: .subnetName)
        }
        if decoderContainer.contains(.vpcId)
        {
            self.vpcId = try decoderContainer.decode(String?.self, forKey: .vpcId)
        }
        if decoderContainer.contains(.vpcName)
        {
            self.vpcName = try decoderContainer.decode(String?.self, forKey: .vpcName)
        }
        if decoderContainer.contains(.azName)
        {
            self.azName = try decoderContainer.decode(String?.self, forKey: .azName)
        }
        if decoderContainer.contains(.pubDomain)
        {
            self.pubDomain = try decoderContainer.decode(String?.self, forKey: .pubDomain)
        }
        if decoderContainer.contains(.priDomain)
        {
            self.priDomain = try decoderContainer.decode(String?.self, forKey: .priDomain)
        }
        if decoderContainer.contains(.instanceStatus)
        {
            self.instanceStatus = try decoderContainer.decode(String?.self, forKey: .instanceStatus)
        }
        if decoderContainer.contains(.progressValue)
        {
            self.progressValue = try decoderContainer.decode(Int?.self, forKey: .progressValue)
        }
        if decoderContainer.contains(.createTime)
        {
            self.createTime = try decoderContainer.decode(Int?.self, forKey: .createTime)
        }
        if decoderContainer.contains(.endTime)
        {
            self.endTime = try decoderContainer.decode(Int?.self, forKey: .endTime)
        }
        if decoderContainer.contains(.descriptionValue)
        {
            self.descriptionValue = try decoderContainer.decode(String?.self, forKey: .descriptionValue)
        }
        if decoderContainer.contains(.regionId)
        {
            self.regionId = try decoderContainer.decode(String?.self, forKey: .regionId)
        }
        if decoderContainer.contains(.regionName)
        {
            self.regionName = try decoderContainer.decode(String?.self, forKey: .regionName)
        }
        if decoderContainer.contains(.maxDevices)
        {
            self.maxDevices = try decoderContainer.decode(Int?.self, forKey: .maxDevices)
        }
        if decoderContainer.contains(.maxMessages)
        {
            self.maxMessages = try decoderContainer.decode(Int?.self, forKey: .maxMessages)
        }
    }
}
public extension InstanceinfoVO{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: InstanceinfoVOCodingKeys.self)
         try encoderContainer.encode(instanceId, forKey: .instanceId)
         try encoderContainer.encode(name, forKey: .name)
         try encoderContainer.encode(subnetId, forKey: .subnetId)
         try encoderContainer.encode(subnetName, forKey: .subnetName)
         try encoderContainer.encode(vpcId, forKey: .vpcId)
         try encoderContainer.encode(vpcName, forKey: .vpcName)
         try encoderContainer.encode(azName, forKey: .azName)
         try encoderContainer.encode(pubDomain, forKey: .pubDomain)
         try encoderContainer.encode(priDomain, forKey: .priDomain)
         try encoderContainer.encode(instanceStatus, forKey: .instanceStatus)
         try encoderContainer.encode(progressValue, forKey: .progressValue)
         try encoderContainer.encode(createTime, forKey: .createTime)
         try encoderContainer.encode(endTime, forKey: .endTime)
         try encoderContainer.encode(descriptionValue, forKey: .descriptionValue)
         try encoderContainer.encode(regionId, forKey: .regionId)
         try encoderContainer.encode(regionName, forKey: .regionName)
         try encoderContainer.encode(maxDevices, forKey: .maxDevices)
         try encoderContainer.encode(maxMessages, forKey: .maxMessages)
    }
}
///  instanceInfoAsAdminVO
public class InstanceInfoAsAdminVO:NSObject,Codable{
    /// IoT Hub实例编号
    var instanceId:String?
    /// IoT Hub实例名称
    var name:String?
    /// 创建实例的主Pin信息
    var userPin:String?
    /// IoT Hub实例所属子网编号
    var subnetId:String?
    /// IoT Hub实例所属子网名称
    var subNetName:String?
    /// IoT Hub实例所属VPC编号
    var vpcId:String?
    /// IoT Hub实例所属VPC名称
    var vpcName:String?
    /// IoT Hub实例所属可用区名称[格式为可用区名称1@可用区名称2]
    var azName:String?
    /// IoT Hub实例提供的公网域名
    var pubDomain:String?
    /// IoT Hub实例提供的内网域名
    var priDomain:String?
    /// IoT Hub实例创建时间
    var createTime:Int?
    /// IoT Hub实例到期时间
    var endTime:Int?
    /// IoT Hub实例删除时间
    var deleteTime:Int?
    /// IoT Hub实例描述
    var descriptionValue:String?
    /// IoT Hub实例所属Region编号
    var regionId:String?
    /// IoT Hub实例所属Region名称
    var regionName:String?
    /// IoT Hub实例中单AZ容器节点数量[每增加1个节点，会在两个AZ下各添加一个容器]
    var replicaNum:Int?
    /// 支持最大在线设备数量
    var maxDevices:Int?
    /// 最大支持消息数量
    var maxMessages:Int?
    /// IoT Hub实例依赖数据库实例编号
    var rdsInstanceId:String?
    /// IoT Hub实例依赖数据库库名
    var rdsDatabase:String?
    /// IoT Hub实例依赖数据库内网域名
    var rdsHostName:String?
    /// IoT Hub实例依赖数据库用户名
    var rdsUserName:String?
    /// IoT Hub实例依赖数据库密码
    var rdsPasswd:String?
    /// IoT Hub实例使用的Agent编号[如已删除则为空]
    var iothubAgentId:String?
    /// IoT Hub实例状态：
      ///   0-IOTHUB_AND_AGENT_RUNNING
      ///   1-IOTHUB_RUNNING
      ///   2-IOTHUB_SUSPEND
      ///   3-IOTHUB_TO_BE_DELETED
      ///   4-IOTHUB_UPDATING
      ///   11-CREATE_PARAMETER_GROUP_SUCCESS
      ///   12-CREATE_PARAMETER_GROUP_FAIL
      ///   13-CREATE_AGENT_SUCCESS
      ///   14-CREATE_AGENT_FAIL
      ///   15-CREATE_MYSQL_SUCCESS
      ///   16-AGENT_JVESSEL_RUNNING
      ///   17-AGENT_RUNNING
      ///   18-MYSQL_RUNNING
      ///   21-CREATE_DATABASE_SUCCESS
      ///   22-CREATE_DATABASE_FAIL
      ///   31-CREATE_ACCOUNT_SUCCESS
      ///   32-CREATE_ACCOUNT_FAIL
      ///   41-GRANT_PRIVILEGE_SUCCESS
      ///   42-GRANT_PRIVILEGE_FAIL
      ///   51-WAIT_INIT_DATABASE
      ///   52-INIT_DATABASE_SUCCESS
      ///   53-INIT_DATABASE_FAIL
      ///   61-DEL_AGENT_SUCCESS
      ///   62-DEL_AGENT_FAIL
      ///   71-WAIT_CREATE_IOTHUB
      ///   72-CREATE_IOTHUB_SUCCESS
      ///   73-CREATE_IOTHUB_JVESSEL_RUNNING
      ///   74-CREATE_IOTHUB_RUNNING
      ///   75-IOTHUB_USER_PIN_SIGNUP
      ///   79-CREATE_IOTHUB_FAIL
      /// 
    var iothubStatus:Int?



    public override init(){
            super.init()
    }

    enum InstanceInfoAsAdminVOCodingKeys: String, CodingKey {
        case instanceId
        case name
        case userPin
        case subnetId
        case subNetName
        case vpcId
        case vpcName
        case azName
        case pubDomain
        case priDomain
        case createTime
        case endTime
        case deleteTime
        case descriptionValue = "description"
        case regionId
        case regionName
        case replicaNum
        case maxDevices
        case maxMessages
        case rdsInstanceId
        case rdsDatabase
        case rdsHostName
        case rdsUserName
        case rdsPasswd
        case iothubAgentId
        case iothubStatus
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: InstanceInfoAsAdminVOCodingKeys.self)
        if decoderContainer.contains(.instanceId)
        {
            self.instanceId = try decoderContainer.decode(String?.self, forKey: .instanceId)
        }
        if decoderContainer.contains(.name)
        {
            self.name = try decoderContainer.decode(String?.self, forKey: .name)
        }
        if decoderContainer.contains(.userPin)
        {
            self.userPin = try decoderContainer.decode(String?.self, forKey: .userPin)
        }
        if decoderContainer.contains(.subnetId)
        {
            self.subnetId = try decoderContainer.decode(String?.self, forKey: .subnetId)
        }
        if decoderContainer.contains(.subNetName)
        {
            self.subNetName = try decoderContainer.decode(String?.self, forKey: .subNetName)
        }
        if decoderContainer.contains(.vpcId)
        {
            self.vpcId = try decoderContainer.decode(String?.self, forKey: .vpcId)
        }
        if decoderContainer.contains(.vpcName)
        {
            self.vpcName = try decoderContainer.decode(String?.self, forKey: .vpcName)
        }
        if decoderContainer.contains(.azName)
        {
            self.azName = try decoderContainer.decode(String?.self, forKey: .azName)
        }
        if decoderContainer.contains(.pubDomain)
        {
            self.pubDomain = try decoderContainer.decode(String?.self, forKey: .pubDomain)
        }
        if decoderContainer.contains(.priDomain)
        {
            self.priDomain = try decoderContainer.decode(String?.self, forKey: .priDomain)
        }
        if decoderContainer.contains(.createTime)
        {
            self.createTime = try decoderContainer.decode(Int?.self, forKey: .createTime)
        }
        if decoderContainer.contains(.endTime)
        {
            self.endTime = try decoderContainer.decode(Int?.self, forKey: .endTime)
        }
        if decoderContainer.contains(.deleteTime)
        {
            self.deleteTime = try decoderContainer.decode(Int?.self, forKey: .deleteTime)
        }
        if decoderContainer.contains(.descriptionValue)
        {
            self.descriptionValue = try decoderContainer.decode(String?.self, forKey: .descriptionValue)
        }
        if decoderContainer.contains(.regionId)
        {
            self.regionId = try decoderContainer.decode(String?.self, forKey: .regionId)
        }
        if decoderContainer.contains(.regionName)
        {
            self.regionName = try decoderContainer.decode(String?.self, forKey: .regionName)
        }
        if decoderContainer.contains(.replicaNum)
        {
            self.replicaNum = try decoderContainer.decode(Int?.self, forKey: .replicaNum)
        }
        if decoderContainer.contains(.maxDevices)
        {
            self.maxDevices = try decoderContainer.decode(Int?.self, forKey: .maxDevices)
        }
        if decoderContainer.contains(.maxMessages)
        {
            self.maxMessages = try decoderContainer.decode(Int?.self, forKey: .maxMessages)
        }
        if decoderContainer.contains(.rdsInstanceId)
        {
            self.rdsInstanceId = try decoderContainer.decode(String?.self, forKey: .rdsInstanceId)
        }
        if decoderContainer.contains(.rdsDatabase)
        {
            self.rdsDatabase = try decoderContainer.decode(String?.self, forKey: .rdsDatabase)
        }
        if decoderContainer.contains(.rdsHostName)
        {
            self.rdsHostName = try decoderContainer.decode(String?.self, forKey: .rdsHostName)
        }
        if decoderContainer.contains(.rdsUserName)
        {
            self.rdsUserName = try decoderContainer.decode(String?.self, forKey: .rdsUserName)
        }
        if decoderContainer.contains(.rdsPasswd)
        {
            self.rdsPasswd = try decoderContainer.decode(String?.self, forKey: .rdsPasswd)
        }
        if decoderContainer.contains(.iothubAgentId)
        {
            self.iothubAgentId = try decoderContainer.decode(String?.self, forKey: .iothubAgentId)
        }
        if decoderContainer.contains(.iothubStatus)
        {
            self.iothubStatus = try decoderContainer.decode(Int?.self, forKey: .iothubStatus)
        }
    }
}
public extension InstanceInfoAsAdminVO{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: InstanceInfoAsAdminVOCodingKeys.self)
         try encoderContainer.encode(instanceId, forKey: .instanceId)
         try encoderContainer.encode(name, forKey: .name)
         try encoderContainer.encode(userPin, forKey: .userPin)
         try encoderContainer.encode(subnetId, forKey: .subnetId)
         try encoderContainer.encode(subNetName, forKey: .subNetName)
         try encoderContainer.encode(vpcId, forKey: .vpcId)
         try encoderContainer.encode(vpcName, forKey: .vpcName)
         try encoderContainer.encode(azName, forKey: .azName)
         try encoderContainer.encode(pubDomain, forKey: .pubDomain)
         try encoderContainer.encode(priDomain, forKey: .priDomain)
         try encoderContainer.encode(createTime, forKey: .createTime)
         try encoderContainer.encode(endTime, forKey: .endTime)
         try encoderContainer.encode(deleteTime, forKey: .deleteTime)
         try encoderContainer.encode(descriptionValue, forKey: .descriptionValue)
         try encoderContainer.encode(regionId, forKey: .regionId)
         try encoderContainer.encode(regionName, forKey: .regionName)
         try encoderContainer.encode(replicaNum, forKey: .replicaNum)
         try encoderContainer.encode(maxDevices, forKey: .maxDevices)
         try encoderContainer.encode(maxMessages, forKey: .maxMessages)
         try encoderContainer.encode(rdsInstanceId, forKey: .rdsInstanceId)
         try encoderContainer.encode(rdsDatabase, forKey: .rdsDatabase)
         try encoderContainer.encode(rdsHostName, forKey: .rdsHostName)
         try encoderContainer.encode(rdsUserName, forKey: .rdsUserName)
         try encoderContainer.encode(rdsPasswd, forKey: .rdsPasswd)
         try encoderContainer.encode(iothubAgentId, forKey: .iothubAgentId)
         try encoderContainer.encode(iothubStatus, forKey: .iothubStatus)
    }
}
///  dataVO
public class DataVO:NSObject,Codable{
    /// 系统流水号
    var id:String?
    /// 实例名称
    var name:String?
    /// 子网编号
    var subNetId:String?
    /// 子网名称
    var subNetName:String?
    /// VPC编号
    var vpcId:String?
    /// VPC名称
    var vpcName:String?
    /// 可用区名称
    var azName:String?
    /// 公网域名
    var pubDomain:String?
    /// 内网域名
    var priDomain:String?
    /// IoT Hub实例状态[10~100为创建中,0或1-运行中,2-欠费停服,3-待删除]
    var status:Int?
    /// 创建时间
    var createTime:Int?
    /// 实例到期时间
    var endTime:Int?
    /// 最大在线设备数
    var maxDevices:Int?
    /// 最大消息条数
    var maxMessage:Int?
    /// 实例编号
    var instanceId:String?
    /// 实例类型[0-独享，1-共享]
    var instanceType:String?



    public override init(){
            super.init()
    }

    enum DataVOCodingKeys: String, CodingKey {
        case id
        case name
        case subNetId
        case subNetName
        case vpcId
        case vpcName
        case azName
        case pubDomain
        case priDomain
        case status
        case createTime
        case endTime
        case maxDevices
        case maxMessage
        case instanceId
        case instanceType
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: DataVOCodingKeys.self)
        if decoderContainer.contains(.id)
        {
            self.id = try decoderContainer.decode(String?.self, forKey: .id)
        }
        if decoderContainer.contains(.name)
        {
            self.name = try decoderContainer.decode(String?.self, forKey: .name)
        }
        if decoderContainer.contains(.subNetId)
        {
            self.subNetId = try decoderContainer.decode(String?.self, forKey: .subNetId)
        }
        if decoderContainer.contains(.subNetName)
        {
            self.subNetName = try decoderContainer.decode(String?.self, forKey: .subNetName)
        }
        if decoderContainer.contains(.vpcId)
        {
            self.vpcId = try decoderContainer.decode(String?.self, forKey: .vpcId)
        }
        if decoderContainer.contains(.vpcName)
        {
            self.vpcName = try decoderContainer.decode(String?.self, forKey: .vpcName)
        }
        if decoderContainer.contains(.azName)
        {
            self.azName = try decoderContainer.decode(String?.self, forKey: .azName)
        }
        if decoderContainer.contains(.pubDomain)
        {
            self.pubDomain = try decoderContainer.decode(String?.self, forKey: .pubDomain)
        }
        if decoderContainer.contains(.priDomain)
        {
            self.priDomain = try decoderContainer.decode(String?.self, forKey: .priDomain)
        }
        if decoderContainer.contains(.status)
        {
            self.status = try decoderContainer.decode(Int?.self, forKey: .status)
        }
        if decoderContainer.contains(.createTime)
        {
            self.createTime = try decoderContainer.decode(Int?.self, forKey: .createTime)
        }
        if decoderContainer.contains(.endTime)
        {
            self.endTime = try decoderContainer.decode(Int?.self, forKey: .endTime)
        }
        if decoderContainer.contains(.maxDevices)
        {
            self.maxDevices = try decoderContainer.decode(Int?.self, forKey: .maxDevices)
        }
        if decoderContainer.contains(.maxMessage)
        {
            self.maxMessage = try decoderContainer.decode(Int?.self, forKey: .maxMessage)
        }
        if decoderContainer.contains(.instanceId)
        {
            self.instanceId = try decoderContainer.decode(String?.self, forKey: .instanceId)
        }
        if decoderContainer.contains(.instanceType)
        {
            self.instanceType = try decoderContainer.decode(String?.self, forKey: .instanceType)
        }
    }
}
public extension DataVO{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: DataVOCodingKeys.self)
         try encoderContainer.encode(id, forKey: .id)
         try encoderContainer.encode(name, forKey: .name)
         try encoderContainer.encode(subNetId, forKey: .subNetId)
         try encoderContainer.encode(subNetName, forKey: .subNetName)
         try encoderContainer.encode(vpcId, forKey: .vpcId)
         try encoderContainer.encode(vpcName, forKey: .vpcName)
         try encoderContainer.encode(azName, forKey: .azName)
         try encoderContainer.encode(pubDomain, forKey: .pubDomain)
         try encoderContainer.encode(priDomain, forKey: .priDomain)
         try encoderContainer.encode(status, forKey: .status)
         try encoderContainer.encode(createTime, forKey: .createTime)
         try encoderContainer.encode(endTime, forKey: .endTime)
         try encoderContainer.encode(maxDevices, forKey: .maxDevices)
         try encoderContainer.encode(maxMessage, forKey: .maxMessage)
         try encoderContainer.encode(instanceId, forKey: .instanceId)
         try encoderContainer.encode(instanceType, forKey: .instanceType)
    }
}
///  resource
public class Resource:NSObject,Codable{
    /// 资源ID
    var resourceId:String?
    /// 资源名称
    var resourceName:String?



    public override init(){
            super.init()
    }

    enum ResourceCodingKeys: String, CodingKey {
        case resourceId
        case resourceName
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: ResourceCodingKeys.self)
        if decoderContainer.contains(.resourceId)
        {
            self.resourceId = try decoderContainer.decode(String?.self, forKey: .resourceId)
        }
        if decoderContainer.contains(.resourceName)
        {
            self.resourceName = try decoderContainer.decode(String?.self, forKey: .resourceName)
        }
    }
}
public extension Resource{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: ResourceCodingKeys.self)
         try encoderContainer.encode(resourceId, forKey: .resourceId)
         try encoderContainer.encode(resourceName, forKey: .resourceName)
    }
}
///  product
public class Product:NSObject,Codable{
    /// 产品名称
    var productName:String?
    /// 产品ID
    var productId:String?
    /// 0：设备。设备不能挂载子设备。可以直连物联网平台，也可以作为网关的子设备连接物联网平台
      /// 1：网关。网关可以挂载子设备，具有子设备管理模块，维持子设备的拓扑关系，和将拓扑关系同步到物联网平台
      /// 
    var productType:Int?
    /// 产品Key
    var productKey:String?
    /// 创建时间，创建时间，时间为东八区（UTC/GMT+08:00）
    var createdTime:Int64?
    /// 产品类型，如自定义等
    var templateName:String?



    public override init(){
            super.init()
    }

    enum ProductCodingKeys: String, CodingKey {
        case productName
        case productId
        case productType
        case productKey
        case createdTime
        case templateName
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: ProductCodingKeys.self)
        if decoderContainer.contains(.productName)
        {
            self.productName = try decoderContainer.decode(String?.self, forKey: .productName)
        }
        if decoderContainer.contains(.productId)
        {
            self.productId = try decoderContainer.decode(String?.self, forKey: .productId)
        }
        if decoderContainer.contains(.productType)
        {
            self.productType = try decoderContainer.decode(Int?.self, forKey: .productType)
        }
        if decoderContainer.contains(.productKey)
        {
            self.productKey = try decoderContainer.decode(String?.self, forKey: .productKey)
        }
        if decoderContainer.contains(.createdTime)
        {
            self.createdTime = try decoderContainer.decode(Int64?.self, forKey: .createdTime)
        }
        if decoderContainer.contains(.templateName)
        {
            self.templateName = try decoderContainer.decode(String?.self, forKey: .templateName)
        }
    }
}
public extension Product{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: ProductCodingKeys.self)
         try encoderContainer.encode(productName, forKey: .productName)
         try encoderContainer.encode(productId, forKey: .productId)
         try encoderContainer.encode(productType, forKey: .productType)
         try encoderContainer.encode(productKey, forKey: .productKey)
         try encoderContainer.encode(createdTime, forKey: .createdTime)
         try encoderContainer.encode(templateName, forKey: .templateName)
    }
}
///  omPropVo
public class OmPropVo:NSObject,Codable{
    /// Uuid
    var uuid:String?
    /// OmId
    var omId:String?
    /// OmName
    var omName:String?
    /// AttrName
    var attrName:String?
    /// AttrText
    var attrText:String?
    /// AttrType
    var attrType:String?
    /// UserPin
    var userPin:String?
    /// InstanceId
    var instanceId:String?



    public override init(){
            super.init()
    }

    enum OmPropVoCodingKeys: String, CodingKey {
        case uuid
        case omId
        case omName
        case attrName
        case attrText
        case attrType
        case userPin
        case instanceId
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: OmPropVoCodingKeys.self)
        if decoderContainer.contains(.uuid)
        {
            self.uuid = try decoderContainer.decode(String?.self, forKey: .uuid)
        }
        if decoderContainer.contains(.omId)
        {
            self.omId = try decoderContainer.decode(String?.self, forKey: .omId)
        }
        if decoderContainer.contains(.omName)
        {
            self.omName = try decoderContainer.decode(String?.self, forKey: .omName)
        }
        if decoderContainer.contains(.attrName)
        {
            self.attrName = try decoderContainer.decode(String?.self, forKey: .attrName)
        }
        if decoderContainer.contains(.attrText)
        {
            self.attrText = try decoderContainer.decode(String?.self, forKey: .attrText)
        }
        if decoderContainer.contains(.attrType)
        {
            self.attrType = try decoderContainer.decode(String?.self, forKey: .attrType)
        }
        if decoderContainer.contains(.userPin)
        {
            self.userPin = try decoderContainer.decode(String?.self, forKey: .userPin)
        }
        if decoderContainer.contains(.instanceId)
        {
            self.instanceId = try decoderContainer.decode(String?.self, forKey: .instanceId)
        }
    }
}
public extension OmPropVo{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: OmPropVoCodingKeys.self)
         try encoderContainer.encode(uuid, forKey: .uuid)
         try encoderContainer.encode(omId, forKey: .omId)
         try encoderContainer.encode(omName, forKey: .omName)
         try encoderContainer.encode(attrName, forKey: .attrName)
         try encoderContainer.encode(attrText, forKey: .attrText)
         try encoderContainer.encode(attrType, forKey: .attrType)
         try encoderContainer.encode(userPin, forKey: .userPin)
         try encoderContainer.encode(instanceId, forKey: .instanceId)
    }
}
///  deviceCommandVO
public class DeviceCommandVO:NSObject,Codable{
    /// Name
    var name:String?
    /// InputData
    var inputData:String?



    public override init(){
            super.init()
    }

    enum DeviceCommandVOCodingKeys: String, CodingKey {
        case name
        case inputData
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: DeviceCommandVOCodingKeys.self)
        if decoderContainer.contains(.name)
        {
            self.name = try decoderContainer.decode(String?.self, forKey: .name)
        }
        if decoderContainer.contains(.inputData)
        {
            self.inputData = try decoderContainer.decode(String?.self, forKey: .inputData)
        }
    }
}
public extension DeviceCommandVO{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: DeviceCommandVOCodingKeys.self)
         try encoderContainer.encode(name, forKey: .name)
         try encoderContainer.encode(inputData, forKey: .inputData)
    }
}
///  productCategory
public class ProductCategory:NSObject,Codable{
    /// 产品分类名称
    var productCategoryName:String?
    /// 产品分类唯一标识
    var productCategoryId:String?



    public override init(){
            super.init()
    }

    enum ProductCategoryCodingKeys: String, CodingKey {
        case productCategoryName
        case productCategoryId
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: ProductCategoryCodingKeys.self)
        if decoderContainer.contains(.productCategoryName)
        {
            self.productCategoryName = try decoderContainer.decode(String?.self, forKey: .productCategoryName)
        }
        if decoderContainer.contains(.productCategoryId)
        {
            self.productCategoryId = try decoderContainer.decode(String?.self, forKey: .productCategoryId)
        }
    }
}
public extension ProductCategory{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: ProductCategoryCodingKeys.self)
         try encoderContainer.encode(productCategoryName, forKey: .productCategoryName)
         try encoderContainer.encode(productCategoryId, forKey: .productCategoryId)
    }
}
///  thingModelTemplate
public class ThingModelTemplate:NSObject,Codable{
    /// 物模型模板ID
    var thingModelTemplateId:String?
    /// 模型模板名称
    var thingModelTemplateName:String?
    /// 产品分类名称数组，索引0为一级产品分类名称
    var productCategoryNames:[String?]?
    /// 产品分类ID数组，索引0为一级产品分类ID
    var productCategoryIds:[String?]?
    /// 更新时间，时间为东八区（UTC/GMT+08:00）
    var updatedTime:Int64?
    /// 操作人
    var userPin:String?
    /// 物模型文件在oss上的存储路径
    var ossPath:String?



    public override init(){
            super.init()
    }

    enum ThingModelTemplateCodingKeys: String, CodingKey {
        case thingModelTemplateId
        case thingModelTemplateName
        case productCategoryNames
        case productCategoryIds
        case updatedTime
        case userPin
        case ossPath
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: ThingModelTemplateCodingKeys.self)
        if decoderContainer.contains(.thingModelTemplateId)
        {
            self.thingModelTemplateId = try decoderContainer.decode(String?.self, forKey: .thingModelTemplateId)
        }
        if decoderContainer.contains(.thingModelTemplateName)
        {
            self.thingModelTemplateName = try decoderContainer.decode(String?.self, forKey: .thingModelTemplateName)
        }
        if decoderContainer.contains(.productCategoryNames)
        {
            self.productCategoryNames = try decoderContainer.decode([String?]?.self, forKey: .productCategoryNames)
        }
        if decoderContainer.contains(.productCategoryIds)
        {
            self.productCategoryIds = try decoderContainer.decode([String?]?.self, forKey: .productCategoryIds)
        }
        if decoderContainer.contains(.updatedTime)
        {
            self.updatedTime = try decoderContainer.decode(Int64?.self, forKey: .updatedTime)
        }
        if decoderContainer.contains(.userPin)
        {
            self.userPin = try decoderContainer.decode(String?.self, forKey: .userPin)
        }
        if decoderContainer.contains(.ossPath)
        {
            self.ossPath = try decoderContainer.decode(String?.self, forKey: .ossPath)
        }
    }
}
public extension ThingModelTemplate{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: ThingModelTemplateCodingKeys.self)
         try encoderContainer.encode(thingModelTemplateId, forKey: .thingModelTemplateId)
         try encoderContainer.encode(thingModelTemplateName, forKey: .thingModelTemplateName)
         try encoderContainer.encode(productCategoryNames, forKey: .productCategoryNames)
         try encoderContainer.encode(productCategoryIds, forKey: .productCategoryIds)
         try encoderContainer.encode(updatedTime, forKey: .updatedTime)
         try encoderContainer.encode(userPin, forKey: .userPin)
         try encoderContainer.encode(ossPath, forKey: .ossPath)
    }
}
///  onlineInfo
public class OnlineInfo:NSObject,Codable{
    /// DeviceId
    var deviceId:String?
    /// Online
    var online:Int?
    /// LastConnectTime
    var lastConnectTime:String?



    public override init(){
            super.init()
    }

    enum OnlineInfoCodingKeys: String, CodingKey {
        case deviceId
        case online
        case lastConnectTime
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: OnlineInfoCodingKeys.self)
        if decoderContainer.contains(.deviceId)
        {
            self.deviceId = try decoderContainer.decode(String?.self, forKey: .deviceId)
        }
        if decoderContainer.contains(.online)
        {
            self.online = try decoderContainer.decode(Int?.self, forKey: .online)
        }
        if decoderContainer.contains(.lastConnectTime)
        {
            self.lastConnectTime = try decoderContainer.decode(String?.self, forKey: .lastConnectTime)
        }
    }
}
public extension OnlineInfo{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: OnlineInfoCodingKeys.self)
         try encoderContainer.encode(deviceId, forKey: .deviceId)
         try encoderContainer.encode(online, forKey: .online)
         try encoderContainer.encode(lastConnectTime, forKey: .lastConnectTime)
    }
}
///  describeDevicePageVo
public class DescribeDevicePageVo:NSObject,Codable{
    /// Uuid
    var uuid:String?
    /// InstanceId
    var instanceId:String?
    /// DeviceId
    var deviceId:String?
    /// DisplayName
    var displayName:String?
    /// DeviceType
    var deviceType:String?
    /// DeviceState
    var deviceState:String?
    /// OmId
    var omId:String?
    /// DeviceFilePath
    var deviceFilePath:String?
    /// OmName
    var omName:String?
    /// CreateTime
    var createTime:String?
    /// UserPin
    var userPin:String?
    /// ParentUuid
    var parentUuid:String?
    /// ParentName
    var parentName:String?
    /// LastConnectTime
    var lastConnectTime:String?



    public override init(){
            super.init()
    }

    enum DescribeDevicePageVoCodingKeys: String, CodingKey {
        case uuid
        case instanceId
        case deviceId
        case displayName
        case deviceType
        case deviceState
        case omId
        case deviceFilePath
        case omName
        case createTime
        case userPin
        case parentUuid
        case parentName
        case lastConnectTime
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: DescribeDevicePageVoCodingKeys.self)
        if decoderContainer.contains(.uuid)
        {
            self.uuid = try decoderContainer.decode(String?.self, forKey: .uuid)
        }
        if decoderContainer.contains(.instanceId)
        {
            self.instanceId = try decoderContainer.decode(String?.self, forKey: .instanceId)
        }
        if decoderContainer.contains(.deviceId)
        {
            self.deviceId = try decoderContainer.decode(String?.self, forKey: .deviceId)
        }
        if decoderContainer.contains(.displayName)
        {
            self.displayName = try decoderContainer.decode(String?.self, forKey: .displayName)
        }
        if decoderContainer.contains(.deviceType)
        {
            self.deviceType = try decoderContainer.decode(String?.self, forKey: .deviceType)
        }
        if decoderContainer.contains(.deviceState)
        {
            self.deviceState = try decoderContainer.decode(String?.self, forKey: .deviceState)
        }
        if decoderContainer.contains(.omId)
        {
            self.omId = try decoderContainer.decode(String?.self, forKey: .omId)
        }
        if decoderContainer.contains(.deviceFilePath)
        {
            self.deviceFilePath = try decoderContainer.decode(String?.self, forKey: .deviceFilePath)
        }
        if decoderContainer.contains(.omName)
        {
            self.omName = try decoderContainer.decode(String?.self, forKey: .omName)
        }
        if decoderContainer.contains(.createTime)
        {
            self.createTime = try decoderContainer.decode(String?.self, forKey: .createTime)
        }
        if decoderContainer.contains(.userPin)
        {
            self.userPin = try decoderContainer.decode(String?.self, forKey: .userPin)
        }
        if decoderContainer.contains(.parentUuid)
        {
            self.parentUuid = try decoderContainer.decode(String?.self, forKey: .parentUuid)
        }
        if decoderContainer.contains(.parentName)
        {
            self.parentName = try decoderContainer.decode(String?.self, forKey: .parentName)
        }
        if decoderContainer.contains(.lastConnectTime)
        {
            self.lastConnectTime = try decoderContainer.decode(String?.self, forKey: .lastConnectTime)
        }
    }
}
public extension DescribeDevicePageVo{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: DescribeDevicePageVoCodingKeys.self)
         try encoderContainer.encode(uuid, forKey: .uuid)
         try encoderContainer.encode(instanceId, forKey: .instanceId)
         try encoderContainer.encode(deviceId, forKey: .deviceId)
         try encoderContainer.encode(displayName, forKey: .displayName)
         try encoderContainer.encode(deviceType, forKey: .deviceType)
         try encoderContainer.encode(deviceState, forKey: .deviceState)
         try encoderContainer.encode(omId, forKey: .omId)
         try encoderContainer.encode(deviceFilePath, forKey: .deviceFilePath)
         try encoderContainer.encode(omName, forKey: .omName)
         try encoderContainer.encode(createTime, forKey: .createTime)
         try encoderContainer.encode(userPin, forKey: .userPin)
         try encoderContainer.encode(parentUuid, forKey: .parentUuid)
         try encoderContainer.encode(parentName, forKey: .parentName)
         try encoderContainer.encode(lastConnectTime, forKey: .lastConnectTime)
    }
}
///  deviceEnrollVO
public class DeviceEnrollVO:NSObject,Codable{
    /// DeviceIds
    var deviceIds:[String?]?
    /// ModelName
    var modelName:String?
    /// DeviceType
    var deviceType:Int?
    /// ParentDeviceName
    var parentDeviceName:String?



    public override init(){
            super.init()
    }

    enum DeviceEnrollVOCodingKeys: String, CodingKey {
        case deviceIds
        case modelName
        case deviceType
        case parentDeviceName
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: DeviceEnrollVOCodingKeys.self)
        if decoderContainer.contains(.deviceIds)
        {
            self.deviceIds = try decoderContainer.decode([String?]?.self, forKey: .deviceIds)
        }
        if decoderContainer.contains(.modelName)
        {
            self.modelName = try decoderContainer.decode(String?.self, forKey: .modelName)
        }
        if decoderContainer.contains(.deviceType)
        {
            self.deviceType = try decoderContainer.decode(Int?.self, forKey: .deviceType)
        }
        if decoderContainer.contains(.parentDeviceName)
        {
            self.parentDeviceName = try decoderContainer.decode(String?.self, forKey: .parentDeviceName)
        }
    }
}
public extension DeviceEnrollVO{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: DeviceEnrollVOCodingKeys.self)
         try encoderContainer.encode(deviceIds, forKey: .deviceIds)
         try encoderContainer.encode(modelName, forKey: .modelName)
         try encoderContainer.encode(deviceType, forKey: .deviceType)
         try encoderContainer.encode(parentDeviceName, forKey: .parentDeviceName)
    }
}
///  hubInstanceBo
public class HubInstanceBo:NSObject,Codable{
    /// InstanceUuid
    var instanceUuid:String?
    /// InstanceId
    var instanceId:String?
    /// InstanceName
    var instanceName:String?
    /// Region
    var region:String?



    public override init(){
            super.init()
    }

    enum HubInstanceBoCodingKeys: String, CodingKey {
        case instanceUuid
        case instanceId
        case instanceName
        case region
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: HubInstanceBoCodingKeys.self)
        if decoderContainer.contains(.instanceUuid)
        {
            self.instanceUuid = try decoderContainer.decode(String?.self, forKey: .instanceUuid)
        }
        if decoderContainer.contains(.instanceId)
        {
            self.instanceId = try decoderContainer.decode(String?.self, forKey: .instanceId)
        }
        if decoderContainer.contains(.instanceName)
        {
            self.instanceName = try decoderContainer.decode(String?.self, forKey: .instanceName)
        }
        if decoderContainer.contains(.region)
        {
            self.region = try decoderContainer.decode(String?.self, forKey: .region)
        }
    }
}
public extension HubInstanceBo{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: HubInstanceBoCodingKeys.self)
         try encoderContainer.encode(instanceUuid, forKey: .instanceUuid)
         try encoderContainer.encode(instanceId, forKey: .instanceId)
         try encoderContainer.encode(instanceName, forKey: .instanceName)
         try encoderContainer.encode(region, forKey: .region)
    }
}
///  modulePageVo
public class ModulePageVo:NSObject,Codable{
    /// Module唯一标识
    var uuid:String?
    /// Module编号
    var moduleId:String?
    /// Module显示名称
    var moduleName:String?
    /// 设备编号
    var deviceId:String?
    /// 设备显示名称
    var deviceName:String?
    /// 设备类型[0-普通设备,1-云网关设备,2-Edge设备]
    var deviceType:Int?
    /// 模块部署状态[0-部署完成,1-待部署]
    var moduleStatus:Int?
    /// 模块类型版本
    var moduleTypeVersion:String?



    public override init(){
            super.init()
    }

    enum ModulePageVoCodingKeys: String, CodingKey {
        case uuid
        case moduleId
        case moduleName
        case deviceId
        case deviceName
        case deviceType
        case moduleStatus
        case moduleTypeVersion
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: ModulePageVoCodingKeys.self)
        if decoderContainer.contains(.uuid)
        {
            self.uuid = try decoderContainer.decode(String?.self, forKey: .uuid)
        }
        if decoderContainer.contains(.moduleId)
        {
            self.moduleId = try decoderContainer.decode(String?.self, forKey: .moduleId)
        }
        if decoderContainer.contains(.moduleName)
        {
            self.moduleName = try decoderContainer.decode(String?.self, forKey: .moduleName)
        }
        if decoderContainer.contains(.deviceId)
        {
            self.deviceId = try decoderContainer.decode(String?.self, forKey: .deviceId)
        }
        if decoderContainer.contains(.deviceName)
        {
            self.deviceName = try decoderContainer.decode(String?.self, forKey: .deviceName)
        }
        if decoderContainer.contains(.deviceType)
        {
            self.deviceType = try decoderContainer.decode(Int?.self, forKey: .deviceType)
        }
        if decoderContainer.contains(.moduleStatus)
        {
            self.moduleStatus = try decoderContainer.decode(Int?.self, forKey: .moduleStatus)
        }
        if decoderContainer.contains(.moduleTypeVersion)
        {
            self.moduleTypeVersion = try decoderContainer.decode(String?.self, forKey: .moduleTypeVersion)
        }
    }
}
public extension ModulePageVo{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: ModulePageVoCodingKeys.self)
         try encoderContainer.encode(uuid, forKey: .uuid)
         try encoderContainer.encode(moduleId, forKey: .moduleId)
         try encoderContainer.encode(moduleName, forKey: .moduleName)
         try encoderContainer.encode(deviceId, forKey: .deviceId)
         try encoderContainer.encode(deviceName, forKey: .deviceName)
         try encoderContainer.encode(deviceType, forKey: .deviceType)
         try encoderContainer.encode(moduleStatus, forKey: .moduleStatus)
         try encoderContainer.encode(moduleTypeVersion, forKey: .moduleTypeVersion)
    }
}
///  childDevices
public class ChildDevices:NSObject,Codable{
    /// 设备编号
    var deviceId:String?
    /// 设备名称
    var deviceName:String?
    /// devvice-service名称
    var deviceServiceName:String?
    /// 在线状态
    var online:String?



    public override init(){
            super.init()
    }

    enum ChildDevicesCodingKeys: String, CodingKey {
        case deviceId
        case deviceName
        case deviceServiceName
        case online
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: ChildDevicesCodingKeys.self)
        if decoderContainer.contains(.deviceId)
        {
            self.deviceId = try decoderContainer.decode(String?.self, forKey: .deviceId)
        }
        if decoderContainer.contains(.deviceName)
        {
            self.deviceName = try decoderContainer.decode(String?.self, forKey: .deviceName)
        }
        if decoderContainer.contains(.deviceServiceName)
        {
            self.deviceServiceName = try decoderContainer.decode(String?.self, forKey: .deviceServiceName)
        }
        if decoderContainer.contains(.online)
        {
            self.online = try decoderContainer.decode(String?.self, forKey: .online)
        }
    }
}
public extension ChildDevices{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: ChildDevicesCodingKeys.self)
         try encoderContainer.encode(deviceId, forKey: .deviceId)
         try encoderContainer.encode(deviceName, forKey: .deviceName)
         try encoderContainer.encode(deviceServiceName, forKey: .deviceServiceName)
         try encoderContainer.encode(online, forKey: .online)
    }
}
///  childModules
public class ChildModules:NSObject,Codable{
    /// 模块编号
    var moduleId:String?
    /// 模块名称
    var moduleName:String?
    /// 模块类型版本
    var moduleTypeVersion:String?
    /// 物模型名称
    var omName:String?
    /// 物模型描述
    var omDesc:String?
    /// 模块状态
    var moduleState:String?



    public override init(){
            super.init()
    }

    enum ChildModulesCodingKeys: String, CodingKey {
        case moduleId
        case moduleName
        case moduleTypeVersion
        case omName
        case omDesc
        case moduleState
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: ChildModulesCodingKeys.self)
        if decoderContainer.contains(.moduleId)
        {
            self.moduleId = try decoderContainer.decode(String?.self, forKey: .moduleId)
        }
        if decoderContainer.contains(.moduleName)
        {
            self.moduleName = try decoderContainer.decode(String?.self, forKey: .moduleName)
        }
        if decoderContainer.contains(.moduleTypeVersion)
        {
            self.moduleTypeVersion = try decoderContainer.decode(String?.self, forKey: .moduleTypeVersion)
        }
        if decoderContainer.contains(.omName)
        {
            self.omName = try decoderContainer.decode(String?.self, forKey: .omName)
        }
        if decoderContainer.contains(.omDesc)
        {
            self.omDesc = try decoderContainer.decode(String?.self, forKey: .omDesc)
        }
        if decoderContainer.contains(.moduleState)
        {
            self.moduleState = try decoderContainer.decode(String?.self, forKey: .moduleState)
        }
    }
}
public extension ChildModules{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: ChildModulesCodingKeys.self)
         try encoderContainer.encode(moduleId, forKey: .moduleId)
         try encoderContainer.encode(moduleName, forKey: .moduleName)
         try encoderContainer.encode(moduleTypeVersion, forKey: .moduleTypeVersion)
         try encoderContainer.encode(omName, forKey: .omName)
         try encoderContainer.encode(omDesc, forKey: .omDesc)
         try encoderContainer.encode(moduleState, forKey: .moduleState)
    }
}
///  edgeInfoVO
public class EdgeInfoVO:NSObject,Codable{
    /// 系统流水号
    var uuid:String?
    /// Edge的唯一编号
    var edgeId:String?
    /// Edge的名称
    var edgeName:String?
    /// 是否在线【0-离线，1-在线】
    var edgeStatus:Int?
    /// 边缘计算说明
    var edgeDesc:String?
    /// Edge版本
    var edgeVersion:String?
    /// Edge创建时间
    var createTime:String?
    /// 最后在线时间
    var lastOnlineTime:String?
    /// 最后开机时间
    var lastTurnOnTime:String?
    /// IoT Hub实例编号
    var iothubInstanceId:String?
    /// IoT Hub实例名称
    var iothubInstanceName:String?



    public override init(){
            super.init()
    }

    enum EdgeInfoVOCodingKeys: String, CodingKey {
        case uuid
        case edgeId
        case edgeName
        case edgeStatus
        case edgeDesc
        case edgeVersion
        case createTime
        case lastOnlineTime
        case lastTurnOnTime
        case iothubInstanceId
        case iothubInstanceName
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: EdgeInfoVOCodingKeys.self)
        if decoderContainer.contains(.uuid)
        {
            self.uuid = try decoderContainer.decode(String?.self, forKey: .uuid)
        }
        if decoderContainer.contains(.edgeId)
        {
            self.edgeId = try decoderContainer.decode(String?.self, forKey: .edgeId)
        }
        if decoderContainer.contains(.edgeName)
        {
            self.edgeName = try decoderContainer.decode(String?.self, forKey: .edgeName)
        }
        if decoderContainer.contains(.edgeStatus)
        {
            self.edgeStatus = try decoderContainer.decode(Int?.self, forKey: .edgeStatus)
        }
        if decoderContainer.contains(.edgeDesc)
        {
            self.edgeDesc = try decoderContainer.decode(String?.self, forKey: .edgeDesc)
        }
        if decoderContainer.contains(.edgeVersion)
        {
            self.edgeVersion = try decoderContainer.decode(String?.self, forKey: .edgeVersion)
        }
        if decoderContainer.contains(.createTime)
        {
            self.createTime = try decoderContainer.decode(String?.self, forKey: .createTime)
        }
        if decoderContainer.contains(.lastOnlineTime)
        {
            self.lastOnlineTime = try decoderContainer.decode(String?.self, forKey: .lastOnlineTime)
        }
        if decoderContainer.contains(.lastTurnOnTime)
        {
            self.lastTurnOnTime = try decoderContainer.decode(String?.self, forKey: .lastTurnOnTime)
        }
        if decoderContainer.contains(.iothubInstanceId)
        {
            self.iothubInstanceId = try decoderContainer.decode(String?.self, forKey: .iothubInstanceId)
        }
        if decoderContainer.contains(.iothubInstanceName)
        {
            self.iothubInstanceName = try decoderContainer.decode(String?.self, forKey: .iothubInstanceName)
        }
    }
}
public extension EdgeInfoVO{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: EdgeInfoVOCodingKeys.self)
         try encoderContainer.encode(uuid, forKey: .uuid)
         try encoderContainer.encode(edgeId, forKey: .edgeId)
         try encoderContainer.encode(edgeName, forKey: .edgeName)
         try encoderContainer.encode(edgeStatus, forKey: .edgeStatus)
         try encoderContainer.encode(edgeDesc, forKey: .edgeDesc)
         try encoderContainer.encode(edgeVersion, forKey: .edgeVersion)
         try encoderContainer.encode(createTime, forKey: .createTime)
         try encoderContainer.encode(lastOnlineTime, forKey: .lastOnlineTime)
         try encoderContainer.encode(lastTurnOnTime, forKey: .lastTurnOnTime)
         try encoderContainer.encode(iothubInstanceId, forKey: .iothubInstanceId)
         try encoderContainer.encode(iothubInstanceName, forKey: .iothubInstanceName)
    }
}
///  edgePageVo
public class EdgePageVo:NSObject,Codable{
    /// Edge编号
    var edgeId:String?
    /// Edge显示名称
    var edgeName:String?
    /// Edge状态
    var edgeState:String?
    /// 物模型名称
    var omName:String?
    /// 最后在线时间
    var lastOnlineTime:String?



    public override init(){
            super.init()
    }

    enum EdgePageVoCodingKeys: String, CodingKey {
        case edgeId
        case edgeName
        case edgeState
        case omName
        case lastOnlineTime
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: EdgePageVoCodingKeys.self)
        if decoderContainer.contains(.edgeId)
        {
            self.edgeId = try decoderContainer.decode(String?.self, forKey: .edgeId)
        }
        if decoderContainer.contains(.edgeName)
        {
            self.edgeName = try decoderContainer.decode(String?.self, forKey: .edgeName)
        }
        if decoderContainer.contains(.edgeState)
        {
            self.edgeState = try decoderContainer.decode(String?.self, forKey: .edgeState)
        }
        if decoderContainer.contains(.omName)
        {
            self.omName = try decoderContainer.decode(String?.self, forKey: .omName)
        }
        if decoderContainer.contains(.lastOnlineTime)
        {
            self.lastOnlineTime = try decoderContainer.decode(String?.self, forKey: .lastOnlineTime)
        }
    }
}
public extension EdgePageVo{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: EdgePageVoCodingKeys.self)
         try encoderContainer.encode(edgeId, forKey: .edgeId)
         try encoderContainer.encode(edgeName, forKey: .edgeName)
         try encoderContainer.encode(edgeState, forKey: .edgeState)
         try encoderContainer.encode(omName, forKey: .omName)
         try encoderContainer.encode(lastOnlineTime, forKey: .lastOnlineTime)
    }
}

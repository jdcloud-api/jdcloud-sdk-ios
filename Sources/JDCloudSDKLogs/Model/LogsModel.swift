/* Copyright 2018 JDCLOUD.COM

   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at

     http:#www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.

   Logtopic APIs
   日志服务日志主题相关的管理控制接口

   OpenAPI spec version: v1
   Contact: 

   NOTE: This class is auto generated by the jdcloud code generator program.
 */


import Foundation
///  customLogSearchSpec
public class CustomLogSearchSpec:NSObject,Codable{
    /// AppName
    /// Required:true
    var appName:[String?]?
    /// From
    var from:Int64?
    /// LogTopicId
    var logTopicId:String?
    /// Match
    var match:[Match?]?
    /// RecordId
    var recordId:String?
    /// Resp
    var resp:[String?]?
    /// Size
    var size:Int64?
    /// Sort
    var sort:String?
    /// TimeRange
    /// Required:true
    var timeRange:DateTimeRange
    /// Uuid
    var uuid:String?



    public  init(appName:[String?]?,timeRange:DateTimeRange){
             self.appName = appName
             self.timeRange = timeRange
    }

    enum CustomLogSearchSpecCodingKeys: String, CodingKey {
        case appName
        case from
        case logTopicId
        case match
        case recordId
        case resp
        case size
        case sort
        case timeRange
        case uuid
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: CustomLogSearchSpecCodingKeys.self)
        self.appName = try decoderContainer.decode([String?]?.self, forKey: .appName)
        if decoderContainer.contains(.from)
        {
            self.from = try decoderContainer.decode(Int64?.self, forKey: .from)
        }
        if decoderContainer.contains(.logTopicId)
        {
            self.logTopicId = try decoderContainer.decode(String?.self, forKey: .logTopicId)
        }
        if decoderContainer.contains(.match)
        {
            self.match = try decoderContainer.decode([Match?]?.self, forKey: .match)
        }
        if decoderContainer.contains(.recordId)
        {
            self.recordId = try decoderContainer.decode(String?.self, forKey: .recordId)
        }
        if decoderContainer.contains(.resp)
        {
            self.resp = try decoderContainer.decode([String?]?.self, forKey: .resp)
        }
        if decoderContainer.contains(.size)
        {
            self.size = try decoderContainer.decode(Int64?.self, forKey: .size)
        }
        if decoderContainer.contains(.sort)
        {
            self.sort = try decoderContainer.decode(String?.self, forKey: .sort)
        }
        self.timeRange = try decoderContainer.decode(DateTimeRange.self, forKey: .timeRange)
        if decoderContainer.contains(.uuid)
        {
            self.uuid = try decoderContainer.decode(String?.self, forKey: .uuid)
        }
    }
}
public extension CustomLogSearchSpec{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: CustomLogSearchSpecCodingKeys.self)
         try encoderContainer.encode(appName, forKey: .appName)
         try encoderContainer.encode(from, forKey: .from)
         try encoderContainer.encode(logTopicId, forKey: .logTopicId)
         try encoderContainer.encode(match, forKey: .match)
         try encoderContainer.encode(recordId, forKey: .recordId)
         try encoderContainer.encode(resp, forKey: .resp)
         try encoderContainer.encode(size, forKey: .size)
         try encoderContainer.encode(sort, forKey: .sort)
         try encoderContainer.encode(timeRange, forKey: .timeRange)
         try encoderContainer.encode(uuid, forKey: .uuid)
    }
}
///  timestampRange
public class TimestampRange:NSObject,Codable{
    /// 结束时间，单位毫秒
    var end:Int64?
    /// 开始时间，单位毫秒
    var start:Int64?



    public override init(){
            super.init()
    }

    enum TimestampRangeCodingKeys: String, CodingKey {
        case end
        case start
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: TimestampRangeCodingKeys.self)
        if decoderContainer.contains(.end)
        {
            self.end = try decoderContainer.decode(Int64?.self, forKey: .end)
        }
        if decoderContainer.contains(.start)
        {
            self.start = try decoderContainer.decode(Int64?.self, forKey: .start)
        }
    }
}
public extension TimestampRange{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: TimestampRangeCodingKeys.self)
         try encoderContainer.encode(end, forKey: .end)
         try encoderContainer.encode(start, forKey: .start)
    }
}
///  systemLogHistorySpec
public class SystemLogHistorySpec:NSObject,Codable{
    /// AppName
    /// Required:true
    var appName:String
    /// 精确匹配，true 或者 false
    var exactMatch:Bool?
    /// Instance
    /// Required:true
    var instance:String
    /// 查询关键字
    var keyword:String?
    /// LogType
    /// Required:true
    var logType:String
    /// 排序，取值&quot;ASC&quot;或&quot;DESC&quot;，默认&quot;ASC&quot;
    var order:String?
    /// 页数，从1开始
    var page:Int64?
    /// 每页日志条数
    var size:Int64?
    /// Time
    /// Required:true
    var time:TimestampRange



    public  init(appName:String,instance:String,logType:String,time:TimestampRange){
             self.appName = appName
             self.instance = instance
             self.logType = logType
             self.time = time
    }

    enum SystemLogHistorySpecCodingKeys: String, CodingKey {
        case appName
        case exactMatch
        case instance
        case keyword
        case logType
        case order
        case page
        case size
        case time
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: SystemLogHistorySpecCodingKeys.self)
        self.appName = try decoderContainer.decode(String.self, forKey: .appName)
        if decoderContainer.contains(.exactMatch)
        {
            self.exactMatch = try decoderContainer.decode(Bool?.self, forKey: .exactMatch)
        }
        self.instance = try decoderContainer.decode(String.self, forKey: .instance)
        if decoderContainer.contains(.keyword)
        {
            self.keyword = try decoderContainer.decode(String?.self, forKey: .keyword)
        }
        self.logType = try decoderContainer.decode(String.self, forKey: .logType)
        if decoderContainer.contains(.order)
        {
            self.order = try decoderContainer.decode(String?.self, forKey: .order)
        }
        if decoderContainer.contains(.page)
        {
            self.page = try decoderContainer.decode(Int64?.self, forKey: .page)
        }
        if decoderContainer.contains(.size)
        {
            self.size = try decoderContainer.decode(Int64?.self, forKey: .size)
        }
        self.time = try decoderContainer.decode(TimestampRange.self, forKey: .time)
    }
}
public extension SystemLogHistorySpec{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: SystemLogHistorySpecCodingKeys.self)
         try encoderContainer.encode(appName, forKey: .appName)
         try encoderContainer.encode(exactMatch, forKey: .exactMatch)
         try encoderContainer.encode(instance, forKey: .instance)
         try encoderContainer.encode(keyword, forKey: .keyword)
         try encoderContainer.encode(logType, forKey: .logType)
         try encoderContainer.encode(order, forKey: .order)
         try encoderContainer.encode(page, forKey: .page)
         try encoderContainer.encode(size, forKey: .size)
         try encoderContainer.encode(time, forKey: .time)
    }
}
///  dateTimeRange
public class DateTimeRange:NSObject,Codable{
    /// End
    var end:String?
    /// Start
    var start:String?



    public override init(){
            super.init()
    }

    enum DateTimeRangeCodingKeys: String, CodingKey {
        case end
        case start
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: DateTimeRangeCodingKeys.self)
        if decoderContainer.contains(.end)
        {
            self.end = try decoderContainer.decode(String?.self, forKey: .end)
        }
        if decoderContainer.contains(.start)
        {
            self.start = try decoderContainer.decode(String?.self, forKey: .start)
        }
    }
}
public extension DateTimeRange{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: DateTimeRangeCodingKeys.self)
         try encoderContainer.encode(end, forKey: .end)
         try encoderContainer.encode(start, forKey: .start)
    }
}
///  systemLogContextSpec
public class SystemLogContextSpec:NSObject,Codable{
    /// Anchor
    var anchor:[AnyObject?]?
    /// AppName
    /// Required:true
    var appName:String
    /// Direction
    var direction:String?
    /// Id
    var id:String?
    /// LineSize
    var lineSize:Int64?
    /// LogType
    /// Required:true
    var logType:String
    /// Time
    var time:Int64?



    public  init(appName:String,logType:String){
             self.appName = appName
             self.logType = logType
    }

    enum SystemLogContextSpecCodingKeys: String, CodingKey {
        case anchor
        case appName
        case direction
        case id
        case lineSize
        case logType
        case time
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: SystemLogContextSpecCodingKeys.self)
        self.appName = try decoderContainer.decode(String.self, forKey: .appName)
        if decoderContainer.contains(.direction)
        {
            self.direction = try decoderContainer.decode(String?.self, forKey: .direction)
        }
        if decoderContainer.contains(.id)
        {
            self.id = try decoderContainer.decode(String?.self, forKey: .id)
        }
        if decoderContainer.contains(.lineSize)
        {
            self.lineSize = try decoderContainer.decode(Int64?.self, forKey: .lineSize)
        }
        self.logType = try decoderContainer.decode(String.self, forKey: .logType)
        if decoderContainer.contains(.time)
        {
            self.time = try decoderContainer.decode(Int64?.self, forKey: .time)
        }
    }
}
public extension SystemLogContextSpec{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: SystemLogContextSpecCodingKeys.self)
         try encoderContainer.encode(appName, forKey: .appName)
         try encoderContainer.encode(direction, forKey: .direction)
         try encoderContainer.encode(id, forKey: .id)
         try encoderContainer.encode(lineSize, forKey: .lineSize)
         try encoderContainer.encode(logType, forKey: .logType)
         try encoderContainer.encode(time, forKey: .time)
    }
}
///  match
public class Match:NSObject,Codable{
    /// Eq
    var eq:[String:[AnyObject?]?]?
    /// Not
    var not:[String:[AnyObject?]?]?
    /// Range
    var range:[String:Range?]?
    /// Regexp
    var regexp:[String:[String?]?]?
    /// Simple_query_string
    var simple_query_string:[String:String?]?
    /// SimpleQuery
    var simpleQuery:[String:SimpleQuery?]?
    /// Substring
    var substring:[String:[String?]?]?



    public override init(){
            super.init()
    }

    enum MatchCodingKeys: String, CodingKey {
        case eq
        case not
        case range
        case regexp
        case simple_query_string
        case simpleQuery
        case substring
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: MatchCodingKeys.self)
        if decoderContainer.contains(.range)
        {
            self.range = try decoderContainer.decode([String:Range?]?.self, forKey: .range)
        }
        if decoderContainer.contains(.regexp)
        {
            self.regexp = try decoderContainer.decode([String:[String?]?]?.self, forKey: .regexp)
        }
        if decoderContainer.contains(.simple_query_string)
        {
            self.simple_query_string = try decoderContainer.decode([String:String?]?.self, forKey: .simple_query_string)
        }
        if decoderContainer.contains(.simpleQuery)
        {
            self.simpleQuery = try decoderContainer.decode([String:SimpleQuery?]?.self, forKey: .simpleQuery)
        }
        if decoderContainer.contains(.substring)
        {
            self.substring = try decoderContainer.decode([String:[String?]?]?.self, forKey: .substring)
        }
    }
}
public extension Match{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: MatchCodingKeys.self)
         try encoderContainer.encode(range, forKey: .range)
         try encoderContainer.encode(regexp, forKey: .regexp)
         try encoderContainer.encode(simple_query_string, forKey: .simple_query_string)
         try encoderContainer.encode(simpleQuery, forKey: .simpleQuery)
         try encoderContainer.encode(substring, forKey: .substring)
    }
}
///  simpleQueryItem
public class SimpleQueryItem:NSObject,Codable{
    /// Exclude
    var exclude:Bool?
    /// Keyword
    var keyword:String?



    public override init(){
            super.init()
    }

    enum SimpleQueryItemCodingKeys: String, CodingKey {
        case exclude
        case keyword
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: SimpleQueryItemCodingKeys.self)
        if decoderContainer.contains(.exclude)
        {
            self.exclude = try decoderContainer.decode(Bool?.self, forKey: .exclude)
        }
        if decoderContainer.contains(.keyword)
        {
            self.keyword = try decoderContainer.decode(String?.self, forKey: .keyword)
        }
    }
}
public extension SimpleQueryItem{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: SimpleQueryItemCodingKeys.self)
         try encoderContainer.encode(exclude, forKey: .exclude)
         try encoderContainer.encode(keyword, forKey: .keyword)
    }
}
///  range
public class Range:NSObject,Codable{
    /// Gt
    var gt:AnyObject?
    /// Gte
    var gte:AnyObject?
    /// Lt
    var lt:AnyObject?
    /// Lte
    var lte:AnyObject?



    public override init(){
            super.init()
    }

    enum RangeCodingKeys: String, CodingKey {
        case gt
        case gte
        case lt
        case lte
    }


    required public init(from decoder: Decoder) throws {
    }
}
public extension Range{
    func encode(to encoder: Encoder) throws {
    }
}
///  simpleQuery
public class SimpleQuery:NSObject,Codable{
    /// Items
    var items:[SimpleQueryItem?]?
    /// Opt
    var opt:String?



    public override init(){
            super.init()
    }

    enum SimpleQueryCodingKeys: String, CodingKey {
        case items
        case opt
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: SimpleQueryCodingKeys.self)
        if decoderContainer.contains(.items)
        {
            self.items = try decoderContainer.decode([SimpleQueryItem?]?.self, forKey: .items)
        }
        if decoderContainer.contains(.opt)
        {
            self.opt = try decoderContainer.decode(String?.self, forKey: .opt)
        }
    }
}
public extension SimpleQuery{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: SimpleQueryCodingKeys.self)
         try encoderContainer.encode(items, forKey: .items)
         try encoderContainer.encode(opt, forKey: .opt)
    }
}
///  searchLogContextSpec
public class SearchLogContextSpec:NSObject,Codable{
    /// 查询anchor,基于该值偏移进行上下文检索
    /// Required:true
    var anchor:[AnyObject?]?
    /// 搜索方向,默认both,可取值:up,down,both
    var direction:String?
    /// 日志记录ID
    /// Required:true
    var id:String
    /// 查看上下文行数大小，最大支持200
    /// Required:true
    var lineSize:Int64
    /// 查询日志时返回的时间戳
    /// Required:true
    var time:Int64



    public  init(anchor:[AnyObject?]?,id:String,lineSize:Int64,time:Int64){
             self.anchor = anchor
             self.id = id
             self.lineSize = lineSize
             self.time = time
    }

    enum SearchLogContextSpecCodingKeys: String, CodingKey {
        case anchor
        case direction
        case id
        case lineSize
        case time
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: SearchLogContextSpecCodingKeys.self)
        if decoderContainer.contains(.direction)
        {
            self.direction = try decoderContainer.decode(String?.self, forKey: .direction)
        }
        self.id = try decoderContainer.decode(String.self, forKey: .id)
        self.lineSize = try decoderContainer.decode(Int64.self, forKey: .lineSize)
        self.time = try decoderContainer.decode(Int64.self, forKey: .time)
    }
}
public extension SearchLogContextSpec{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: SearchLogContextSpecCodingKeys.self)
         try encoderContainer.encode(direction, forKey: .direction)
         try encoderContainer.encode(id, forKey: .id)
         try encoderContainer.encode(lineSize, forKey: .lineSize)
         try encoderContainer.encode(time, forKey: .time)
    }
}
///  field
public class Field:NSObject,Codable{
    /// key
    /// Required:true
    var key:String
    /// 字段类型
    /// Required:true
    var type:String



    public  init(key:String,type:String){
             self.key = key
             self.type = type
    }

    enum FieldCodingKeys: String, CodingKey {
        case key
        case type
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: FieldCodingKeys.self)
        self.key = try decoderContainer.decode(String.self, forKey: .key)
        self.type = try decoderContainer.decode(String.self, forKey: .type)
    }
}
public extension Field{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: FieldCodingKeys.self)
         try encoderContainer.encode(key, forKey: .key)
         try encoderContainer.encode(type, forKey: .type)
    }
}
///  templateEnd
public class TemplateEnd:NSObject,Codable{
    /// UID
    var uID:String?
    /// 模板名称
    var name:String?



    public override init(){
            super.init()
    }

    enum TemplateEndCodingKeys: String, CodingKey {
        case uID
        case name
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: TemplateEndCodingKeys.self)
        if decoderContainer.contains(.uID)
        {
            self.uID = try decoderContainer.decode(String?.self, forKey: .uID)
        }
        if decoderContainer.contains(.name)
        {
            self.name = try decoderContainer.decode(String?.self, forKey: .name)
        }
    }
}
public extension TemplateEnd{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: TemplateEndCodingKeys.self)
         try encoderContainer.encode(uID, forKey: .uID)
         try encoderContainer.encode(name, forKey: .name)
    }
}
///  entry
public class Entry:NSObject,Codable{
    /// 日志原文
    /// Required:true
    var content:String
    /// 日志流标识符,不传则使用全局日志流标识符
    var stream:String?
    /// 标签，不传则取全局标签 map[string]string
    var tags:AnyObject?
    /// 时间戳，UTC格式，最多支持到纳秒级别，不传入则取全局时间戳。如 2019-04-08T03:08:04.437670934Z、2019-04-08T03:08:04Z、2019-04-08T03:08:04.123Z
    var timestamp:String?



    public  init(content:String){
             self.content = content
    }

    enum EntryCodingKeys: String, CodingKey {
        case content
        case stream
        case tags
        case timestamp
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: EntryCodingKeys.self)
        self.content = try decoderContainer.decode(String.self, forKey: .content)
        if decoderContainer.contains(.stream)
        {
            self.stream = try decoderContainer.decode(String?.self, forKey: .stream)
        }
        if decoderContainer.contains(.timestamp)
        {
            self.timestamp = try decoderContainer.decode(String?.self, forKey: .timestamp)
        }
    }
}
public extension Entry{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: EntryCodingKeys.self)
         try encoderContainer.encode(content, forKey: .content)
         try encoderContainer.encode(stream, forKey: .stream)
         try encoderContainer.encode(timestamp, forKey: .timestamp)
    }
}
///  shipperTaskEnd
public class ShipperTaskEnd:NSObject,Codable{
    /// UID
    var uID:String?
    /// 是否允许重试， true，false
    var allowRetry:Bool?
    /// 创建时间
    var createTime:String?
    /// 结束时间
    var endTime:Int64?
    /// 日志集uuid
    var logsetUID:String?
    /// 日志主题uuid
    var logtopicUID:String?
    /// 地域信息
    var region:String?
    /// 日志批次任务截止时间
    var shipperEndTime:Int64?
    /// 日志批次任务起始时间
    var shipperStartTime:Int64?
    /// shipperUID
    var shipperUID:String?
    /// 开始时间
    var startTime:Int64?
    /// 该批次转储任务状态： 1 发送中 2 成功，3 失败
    var status:Int64?
    /// 更新时间
    var updateTime:String?



    public override init(){
            super.init()
    }

    enum ShipperTaskEndCodingKeys: String, CodingKey {
        case uID
        case allowRetry
        case createTime
        case endTime
        case logsetUID
        case logtopicUID
        case region
        case shipperEndTime
        case shipperStartTime
        case shipperUID
        case startTime
        case status
        case updateTime
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: ShipperTaskEndCodingKeys.self)
        if decoderContainer.contains(.uID)
        {
            self.uID = try decoderContainer.decode(String?.self, forKey: .uID)
        }
        if decoderContainer.contains(.allowRetry)
        {
            self.allowRetry = try decoderContainer.decode(Bool?.self, forKey: .allowRetry)
        }
        if decoderContainer.contains(.createTime)
        {
            self.createTime = try decoderContainer.decode(String?.self, forKey: .createTime)
        }
        if decoderContainer.contains(.endTime)
        {
            self.endTime = try decoderContainer.decode(Int64?.self, forKey: .endTime)
        }
        if decoderContainer.contains(.logsetUID)
        {
            self.logsetUID = try decoderContainer.decode(String?.self, forKey: .logsetUID)
        }
        if decoderContainer.contains(.logtopicUID)
        {
            self.logtopicUID = try decoderContainer.decode(String?.self, forKey: .logtopicUID)
        }
        if decoderContainer.contains(.region)
        {
            self.region = try decoderContainer.decode(String?.self, forKey: .region)
        }
        if decoderContainer.contains(.shipperEndTime)
        {
            self.shipperEndTime = try decoderContainer.decode(Int64?.self, forKey: .shipperEndTime)
        }
        if decoderContainer.contains(.shipperStartTime)
        {
            self.shipperStartTime = try decoderContainer.decode(Int64?.self, forKey: .shipperStartTime)
        }
        if decoderContainer.contains(.shipperUID)
        {
            self.shipperUID = try decoderContainer.decode(String?.self, forKey: .shipperUID)
        }
        if decoderContainer.contains(.startTime)
        {
            self.startTime = try decoderContainer.decode(Int64?.self, forKey: .startTime)
        }
        if decoderContainer.contains(.status)
        {
            self.status = try decoderContainer.decode(Int64?.self, forKey: .status)
        }
        if decoderContainer.contains(.updateTime)
        {
            self.updateTime = try decoderContainer.decode(String?.self, forKey: .updateTime)
        }
    }
}
public extension ShipperTaskEnd{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: ShipperTaskEndCodingKeys.self)
         try encoderContainer.encode(uID, forKey: .uID)
         try encoderContainer.encode(allowRetry, forKey: .allowRetry)
         try encoderContainer.encode(createTime, forKey: .createTime)
         try encoderContainer.encode(endTime, forKey: .endTime)
         try encoderContainer.encode(logsetUID, forKey: .logsetUID)
         try encoderContainer.encode(logtopicUID, forKey: .logtopicUID)
         try encoderContainer.encode(region, forKey: .region)
         try encoderContainer.encode(shipperEndTime, forKey: .shipperEndTime)
         try encoderContainer.encode(shipperStartTime, forKey: .shipperStartTime)
         try encoderContainer.encode(shipperUID, forKey: .shipperUID)
         try encoderContainer.encode(startTime, forKey: .startTime)
         try encoderContainer.encode(status, forKey: .status)
         try encoderContainer.encode(updateTime, forKey: .updateTime)
    }
}
///  stopShippersSpec
public class StopShippersSpec:NSObject,Codable{
    /// 转储任务uuid列表
    /// Required:true
    var shipperList:[String?]?



    public  init(shipperList:[String?]?){
             self.shipperList = shipperList
    }

    enum StopShippersSpecCodingKeys: String, CodingKey {
        case shipperList
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: StopShippersSpecCodingKeys.self)
        self.shipperList = try decoderContainer.decode([String?]?.self, forKey: .shipperList)
    }
}
public extension StopShippersSpec{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: StopShippersSpecCodingKeys.self)
         try encoderContainer.encode(shipperList, forKey: .shipperList)
    }
}
///  shipperEnd
public class ShipperEnd:NSObject,Codable{
    /// UID
    var uID:String?
    /// 日志类型
    var appName:String?
    /// 压缩格式，为空不压缩
    var compress:String?
    /// 创建时间
    var createTime:String?
    /// 投递格式 json,  origin(原始日志格式), 默认origin
    var fileFormat:String?
    /// 投递文件大小，单位MB，支持200,300,400,500,1000
    /// Required:true
    var fileSize:Int64
    /// 日志集uuid
    var logsetUID:String?
    /// 日志主题uuid
    var logtopicUID:String?
    /// 转储任务名称
    /// Required:true
    var name:String
    /// pin
    var pin:String?
    /// 地域信息
    var region:String?
    /// 日志采集资源类型
    var resourceType:Int64?
    /// 日志采集列表
    var resourceUIDs:[String?]?
    /// serviceCode
    var serviceCode:String?
    /// 日志转储任务状态，开启，停止
    var status:Int64?
    /// 目的地 配置
    /// Required:true
    var targetConf:[String:AnyObject?]?
    /// 转储目的地类型 0: oss, 目前只支持oss
    var targetType:Int64?
    /// 投递时间间隔单位分钟，5分钟整数倍，支持5,10,15,20,30,60
    /// Required:true
    var timeInterval:Int64
    /// 更新时间
    var updateTime:String?



    public  init(fileSize:Int64,name:String,targetConf:[String:AnyObject?]?,timeInterval:Int64){
             self.fileSize = fileSize
             self.name = name
             self.targetConf = targetConf
             self.timeInterval = timeInterval
    }

    enum ShipperEndCodingKeys: String, CodingKey {
        case uID
        case appName
        case compress
        case createTime
        case fileFormat
        case fileSize
        case logsetUID
        case logtopicUID
        case name
        case pin
        case region
        case resourceType
        case resourceUIDs
        case serviceCode
        case status
        case targetConf
        case targetType
        case timeInterval
        case updateTime
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: ShipperEndCodingKeys.self)
        if decoderContainer.contains(.uID)
        {
            self.uID = try decoderContainer.decode(String?.self, forKey: .uID)
        }
        if decoderContainer.contains(.appName)
        {
            self.appName = try decoderContainer.decode(String?.self, forKey: .appName)
        }
        if decoderContainer.contains(.compress)
        {
            self.compress = try decoderContainer.decode(String?.self, forKey: .compress)
        }
        if decoderContainer.contains(.createTime)
        {
            self.createTime = try decoderContainer.decode(String?.self, forKey: .createTime)
        }
        if decoderContainer.contains(.fileFormat)
        {
            self.fileFormat = try decoderContainer.decode(String?.self, forKey: .fileFormat)
        }
        self.fileSize = try decoderContainer.decode(Int64.self, forKey: .fileSize)
        if decoderContainer.contains(.logsetUID)
        {
            self.logsetUID = try decoderContainer.decode(String?.self, forKey: .logsetUID)
        }
        if decoderContainer.contains(.logtopicUID)
        {
            self.logtopicUID = try decoderContainer.decode(String?.self, forKey: .logtopicUID)
        }
        self.name = try decoderContainer.decode(String.self, forKey: .name)
        if decoderContainer.contains(.pin)
        {
            self.pin = try decoderContainer.decode(String?.self, forKey: .pin)
        }
        if decoderContainer.contains(.region)
        {
            self.region = try decoderContainer.decode(String?.self, forKey: .region)
        }
        if decoderContainer.contains(.resourceType)
        {
            self.resourceType = try decoderContainer.decode(Int64?.self, forKey: .resourceType)
        }
        if decoderContainer.contains(.resourceUIDs)
        {
            self.resourceUIDs = try decoderContainer.decode([String?]?.self, forKey: .resourceUIDs)
        }
        if decoderContainer.contains(.serviceCode)
        {
            self.serviceCode = try decoderContainer.decode(String?.self, forKey: .serviceCode)
        }
        if decoderContainer.contains(.status)
        {
            self.status = try decoderContainer.decode(Int64?.self, forKey: .status)
        }
        if decoderContainer.contains(.targetType)
        {
            self.targetType = try decoderContainer.decode(Int64?.self, forKey: .targetType)
        }
        self.timeInterval = try decoderContainer.decode(Int64.self, forKey: .timeInterval)
        if decoderContainer.contains(.updateTime)
        {
            self.updateTime = try decoderContainer.decode(String?.self, forKey: .updateTime)
        }
    }
}
public extension ShipperEnd{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: ShipperEndCodingKeys.self)
         try encoderContainer.encode(uID, forKey: .uID)
         try encoderContainer.encode(appName, forKey: .appName)
         try encoderContainer.encode(compress, forKey: .compress)
         try encoderContainer.encode(createTime, forKey: .createTime)
         try encoderContainer.encode(fileFormat, forKey: .fileFormat)
         try encoderContainer.encode(fileSize, forKey: .fileSize)
         try encoderContainer.encode(logsetUID, forKey: .logsetUID)
         try encoderContainer.encode(logtopicUID, forKey: .logtopicUID)
         try encoderContainer.encode(name, forKey: .name)
         try encoderContainer.encode(pin, forKey: .pin)
         try encoderContainer.encode(region, forKey: .region)
         try encoderContainer.encode(resourceType, forKey: .resourceType)
         try encoderContainer.encode(resourceUIDs, forKey: .resourceUIDs)
         try encoderContainer.encode(serviceCode, forKey: .serviceCode)
         try encoderContainer.encode(status, forKey: .status)
         try encoderContainer.encode(targetType, forKey: .targetType)
         try encoderContainer.encode(timeInterval, forKey: .timeInterval)
         try encoderContainer.encode(updateTime, forKey: .updateTime)
    }
}
///  createShipperSpec
public class CreateShipperSpec:NSObject,Codable{
    /// 压缩格式，为空不压缩
    var compress:String?
    /// 投递格式 json,  origin(原始日志格式), 默认origin
    var fileFormat:String?
    /// 投递文件大小，单位MB，支持200,300,400,500,1000
    /// Required:true
    var fileSize:Int64
    /// 转储任务名称
    /// Required:true
    var name:String
    /// 目的地 配置
    /// Required:true
    var targetConf:[String:AnyObject?]?
    /// 转储目的地类型 0: oss, 目前只支持oss
    var targetType:Int64?
    /// 投递时间间隔单位分钟，5分钟整数倍，支持5,10,15,20,30,60
    /// Required:true
    var timeInterval:Int64



    public  init(fileSize:Int64,name:String,targetConf:[String:AnyObject?]?,timeInterval:Int64){
             self.fileSize = fileSize
             self.name = name
             self.targetConf = targetConf
             self.timeInterval = timeInterval
    }

    enum CreateShipperSpecCodingKeys: String, CodingKey {
        case compress
        case fileFormat
        case fileSize
        case name
        case targetConf
        case targetType
        case timeInterval
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: CreateShipperSpecCodingKeys.self)
        if decoderContainer.contains(.compress)
        {
            self.compress = try decoderContainer.decode(String?.self, forKey: .compress)
        }
        if decoderContainer.contains(.fileFormat)
        {
            self.fileFormat = try decoderContainer.decode(String?.self, forKey: .fileFormat)
        }
        self.fileSize = try decoderContainer.decode(Int64.self, forKey: .fileSize)
        self.name = try decoderContainer.decode(String.self, forKey: .name)
        if decoderContainer.contains(.targetType)
        {
            self.targetType = try decoderContainer.decode(Int64?.self, forKey: .targetType)
        }
        self.timeInterval = try decoderContainer.decode(Int64.self, forKey: .timeInterval)
    }
}
public extension CreateShipperSpec{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: CreateShipperSpecCodingKeys.self)
         try encoderContainer.encode(compress, forKey: .compress)
         try encoderContainer.encode(fileFormat, forKey: .fileFormat)
         try encoderContainer.encode(fileSize, forKey: .fileSize)
         try encoderContainer.encode(name, forKey: .name)
         try encoderContainer.encode(targetType, forKey: .targetType)
         try encoderContainer.encode(timeInterval, forKey: .timeInterval)
    }
}
///  startShippersSpec
public class StartShippersSpec:NSObject,Codable{
    /// 转储任务uuid列表
    /// Required:true
    var shipperList:[String?]?



    public  init(shipperList:[String?]?){
             self.shipperList = shipperList
    }

    enum StartShippersSpecCodingKeys: String, CodingKey {
        case shipperList
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: StartShippersSpecCodingKeys.self)
        self.shipperList = try decoderContainer.decode([String?]?.self, forKey: .shipperList)
    }
}
public extension StartShippersSpec{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: StartShippersSpecCodingKeys.self)
         try encoderContainer.encode(shipperList, forKey: .shipperList)
    }
}
///  pair
public class Pair:NSObject,Codable{
    /// key
    /// Required:true
    var key:String
    /// value
    /// Required:true
    var value:String



    public  init(key:String,value:String){
             self.key = key
             self.value = value
    }

    enum PairCodingKeys: String, CodingKey {
        case key
        case value
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: PairCodingKeys.self)
        self.key = try decoderContainer.decode(String.self, forKey: .key)
        self.value = try decoderContainer.decode(String.self, forKey: .value)
    }
}
public extension Pair{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: PairCodingKeys.self)
         try encoderContainer.encode(key, forKey: .key)
         try encoderContainer.encode(value, forKey: .value)
    }
}
///  erp
public class Erp:NSObject,Codable{
    /// ERP
    var erpValue:String?
    /// 产品线代码
    var serviceCode:[String?]?



    public override init(){
            super.init()
    }

    enum ErpCodingKeys: String, CodingKey {
        case erpValue = "erp"
        case serviceCode
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: ErpCodingKeys.self)
        if decoderContainer.contains(.erpValue)
        {
            self.erpValue = try decoderContainer.decode(String?.self, forKey: .erpValue)
        }
        if decoderContainer.contains(.serviceCode)
        {
            self.serviceCode = try decoderContainer.decode([String?]?.self, forKey: .serviceCode)
        }
    }
}
public extension Erp{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: ErpCodingKeys.self)
         try encoderContainer.encode(erpValue, forKey: .erpValue)
         try encoderContainer.encode(serviceCode, forKey: .serviceCode)
    }
}
///  sysTemplateEnd
public class SysTemplateEnd:NSObject,Codable{
    /// UID
    var uID:String?
    /// create user
    var createErp:String?
    /// create date
    var createTime:String?
    /// 是否启用
    var enabled:Bool?
    /// 模板名称
    var name:String?
    /// serviceCode
    var serviceCode:String?
    /// update user
    var updateErp:String?
    /// update date
    var updateTime:String?



    public override init(){
            super.init()
    }

    enum SysTemplateEndCodingKeys: String, CodingKey {
        case uID
        case createErp
        case createTime
        case enabled
        case name
        case serviceCode
        case updateErp
        case updateTime
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: SysTemplateEndCodingKeys.self)
        if decoderContainer.contains(.uID)
        {
            self.uID = try decoderContainer.decode(String?.self, forKey: .uID)
        }
        if decoderContainer.contains(.createErp)
        {
            self.createErp = try decoderContainer.decode(String?.self, forKey: .createErp)
        }
        if decoderContainer.contains(.createTime)
        {
            self.createTime = try decoderContainer.decode(String?.self, forKey: .createTime)
        }
        if decoderContainer.contains(.enabled)
        {
            self.enabled = try decoderContainer.decode(Bool?.self, forKey: .enabled)
        }
        if decoderContainer.contains(.name)
        {
            self.name = try decoderContainer.decode(String?.self, forKey: .name)
        }
        if decoderContainer.contains(.serviceCode)
        {
            self.serviceCode = try decoderContainer.decode(String?.self, forKey: .serviceCode)
        }
        if decoderContainer.contains(.updateErp)
        {
            self.updateErp = try decoderContainer.decode(String?.self, forKey: .updateErp)
        }
        if decoderContainer.contains(.updateTime)
        {
            self.updateTime = try decoderContainer.decode(String?.self, forKey: .updateTime)
        }
    }
}
public extension SysTemplateEnd{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: SysTemplateEndCodingKeys.self)
         try encoderContainer.encode(uID, forKey: .uID)
         try encoderContainer.encode(createErp, forKey: .createErp)
         try encoderContainer.encode(createTime, forKey: .createTime)
         try encoderContainer.encode(enabled, forKey: .enabled)
         try encoderContainer.encode(name, forKey: .name)
         try encoderContainer.encode(serviceCode, forKey: .serviceCode)
         try encoderContainer.encode(updateErp, forKey: .updateErp)
         try encoderContainer.encode(updateTime, forKey: .updateTime)
    }
}
///  apiConfEnd
public class ApiConfEnd:NSObject,Codable{
    /// api name
    var apiName:String?
    /// apiType: 1-openapi,2-http
    var apiType:Int64?
    /// 记录id
    var id:Int64?
    /// method: GET/POST ...
    var method:String?
    /// params
    var params:[Pair?]?
    /// reps
    var resp:[Pair?]?
    /// serviceCode
    var serviceCode:String?
    /// url
    var url:String?
    /// version: v1
    var version:String?



    public override init(){
            super.init()
    }

    enum ApiConfEndCodingKeys: String, CodingKey {
        case apiName
        case apiType
        case id
        case method
        case params
        case resp
        case serviceCode
        case url
        case version
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: ApiConfEndCodingKeys.self)
        if decoderContainer.contains(.apiName)
        {
            self.apiName = try decoderContainer.decode(String?.self, forKey: .apiName)
        }
        if decoderContainer.contains(.apiType)
        {
            self.apiType = try decoderContainer.decode(Int64?.self, forKey: .apiType)
        }
        if decoderContainer.contains(.id)
        {
            self.id = try decoderContainer.decode(Int64?.self, forKey: .id)
        }
        if decoderContainer.contains(.method)
        {
            self.method = try decoderContainer.decode(String?.self, forKey: .method)
        }
        if decoderContainer.contains(.params)
        {
            self.params = try decoderContainer.decode([Pair?]?.self, forKey: .params)
        }
        if decoderContainer.contains(.resp)
        {
            self.resp = try decoderContainer.decode([Pair?]?.self, forKey: .resp)
        }
        if decoderContainer.contains(.serviceCode)
        {
            self.serviceCode = try decoderContainer.decode(String?.self, forKey: .serviceCode)
        }
        if decoderContainer.contains(.url)
        {
            self.url = try decoderContainer.decode(String?.self, forKey: .url)
        }
        if decoderContainer.contains(.version)
        {
            self.version = try decoderContainer.decode(String?.self, forKey: .version)
        }
    }
}
public extension ApiConfEnd{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: ApiConfEndCodingKeys.self)
         try encoderContainer.encode(apiName, forKey: .apiName)
         try encoderContainer.encode(apiType, forKey: .apiType)
         try encoderContainer.encode(id, forKey: .id)
         try encoderContainer.encode(method, forKey: .method)
         try encoderContainer.encode(params, forKey: .params)
         try encoderContainer.encode(resp, forKey: .resp)
         try encoderContainer.encode(serviceCode, forKey: .serviceCode)
         try encoderContainer.encode(url, forKey: .url)
         try encoderContainer.encode(version, forKey: .version)
    }
}
///  describeMetricTasksSpec
public class DescribeMetricTasksSpec:NSObject,Codable{
    /// 当前所在页，默认为1
      /// in: query
    var pageNumber:Int64?
    /// 页面大小，默认为20；取值范围[1, 100]
      /// in: query
    var pageSize:Int64?



    public override init(){
            super.init()
    }

    enum DescribeMetricTasksSpecCodingKeys: String, CodingKey {
        case pageNumber
        case pageSize
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: DescribeMetricTasksSpecCodingKeys.self)
        if decoderContainer.contains(.pageNumber)
        {
            self.pageNumber = try decoderContainer.decode(Int64?.self, forKey: .pageNumber)
        }
        if decoderContainer.contains(.pageSize)
        {
            self.pageSize = try decoderContainer.decode(Int64?.self, forKey: .pageSize)
        }
    }
}
public extension DescribeMetricTasksSpec{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: DescribeMetricTasksSpecCodingKeys.self)
         try encoderContainer.encode(pageNumber, forKey: .pageNumber)
         try encoderContainer.encode(pageSize, forKey: .pageSize)
    }
}
///  updateMetricTaskSpec
public class UpdateMetricTaskSpec:NSObject,Codable{
    /// 自定义单位
    /// Required:true
    var customUnit:String
    /// 过滤语法，可以为空
    var filterContent:String?
    /// 是否打开过滤
    /// Required:true
    var filterOpen:String
    /// 过滤类型，只能是fulltext和 advance
    /// Required:true
    var filterType:String
    /// 监控任务名称,同一日志主题下唯一，支持中文 大小写英文字母 下划线 中划线 数字，且不超过32
    /// Required:true
    var name:String
    /// 单位
    /// Required:true
    var unit:String



    public  init(customUnit:String,filterOpen:String,filterType:String,name:String,unit:String){
             self.customUnit = customUnit
             self.filterOpen = filterOpen
             self.filterType = filterType
             self.name = name
             self.unit = unit
    }

    enum UpdateMetricTaskSpecCodingKeys: String, CodingKey {
        case customUnit
        case filterContent
        case filterOpen
        case filterType
        case name
        case unit
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: UpdateMetricTaskSpecCodingKeys.self)
        self.customUnit = try decoderContainer.decode(String.self, forKey: .customUnit)
        if decoderContainer.contains(.filterContent)
        {
            self.filterContent = try decoderContainer.decode(String?.self, forKey: .filterContent)
        }
        self.filterOpen = try decoderContainer.decode(String.self, forKey: .filterOpen)
        self.filterType = try decoderContainer.decode(String.self, forKey: .filterType)
        self.name = try decoderContainer.decode(String.self, forKey: .name)
        self.unit = try decoderContainer.decode(String.self, forKey: .unit)
    }
}
public extension UpdateMetricTaskSpec{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: UpdateMetricTaskSpecCodingKeys.self)
         try encoderContainer.encode(customUnit, forKey: .customUnit)
         try encoderContainer.encode(filterContent, forKey: .filterContent)
         try encoderContainer.encode(filterOpen, forKey: .filterOpen)
         try encoderContainer.encode(filterType, forKey: .filterType)
         try encoderContainer.encode(name, forKey: .name)
         try encoderContainer.encode(unit, forKey: .unit)
    }
}
///  testMetricTaskSpec
public class TestMetricTaskSpec:NSObject,Codable{
    /// 聚合函数,支持 count sum max min avg
    /// Required:true
    var aggregate:String
    /// 测试内容
    /// Required:true
    var content:[String?]?
    /// 查询字段,支持 英文字母 数字 下划线 中划线 点（中文日志原文和各产品线的key）
    /// Required:true
    var dataField:String
    /// 过滤语法，可以为空
    var filterContent:String?
    /// 是否打开过滤
    /// Required:true
    var filterOpen:String
    /// 过滤类型，只能是fulltext和 advance
    /// Required:true
    var filterType:String



    public  init(aggregate:String,content:[String?]?,dataField:String,filterOpen:String,filterType:String){
             self.aggregate = aggregate
             self.content = content
             self.dataField = dataField
             self.filterOpen = filterOpen
             self.filterType = filterType
    }

    enum TestMetricTaskSpecCodingKeys: String, CodingKey {
        case aggregate
        case content
        case dataField
        case filterContent
        case filterOpen
        case filterType
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: TestMetricTaskSpecCodingKeys.self)
        self.aggregate = try decoderContainer.decode(String.self, forKey: .aggregate)
        self.content = try decoderContainer.decode([String?]?.self, forKey: .content)
        self.dataField = try decoderContainer.decode(String.self, forKey: .dataField)
        if decoderContainer.contains(.filterContent)
        {
            self.filterContent = try decoderContainer.decode(String?.self, forKey: .filterContent)
        }
        self.filterOpen = try decoderContainer.decode(String.self, forKey: .filterOpen)
        self.filterType = try decoderContainer.decode(String.self, forKey: .filterType)
    }
}
public extension TestMetricTaskSpec{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: TestMetricTaskSpecCodingKeys.self)
         try encoderContainer.encode(aggregate, forKey: .aggregate)
         try encoderContainer.encode(content, forKey: .content)
         try encoderContainer.encode(dataField, forKey: .dataField)
         try encoderContainer.encode(filterContent, forKey: .filterContent)
         try encoderContainer.encode(filterOpen, forKey: .filterOpen)
         try encoderContainer.encode(filterType, forKey: .filterType)
    }
}
///  metrictaskDetailEnd
public class MetrictaskDetailEnd:NSObject,Codable{
    /// 聚合函数
    var aggregate:String?
    /// CretedTime
    var cretedTime:String?
    /// 开启自定义单位
    var customUnit:String?
    /// 查询字段
    var dataField:String?
    /// 过滤语法
    var filterContent:String?
    /// FilterOpen
    var filterOpen:String?
    /// 过滤类型
    var filterType:String?
    /// id
    var id:String?
    /// 周期
    var interval:Int64?
    /// 监控项名称
    var metric:String?
    /// 监控任务名称
    var name:String?
    /// 单位
    var unit:String?
    /// UpdateTime
    var updateTime:String?



    public override init(){
            super.init()
    }

    enum MetrictaskDetailEndCodingKeys: String, CodingKey {
        case aggregate
        case cretedTime
        case customUnit
        case dataField
        case filterContent
        case filterOpen
        case filterType
        case id
        case interval
        case metric
        case name
        case unit
        case updateTime
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: MetrictaskDetailEndCodingKeys.self)
        if decoderContainer.contains(.aggregate)
        {
            self.aggregate = try decoderContainer.decode(String?.self, forKey: .aggregate)
        }
        if decoderContainer.contains(.cretedTime)
        {
            self.cretedTime = try decoderContainer.decode(String?.self, forKey: .cretedTime)
        }
        if decoderContainer.contains(.customUnit)
        {
            self.customUnit = try decoderContainer.decode(String?.self, forKey: .customUnit)
        }
        if decoderContainer.contains(.dataField)
        {
            self.dataField = try decoderContainer.decode(String?.self, forKey: .dataField)
        }
        if decoderContainer.contains(.filterContent)
        {
            self.filterContent = try decoderContainer.decode(String?.self, forKey: .filterContent)
        }
        if decoderContainer.contains(.filterOpen)
        {
            self.filterOpen = try decoderContainer.decode(String?.self, forKey: .filterOpen)
        }
        if decoderContainer.contains(.filterType)
        {
            self.filterType = try decoderContainer.decode(String?.self, forKey: .filterType)
        }
        if decoderContainer.contains(.id)
        {
            self.id = try decoderContainer.decode(String?.self, forKey: .id)
        }
        if decoderContainer.contains(.interval)
        {
            self.interval = try decoderContainer.decode(Int64?.self, forKey: .interval)
        }
        if decoderContainer.contains(.metric)
        {
            self.metric = try decoderContainer.decode(String?.self, forKey: .metric)
        }
        if decoderContainer.contains(.name)
        {
            self.name = try decoderContainer.decode(String?.self, forKey: .name)
        }
        if decoderContainer.contains(.unit)
        {
            self.unit = try decoderContainer.decode(String?.self, forKey: .unit)
        }
        if decoderContainer.contains(.updateTime)
        {
            self.updateTime = try decoderContainer.decode(String?.self, forKey: .updateTime)
        }
    }
}
public extension MetrictaskDetailEnd{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: MetrictaskDetailEndCodingKeys.self)
         try encoderContainer.encode(aggregate, forKey: .aggregate)
         try encoderContainer.encode(cretedTime, forKey: .cretedTime)
         try encoderContainer.encode(customUnit, forKey: .customUnit)
         try encoderContainer.encode(dataField, forKey: .dataField)
         try encoderContainer.encode(filterContent, forKey: .filterContent)
         try encoderContainer.encode(filterOpen, forKey: .filterOpen)
         try encoderContainer.encode(filterType, forKey: .filterType)
         try encoderContainer.encode(id, forKey: .id)
         try encoderContainer.encode(interval, forKey: .interval)
         try encoderContainer.encode(metric, forKey: .metric)
         try encoderContainer.encode(name, forKey: .name)
         try encoderContainer.encode(unit, forKey: .unit)
         try encoderContainer.encode(updateTime, forKey: .updateTime)
    }
}
///  createMetricTaskSpec
public class CreateMetricTaskSpec:NSObject,Codable{
    /// 聚合函数,支持 count sum max min avg
    /// Required:true
    var aggregate:String
    /// 自定义单位
    /// Required:true
    var customUnit:String
    /// 查询字段,支持 英文字母 数字 下划线 中划线 点（中文日志原文和各产品线的key）
    /// Required:true
    var dataField:String
    /// 过滤语法，可以为空
    var filterContent:String?
    /// 是否打开过滤
    /// Required:true
    var filterOpen:String
    /// 过滤类型，只能是fulltext和 advance
    /// Required:true
    var filterType:String
    /// 时间周期，固定60s
    /// Required:true
    var interval:Int64
    /// 监控项 , 支持大小写英文字母 下划线 数字 点，且不超过255byte（不支持中划线）
    /// Required:true
    var metric:String
    /// 监控任务名称,同一个日志主题下唯一，支持中文 大小写英文字母 下划线 中划线 数字，且不超过32字符
    /// Required:true
    var name:String
    /// 单位
    /// Required:true
    var unit:String



    public  init(aggregate:String,customUnit:String,dataField:String,filterOpen:String,filterType:String,interval:Int64,metric:String,name:String,unit:String){
             self.aggregate = aggregate
             self.customUnit = customUnit
             self.dataField = dataField
             self.filterOpen = filterOpen
             self.filterType = filterType
             self.interval = interval
             self.metric = metric
             self.name = name
             self.unit = unit
    }

    enum CreateMetricTaskSpecCodingKeys: String, CodingKey {
        case aggregate
        case customUnit
        case dataField
        case filterContent
        case filterOpen
        case filterType
        case interval
        case metric
        case name
        case unit
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: CreateMetricTaskSpecCodingKeys.self)
        self.aggregate = try decoderContainer.decode(String.self, forKey: .aggregate)
        self.customUnit = try decoderContainer.decode(String.self, forKey: .customUnit)
        self.dataField = try decoderContainer.decode(String.self, forKey: .dataField)
        if decoderContainer.contains(.filterContent)
        {
            self.filterContent = try decoderContainer.decode(String?.self, forKey: .filterContent)
        }
        self.filterOpen = try decoderContainer.decode(String.self, forKey: .filterOpen)
        self.filterType = try decoderContainer.decode(String.self, forKey: .filterType)
        self.interval = try decoderContainer.decode(Int64.self, forKey: .interval)
        self.metric = try decoderContainer.decode(String.self, forKey: .metric)
        self.name = try decoderContainer.decode(String.self, forKey: .name)
        self.unit = try decoderContainer.decode(String.self, forKey: .unit)
    }
}
public extension CreateMetricTaskSpec{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: CreateMetricTaskSpecCodingKeys.self)
         try encoderContainer.encode(aggregate, forKey: .aggregate)
         try encoderContainer.encode(customUnit, forKey: .customUnit)
         try encoderContainer.encode(dataField, forKey: .dataField)
         try encoderContainer.encode(filterContent, forKey: .filterContent)
         try encoderContainer.encode(filterOpen, forKey: .filterOpen)
         try encoderContainer.encode(filterType, forKey: .filterType)
         try encoderContainer.encode(interval, forKey: .interval)
         try encoderContainer.encode(metric, forKey: .metric)
         try encoderContainer.encode(name, forKey: .name)
         try encoderContainer.encode(unit, forKey: .unit)
    }
}
///  logsetEnd
public class LogsetEnd:NSObject,Codable{
    /// UID
    var uID:String?
    /// 创建时间
    var createTime:String?
    /// 描述信息
    var descriptionValue:String?
    /// 是否存在日志主题
    var hasTopic:Bool?
    /// 保存周期
    var lifeCycle:Int64?
    /// 日志集名称
    var name:String?
    /// 地域信息
    var region:String?



    public override init(){
            super.init()
    }

    enum LogsetEndCodingKeys: String, CodingKey {
        case uID
        case createTime
        case descriptionValue = "description"
        case hasTopic
        case lifeCycle
        case name
        case region
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: LogsetEndCodingKeys.self)
        if decoderContainer.contains(.uID)
        {
            self.uID = try decoderContainer.decode(String?.self, forKey: .uID)
        }
        if decoderContainer.contains(.createTime)
        {
            self.createTime = try decoderContainer.decode(String?.self, forKey: .createTime)
        }
        if decoderContainer.contains(.descriptionValue)
        {
            self.descriptionValue = try decoderContainer.decode(String?.self, forKey: .descriptionValue)
        }
        if decoderContainer.contains(.hasTopic)
        {
            self.hasTopic = try decoderContainer.decode(Bool?.self, forKey: .hasTopic)
        }
        if decoderContainer.contains(.lifeCycle)
        {
            self.lifeCycle = try decoderContainer.decode(Int64?.self, forKey: .lifeCycle)
        }
        if decoderContainer.contains(.name)
        {
            self.name = try decoderContainer.decode(String?.self, forKey: .name)
        }
        if decoderContainer.contains(.region)
        {
            self.region = try decoderContainer.decode(String?.self, forKey: .region)
        }
    }
}
public extension LogsetEnd{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: LogsetEndCodingKeys.self)
         try encoderContainer.encode(uID, forKey: .uID)
         try encoderContainer.encode(createTime, forKey: .createTime)
         try encoderContainer.encode(descriptionValue, forKey: .descriptionValue)
         try encoderContainer.encode(hasTopic, forKey: .hasTopic)
         try encoderContainer.encode(lifeCycle, forKey: .lifeCycle)
         try encoderContainer.encode(name, forKey: .name)
         try encoderContainer.encode(region, forKey: .region)
    }
}
///  collectConf
public class CollectConf:NSObject,Codable{
    /// collectTemplateUID
    var collectTemplateUID:String?
    /// 采集文件名称，支持通配
    var file:String?
    /// filters 过滤器V1：多个词之间为or的关系
    var filters:[String?]?
    /// logtopicUID 日志主题UID
    var logtopicUID:String?
    /// 采集文件路径，支持通配
    var path:String?
    /// 用户 PIN
    var pin:String?



    public override init(){
            super.init()
    }

    enum CollectConfCodingKeys: String, CodingKey {
        case collectTemplateUID
        case file
        case filters
        case logtopicUID
        case path
        case pin
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: CollectConfCodingKeys.self)
        if decoderContainer.contains(.collectTemplateUID)
        {
            self.collectTemplateUID = try decoderContainer.decode(String?.self, forKey: .collectTemplateUID)
        }
        if decoderContainer.contains(.file)
        {
            self.file = try decoderContainer.decode(String?.self, forKey: .file)
        }
        if decoderContainer.contains(.filters)
        {
            self.filters = try decoderContainer.decode([String?]?.self, forKey: .filters)
        }
        if decoderContainer.contains(.logtopicUID)
        {
            self.logtopicUID = try decoderContainer.decode(String?.self, forKey: .logtopicUID)
        }
        if decoderContainer.contains(.path)
        {
            self.path = try decoderContainer.decode(String?.self, forKey: .path)
        }
        if decoderContainer.contains(.pin)
        {
            self.pin = try decoderContainer.decode(String?.self, forKey: .pin)
        }
    }
}
public extension CollectConf{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: CollectConfCodingKeys.self)
         try encoderContainer.encode(collectTemplateUID, forKey: .collectTemplateUID)
         try encoderContainer.encode(file, forKey: .file)
         try encoderContainer.encode(filters, forKey: .filters)
         try encoderContainer.encode(logtopicUID, forKey: .logtopicUID)
         try encoderContainer.encode(path, forKey: .path)
         try encoderContainer.encode(pin, forKey: .pin)
    }
}
///  resource
public class Resource:NSObject,Codable{
    /// 资源所属地域
    /// Required:true
    var region:String
    /// 资源ID
    /// Required:true
    var resourceId:String



    public  init(region:String,resourceId:String){
             self.region = region
             self.resourceId = resourceId
    }

    enum ResourceCodingKeys: String, CodingKey {
        case region
        case resourceId
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: ResourceCodingKeys.self)
        self.region = try decoderContainer.decode(String.self, forKey: .region)
        self.resourceId = try decoderContainer.decode(String.self, forKey: .resourceId)
    }
}
public extension Resource{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: ResourceCodingKeys.self)
         try encoderContainer.encode(region, forKey: .region)
         try encoderContainer.encode(resourceId, forKey: .resourceId)
    }
}
///  resourceEnd
public class ResourceEnd:NSObject,Codable{
    /// agent 状态: 0-异常，1-正常
    var agentStatus:Int64?
    /// 资源名称
    var name:String?
    /// 资源所属地域
    var region:String?
    /// 资源ID
    var resourceId:String?



    public override init(){
            super.init()
    }

    enum ResourceEndCodingKeys: String, CodingKey {
        case agentStatus
        case name
        case region
        case resourceId
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: ResourceEndCodingKeys.self)
        if decoderContainer.contains(.agentStatus)
        {
            self.agentStatus = try decoderContainer.decode(Int64?.self, forKey: .agentStatus)
        }
        if decoderContainer.contains(.name)
        {
            self.name = try decoderContainer.decode(String?.self, forKey: .name)
        }
        if decoderContainer.contains(.region)
        {
            self.region = try decoderContainer.decode(String?.self, forKey: .region)
        }
        if decoderContainer.contains(.resourceId)
        {
            self.resourceId = try decoderContainer.decode(String?.self, forKey: .resourceId)
        }
    }
}
public extension ResourceEnd{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: ResourceEndCodingKeys.self)
         try encoderContainer.encode(agentStatus, forKey: .agentStatus)
         try encoderContainer.encode(name, forKey: .name)
         try encoderContainer.encode(region, forKey: .region)
         try encoderContainer.encode(resourceId, forKey: .resourceId)
    }
}
///  collectInfoDetailEnd
public class CollectInfoDetailEnd:NSObject,Codable{
    /// UID
    var uID:String?
    /// 日志来源，只能是 custom
    var appCode:String?
    /// Detail
    var detail:CollectTempalteEnd?
    /// Enabled
    var enabled:Int64?
    /// 采集实例类型, 只能是 all/part
    var resourceType:String?
    /// 采集实例数量
    var resourcesCount:Int64?
    /// 产品线
    var serviceCode:String?
    /// 日志类型名称
    var templateName:String?
    /// 日志类型
    var templateUID:String?



    public override init(){
            super.init()
    }

    enum CollectInfoDetailEndCodingKeys: String, CodingKey {
        case uID
        case appCode
        case detail
        case enabled
        case resourceType
        case resourcesCount
        case serviceCode
        case templateName
        case templateUID
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: CollectInfoDetailEndCodingKeys.self)
        if decoderContainer.contains(.uID)
        {
            self.uID = try decoderContainer.decode(String?.self, forKey: .uID)
        }
        if decoderContainer.contains(.appCode)
        {
            self.appCode = try decoderContainer.decode(String?.self, forKey: .appCode)
        }
        if decoderContainer.contains(.detail)
        {
            self.detail = try decoderContainer.decode(CollectTempalteEnd?.self, forKey: .detail)
        }
        if decoderContainer.contains(.enabled)
        {
            self.enabled = try decoderContainer.decode(Int64?.self, forKey: .enabled)
        }
        if decoderContainer.contains(.resourceType)
        {
            self.resourceType = try decoderContainer.decode(String?.self, forKey: .resourceType)
        }
        if decoderContainer.contains(.resourcesCount)
        {
            self.resourcesCount = try decoderContainer.decode(Int64?.self, forKey: .resourcesCount)
        }
        if decoderContainer.contains(.serviceCode)
        {
            self.serviceCode = try decoderContainer.decode(String?.self, forKey: .serviceCode)
        }
        if decoderContainer.contains(.templateName)
        {
            self.templateName = try decoderContainer.decode(String?.self, forKey: .templateName)
        }
        if decoderContainer.contains(.templateUID)
        {
            self.templateUID = try decoderContainer.decode(String?.self, forKey: .templateUID)
        }
    }
}
public extension CollectInfoDetailEnd{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: CollectInfoDetailEndCodingKeys.self)
         try encoderContainer.encode(uID, forKey: .uID)
         try encoderContainer.encode(appCode, forKey: .appCode)
         try encoderContainer.encode(detail, forKey: .detail)
         try encoderContainer.encode(enabled, forKey: .enabled)
         try encoderContainer.encode(resourceType, forKey: .resourceType)
         try encoderContainer.encode(resourcesCount, forKey: .resourcesCount)
         try encoderContainer.encode(serviceCode, forKey: .serviceCode)
         try encoderContainer.encode(templateName, forKey: .templateName)
         try encoderContainer.encode(templateUID, forKey: .templateUID)
    }
}
///  logtopicDetailEnd
public class LogtopicDetailEnd:NSObject,Codable{
    /// CollectInfo
    var collectInfo:CollectInfoDetailEnd?
    /// UID
    var uID:String?
    /// 采集配置UID
    var collectInfoUID:String?
    /// 创建时间
    var createTime:String?
    /// 描述信息
    var descriptionValue:String?
    /// 最新日志上报时间
    var lastRecordTime:String?
    /// 所属日志集名称
    var logsetName:String?
    /// 所属日志集
    var logsetUID:String?
    /// 日志主题名称
    var name:String?
    /// 地域信息
    var region:String?



    public override init(){
            super.init()
    }

    enum LogtopicDetailEndCodingKeys: String, CodingKey {
        case collectInfo
        case uID
        case collectInfoUID
        case createTime
        case descriptionValue = "description"
        case lastRecordTime
        case logsetName
        case logsetUID
        case name
        case region
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: LogtopicDetailEndCodingKeys.self)
        if decoderContainer.contains(.collectInfo)
        {
            self.collectInfo = try decoderContainer.decode(CollectInfoDetailEnd?.self, forKey: .collectInfo)
        }
        if decoderContainer.contains(.uID)
        {
            self.uID = try decoderContainer.decode(String?.self, forKey: .uID)
        }
        if decoderContainer.contains(.collectInfoUID)
        {
            self.collectInfoUID = try decoderContainer.decode(String?.self, forKey: .collectInfoUID)
        }
        if decoderContainer.contains(.createTime)
        {
            self.createTime = try decoderContainer.decode(String?.self, forKey: .createTime)
        }
        if decoderContainer.contains(.descriptionValue)
        {
            self.descriptionValue = try decoderContainer.decode(String?.self, forKey: .descriptionValue)
        }
        if decoderContainer.contains(.lastRecordTime)
        {
            self.lastRecordTime = try decoderContainer.decode(String?.self, forKey: .lastRecordTime)
        }
        if decoderContainer.contains(.logsetName)
        {
            self.logsetName = try decoderContainer.decode(String?.self, forKey: .logsetName)
        }
        if decoderContainer.contains(.logsetUID)
        {
            self.logsetUID = try decoderContainer.decode(String?.self, forKey: .logsetUID)
        }
        if decoderContainer.contains(.name)
        {
            self.name = try decoderContainer.decode(String?.self, forKey: .name)
        }
        if decoderContainer.contains(.region)
        {
            self.region = try decoderContainer.decode(String?.self, forKey: .region)
        }
    }
}
public extension LogtopicDetailEnd{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: LogtopicDetailEndCodingKeys.self)
         try encoderContainer.encode(collectInfo, forKey: .collectInfo)
         try encoderContainer.encode(uID, forKey: .uID)
         try encoderContainer.encode(collectInfoUID, forKey: .collectInfoUID)
         try encoderContainer.encode(createTime, forKey: .createTime)
         try encoderContainer.encode(descriptionValue, forKey: .descriptionValue)
         try encoderContainer.encode(lastRecordTime, forKey: .lastRecordTime)
         try encoderContainer.encode(logsetName, forKey: .logsetName)
         try encoderContainer.encode(logsetUID, forKey: .logsetUID)
         try encoderContainer.encode(name, forKey: .name)
         try encoderContainer.encode(region, forKey: .region)
    }
}
///  collectTempalteEnd
public class CollectTempalteEnd:NSObject,Codable{
    /// 过滤器是否启用
    var filterEnabled:Bool?
    /// 日志文件
    var logFile:String?
    /// 过滤器
    var logFilters:[String?]?
    /// 日志路径
    var logPath:String?



    public override init(){
            super.init()
    }

    enum CollectTempalteEndCodingKeys: String, CodingKey {
        case filterEnabled
        case logFile
        case logFilters
        case logPath
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: CollectTempalteEndCodingKeys.self)
        if decoderContainer.contains(.filterEnabled)
        {
            self.filterEnabled = try decoderContainer.decode(Bool?.self, forKey: .filterEnabled)
        }
        if decoderContainer.contains(.logFile)
        {
            self.logFile = try decoderContainer.decode(String?.self, forKey: .logFile)
        }
        if decoderContainer.contains(.logFilters)
        {
            self.logFilters = try decoderContainer.decode([String?]?.self, forKey: .logFilters)
        }
        if decoderContainer.contains(.logPath)
        {
            self.logPath = try decoderContainer.decode(String?.self, forKey: .logPath)
        }
    }
}
public extension CollectTempalteEnd{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: CollectTempalteEndCodingKeys.self)
         try encoderContainer.encode(filterEnabled, forKey: .filterEnabled)
         try encoderContainer.encode(logFile, forKey: .logFile)
         try encoderContainer.encode(logFilters, forKey: .logFilters)
         try encoderContainer.encode(logPath, forKey: .logPath)
    }
}
///  describeInstanceCollectConfsEnd
public class DescribeInstanceCollectConfsEnd:NSObject,Codable{
    /// result
    var result:[CollectConf?]?



    public override init(){
            super.init()
    }

    enum DescribeInstanceCollectConfsEndCodingKeys: String, CodingKey {
        case result
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: DescribeInstanceCollectConfsEndCodingKeys.self)
        if decoderContainer.contains(.result)
        {
            self.result = try decoderContainer.decode([CollectConf?]?.self, forKey: .result)
        }
    }
}
public extension DescribeInstanceCollectConfsEnd{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: DescribeInstanceCollectConfsEndCodingKeys.self)
         try encoderContainer.encode(result, forKey: .result)
    }
}
///  systemLogResultData
public class SystemLogResultData:NSObject,Codable{
    /// 上下文日志搜索锚点
    var anchor:[AnyObject?]?
    /// 包含id, originalMsg, time字段
    var source:AnyObject?



    public override init(){
            super.init()
    }

    enum SystemLogResultDataCodingKeys: String, CodingKey {
        case anchor
        case source
    }


    required public init(from decoder: Decoder) throws {
    }
}
public extension SystemLogResultData{
    func encode(to encoder: Encoder) throws {
    }
}
///  error
public class Error:NSObject,Codable{
    /// Code
    var code:Int64?
    /// Details
    var details:AnyObject?
    /// Message
    var message:String?
    /// Status
    var status:String?



    public override init(){
            super.init()
    }

    enum ErrorCodingKeys: String, CodingKey {
        case code
        case details
        case message
        case status
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: ErrorCodingKeys.self)
        if decoderContainer.contains(.code)
        {
            self.code = try decoderContainer.decode(Int64?.self, forKey: .code)
        }
        if decoderContainer.contains(.message)
        {
            self.message = try decoderContainer.decode(String?.self, forKey: .message)
        }
        if decoderContainer.contains(.status)
        {
            self.status = try decoderContainer.decode(String?.self, forKey: .status)
        }
    }
}
public extension Error{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: ErrorCodingKeys.self)
         try encoderContainer.encode(code, forKey: .code)
         try encoderContainer.encode(message, forKey: .message)
         try encoderContainer.encode(status, forKey: .status)
    }
}
///  describeLogdCAEnd
public class DescribeLogdCAEnd:NSObject,Codable{
    /// cer 证书，hex string
    var cer:String?
    /// expiryDate 证书到期日
    var expiryDate:String?



    public override init(){
            super.init()
    }

    enum DescribeLogdCAEndCodingKeys: String, CodingKey {
        case cer
        case expiryDate
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: DescribeLogdCAEndCodingKeys.self)
        if decoderContainer.contains(.cer)
        {
            self.cer = try decoderContainer.decode(String?.self, forKey: .cer)
        }
        if decoderContainer.contains(.expiryDate)
        {
            self.expiryDate = try decoderContainer.decode(String?.self, forKey: .expiryDate)
        }
    }
}
public extension DescribeLogdCAEnd{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: DescribeLogdCAEndCodingKeys.self)
         try encoderContainer.encode(cer, forKey: .cer)
         try encoderContainer.encode(expiryDate, forKey: .expiryDate)
    }
}
///  customLogSearchOut
public class CustomLogSearchOut:NSObject,Codable{
    /// Code
    var code:Int64?
    /// Data
    var data:[AnyObject?]?
    /// Message
    var message:String?
    /// Size
    var size:Int64?
    /// Total
    var total:Int64?



    public override init(){
            super.init()
    }

    enum CustomLogSearchOutCodingKeys: String, CodingKey {
        case code
        case data
        case message
        case size
        case total
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: CustomLogSearchOutCodingKeys.self)
        if decoderContainer.contains(.code)
        {
            self.code = try decoderContainer.decode(Int64?.self, forKey: .code)
        }
        if decoderContainer.contains(.message)
        {
            self.message = try decoderContainer.decode(String?.self, forKey: .message)
        }
        if decoderContainer.contains(.size)
        {
            self.size = try decoderContainer.decode(Int64?.self, forKey: .size)
        }
        if decoderContainer.contains(.total)
        {
            self.total = try decoderContainer.decode(Int64?.self, forKey: .total)
        }
    }
}
public extension CustomLogSearchOut{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: CustomLogSearchOutCodingKeys.self)
         try encoderContainer.encode(code, forKey: .code)
         try encoderContainer.encode(message, forKey: .message)
         try encoderContainer.encode(size, forKey: .size)
         try encoderContainer.encode(total, forKey: .total)
    }
}
///  describeInstanceMetaEnd
public class DescribeInstanceMetaEnd:NSObject,Codable{
    /// pin 机器所属pin
    var pin:String?
    /// tags map[string]string 冗余字段，后续随时添加
    var tags:[String:String?]?
    /// timestamp 服务器时间
    var timestamp:String?



    public override init(){
            super.init()
    }

    enum DescribeInstanceMetaEndCodingKeys: String, CodingKey {
        case pin
        case tags
        case timestamp
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: DescribeInstanceMetaEndCodingKeys.self)
        if decoderContainer.contains(.pin)
        {
            self.pin = try decoderContainer.decode(String?.self, forKey: .pin)
        }
        if decoderContainer.contains(.tags)
        {
            self.tags = try decoderContainer.decode([String:String?]?.self, forKey: .tags)
        }
        if decoderContainer.contains(.timestamp)
        {
            self.timestamp = try decoderContainer.decode(String?.self, forKey: .timestamp)
        }
    }
}
public extension DescribeInstanceMetaEnd{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: DescribeInstanceMetaEndCodingKeys.self)
         try encoderContainer.encode(pin, forKey: .pin)
         try encoderContainer.encode(tags, forKey: .tags)
         try encoderContainer.encode(timestamp, forKey: .timestamp)
    }
}
///  targetConf
public class TargetConf:NSObject,Codable{
    /// 目的地 配置
    /// Required:true
    var targetConfValue:[String:AnyObject?]?
    /// 转储目的地类型 0: oss, 目前只支持oss
    var targetType:Int64?



    public  init(targetConfValue:[String:AnyObject?]?){
             self.targetConfValue = targetConfValue
    }

    enum TargetConfCodingKeys: String, CodingKey {
        case targetConfValue = "targetConf"
        case targetType
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: TargetConfCodingKeys.self)
        if decoderContainer.contains(.targetType)
        {
            self.targetType = try decoderContainer.decode(Int64?.self, forKey: .targetType)
        }
    }
}
public extension TargetConf{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: TargetConfCodingKeys.self)
         try encoderContainer.encode(targetType, forKey: .targetType)
    }
}
///  err
public class Err:NSObject,Codable{
    /// Code
    var code:Int64?
    /// Details
    var details:AnyObject?
    /// Message
    var message:String?
    /// Status
    var status:String?



    public override init(){
            super.init()
    }

    enum ErrCodingKeys: String, CodingKey {
        case code
        case details
        case message
        case status
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: ErrCodingKeys.self)
        if decoderContainer.contains(.code)
        {
            self.code = try decoderContainer.decode(Int64?.self, forKey: .code)
        }
        if decoderContainer.contains(.message)
        {
            self.message = try decoderContainer.decode(String?.self, forKey: .message)
        }
        if decoderContainer.contains(.status)
        {
            self.status = try decoderContainer.decode(String?.self, forKey: .status)
        }
    }
}
public extension Err{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: ErrCodingKeys.self)
         try encoderContainer.encode(code, forKey: .code)
         try encoderContainer.encode(message, forKey: .message)
         try encoderContainer.encode(status, forKey: .status)
    }
}
///  systemLogResultTrace
public class SystemLogResultTrace:NSObject,Codable{
    /// DestIp
    var destIp:String?
    /// Id
    var id:String?
    /// SrcIp
    var srcIp:String?
    /// Timestamp
    var timestamp:Int64?



    public override init(){
            super.init()
    }

    enum SystemLogResultTraceCodingKeys: String, CodingKey {
        case destIp
        case id
        case srcIp
        case timestamp
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: SystemLogResultTraceCodingKeys.self)
        if decoderContainer.contains(.destIp)
        {
            self.destIp = try decoderContainer.decode(String?.self, forKey: .destIp)
        }
        if decoderContainer.contains(.id)
        {
            self.id = try decoderContainer.decode(String?.self, forKey: .id)
        }
        if decoderContainer.contains(.srcIp)
        {
            self.srcIp = try decoderContainer.decode(String?.self, forKey: .srcIp)
        }
        if decoderContainer.contains(.timestamp)
        {
            self.timestamp = try decoderContainer.decode(Int64?.self, forKey: .timestamp)
        }
    }
}
public extension SystemLogResultTrace{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: SystemLogResultTraceCodingKeys.self)
         try encoderContainer.encode(destIp, forKey: .destIp)
         try encoderContainer.encode(id, forKey: .id)
         try encoderContainer.encode(srcIp, forKey: .srcIp)
         try encoderContainer.encode(timestamp, forKey: .timestamp)
    }
}
///  systemLogResultStatus
public class SystemLogResultStatus:NSObject,Codable{
    /// Code
    var code:String?



    public override init(){
            super.init()
    }

    enum SystemLogResultStatusCodingKeys: String, CodingKey {
        case code
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: SystemLogResultStatusCodingKeys.self)
        if decoderContainer.contains(.code)
        {
            self.code = try decoderContainer.decode(String?.self, forKey: .code)
        }
    }
}
public extension SystemLogResultStatus{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: SystemLogResultStatusCodingKeys.self)
         try encoderContainer.encode(code, forKey: .code)
    }
}
///  systemLogEnd
public class SystemLogEnd:NSObject,Codable{
    /// Data
    var data:[SystemLogResultData?]?
    /// Hits
    var hits:Int64?
    /// Size
    var size:Int64?



    public override init(){
            super.init()
    }

    enum SystemLogEndCodingKeys: String, CodingKey {
        case data
        case hits
        case size
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: SystemLogEndCodingKeys.self)
        if decoderContainer.contains(.data)
        {
            self.data = try decoderContainer.decode([SystemLogResultData?]?.self, forKey: .data)
        }
        if decoderContainer.contains(.hits)
        {
            self.hits = try decoderContainer.decode(Int64?.self, forKey: .hits)
        }
        if decoderContainer.contains(.size)
        {
            self.size = try decoderContainer.decode(Int64?.self, forKey: .size)
        }
    }
}
public extension SystemLogEnd{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: SystemLogEndCodingKeys.self)
         try encoderContainer.encode(data, forKey: .data)
         try encoderContainer.encode(hits, forKey: .hits)
         try encoderContainer.encode(size, forKey: .size)
    }
}

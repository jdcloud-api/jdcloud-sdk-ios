/* Copyright 2018 JDCLOUD.COM

   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at

     http:#www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.

   
   

   
   Contact: 

   NOTE: This class is auto generated by the jdcloud code generator program.
 */


import Foundation

///  shipperEnd
@objc(ShipperEnd)
public class ShipperEnd:NSObject,Codable{
    /// UID
    var uID:String?
    /// 日志类型
    var appName:String?
    /// 压缩格式，为空不压缩
    var compress:String?
    /// 创建时间
    var createTime:String?
    /// 投递格式 json,  origin(原始日志格式), 默认origin
    var fileFormat:String?
    /// 投递文件大小，单位MB，支持200,300,400,500,1000
    /// Required:true
    var fileSize:Int64
    /// 日志集uuid
    var logsetUID:String?
    /// 日志主题uuid
    var logtopicUID:String?
    /// 转储任务名称
    /// Required:true
    var name:String
    /// pin
    var pin:String?
    /// 地域信息
    var region:String?
    /// 日志采集资源类型
    var resourceType:Int64?
    /// 日志采集列表
    var resourceUIDs:[String?]?
    /// serviceCode
    var serviceCode:String?
    /// 日志转储任务状态，开启，停止
    var status:Int64?
    /// 目的地 配置
    /// Required:true
    var targetConf:[String:AnyObject?]?
    /// 转储目的地类型 0: oss, 目前只支持oss
    var targetType:Int64?
    /// 投递时间间隔单位分钟，5分钟整数倍，支持5,10,15,20,30,60
    /// Required:true
    var timeInterval:Int64
    /// 更新时间
    var updateTime:String?



    public  init(fileSize:Int64,name:String,targetConf:[String:AnyObject?],timeInterval:Int64){
             self.fileSize = fileSize
             self.name = name
             self.targetConf = targetConf
             self.timeInterval = timeInterval
    }

    enum ShipperEndCodingKeys: String, CodingKey {
        case uID
        case appName
        case compress
        case createTime
        case fileFormat
        case fileSize
        case logsetUID
        case logtopicUID
        case name
        case pin
        case region
        case resourceType
        case resourceUIDs
        case serviceCode
        case status
        case targetType
        case timeInterval
        case updateTime
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: ShipperEndCodingKeys.self)
        if decoderContainer.contains(.uID)
        {
            self.uID = try decoderContainer.decode(String?.self, forKey: .uID)
        }
        if decoderContainer.contains(.appName)
        {
            self.appName = try decoderContainer.decode(String?.self, forKey: .appName)
        }
        if decoderContainer.contains(.compress)
        {
            self.compress = try decoderContainer.decode(String?.self, forKey: .compress)
        }
        if decoderContainer.contains(.createTime)
        {
            self.createTime = try decoderContainer.decode(String?.self, forKey: .createTime)
        }
        if decoderContainer.contains(.fileFormat)
        {
            self.fileFormat = try decoderContainer.decode(String?.self, forKey: .fileFormat)
        }
        self.fileSize = try decoderContainer.decode(Int64.self, forKey: .fileSize)
        if decoderContainer.contains(.logsetUID)
        {
            self.logsetUID = try decoderContainer.decode(String?.self, forKey: .logsetUID)
        }
        if decoderContainer.contains(.logtopicUID)
        {
            self.logtopicUID = try decoderContainer.decode(String?.self, forKey: .logtopicUID)
        }
        self.name = try decoderContainer.decode(String.self, forKey: .name)
        if decoderContainer.contains(.pin)
        {
            self.pin = try decoderContainer.decode(String?.self, forKey: .pin)
        }
        if decoderContainer.contains(.region)
        {
            self.region = try decoderContainer.decode(String?.self, forKey: .region)
        }
        if decoderContainer.contains(.resourceType)
        {
            self.resourceType = try decoderContainer.decode(Int64?.self, forKey: .resourceType)
        }
        if decoderContainer.contains(.resourceUIDs)
        {
            self.resourceUIDs = try decoderContainer.decode([String?]?.self, forKey: .resourceUIDs)
        }
        if decoderContainer.contains(.serviceCode)
        {
            self.serviceCode = try decoderContainer.decode(String?.self, forKey: .serviceCode)
        }
        if decoderContainer.contains(.status)
        {
            self.status = try decoderContainer.decode(Int64?.self, forKey: .status)
        }
        if decoderContainer.contains(.targetType)
        {
            self.targetType = try decoderContainer.decode(Int64?.self, forKey: .targetType)
        }
        self.timeInterval = try decoderContainer.decode(Int64.self, forKey: .timeInterval)
        if decoderContainer.contains(.updateTime)
        {
            self.updateTime = try decoderContainer.decode(String?.self, forKey: .updateTime)
        }
    }
}
public extension ShipperEnd{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: ShipperEndCodingKeys.self)
         try encoderContainer.encode(uID, forKey: .uID)
         try encoderContainer.encode(appName, forKey: .appName)
         try encoderContainer.encode(compress, forKey: .compress)
         try encoderContainer.encode(createTime, forKey: .createTime)
         try encoderContainer.encode(fileFormat, forKey: .fileFormat)
         try encoderContainer.encode(fileSize, forKey: .fileSize)
         try encoderContainer.encode(logsetUID, forKey: .logsetUID)
         try encoderContainer.encode(logtopicUID, forKey: .logtopicUID)
         try encoderContainer.encode(name, forKey: .name)
         try encoderContainer.encode(pin, forKey: .pin)
         try encoderContainer.encode(region, forKey: .region)
         try encoderContainer.encode(resourceType, forKey: .resourceType)
         try encoderContainer.encode(resourceUIDs, forKey: .resourceUIDs)
         try encoderContainer.encode(serviceCode, forKey: .serviceCode)
         try encoderContainer.encode(status, forKey: .status)
         try encoderContainer.encode(targetType, forKey: .targetType)
         try encoderContainer.encode(timeInterval, forKey: .timeInterval)
         try encoderContainer.encode(updateTime, forKey: .updateTime)
    }
}

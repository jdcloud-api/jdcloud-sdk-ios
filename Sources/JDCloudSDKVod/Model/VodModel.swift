/* Copyright 2018 JDCLOUD.COM

   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at

     http:#www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.

   Media Upload
   媒体上传相关接口

   OpenAPI spec version: v1
   Contact: 

   NOTE: This class is auto generated by the jdcloud code generator program.
 */


import Foundation
///  uploadCallbackRequestObject
public class UploadCallbackRequestObject:NSObject,Codable{
    /// 上传状态
    var status:Int?
    /// 视频名称
    var name:String?
    /// 格式
    var format:String?
    /// 文件大小
    var size:Int64?
    /// 分类ID
    var categoryId:Int64?
    /// 转码模板ID，多个时以逗号分隔
    var coderateId:String?
    /// 水印ID，多个时以逗号分隔
    var logoId:String?
    /// 下载地址
    var url:String?
    /// 存储节点域名
    var endpoint:String?
    /// 存储桶名称
    var bucket:String?



    public override init(){
            super.init()
    }

    enum UploadCallbackRequestObjectCodingKeys: String, CodingKey {
        case status
        case name
        case format
        case size
        case categoryId
        case coderateId
        case logoId
        case url
        case endpoint
        case bucket
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: UploadCallbackRequestObjectCodingKeys.self)
        if decoderContainer.contains(.status)
        {
            self.status = try decoderContainer.decode(Int?.self, forKey: .status)
        }
        if decoderContainer.contains(.name)
        {
            self.name = try decoderContainer.decode(String?.self, forKey: .name)
        }
        if decoderContainer.contains(.format)
        {
            self.format = try decoderContainer.decode(String?.self, forKey: .format)
        }
        if decoderContainer.contains(.size)
        {
            self.size = try decoderContainer.decode(Int64?.self, forKey: .size)
        }
        if decoderContainer.contains(.categoryId)
        {
            self.categoryId = try decoderContainer.decode(Int64?.self, forKey: .categoryId)
        }
        if decoderContainer.contains(.coderateId)
        {
            self.coderateId = try decoderContainer.decode(String?.self, forKey: .coderateId)
        }
        if decoderContainer.contains(.logoId)
        {
            self.logoId = try decoderContainer.decode(String?.self, forKey: .logoId)
        }
        if decoderContainer.contains(.url)
        {
            self.url = try decoderContainer.decode(String?.self, forKey: .url)
        }
        if decoderContainer.contains(.endpoint)
        {
            self.endpoint = try decoderContainer.decode(String?.self, forKey: .endpoint)
        }
        if decoderContainer.contains(.bucket)
        {
            self.bucket = try decoderContainer.decode(String?.self, forKey: .bucket)
        }
    }
}
public extension UploadCallbackRequestObject{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: UploadCallbackRequestObjectCodingKeys.self)
         try encoderContainer.encode(status, forKey: .status)
         try encoderContainer.encode(name, forKey: .name)
         try encoderContainer.encode(format, forKey: .format)
         try encoderContainer.encode(size, forKey: .size)
         try encoderContainer.encode(categoryId, forKey: .categoryId)
         try encoderContainer.encode(coderateId, forKey: .coderateId)
         try encoderContainer.encode(logoId, forKey: .logoId)
         try encoderContainer.encode(url, forKey: .url)
         try encoderContainer.encode(endpoint, forKey: .endpoint)
         try encoderContainer.encode(bucket, forKey: .bucket)
    }
}
///  uploadCallbackResultObject
public class UploadCallbackResultObject:NSObject,Codable{
    /// 媒资ID
    var mid:String?



    public override init(){
            super.init()
    }

    enum UploadCallbackResultObjectCodingKeys: String, CodingKey {
        case mid
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: UploadCallbackResultObjectCodingKeys.self)
        if decoderContainer.contains(.mid)
        {
            self.mid = try decoderContainer.decode(String?.self, forKey: .mid)
        }
    }
}
public extension UploadCallbackResultObject{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: UploadCallbackResultObjectCodingKeys.self)
         try encoderContainer.encode(mid, forKey: .mid)
    }
}
///  提交质检作业请求对象
public class SubmitQualityDetectionJobRequestObject:NSObject,Codable{
    /// 媒资ID
    var mediaId:String?
    /// 质检模板ID列表
    var templateIds:[Int64?]?



    public override init(){
            super.init()
    }

    enum SubmitQualityDetectionJobRequestObjectCodingKeys: String, CodingKey {
        case mediaId
        case templateIds
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: SubmitQualityDetectionJobRequestObjectCodingKeys.self)
        if decoderContainer.contains(.mediaId)
        {
            self.mediaId = try decoderContainer.decode(String?.self, forKey: .mediaId)
        }
        if decoderContainer.contains(.templateIds)
        {
            self.templateIds = try decoderContainer.decode([Int64?]?.self, forKey: .templateIds)
        }
    }
}
public extension SubmitQualityDetectionJobRequestObject{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: SubmitQualityDetectionJobRequestObjectCodingKeys.self)
         try encoderContainer.encode(mediaId, forKey: .mediaId)
         try encoderContainer.encode(templateIds, forKey: .templateIds)
    }
}
///  批量提交质检作业请求对象
public class BatchSubmitQualityDetectionJobsRequestObject:NSObject,Codable{
    /// BulkItems
    var bulkItems:[SubmitQualityDetectionJobRequestObject?]?



    public override init(){
            super.init()
    }

    enum BatchSubmitQualityDetectionJobsRequestObjectCodingKeys: String, CodingKey {
        case bulkItems
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: BatchSubmitQualityDetectionJobsRequestObjectCodingKeys.self)
        if decoderContainer.contains(.bulkItems)
        {
            self.bulkItems = try decoderContainer.decode([SubmitQualityDetectionJobRequestObject?]?.self, forKey: .bulkItems)
        }
    }
}
public extension BatchSubmitQualityDetectionJobsRequestObject{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: BatchSubmitQualityDetectionJobsRequestObjectCodingKeys.self)
         try encoderContainer.encode(bulkItems, forKey: .bulkItems)
    }
}
///  notifyConfig
public class NotifyConfig:NSObject,Codable{
    /// 回调ID
    var notifyId:Int64?
    /// 类型
    var type:Int?
    /// 回调开关
    var notifyFlag:Int?
    /// 回调地址
    var notifyUrl:String?
    /// 回调类型
    var callType:String?
    /// 回调关键值
    var notifyKey:String?
    /// 创建时间
    var createTime:String?
    /// 修改时间
    var updateTime:String?



    public override init(){
            super.init()
    }

    enum NotifyConfigCodingKeys: String, CodingKey {
        case notifyId
        case type
        case notifyFlag
        case notifyUrl
        case callType
        case notifyKey
        case createTime
        case updateTime
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: NotifyConfigCodingKeys.self)
        if decoderContainer.contains(.notifyId)
        {
            self.notifyId = try decoderContainer.decode(Int64?.self, forKey: .notifyId)
        }
        if decoderContainer.contains(.type)
        {
            self.type = try decoderContainer.decode(Int?.self, forKey: .type)
        }
        if decoderContainer.contains(.notifyFlag)
        {
            self.notifyFlag = try decoderContainer.decode(Int?.self, forKey: .notifyFlag)
        }
        if decoderContainer.contains(.notifyUrl)
        {
            self.notifyUrl = try decoderContainer.decode(String?.self, forKey: .notifyUrl)
        }
        if decoderContainer.contains(.callType)
        {
            self.callType = try decoderContainer.decode(String?.self, forKey: .callType)
        }
        if decoderContainer.contains(.notifyKey)
        {
            self.notifyKey = try decoderContainer.decode(String?.self, forKey: .notifyKey)
        }
        if decoderContainer.contains(.createTime)
        {
            self.createTime = try decoderContainer.decode(String?.self, forKey: .createTime)
        }
        if decoderContainer.contains(.updateTime)
        {
            self.updateTime = try decoderContainer.decode(String?.self, forKey: .updateTime)
        }
    }
}
public extension NotifyConfig{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: NotifyConfigCodingKeys.self)
         try encoderContainer.encode(notifyId, forKey: .notifyId)
         try encoderContainer.encode(type, forKey: .type)
         try encoderContainer.encode(notifyFlag, forKey: .notifyFlag)
         try encoderContainer.encode(notifyUrl, forKey: .notifyUrl)
         try encoderContainer.encode(callType, forKey: .callType)
         try encoderContainer.encode(notifyKey, forKey: .notifyKey)
         try encoderContainer.encode(createTime, forKey: .createTime)
         try encoderContainer.encode(updateTime, forKey: .updateTime)
    }
}
///  创建域名请求
public class CreateDomainRequestObject:NSObject,Codable{
    /// 域名名称
    /// Required:true
    var name:String



    public  init(name:String){
             self.name = name
    }

    enum CreateDomainRequestObjectCodingKeys: String, CodingKey {
        case name
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: CreateDomainRequestObjectCodingKeys.self)
        self.name = try decoderContainer.decode(String.self, forKey: .name)
    }
}
public extension CreateDomainRequestObject{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: CreateDomainRequestObjectCodingKeys.self)
         try encoderContainer.encode(name, forKey: .name)
    }
}
///  删除域名头参数请求
public class DeleteHeaderRequestObject:NSObject,Codable{
    /// 头参数名。当前支持的访问头参数取值范围：
      ///   Content-Disposition
      ///   Content-Language
      ///   Expires
      ///   Access-Control-Allow-Origin
      ///   Access-Control-Allow-Methods
      ///   Access-Control-Max-Age
      ///   Access-Control-Expose-Headers
      /// 
    /// Required:true
    var headerName:String
    /// 头参数类型，取值范围：req、resp
    /// Required:true
    var headerType:String



    public  init(headerName:String,headerType:String){
             self.headerName = headerName
             self.headerType = headerType
    }

    enum DeleteHeaderRequestObjectCodingKeys: String, CodingKey {
        case headerName
        case headerType
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: DeleteHeaderRequestObjectCodingKeys.self)
        self.headerName = try decoderContainer.decode(String.self, forKey: .headerName)
        self.headerType = try decoderContainer.decode(String.self, forKey: .headerType)
    }
}
public extension DeleteHeaderRequestObject{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: DeleteHeaderRequestObjectCodingKeys.self)
         try encoderContainer.encode(headerName, forKey: .headerName)
         try encoderContainer.encode(headerType, forKey: .headerType)
    }
}
///  校验域名结果
public class VerifyDomainResultObject:NSObject,Codable{
    /// 校验域名
    var domainName:String?
    /// 校验是否通过
    var verified:Bool?
    /// ICP备案信息
    var icpInfo:String?



    public override init(){
            super.init()
    }

    enum VerifyDomainResultObjectCodingKeys: String, CodingKey {
        case domainName
        case verified
        case icpInfo
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: VerifyDomainResultObjectCodingKeys.self)
        if decoderContainer.contains(.domainName)
        {
            self.domainName = try decoderContainer.decode(String?.self, forKey: .domainName)
        }
        if decoderContainer.contains(.verified)
        {
            self.verified = try decoderContainer.decode(Bool?.self, forKey: .verified)
        }
        if decoderContainer.contains(.icpInfo)
        {
            self.icpInfo = try decoderContainer.decode(String?.self, forKey: .icpInfo)
        }
    }
}
public extension VerifyDomainResultObject{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: VerifyDomainResultObjectCodingKeys.self)
         try encoderContainer.encode(domainName, forKey: .domainName)
         try encoderContainer.encode(verified, forKey: .verified)
         try encoderContainer.encode(icpInfo, forKey: .icpInfo)
    }
}
///  查询CDN域名URL鉴权规则配置结果
public class GetURLRuleResultObject:NSObject,Codable{
    /// 规则类型，取值 &#39;url&#39;
    var ruleType:String?
    /// URL鉴权规则配置对象
    var config:URLRuleConfigObject?
    /// 是否启用该规则
    var enabled:Bool?



    public override init(){
            super.init()
    }

    enum GetURLRuleResultObjectCodingKeys: String, CodingKey {
        case ruleType
        case config
        case enabled
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: GetURLRuleResultObjectCodingKeys.self)
        if decoderContainer.contains(.ruleType)
        {
            self.ruleType = try decoderContainer.decode(String?.self, forKey: .ruleType)
        }
        if decoderContainer.contains(.config)
        {
            self.config = try decoderContainer.decode(URLRuleConfigObject?.self, forKey: .config)
        }
        if decoderContainer.contains(.enabled)
        {
            self.enabled = try decoderContainer.decode(Bool?.self, forKey: .enabled)
        }
    }
}
public extension GetURLRuleResultObject{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: GetURLRuleResultObjectCodingKeys.self)
         try encoderContainer.encode(ruleType, forKey: .ruleType)
         try encoderContainer.encode(config, forKey: .config)
         try encoderContainer.encode(enabled, forKey: .enabled)
    }
}
///  设置CDN域名URL鉴权规则请求
public class SetURLRuleRequestObject:NSObject,Codable{
    /// URL鉴权规则配置对象
    /// Required:true
    var config:URLRuleConfigObject
    /// 是否启用该规则
    /// Required:true
    var enabled:Bool



    public  init(config:URLRuleConfigObject,enabled:Bool){
             self.config = config
             self.enabled = enabled
    }

    enum SetURLRuleRequestObjectCodingKeys: String, CodingKey {
        case config
        case enabled
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: SetURLRuleRequestObjectCodingKeys.self)
        self.config = try decoderContainer.decode(URLRuleConfigObject.self, forKey: .config)
        self.enabled = try decoderContainer.decode(Bool.self, forKey: .enabled)
    }
}
public extension SetURLRuleRequestObject{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: SetURLRuleRequestObjectCodingKeys.self)
         try encoderContainer.encode(config, forKey: .config)
         try encoderContainer.encode(enabled, forKey: .enabled)
    }
}
///  添加域名头参数请求
public class GetHeaderResultObject:NSObject,Codable{
    /// 头参数名
    var headerName:String?
    /// 头参数值
    var headerValue:String?
    /// 头参数类型，取值范围：req、resp
    var headerType:String?



    public override init(){
            super.init()
    }

    enum GetHeaderResultObjectCodingKeys: String, CodingKey {
        case headerName
        case headerValue
        case headerType
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: GetHeaderResultObjectCodingKeys.self)
        if decoderContainer.contains(.headerName)
        {
            self.headerName = try decoderContainer.decode(String?.self, forKey: .headerName)
        }
        if decoderContainer.contains(.headerValue)
        {
            self.headerValue = try decoderContainer.decode(String?.self, forKey: .headerValue)
        }
        if decoderContainer.contains(.headerType)
        {
            self.headerType = try decoderContainer.decode(String?.self, forKey: .headerType)
        }
    }
}
public extension GetHeaderResultObject{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: GetHeaderResultObjectCodingKeys.self)
         try encoderContainer.encode(headerName, forKey: .headerName)
         try encoderContainer.encode(headerValue, forKey: .headerValue)
         try encoderContainer.encode(headerType, forKey: .headerType)
    }
}
///  设置CDN域名SSL配置
public class SetHttpSslRequestObject:NSObject,Codable{
    /// 证书来源。取值范围：default
    var source:String?
    /// 证书标题
    var title:String?
    /// 证书内容
    var sslCert:String?
    /// 证书私钥
    var sslKey:String?
    /// 跳转类型。取值范围：
      /// default - 采用回源域名的默认协议
      /// http - 强制采用http协议回源
      /// https - 强制采用https协议回源
      /// 
    var jumpType:String?
    /// SSL配置启用状态
    var enabled:Bool?



    public override init(){
            super.init()
    }

    enum SetHttpSslRequestObjectCodingKeys: String, CodingKey {
        case source
        case title
        case sslCert
        case sslKey
        case jumpType
        case enabled
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: SetHttpSslRequestObjectCodingKeys.self)
        if decoderContainer.contains(.source)
        {
            self.source = try decoderContainer.decode(String?.self, forKey: .source)
        }
        if decoderContainer.contains(.title)
        {
            self.title = try decoderContainer.decode(String?.self, forKey: .title)
        }
        if decoderContainer.contains(.sslCert)
        {
            self.sslCert = try decoderContainer.decode(String?.self, forKey: .sslCert)
        }
        if decoderContainer.contains(.sslKey)
        {
            self.sslKey = try decoderContainer.decode(String?.self, forKey: .sslKey)
        }
        if decoderContainer.contains(.jumpType)
        {
            self.jumpType = try decoderContainer.decode(String?.self, forKey: .jumpType)
        }
        if decoderContainer.contains(.enabled)
        {
            self.enabled = try decoderContainer.decode(Bool?.self, forKey: .enabled)
        }
    }
}
public extension SetHttpSslRequestObject{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: SetHttpSslRequestObjectCodingKeys.self)
         try encoderContainer.encode(source, forKey: .source)
         try encoderContainer.encode(title, forKey: .title)
         try encoderContainer.encode(sslCert, forKey: .sslCert)
         try encoderContainer.encode(sslKey, forKey: .sslKey)
         try encoderContainer.encode(jumpType, forKey: .jumpType)
         try encoderContainer.encode(enabled, forKey: .enabled)
    }
}
///  设置域名头参数请求
public class SetHeaderRequestObject:NSObject,Codable{
    /// 头参数名。当前支持的访问头参数取值范围：
      ///   Content-Disposition
      ///   Content-Language
      ///   Expires
      ///   Access-Control-Allow-Origin
      ///   Access-Control-Allow-Methods
      ///   Access-Control-Max-Age
      ///   Access-Control-Expose-Headers
      /// 
    /// Required:true
    var headerName:String
    /// 头参数值
    /// Required:true
    var headerValue:String
    /// 头参数类型，取值范围：req、resp
    /// Required:true
    var headerType:String



    public  init(headerName:String,headerValue:String,headerType:String){
             self.headerName = headerName
             self.headerValue = headerValue
             self.headerType = headerType
    }

    enum SetHeaderRequestObjectCodingKeys: String, CodingKey {
        case headerName
        case headerValue
        case headerType
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: SetHeaderRequestObjectCodingKeys.self)
        self.headerName = try decoderContainer.decode(String.self, forKey: .headerName)
        self.headerValue = try decoderContainer.decode(String.self, forKey: .headerValue)
        self.headerType = try decoderContainer.decode(String.self, forKey: .headerType)
    }
}
public extension SetHeaderRequestObject{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: SetHeaderRequestObjectCodingKeys.self)
         try encoderContainer.encode(headerName, forKey: .headerName)
         try encoderContainer.encode(headerValue, forKey: .headerValue)
         try encoderContainer.encode(headerType, forKey: .headerType)
    }
}
///  查询域名列表信息结果
public class ListDomainsResultObject:NSObject,Codable{
    /// 当前页码
    var pageNumber:Int?
    /// 每页数量
    var pageSize:Int?
    /// 查询总数
    var totalElements:Int?
    /// 总页数
    var totalPages:Int?
    /// 分页内容
    var content:[DomainObject?]?



    public override init(){
            super.init()
    }

    enum ListDomainsResultObjectCodingKeys: String, CodingKey {
        case pageNumber
        case pageSize
        case totalElements
        case totalPages
        case content
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: ListDomainsResultObjectCodingKeys.self)
        if decoderContainer.contains(.pageNumber)
        {
            self.pageNumber = try decoderContainer.decode(Int?.self, forKey: .pageNumber)
        }
        if decoderContainer.contains(.pageSize)
        {
            self.pageSize = try decoderContainer.decode(Int?.self, forKey: .pageSize)
        }
        if decoderContainer.contains(.totalElements)
        {
            self.totalElements = try decoderContainer.decode(Int?.self, forKey: .totalElements)
        }
        if decoderContainer.contains(.totalPages)
        {
            self.totalPages = try decoderContainer.decode(Int?.self, forKey: .totalPages)
        }
        if decoderContainer.contains(.content)
        {
            self.content = try decoderContainer.decode([DomainObject?]?.self, forKey: .content)
        }
    }
}
public extension ListDomainsResultObject{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: ListDomainsResultObjectCodingKeys.self)
         try encoderContainer.encode(pageNumber, forKey: .pageNumber)
         try encoderContainer.encode(pageSize, forKey: .pageSize)
         try encoderContainer.encode(totalElements, forKey: .totalElements)
         try encoderContainer.encode(totalPages, forKey: .totalPages)
         try encoderContainer.encode(content, forKey: .content)
    }
}
///  查询CDN域名SSL配置
public class GetHttpSslResultObject:NSObject,Codable{
    /// 证书来源。取值范围：default
    var source:String?
    /// 证书标题
    var title:String?
    /// 证书内容
    var sslCert:String?
    /// 证书私钥
    var sslKey:String?
    /// 跳转类型。取值范围：
      /// default - 采用回源域名的默认协议
      /// http - 强制采用http协议回源
      /// https - 强制采用https协议回源
      /// 
    var jumpType:String?
    /// SSL配置启用状态
    var enabled:Bool?



    public override init(){
            super.init()
    }

    enum GetHttpSslResultObjectCodingKeys: String, CodingKey {
        case source
        case title
        case sslCert
        case sslKey
        case jumpType
        case enabled
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: GetHttpSslResultObjectCodingKeys.self)
        if decoderContainer.contains(.source)
        {
            self.source = try decoderContainer.decode(String?.self, forKey: .source)
        }
        if decoderContainer.contains(.title)
        {
            self.title = try decoderContainer.decode(String?.self, forKey: .title)
        }
        if decoderContainer.contains(.sslCert)
        {
            self.sslCert = try decoderContainer.decode(String?.self, forKey: .sslCert)
        }
        if decoderContainer.contains(.sslKey)
        {
            self.sslKey = try decoderContainer.decode(String?.self, forKey: .sslKey)
        }
        if decoderContainer.contains(.jumpType)
        {
            self.jumpType = try decoderContainer.decode(String?.self, forKey: .jumpType)
        }
        if decoderContainer.contains(.enabled)
        {
            self.enabled = try decoderContainer.decode(Bool?.self, forKey: .enabled)
        }
    }
}
public extension GetHttpSslResultObject{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: GetHttpSslResultObjectCodingKeys.self)
         try encoderContainer.encode(source, forKey: .source)
         try encoderContainer.encode(title, forKey: .title)
         try encoderContainer.encode(sslCert, forKey: .sslCert)
         try encoderContainer.encode(sslKey, forKey: .sslKey)
         try encoderContainer.encode(jumpType, forKey: .jumpType)
         try encoderContainer.encode(enabled, forKey: .enabled)
    }
}
///  查询域名响应信息
public class DomainObject:NSObject,Codable{
    /// 域名ID
    var id:String?
    /// 域名名称
    var name:String?
    /// 域名CNAME
    var cname:String?
    /// 域名状态。取值范围：
      ///   init - 初始状态
      ///   configuring - 配置中
      ///   normal - 正常
      ///   stopped - 已停用
      /// 
    var status:String?
    /// 域名来源。取值范围：
      ///   system - 系统生成
      ///   custom - 用户自建
      /// 
    var source:String?
    /// 是否默认域名
    var asDefault:Bool?
    /// 创建时间
    var createTime:String?
    /// 修改时间
    var updateTime:String?



    public override init(){
            super.init()
    }

    enum DomainObjectCodingKeys: String, CodingKey {
        case id
        case name
        case cname
        case status
        case source
        case asDefault
        case createTime
        case updateTime
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: DomainObjectCodingKeys.self)
        if decoderContainer.contains(.id)
        {
            self.id = try decoderContainer.decode(String?.self, forKey: .id)
        }
        if decoderContainer.contains(.name)
        {
            self.name = try decoderContainer.decode(String?.self, forKey: .name)
        }
        if decoderContainer.contains(.cname)
        {
            self.cname = try decoderContainer.decode(String?.self, forKey: .cname)
        }
        if decoderContainer.contains(.status)
        {
            self.status = try decoderContainer.decode(String?.self, forKey: .status)
        }
        if decoderContainer.contains(.source)
        {
            self.source = try decoderContainer.decode(String?.self, forKey: .source)
        }
        if decoderContainer.contains(.asDefault)
        {
            self.asDefault = try decoderContainer.decode(Bool?.self, forKey: .asDefault)
        }
        if decoderContainer.contains(.createTime)
        {
            self.createTime = try decoderContainer.decode(String?.self, forKey: .createTime)
        }
        if decoderContainer.contains(.updateTime)
        {
            self.updateTime = try decoderContainer.decode(String?.self, forKey: .updateTime)
        }
    }
}
public extension DomainObject{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: DomainObjectCodingKeys.self)
         try encoderContainer.encode(id, forKey: .id)
         try encoderContainer.encode(name, forKey: .name)
         try encoderContainer.encode(cname, forKey: .cname)
         try encoderContainer.encode(status, forKey: .status)
         try encoderContainer.encode(source, forKey: .source)
         try encoderContainer.encode(asDefault, forKey: .asDefault)
         try encoderContainer.encode(createTime, forKey: .createTime)
         try encoderContainer.encode(updateTime, forKey: .updateTime)
    }
}
///  设置CDN域名IP黑名单规则请求
public class SetIPRuleRequestObject:NSObject,Codable{
    /// IP黑名单规则配置对象
    /// Required:true
    var config:IPRuleConfigObject
    /// 是否启用该规则
    /// Required:true
    var enabled:Bool



    public  init(config:IPRuleConfigObject,enabled:Bool){
             self.config = config
             self.enabled = enabled
    }

    enum SetIPRuleRequestObjectCodingKeys: String, CodingKey {
        case config
        case enabled
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: SetIPRuleRequestObjectCodingKeys.self)
        self.config = try decoderContainer.decode(IPRuleConfigObject.self, forKey: .config)
        self.enabled = try decoderContainer.decode(Bool.self, forKey: .enabled)
    }
}
public extension SetIPRuleRequestObject{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: SetIPRuleRequestObjectCodingKeys.self)
         try encoderContainer.encode(config, forKey: .config)
         try encoderContainer.encode(enabled, forKey: .enabled)
    }
}
///  IP黑名单规则配置对象
public class IPRuleConfigObject:NSObject,Codable{
    /// IP黑名单列表
    /// Required:true
    var ips:[String?]?



    public  init(ips:[String?]?){
             self.ips = ips
    }

    enum IPRuleConfigObjectCodingKeys: String, CodingKey {
        case ips
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: IPRuleConfigObjectCodingKeys.self)
        self.ips = try decoderContainer.decode([String?]?.self, forKey: .ips)
    }
}
public extension IPRuleConfigObject{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: IPRuleConfigObjectCodingKeys.self)
         try encoderContainer.encode(ips, forKey: .ips)
    }
}
///  设置CDN域名Referer防盗链规则请求
public class SetRefererRuleRequestObject:NSObject,Codable{
    /// Referer防盗链规则配置对象
    /// Required:true
    var config:RefererRuleConfigObject
    /// 是否启用该规则
    /// Required:true
    var enabled:Bool



    public  init(config:RefererRuleConfigObject,enabled:Bool){
             self.config = config
             self.enabled = enabled
    }

    enum SetRefererRuleRequestObjectCodingKeys: String, CodingKey {
        case config
        case enabled
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: SetRefererRuleRequestObjectCodingKeys.self)
        self.config = try decoderContainer.decode(RefererRuleConfigObject.self, forKey: .config)
        self.enabled = try decoderContainer.decode(Bool.self, forKey: .enabled)
    }
}
public extension SetRefererRuleRequestObject{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: SetRefererRuleRequestObjectCodingKeys.self)
         try encoderContainer.encode(config, forKey: .config)
         try encoderContainer.encode(enabled, forKey: .enabled)
    }
}
///  获取全类型域名访问控制规则配置响应消息体
public class GetAllTypeRuleResultObject:NSObject,Codable{
    /// Referer
    var referer:GetRefererRuleResultObject?
    /// Url
    var url:GetURLRuleResultObject?
    /// Ip
    var ip:GetIPRuleResultObject?



    public override init(){
            super.init()
    }

    enum GetAllTypeRuleResultObjectCodingKeys: String, CodingKey {
        case referer
        case url
        case ip
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: GetAllTypeRuleResultObjectCodingKeys.self)
        if decoderContainer.contains(.referer)
        {
            self.referer = try decoderContainer.decode(GetRefererRuleResultObject?.self, forKey: .referer)
        }
        if decoderContainer.contains(.url)
        {
            self.url = try decoderContainer.decode(GetURLRuleResultObject?.self, forKey: .url)
        }
        if decoderContainer.contains(.ip)
        {
            self.ip = try decoderContainer.decode(GetIPRuleResultObject?.self, forKey: .ip)
        }
    }
}
public extension GetAllTypeRuleResultObject{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: GetAllTypeRuleResultObjectCodingKeys.self)
         try encoderContainer.encode(referer, forKey: .referer)
         try encoderContainer.encode(url, forKey: .url)
         try encoderContainer.encode(ip, forKey: .ip)
    }
}
///  sort
public class Sort:NSObject,Codable{
    /// 排序属性名
    var name:String?
    /// 排序方向
    var direction:String?



    public override init(){
            super.init()
    }

    enum SortCodingKeys: String, CodingKey {
        case name
        case direction
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: SortCodingKeys.self)
        if decoderContainer.contains(.name)
        {
            self.name = try decoderContainer.decode(String?.self, forKey: .name)
        }
        if decoderContainer.contains(.direction)
        {
            self.direction = try decoderContainer.decode(String?.self, forKey: .direction)
        }
    }
}
public extension Sort{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: SortCodingKeys.self)
         try encoderContainer.encode(name, forKey: .name)
         try encoderContainer.encode(direction, forKey: .direction)
    }
}
///  查询CDN域名IP黑名单规则配置
public class GetIPRuleResultObject:NSObject,Codable{
    /// 规则类型，取值 &#39;ip&#39;
    var ruleType:String?
    /// IP黑名单规则配置对象
    var config:IPRuleConfigObject?
    /// 是否启用该规则
    var enabled:Bool?



    public override init(){
            super.init()
    }

    enum GetIPRuleResultObjectCodingKeys: String, CodingKey {
        case ruleType
        case config
        case enabled
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: GetIPRuleResultObjectCodingKeys.self)
        if decoderContainer.contains(.ruleType)
        {
            self.ruleType = try decoderContainer.decode(String?.self, forKey: .ruleType)
        }
        if decoderContainer.contains(.config)
        {
            self.config = try decoderContainer.decode(IPRuleConfigObject?.self, forKey: .config)
        }
        if decoderContainer.contains(.enabled)
        {
            self.enabled = try decoderContainer.decode(Bool?.self, forKey: .enabled)
        }
    }
}
public extension GetIPRuleResultObject{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: GetIPRuleResultObjectCodingKeys.self)
         try encoderContainer.encode(ruleType, forKey: .ruleType)
         try encoderContainer.encode(config, forKey: .config)
         try encoderContainer.encode(enabled, forKey: .enabled)
    }
}
///  查询域名头参数列表结果
public class ListHeadersResultObject:NSObject,Codable{
    /// 头参数列表
    var headers:[GetHeaderResultObject?]?



    public override init(){
            super.init()
    }

    enum ListHeadersResultObjectCodingKeys: String, CodingKey {
        case headers
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: ListHeadersResultObjectCodingKeys.self)
        if decoderContainer.contains(.headers)
        {
            self.headers = try decoderContainer.decode([GetHeaderResultObject?]?.self, forKey: .headers)
        }
    }
}
public extension ListHeadersResultObject{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: ListHeadersResultObjectCodingKeys.self)
         try encoderContainer.encode(headers, forKey: .headers)
    }
}
///  Referer防盗链规则配置对象
public class RefererRuleConfigObject:NSObject,Codable{
    /// 启用策略。取值范围：
      ///   denial - 拒绝
      ///   allowance - 允许
      /// 
    /// Required:true
    var strategy:String
    /// Referer域名列表
    /// Required:true
    var domains:[String?]?
    /// 是否允许请求头 Referer 为空，如允许浏览器直接访问等
    /// Required:true
    var allowBlank:Bool



    public  init(strategy:String,domains:[String?]?,allowBlank:Bool){
             self.strategy = strategy
             self.domains = domains
             self.allowBlank = allowBlank
    }

    enum RefererRuleConfigObjectCodingKeys: String, CodingKey {
        case strategy
        case domains
        case allowBlank
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: RefererRuleConfigObjectCodingKeys.self)
        self.strategy = try decoderContainer.decode(String.self, forKey: .strategy)
        self.domains = try decoderContainer.decode([String?]?.self, forKey: .domains)
        self.allowBlank = try decoderContainer.decode(Bool.self, forKey: .allowBlank)
    }
}
public extension RefererRuleConfigObject{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: RefererRuleConfigObjectCodingKeys.self)
         try encoderContainer.encode(strategy, forKey: .strategy)
         try encoderContainer.encode(domains, forKey: .domains)
         try encoderContainer.encode(allowBlank, forKey: .allowBlank)
    }
}
///  查询CDN域名Referer防盗链规则配置结果
public class GetRefererRuleResultObject:NSObject,Codable{
    /// 规则类型，取值 &#39;referer&#39;
    var ruleType:String?
    /// Referer防盗链规则配置对象
    var config:RefererRuleConfigObject?
    /// 是否启用该规则
    var enabled:Bool?



    public override init(){
            super.init()
    }

    enum GetRefererRuleResultObjectCodingKeys: String, CodingKey {
        case ruleType
        case config
        case enabled
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: GetRefererRuleResultObjectCodingKeys.self)
        if decoderContainer.contains(.ruleType)
        {
            self.ruleType = try decoderContainer.decode(String?.self, forKey: .ruleType)
        }
        if decoderContainer.contains(.config)
        {
            self.config = try decoderContainer.decode(RefererRuleConfigObject?.self, forKey: .config)
        }
        if decoderContainer.contains(.enabled)
        {
            self.enabled = try decoderContainer.decode(Bool?.self, forKey: .enabled)
        }
    }
}
public extension GetRefererRuleResultObject{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: GetRefererRuleResultObjectCodingKeys.self)
         try encoderContainer.encode(ruleType, forKey: .ruleType)
         try encoderContainer.encode(config, forKey: .config)
         try encoderContainer.encode(enabled, forKey: .enabled)
    }
}
///  URL鉴权规则配置对象
public class URLRuleConfigObject:NSObject,Codable{
    /// 鉴权类型。取值范围：
      ///   by_params - 参数鉴权
      ///   by_path - 路径鉴权
      /// 
    /// Required:true
    var authType:String
    /// 鉴权密钥
    /// Required:true
    var authKey:String



    public  init(authType:String,authKey:String){
             self.authType = authType
             self.authKey = authKey
    }

    enum URLRuleConfigObjectCodingKeys: String, CodingKey {
        case authType
        case authKey
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: URLRuleConfigObjectCodingKeys.self)
        self.authType = try decoderContainer.decode(String.self, forKey: .authType)
        self.authKey = try decoderContainer.decode(String.self, forKey: .authKey)
    }
}
public extension URLRuleConfigObject{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: URLRuleConfigObjectCodingKeys.self)
         try encoderContainer.encode(authType, forKey: .authType)
         try encoderContainer.encode(authKey, forKey: .authKey)
    }
}
///  uploadCallbackReq
public class UploadCallbackReq:NSObject,Codable{
    /// 上传状态
    var status:Int?
    /// 视频名称
    var name:String?
    /// 格式
    var format:String?
    /// 文件大小
    var size:Int64?
    /// 分类ID
    var categoryId:Int64?
    /// 转码模板ID，多个时以逗号分隔
    var coderateId:String?
    /// 水印ID，多个时以逗号分隔
    var logoId:String?
    /// 下载地址
    var url:String?
    /// 存储节点域名
    var endpoint:String?
    /// 存储桶名称
    var bucket:String?



    public override init(){
            super.init()
    }

    enum UploadCallbackReqCodingKeys: String, CodingKey {
        case status
        case name
        case format
        case size
        case categoryId
        case coderateId
        case logoId
        case url
        case endpoint
        case bucket
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: UploadCallbackReqCodingKeys.self)
        if decoderContainer.contains(.status)
        {
            self.status = try decoderContainer.decode(Int?.self, forKey: .status)
        }
        if decoderContainer.contains(.name)
        {
            self.name = try decoderContainer.decode(String?.self, forKey: .name)
        }
        if decoderContainer.contains(.format)
        {
            self.format = try decoderContainer.decode(String?.self, forKey: .format)
        }
        if decoderContainer.contains(.size)
        {
            self.size = try decoderContainer.decode(Int64?.self, forKey: .size)
        }
        if decoderContainer.contains(.categoryId)
        {
            self.categoryId = try decoderContainer.decode(Int64?.self, forKey: .categoryId)
        }
        if decoderContainer.contains(.coderateId)
        {
            self.coderateId = try decoderContainer.decode(String?.self, forKey: .coderateId)
        }
        if decoderContainer.contains(.logoId)
        {
            self.logoId = try decoderContainer.decode(String?.self, forKey: .logoId)
        }
        if decoderContainer.contains(.url)
        {
            self.url = try decoderContainer.decode(String?.self, forKey: .url)
        }
        if decoderContainer.contains(.endpoint)
        {
            self.endpoint = try decoderContainer.decode(String?.self, forKey: .endpoint)
        }
        if decoderContainer.contains(.bucket)
        {
            self.bucket = try decoderContainer.decode(String?.self, forKey: .bucket)
        }
    }
}
public extension UploadCallbackReq{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: UploadCallbackReqCodingKeys.self)
         try encoderContainer.encode(status, forKey: .status)
         try encoderContainer.encode(name, forKey: .name)
         try encoderContainer.encode(format, forKey: .format)
         try encoderContainer.encode(size, forKey: .size)
         try encoderContainer.encode(categoryId, forKey: .categoryId)
         try encoderContainer.encode(coderateId, forKey: .coderateId)
         try encoderContainer.encode(logoId, forKey: .logoId)
         try encoderContainer.encode(url, forKey: .url)
         try encoderContainer.encode(endpoint, forKey: .endpoint)
         try encoderContainer.encode(bucket, forKey: .bucket)
    }
}
///  uploadCallbackResp
public class UploadCallbackResp:NSObject,Codable{
    /// 媒资ID
    var mid:String?



    public override init(){
            super.init()
    }

    enum UploadCallbackRespCodingKeys: String, CodingKey {
        case mid
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: UploadCallbackRespCodingKeys.self)
        if decoderContainer.contains(.mid)
        {
            self.mid = try decoderContainer.decode(String?.self, forKey: .mid)
        }
    }
}
public extension UploadCallbackResp{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: UploadCallbackRespCodingKeys.self)
         try encoderContainer.encode(mid, forKey: .mid)
    }
}
///  质检模板
public class QualityDetectionTemplateObject:NSObject,Codable{
    /// 模板ID
    var id:Int64?
    /// 模板名称。长度不超过128个字符。UTF-8编码。
      /// 
    var name:String?
    /// 模板类型，区分该模板的检测内容。目前只支持 video 。
    var templateType:String?
    /// 检测项列表。取值范围：
      ///   blackScreen - 黑场
      ///   pureColor - 纯色
      ///   colorCast - 偏色
      ///   frozenFrame - 静帧
      ///   brightness - 亮度
      ///   contrast - 对比度
      /// 
    var detections:[String?]?
    /// 创建时间
    var createTime:String?
    /// 修改时间
    var updateTime:String?



    public override init(){
            super.init()
    }

    enum QualityDetectionTemplateObjectCodingKeys: String, CodingKey {
        case id
        case name
        case templateType
        case detections
        case createTime
        case updateTime
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: QualityDetectionTemplateObjectCodingKeys.self)
        if decoderContainer.contains(.id)
        {
            self.id = try decoderContainer.decode(Int64?.self, forKey: .id)
        }
        if decoderContainer.contains(.name)
        {
            self.name = try decoderContainer.decode(String?.self, forKey: .name)
        }
        if decoderContainer.contains(.templateType)
        {
            self.templateType = try decoderContainer.decode(String?.self, forKey: .templateType)
        }
        if decoderContainer.contains(.detections)
        {
            self.detections = try decoderContainer.decode([String?]?.self, forKey: .detections)
        }
        if decoderContainer.contains(.createTime)
        {
            self.createTime = try decoderContainer.decode(String?.self, forKey: .createTime)
        }
        if decoderContainer.contains(.updateTime)
        {
            self.updateTime = try decoderContainer.decode(String?.self, forKey: .updateTime)
        }
    }
}
public extension QualityDetectionTemplateObject{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: QualityDetectionTemplateObjectCodingKeys.self)
         try encoderContainer.encode(id, forKey: .id)
         try encoderContainer.encode(name, forKey: .name)
         try encoderContainer.encode(templateType, forKey: .templateType)
         try encoderContainer.encode(detections, forKey: .detections)
         try encoderContainer.encode(createTime, forKey: .createTime)
         try encoderContainer.encode(updateTime, forKey: .updateTime)
    }
}
///  修改质检模板请求信息
public class UpdateQualityDetectionTemplateRequestObject:NSObject,Codable{
    /// 模板名称。长度不超过128个字符。UTF-8编码。
      /// 
    var name:String?
    /// 检测项列表。取值范围：
      ///   blackScreen - 黑场
      ///   pureColor - 纯色
      ///   colorCast - 偏色
      ///   frozenFrame - 静帧
      ///   brightness - 亮度
      ///   contrast - 对比度
      /// 
    var detections:[String?]?



    public override init(){
            super.init()
    }

    enum UpdateQualityDetectionTemplateRequestObjectCodingKeys: String, CodingKey {
        case name
        case detections
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: UpdateQualityDetectionTemplateRequestObjectCodingKeys.self)
        if decoderContainer.contains(.name)
        {
            self.name = try decoderContainer.decode(String?.self, forKey: .name)
        }
        if decoderContainer.contains(.detections)
        {
            self.detections = try decoderContainer.decode([String?]?.self, forKey: .detections)
        }
    }
}
public extension UpdateQualityDetectionTemplateRequestObject{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: UpdateQualityDetectionTemplateRequestObjectCodingKeys.self)
         try encoderContainer.encode(name, forKey: .name)
         try encoderContainer.encode(detections, forKey: .detections)
    }
}
///  查询质检模板列表结果信息
public class ListQualityDetectionTemplatesResultObject:NSObject,Codable{
    /// 当前页码
    var pageNumber:Int?
    /// 每页数量
    var pageSize:Int?
    /// 查询总数
    var totalElements:Int?
    /// 总页数
    var totalPages:Int?
    /// 分页内容
    var content:[QualityDetectionTemplateObject?]?



    public override init(){
            super.init()
    }

    enum ListQualityDetectionTemplatesResultObjectCodingKeys: String, CodingKey {
        case pageNumber
        case pageSize
        case totalElements
        case totalPages
        case content
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: ListQualityDetectionTemplatesResultObjectCodingKeys.self)
        if decoderContainer.contains(.pageNumber)
        {
            self.pageNumber = try decoderContainer.decode(Int?.self, forKey: .pageNumber)
        }
        if decoderContainer.contains(.pageSize)
        {
            self.pageSize = try decoderContainer.decode(Int?.self, forKey: .pageSize)
        }
        if decoderContainer.contains(.totalElements)
        {
            self.totalElements = try decoderContainer.decode(Int?.self, forKey: .totalElements)
        }
        if decoderContainer.contains(.totalPages)
        {
            self.totalPages = try decoderContainer.decode(Int?.self, forKey: .totalPages)
        }
        if decoderContainer.contains(.content)
        {
            self.content = try decoderContainer.decode([QualityDetectionTemplateObject?]?.self, forKey: .content)
        }
    }
}
public extension ListQualityDetectionTemplatesResultObject{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: ListQualityDetectionTemplatesResultObjectCodingKeys.self)
         try encoderContainer.encode(pageNumber, forKey: .pageNumber)
         try encoderContainer.encode(pageSize, forKey: .pageSize)
         try encoderContainer.encode(totalElements, forKey: .totalElements)
         try encoderContainer.encode(totalPages, forKey: .totalPages)
         try encoderContainer.encode(content, forKey: .content)
    }
}
///  创建质检模板请求信息
public class CreateQualityDetectionTemplateRequestObject:NSObject,Codable{
    /// 模板名称。长度不超过128个字符。UTF-8编码。
      /// 
    /// Required:true
    var name:String
    /// 模板类型，区分该模板的检测内容。目前只支持 video 。
    /// Required:true
    var templateType:String
    /// 检测项列表。取值范围：
      ///   blackScreen - 黑场
      ///   pureColor - 纯色
      ///   colorCast - 偏色
      ///   frozenFrame - 静帧
      ///   brightness - 亮度
      ///   contrast - 对比度
      /// 
    /// Required:true
    var detections:[String?]?



    public  init(name:String,templateType:String,detections:[String?]?){
             self.name = name
             self.templateType = templateType
             self.detections = detections
    }

    enum CreateQualityDetectionTemplateRequestObjectCodingKeys: String, CodingKey {
        case name
        case templateType
        case detections
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: CreateQualityDetectionTemplateRequestObjectCodingKeys.self)
        self.name = try decoderContainer.decode(String.self, forKey: .name)
        self.templateType = try decoderContainer.decode(String.self, forKey: .templateType)
        self.detections = try decoderContainer.decode([String?]?.self, forKey: .detections)
    }
}
public extension CreateQualityDetectionTemplateRequestObject{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: CreateQualityDetectionTemplateRequestObjectCodingKeys.self)
         try encoderContainer.encode(name, forKey: .name)
         try encoderContainer.encode(templateType, forKey: .templateType)
         try encoderContainer.encode(detections, forKey: .detections)
    }
}
///  查询CDN统计基础数据返回结果
public class QueryCDNBasicDataResultObject:NSObject,Codable{
    /// Isps
    var isps:[BasicItem?]?
    /// Areas
    var areas:Areas?



    public override init(){
            super.init()
    }

    enum QueryCDNBasicDataResultObjectCodingKeys: String, CodingKey {
        case isps
        case areas
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: QueryCDNBasicDataResultObjectCodingKeys.self)
        if decoderContainer.contains(.isps)
        {
            self.isps = try decoderContainer.decode([BasicItem?]?.self, forKey: .isps)
        }
        if decoderContainer.contains(.areas)
        {
            self.areas = try decoderContainer.decode(Areas?.self, forKey: .areas)
        }
    }
}
public extension QueryCDNBasicDataResultObject{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: QueryCDNBasicDataResultObjectCodingKeys.self)
         try encoderContainer.encode(isps, forKey: .isps)
         try encoderContainer.encode(areas, forKey: .areas)
    }
}
///  dataItem
public class DataItem:NSObject,Codable{
    /// StartTime
    var startTime:String?
    /// EndTime
    var endTime:String?
    /// Data
    var data:AnyObject?



    public override init(){
            super.init()
    }

    enum DataItemCodingKeys: String, CodingKey {
        case startTime
        case endTime
        case data
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: DataItemCodingKeys.self)
        if decoderContainer.contains(.startTime)
        {
            self.startTime = try decoderContainer.decode(String?.self, forKey: .startTime)
        }
        if decoderContainer.contains(.endTime)
        {
            self.endTime = try decoderContainer.decode(String?.self, forKey: .endTime)
        }
    }
}
public extension DataItem{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: DataItemCodingKeys.self)
         try encoderContainer.encode(startTime, forKey: .startTime)
         try encoderContainer.encode(endTime, forKey: .endTime)
    }
}
///  basicItem
public class BasicItem:NSObject,Codable{
    /// Code
    var code:String?
    /// Description
    var descriptionValue:String?



    public override init(){
            super.init()
    }

    enum BasicItemCodingKeys: String, CodingKey {
        case code
        case descriptionValue = "description"
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: BasicItemCodingKeys.self)
        if decoderContainer.contains(.code)
        {
            self.code = try decoderContainer.decode(String?.self, forKey: .code)
        }
        if decoderContainer.contains(.descriptionValue)
        {
            self.descriptionValue = try decoderContainer.decode(String?.self, forKey: .descriptionValue)
        }
    }
}
public extension BasicItem{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: BasicItemCodingKeys.self)
         try encoderContainer.encode(code, forKey: .code)
         try encoderContainer.encode(descriptionValue, forKey: .descriptionValue)
    }
}
///  查询CDN统计数据返回结果
public class QueryCDNStatsDataResultObject:NSObject,Codable{
    /// StartTime
    var startTime:String?
    /// EndTime
    var endTime:String?
    /// Data
    var data:[DataItem?]?



    public override init(){
            super.init()
    }

    enum QueryCDNStatsDataResultObjectCodingKeys: String, CodingKey {
        case startTime
        case endTime
        case data
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: QueryCDNStatsDataResultObjectCodingKeys.self)
        if decoderContainer.contains(.startTime)
        {
            self.startTime = try decoderContainer.decode(String?.self, forKey: .startTime)
        }
        if decoderContainer.contains(.endTime)
        {
            self.endTime = try decoderContainer.decode(String?.self, forKey: .endTime)
        }
        if decoderContainer.contains(.data)
        {
            self.data = try decoderContainer.decode([DataItem?]?.self, forKey: .data)
        }
    }
}
public extension QueryCDNStatsDataResultObject{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: QueryCDNStatsDataResultObjectCodingKeys.self)
         try encoderContainer.encode(startTime, forKey: .startTime)
         try encoderContainer.encode(endTime, forKey: .endTime)
         try encoderContainer.encode(data, forKey: .data)
    }
}
///  filter
public class Filter:NSObject,Codable{
    /// 过滤器属性名
    /// Required:true
    var name:String
    /// 过滤器操作符，默认值为 eq
    var operatorValue:String?
    /// 过滤器属性值
    /// Required:true
    var values:[String?]?



    public  init(name:String,values:[String?]?){
             self.name = name
             self.values = values
    }

    enum FilterCodingKeys: String, CodingKey {
        case name
        case operatorValue = "operator"
        case values
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: FilterCodingKeys.self)
        self.name = try decoderContainer.decode(String.self, forKey: .name)
        if decoderContainer.contains(.operatorValue)
        {
            self.operatorValue = try decoderContainer.decode(String?.self, forKey: .operatorValue)
        }
        self.values = try decoderContainer.decode([String?]?.self, forKey: .values)
    }
}
public extension Filter{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: FilterCodingKeys.self)
         try encoderContainer.encode(name, forKey: .name)
         try encoderContainer.encode(operatorValue, forKey: .operatorValue)
         try encoderContainer.encode(values, forKey: .values)
    }
}
///  task
public class Task:NSObject,Codable{
    /// 任务ID
    var taskId:Int64?
    /// 视频名称
    var name:String?
    /// 分类ID
    var categoryId:Double?
    /// 分类名称
    var category:String?
    /// 格式
    var format:String?
    /// 文件大小
    var size:Double?
    /// 上传状态
    var status:Int?



    public override init(){
            super.init()
    }

    enum TaskCodingKeys: String, CodingKey {
        case taskId
        case name
        case categoryId
        case category
        case format
        case size
        case status
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: TaskCodingKeys.self)
        if decoderContainer.contains(.taskId)
        {
            self.taskId = try decoderContainer.decode(Int64?.self, forKey: .taskId)
        }
        if decoderContainer.contains(.name)
        {
            self.name = try decoderContainer.decode(String?.self, forKey: .name)
        }
        if decoderContainer.contains(.categoryId)
        {
            self.categoryId = try decoderContainer.decode(Double?.self, forKey: .categoryId)
        }
        if decoderContainer.contains(.category)
        {
            self.category = try decoderContainer.decode(String?.self, forKey: .category)
        }
        if decoderContainer.contains(.format)
        {
            self.format = try decoderContainer.decode(String?.self, forKey: .format)
        }
        if decoderContainer.contains(.size)
        {
            self.size = try decoderContainer.decode(Double?.self, forKey: .size)
        }
        if decoderContainer.contains(.status)
        {
            self.status = try decoderContainer.decode(Int?.self, forKey: .status)
        }
    }
}
public extension Task{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: TaskCodingKeys.self)
         try encoderContainer.encode(taskId, forKey: .taskId)
         try encoderContainer.encode(name, forKey: .name)
         try encoderContainer.encode(categoryId, forKey: .categoryId)
         try encoderContainer.encode(category, forKey: .category)
         try encoderContainer.encode(format, forKey: .format)
         try encoderContainer.encode(size, forKey: .size)
         try encoderContainer.encode(status, forKey: .status)
    }
}
///  estimateData
public class EstimateData:NSObject,Codable{
    /// 时间戳
    var timestamp:Int64?
    /// 流量、带宽
    var total:Double?
    /// 域名
    var domain:String?



    public override init(){
            super.init()
    }

    enum EstimateDataCodingKeys: String, CodingKey {
        case timestamp
        case total
        case domain
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: EstimateDataCodingKeys.self)
        if decoderContainer.contains(.timestamp)
        {
            self.timestamp = try decoderContainer.decode(Int64?.self, forKey: .timestamp)
        }
        if decoderContainer.contains(.total)
        {
            self.total = try decoderContainer.decode(Double?.self, forKey: .total)
        }
        if decoderContainer.contains(.domain)
        {
            self.domain = try decoderContainer.decode(String?.self, forKey: .domain)
        }
    }
}
public extension EstimateData{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: EstimateDataCodingKeys.self)
         try encoderContainer.encode(timestamp, forKey: .timestamp)
         try encoderContainer.encode(total, forKey: .total)
         try encoderContainer.encode(domain, forKey: .domain)
    }
}
///  transcodeData
public class TranscodeData:NSObject,Codable{
    /// 日期
    var date:String?
    /// 转码时长
    var duration:Double?



    public override init(){
            super.init()
    }

    enum TranscodeDataCodingKeys: String, CodingKey {
        case date
        case duration
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: TranscodeDataCodingKeys.self)
        if decoderContainer.contains(.date)
        {
            self.date = try decoderContainer.decode(String?.self, forKey: .date)
        }
        if decoderContainer.contains(.duration)
        {
            self.duration = try decoderContainer.decode(Double?.self, forKey: .duration)
        }
    }
}
public extension TranscodeData{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: TranscodeDataCodingKeys.self)
         try encoderContainer.encode(date, forKey: .date)
         try encoderContainer.encode(duration, forKey: .duration)
    }
}
///  queryStorageSizeResultObject
public class QueryStorageSizeResultObject:NSObject,Codable{
    /// Data
    var data:StorageSize?



    public override init(){
            super.init()
    }

    enum QueryStorageSizeResultObjectCodingKeys: String, CodingKey {
        case data
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: QueryStorageSizeResultObjectCodingKeys.self)
        if decoderContainer.contains(.data)
        {
            self.data = try decoderContainer.decode(StorageSize?.self, forKey: .data)
        }
    }
}
public extension QueryStorageSizeResultObject{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: QueryStorageSizeResultObjectCodingKeys.self)
         try encoderContainer.encode(data, forKey: .data)
    }
}
///  storageSize
public class StorageSize:NSObject,Codable{
    /// StartTime
    var startTime:String?
    /// EndTime
    var endTime:String?
    /// Size
    var size:Int64?



    public override init(){
            super.init()
    }

    enum StorageSizeCodingKeys: String, CodingKey {
        case startTime
        case endTime
        case size
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: StorageSizeCodingKeys.self)
        if decoderContainer.contains(.startTime)
        {
            self.startTime = try decoderContainer.decode(String?.self, forKey: .startTime)
        }
        if decoderContainer.contains(.endTime)
        {
            self.endTime = try decoderContainer.decode(String?.self, forKey: .endTime)
        }
        if decoderContainer.contains(.size)
        {
            self.size = try decoderContainer.decode(Int64?.self, forKey: .size)
        }
    }
}
public extension StorageSize{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: StorageSizeCodingKeys.self)
         try encoderContainer.encode(startTime, forKey: .startTime)
         try encoderContainer.encode(endTime, forKey: .endTime)
         try encoderContainer.encode(size, forKey: .size)
    }
}
///  批量提交转码作业结果对象
public class BatchSubmitTranscodeJobsRequestObject:NSObject,Codable{
    /// BulkItems
    var bulkItems:[SubmitTranscodeJobRequestObject?]?



    public override init(){
            super.init()
    }

    enum BatchSubmitTranscodeJobsRequestObjectCodingKeys: String, CodingKey {
        case bulkItems
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: BatchSubmitTranscodeJobsRequestObjectCodingKeys.self)
        if decoderContainer.contains(.bulkItems)
        {
            self.bulkItems = try decoderContainer.decode([SubmitTranscodeJobRequestObject?]?.self, forKey: .bulkItems)
        }
    }
}
public extension BatchSubmitTranscodeJobsRequestObject{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: BatchSubmitTranscodeJobsRequestObjectCodingKeys.self)
         try encoderContainer.encode(bulkItems, forKey: .bulkItems)
    }
}
///  提交转码作业请求对象
public class SubmitTranscodeJobRequestObject:NSObject,Codable{
    /// 视频ID
    var videoId:String?
    /// 转码模板ID列表
    var templateIds:[Int64?]?
    /// 水印ID列表
    var watermarkIds:[Int64?]?



    public override init(){
            super.init()
    }

    enum SubmitTranscodeJobRequestObjectCodingKeys: String, CodingKey {
        case videoId
        case templateIds
        case watermarkIds
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: SubmitTranscodeJobRequestObjectCodingKeys.self)
        if decoderContainer.contains(.videoId)
        {
            self.videoId = try decoderContainer.decode(String?.self, forKey: .videoId)
        }
        if decoderContainer.contains(.templateIds)
        {
            self.templateIds = try decoderContainer.decode([Int64?]?.self, forKey: .templateIds)
        }
        if decoderContainer.contains(.watermarkIds)
        {
            self.watermarkIds = try decoderContainer.decode([Int64?]?.self, forKey: .watermarkIds)
        }
    }
}
public extension SubmitTranscodeJobRequestObject{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: SubmitTranscodeJobRequestObjectCodingKeys.self)
         try encoderContainer.encode(videoId, forKey: .videoId)
         try encoderContainer.encode(templateIds, forKey: .templateIds)
         try encoderContainer.encode(watermarkIds, forKey: .watermarkIds)
    }
}
///  获取视频转码任务信息
public class TranscodeTaskObject:NSObject,Codable{
    /// 任务ID
    var taskId:Int64?
    /// 码率名称
    var name:String?
    /// 媒体类型
    var mediaType:Int?
    /// 状态
    var status:Int?
    /// 进度
    var progress:String?
    /// 文件大小
    var size:Int64?
    /// 转码模板ID
    var templateId:Int?
    /// 码率
    var bitrate:Int64?
    /// 编码格式
    var codec:String?
    /// 封装格式
    var format:String?
    /// 宽度
    var width:Int?
    /// 高度
    var height:Int?
    /// 帧率
    var fps:String?
    /// 创建时间
    var createTime:String?
    /// 更新时间
    var updateTime:String?



    public override init(){
            super.init()
    }

    enum TranscodeTaskObjectCodingKeys: String, CodingKey {
        case taskId
        case name
        case mediaType
        case status
        case progress
        case size
        case templateId
        case bitrate
        case codec
        case format
        case width
        case height
        case fps
        case createTime
        case updateTime
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: TranscodeTaskObjectCodingKeys.self)
        if decoderContainer.contains(.taskId)
        {
            self.taskId = try decoderContainer.decode(Int64?.self, forKey: .taskId)
        }
        if decoderContainer.contains(.name)
        {
            self.name = try decoderContainer.decode(String?.self, forKey: .name)
        }
        if decoderContainer.contains(.mediaType)
        {
            self.mediaType = try decoderContainer.decode(Int?.self, forKey: .mediaType)
        }
        if decoderContainer.contains(.status)
        {
            self.status = try decoderContainer.decode(Int?.self, forKey: .status)
        }
        if decoderContainer.contains(.progress)
        {
            self.progress = try decoderContainer.decode(String?.self, forKey: .progress)
        }
        if decoderContainer.contains(.size)
        {
            self.size = try decoderContainer.decode(Int64?.self, forKey: .size)
        }
        if decoderContainer.contains(.templateId)
        {
            self.templateId = try decoderContainer.decode(Int?.self, forKey: .templateId)
        }
        if decoderContainer.contains(.bitrate)
        {
            self.bitrate = try decoderContainer.decode(Int64?.self, forKey: .bitrate)
        }
        if decoderContainer.contains(.codec)
        {
            self.codec = try decoderContainer.decode(String?.self, forKey: .codec)
        }
        if decoderContainer.contains(.format)
        {
            self.format = try decoderContainer.decode(String?.self, forKey: .format)
        }
        if decoderContainer.contains(.width)
        {
            self.width = try decoderContainer.decode(Int?.self, forKey: .width)
        }
        if decoderContainer.contains(.height)
        {
            self.height = try decoderContainer.decode(Int?.self, forKey: .height)
        }
        if decoderContainer.contains(.fps)
        {
            self.fps = try decoderContainer.decode(String?.self, forKey: .fps)
        }
        if decoderContainer.contains(.createTime)
        {
            self.createTime = try decoderContainer.decode(String?.self, forKey: .createTime)
        }
        if decoderContainer.contains(.updateTime)
        {
            self.updateTime = try decoderContainer.decode(String?.self, forKey: .updateTime)
        }
    }
}
public extension TranscodeTaskObject{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: TranscodeTaskObjectCodingKeys.self)
         try encoderContainer.encode(taskId, forKey: .taskId)
         try encoderContainer.encode(name, forKey: .name)
         try encoderContainer.encode(mediaType, forKey: .mediaType)
         try encoderContainer.encode(status, forKey: .status)
         try encoderContainer.encode(progress, forKey: .progress)
         try encoderContainer.encode(size, forKey: .size)
         try encoderContainer.encode(templateId, forKey: .templateId)
         try encoderContainer.encode(bitrate, forKey: .bitrate)
         try encoderContainer.encode(codec, forKey: .codec)
         try encoderContainer.encode(format, forKey: .format)
         try encoderContainer.encode(width, forKey: .width)
         try encoderContainer.encode(height, forKey: .height)
         try encoderContainer.encode(fps, forKey: .fps)
         try encoderContainer.encode(createTime, forKey: .createTime)
         try encoderContainer.encode(updateTime, forKey: .updateTime)
    }
}
///  提交转码作业结果对象
public class SubmitTranscodeJobResultObject:NSObject,Codable{
    /// 已提交的转码任务
    var tasks:[SubmittedTranscodeTask?]?



    public override init(){
            super.init()
    }

    enum SubmitTranscodeJobResultObjectCodingKeys: String, CodingKey {
        case tasks
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: SubmitTranscodeJobResultObjectCodingKeys.self)
        if decoderContainer.contains(.tasks)
        {
            self.tasks = try decoderContainer.decode([SubmittedTranscodeTask?]?.self, forKey: .tasks)
        }
    }
}
public extension SubmitTranscodeJobResultObject{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: SubmitTranscodeJobResultObjectCodingKeys.self)
         try encoderContainer.encode(tasks, forKey: .tasks)
    }
}
///  批量提交转码作业结果对象
public class BatchSubmitTranscodeJobsResultObject:NSObject,Codable{
    /// Tasks
    var tasks:[SubmittedTranscodeTask?]?



    public override init(){
            super.init()
    }

    enum BatchSubmitTranscodeJobsResultObjectCodingKeys: String, CodingKey {
        case tasks
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: BatchSubmitTranscodeJobsResultObjectCodingKeys.self)
        if decoderContainer.contains(.tasks)
        {
            self.tasks = try decoderContainer.decode([SubmittedTranscodeTask?]?.self, forKey: .tasks)
        }
    }
}
public extension BatchSubmitTranscodeJobsResultObject{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: BatchSubmitTranscodeJobsResultObjectCodingKeys.self)
         try encoderContainer.encode(tasks, forKey: .tasks)
    }
}
///  submittedTranscodeTask
public class SubmittedTranscodeTask:NSObject,Codable{
    /// 任务ID
    var taskId:Int64?
    /// 视频ID
    var videoId:String?
    /// 转码模板ID
    var templateId:Int64?
    /// 水印ID列表
    var watermarkIds:[Int64?]?



    public override init(){
            super.init()
    }

    enum SubmittedTranscodeTaskCodingKeys: String, CodingKey {
        case taskId
        case videoId
        case templateId
        case watermarkIds
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: SubmittedTranscodeTaskCodingKeys.self)
        if decoderContainer.contains(.taskId)
        {
            self.taskId = try decoderContainer.decode(Int64?.self, forKey: .taskId)
        }
        if decoderContainer.contains(.videoId)
        {
            self.videoId = try decoderContainer.decode(String?.self, forKey: .videoId)
        }
        if decoderContainer.contains(.templateId)
        {
            self.templateId = try decoderContainer.decode(Int64?.self, forKey: .templateId)
        }
        if decoderContainer.contains(.watermarkIds)
        {
            self.watermarkIds = try decoderContainer.decode([Int64?]?.self, forKey: .watermarkIds)
        }
    }
}
public extension SubmittedTranscodeTask{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: SubmittedTranscodeTaskCodingKeys.self)
         try encoderContainer.encode(taskId, forKey: .taskId)
         try encoderContainer.encode(videoId, forKey: .videoId)
         try encoderContainer.encode(templateId, forKey: .templateId)
         try encoderContainer.encode(watermarkIds, forKey: .watermarkIds)
    }
}
///  转码封装配置
public class Encapsulation:NSObject,Codable{
    /// 封装格式
    var format:String?



    public override init(){
            super.init()
    }

    enum EncapsulationCodingKeys: String, CodingKey {
        case format
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: EncapsulationCodingKeys.self)
        if decoderContainer.contains(.format)
        {
            self.format = try decoderContainer.decode(String?.self, forKey: .format)
        }
    }
}
public extension Encapsulation{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: EncapsulationCodingKeys.self)
         try encoderContainer.encode(format, forKey: .format)
    }
}
///  查询转码模板列表结果信息
public class ListTranscodeTemplatesResultObject:NSObject,Codable{
    /// 当前页码
    var pageNumber:Int?
    /// 每页数量
    var pageSize:Int?
    /// 查询总数
    var totalElements:Int?
    /// 总页数
    var totalPages:Int?
    /// 分页内容
    var content:[TranscodeTemplateObject?]?



    public override init(){
            super.init()
    }

    enum ListTranscodeTemplatesResultObjectCodingKeys: String, CodingKey {
        case pageNumber
        case pageSize
        case totalElements
        case totalPages
        case content
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: ListTranscodeTemplatesResultObjectCodingKeys.self)
        if decoderContainer.contains(.pageNumber)
        {
            self.pageNumber = try decoderContainer.decode(Int?.self, forKey: .pageNumber)
        }
        if decoderContainer.contains(.pageSize)
        {
            self.pageSize = try decoderContainer.decode(Int?.self, forKey: .pageSize)
        }
        if decoderContainer.contains(.totalElements)
        {
            self.totalElements = try decoderContainer.decode(Int?.self, forKey: .totalElements)
        }
        if decoderContainer.contains(.totalPages)
        {
            self.totalPages = try decoderContainer.decode(Int?.self, forKey: .totalPages)
        }
        if decoderContainer.contains(.content)
        {
            self.content = try decoderContainer.decode([TranscodeTemplateObject?]?.self, forKey: .content)
        }
    }
}
public extension ListTranscodeTemplatesResultObject{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: ListTranscodeTemplatesResultObjectCodingKeys.self)
         try encoderContainer.encode(pageNumber, forKey: .pageNumber)
         try encoderContainer.encode(pageSize, forKey: .pageSize)
         try encoderContainer.encode(totalElements, forKey: .totalElements)
         try encoderContainer.encode(totalPages, forKey: .totalPages)
         try encoderContainer.encode(content, forKey: .content)
    }
}
///  转码模板信息
public class TranscodeTemplateObject:NSObject,Codable{
    /// 模板ID
    var id:Int64?
    /// 模板名称。长度不超过128个字符。UTF-8编码。
      /// 
    var name:String?
    /// 视频参数配置
    var video:Video?
    /// 音频参数配置
    var audio:Audio?
    /// 封装配置
    var encapsulation:Encapsulation?
    /// 清晰度规格标记。取值范围：
      ///   SD - 标清
      ///   HD - 高清
      ///   FHD - 超清
      ///   2K
      ///   4K
      /// 
    var definition:String?
    /// 模板来源。取值范围：
      ///   system - 系统预置
      ///   custom - 用户自建
      /// 
    var source:String?
    /// 模板类型。取值范围：
      ///   jdchd - 京享超清
      ///   jdchs - 极速转码
      /// 
    var templateType:String?
    /// 创建时间
    var createTime:String?
    /// 修改时间
    var updateTime:String?



    public override init(){
            super.init()
    }

    enum TranscodeTemplateObjectCodingKeys: String, CodingKey {
        case id
        case name
        case video
        case audio
        case encapsulation
        case definition
        case source
        case templateType
        case createTime
        case updateTime
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: TranscodeTemplateObjectCodingKeys.self)
        if decoderContainer.contains(.id)
        {
            self.id = try decoderContainer.decode(Int64?.self, forKey: .id)
        }
        if decoderContainer.contains(.name)
        {
            self.name = try decoderContainer.decode(String?.self, forKey: .name)
        }
        if decoderContainer.contains(.video)
        {
            self.video = try decoderContainer.decode(Video?.self, forKey: .video)
        }
        if decoderContainer.contains(.audio)
        {
            self.audio = try decoderContainer.decode(Audio?.self, forKey: .audio)
        }
        if decoderContainer.contains(.encapsulation)
        {
            self.encapsulation = try decoderContainer.decode(Encapsulation?.self, forKey: .encapsulation)
        }
        if decoderContainer.contains(.definition)
        {
            self.definition = try decoderContainer.decode(String?.self, forKey: .definition)
        }
        if decoderContainer.contains(.source)
        {
            self.source = try decoderContainer.decode(String?.self, forKey: .source)
        }
        if decoderContainer.contains(.templateType)
        {
            self.templateType = try decoderContainer.decode(String?.self, forKey: .templateType)
        }
        if decoderContainer.contains(.createTime)
        {
            self.createTime = try decoderContainer.decode(String?.self, forKey: .createTime)
        }
        if decoderContainer.contains(.updateTime)
        {
            self.updateTime = try decoderContainer.decode(String?.self, forKey: .updateTime)
        }
    }
}
public extension TranscodeTemplateObject{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: TranscodeTemplateObjectCodingKeys.self)
         try encoderContainer.encode(id, forKey: .id)
         try encoderContainer.encode(name, forKey: .name)
         try encoderContainer.encode(video, forKey: .video)
         try encoderContainer.encode(audio, forKey: .audio)
         try encoderContainer.encode(encapsulation, forKey: .encapsulation)
         try encoderContainer.encode(definition, forKey: .definition)
         try encoderContainer.encode(source, forKey: .source)
         try encoderContainer.encode(templateType, forKey: .templateType)
         try encoderContainer.encode(createTime, forKey: .createTime)
         try encoderContainer.encode(updateTime, forKey: .updateTime)
    }
}
///  创建转码模板请求信息
public class CreateTranscodeTemplateRequestObject:NSObject,Codable{
    /// 模板名称。长度不超过128个字符。UTF-8编码。
      /// 
    /// Required:true
    var name:String
    /// 视频参数配置
    /// Required:true
    var video:Video
    /// 音频参数配置
    /// Required:true
    var audio:Audio
    /// 封装配置
    /// Required:true
    var encapsulation:Encapsulation
    /// 清晰度规格标记。取值范围：
      ///   SD - 标清
      ///   HD - 高清
      ///   FHD - 超清
      ///   2K
      ///   4K
      /// 
    /// Required:true
    var definition:String
    /// 模板类型。取值范围：
      ///   jdchd - 京享超清
      ///   jdchs - 极速转码
      /// 
    var templateType:String?



    public  init(name:String,video:Video,audio:Audio,encapsulation:Encapsulation,definition:String){
             self.name = name
             self.video = video
             self.audio = audio
             self.encapsulation = encapsulation
             self.definition = definition
    }

    enum CreateTranscodeTemplateRequestObjectCodingKeys: String, CodingKey {
        case name
        case video
        case audio
        case encapsulation
        case definition
        case templateType
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: CreateTranscodeTemplateRequestObjectCodingKeys.self)
        self.name = try decoderContainer.decode(String.self, forKey: .name)
        self.video = try decoderContainer.decode(Video.self, forKey: .video)
        self.audio = try decoderContainer.decode(Audio.self, forKey: .audio)
        self.encapsulation = try decoderContainer.decode(Encapsulation.self, forKey: .encapsulation)
        self.definition = try decoderContainer.decode(String.self, forKey: .definition)
        if decoderContainer.contains(.templateType)
        {
            self.templateType = try decoderContainer.decode(String?.self, forKey: .templateType)
        }
    }
}
public extension CreateTranscodeTemplateRequestObject{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: CreateTranscodeTemplateRequestObjectCodingKeys.self)
         try encoderContainer.encode(name, forKey: .name)
         try encoderContainer.encode(video, forKey: .video)
         try encoderContainer.encode(audio, forKey: .audio)
         try encoderContainer.encode(encapsulation, forKey: .encapsulation)
         try encoderContainer.encode(definition, forKey: .definition)
         try encoderContainer.encode(templateType, forKey: .templateType)
    }
}
///  转码视频参数配置
public class Video:NSObject,Codable{
    /// 视频编码。取值范围：h265、h264
    var codec:String?
    /// 视频码率。取值范围 [128、10000]，单位为 Kbps
    var bitrate:Int?
    /// 视频帧率。取值范围为 [1、60]，单位为 fps
    var fps:Int?
    /// 视频输出宽度。取值范围 [128，4096] 整数。
      /// 当值为空时，若 height 也为空，则 width 和 height 与原视频保持一致；若 height 不为空，则 width 按照原视频的分辨率等比缩放。
      /// 
    var width:Int?
    /// 视频输出高度。取值范围 [128，4096] 整数。
      /// 当值为空时，若 width 也为空，则 width 和 height 与原视频保持一致；若 width 不为空，则 height 按照原视频的分辨率等比缩放。
      /// 
    var height:Int?



    public override init(){
            super.init()
    }

    enum VideoCodingKeys: String, CodingKey {
        case codec
        case bitrate
        case fps
        case width
        case height
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: VideoCodingKeys.self)
        if decoderContainer.contains(.codec)
        {
            self.codec = try decoderContainer.decode(String?.self, forKey: .codec)
        }
        if decoderContainer.contains(.bitrate)
        {
            self.bitrate = try decoderContainer.decode(Int?.self, forKey: .bitrate)
        }
        if decoderContainer.contains(.fps)
        {
            self.fps = try decoderContainer.decode(Int?.self, forKey: .fps)
        }
        if decoderContainer.contains(.width)
        {
            self.width = try decoderContainer.decode(Int?.self, forKey: .width)
        }
        if decoderContainer.contains(.height)
        {
            self.height = try decoderContainer.decode(Int?.self, forKey: .height)
        }
    }
}
public extension Video{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: VideoCodingKeys.self)
         try encoderContainer.encode(codec, forKey: .codec)
         try encoderContainer.encode(bitrate, forKey: .bitrate)
         try encoderContainer.encode(fps, forKey: .fps)
         try encoderContainer.encode(width, forKey: .width)
         try encoderContainer.encode(height, forKey: .height)
    }
}
///  转码音频参数配置
public class Audio:NSObject,Codable{
    /// 音频编码。取值范围：aac
    var codec:String?
    /// 音频目标码率。取值范围：[8，1000]，单位为 Kbps
    var bitrate:Int?
    /// 音频采样率。取值范围：8000、11025、12000、16000、22050、24000、32000、44100、48000、64000、88200、96000
    var sampleRate:Int?
    /// 音频声道数：1、2
    var channels:Int?
    /// 是否开启舒适音频：true、false
    var comfortable:Bool?



    public override init(){
            super.init()
    }

    enum AudioCodingKeys: String, CodingKey {
        case codec
        case bitrate
        case sampleRate
        case channels
        case comfortable
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: AudioCodingKeys.self)
        if decoderContainer.contains(.codec)
        {
            self.codec = try decoderContainer.decode(String?.self, forKey: .codec)
        }
        if decoderContainer.contains(.bitrate)
        {
            self.bitrate = try decoderContainer.decode(Int?.self, forKey: .bitrate)
        }
        if decoderContainer.contains(.sampleRate)
        {
            self.sampleRate = try decoderContainer.decode(Int?.self, forKey: .sampleRate)
        }
        if decoderContainer.contains(.channels)
        {
            self.channels = try decoderContainer.decode(Int?.self, forKey: .channels)
        }
        if decoderContainer.contains(.comfortable)
        {
            self.comfortable = try decoderContainer.decode(Bool?.self, forKey: .comfortable)
        }
    }
}
public extension Audio{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: AudioCodingKeys.self)
         try encoderContainer.encode(codec, forKey: .codec)
         try encoderContainer.encode(bitrate, forKey: .bitrate)
         try encoderContainer.encode(sampleRate, forKey: .sampleRate)
         try encoderContainer.encode(channels, forKey: .channels)
         try encoderContainer.encode(comfortable, forKey: .comfortable)
    }
}
///  修改转码模板请求信息
public class UpdateTranscodeTemplateRequestObject:NSObject,Codable{
    /// 模板名称。长度不超过128个字符。UTF-8编码。
      /// 
    var name:String?
    /// 视频参数配置
    var video:Video?
    /// 音频参数配置
    var audio:Audio?
    /// 封装配置
    var encapsulation:Encapsulation?
    /// 清晰度规格标记。取值范围：
      ///   SD - 标清
      ///   HD - 高清
      ///   FHD - 超清
      ///   2K
      ///   4K
      /// 
    var definition:String?
    /// 模板类型。取值范围：
      ///   jdchd - 京享超清
      ///   jdchs - 极速转码
      /// 
    var templateType:String?



    public override init(){
            super.init()
    }

    enum UpdateTranscodeTemplateRequestObjectCodingKeys: String, CodingKey {
        case name
        case video
        case audio
        case encapsulation
        case definition
        case templateType
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: UpdateTranscodeTemplateRequestObjectCodingKeys.self)
        if decoderContainer.contains(.name)
        {
            self.name = try decoderContainer.decode(String?.self, forKey: .name)
        }
        if decoderContainer.contains(.video)
        {
            self.video = try decoderContainer.decode(Video?.self, forKey: .video)
        }
        if decoderContainer.contains(.audio)
        {
            self.audio = try decoderContainer.decode(Audio?.self, forKey: .audio)
        }
        if decoderContainer.contains(.encapsulation)
        {
            self.encapsulation = try decoderContainer.decode(Encapsulation?.self, forKey: .encapsulation)
        }
        if decoderContainer.contains(.definition)
        {
            self.definition = try decoderContainer.decode(String?.self, forKey: .definition)
        }
        if decoderContainer.contains(.templateType)
        {
            self.templateType = try decoderContainer.decode(String?.self, forKey: .templateType)
        }
    }
}
public extension UpdateTranscodeTemplateRequestObject{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: UpdateTranscodeTemplateRequestObjectCodingKeys.self)
         try encoderContainer.encode(name, forKey: .name)
         try encoderContainer.encode(video, forKey: .video)
         try encoderContainer.encode(audio, forKey: .audio)
         try encoderContainer.encode(encapsulation, forKey: .encapsulation)
         try encoderContainer.encode(definition, forKey: .definition)
         try encoderContainer.encode(templateType, forKey: .templateType)
    }
}
///  查询分类响应信息
public class CategoryObject:NSObject,Codable{
    /// 分类ID
    var id:Int64?
    /// 分类名称
    var name:String?
    /// 分类级别。取值范围为 [0, 3]，取值为 0 时为虚拟根节点
      /// 
    var level:Int?
    /// 父分类ID，取值为 0 或 null 时，表示该分类为一级分类
      /// 
    var parentId:Int64?
    /// 分类描述信息
    var descriptionValue:String?
    /// 创建时间
    var createTime:String?
    /// 修改时间
    var updateTime:String?



    public override init(){
            super.init()
    }

    enum CategoryObjectCodingKeys: String, CodingKey {
        case id
        case name
        case level
        case parentId
        case descriptionValue = "description"
        case createTime
        case updateTime
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: CategoryObjectCodingKeys.self)
        if decoderContainer.contains(.id)
        {
            self.id = try decoderContainer.decode(Int64?.self, forKey: .id)
        }
        if decoderContainer.contains(.name)
        {
            self.name = try decoderContainer.decode(String?.self, forKey: .name)
        }
        if decoderContainer.contains(.level)
        {
            self.level = try decoderContainer.decode(Int?.self, forKey: .level)
        }
        if decoderContainer.contains(.parentId)
        {
            self.parentId = try decoderContainer.decode(Int64?.self, forKey: .parentId)
        }
        if decoderContainer.contains(.descriptionValue)
        {
            self.descriptionValue = try decoderContainer.decode(String?.self, forKey: .descriptionValue)
        }
        if decoderContainer.contains(.createTime)
        {
            self.createTime = try decoderContainer.decode(String?.self, forKey: .createTime)
        }
        if decoderContainer.contains(.updateTime)
        {
            self.updateTime = try decoderContainer.decode(String?.self, forKey: .updateTime)
        }
    }
}
public extension CategoryObject{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: CategoryObjectCodingKeys.self)
         try encoderContainer.encode(id, forKey: .id)
         try encoderContainer.encode(name, forKey: .name)
         try encoderContainer.encode(level, forKey: .level)
         try encoderContainer.encode(parentId, forKey: .parentId)
         try encoderContainer.encode(descriptionValue, forKey: .descriptionValue)
         try encoderContainer.encode(createTime, forKey: .createTime)
         try encoderContainer.encode(updateTime, forKey: .updateTime)
    }
}
///  修改分类请求信息
public class UpdateCategoryRequestObject:NSObject,Codable{
    /// 分类名称
    var name:String?
    /// 父分类ID，取值为 0 或 null 时，表示该分类为一级分类
      /// 
    var parentId:Int64?
    /// 分类描述信息
    var descriptionValue:String?



    public override init(){
            super.init()
    }

    enum UpdateCategoryRequestObjectCodingKeys: String, CodingKey {
        case name
        case parentId
        case descriptionValue = "description"
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: UpdateCategoryRequestObjectCodingKeys.self)
        if decoderContainer.contains(.name)
        {
            self.name = try decoderContainer.decode(String?.self, forKey: .name)
        }
        if decoderContainer.contains(.parentId)
        {
            self.parentId = try decoderContainer.decode(Int64?.self, forKey: .parentId)
        }
        if decoderContainer.contains(.descriptionValue)
        {
            self.descriptionValue = try decoderContainer.decode(String?.self, forKey: .descriptionValue)
        }
    }
}
public extension UpdateCategoryRequestObject{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: UpdateCategoryRequestObjectCodingKeys.self)
         try encoderContainer.encode(name, forKey: .name)
         try encoderContainer.encode(parentId, forKey: .parentId)
         try encoderContainer.encode(descriptionValue, forKey: .descriptionValue)
    }
}
///  查询分类响应信息
public class GetCategoryWithChildrenResultObject:NSObject,Codable{
    /// 分类ID
    var id:Int64?
    /// 分类名称
    var name:String?
    /// 分类级别
    var level:Int?
    /// 分类描述
    var descriptionValue:String?
    /// 下级分类
    var children:[SubCategory?]?
    /// 创建时间
    var createTime:String?
    /// 修改时间
    var updateTime:String?



    public override init(){
            super.init()
    }

    enum GetCategoryWithChildrenResultObjectCodingKeys: String, CodingKey {
        case id
        case name
        case level
        case descriptionValue = "description"
        case children
        case createTime
        case updateTime
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: GetCategoryWithChildrenResultObjectCodingKeys.self)
        if decoderContainer.contains(.id)
        {
            self.id = try decoderContainer.decode(Int64?.self, forKey: .id)
        }
        if decoderContainer.contains(.name)
        {
            self.name = try decoderContainer.decode(String?.self, forKey: .name)
        }
        if decoderContainer.contains(.level)
        {
            self.level = try decoderContainer.decode(Int?.self, forKey: .level)
        }
        if decoderContainer.contains(.descriptionValue)
        {
            self.descriptionValue = try decoderContainer.decode(String?.self, forKey: .descriptionValue)
        }
        if decoderContainer.contains(.children)
        {
            self.children = try decoderContainer.decode([SubCategory?]?.self, forKey: .children)
        }
        if decoderContainer.contains(.createTime)
        {
            self.createTime = try decoderContainer.decode(String?.self, forKey: .createTime)
        }
        if decoderContainer.contains(.updateTime)
        {
            self.updateTime = try decoderContainer.decode(String?.self, forKey: .updateTime)
        }
    }
}
public extension GetCategoryWithChildrenResultObject{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: GetCategoryWithChildrenResultObjectCodingKeys.self)
         try encoderContainer.encode(id, forKey: .id)
         try encoderContainer.encode(name, forKey: .name)
         try encoderContainer.encode(level, forKey: .level)
         try encoderContainer.encode(descriptionValue, forKey: .descriptionValue)
         try encoderContainer.encode(children, forKey: .children)
         try encoderContainer.encode(createTime, forKey: .createTime)
         try encoderContainer.encode(updateTime, forKey: .updateTime)
    }
}
///  查询分类信息列表结果
public class ListCategoriesResultObject:NSObject,Codable{
    /// 当前页码
    var pageNumber:Int?
    /// 每页数量
    var pageSize:Int?
    /// 查询总数
    var totalElements:Int?
    /// 总页数
    var totalPages:Int?
    /// 分页内容
    var content:[CategoryObject?]?



    public override init(){
            super.init()
    }

    enum ListCategoriesResultObjectCodingKeys: String, CodingKey {
        case pageNumber
        case pageSize
        case totalElements
        case totalPages
        case content
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: ListCategoriesResultObjectCodingKeys.self)
        if decoderContainer.contains(.pageNumber)
        {
            self.pageNumber = try decoderContainer.decode(Int?.self, forKey: .pageNumber)
        }
        if decoderContainer.contains(.pageSize)
        {
            self.pageSize = try decoderContainer.decode(Int?.self, forKey: .pageSize)
        }
        if decoderContainer.contains(.totalElements)
        {
            self.totalElements = try decoderContainer.decode(Int?.self, forKey: .totalElements)
        }
        if decoderContainer.contains(.totalPages)
        {
            self.totalPages = try decoderContainer.decode(Int?.self, forKey: .totalPages)
        }
        if decoderContainer.contains(.content)
        {
            self.content = try decoderContainer.decode([CategoryObject?]?.self, forKey: .content)
        }
    }
}
public extension ListCategoriesResultObject{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: ListCategoriesResultObjectCodingKeys.self)
         try encoderContainer.encode(pageNumber, forKey: .pageNumber)
         try encoderContainer.encode(pageSize, forKey: .pageSize)
         try encoderContainer.encode(totalElements, forKey: .totalElements)
         try encoderContainer.encode(totalPages, forKey: .totalPages)
         try encoderContainer.encode(content, forKey: .content)
    }
}
///  查询所有分类
public class ListAllCategoriesResultObject:NSObject,Codable{
    /// 平坦结构结果
    var flatResult:[CategoryObject?]?
    /// 树结构结果
    var treeResult:CategoryTreeNode?



    public override init(){
            super.init()
    }

    enum ListAllCategoriesResultObjectCodingKeys: String, CodingKey {
        case flatResult
        case treeResult
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: ListAllCategoriesResultObjectCodingKeys.self)
        if decoderContainer.contains(.flatResult)
        {
            self.flatResult = try decoderContainer.decode([CategoryObject?]?.self, forKey: .flatResult)
        }
        if decoderContainer.contains(.treeResult)
        {
            self.treeResult = try decoderContainer.decode(CategoryTreeNode?.self, forKey: .treeResult)
        }
    }
}
public extension ListAllCategoriesResultObject{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: ListAllCategoriesResultObjectCodingKeys.self)
         try encoderContainer.encode(flatResult, forKey: .flatResult)
         try encoderContainer.encode(treeResult, forKey: .treeResult)
    }
}
///  创建分类请求信息
public class CreateCategoryRequestObject:NSObject,Codable{
    /// 分类名称
    /// Required:true
    var name:String
    /// 父分类ID，取值为 0 或 null 时，表示该分类为一级分类
      /// 
    var parentId:Int64?
    /// 分类描述信息
    var descriptionValue:String?



    public  init(name:String){
             self.name = name
    }

    enum CreateCategoryRequestObjectCodingKeys: String, CodingKey {
        case name
        case parentId
        case descriptionValue = "description"
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: CreateCategoryRequestObjectCodingKeys.self)
        self.name = try decoderContainer.decode(String.self, forKey: .name)
        if decoderContainer.contains(.parentId)
        {
            self.parentId = try decoderContainer.decode(Int64?.self, forKey: .parentId)
        }
        if decoderContainer.contains(.descriptionValue)
        {
            self.descriptionValue = try decoderContainer.decode(String?.self, forKey: .descriptionValue)
        }
    }
}
public extension CreateCategoryRequestObject{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: CreateCategoryRequestObjectCodingKeys.self)
         try encoderContainer.encode(name, forKey: .name)
         try encoderContainer.encode(parentId, forKey: .parentId)
         try encoderContainer.encode(descriptionValue, forKey: .descriptionValue)
    }
}
///  分类树节点
public class CategoryTreeNode:NSObject,Codable{
    /// 分类ID
    var id:Int64?
    /// 分类名称
    var name:String?
    /// 分类级别
    var level:Int?
    /// 分类描述信息
    var descriptionValue:String?
    /// 子分类
    var children:[CategoryTreeNode?]?
    /// 创建时间
    var createTime:String?
    /// 修改时间
    var updateTime:String?



    public override init(){
            super.init()
    }

    enum CategoryTreeNodeCodingKeys: String, CodingKey {
        case id
        case name
        case level
        case descriptionValue = "description"
        case children
        case createTime
        case updateTime
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: CategoryTreeNodeCodingKeys.self)
        if decoderContainer.contains(.id)
        {
            self.id = try decoderContainer.decode(Int64?.self, forKey: .id)
        }
        if decoderContainer.contains(.name)
        {
            self.name = try decoderContainer.decode(String?.self, forKey: .name)
        }
        if decoderContainer.contains(.level)
        {
            self.level = try decoderContainer.decode(Int?.self, forKey: .level)
        }
        if decoderContainer.contains(.descriptionValue)
        {
            self.descriptionValue = try decoderContainer.decode(String?.self, forKey: .descriptionValue)
        }
        if decoderContainer.contains(.children)
        {
            self.children = try decoderContainer.decode([CategoryTreeNode?]?.self, forKey: .children)
        }
        if decoderContainer.contains(.createTime)
        {
            self.createTime = try decoderContainer.decode(String?.self, forKey: .createTime)
        }
        if decoderContainer.contains(.updateTime)
        {
            self.updateTime = try decoderContainer.decode(String?.self, forKey: .updateTime)
        }
    }
}
public extension CategoryTreeNode{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: CategoryTreeNodeCodingKeys.self)
         try encoderContainer.encode(id, forKey: .id)
         try encoderContainer.encode(name, forKey: .name)
         try encoderContainer.encode(level, forKey: .level)
         try encoderContainer.encode(descriptionValue, forKey: .descriptionValue)
         try encoderContainer.encode(children, forKey: .children)
         try encoderContainer.encode(createTime, forKey: .createTime)
         try encoderContainer.encode(updateTime, forKey: .updateTime)
    }
}
///  下级分类
public class SubCategory:NSObject,Codable{
    /// 分类ID
    var id:Int64?
    /// 分类名称
    var name:String?
    /// 分类级别
    var level:Int?
    /// 分类描述
    var descriptionValue:String?
    /// 创建时间
    var createTime:String?
    /// 修改时间
    var updateTime:String?



    public override init(){
            super.init()
    }

    enum SubCategoryCodingKeys: String, CodingKey {
        case id
        case name
        case level
        case descriptionValue = "description"
        case createTime
        case updateTime
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: SubCategoryCodingKeys.self)
        if decoderContainer.contains(.id)
        {
            self.id = try decoderContainer.decode(Int64?.self, forKey: .id)
        }
        if decoderContainer.contains(.name)
        {
            self.name = try decoderContainer.decode(String?.self, forKey: .name)
        }
        if decoderContainer.contains(.level)
        {
            self.level = try decoderContainer.decode(Int?.self, forKey: .level)
        }
        if decoderContainer.contains(.descriptionValue)
        {
            self.descriptionValue = try decoderContainer.decode(String?.self, forKey: .descriptionValue)
        }
        if decoderContainer.contains(.createTime)
        {
            self.createTime = try decoderContainer.decode(String?.self, forKey: .createTime)
        }
        if decoderContainer.contains(.updateTime)
        {
            self.updateTime = try decoderContainer.decode(String?.self, forKey: .updateTime)
        }
    }
}
public extension SubCategory{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: SubCategoryCodingKeys.self)
         try encoderContainer.encode(id, forKey: .id)
         try encoderContainer.encode(name, forKey: .name)
         try encoderContainer.encode(level, forKey: .level)
         try encoderContainer.encode(descriptionValue, forKey: .descriptionValue)
         try encoderContainer.encode(createTime, forKey: .createTime)
         try encoderContainer.encode(updateTime, forKey: .updateTime)
    }
}
///  批量修改视频信息结果
public class BatchUpdateVideosResultObject:NSObject,Codable{
    /// 更新成功的视频ID列表
    var okVideoIds:[String?]?
    /// 未找到的视频ID列表
    var notFoundVideoIds:[String?]?
    /// 更新失败的视频ID列表
    var failedVideoIds:[String?]?



    public override init(){
            super.init()
    }

    enum BatchUpdateVideosResultObjectCodingKeys: String, CodingKey {
        case okVideoIds
        case notFoundVideoIds
        case failedVideoIds
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: BatchUpdateVideosResultObjectCodingKeys.self)
        if decoderContainer.contains(.okVideoIds)
        {
            self.okVideoIds = try decoderContainer.decode([String?]?.self, forKey: .okVideoIds)
        }
        if decoderContainer.contains(.notFoundVideoIds)
        {
            self.notFoundVideoIds = try decoderContainer.decode([String?]?.self, forKey: .notFoundVideoIds)
        }
        if decoderContainer.contains(.failedVideoIds)
        {
            self.failedVideoIds = try decoderContainer.decode([String?]?.self, forKey: .failedVideoIds)
        }
    }
}
public extension BatchUpdateVideosResultObject{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: BatchUpdateVideosResultObjectCodingKeys.self)
         try encoderContainer.encode(okVideoIds, forKey: .okVideoIds)
         try encoderContainer.encode(notFoundVideoIds, forKey: .notFoundVideoIds)
         try encoderContainer.encode(failedVideoIds, forKey: .failedVideoIds)
    }
}
///  获取音视频播放信息响应体
public class GetPlayInfoResultObject:NSObject,Codable{
    /// 视频基础信息
    var baseInfo:VideoBaseInfo?
    /// 视频播放信息列表
    var playInfoList:[VideoPlayInfo?]?



    public override init(){
            super.init()
    }

    enum GetPlayInfoResultObjectCodingKeys: String, CodingKey {
        case baseInfo
        case playInfoList
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: GetPlayInfoResultObjectCodingKeys.self)
        if decoderContainer.contains(.baseInfo)
        {
            self.baseInfo = try decoderContainer.decode(VideoBaseInfo?.self, forKey: .baseInfo)
        }
        if decoderContainer.contains(.playInfoList)
        {
            self.playInfoList = try decoderContainer.decode([VideoPlayInfo?]?.self, forKey: .playInfoList)
        }
    }
}
public extension GetPlayInfoResultObject{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: GetPlayInfoResultObjectCodingKeys.self)
         try encoderContainer.encode(baseInfo, forKey: .baseInfo)
         try encoderContainer.encode(playInfoList, forKey: .playInfoList)
    }
}
///  snapshot
public class Snapshot:NSObject,Codable{
    /// 截图ID
    var imgId:Int64?
    /// 截图URL
    var imgUrl:String?
    /// 截图宽度
    var width:Int?
    /// 截图高度
    var height:Int?



    public override init(){
            super.init()
    }

    enum SnapshotCodingKeys: String, CodingKey {
        case imgId
        case imgUrl
        case width
        case height
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: SnapshotCodingKeys.self)
        if decoderContainer.contains(.imgId)
        {
            self.imgId = try decoderContainer.decode(Int64?.self, forKey: .imgId)
        }
        if decoderContainer.contains(.imgUrl)
        {
            self.imgUrl = try decoderContainer.decode(String?.self, forKey: .imgUrl)
        }
        if decoderContainer.contains(.width)
        {
            self.width = try decoderContainer.decode(Int?.self, forKey: .width)
        }
        if decoderContainer.contains(.height)
        {
            self.height = try decoderContainer.decode(Int?.self, forKey: .height)
        }
    }
}
public extension Snapshot{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: SnapshotCodingKeys.self)
         try encoderContainer.encode(imgId, forKey: .imgId)
         try encoderContainer.encode(imgUrl, forKey: .imgUrl)
         try encoderContainer.encode(width, forKey: .width)
         try encoderContainer.encode(height, forKey: .height)
    }
}
///  视频基础信息
public class VideoBaseInfo:NSObject,Codable{
    /// 视频ID
    var videoId:String?
    /// 视频名称
    var videoName:String?
    /// 视频描述
    var descriptionValue:String?
    /// CategoryId
    var categoryId:Int64?
    /// 分类名称
    var categoryName:String?
    /// 标签
    var tags:String?
    /// 视频时长
    var duration:Int64?
    /// 封面地址
    var coverUrl:String?



    public override init(){
            super.init()
    }

    enum VideoBaseInfoCodingKeys: String, CodingKey {
        case videoId
        case videoName
        case descriptionValue = "description"
        case categoryId
        case categoryName
        case tags
        case duration
        case coverUrl
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: VideoBaseInfoCodingKeys.self)
        if decoderContainer.contains(.videoId)
        {
            self.videoId = try decoderContainer.decode(String?.self, forKey: .videoId)
        }
        if decoderContainer.contains(.videoName)
        {
            self.videoName = try decoderContainer.decode(String?.self, forKey: .videoName)
        }
        if decoderContainer.contains(.descriptionValue)
        {
            self.descriptionValue = try decoderContainer.decode(String?.self, forKey: .descriptionValue)
        }
        if decoderContainer.contains(.categoryId)
        {
            self.categoryId = try decoderContainer.decode(Int64?.self, forKey: .categoryId)
        }
        if decoderContainer.contains(.categoryName)
        {
            self.categoryName = try decoderContainer.decode(String?.self, forKey: .categoryName)
        }
        if decoderContainer.contains(.tags)
        {
            self.tags = try decoderContainer.decode(String?.self, forKey: .tags)
        }
        if decoderContainer.contains(.duration)
        {
            self.duration = try decoderContainer.decode(Int64?.self, forKey: .duration)
        }
        if decoderContainer.contains(.coverUrl)
        {
            self.coverUrl = try decoderContainer.decode(String?.self, forKey: .coverUrl)
        }
    }
}
public extension VideoBaseInfo{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: VideoBaseInfoCodingKeys.self)
         try encoderContainer.encode(videoId, forKey: .videoId)
         try encoderContainer.encode(videoName, forKey: .videoName)
         try encoderContainer.encode(descriptionValue, forKey: .descriptionValue)
         try encoderContainer.encode(categoryId, forKey: .categoryId)
         try encoderContainer.encode(categoryName, forKey: .categoryName)
         try encoderContainer.encode(tags, forKey: .tags)
         try encoderContainer.encode(duration, forKey: .duration)
         try encoderContainer.encode(coverUrl, forKey: .coverUrl)
    }
}
///  videoObject
public class VideoObject:NSObject,Codable{
    /// 视频ID
    var id:String?
    /// 视频名称
    var name:String?
    /// 视频描述
    var descriptionValue:String?
    /// 封面图地址
    var coverUrl:String?
    /// 视频状态。取值范围：
      ///   transcoding - 转码中
      ///   transcode_failed - 转码失败
      ///   normal - 正常
      ///   uploaded - 上传完成（未转码）
      /// 
    var status:String?
    /// 文件大小，单位为 Byte
    var fileSize:Int64?
    /// 文件MD5校验和
    var checksum:String?
    /// 视频时长
    var duration:Int64?
    /// 标签集合
    var tags:[String?]?
    /// 分类ID
    var categoryId:Int64?
    /// 分类名称
    var categoryName:String?
    /// 转码截图
    var snapshots:[Snapshot?]?
    /// 创建时间
    var createTime:String?
    /// 修改时间
    var updateTime:String?



    public override init(){
            super.init()
    }

    enum VideoObjectCodingKeys: String, CodingKey {
        case id
        case name
        case descriptionValue = "description"
        case coverUrl
        case status
        case fileSize
        case checksum
        case duration
        case tags
        case categoryId
        case categoryName
        case snapshots
        case createTime
        case updateTime
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: VideoObjectCodingKeys.self)
        if decoderContainer.contains(.id)
        {
            self.id = try decoderContainer.decode(String?.self, forKey: .id)
        }
        if decoderContainer.contains(.name)
        {
            self.name = try decoderContainer.decode(String?.self, forKey: .name)
        }
        if decoderContainer.contains(.descriptionValue)
        {
            self.descriptionValue = try decoderContainer.decode(String?.self, forKey: .descriptionValue)
        }
        if decoderContainer.contains(.coverUrl)
        {
            self.coverUrl = try decoderContainer.decode(String?.self, forKey: .coverUrl)
        }
        if decoderContainer.contains(.status)
        {
            self.status = try decoderContainer.decode(String?.self, forKey: .status)
        }
        if decoderContainer.contains(.fileSize)
        {
            self.fileSize = try decoderContainer.decode(Int64?.self, forKey: .fileSize)
        }
        if decoderContainer.contains(.checksum)
        {
            self.checksum = try decoderContainer.decode(String?.self, forKey: .checksum)
        }
        if decoderContainer.contains(.duration)
        {
            self.duration = try decoderContainer.decode(Int64?.self, forKey: .duration)
        }
        if decoderContainer.contains(.tags)
        {
            self.tags = try decoderContainer.decode([String?]?.self, forKey: .tags)
        }
        if decoderContainer.contains(.categoryId)
        {
            self.categoryId = try decoderContainer.decode(Int64?.self, forKey: .categoryId)
        }
        if decoderContainer.contains(.categoryName)
        {
            self.categoryName = try decoderContainer.decode(String?.self, forKey: .categoryName)
        }
        if decoderContainer.contains(.snapshots)
        {
            self.snapshots = try decoderContainer.decode([Snapshot?]?.self, forKey: .snapshots)
        }
        if decoderContainer.contains(.createTime)
        {
            self.createTime = try decoderContainer.decode(String?.self, forKey: .createTime)
        }
        if decoderContainer.contains(.updateTime)
        {
            self.updateTime = try decoderContainer.decode(String?.self, forKey: .updateTime)
        }
    }
}
public extension VideoObject{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: VideoObjectCodingKeys.self)
         try encoderContainer.encode(id, forKey: .id)
         try encoderContainer.encode(name, forKey: .name)
         try encoderContainer.encode(descriptionValue, forKey: .descriptionValue)
         try encoderContainer.encode(coverUrl, forKey: .coverUrl)
         try encoderContainer.encode(status, forKey: .status)
         try encoderContainer.encode(fileSize, forKey: .fileSize)
         try encoderContainer.encode(checksum, forKey: .checksum)
         try encoderContainer.encode(duration, forKey: .duration)
         try encoderContainer.encode(tags, forKey: .tags)
         try encoderContainer.encode(categoryId, forKey: .categoryId)
         try encoderContainer.encode(categoryName, forKey: .categoryName)
         try encoderContainer.encode(snapshots, forKey: .snapshots)
         try encoderContainer.encode(createTime, forKey: .createTime)
         try encoderContainer.encode(updateTime, forKey: .updateTime)
    }
}
///  updateVideoRequestObject
public class UpdateVideoRequestObject:NSObject,Codable{
    /// 视频名称
    var name:String?
    /// 分类ID
    var categoryId:Int64?
    /// 标签
    var tags:[String?]?
    /// 封面地址
    var coverUrl:String?
    /// 视频描述信息
    var descriptionValue:String?



    public override init(){
            super.init()
    }

    enum UpdateVideoRequestObjectCodingKeys: String, CodingKey {
        case name
        case categoryId
        case tags
        case coverUrl
        case descriptionValue = "description"
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: UpdateVideoRequestObjectCodingKeys.self)
        if decoderContainer.contains(.name)
        {
            self.name = try decoderContainer.decode(String?.self, forKey: .name)
        }
        if decoderContainer.contains(.categoryId)
        {
            self.categoryId = try decoderContainer.decode(Int64?.self, forKey: .categoryId)
        }
        if decoderContainer.contains(.tags)
        {
            self.tags = try decoderContainer.decode([String?]?.self, forKey: .tags)
        }
        if decoderContainer.contains(.coverUrl)
        {
            self.coverUrl = try decoderContainer.decode(String?.self, forKey: .coverUrl)
        }
        if decoderContainer.contains(.descriptionValue)
        {
            self.descriptionValue = try decoderContainer.decode(String?.self, forKey: .descriptionValue)
        }
    }
}
public extension UpdateVideoRequestObject{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: UpdateVideoRequestObjectCodingKeys.self)
         try encoderContainer.encode(name, forKey: .name)
         try encoderContainer.encode(categoryId, forKey: .categoryId)
         try encoderContainer.encode(tags, forKey: .tags)
         try encoderContainer.encode(coverUrl, forKey: .coverUrl)
         try encoderContainer.encode(descriptionValue, forKey: .descriptionValue)
    }
}
///  batchChangeCategoryRequestObject
public class BatchChangeCategoryRequestObject:NSObject,Codable{
    /// 分类ID
    var categoryId:Int64?
    /// 视频分类ID列表
    var videoIds:[String?]?



    public override init(){
            super.init()
    }

    enum BatchChangeCategoryRequestObjectCodingKeys: String, CodingKey {
        case categoryId
        case videoIds
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: BatchChangeCategoryRequestObjectCodingKeys.self)
        if decoderContainer.contains(.categoryId)
        {
            self.categoryId = try decoderContainer.decode(Int64?.self, forKey: .categoryId)
        }
        if decoderContainer.contains(.videoIds)
        {
            self.videoIds = try decoderContainer.decode([String?]?.self, forKey: .videoIds)
        }
    }
}
public extension BatchChangeCategoryRequestObject{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: BatchChangeCategoryRequestObjectCodingKeys.self)
         try encoderContainer.encode(categoryId, forKey: .categoryId)
         try encoderContainer.encode(videoIds, forKey: .videoIds)
    }
}
///  视频播放信息
public class VideoPlayInfo:NSObject,Codable{
    /// 生成播放信息的转码任务ID
    var taskId:String?
    /// 清晰度规格标记。取值范围：
      ///   SD - 标清
      ///   HD - 高清
      ///   FHD - 超清
      ///   2K
      ///   4K
      /// 
    var definition:String?
    /// 媒体类型
    var mediaType:Int?
    /// 播放信息状态，目前只有正常状态(normal)
    var status:String?
    /// CDN地址，原始地址或者鉴权地址
    var url:String?
    /// Size
    var size:Int64?
    /// 视频时长
    var duration:Int64?
    /// 码率
    var bitrate:Int64?
    /// 编码格式
    var codec:String?
    /// 封装格式
    var format:String?
    /// 视频宽度
    var width:Int?
    /// 视频高度
    var height:Int?
    /// 视频帧率
    var fps:String?
    /// CreateTime
    var createTime:String?
    /// UpdateTime
    var updateTime:String?



    public override init(){
            super.init()
    }

    enum VideoPlayInfoCodingKeys: String, CodingKey {
        case taskId
        case definition
        case mediaType
        case status
        case url
        case size
        case duration
        case bitrate
        case codec
        case format
        case width
        case height
        case fps
        case createTime
        case updateTime
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: VideoPlayInfoCodingKeys.self)
        if decoderContainer.contains(.taskId)
        {
            self.taskId = try decoderContainer.decode(String?.self, forKey: .taskId)
        }
        if decoderContainer.contains(.definition)
        {
            self.definition = try decoderContainer.decode(String?.self, forKey: .definition)
        }
        if decoderContainer.contains(.mediaType)
        {
            self.mediaType = try decoderContainer.decode(Int?.self, forKey: .mediaType)
        }
        if decoderContainer.contains(.status)
        {
            self.status = try decoderContainer.decode(String?.self, forKey: .status)
        }
        if decoderContainer.contains(.url)
        {
            self.url = try decoderContainer.decode(String?.self, forKey: .url)
        }
        if decoderContainer.contains(.size)
        {
            self.size = try decoderContainer.decode(Int64?.self, forKey: .size)
        }
        if decoderContainer.contains(.duration)
        {
            self.duration = try decoderContainer.decode(Int64?.self, forKey: .duration)
        }
        if decoderContainer.contains(.bitrate)
        {
            self.bitrate = try decoderContainer.decode(Int64?.self, forKey: .bitrate)
        }
        if decoderContainer.contains(.codec)
        {
            self.codec = try decoderContainer.decode(String?.self, forKey: .codec)
        }
        if decoderContainer.contains(.format)
        {
            self.format = try decoderContainer.decode(String?.self, forKey: .format)
        }
        if decoderContainer.contains(.width)
        {
            self.width = try decoderContainer.decode(Int?.self, forKey: .width)
        }
        if decoderContainer.contains(.height)
        {
            self.height = try decoderContainer.decode(Int?.self, forKey: .height)
        }
        if decoderContainer.contains(.fps)
        {
            self.fps = try decoderContainer.decode(String?.self, forKey: .fps)
        }
        if decoderContainer.contains(.createTime)
        {
            self.createTime = try decoderContainer.decode(String?.self, forKey: .createTime)
        }
        if decoderContainer.contains(.updateTime)
        {
            self.updateTime = try decoderContainer.decode(String?.self, forKey: .updateTime)
        }
    }
}
public extension VideoPlayInfo{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: VideoPlayInfoCodingKeys.self)
         try encoderContainer.encode(taskId, forKey: .taskId)
         try encoderContainer.encode(definition, forKey: .definition)
         try encoderContainer.encode(mediaType, forKey: .mediaType)
         try encoderContainer.encode(status, forKey: .status)
         try encoderContainer.encode(url, forKey: .url)
         try encoderContainer.encode(size, forKey: .size)
         try encoderContainer.encode(duration, forKey: .duration)
         try encoderContainer.encode(bitrate, forKey: .bitrate)
         try encoderContainer.encode(codec, forKey: .codec)
         try encoderContainer.encode(format, forKey: .format)
         try encoderContainer.encode(width, forKey: .width)
         try encoderContainer.encode(height, forKey: .height)
         try encoderContainer.encode(fps, forKey: .fps)
         try encoderContainer.encode(createTime, forKey: .createTime)
         try encoderContainer.encode(updateTime, forKey: .updateTime)
    }
}
///  删除视频转码流请求
public class DeleteVideoStreamsRequestObject:NSObject,Codable{
    /// TaskIds
    /// Required:true
    var taskIds:[Int64?]?



    public  init(taskIds:[Int64?]?){
             self.taskIds = taskIds
    }

    enum DeleteVideoStreamsRequestObjectCodingKeys: String, CodingKey {
        case taskIds
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: DeleteVideoStreamsRequestObjectCodingKeys.self)
        self.taskIds = try decoderContainer.decode([Int64?]?.self, forKey: .taskIds)
    }
}
public extension DeleteVideoStreamsRequestObject{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: DeleteVideoStreamsRequestObjectCodingKeys.self)
         try encoderContainer.encode(taskIds, forKey: .taskIds)
    }
}
///  删除视频转码流结果
public class DeleteVideoStreamsResultObject:NSObject,Codable{
    /// 删除成功的转码任务ID列表
    var okTaskIds:[Int64?]?
    /// 未找到的转码任务ID列表
    var notFoundTaskIds:[Int64?]?
    /// 删除失败的转码任务ID列表
    var failedTaskIds:[Int64?]?



    public override init(){
            super.init()
    }

    enum DeleteVideoStreamsResultObjectCodingKeys: String, CodingKey {
        case okTaskIds
        case notFoundTaskIds
        case failedTaskIds
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: DeleteVideoStreamsResultObjectCodingKeys.self)
        if decoderContainer.contains(.okTaskIds)
        {
            self.okTaskIds = try decoderContainer.decode([Int64?]?.self, forKey: .okTaskIds)
        }
        if decoderContainer.contains(.notFoundTaskIds)
        {
            self.notFoundTaskIds = try decoderContainer.decode([Int64?]?.self, forKey: .notFoundTaskIds)
        }
        if decoderContainer.contains(.failedTaskIds)
        {
            self.failedTaskIds = try decoderContainer.decode([Int64?]?.self, forKey: .failedTaskIds)
        }
    }
}
public extension DeleteVideoStreamsResultObject{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: DeleteVideoStreamsResultObjectCodingKeys.self)
         try encoderContainer.encode(okTaskIds, forKey: .okTaskIds)
         try encoderContainer.encode(notFoundTaskIds, forKey: .notFoundTaskIds)
         try encoderContainer.encode(failedTaskIds, forKey: .failedTaskIds)
    }
}
///  批量删除视频结果
public class BatchDeleteVideosResultObject:NSObject,Codable{
    /// 删除成功的视频ID集合
    var okVideoIds:[String?]?
    /// 未找到的视频ID集合
    var notFoundVideoIds:[String?]?
    /// 删除失败的视频ID集合
    var failedVideoIds:[String?]?



    public override init(){
            super.init()
    }

    enum BatchDeleteVideosResultObjectCodingKeys: String, CodingKey {
        case okVideoIds
        case notFoundVideoIds
        case failedVideoIds
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: BatchDeleteVideosResultObjectCodingKeys.self)
        if decoderContainer.contains(.okVideoIds)
        {
            self.okVideoIds = try decoderContainer.decode([String?]?.self, forKey: .okVideoIds)
        }
        if decoderContainer.contains(.notFoundVideoIds)
        {
            self.notFoundVideoIds = try decoderContainer.decode([String?]?.self, forKey: .notFoundVideoIds)
        }
        if decoderContainer.contains(.failedVideoIds)
        {
            self.failedVideoIds = try decoderContainer.decode([String?]?.self, forKey: .failedVideoIds)
        }
    }
}
public extension BatchDeleteVideosResultObject{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: BatchDeleteVideosResultObjectCodingKeys.self)
         try encoderContainer.encode(okVideoIds, forKey: .okVideoIds)
         try encoderContainer.encode(notFoundVideoIds, forKey: .notFoundVideoIds)
         try encoderContainer.encode(failedVideoIds, forKey: .failedVideoIds)
    }
}
///  批量修改视频信息请求
public class BatchUpdateVideosRequestObject:NSObject,Codable{
    /// 批量更新视频的条目集合
    /// Required:true
    var bulkItems:[BatchUpdateVideosBulkItem?]?



    public  init(bulkItems:[BatchUpdateVideosBulkItem?]?){
             self.bulkItems = bulkItems
    }

    enum BatchUpdateVideosRequestObjectCodingKeys: String, CodingKey {
        case bulkItems
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: BatchUpdateVideosRequestObjectCodingKeys.self)
        self.bulkItems = try decoderContainer.decode([BatchUpdateVideosBulkItem?]?.self, forKey: .bulkItems)
    }
}
public extension BatchUpdateVideosRequestObject{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: BatchUpdateVideosRequestObjectCodingKeys.self)
         try encoderContainer.encode(bulkItems, forKey: .bulkItems)
    }
}
///  批量修改视频的条目信息
public class BatchUpdateVideosBulkItem:NSObject,Codable{
    /// 视频ID
    var videoId:String?
    /// 视频名称
    var name:String?
    /// 分类ID
    var categoryId:Int64?
    /// 视频标签
    var tags:[String?]?
    /// 封面图地址
    var coverUrl:String?
    /// 视频描述信息
    var descriptionValue:String?



    public override init(){
            super.init()
    }

    enum BatchUpdateVideosBulkItemCodingKeys: String, CodingKey {
        case videoId
        case name
        case categoryId
        case tags
        case coverUrl
        case descriptionValue = "description"
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: BatchUpdateVideosBulkItemCodingKeys.self)
        if decoderContainer.contains(.videoId)
        {
            self.videoId = try decoderContainer.decode(String?.self, forKey: .videoId)
        }
        if decoderContainer.contains(.name)
        {
            self.name = try decoderContainer.decode(String?.self, forKey: .name)
        }
        if decoderContainer.contains(.categoryId)
        {
            self.categoryId = try decoderContainer.decode(Int64?.self, forKey: .categoryId)
        }
        if decoderContainer.contains(.tags)
        {
            self.tags = try decoderContainer.decode([String?]?.self, forKey: .tags)
        }
        if decoderContainer.contains(.coverUrl)
        {
            self.coverUrl = try decoderContainer.decode(String?.self, forKey: .coverUrl)
        }
        if decoderContainer.contains(.descriptionValue)
        {
            self.descriptionValue = try decoderContainer.decode(String?.self, forKey: .descriptionValue)
        }
    }
}
public extension BatchUpdateVideosBulkItem{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: BatchUpdateVideosBulkItemCodingKeys.self)
         try encoderContainer.encode(videoId, forKey: .videoId)
         try encoderContainer.encode(name, forKey: .name)
         try encoderContainer.encode(categoryId, forKey: .categoryId)
         try encoderContainer.encode(tags, forKey: .tags)
         try encoderContainer.encode(coverUrl, forKey: .coverUrl)
         try encoderContainer.encode(descriptionValue, forKey: .descriptionValue)
    }
}
///  查询视频列表信息结果
public class ListVideosResultObject:NSObject,Codable{
    /// 当前页码
    var pageNumber:Int?
    /// 每页数量
    var pageSize:Int?
    /// 查询总数
    var totalElements:Int?
    /// 总页数
    var totalPages:Int?
    /// 分页内容
    var content:[VideoObject?]?



    public override init(){
            super.init()
    }

    enum ListVideosResultObjectCodingKeys: String, CodingKey {
        case pageNumber
        case pageSize
        case totalElements
        case totalPages
        case content
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: ListVideosResultObjectCodingKeys.self)
        if decoderContainer.contains(.pageNumber)
        {
            self.pageNumber = try decoderContainer.decode(Int?.self, forKey: .pageNumber)
        }
        if decoderContainer.contains(.pageSize)
        {
            self.pageSize = try decoderContainer.decode(Int?.self, forKey: .pageSize)
        }
        if decoderContainer.contains(.totalElements)
        {
            self.totalElements = try decoderContainer.decode(Int?.self, forKey: .totalElements)
        }
        if decoderContainer.contains(.totalPages)
        {
            self.totalPages = try decoderContainer.decode(Int?.self, forKey: .totalPages)
        }
        if decoderContainer.contains(.content)
        {
            self.content = try decoderContainer.decode([VideoObject?]?.self, forKey: .content)
        }
    }
}
public extension ListVideosResultObject{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: ListVideosResultObjectCodingKeys.self)
         try encoderContainer.encode(pageNumber, forKey: .pageNumber)
         try encoderContainer.encode(pageSize, forKey: .pageSize)
         try encoderContainer.encode(totalElements, forKey: .totalElements)
         try encoderContainer.encode(totalPages, forKey: .totalPages)
         try encoderContainer.encode(content, forKey: .content)
    }
}
///  批量删除视频请求
public class BatchDeleteVideosRequestObject:NSObject,Codable{
    /// 视频ID集合
    /// Required:true
    var videoIds:[String?]?



    public  init(videoIds:[String?]?){
             self.videoIds = videoIds
    }

    enum BatchDeleteVideosRequestObjectCodingKeys: String, CodingKey {
        case videoIds
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: BatchDeleteVideosRequestObjectCodingKeys.self)
        self.videoIds = try decoderContainer.decode([String?]?.self, forKey: .videoIds)
    }
}
public extension BatchDeleteVideosRequestObject{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: BatchDeleteVideosRequestObjectCodingKeys.self)
         try encoderContainer.encode(videoIds, forKey: .videoIds)
    }
}
///  batchChangeCategoryResultObject
public class BatchChangeCategoryResultObject:NSObject,Codable{
    /// 操作成功的视频ID列表
    var okVideoIds:[String?]?
    /// 未找到的视频ID列表
    var notFoundVideoIds:[String?]?



    public override init(){
            super.init()
    }

    enum BatchChangeCategoryResultObjectCodingKeys: String, CodingKey {
        case okVideoIds
        case notFoundVideoIds
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: BatchChangeCategoryResultObjectCodingKeys.self)
        if decoderContainer.contains(.okVideoIds)
        {
            self.okVideoIds = try decoderContainer.decode([String?]?.self, forKey: .okVideoIds)
        }
        if decoderContainer.contains(.notFoundVideoIds)
        {
            self.notFoundVideoIds = try decoderContainer.decode([String?]?.self, forKey: .notFoundVideoIds)
        }
    }
}
public extension BatchChangeCategoryResultObject{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: BatchChangeCategoryResultObjectCodingKeys.self)
         try encoderContainer.encode(okVideoIds, forKey: .okVideoIds)
         try encoderContainer.encode(notFoundVideoIds, forKey: .notFoundVideoIds)
    }
}
///  uploadTask
public class UploadTask:NSObject,Codable{
    /// 任务ID
    var taskId:Int64?
    /// 视频名称
    var name:String?
    /// 分类ID
    var categoryId:Int64?
    /// 分类名称
    var category:String?
    /// 格式
    var format:String?
    /// 文件大小
    var size:Int64?
    /// 上传状态
    var status:Int?



    public override init(){
            super.init()
    }

    enum UploadTaskCodingKeys: String, CodingKey {
        case taskId
        case name
        case categoryId
        case category
        case format
        case size
        case status
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: UploadTaskCodingKeys.self)
        if decoderContainer.contains(.taskId)
        {
            self.taskId = try decoderContainer.decode(Int64?.self, forKey: .taskId)
        }
        if decoderContainer.contains(.name)
        {
            self.name = try decoderContainer.decode(String?.self, forKey: .name)
        }
        if decoderContainer.contains(.categoryId)
        {
            self.categoryId = try decoderContainer.decode(Int64?.self, forKey: .categoryId)
        }
        if decoderContainer.contains(.category)
        {
            self.category = try decoderContainer.decode(String?.self, forKey: .category)
        }
        if decoderContainer.contains(.format)
        {
            self.format = try decoderContainer.decode(String?.self, forKey: .format)
        }
        if decoderContainer.contains(.size)
        {
            self.size = try decoderContainer.decode(Int64?.self, forKey: .size)
        }
        if decoderContainer.contains(.status)
        {
            self.status = try decoderContainer.decode(Int?.self, forKey: .status)
        }
    }
}
public extension UploadTask{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: UploadTaskCodingKeys.self)
         try encoderContainer.encode(taskId, forKey: .taskId)
         try encoderContainer.encode(name, forKey: .name)
         try encoderContainer.encode(categoryId, forKey: .categoryId)
         try encoderContainer.encode(category, forKey: .category)
         try encoderContainer.encode(format, forKey: .format)
         try encoderContainer.encode(size, forKey: .size)
         try encoderContainer.encode(status, forKey: .status)
    }
}
///  修改水印请求信息
public class UpdateWatermarkRequestObject:NSObject,Codable{
    /// 水印名称。只支持中英文、数字。长度不超过128个字符。UTF-8编码。
      /// 
    var name:String?
    /// 图片地址
    var imgUrl:String?
    /// 水印宽度。
      /// 当 sizeUnit &#x3D; pixel 时，取值范围为 [8, 4096] 整数
      /// 当 sizeUnit &#x3D; percent 时，取值范围为 [0, 100] 小数
      /// 
    var width:String?
    /// 水印高度。
      /// 当 sizeUnit &#x3D; pixel 时，取值范围为 [8, 4096] 整数
      /// 当 sizeUnit &#x3D; percent 时，取值范围为 [0, 100] 小数
      /// 
    var height:String?
    /// 尺寸单位。取值范围：
      ///   pixel - 像素
      ///   percent - 百分比
      /// 默认值为 pixel
      /// 
    var sizeUnit:String?
    /// 水印位置。取值范围：
      ///   LT - 左上
      ///   RT - 右上
      ///   LB - 左下
      ///   RB - 右下
      /// 
    var position:String?
    /// 水平偏移。
      /// 当 offsetUnit &#x3D; pixel 时，取值范围为 [8, 4088] 整数
      /// 当 offsetUnit &#x3D; percent 时，取值范围为 [0, 100] 小数
      /// 
    var offsetX:String?
    /// 竖直偏移。
      /// 当 offsetUnit &#x3D; pixel 时，取值范围为 [8, 4088] 整数
      /// 当 offsetUnit &#x3D; percent 时，取值范围为 [0, 100] 小数
      /// 
    var offsetY:String?
    /// 偏移单位。取值范围：
      ///   pixel - 像素
      ///   percent - 百分比
      /// 默认值为 pixel
      /// 
    var offsetUnit:String?



    public override init(){
            super.init()
    }

    enum UpdateWatermarkRequestObjectCodingKeys: String, CodingKey {
        case name
        case imgUrl
        case width
        case height
        case sizeUnit
        case position
        case offsetX
        case offsetY
        case offsetUnit
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: UpdateWatermarkRequestObjectCodingKeys.self)
        if decoderContainer.contains(.name)
        {
            self.name = try decoderContainer.decode(String?.self, forKey: .name)
        }
        if decoderContainer.contains(.imgUrl)
        {
            self.imgUrl = try decoderContainer.decode(String?.self, forKey: .imgUrl)
        }
        if decoderContainer.contains(.width)
        {
            self.width = try decoderContainer.decode(String?.self, forKey: .width)
        }
        if decoderContainer.contains(.height)
        {
            self.height = try decoderContainer.decode(String?.self, forKey: .height)
        }
        if decoderContainer.contains(.sizeUnit)
        {
            self.sizeUnit = try decoderContainer.decode(String?.self, forKey: .sizeUnit)
        }
        if decoderContainer.contains(.position)
        {
            self.position = try decoderContainer.decode(String?.self, forKey: .position)
        }
        if decoderContainer.contains(.offsetX)
        {
            self.offsetX = try decoderContainer.decode(String?.self, forKey: .offsetX)
        }
        if decoderContainer.contains(.offsetY)
        {
            self.offsetY = try decoderContainer.decode(String?.self, forKey: .offsetY)
        }
        if decoderContainer.contains(.offsetUnit)
        {
            self.offsetUnit = try decoderContainer.decode(String?.self, forKey: .offsetUnit)
        }
    }
}
public extension UpdateWatermarkRequestObject{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: UpdateWatermarkRequestObjectCodingKeys.self)
         try encoderContainer.encode(name, forKey: .name)
         try encoderContainer.encode(imgUrl, forKey: .imgUrl)
         try encoderContainer.encode(width, forKey: .width)
         try encoderContainer.encode(height, forKey: .height)
         try encoderContainer.encode(sizeUnit, forKey: .sizeUnit)
         try encoderContainer.encode(position, forKey: .position)
         try encoderContainer.encode(offsetX, forKey: .offsetX)
         try encoderContainer.encode(offsetY, forKey: .offsetY)
         try encoderContainer.encode(offsetUnit, forKey: .offsetUnit)
    }
}
///  查询水印列表信息结果
public class ListWatermarksResultObject:NSObject,Codable{
    /// 当前页码
    var pageNumber:Int?
    /// 每页数量
    var pageSize:Int?
    /// 查询总数
    var totalElements:Int?
    /// 总页数
    var totalPages:Int?
    /// 分页内容
    var content:[WatermarkObject?]?



    public override init(){
            super.init()
    }

    enum ListWatermarksResultObjectCodingKeys: String, CodingKey {
        case pageNumber
        case pageSize
        case totalElements
        case totalPages
        case content
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: ListWatermarksResultObjectCodingKeys.self)
        if decoderContainer.contains(.pageNumber)
        {
            self.pageNumber = try decoderContainer.decode(Int?.self, forKey: .pageNumber)
        }
        if decoderContainer.contains(.pageSize)
        {
            self.pageSize = try decoderContainer.decode(Int?.self, forKey: .pageSize)
        }
        if decoderContainer.contains(.totalElements)
        {
            self.totalElements = try decoderContainer.decode(Int?.self, forKey: .totalElements)
        }
        if decoderContainer.contains(.totalPages)
        {
            self.totalPages = try decoderContainer.decode(Int?.self, forKey: .totalPages)
        }
        if decoderContainer.contains(.content)
        {
            self.content = try decoderContainer.decode([WatermarkObject?]?.self, forKey: .content)
        }
    }
}
public extension ListWatermarksResultObject{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: ListWatermarksResultObjectCodingKeys.self)
         try encoderContainer.encode(pageNumber, forKey: .pageNumber)
         try encoderContainer.encode(pageSize, forKey: .pageSize)
         try encoderContainer.encode(totalElements, forKey: .totalElements)
         try encoderContainer.encode(totalPages, forKey: .totalPages)
         try encoderContainer.encode(content, forKey: .content)
    }
}
///  查询水印响应信息
public class WatermarkObject:NSObject,Codable{
    /// 水印ID
    var id:Int64?
    /// 水印名称。只支持中英文、数字。长度不超过128个字符。UTF-8编码。
      /// 
    var name:String?
    /// 图片地址
    var imgUrl:String?
    /// 水印宽度。
      /// 当 sizeUnit &#x3D; pixel 时，取值范围为 [8, 4096] 整数
      /// 当 sizeUnit &#x3D; percent 时，取值范围为 [0, 100] 小数
      /// 
    var width:String?
    /// 水印高度。
      /// 当 sizeUnit &#x3D; pixel 时，取值范围为 [8, 4096] 整数
      /// 当 sizeUnit &#x3D; percent 时，取值范围为 [0, 100] 小数
      /// 
    var height:String?
    /// 尺寸单位。取值范围：
      ///   pixel - 像素
      ///   percent - 百分比
      /// 默认值为 pixel
      /// 
    var sizeUnit:String?
    /// 水印位置。取值范围：
      ///   LT - 左上
      ///   RT - 右上
      ///   LB - 左下
      ///   RB - 右下
    var position:String?
    /// 水平偏移。
      /// 当 offsetUnit &#x3D; pixel 时，取值范围为 [8, 4088] 整数
      /// 当 offsetUnit &#x3D; percent 时，取值范围为 [0, 100] 小数
      /// 
    var offsetX:String?
    /// 竖直偏移。
      /// 当 offsetUnit &#x3D; pixel 时，取值范围为 [8, 4088] 整数
      /// 当 offsetUnit &#x3D; percent 时，取值范围为 [0, 100] 小数
      /// 
    var offsetY:String?
    /// 偏移单位。取值范围：
      ///   pixel - 像素
      ///   percent - 百分比
      /// 默认值为 pixel
      /// 
    var offsetUnit:String?
    /// 创建时间
    var createTime:String?
    /// 修改时间
    var updateTime:String?



    public override init(){
            super.init()
    }

    enum WatermarkObjectCodingKeys: String, CodingKey {
        case id
        case name
        case imgUrl
        case width
        case height
        case sizeUnit
        case position
        case offsetX
        case offsetY
        case offsetUnit
        case createTime
        case updateTime
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: WatermarkObjectCodingKeys.self)
        if decoderContainer.contains(.id)
        {
            self.id = try decoderContainer.decode(Int64?.self, forKey: .id)
        }
        if decoderContainer.contains(.name)
        {
            self.name = try decoderContainer.decode(String?.self, forKey: .name)
        }
        if decoderContainer.contains(.imgUrl)
        {
            self.imgUrl = try decoderContainer.decode(String?.self, forKey: .imgUrl)
        }
        if decoderContainer.contains(.width)
        {
            self.width = try decoderContainer.decode(String?.self, forKey: .width)
        }
        if decoderContainer.contains(.height)
        {
            self.height = try decoderContainer.decode(String?.self, forKey: .height)
        }
        if decoderContainer.contains(.sizeUnit)
        {
            self.sizeUnit = try decoderContainer.decode(String?.self, forKey: .sizeUnit)
        }
        if decoderContainer.contains(.position)
        {
            self.position = try decoderContainer.decode(String?.self, forKey: .position)
        }
        if decoderContainer.contains(.offsetX)
        {
            self.offsetX = try decoderContainer.decode(String?.self, forKey: .offsetX)
        }
        if decoderContainer.contains(.offsetY)
        {
            self.offsetY = try decoderContainer.decode(String?.self, forKey: .offsetY)
        }
        if decoderContainer.contains(.offsetUnit)
        {
            self.offsetUnit = try decoderContainer.decode(String?.self, forKey: .offsetUnit)
        }
        if decoderContainer.contains(.createTime)
        {
            self.createTime = try decoderContainer.decode(String?.self, forKey: .createTime)
        }
        if decoderContainer.contains(.updateTime)
        {
            self.updateTime = try decoderContainer.decode(String?.self, forKey: .updateTime)
        }
    }
}
public extension WatermarkObject{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: WatermarkObjectCodingKeys.self)
         try encoderContainer.encode(id, forKey: .id)
         try encoderContainer.encode(name, forKey: .name)
         try encoderContainer.encode(imgUrl, forKey: .imgUrl)
         try encoderContainer.encode(width, forKey: .width)
         try encoderContainer.encode(height, forKey: .height)
         try encoderContainer.encode(sizeUnit, forKey: .sizeUnit)
         try encoderContainer.encode(position, forKey: .position)
         try encoderContainer.encode(offsetX, forKey: .offsetX)
         try encoderContainer.encode(offsetY, forKey: .offsetY)
         try encoderContainer.encode(offsetUnit, forKey: .offsetUnit)
         try encoderContainer.encode(createTime, forKey: .createTime)
         try encoderContainer.encode(updateTime, forKey: .updateTime)
    }
}
///  创建水印请求信息
public class CreateWatermarkRequestObject:NSObject,Codable{
    /// 水印名称。只支持中英文、数字。长度不超过128个字符。UTF-8编码。
      /// 
    /// Required:true
    var name:String
    /// 图片地址
    /// Required:true
    var imgUrl:String
    /// 水印宽度。
      /// 当 sizeUnit &#x3D; pixel 时，取值范围为 [8, 4096] 整数
      /// 当 sizeUnit &#x3D; percent 时，取值范围为 [0, 100] 小数
      /// 
    /// Required:true
    var width:String
    /// 水印高度。
      /// 当 sizeUnit &#x3D; pixel 时，取值范围为 [8, 4096] 整数
      /// 当 sizeUnit &#x3D; percent 时，取值范围为 [0, 100] 小数
      /// 
    /// Required:true
    var height:String
    /// 尺寸单位。取值范围：
      ///   pixel - 像素
      ///   percent - 百分比
      /// 默认值为 pixel
      /// 
    var sizeUnit:String?
    /// 水印位置。取值范围：
      ///   LT - 左上
      ///   RT - 右上
      ///   LB - 左下
      ///   RB - 右下
      /// 
    /// Required:true
    var position:String
    /// 水平偏移。
      /// 当 offsetUnit &#x3D; pixel 时，取值范围为 [8, 4088] 整数
      /// 当 offsetUnit &#x3D; percent 时，取值范围为 [0, 100] 小数
      /// 
    /// Required:true
    var offsetX:String
    /// 竖直偏移。
      /// 当 offsetUnit &#x3D; pixel 时，取值范围为 [8, 4088] 整数
      /// 当 offsetUnit &#x3D; percent 时，取值范围为 [0, 100] 小数
      /// 
    /// Required:true
    var offsetY:String
    /// 偏移单位。取值范围：
      ///   pixel - 像素
      ///   percent - 百分比
      /// 默认值为 pixel
      /// 
    var offsetUnit:String?



    public  init(name:String,imgUrl:String,width:String,height:String,position:String,offsetX:String,offsetY:String){
             self.name = name
             self.imgUrl = imgUrl
             self.width = width
             self.height = height
             self.position = position
             self.offsetX = offsetX
             self.offsetY = offsetY
    }

    enum CreateWatermarkRequestObjectCodingKeys: String, CodingKey {
        case name
        case imgUrl
        case width
        case height
        case sizeUnit
        case position
        case offsetX
        case offsetY
        case offsetUnit
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: CreateWatermarkRequestObjectCodingKeys.self)
        self.name = try decoderContainer.decode(String.self, forKey: .name)
        self.imgUrl = try decoderContainer.decode(String.self, forKey: .imgUrl)
        self.width = try decoderContainer.decode(String.self, forKey: .width)
        self.height = try decoderContainer.decode(String.self, forKey: .height)
        if decoderContainer.contains(.sizeUnit)
        {
            self.sizeUnit = try decoderContainer.decode(String?.self, forKey: .sizeUnit)
        }
        self.position = try decoderContainer.decode(String.self, forKey: .position)
        self.offsetX = try decoderContainer.decode(String.self, forKey: .offsetX)
        self.offsetY = try decoderContainer.decode(String.self, forKey: .offsetY)
        if decoderContainer.contains(.offsetUnit)
        {
            self.offsetUnit = try decoderContainer.decode(String?.self, forKey: .offsetUnit)
        }
    }
}
public extension CreateWatermarkRequestObject{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: CreateWatermarkRequestObjectCodingKeys.self)
         try encoderContainer.encode(name, forKey: .name)
         try encoderContainer.encode(imgUrl, forKey: .imgUrl)
         try encoderContainer.encode(width, forKey: .width)
         try encoderContainer.encode(height, forKey: .height)
         try encoderContainer.encode(sizeUnit, forKey: .sizeUnit)
         try encoderContainer.encode(position, forKey: .position)
         try encoderContainer.encode(offsetX, forKey: .offsetX)
         try encoderContainer.encode(offsetY, forKey: .offsetY)
         try encoderContainer.encode(offsetUnit, forKey: .offsetUnit)
    }
}
///  视频上传地址和凭证
public class VideoUploadTaskObject:NSObject,Codable{
    /// 视频ID
    var videoId:String?
    /// 视频上传地址
    var uploadUrl:String?



    public override init(){
            super.init()
    }

    enum VideoUploadTaskObjectCodingKeys: String, CodingKey {
        case videoId
        case uploadUrl
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: VideoUploadTaskObjectCodingKeys.self)
        if decoderContainer.contains(.videoId)
        {
            self.videoId = try decoderContainer.decode(String?.self, forKey: .videoId)
        }
        if decoderContainer.contains(.uploadUrl)
        {
            self.uploadUrl = try decoderContainer.decode(String?.self, forKey: .uploadUrl)
        }
    }
}
public extension VideoUploadTaskObject{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: VideoUploadTaskObjectCodingKeys.self)
         try encoderContainer.encode(videoId, forKey: .videoId)
         try encoderContainer.encode(uploadUrl, forKey: .uploadUrl)
    }
}
///  获取图片上传地址和凭证请求
public class CreateImageUploadTaskRequestObject:NSObject,Codable{
    /// HTTP 请求方法，取值范围：GET、POST、PUT、DELETE、HEAD、PATCH，默认值为 PUT
    var httpMethod:String?
    /// 文件名称
    var fileName:String?
    /// 文件大小
    var fileSize:Int64?



    public override init(){
            super.init()
    }

    enum CreateImageUploadTaskRequestObjectCodingKeys: String, CodingKey {
        case httpMethod
        case fileName
        case fileSize
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: CreateImageUploadTaskRequestObjectCodingKeys.self)
        if decoderContainer.contains(.httpMethod)
        {
            self.httpMethod = try decoderContainer.decode(String?.self, forKey: .httpMethod)
        }
        if decoderContainer.contains(.fileName)
        {
            self.fileName = try decoderContainer.decode(String?.self, forKey: .fileName)
        }
        if decoderContainer.contains(.fileSize)
        {
            self.fileSize = try decoderContainer.decode(Int64?.self, forKey: .fileSize)
        }
    }
}
public extension CreateImageUploadTaskRequestObject{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: CreateImageUploadTaskRequestObjectCodingKeys.self)
         try encoderContainer.encode(httpMethod, forKey: .httpMethod)
         try encoderContainer.encode(fileName, forKey: .fileName)
         try encoderContainer.encode(fileSize, forKey: .fileSize)
    }
}
///  获取视频上传地址和凭证请求
public class CreateVideoUploadTaskRequestObject:NSObject,Codable{
    /// HTTP 请求方法，取值范围：GET、POST、PUT、DELETE、HEAD、PATCH，默认值为 PUT
    var httpMethod:String?
    /// 视频标题
    var title:String?
    /// 文件名称
    var fileName:String?
    /// 文件大小
    var fileSize:Int64?
    /// 封面地址
    var coverUrl:String?
    /// 视频描述
    var descriptionValue:String?
    /// 分类ID
    var categoryId:Int64?
    /// 视频标签集合
    var tags:[String?]?
    /// 转码模板ID集合
    var transcodeTemplateIds:[Int64?]?
    /// 水印ID集合
    var watermarkIds:[Int64?]?



    public override init(){
            super.init()
    }

    enum CreateVideoUploadTaskRequestObjectCodingKeys: String, CodingKey {
        case httpMethod
        case title
        case fileName
        case fileSize
        case coverUrl
        case descriptionValue = "description"
        case categoryId
        case tags
        case transcodeTemplateIds
        case watermarkIds
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: CreateVideoUploadTaskRequestObjectCodingKeys.self)
        if decoderContainer.contains(.httpMethod)
        {
            self.httpMethod = try decoderContainer.decode(String?.self, forKey: .httpMethod)
        }
        if decoderContainer.contains(.title)
        {
            self.title = try decoderContainer.decode(String?.self, forKey: .title)
        }
        if decoderContainer.contains(.fileName)
        {
            self.fileName = try decoderContainer.decode(String?.self, forKey: .fileName)
        }
        if decoderContainer.contains(.fileSize)
        {
            self.fileSize = try decoderContainer.decode(Int64?.self, forKey: .fileSize)
        }
        if decoderContainer.contains(.coverUrl)
        {
            self.coverUrl = try decoderContainer.decode(String?.self, forKey: .coverUrl)
        }
        if decoderContainer.contains(.descriptionValue)
        {
            self.descriptionValue = try decoderContainer.decode(String?.self, forKey: .descriptionValue)
        }
        if decoderContainer.contains(.categoryId)
        {
            self.categoryId = try decoderContainer.decode(Int64?.self, forKey: .categoryId)
        }
        if decoderContainer.contains(.tags)
        {
            self.tags = try decoderContainer.decode([String?]?.self, forKey: .tags)
        }
        if decoderContainer.contains(.transcodeTemplateIds)
        {
            self.transcodeTemplateIds = try decoderContainer.decode([Int64?]?.self, forKey: .transcodeTemplateIds)
        }
        if decoderContainer.contains(.watermarkIds)
        {
            self.watermarkIds = try decoderContainer.decode([Int64?]?.self, forKey: .watermarkIds)
        }
    }
}
public extension CreateVideoUploadTaskRequestObject{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: CreateVideoUploadTaskRequestObjectCodingKeys.self)
         try encoderContainer.encode(httpMethod, forKey: .httpMethod)
         try encoderContainer.encode(title, forKey: .title)
         try encoderContainer.encode(fileName, forKey: .fileName)
         try encoderContainer.encode(fileSize, forKey: .fileSize)
         try encoderContainer.encode(coverUrl, forKey: .coverUrl)
         try encoderContainer.encode(descriptionValue, forKey: .descriptionValue)
         try encoderContainer.encode(categoryId, forKey: .categoryId)
         try encoderContainer.encode(tags, forKey: .tags)
         try encoderContainer.encode(transcodeTemplateIds, forKey: .transcodeTemplateIds)
         try encoderContainer.encode(watermarkIds, forKey: .watermarkIds)
    }
}
///  图片上传地址和凭证
public class ImageUploadTaskObject:NSObject,Codable{
    /// 图片ID
    var imageId:String?
    /// 图片上传地址
    var uploadUrl:String?



    public override init(){
            super.init()
    }

    enum ImageUploadTaskObjectCodingKeys: String, CodingKey {
        case imageId
        case uploadUrl
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: ImageUploadTaskObjectCodingKeys.self)
        if decoderContainer.contains(.imageId)
        {
            self.imageId = try decoderContainer.decode(String?.self, forKey: .imageId)
        }
        if decoderContainer.contains(.uploadUrl)
        {
            self.uploadUrl = try decoderContainer.decode(String?.self, forKey: .uploadUrl)
        }
    }
}
public extension ImageUploadTaskObject{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: ImageUploadTaskObjectCodingKeys.self)
         try encoderContainer.encode(imageId, forKey: .imageId)
         try encoderContainer.encode(uploadUrl, forKey: .uploadUrl)
    }
}
///  areas
public class Areas:NSObject,Codable{
    /// Mainland
    var mainland:[BasicItem?]?
    /// Overseas
    var overseas:[BasicItem?]?



    public override init(){
            super.init()
    }

    enum AreasCodingKeys: String, CodingKey {
        case mainland
        case overseas
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: AreasCodingKeys.self)
        if decoderContainer.contains(.mainland)
        {
            self.mainland = try decoderContainer.decode([BasicItem?]?.self, forKey: .mainland)
        }
        if decoderContainer.contains(.overseas)
        {
            self.overseas = try decoderContainer.decode([BasicItem?]?.self, forKey: .overseas)
        }
    }
}
public extension Areas{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: AreasCodingKeys.self)
         try encoderContainer.encode(mainland, forKey: .mainland)
         try encoderContainer.encode(overseas, forKey: .overseas)
    }
}
///  simpleResponse
public class SimpleResponse:NSObject,Codable{
    /// Request ID
    var requestId:String?



    public override init(){
            super.init()
    }

    enum SimpleResponseCodingKeys: String, CodingKey {
        case requestId
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: SimpleResponseCodingKeys.self)
        if decoderContainer.contains(.requestId)
        {
            self.requestId = try decoderContainer.decode(String?.self, forKey: .requestId)
        }
    }
}
public extension SimpleResponse{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: SimpleResponseCodingKeys.self)
         try encoderContainer.encode(requestId, forKey: .requestId)
    }
}

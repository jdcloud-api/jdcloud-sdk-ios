/* Copyright 2018 JDCLOUD.COM

   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at

     http:#www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.

   Media Upload
   媒体上传相关接口

   OpenAPI spec version: v1
   Contact: 

   NOTE: This class is auto generated by the jdcloud code generator program.
 */


import Foundation
import JDCloudSDKCore

public class BatchSubmitQualityDetectionJobsResponse:NSObject,Codable
{
    var requestId:String?;

    var error:ServiceError?;

    var result:BatchSubmitQualityDetectionJobsResult?;

    enum BatchSubmitQualityDetectionJobsResponseCodingKeys: String, CodingKey {
        case requestId
        case error
        case result
    }

    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: BatchSubmitQualityDetectionJobsResponseCodingKeys.self)
        self.requestId = try decoderContainer.decodeIfPresent(String?.self, forKey: .requestId) ?? nil
        self.error = try decoderContainer.decodeIfPresent(ServiceError?.self, forKey: .error) ?? nil
        self.result = try decoderContainer.decodeIfPresent(BatchSubmitQualityDetectionJobsResult?.self, forKey: .result) ?? nil
    }
}

public extension BatchSubmitQualityDetectionJobsResponse{
        func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: BatchSubmitQualityDetectionJobsResponseCodingKeys.self)
        try encoderContainer.encode(requestId, forKey: .requestId)
        try encoderContainer.encode(error, forKey: .error)
        try encoderContainer.encode(result, forKey: .result)
    }
}    

///  批量提交质检作业
public class BatchSubmitQualityDetectionJobsRequest:JdCloudRequest
{
    /// BulkItems
    var bulkItems:[SubmitQualityDetectionJobRequestObject?]?




    enum BatchSubmitQualityDetectionJobsRequestRequestCodingKeys: String, CodingKey {
        case bulkItems
    }

    public override func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: BatchSubmitQualityDetectionJobsRequestRequestCodingKeys.self)
        try encoderContainer.encode(bulkItems, forKey: .bulkItems)

    }
}

/// 批量提交质检作业 
public class BatchSubmitQualityDetectionJobsResult:NSObject,JdCloudResult
{
}
/// 提交质检作业 
public class SubmitQualityDetectionJobResult:NSObject,JdCloudResult
{
}

///  提交质检作业
public class SubmitQualityDetectionJobRequest:JdCloudRequest
{
    /// 媒资ID
    var mediaId:String?

    /// 质检模板ID列表
    var templateIds:[Int64?]?




    enum SubmitQualityDetectionJobRequestRequestCodingKeys: String, CodingKey {
        case mediaId
        case templateIds
    }

    public override func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: SubmitQualityDetectionJobRequestRequestCodingKeys.self)
        try encoderContainer.encode(mediaId, forKey: .mediaId)
        try encoderContainer.encode(templateIds, forKey: .templateIds)

    }
}

public class SubmitQualityDetectionJobResponse:NSObject,Codable
{
    var requestId:String?;

    var error:ServiceError?;

    var result:SubmitQualityDetectionJobResult?;

    enum SubmitQualityDetectionJobResponseCodingKeys: String, CodingKey {
        case requestId
        case error
        case result
    }

    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: SubmitQualityDetectionJobResponseCodingKeys.self)
        self.requestId = try decoderContainer.decodeIfPresent(String?.self, forKey: .requestId) ?? nil
        self.error = try decoderContainer.decodeIfPresent(ServiceError?.self, forKey: .error) ?? nil
        self.result = try decoderContainer.decodeIfPresent(SubmitQualityDetectionJobResult?.self, forKey: .result) ?? nil
    }
}

public extension SubmitQualityDetectionJobResponse{
        func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: SubmitQualityDetectionJobResponseCodingKeys.self)
        try encoderContainer.encode(requestId, forKey: .requestId)
        try encoderContainer.encode(error, forKey: .error)
        try encoderContainer.encode(result, forKey: .result)
    }
}    

///  设置CDN域名URL鉴权规则
public class SetURLRuleRequest:JdCloudRequest
{
    /// URL鉴权规则配置对象
    var config:URLRuleConfigObject

    /// 是否启用该规则
    var enabled:Bool

    /// 域名ID
    var domainId:Int64


    public init(regionId: String,config:URLRuleConfigObject,enabled:Bool,domainId:Int64){
        self.config = config
        self.enabled = enabled
        self.domainId = domainId
        super.init(regionId: regionId)
    }


    enum SetURLRuleRequestRequestCodingKeys: String, CodingKey {
        case config
        case enabled
        case domainId
    }

    public override func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: SetURLRuleRequestRequestCodingKeys.self)
        try encoderContainer.encode(config, forKey: .config)
        try encoderContainer.encode(enabled, forKey: .enabled)
        try encoderContainer.encode(domainId, forKey: .domainId)

    }
}

/// 查询CDN域名IP黑名单规则配置 
public class GetIPRuleResult:NSObject,JdCloudResult
{
    /// 规则类型，取值 &#39;ip&#39;
    var ruleType:String?

    /// IP黑名单规则配置对象
    var config:IPRuleConfigObject?

    /// 是否启用该规则
    var enabled:Bool?



    public override init(){
        super.init()
    }

    enum GetIPRuleResultCodingKeys: String, CodingKey {
        case ruleType
        case config
        case enabled
    }

    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: GetIPRuleResultCodingKeys.self)
        if decoderContainer.contains(.ruleType)
        {
            self.ruleType = try decoderContainer.decode(String?.self, forKey: .ruleType)
        }
        if decoderContainer.contains(.config)
        {
            self.config = try decoderContainer.decode(IPRuleConfigObject?.self, forKey: .config)
        }
        if decoderContainer.contains(.enabled)
        {
            self.enabled = try decoderContainer.decode(Bool?.self, forKey: .enabled)
        }
    }
}
public extension GetIPRuleResult{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: GetIPRuleResultCodingKeys.self)
        try encoderContainer.encode(ruleType, forKey: .ruleType)
        try encoderContainer.encode(config, forKey: .config)
        try encoderContainer.encode(enabled, forKey: .enabled)
    }
}
/// 停用域名 
public class DisableDomainResult:NSObject,JdCloudResult
{
}
/// 查询CDN域名Referer防盗链规则配置 
public class GetRefererRuleResult:NSObject,JdCloudResult
{
    /// 规则类型，取值 &#39;referer&#39;
    var ruleType:String?

    /// Referer防盗链规则配置对象
    var config:RefererRuleConfigObject?

    /// 是否启用该规则
    var enabled:Bool?



    public override init(){
        super.init()
    }

    enum GetRefererRuleResultCodingKeys: String, CodingKey {
        case ruleType
        case config
        case enabled
    }

    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: GetRefererRuleResultCodingKeys.self)
        if decoderContainer.contains(.ruleType)
        {
            self.ruleType = try decoderContainer.decode(String?.self, forKey: .ruleType)
        }
        if decoderContainer.contains(.config)
        {
            self.config = try decoderContainer.decode(RefererRuleConfigObject?.self, forKey: .config)
        }
        if decoderContainer.contains(.enabled)
        {
            self.enabled = try decoderContainer.decode(Bool?.self, forKey: .enabled)
        }
    }
}
public extension GetRefererRuleResult{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: GetRefererRuleResultCodingKeys.self)
        try encoderContainer.encode(ruleType, forKey: .ruleType)
        try encoderContainer.encode(config, forKey: .config)
        try encoderContainer.encode(enabled, forKey: .enabled)
    }
}
public class SetDefaultDomainResponse:NSObject,Codable
{
    var requestId:String?;

    var error:ServiceError?;

    var result:SetDefaultDomainResult?;

    enum SetDefaultDomainResponseCodingKeys: String, CodingKey {
        case requestId
        case error
        case result
    }

    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: SetDefaultDomainResponseCodingKeys.self)
        self.requestId = try decoderContainer.decodeIfPresent(String?.self, forKey: .requestId) ?? nil
        self.error = try decoderContainer.decodeIfPresent(ServiceError?.self, forKey: .error) ?? nil
        self.result = try decoderContainer.decodeIfPresent(SetDefaultDomainResult?.self, forKey: .result) ?? nil
    }
}

public extension SetDefaultDomainResponse{
        func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: SetDefaultDomainResponseCodingKeys.self)
        try encoderContainer.encode(requestId, forKey: .requestId)
        try encoderContainer.encode(error, forKey: .error)
        try encoderContainer.encode(result, forKey: .result)
    }
}    
public class ListHeadersResponse:NSObject,Codable
{
    var requestId:String?;

    var error:ServiceError?;

    var result:ListHeadersResult?;

    enum ListHeadersResponseCodingKeys: String, CodingKey {
        case requestId
        case error
        case result
    }

    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: ListHeadersResponseCodingKeys.self)
        self.requestId = try decoderContainer.decodeIfPresent(String?.self, forKey: .requestId) ?? nil
        self.error = try decoderContainer.decodeIfPresent(ServiceError?.self, forKey: .error) ?? nil
        self.result = try decoderContainer.decodeIfPresent(ListHeadersResult?.self, forKey: .result) ?? nil
    }
}

public extension ListHeadersResponse{
        func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: ListHeadersResponseCodingKeys.self)
        try encoderContainer.encode(requestId, forKey: .requestId)
        try encoderContainer.encode(error, forKey: .error)
        try encoderContainer.encode(result, forKey: .result)
    }
}    

///  设置CDN域名Referer防盗链规则
public class SetRefererRuleRequest:JdCloudRequest
{
    /// Referer防盗链规则配置对象
    var config:RefererRuleConfigObject

    /// 是否启用该规则
    var enabled:Bool

    /// 域名ID
    var domainId:Int64


    public init(regionId: String,config:RefererRuleConfigObject,enabled:Bool,domainId:Int64){
        self.config = config
        self.enabled = enabled
        self.domainId = domainId
        super.init(regionId: regionId)
    }


    enum SetRefererRuleRequestRequestCodingKeys: String, CodingKey {
        case config
        case enabled
        case domainId
    }

    public override func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: SetRefererRuleRequestRequestCodingKeys.self)
        try encoderContainer.encode(config, forKey: .config)
        try encoderContainer.encode(enabled, forKey: .enabled)
        try encoderContainer.encode(domainId, forKey: .domainId)

    }
}


///  查询域名列表
public class ListDomainsRequest:JdCloudRequest
{
    /// 页码；默认值为 1
    var pageNumber:Int?

    /// 分页大小；默认值为 10；取值范围 [10, 100]
    var pageSize:Int?

    /// Sorts
    var sorts:[Sort?]?




    enum ListDomainsRequestRequestCodingKeys: String, CodingKey {
        case pageNumber
        case pageSize
        case sorts
    }

    public override func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: ListDomainsRequestRequestCodingKeys.self)
        try encoderContainer.encode(pageNumber, forKey: .pageNumber)
        try encoderContainer.encode(pageSize, forKey: .pageSize)
        try encoderContainer.encode(sorts, forKey: .sorts)

    }
}

public class SetURLRuleResponse:NSObject,Codable
{
    var requestId:String?;

    var error:ServiceError?;

    var result:SetURLRuleResult?;

    enum SetURLRuleResponseCodingKeys: String, CodingKey {
        case requestId
        case error
        case result
    }

    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: SetURLRuleResponseCodingKeys.self)
        self.requestId = try decoderContainer.decodeIfPresent(String?.self, forKey: .requestId) ?? nil
        self.error = try decoderContainer.decodeIfPresent(ServiceError?.self, forKey: .error) ?? nil
        self.result = try decoderContainer.decodeIfPresent(SetURLRuleResult?.self, forKey: .result) ?? nil
    }
}

public extension SetURLRuleResponse{
        func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: SetURLRuleResponseCodingKeys.self)
        try encoderContainer.encode(requestId, forKey: .requestId)
        try encoderContainer.encode(error, forKey: .error)
        try encoderContainer.encode(result, forKey: .result)
    }
}    
public class CreateDomainResponse:NSObject,Codable
{
    var requestId:String?;

    var error:ServiceError?;

    var result:CreateDomainResult?;

    enum CreateDomainResponseCodingKeys: String, CodingKey {
        case requestId
        case error
        case result
    }

    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: CreateDomainResponseCodingKeys.self)
        self.requestId = try decoderContainer.decodeIfPresent(String?.self, forKey: .requestId) ?? nil
        self.error = try decoderContainer.decodeIfPresent(ServiceError?.self, forKey: .error) ?? nil
        self.result = try decoderContainer.decodeIfPresent(CreateDomainResult?.self, forKey: .result) ?? nil
    }
}

public extension CreateDomainResponse{
        func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: CreateDomainResponseCodingKeys.self)
        try encoderContainer.encode(requestId, forKey: .requestId)
        try encoderContainer.encode(error, forKey: .error)
        try encoderContainer.encode(result, forKey: .result)
    }
}    

///  设为默认域名
public class SetDefaultDomainRequest:JdCloudRequest
{
    /// 域名ID
    var domainId:Int64


    public init(regionId: String,domainId:Int64){
        self.domainId = domainId
        super.init(regionId: regionId)
    }


    enum SetDefaultDomainRequestRequestCodingKeys: String, CodingKey {
        case domainId
    }

    public override func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: SetDefaultDomainRequestRequestCodingKeys.self)
        try encoderContainer.encode(domainId, forKey: .domainId)

    }
}

public class SetRefererRuleResponse:NSObject,Codable
{
    var requestId:String?;

    var error:ServiceError?;

    var result:SetRefererRuleResult?;

    enum SetRefererRuleResponseCodingKeys: String, CodingKey {
        case requestId
        case error
        case result
    }

    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: SetRefererRuleResponseCodingKeys.self)
        self.requestId = try decoderContainer.decodeIfPresent(String?.self, forKey: .requestId) ?? nil
        self.error = try decoderContainer.decodeIfPresent(ServiceError?.self, forKey: .error) ?? nil
        self.result = try decoderContainer.decodeIfPresent(SetRefererRuleResult?.self, forKey: .result) ?? nil
    }
}

public extension SetRefererRuleResponse{
        func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: SetRefererRuleResponseCodingKeys.self)
        try encoderContainer.encode(requestId, forKey: .requestId)
        try encoderContainer.encode(error, forKey: .error)
        try encoderContainer.encode(result, forKey: .result)
    }
}    

///  查询域名访问头参数列表
public class ListHeadersRequest:JdCloudRequest
{
    /// 域名ID
    var domainId:Int64


    public init(regionId: String,domainId:Int64){
        self.domainId = domainId
        super.init(regionId: regionId)
    }


    enum ListHeadersRequestRequestCodingKeys: String, CodingKey {
        case domainId
    }

    public override func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: ListHeadersRequestRequestCodingKeys.self)
        try encoderContainer.encode(domainId, forKey: .domainId)

    }
}


///  查询域名
public class GetDomainRequest:JdCloudRequest
{
    /// 域名ID
    var domainId:Int64


    public init(regionId: String,domainId:Int64){
        self.domainId = domainId
        super.init(regionId: regionId)
    }


    enum GetDomainRequestRequestCodingKeys: String, CodingKey {
        case domainId
    }

    public override func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: GetDomainRequestRequestCodingKeys.self)
        try encoderContainer.encode(domainId, forKey: .domainId)

    }
}

/// 查询CDN域名SSL配置 
public class GetHttpSslResult:NSObject,JdCloudResult
{
    /// 证书来源。取值范围：default
    var source:String?

    /// 证书标题
    var title:String?

    /// 证书内容
    var sslCert:String?

    /// 证书私钥
    var sslKey:String?

    /// 跳转类型。取值范围：
      /// default - 采用回源域名的默认协议
      /// http - 强制采用http协议回源
      /// https - 强制采用https协议回源
      /// 
    var jumpType:String?

    /// SSL配置启用状态
    var enabled:Bool?



    public override init(){
        super.init()
    }

    enum GetHttpSslResultCodingKeys: String, CodingKey {
        case source
        case title
        case sslCert
        case sslKey
        case jumpType
        case enabled
    }

    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: GetHttpSslResultCodingKeys.self)
        if decoderContainer.contains(.source)
        {
            self.source = try decoderContainer.decode(String?.self, forKey: .source)
        }
        if decoderContainer.contains(.title)
        {
            self.title = try decoderContainer.decode(String?.self, forKey: .title)
        }
        if decoderContainer.contains(.sslCert)
        {
            self.sslCert = try decoderContainer.decode(String?.self, forKey: .sslCert)
        }
        if decoderContainer.contains(.sslKey)
        {
            self.sslKey = try decoderContainer.decode(String?.self, forKey: .sslKey)
        }
        if decoderContainer.contains(.jumpType)
        {
            self.jumpType = try decoderContainer.decode(String?.self, forKey: .jumpType)
        }
        if decoderContainer.contains(.enabled)
        {
            self.enabled = try decoderContainer.decode(Bool?.self, forKey: .enabled)
        }
    }
}
public extension GetHttpSslResult{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: GetHttpSslResultCodingKeys.self)
        try encoderContainer.encode(source, forKey: .source)
        try encoderContainer.encode(title, forKey: .title)
        try encoderContainer.encode(sslCert, forKey: .sslCert)
        try encoderContainer.encode(sslKey, forKey: .sslKey)
        try encoderContainer.encode(jumpType, forKey: .jumpType)
        try encoderContainer.encode(enabled, forKey: .enabled)
    }
}
/// 删除域名访问头参数 
public class DeleteHeaderResult:NSObject,JdCloudResult
{
}

///  设置CDN域名SSL配置
public class SetHttpSslRequest:JdCloudRequest
{
    /// 证书来源。取值范围：default
    var source:String?

    /// 证书标题
    var title:String?

    /// 证书内容
    var sslCert:String?

    /// 证书私钥
    var sslKey:String?

    /// 跳转类型。取值范围：
      /// default - 采用回源域名的默认协议
      /// http - 强制采用http协议回源
      /// https - 强制采用https协议回源
      /// 
    var jumpType:String?

    /// SSL配置启用状态
    var enabled:Bool?

    /// 域名ID
    var domainId:Int64


    public init(regionId: String,domainId:Int64){
        self.domainId = domainId
        super.init(regionId: regionId)
    }


    enum SetHttpSslRequestRequestCodingKeys: String, CodingKey {
        case source
        case title
        case sslCert
        case sslKey
        case jumpType
        case enabled
        case domainId
    }

    public override func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: SetHttpSslRequestRequestCodingKeys.self)
        try encoderContainer.encode(source, forKey: .source)
        try encoderContainer.encode(title, forKey: .title)
        try encoderContainer.encode(sslCert, forKey: .sslCert)
        try encoderContainer.encode(sslKey, forKey: .sslKey)
        try encoderContainer.encode(jumpType, forKey: .jumpType)
        try encoderContainer.encode(enabled, forKey: .enabled)
        try encoderContainer.encode(domainId, forKey: .domainId)

    }
}

/// 查询域名列表 
public class ListDomainsResult:NSObject,JdCloudResult
{
    /// 当前页码
    var pageNumber:Int?

    /// 每页数量
    var pageSize:Int?

    /// 查询总数
    var totalElements:Int?

    /// 总页数
    var totalPages:Int?

    /// 分页内容
    var content:[DomainObject?]?



    public override init(){
        super.init()
    }

    enum ListDomainsResultCodingKeys: String, CodingKey {
        case pageNumber
        case pageSize
        case totalElements
        case totalPages
        case content
    }

    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: ListDomainsResultCodingKeys.self)
        if decoderContainer.contains(.pageNumber)
        {
            self.pageNumber = try decoderContainer.decode(Int?.self, forKey: .pageNumber)
        }
        if decoderContainer.contains(.pageSize)
        {
            self.pageSize = try decoderContainer.decode(Int?.self, forKey: .pageSize)
        }
        if decoderContainer.contains(.totalElements)
        {
            self.totalElements = try decoderContainer.decode(Int?.self, forKey: .totalElements)
        }
        if decoderContainer.contains(.totalPages)
        {
            self.totalPages = try decoderContainer.decode(Int?.self, forKey: .totalPages)
        }
        if decoderContainer.contains(.content)
        {
            self.content = try decoderContainer.decode([DomainObject?]?.self, forKey: .content)
        }
    }
}
public extension ListDomainsResult{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: ListDomainsResultCodingKeys.self)
        try encoderContainer.encode(pageNumber, forKey: .pageNumber)
        try encoderContainer.encode(pageSize, forKey: .pageSize)
        try encoderContainer.encode(totalElements, forKey: .totalElements)
        try encoderContainer.encode(totalPages, forKey: .totalPages)
        try encoderContainer.encode(content, forKey: .content)
    }
}
/// 设置CDN域名Referer防盗链规则 
public class SetRefererRuleResult:NSObject,JdCloudResult
{
}

///  删除域名访问头参数
public class DeleteHeaderRequest:JdCloudRequest
{
    /// 头参数名。当前支持的访问头参数取值范围：
      ///   Content-Disposition
      ///   Content-Language
      ///   Expires
      ///   Access-Control-Allow-Origin
      ///   Access-Control-Allow-Methods
      ///   Access-Control-Max-Age
      ///   Access-Control-Expose-Headers
      /// 
    var headerName:String

    /// 头参数类型，取值范围：req、resp
    var headerType:String

    /// 域名ID
    var domainId:Int64


    public init(regionId: String,headerName:String,headerType:String,domainId:Int64){
        self.headerName = headerName
        self.headerType = headerType
        self.domainId = domainId
        super.init(regionId: regionId)
    }


    enum DeleteHeaderRequestRequestCodingKeys: String, CodingKey {
        case headerName
        case headerType
        case domainId
    }

    public override func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: DeleteHeaderRequestRequestCodingKeys.self)
        try encoderContainer.encode(headerName, forKey: .headerName)
        try encoderContainer.encode(headerType, forKey: .headerType)
        try encoderContainer.encode(domainId, forKey: .domainId)

    }
}

/// 设置CDN域名URL鉴权规则 
public class SetURLRuleResult:NSObject,JdCloudResult
{
}

///  查询CDN域名URL鉴权规则配置
public class GetURLRuleRequest:JdCloudRequest
{
    /// 域名ID
    var domainId:Int64


    public init(regionId: String,domainId:Int64){
        self.domainId = domainId
        super.init(regionId: regionId)
    }


    enum GetURLRuleRequestRequestCodingKeys: String, CodingKey {
        case domainId
    }

    public override func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: GetURLRuleRequestRequestCodingKeys.self)
        try encoderContainer.encode(domainId, forKey: .domainId)

    }
}


///  查询CDN域名SSL配置
public class GetHttpSslRequest:JdCloudRequest
{
    /// 域名ID
    var domainId:Int64


    public init(regionId: String,domainId:Int64){
        self.domainId = domainId
        super.init(regionId: regionId)
    }


    enum GetHttpSslRequestRequestCodingKeys: String, CodingKey {
        case domainId
    }

    public override func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: GetHttpSslRequestRequestCodingKeys.self)
        try encoderContainer.encode(domainId, forKey: .domainId)

    }
}

public class SetIPRuleResponse:NSObject,Codable
{
    var requestId:String?;

    var error:ServiceError?;

    var result:SetIPRuleResult?;

    enum SetIPRuleResponseCodingKeys: String, CodingKey {
        case requestId
        case error
        case result
    }

    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: SetIPRuleResponseCodingKeys.self)
        self.requestId = try decoderContainer.decodeIfPresent(String?.self, forKey: .requestId) ?? nil
        self.error = try decoderContainer.decodeIfPresent(ServiceError?.self, forKey: .error) ?? nil
        self.result = try decoderContainer.decodeIfPresent(SetIPRuleResult?.self, forKey: .result) ?? nil
    }
}

public extension SetIPRuleResponse{
        func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: SetIPRuleResponseCodingKeys.self)
        try encoderContainer.encode(requestId, forKey: .requestId)
        try encoderContainer.encode(error, forKey: .error)
        try encoderContainer.encode(result, forKey: .result)
    }
}    
/// 设置CDN域名IP黑名单规则 
public class SetIPRuleResult:NSObject,JdCloudResult
{
}
/// 启用域名 
public class EnableDomainResult:NSObject,JdCloudResult
{
}
/// 设为默认域名 
public class SetDefaultDomainResult:NSObject,JdCloudResult
{
}
/// 查询CDN域名URL鉴权规则配置 
public class GetURLRuleResult:NSObject,JdCloudResult
{
    /// 规则类型，取值 &#39;url&#39;
    var ruleType:String?

    /// URL鉴权规则配置对象
    var config:URLRuleConfigObject?

    /// 是否启用该规则
    var enabled:Bool?



    public override init(){
        super.init()
    }

    enum GetURLRuleResultCodingKeys: String, CodingKey {
        case ruleType
        case config
        case enabled
    }

    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: GetURLRuleResultCodingKeys.self)
        if decoderContainer.contains(.ruleType)
        {
            self.ruleType = try decoderContainer.decode(String?.self, forKey: .ruleType)
        }
        if decoderContainer.contains(.config)
        {
            self.config = try decoderContainer.decode(URLRuleConfigObject?.self, forKey: .config)
        }
        if decoderContainer.contains(.enabled)
        {
            self.enabled = try decoderContainer.decode(Bool?.self, forKey: .enabled)
        }
    }
}
public extension GetURLRuleResult{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: GetURLRuleResultCodingKeys.self)
        try encoderContainer.encode(ruleType, forKey: .ruleType)
        try encoderContainer.encode(config, forKey: .config)
        try encoderContainer.encode(enabled, forKey: .enabled)
    }
}
public class DeleteDomainResponse:NSObject,Codable
{
    var requestId:String?;

    var error:ServiceError?;

    var result:DeleteDomainResult?;

    enum DeleteDomainResponseCodingKeys: String, CodingKey {
        case requestId
        case error
        case result
    }

    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: DeleteDomainResponseCodingKeys.self)
        self.requestId = try decoderContainer.decodeIfPresent(String?.self, forKey: .requestId) ?? nil
        self.error = try decoderContainer.decodeIfPresent(ServiceError?.self, forKey: .error) ?? nil
        self.result = try decoderContainer.decodeIfPresent(DeleteDomainResult?.self, forKey: .result) ?? nil
    }
}

public extension DeleteDomainResponse{
        func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: DeleteDomainResponseCodingKeys.self)
        try encoderContainer.encode(requestId, forKey: .requestId)
        try encoderContainer.encode(error, forKey: .error)
        try encoderContainer.encode(result, forKey: .result)
    }
}    

///  添加域名
public class CreateDomainRequest:JdCloudRequest
{
    /// 域名名称
    var name:String


    public init(regionId: String,name:String){
        self.name = name
        super.init(regionId: regionId)
    }


    enum CreateDomainRequestRequestCodingKeys: String, CodingKey {
        case name
    }

    public override func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: CreateDomainRequestRequestCodingKeys.self)
        try encoderContainer.encode(name, forKey: .name)

    }
}

public class EnableDomainResponse:NSObject,Codable
{
    var requestId:String?;

    var error:ServiceError?;

    var result:EnableDomainResult?;

    enum EnableDomainResponseCodingKeys: String, CodingKey {
        case requestId
        case error
        case result
    }

    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: EnableDomainResponseCodingKeys.self)
        self.requestId = try decoderContainer.decodeIfPresent(String?.self, forKey: .requestId) ?? nil
        self.error = try decoderContainer.decodeIfPresent(ServiceError?.self, forKey: .error) ?? nil
        self.result = try decoderContainer.decodeIfPresent(EnableDomainResult?.self, forKey: .result) ?? nil
    }
}

public extension EnableDomainResponse{
        func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: EnableDomainResponseCodingKeys.self)
        try encoderContainer.encode(requestId, forKey: .requestId)
        try encoderContainer.encode(error, forKey: .error)
        try encoderContainer.encode(result, forKey: .result)
    }
}    
public class DisableDomainResponse:NSObject,Codable
{
    var requestId:String?;

    var error:ServiceError?;

    var result:DisableDomainResult?;

    enum DisableDomainResponseCodingKeys: String, CodingKey {
        case requestId
        case error
        case result
    }

    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: DisableDomainResponseCodingKeys.self)
        self.requestId = try decoderContainer.decodeIfPresent(String?.self, forKey: .requestId) ?? nil
        self.error = try decoderContainer.decodeIfPresent(ServiceError?.self, forKey: .error) ?? nil
        self.result = try decoderContainer.decodeIfPresent(DisableDomainResult?.self, forKey: .result) ?? nil
    }
}

public extension DisableDomainResponse{
        func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: DisableDomainResponseCodingKeys.self)
        try encoderContainer.encode(requestId, forKey: .requestId)
        try encoderContainer.encode(error, forKey: .error)
        try encoderContainer.encode(result, forKey: .result)
    }
}    
/// 查询域名访问头参数列表 
public class ListHeadersResult:NSObject,JdCloudResult
{
    /// 头参数列表
    var headers:[GetHeaderResultObject?]?



    public override init(){
        super.init()
    }

    enum ListHeadersResultCodingKeys: String, CodingKey {
        case headers
    }

    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: ListHeadersResultCodingKeys.self)
        if decoderContainer.contains(.headers)
        {
            self.headers = try decoderContainer.decode([GetHeaderResultObject?]?.self, forKey: .headers)
        }
    }
}
public extension ListHeadersResult{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: ListHeadersResultCodingKeys.self)
        try encoderContainer.encode(headers, forKey: .headers)
    }
}

///  删除域名。执行该操作，需确保域名已被停用。
public class DeleteDomainRequest:JdCloudRequest
{
    /// 域名ID
    var domainId:Int64


    public init(regionId: String,domainId:Int64){
        self.domainId = domainId
        super.init(regionId: regionId)
    }


    enum DeleteDomainRequestRequestCodingKeys: String, CodingKey {
        case domainId
    }

    public override func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: DeleteDomainRequestRequestCodingKeys.self)
        try encoderContainer.encode(domainId, forKey: .domainId)

    }
}


///  查询CDN域名IP黑名单规则配置
public class GetIPRuleRequest:JdCloudRequest
{
    /// 域名ID
    var domainId:Int64


    public init(regionId: String,domainId:Int64){
        self.domainId = domainId
        super.init(regionId: regionId)
    }


    enum GetIPRuleRequestRequestCodingKeys: String, CodingKey {
        case domainId
    }

    public override func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: GetIPRuleRequestRequestCodingKeys.self)
        try encoderContainer.encode(domainId, forKey: .domainId)

    }
}

public class SetHttpSslResponse:NSObject,Codable
{
    var requestId:String?;

    var error:ServiceError?;

    var result:SetHttpSslResult?;

    enum SetHttpSslResponseCodingKeys: String, CodingKey {
        case requestId
        case error
        case result
    }

    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: SetHttpSslResponseCodingKeys.self)
        self.requestId = try decoderContainer.decodeIfPresent(String?.self, forKey: .requestId) ?? nil
        self.error = try decoderContainer.decodeIfPresent(ServiceError?.self, forKey: .error) ?? nil
        self.result = try decoderContainer.decodeIfPresent(SetHttpSslResult?.self, forKey: .result) ?? nil
    }
}

public extension SetHttpSslResponse{
        func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: SetHttpSslResponseCodingKeys.self)
        try encoderContainer.encode(requestId, forKey: .requestId)
        try encoderContainer.encode(error, forKey: .error)
        try encoderContainer.encode(result, forKey: .result)
    }
}    
public class GetDomainResponse:NSObject,Codable
{
    var requestId:String?;

    var error:ServiceError?;

    var result:GetDomainResult?;

    enum GetDomainResponseCodingKeys: String, CodingKey {
        case requestId
        case error
        case result
    }

    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: GetDomainResponseCodingKeys.self)
        self.requestId = try decoderContainer.decodeIfPresent(String?.self, forKey: .requestId) ?? nil
        self.error = try decoderContainer.decodeIfPresent(ServiceError?.self, forKey: .error) ?? nil
        self.result = try decoderContainer.decodeIfPresent(GetDomainResult?.self, forKey: .result) ?? nil
    }
}

public extension GetDomainResponse{
        func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: GetDomainResponseCodingKeys.self)
        try encoderContainer.encode(requestId, forKey: .requestId)
        try encoderContainer.encode(error, forKey: .error)
        try encoderContainer.encode(result, forKey: .result)
    }
}    

///  停用域名
public class DisableDomainRequest:JdCloudRequest
{
    /// 域名ID
    var domainId:Int64


    public init(regionId: String,domainId:Int64){
        self.domainId = domainId
        super.init(regionId: regionId)
    }


    enum DisableDomainRequestRequestCodingKeys: String, CodingKey {
        case domainId
    }

    public override func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: DisableDomainRequestRequestCodingKeys.self)
        try encoderContainer.encode(domainId, forKey: .domainId)

    }
}

/// 查询域名 
public class GetDomainResult:NSObject,JdCloudResult
{
    /// 域名ID
    var id:String?

    /// 域名名称
    var name:String?

    /// 域名CNAME
    var cname:String?

    /// 域名状态。取值范围：
      ///   init - 初始状态
      ///   configuring - 配置中
      ///   normal - 正常
      ///   stopped - 已停用
      /// 
    var status:String?

    /// 域名来源。取值范围：
      ///   system - 系统生成
      ///   custom - 用户自建
      /// 
    var source:String?

    /// 是否默认域名
    var asDefault:Bool?

    /// 创建时间
    var createTime:String?

    /// 修改时间
    var updateTime:String?



    public override init(){
        super.init()
    }

    enum GetDomainResultCodingKeys: String, CodingKey {
        case id
        case name
        case cname
        case status
        case source
        case asDefault
        case createTime
        case updateTime
    }

    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: GetDomainResultCodingKeys.self)
        if decoderContainer.contains(.id)
        {
            self.id = try decoderContainer.decode(String?.self, forKey: .id)
        }
        if decoderContainer.contains(.name)
        {
            self.name = try decoderContainer.decode(String?.self, forKey: .name)
        }
        if decoderContainer.contains(.cname)
        {
            self.cname = try decoderContainer.decode(String?.self, forKey: .cname)
        }
        if decoderContainer.contains(.status)
        {
            self.status = try decoderContainer.decode(String?.self, forKey: .status)
        }
        if decoderContainer.contains(.source)
        {
            self.source = try decoderContainer.decode(String?.self, forKey: .source)
        }
        if decoderContainer.contains(.asDefault)
        {
            self.asDefault = try decoderContainer.decode(Bool?.self, forKey: .asDefault)
        }
        if decoderContainer.contains(.createTime)
        {
            self.createTime = try decoderContainer.decode(String?.self, forKey: .createTime)
        }
        if decoderContainer.contains(.updateTime)
        {
            self.updateTime = try decoderContainer.decode(String?.self, forKey: .updateTime)
        }
    }
}
public extension GetDomainResult{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: GetDomainResultCodingKeys.self)
        try encoderContainer.encode(id, forKey: .id)
        try encoderContainer.encode(name, forKey: .name)
        try encoderContainer.encode(cname, forKey: .cname)
        try encoderContainer.encode(status, forKey: .status)
        try encoderContainer.encode(source, forKey: .source)
        try encoderContainer.encode(asDefault, forKey: .asDefault)
        try encoderContainer.encode(createTime, forKey: .createTime)
        try encoderContainer.encode(updateTime, forKey: .updateTime)
    }
}
/// 添加域名 
public class CreateDomainResult:NSObject,JdCloudResult
{
    /// 域名ID
    var id:String?

    /// 域名名称
    var name:String?

    /// 域名CNAME
    var cname:String?

    /// 域名状态。取值范围：
      ///   init - 初始状态
      ///   configuring - 配置中
      ///   normal - 正常
      ///   stopped - 已停用
      /// 
    var status:String?

    /// 域名来源。取值范围：
      ///   system - 系统生成
      ///   custom - 用户自建
      /// 
    var source:String?

    /// 是否默认域名
    var asDefault:Bool?

    /// 创建时间
    var createTime:String?

    /// 修改时间
    var updateTime:String?



    public override init(){
        super.init()
    }

    enum CreateDomainResultCodingKeys: String, CodingKey {
        case id
        case name
        case cname
        case status
        case source
        case asDefault
        case createTime
        case updateTime
    }

    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: CreateDomainResultCodingKeys.self)
        if decoderContainer.contains(.id)
        {
            self.id = try decoderContainer.decode(String?.self, forKey: .id)
        }
        if decoderContainer.contains(.name)
        {
            self.name = try decoderContainer.decode(String?.self, forKey: .name)
        }
        if decoderContainer.contains(.cname)
        {
            self.cname = try decoderContainer.decode(String?.self, forKey: .cname)
        }
        if decoderContainer.contains(.status)
        {
            self.status = try decoderContainer.decode(String?.self, forKey: .status)
        }
        if decoderContainer.contains(.source)
        {
            self.source = try decoderContainer.decode(String?.self, forKey: .source)
        }
        if decoderContainer.contains(.asDefault)
        {
            self.asDefault = try decoderContainer.decode(Bool?.self, forKey: .asDefault)
        }
        if decoderContainer.contains(.createTime)
        {
            self.createTime = try decoderContainer.decode(String?.self, forKey: .createTime)
        }
        if decoderContainer.contains(.updateTime)
        {
            self.updateTime = try decoderContainer.decode(String?.self, forKey: .updateTime)
        }
    }
}
public extension CreateDomainResult{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: CreateDomainResultCodingKeys.self)
        try encoderContainer.encode(id, forKey: .id)
        try encoderContainer.encode(name, forKey: .name)
        try encoderContainer.encode(cname, forKey: .cname)
        try encoderContainer.encode(status, forKey: .status)
        try encoderContainer.encode(source, forKey: .source)
        try encoderContainer.encode(asDefault, forKey: .asDefault)
        try encoderContainer.encode(createTime, forKey: .createTime)
        try encoderContainer.encode(updateTime, forKey: .updateTime)
    }
}

///  设置域名访问头参数
public class SetHeaderRequest:JdCloudRequest
{
    /// 头参数名。当前支持的访问头参数取值范围：
      ///   Content-Disposition
      ///   Content-Language
      ///   Expires
      ///   Access-Control-Allow-Origin
      ///   Access-Control-Allow-Methods
      ///   Access-Control-Max-Age
      ///   Access-Control-Expose-Headers
      /// 
    var headerName:String

    /// 头参数值
    var headerValue:String

    /// 头参数类型，取值范围：req、resp
    var headerType:String

    /// 域名ID
    var domainId:Int64


    public init(regionId: String,headerName:String,headerValue:String,headerType:String,domainId:Int64){
        self.headerName = headerName
        self.headerValue = headerValue
        self.headerType = headerType
        self.domainId = domainId
        super.init(regionId: regionId)
    }


    enum SetHeaderRequestRequestCodingKeys: String, CodingKey {
        case headerName
        case headerValue
        case headerType
        case domainId
    }

    public override func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: SetHeaderRequestRequestCodingKeys.self)
        try encoderContainer.encode(headerName, forKey: .headerName)
        try encoderContainer.encode(headerValue, forKey: .headerValue)
        try encoderContainer.encode(headerType, forKey: .headerType)
        try encoderContainer.encode(domainId, forKey: .domainId)

    }
}

public class DeleteHeaderResponse:NSObject,Codable
{
    var requestId:String?;

    var error:ServiceError?;

    var result:DeleteHeaderResult?;

    enum DeleteHeaderResponseCodingKeys: String, CodingKey {
        case requestId
        case error
        case result
    }

    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: DeleteHeaderResponseCodingKeys.self)
        self.requestId = try decoderContainer.decodeIfPresent(String?.self, forKey: .requestId) ?? nil
        self.error = try decoderContainer.decodeIfPresent(ServiceError?.self, forKey: .error) ?? nil
        self.result = try decoderContainer.decodeIfPresent(DeleteHeaderResult?.self, forKey: .result) ?? nil
    }
}

public extension DeleteHeaderResponse{
        func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: DeleteHeaderResponseCodingKeys.self)
        try encoderContainer.encode(requestId, forKey: .requestId)
        try encoderContainer.encode(error, forKey: .error)
        try encoderContainer.encode(result, forKey: .result)
    }
}    
public class GetURLRuleResponse:NSObject,Codable
{
    var requestId:String?;

    var error:ServiceError?;

    var result:GetURLRuleResult?;

    enum GetURLRuleResponseCodingKeys: String, CodingKey {
        case requestId
        case error
        case result
    }

    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: GetURLRuleResponseCodingKeys.self)
        self.requestId = try decoderContainer.decodeIfPresent(String?.self, forKey: .requestId) ?? nil
        self.error = try decoderContainer.decodeIfPresent(ServiceError?.self, forKey: .error) ?? nil
        self.result = try decoderContainer.decodeIfPresent(GetURLRuleResult?.self, forKey: .result) ?? nil
    }
}

public extension GetURLRuleResponse{
        func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: GetURLRuleResponseCodingKeys.self)
        try encoderContainer.encode(requestId, forKey: .requestId)
        try encoderContainer.encode(error, forKey: .error)
        try encoderContainer.encode(result, forKey: .result)
    }
}    

///  查询CDN域名Referer防盗链规则配置
public class GetRefererRuleRequest:JdCloudRequest
{
    /// 域名ID
    var domainId:Int64


    public init(regionId: String,domainId:Int64){
        self.domainId = domainId
        super.init(regionId: regionId)
    }


    enum GetRefererRuleRequestRequestCodingKeys: String, CodingKey {
        case domainId
    }

    public override func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: GetRefererRuleRequestRequestCodingKeys.self)
        try encoderContainer.encode(domainId, forKey: .domainId)

    }
}

public class GetHttpSslResponse:NSObject,Codable
{
    var requestId:String?;

    var error:ServiceError?;

    var result:GetHttpSslResult?;

    enum GetHttpSslResponseCodingKeys: String, CodingKey {
        case requestId
        case error
        case result
    }

    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: GetHttpSslResponseCodingKeys.self)
        self.requestId = try decoderContainer.decodeIfPresent(String?.self, forKey: .requestId) ?? nil
        self.error = try decoderContainer.decodeIfPresent(ServiceError?.self, forKey: .error) ?? nil
        self.result = try decoderContainer.decodeIfPresent(GetHttpSslResult?.self, forKey: .result) ?? nil
    }
}

public extension GetHttpSslResponse{
        func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: GetHttpSslResponseCodingKeys.self)
        try encoderContainer.encode(requestId, forKey: .requestId)
        try encoderContainer.encode(error, forKey: .error)
        try encoderContainer.encode(result, forKey: .result)
    }
}    

///  设置CDN域名IP黑名单规则
public class SetIPRuleRequest:JdCloudRequest
{
    /// IP黑名单规则配置对象
    var config:IPRuleConfigObject

    /// 是否启用该规则
    var enabled:Bool

    /// 域名ID
    var domainId:Int64


    public init(regionId: String,config:IPRuleConfigObject,enabled:Bool,domainId:Int64){
        self.config = config
        self.enabled = enabled
        self.domainId = domainId
        super.init(regionId: regionId)
    }


    enum SetIPRuleRequestRequestCodingKeys: String, CodingKey {
        case config
        case enabled
        case domainId
    }

    public override func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: SetIPRuleRequestRequestCodingKeys.self)
        try encoderContainer.encode(config, forKey: .config)
        try encoderContainer.encode(enabled, forKey: .enabled)
        try encoderContainer.encode(domainId, forKey: .domainId)

    }
}

public class ListDomainsResponse:NSObject,Codable
{
    var requestId:String?;

    var error:ServiceError?;

    var result:ListDomainsResult?;

    enum ListDomainsResponseCodingKeys: String, CodingKey {
        case requestId
        case error
        case result
    }

    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: ListDomainsResponseCodingKeys.self)
        self.requestId = try decoderContainer.decodeIfPresent(String?.self, forKey: .requestId) ?? nil
        self.error = try decoderContainer.decodeIfPresent(ServiceError?.self, forKey: .error) ?? nil
        self.result = try decoderContainer.decodeIfPresent(ListDomainsResult?.self, forKey: .result) ?? nil
    }
}

public extension ListDomainsResponse{
        func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: ListDomainsResponseCodingKeys.self)
        try encoderContainer.encode(requestId, forKey: .requestId)
        try encoderContainer.encode(error, forKey: .error)
        try encoderContainer.encode(result, forKey: .result)
    }
}    
/// 删除域名。执行该操作，需确保域名已被停用。 
public class DeleteDomainResult:NSObject,JdCloudResult
{
}
/// 设置域名访问头参数 
public class SetHeaderResult:NSObject,JdCloudResult
{
}
public class GetRefererRuleResponse:NSObject,Codable
{
    var requestId:String?;

    var error:ServiceError?;

    var result:GetRefererRuleResult?;

    enum GetRefererRuleResponseCodingKeys: String, CodingKey {
        case requestId
        case error
        case result
    }

    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: GetRefererRuleResponseCodingKeys.self)
        self.requestId = try decoderContainer.decodeIfPresent(String?.self, forKey: .requestId) ?? nil
        self.error = try decoderContainer.decodeIfPresent(ServiceError?.self, forKey: .error) ?? nil
        self.result = try decoderContainer.decodeIfPresent(GetRefererRuleResult?.self, forKey: .result) ?? nil
    }
}

public extension GetRefererRuleResponse{
        func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: GetRefererRuleResponseCodingKeys.self)
        try encoderContainer.encode(requestId, forKey: .requestId)
        try encoderContainer.encode(error, forKey: .error)
        try encoderContainer.encode(result, forKey: .result)
    }
}    
public class SetHeaderResponse:NSObject,Codable
{
    var requestId:String?;

    var error:ServiceError?;

    var result:SetHeaderResult?;

    enum SetHeaderResponseCodingKeys: String, CodingKey {
        case requestId
        case error
        case result
    }

    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: SetHeaderResponseCodingKeys.self)
        self.requestId = try decoderContainer.decodeIfPresent(String?.self, forKey: .requestId) ?? nil
        self.error = try decoderContainer.decodeIfPresent(ServiceError?.self, forKey: .error) ?? nil
        self.result = try decoderContainer.decodeIfPresent(SetHeaderResult?.self, forKey: .result) ?? nil
    }
}

public extension SetHeaderResponse{
        func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: SetHeaderResponseCodingKeys.self)
        try encoderContainer.encode(requestId, forKey: .requestId)
        try encoderContainer.encode(error, forKey: .error)
        try encoderContainer.encode(result, forKey: .result)
    }
}    

///  启用域名
public class EnableDomainRequest:JdCloudRequest
{
    /// 域名ID
    var domainId:Int64


    public init(regionId: String,domainId:Int64){
        self.domainId = domainId
        super.init(regionId: regionId)
    }


    enum EnableDomainRequestRequestCodingKeys: String, CodingKey {
        case domainId
    }

    public override func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: EnableDomainRequestRequestCodingKeys.self)
        try encoderContainer.encode(domainId, forKey: .domainId)

    }
}

public class GetIPRuleResponse:NSObject,Codable
{
    var requestId:String?;

    var error:ServiceError?;

    var result:GetIPRuleResult?;

    enum GetIPRuleResponseCodingKeys: String, CodingKey {
        case requestId
        case error
        case result
    }

    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: GetIPRuleResponseCodingKeys.self)
        self.requestId = try decoderContainer.decodeIfPresent(String?.self, forKey: .requestId) ?? nil
        self.error = try decoderContainer.decodeIfPresent(ServiceError?.self, forKey: .error) ?? nil
        self.result = try decoderContainer.decodeIfPresent(GetIPRuleResult?.self, forKey: .result) ?? nil
    }
}

public extension GetIPRuleResponse{
        func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: GetIPRuleResponseCodingKeys.self)
        try encoderContainer.encode(requestId, forKey: .requestId)
        try encoderContainer.encode(error, forKey: .error)
        try encoderContainer.encode(result, forKey: .result)
    }
}    
/// 设置CDN域名SSL配置 
public class SetHttpSslResult:NSObject,JdCloudResult
{
}
public class ListQualityDetectionTemplatesResponse:NSObject,Codable
{
    var requestId:String?;

    var error:ServiceError?;

    var result:ListQualityDetectionTemplatesResult?;

    enum ListQualityDetectionTemplatesResponseCodingKeys: String, CodingKey {
        case requestId
        case error
        case result
    }

    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: ListQualityDetectionTemplatesResponseCodingKeys.self)
        self.requestId = try decoderContainer.decodeIfPresent(String?.self, forKey: .requestId) ?? nil
        self.error = try decoderContainer.decodeIfPresent(ServiceError?.self, forKey: .error) ?? nil
        self.result = try decoderContainer.decodeIfPresent(ListQualityDetectionTemplatesResult?.self, forKey: .result) ?? nil
    }
}

public extension ListQualityDetectionTemplatesResponse{
        func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: ListQualityDetectionTemplatesResponseCodingKeys.self)
        try encoderContainer.encode(requestId, forKey: .requestId)
        try encoderContainer.encode(error, forKey: .error)
        try encoderContainer.encode(result, forKey: .result)
    }
}    
/// 查询质检模板 
public class GetQualityDetectionTemplateResult:NSObject,JdCloudResult
{
    /// 模板ID
    var id:Int64?

    /// 模板名称。长度不超过128个字符。UTF-8编码。
      /// 
    var name:String?

    /// 模板类型，区分该模板的检测内容。目前只支持 video 。
    var templateType:String?

    /// 检测项列表。取值范围：
      ///   blackScreen - 黑场
      ///   pureColor - 纯色
      ///   colorCast - 偏色
      ///   frozenFrame - 静帧
      ///   brightness - 亮度
      ///   contrast - 对比度
      /// 
    var detections:[String?]?

    /// 创建时间
    var createTime:String?

    /// 修改时间
    var updateTime:String?



    public override init(){
        super.init()
    }

    enum GetQualityDetectionTemplateResultCodingKeys: String, CodingKey {
        case id
        case name
        case templateType
        case detections
        case createTime
        case updateTime
    }

    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: GetQualityDetectionTemplateResultCodingKeys.self)
        if decoderContainer.contains(.id)
        {
            self.id = try decoderContainer.decode(Int64?.self, forKey: .id)
        }
        if decoderContainer.contains(.name)
        {
            self.name = try decoderContainer.decode(String?.self, forKey: .name)
        }
        if decoderContainer.contains(.templateType)
        {
            self.templateType = try decoderContainer.decode(String?.self, forKey: .templateType)
        }
        if decoderContainer.contains(.detections)
        {
            self.detections = try decoderContainer.decode([String?]?.self, forKey: .detections)
        }
        if decoderContainer.contains(.createTime)
        {
            self.createTime = try decoderContainer.decode(String?.self, forKey: .createTime)
        }
        if decoderContainer.contains(.updateTime)
        {
            self.updateTime = try decoderContainer.decode(String?.self, forKey: .updateTime)
        }
    }
}
public extension GetQualityDetectionTemplateResult{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: GetQualityDetectionTemplateResultCodingKeys.self)
        try encoderContainer.encode(id, forKey: .id)
        try encoderContainer.encode(name, forKey: .name)
        try encoderContainer.encode(templateType, forKey: .templateType)
        try encoderContainer.encode(detections, forKey: .detections)
        try encoderContainer.encode(createTime, forKey: .createTime)
        try encoderContainer.encode(updateTime, forKey: .updateTime)
    }
}
/// 查询质测模板列表。
      ///       ///  
public class ListQualityDetectionTemplatesResult:NSObject,JdCloudResult
{
    /// 当前页码
    var pageNumber:Int?

    /// 每页数量
    var pageSize:Int?

    /// 查询总数
    var totalElements:Int?

    /// 总页数
    var totalPages:Int?

    /// 分页内容
    var content:[QualityDetectionTemplateObject?]?



    public override init(){
        super.init()
    }

    enum ListQualityDetectionTemplatesResultCodingKeys: String, CodingKey {
        case pageNumber
        case pageSize
        case totalElements
        case totalPages
        case content
    }

    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: ListQualityDetectionTemplatesResultCodingKeys.self)
        if decoderContainer.contains(.pageNumber)
        {
            self.pageNumber = try decoderContainer.decode(Int?.self, forKey: .pageNumber)
        }
        if decoderContainer.contains(.pageSize)
        {
            self.pageSize = try decoderContainer.decode(Int?.self, forKey: .pageSize)
        }
        if decoderContainer.contains(.totalElements)
        {
            self.totalElements = try decoderContainer.decode(Int?.self, forKey: .totalElements)
        }
        if decoderContainer.contains(.totalPages)
        {
            self.totalPages = try decoderContainer.decode(Int?.self, forKey: .totalPages)
        }
        if decoderContainer.contains(.content)
        {
            self.content = try decoderContainer.decode([QualityDetectionTemplateObject?]?.self, forKey: .content)
        }
    }
}
public extension ListQualityDetectionTemplatesResult{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: ListQualityDetectionTemplatesResultCodingKeys.self)
        try encoderContainer.encode(pageNumber, forKey: .pageNumber)
        try encoderContainer.encode(pageSize, forKey: .pageSize)
        try encoderContainer.encode(totalElements, forKey: .totalElements)
        try encoderContainer.encode(totalPages, forKey: .totalPages)
        try encoderContainer.encode(content, forKey: .content)
    }
}

///  创建质检模板
public class CreateQualityDetectionTemplateRequest:JdCloudRequest
{
    /// 模板名称。长度不超过128个字符。UTF-8编码。
      /// 
    var name:String

    /// 模板类型，区分该模板的检测内容。目前只支持 video 。
    var templateType:String

    /// 检测项列表。取值范围：
      ///   blackScreen - 黑场
      ///   pureColor - 纯色
      ///   colorCast - 偏色
      ///   frozenFrame - 静帧
      ///   brightness - 亮度
      ///   contrast - 对比度
      /// 
    var detections:[String?]?


    public init(regionId: String,name:String,templateType:String){
        self.name = name
        self.templateType = templateType
        super.init(regionId: regionId)
    }


    enum CreateQualityDetectionTemplateRequestRequestCodingKeys: String, CodingKey {
        case name
        case templateType
        case detections
    }

    public override func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: CreateQualityDetectionTemplateRequestRequestCodingKeys.self)
        try encoderContainer.encode(name, forKey: .name)
        try encoderContainer.encode(templateType, forKey: .templateType)
        try encoderContainer.encode(detections, forKey: .detections)

    }
}

/// 删除质检模板 
public class DeleteQualityDetectionTemplateResult:NSObject,JdCloudResult
{
}
public class GetQualityDetectionTemplateResponse:NSObject,Codable
{
    var requestId:String?;

    var error:ServiceError?;

    var result:GetQualityDetectionTemplateResult?;

    enum GetQualityDetectionTemplateResponseCodingKeys: String, CodingKey {
        case requestId
        case error
        case result
    }

    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: GetQualityDetectionTemplateResponseCodingKeys.self)
        self.requestId = try decoderContainer.decodeIfPresent(String?.self, forKey: .requestId) ?? nil
        self.error = try decoderContainer.decodeIfPresent(ServiceError?.self, forKey: .error) ?? nil
        self.result = try decoderContainer.decodeIfPresent(GetQualityDetectionTemplateResult?.self, forKey: .result) ?? nil
    }
}

public extension GetQualityDetectionTemplateResponse{
        func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: GetQualityDetectionTemplateResponseCodingKeys.self)
        try encoderContainer.encode(requestId, forKey: .requestId)
        try encoderContainer.encode(error, forKey: .error)
        try encoderContainer.encode(result, forKey: .result)
    }
}    
public class DeleteQualityDetectionTemplateResponse:NSObject,Codable
{
    var requestId:String?;

    var error:ServiceError?;

    var result:DeleteQualityDetectionTemplateResult?;

    enum DeleteQualityDetectionTemplateResponseCodingKeys: String, CodingKey {
        case requestId
        case error
        case result
    }

    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: DeleteQualityDetectionTemplateResponseCodingKeys.self)
        self.requestId = try decoderContainer.decodeIfPresent(String?.self, forKey: .requestId) ?? nil
        self.error = try decoderContainer.decodeIfPresent(ServiceError?.self, forKey: .error) ?? nil
        self.result = try decoderContainer.decodeIfPresent(DeleteQualityDetectionTemplateResult?.self, forKey: .result) ?? nil
    }
}

public extension DeleteQualityDetectionTemplateResponse{
        func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: DeleteQualityDetectionTemplateResponseCodingKeys.self)
        try encoderContainer.encode(requestId, forKey: .requestId)
        try encoderContainer.encode(error, forKey: .error)
        try encoderContainer.encode(result, forKey: .result)
    }
}    
/// 创建质检模板 
public class CreateQualityDetectionTemplateResult:NSObject,JdCloudResult
{
    /// 模板ID
    var id:Int64?

    /// 模板名称。长度不超过128个字符。UTF-8编码。
      /// 
    var name:String?

    /// 模板类型，区分该模板的检测内容。目前只支持 video 。
    var templateType:String?

    /// 检测项列表。取值范围：
      ///   blackScreen - 黑场
      ///   pureColor - 纯色
      ///   colorCast - 偏色
      ///   frozenFrame - 静帧
      ///   brightness - 亮度
      ///   contrast - 对比度
      /// 
    var detections:[String?]?

    /// 创建时间
    var createTime:String?

    /// 修改时间
    var updateTime:String?



    public override init(){
        super.init()
    }

    enum CreateQualityDetectionTemplateResultCodingKeys: String, CodingKey {
        case id
        case name
        case templateType
        case detections
        case createTime
        case updateTime
    }

    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: CreateQualityDetectionTemplateResultCodingKeys.self)
        if decoderContainer.contains(.id)
        {
            self.id = try decoderContainer.decode(Int64?.self, forKey: .id)
        }
        if decoderContainer.contains(.name)
        {
            self.name = try decoderContainer.decode(String?.self, forKey: .name)
        }
        if decoderContainer.contains(.templateType)
        {
            self.templateType = try decoderContainer.decode(String?.self, forKey: .templateType)
        }
        if decoderContainer.contains(.detections)
        {
            self.detections = try decoderContainer.decode([String?]?.self, forKey: .detections)
        }
        if decoderContainer.contains(.createTime)
        {
            self.createTime = try decoderContainer.decode(String?.self, forKey: .createTime)
        }
        if decoderContainer.contains(.updateTime)
        {
            self.updateTime = try decoderContainer.decode(String?.self, forKey: .updateTime)
        }
    }
}
public extension CreateQualityDetectionTemplateResult{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: CreateQualityDetectionTemplateResultCodingKeys.self)
        try encoderContainer.encode(id, forKey: .id)
        try encoderContainer.encode(name, forKey: .name)
        try encoderContainer.encode(templateType, forKey: .templateType)
        try encoderContainer.encode(detections, forKey: .detections)
        try encoderContainer.encode(createTime, forKey: .createTime)
        try encoderContainer.encode(updateTime, forKey: .updateTime)
    }
}

///  修改质检模板
public class UpdateQualityDetectionTemplateRequest:JdCloudRequest
{
    /// 模板名称。长度不超过128个字符。UTF-8编码。
      /// 
    var name:String?

    /// 检测项列表。取值范围：
      ///   blackScreen - 黑场
      ///   pureColor - 纯色
      ///   colorCast - 偏色
      ///   frozenFrame - 静帧
      ///   brightness - 亮度
      ///   contrast - 对比度
      /// 
    var detections:[String?]?

    /// 模板ID
    var templateId:Int64


    public init(regionId: String,templateId:Int64){
        self.templateId = templateId
        super.init(regionId: regionId)
    }


    enum UpdateQualityDetectionTemplateRequestRequestCodingKeys: String, CodingKey {
        case name
        case detections
        case templateId
    }

    public override func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: UpdateQualityDetectionTemplateRequestRequestCodingKeys.self)
        try encoderContainer.encode(name, forKey: .name)
        try encoderContainer.encode(detections, forKey: .detections)
        try encoderContainer.encode(templateId, forKey: .templateId)

    }
}

public class UpdateQualityDetectionTemplateResponse:NSObject,Codable
{
    var requestId:String?;

    var error:ServiceError?;

    var result:UpdateQualityDetectionTemplateResult?;

    enum UpdateQualityDetectionTemplateResponseCodingKeys: String, CodingKey {
        case requestId
        case error
        case result
    }

    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: UpdateQualityDetectionTemplateResponseCodingKeys.self)
        self.requestId = try decoderContainer.decodeIfPresent(String?.self, forKey: .requestId) ?? nil
        self.error = try decoderContainer.decodeIfPresent(ServiceError?.self, forKey: .error) ?? nil
        self.result = try decoderContainer.decodeIfPresent(UpdateQualityDetectionTemplateResult?.self, forKey: .result) ?? nil
    }
}

public extension UpdateQualityDetectionTemplateResponse{
        func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: UpdateQualityDetectionTemplateResponseCodingKeys.self)
        try encoderContainer.encode(requestId, forKey: .requestId)
        try encoderContainer.encode(error, forKey: .error)
        try encoderContainer.encode(result, forKey: .result)
    }
}    

///  删除质检模板
public class DeleteQualityDetectionTemplateRequest:JdCloudRequest
{
    /// 模板ID
    var templateId:Int64


    public init(regionId: String,templateId:Int64){
        self.templateId = templateId
        super.init(regionId: regionId)
    }


    enum DeleteQualityDetectionTemplateRequestRequestCodingKeys: String, CodingKey {
        case templateId
    }

    public override func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: DeleteQualityDetectionTemplateRequestRequestCodingKeys.self)
        try encoderContainer.encode(templateId, forKey: .templateId)

    }
}


///  查询质检模板
public class GetQualityDetectionTemplateRequest:JdCloudRequest
{
    /// 模板ID
    var templateId:Int64


    public init(regionId: String,templateId:Int64){
        self.templateId = templateId
        super.init(regionId: regionId)
    }


    enum GetQualityDetectionTemplateRequestRequestCodingKeys: String, CodingKey {
        case templateId
    }

    public override func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: GetQualityDetectionTemplateRequestRequestCodingKeys.self)
        try encoderContainer.encode(templateId, forKey: .templateId)

    }
}


///  查询质测模板列表。
      ///       /// 
public class ListQualityDetectionTemplatesRequest:JdCloudRequest
{
    /// 页码；默认值为 1
    var pageNumber:Int?

    /// 分页大小；默认值为 10；取值范围 [10, 100]
    var pageSize:Int?




    enum ListQualityDetectionTemplatesRequestRequestCodingKeys: String, CodingKey {
        case pageNumber
        case pageSize
    }

    public override func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: ListQualityDetectionTemplatesRequestRequestCodingKeys.self)
        try encoderContainer.encode(pageNumber, forKey: .pageNumber)
        try encoderContainer.encode(pageSize, forKey: .pageSize)

    }
}

/// 修改质检模板 
public class UpdateQualityDetectionTemplateResult:NSObject,JdCloudResult
{
    /// 模板ID
    var id:Int64?

    /// 模板名称。长度不超过128个字符。UTF-8编码。
      /// 
    var name:String?

    /// 模板类型，区分该模板的检测内容。目前只支持 video 。
    var templateType:String?

    /// 检测项列表。取值范围：
      ///   blackScreen - 黑场
      ///   pureColor - 纯色
      ///   colorCast - 偏色
      ///   frozenFrame - 静帧
      ///   brightness - 亮度
      ///   contrast - 对比度
      /// 
    var detections:[String?]?

    /// 创建时间
    var createTime:String?

    /// 修改时间
    var updateTime:String?



    public override init(){
        super.init()
    }

    enum UpdateQualityDetectionTemplateResultCodingKeys: String, CodingKey {
        case id
        case name
        case templateType
        case detections
        case createTime
        case updateTime
    }

    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: UpdateQualityDetectionTemplateResultCodingKeys.self)
        if decoderContainer.contains(.id)
        {
            self.id = try decoderContainer.decode(Int64?.self, forKey: .id)
        }
        if decoderContainer.contains(.name)
        {
            self.name = try decoderContainer.decode(String?.self, forKey: .name)
        }
        if decoderContainer.contains(.templateType)
        {
            self.templateType = try decoderContainer.decode(String?.self, forKey: .templateType)
        }
        if decoderContainer.contains(.detections)
        {
            self.detections = try decoderContainer.decode([String?]?.self, forKey: .detections)
        }
        if decoderContainer.contains(.createTime)
        {
            self.createTime = try decoderContainer.decode(String?.self, forKey: .createTime)
        }
        if decoderContainer.contains(.updateTime)
        {
            self.updateTime = try decoderContainer.decode(String?.self, forKey: .updateTime)
        }
    }
}
public extension UpdateQualityDetectionTemplateResult{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: UpdateQualityDetectionTemplateResultCodingKeys.self)
        try encoderContainer.encode(id, forKey: .id)
        try encoderContainer.encode(name, forKey: .name)
        try encoderContainer.encode(templateType, forKey: .templateType)
        try encoderContainer.encode(detections, forKey: .detections)
        try encoderContainer.encode(createTime, forKey: .createTime)
        try encoderContainer.encode(updateTime, forKey: .updateTime)
    }
}
public class CreateQualityDetectionTemplateResponse:NSObject,Codable
{
    var requestId:String?;

    var error:ServiceError?;

    var result:CreateQualityDetectionTemplateResult?;

    enum CreateQualityDetectionTemplateResponseCodingKeys: String, CodingKey {
        case requestId
        case error
        case result
    }

    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: CreateQualityDetectionTemplateResponseCodingKeys.self)
        self.requestId = try decoderContainer.decodeIfPresent(String?.self, forKey: .requestId) ?? nil
        self.error = try decoderContainer.decodeIfPresent(ServiceError?.self, forKey: .error) ?? nil
        self.result = try decoderContainer.decodeIfPresent(CreateQualityDetectionTemplateResult?.self, forKey: .result) ?? nil
    }
}

public extension CreateQualityDetectionTemplateResponse{
        func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: CreateQualityDetectionTemplateResponseCodingKeys.self)
        try encoderContainer.encode(requestId, forKey: .requestId)
        try encoderContainer.encode(error, forKey: .error)
        try encoderContainer.encode(result, forKey: .result)
    }
}    
/// 批量提交转码作业 
public class BatchSubmitTranscodeJobsResult:NSObject,JdCloudResult
{
    /// Tasks
    var tasks:[SubmittedTranscodeTask?]?



    public override init(){
        super.init()
    }

    enum BatchSubmitTranscodeJobsResultCodingKeys: String, CodingKey {
        case tasks
    }

    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: BatchSubmitTranscodeJobsResultCodingKeys.self)
        if decoderContainer.contains(.tasks)
        {
            self.tasks = try decoderContainer.decode([SubmittedTranscodeTask?]?.self, forKey: .tasks)
        }
    }
}
public extension BatchSubmitTranscodeJobsResult{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: BatchSubmitTranscodeJobsResultCodingKeys.self)
        try encoderContainer.encode(tasks, forKey: .tasks)
    }
}
public class BatchSubmitTranscodeJobsResponse:NSObject,Codable
{
    var requestId:String?;

    var error:ServiceError?;

    var result:BatchSubmitTranscodeJobsResult?;

    enum BatchSubmitTranscodeJobsResponseCodingKeys: String, CodingKey {
        case requestId
        case error
        case result
    }

    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: BatchSubmitTranscodeJobsResponseCodingKeys.self)
        self.requestId = try decoderContainer.decodeIfPresent(String?.self, forKey: .requestId) ?? nil
        self.error = try decoderContainer.decodeIfPresent(ServiceError?.self, forKey: .error) ?? nil
        self.result = try decoderContainer.decodeIfPresent(BatchSubmitTranscodeJobsResult?.self, forKey: .result) ?? nil
    }
}

public extension BatchSubmitTranscodeJobsResponse{
        func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: BatchSubmitTranscodeJobsResponseCodingKeys.self)
        try encoderContainer.encode(requestId, forKey: .requestId)
        try encoderContainer.encode(error, forKey: .error)
        try encoderContainer.encode(result, forKey: .result)
    }
}    

///  提交转码作业
public class SubmitTranscodeJobRequest:JdCloudRequest
{
    /// 视频ID
    var videoId:String?

    /// 转码模板ID列表
    var templateIds:[Int64?]?

    /// 水印ID列表
    var watermarkIds:[Int64?]?




    enum SubmitTranscodeJobRequestRequestCodingKeys: String, CodingKey {
        case videoId
        case templateIds
        case watermarkIds
    }

    public override func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: SubmitTranscodeJobRequestRequestCodingKeys.self)
        try encoderContainer.encode(videoId, forKey: .videoId)
        try encoderContainer.encode(templateIds, forKey: .templateIds)
        try encoderContainer.encode(watermarkIds, forKey: .watermarkIds)

    }
}

/// 提交转码作业 
public class SubmitTranscodeJobResult:NSObject,JdCloudResult
{
    /// 已提交的转码任务
    var tasks:[SubmittedTranscodeTask?]?



    public override init(){
        super.init()
    }

    enum SubmitTranscodeJobResultCodingKeys: String, CodingKey {
        case tasks
    }

    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: SubmitTranscodeJobResultCodingKeys.self)
        if decoderContainer.contains(.tasks)
        {
            self.tasks = try decoderContainer.decode([SubmittedTranscodeTask?]?.self, forKey: .tasks)
        }
    }
}
public extension SubmitTranscodeJobResult{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: SubmitTranscodeJobResultCodingKeys.self)
        try encoderContainer.encode(tasks, forKey: .tasks)
    }
}
public class SubmitTranscodeJobResponse:NSObject,Codable
{
    var requestId:String?;

    var error:ServiceError?;

    var result:SubmitTranscodeJobResult?;

    enum SubmitTranscodeJobResponseCodingKeys: String, CodingKey {
        case requestId
        case error
        case result
    }

    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: SubmitTranscodeJobResponseCodingKeys.self)
        self.requestId = try decoderContainer.decodeIfPresent(String?.self, forKey: .requestId) ?? nil
        self.error = try decoderContainer.decodeIfPresent(ServiceError?.self, forKey: .error) ?? nil
        self.result = try decoderContainer.decodeIfPresent(SubmitTranscodeJobResult?.self, forKey: .result) ?? nil
    }
}

public extension SubmitTranscodeJobResponse{
        func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: SubmitTranscodeJobResponseCodingKeys.self)
        try encoderContainer.encode(requestId, forKey: .requestId)
        try encoderContainer.encode(error, forKey: .error)
        try encoderContainer.encode(result, forKey: .result)
    }
}    

///  批量提交转码作业
public class BatchSubmitTranscodeJobsRequest:JdCloudRequest
{
    /// BulkItems
    var bulkItems:[SubmitTranscodeJobRequestObject?]?




    enum BatchSubmitTranscodeJobsRequestRequestCodingKeys: String, CodingKey {
        case bulkItems
    }

    public override func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: BatchSubmitTranscodeJobsRequestRequestCodingKeys.self)
        try encoderContainer.encode(bulkItems, forKey: .bulkItems)

    }
}


///  创建转码模板
public class CreateTranscodeTemplateRequest:JdCloudRequest
{
    /// 模板名称。长度不超过128个字符。UTF-8编码。
      /// 
    var name:String

    /// 视频参数配置
    var video:Video

    /// 音频参数配置
    var audio:Audio

    /// 封装配置
    var encapsulation:Encapsulation

    /// 清晰度规格标记。取值范围：
      ///   SD - 标清
      ///   HD - 高清
      ///   FHD - 超清
      ///   2K
      ///   4K
      /// 
    var definition:String

    /// 模板类型。取值范围：
      ///   jdchd - 京享超清
      ///   jdchs - 极速转码
      /// 
    var templateType:String?


    public init(regionId: String,name:String,video:Video,audio:Audio,encapsulation:Encapsulation,definition:String){
        self.name = name
        self.video = video
        self.audio = audio
        self.encapsulation = encapsulation
        self.definition = definition
        super.init(regionId: regionId)
    }


    enum CreateTranscodeTemplateRequestRequestCodingKeys: String, CodingKey {
        case name
        case video
        case audio
        case encapsulation
        case definition
        case templateType
    }

    public override func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: CreateTranscodeTemplateRequestRequestCodingKeys.self)
        try encoderContainer.encode(name, forKey: .name)
        try encoderContainer.encode(video, forKey: .video)
        try encoderContainer.encode(audio, forKey: .audio)
        try encoderContainer.encode(encapsulation, forKey: .encapsulation)
        try encoderContainer.encode(definition, forKey: .definition)
        try encoderContainer.encode(templateType, forKey: .templateType)

    }
}


///  修改转码模板
public class UpdateTranscodeTemplateRequest:JdCloudRequest
{
    /// 模板名称。长度不超过128个字符。UTF-8编码。
      /// 
    var name:String?

    /// 视频参数配置
    var video:Video?

    /// 音频参数配置
    var audio:Audio?

    /// 封装配置
    var encapsulation:Encapsulation?

    /// 清晰度规格标记。取值范围：
      ///   SD - 标清
      ///   HD - 高清
      ///   FHD - 超清
      ///   2K
      ///   4K
      /// 
    var definition:String?

    /// 模板类型。取值范围：
      ///   jdchd - 京享超清
      ///   jdchs - 极速转码
      /// 
    var templateType:String?

    /// 模板ID
    var templateId:Int64


    public init(regionId: String,templateId:Int64){
        self.templateId = templateId
        super.init(regionId: regionId)
    }


    enum UpdateTranscodeTemplateRequestRequestCodingKeys: String, CodingKey {
        case name
        case video
        case audio
        case encapsulation
        case definition
        case templateType
        case templateId
    }

    public override func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: UpdateTranscodeTemplateRequestRequestCodingKeys.self)
        try encoderContainer.encode(name, forKey: .name)
        try encoderContainer.encode(video, forKey: .video)
        try encoderContainer.encode(audio, forKey: .audio)
        try encoderContainer.encode(encapsulation, forKey: .encapsulation)
        try encoderContainer.encode(definition, forKey: .definition)
        try encoderContainer.encode(templateType, forKey: .templateType)
        try encoderContainer.encode(templateId, forKey: .templateId)

    }
}

public class CreateTranscodeTemplateResponse:NSObject,Codable
{
    var requestId:String?;

    var error:ServiceError?;

    var result:CreateTranscodeTemplateResult?;

    enum CreateTranscodeTemplateResponseCodingKeys: String, CodingKey {
        case requestId
        case error
        case result
    }

    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: CreateTranscodeTemplateResponseCodingKeys.self)
        self.requestId = try decoderContainer.decodeIfPresent(String?.self, forKey: .requestId) ?? nil
        self.error = try decoderContainer.decodeIfPresent(ServiceError?.self, forKey: .error) ?? nil
        self.result = try decoderContainer.decodeIfPresent(CreateTranscodeTemplateResult?.self, forKey: .result) ?? nil
    }
}

public extension CreateTranscodeTemplateResponse{
        func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: CreateTranscodeTemplateResponseCodingKeys.self)
        try encoderContainer.encode(requestId, forKey: .requestId)
        try encoderContainer.encode(error, forKey: .error)
        try encoderContainer.encode(result, forKey: .result)
    }
}    
/// 修改转码模板 
public class UpdateTranscodeTemplateResult:NSObject,JdCloudResult
{
    /// 模板ID
    var id:Int64?

    /// 模板名称。长度不超过128个字符。UTF-8编码。
      /// 
    var name:String?

    /// 视频参数配置
    var video:Video?

    /// 音频参数配置
    var audio:Audio?

    /// 封装配置
    var encapsulation:Encapsulation?

    /// 清晰度规格标记。取值范围：
      ///   SD - 标清
      ///   HD - 高清
      ///   FHD - 超清
      ///   2K
      ///   4K
      /// 
    var definition:String?

    /// 模板来源。取值范围：
      ///   system - 系统预置
      ///   custom - 用户自建
      /// 
    var source:String?

    /// 模板类型。取值范围：
      ///   jdchd - 京享超清
      ///   jdchs - 极速转码
      /// 
    var templateType:String?

    /// 创建时间
    var createTime:String?

    /// 修改时间
    var updateTime:String?



    public override init(){
        super.init()
    }

    enum UpdateTranscodeTemplateResultCodingKeys: String, CodingKey {
        case id
        case name
        case video
        case audio
        case encapsulation
        case definition
        case source
        case templateType
        case createTime
        case updateTime
    }

    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: UpdateTranscodeTemplateResultCodingKeys.self)
        if decoderContainer.contains(.id)
        {
            self.id = try decoderContainer.decode(Int64?.self, forKey: .id)
        }
        if decoderContainer.contains(.name)
        {
            self.name = try decoderContainer.decode(String?.self, forKey: .name)
        }
        if decoderContainer.contains(.video)
        {
            self.video = try decoderContainer.decode(Video?.self, forKey: .video)
        }
        if decoderContainer.contains(.audio)
        {
            self.audio = try decoderContainer.decode(Audio?.self, forKey: .audio)
        }
        if decoderContainer.contains(.encapsulation)
        {
            self.encapsulation = try decoderContainer.decode(Encapsulation?.self, forKey: .encapsulation)
        }
        if decoderContainer.contains(.definition)
        {
            self.definition = try decoderContainer.decode(String?.self, forKey: .definition)
        }
        if decoderContainer.contains(.source)
        {
            self.source = try decoderContainer.decode(String?.self, forKey: .source)
        }
        if decoderContainer.contains(.templateType)
        {
            self.templateType = try decoderContainer.decode(String?.self, forKey: .templateType)
        }
        if decoderContainer.contains(.createTime)
        {
            self.createTime = try decoderContainer.decode(String?.self, forKey: .createTime)
        }
        if decoderContainer.contains(.updateTime)
        {
            self.updateTime = try decoderContainer.decode(String?.self, forKey: .updateTime)
        }
    }
}
public extension UpdateTranscodeTemplateResult{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: UpdateTranscodeTemplateResultCodingKeys.self)
        try encoderContainer.encode(id, forKey: .id)
        try encoderContainer.encode(name, forKey: .name)
        try encoderContainer.encode(video, forKey: .video)
        try encoderContainer.encode(audio, forKey: .audio)
        try encoderContainer.encode(encapsulation, forKey: .encapsulation)
        try encoderContainer.encode(definition, forKey: .definition)
        try encoderContainer.encode(source, forKey: .source)
        try encoderContainer.encode(templateType, forKey: .templateType)
        try encoderContainer.encode(createTime, forKey: .createTime)
        try encoderContainer.encode(updateTime, forKey: .updateTime)
    }
}
public class DeleteTranscodeTemplateResponse:NSObject,Codable
{
    var requestId:String?;

    var error:ServiceError?;

    var result:DeleteTranscodeTemplateResult?;

    enum DeleteTranscodeTemplateResponseCodingKeys: String, CodingKey {
        case requestId
        case error
        case result
    }

    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: DeleteTranscodeTemplateResponseCodingKeys.self)
        self.requestId = try decoderContainer.decodeIfPresent(String?.self, forKey: .requestId) ?? nil
        self.error = try decoderContainer.decodeIfPresent(ServiceError?.self, forKey: .error) ?? nil
        self.result = try decoderContainer.decodeIfPresent(DeleteTranscodeTemplateResult?.self, forKey: .result) ?? nil
    }
}

public extension DeleteTranscodeTemplateResponse{
        func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: DeleteTranscodeTemplateResponseCodingKeys.self)
        try encoderContainer.encode(requestId, forKey: .requestId)
        try encoderContainer.encode(error, forKey: .error)
        try encoderContainer.encode(result, forKey: .result)
    }
}    

///  查询转码模板
public class GetTranscodeTemplateRequest:JdCloudRequest
{
    /// 模板ID
    var templateId:Int64


    public init(regionId: String,templateId:Int64){
        self.templateId = templateId
        super.init(regionId: regionId)
    }


    enum GetTranscodeTemplateRequestRequestCodingKeys: String, CodingKey {
        case templateId
    }

    public override func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: GetTranscodeTemplateRequestRequestCodingKeys.self)
        try encoderContainer.encode(templateId, forKey: .templateId)

    }
}

public class UpdateTranscodeTemplateResponse:NSObject,Codable
{
    var requestId:String?;

    var error:ServiceError?;

    var result:UpdateTranscodeTemplateResult?;

    enum UpdateTranscodeTemplateResponseCodingKeys: String, CodingKey {
        case requestId
        case error
        case result
    }

    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: UpdateTranscodeTemplateResponseCodingKeys.self)
        self.requestId = try decoderContainer.decodeIfPresent(String?.self, forKey: .requestId) ?? nil
        self.error = try decoderContainer.decodeIfPresent(ServiceError?.self, forKey: .error) ?? nil
        self.result = try decoderContainer.decodeIfPresent(UpdateTranscodeTemplateResult?.self, forKey: .result) ?? nil
    }
}

public extension UpdateTranscodeTemplateResponse{
        func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: UpdateTranscodeTemplateResponseCodingKeys.self)
        try encoderContainer.encode(requestId, forKey: .requestId)
        try encoderContainer.encode(error, forKey: .error)
        try encoderContainer.encode(result, forKey: .result)
    }
}    
/// 创建转码模板 
public class CreateTranscodeTemplateResult:NSObject,JdCloudResult
{
    /// 模板ID
    var id:Int64?

    /// 模板名称。长度不超过128个字符。UTF-8编码。
      /// 
    var name:String?

    /// 视频参数配置
    var video:Video?

    /// 音频参数配置
    var audio:Audio?

    /// 封装配置
    var encapsulation:Encapsulation?

    /// 清晰度规格标记。取值范围：
      ///   SD - 标清
      ///   HD - 高清
      ///   FHD - 超清
      ///   2K
      ///   4K
      /// 
    var definition:String?

    /// 模板来源。取值范围：
      ///   system - 系统预置
      ///   custom - 用户自建
      /// 
    var source:String?

    /// 模板类型。取值范围：
      ///   jdchd - 京享超清
      ///   jdchs - 极速转码
      /// 
    var templateType:String?

    /// 创建时间
    var createTime:String?

    /// 修改时间
    var updateTime:String?



    public override init(){
        super.init()
    }

    enum CreateTranscodeTemplateResultCodingKeys: String, CodingKey {
        case id
        case name
        case video
        case audio
        case encapsulation
        case definition
        case source
        case templateType
        case createTime
        case updateTime
    }

    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: CreateTranscodeTemplateResultCodingKeys.self)
        if decoderContainer.contains(.id)
        {
            self.id = try decoderContainer.decode(Int64?.self, forKey: .id)
        }
        if decoderContainer.contains(.name)
        {
            self.name = try decoderContainer.decode(String?.self, forKey: .name)
        }
        if decoderContainer.contains(.video)
        {
            self.video = try decoderContainer.decode(Video?.self, forKey: .video)
        }
        if decoderContainer.contains(.audio)
        {
            self.audio = try decoderContainer.decode(Audio?.self, forKey: .audio)
        }
        if decoderContainer.contains(.encapsulation)
        {
            self.encapsulation = try decoderContainer.decode(Encapsulation?.self, forKey: .encapsulation)
        }
        if decoderContainer.contains(.definition)
        {
            self.definition = try decoderContainer.decode(String?.self, forKey: .definition)
        }
        if decoderContainer.contains(.source)
        {
            self.source = try decoderContainer.decode(String?.self, forKey: .source)
        }
        if decoderContainer.contains(.templateType)
        {
            self.templateType = try decoderContainer.decode(String?.self, forKey: .templateType)
        }
        if decoderContainer.contains(.createTime)
        {
            self.createTime = try decoderContainer.decode(String?.self, forKey: .createTime)
        }
        if decoderContainer.contains(.updateTime)
        {
            self.updateTime = try decoderContainer.decode(String?.self, forKey: .updateTime)
        }
    }
}
public extension CreateTranscodeTemplateResult{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: CreateTranscodeTemplateResultCodingKeys.self)
        try encoderContainer.encode(id, forKey: .id)
        try encoderContainer.encode(name, forKey: .name)
        try encoderContainer.encode(video, forKey: .video)
        try encoderContainer.encode(audio, forKey: .audio)
        try encoderContainer.encode(encapsulation, forKey: .encapsulation)
        try encoderContainer.encode(definition, forKey: .definition)
        try encoderContainer.encode(source, forKey: .source)
        try encoderContainer.encode(templateType, forKey: .templateType)
        try encoderContainer.encode(createTime, forKey: .createTime)
        try encoderContainer.encode(updateTime, forKey: .updateTime)
    }
}
/// 查询转码模板列表。
      ///       /// 允许通过条件过滤查询，支持的过滤字段如下：
      ///       ///   - source[eq] 按模板来源精确查询
      ///       ///   - templateType[eq] 按模板类型精确查询
      ///       ///  
public class ListTranscodeTemplatesResult:NSObject,JdCloudResult
{
    /// 当前页码
    var pageNumber:Int?

    /// 每页数量
    var pageSize:Int?

    /// 查询总数
    var totalElements:Int?

    /// 总页数
    var totalPages:Int?

    /// 分页内容
    var content:[TranscodeTemplateObject?]?



    public override init(){
        super.init()
    }

    enum ListTranscodeTemplatesResultCodingKeys: String, CodingKey {
        case pageNumber
        case pageSize
        case totalElements
        case totalPages
        case content
    }

    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: ListTranscodeTemplatesResultCodingKeys.self)
        if decoderContainer.contains(.pageNumber)
        {
            self.pageNumber = try decoderContainer.decode(Int?.self, forKey: .pageNumber)
        }
        if decoderContainer.contains(.pageSize)
        {
            self.pageSize = try decoderContainer.decode(Int?.self, forKey: .pageSize)
        }
        if decoderContainer.contains(.totalElements)
        {
            self.totalElements = try decoderContainer.decode(Int?.self, forKey: .totalElements)
        }
        if decoderContainer.contains(.totalPages)
        {
            self.totalPages = try decoderContainer.decode(Int?.self, forKey: .totalPages)
        }
        if decoderContainer.contains(.content)
        {
            self.content = try decoderContainer.decode([TranscodeTemplateObject?]?.self, forKey: .content)
        }
    }
}
public extension ListTranscodeTemplatesResult{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: ListTranscodeTemplatesResultCodingKeys.self)
        try encoderContainer.encode(pageNumber, forKey: .pageNumber)
        try encoderContainer.encode(pageSize, forKey: .pageSize)
        try encoderContainer.encode(totalElements, forKey: .totalElements)
        try encoderContainer.encode(totalPages, forKey: .totalPages)
        try encoderContainer.encode(content, forKey: .content)
    }
}
/// 删除转码模板 
public class DeleteTranscodeTemplateResult:NSObject,JdCloudResult
{
}

///  查询转码模板列表。
      ///       /// 允许通过条件过滤查询，支持的过滤字段如下：
      ///       ///   - source[eq] 按模板来源精确查询
      ///       ///   - templateType[eq] 按模板类型精确查询
      ///       /// 
public class ListTranscodeTemplatesRequest:JdCloudRequest
{
    /// 页码；默认值为 1
    var pageNumber:Int?

    /// 分页大小；默认值为 10；取值范围 [10, 100]
    var pageSize:Int?

    /// Filters
    var filters:[Filter?]?




    enum ListTranscodeTemplatesRequestRequestCodingKeys: String, CodingKey {
        case pageNumber
        case pageSize
        case filters
    }

    public override func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: ListTranscodeTemplatesRequestRequestCodingKeys.self)
        try encoderContainer.encode(pageNumber, forKey: .pageNumber)
        try encoderContainer.encode(pageSize, forKey: .pageSize)
        try encoderContainer.encode(filters, forKey: .filters)

    }
}

public class ListTranscodeTemplatesResponse:NSObject,Codable
{
    var requestId:String?;

    var error:ServiceError?;

    var result:ListTranscodeTemplatesResult?;

    enum ListTranscodeTemplatesResponseCodingKeys: String, CodingKey {
        case requestId
        case error
        case result
    }

    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: ListTranscodeTemplatesResponseCodingKeys.self)
        self.requestId = try decoderContainer.decodeIfPresent(String?.self, forKey: .requestId) ?? nil
        self.error = try decoderContainer.decodeIfPresent(ServiceError?.self, forKey: .error) ?? nil
        self.result = try decoderContainer.decodeIfPresent(ListTranscodeTemplatesResult?.self, forKey: .result) ?? nil
    }
}

public extension ListTranscodeTemplatesResponse{
        func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: ListTranscodeTemplatesResponseCodingKeys.self)
        try encoderContainer.encode(requestId, forKey: .requestId)
        try encoderContainer.encode(error, forKey: .error)
        try encoderContainer.encode(result, forKey: .result)
    }
}    
public class GetTranscodeTemplateResponse:NSObject,Codable
{
    var requestId:String?;

    var error:ServiceError?;

    var result:GetTranscodeTemplateResult?;

    enum GetTranscodeTemplateResponseCodingKeys: String, CodingKey {
        case requestId
        case error
        case result
    }

    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: GetTranscodeTemplateResponseCodingKeys.self)
        self.requestId = try decoderContainer.decodeIfPresent(String?.self, forKey: .requestId) ?? nil
        self.error = try decoderContainer.decodeIfPresent(ServiceError?.self, forKey: .error) ?? nil
        self.result = try decoderContainer.decodeIfPresent(GetTranscodeTemplateResult?.self, forKey: .result) ?? nil
    }
}

public extension GetTranscodeTemplateResponse{
        func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: GetTranscodeTemplateResponseCodingKeys.self)
        try encoderContainer.encode(requestId, forKey: .requestId)
        try encoderContainer.encode(error, forKey: .error)
        try encoderContainer.encode(result, forKey: .result)
    }
}    
/// 查询转码模板 
public class GetTranscodeTemplateResult:NSObject,JdCloudResult
{
    /// 模板ID
    var id:Int64?

    /// 模板名称。长度不超过128个字符。UTF-8编码。
      /// 
    var name:String?

    /// 视频参数配置
    var video:Video?

    /// 音频参数配置
    var audio:Audio?

    /// 封装配置
    var encapsulation:Encapsulation?

    /// 清晰度规格标记。取值范围：
      ///   SD - 标清
      ///   HD - 高清
      ///   FHD - 超清
      ///   2K
      ///   4K
      /// 
    var definition:String?

    /// 模板来源。取值范围：
      ///   system - 系统预置
      ///   custom - 用户自建
      /// 
    var source:String?

    /// 模板类型。取值范围：
      ///   jdchd - 京享超清
      ///   jdchs - 极速转码
      /// 
    var templateType:String?

    /// 创建时间
    var createTime:String?

    /// 修改时间
    var updateTime:String?



    public override init(){
        super.init()
    }

    enum GetTranscodeTemplateResultCodingKeys: String, CodingKey {
        case id
        case name
        case video
        case audio
        case encapsulation
        case definition
        case source
        case templateType
        case createTime
        case updateTime
    }

    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: GetTranscodeTemplateResultCodingKeys.self)
        if decoderContainer.contains(.id)
        {
            self.id = try decoderContainer.decode(Int64?.self, forKey: .id)
        }
        if decoderContainer.contains(.name)
        {
            self.name = try decoderContainer.decode(String?.self, forKey: .name)
        }
        if decoderContainer.contains(.video)
        {
            self.video = try decoderContainer.decode(Video?.self, forKey: .video)
        }
        if decoderContainer.contains(.audio)
        {
            self.audio = try decoderContainer.decode(Audio?.self, forKey: .audio)
        }
        if decoderContainer.contains(.encapsulation)
        {
            self.encapsulation = try decoderContainer.decode(Encapsulation?.self, forKey: .encapsulation)
        }
        if decoderContainer.contains(.definition)
        {
            self.definition = try decoderContainer.decode(String?.self, forKey: .definition)
        }
        if decoderContainer.contains(.source)
        {
            self.source = try decoderContainer.decode(String?.self, forKey: .source)
        }
        if decoderContainer.contains(.templateType)
        {
            self.templateType = try decoderContainer.decode(String?.self, forKey: .templateType)
        }
        if decoderContainer.contains(.createTime)
        {
            self.createTime = try decoderContainer.decode(String?.self, forKey: .createTime)
        }
        if decoderContainer.contains(.updateTime)
        {
            self.updateTime = try decoderContainer.decode(String?.self, forKey: .updateTime)
        }
    }
}
public extension GetTranscodeTemplateResult{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: GetTranscodeTemplateResultCodingKeys.self)
        try encoderContainer.encode(id, forKey: .id)
        try encoderContainer.encode(name, forKey: .name)
        try encoderContainer.encode(video, forKey: .video)
        try encoderContainer.encode(audio, forKey: .audio)
        try encoderContainer.encode(encapsulation, forKey: .encapsulation)
        try encoderContainer.encode(definition, forKey: .definition)
        try encoderContainer.encode(source, forKey: .source)
        try encoderContainer.encode(templateType, forKey: .templateType)
        try encoderContainer.encode(createTime, forKey: .createTime)
        try encoderContainer.encode(updateTime, forKey: .updateTime)
    }
}

///  删除转码模板
public class DeleteTranscodeTemplateRequest:JdCloudRequest
{
    /// 模板ID
    var templateId:Int64


    public init(regionId: String,templateId:Int64){
        self.templateId = templateId
        super.init(regionId: regionId)
    }


    enum DeleteTranscodeTemplateRequestRequestCodingKeys: String, CodingKey {
        case templateId
    }

    public override func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: DeleteTranscodeTemplateRequestRequestCodingKeys.self)
        try encoderContainer.encode(templateId, forKey: .templateId)

    }
}

/// 查询分类及其子分类，若指定的分类ID为0，则返回一个根分类及其子分类（即一级分类）. 
public class GetCategoryWithChildrenResult:NSObject,JdCloudResult
{
    /// 分类ID
    var id:Int64?

    /// 分类名称
    var name:String?

    /// 分类级别
    var level:Int?

    /// 分类描述
    var descriptionValue:String?

    /// 下级分类
    var children:[SubCategory?]?

    /// 创建时间
    var createTime:String?

    /// 修改时间
    var updateTime:String?



    public override init(){
        super.init()
    }

    enum GetCategoryWithChildrenResultCodingKeys: String, CodingKey {
        case id
        case name
        case level
        case descriptionValue = "description"
        case children
        case createTime
        case updateTime
    }

    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: GetCategoryWithChildrenResultCodingKeys.self)
        if decoderContainer.contains(.id)
        {
            self.id = try decoderContainer.decode(Int64?.self, forKey: .id)
        }
        if decoderContainer.contains(.name)
        {
            self.name = try decoderContainer.decode(String?.self, forKey: .name)
        }
        if decoderContainer.contains(.level)
        {
            self.level = try decoderContainer.decode(Int?.self, forKey: .level)
        }
        if decoderContainer.contains(.descriptionValue)
        {
            self.descriptionValue = try decoderContainer.decode(String?.self, forKey: .descriptionValue)
        }
        if decoderContainer.contains(.children)
        {
            self.children = try decoderContainer.decode([SubCategory?]?.self, forKey: .children)
        }
        if decoderContainer.contains(.createTime)
        {
            self.createTime = try decoderContainer.decode(String?.self, forKey: .createTime)
        }
        if decoderContainer.contains(.updateTime)
        {
            self.updateTime = try decoderContainer.decode(String?.self, forKey: .updateTime)
        }
    }
}
public extension GetCategoryWithChildrenResult{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: GetCategoryWithChildrenResultCodingKeys.self)
        try encoderContainer.encode(id, forKey: .id)
        try encoderContainer.encode(name, forKey: .name)
        try encoderContainer.encode(level, forKey: .level)
        try encoderContainer.encode(descriptionValue, forKey: .descriptionValue)
        try encoderContainer.encode(children, forKey: .children)
        try encoderContainer.encode(createTime, forKey: .createTime)
        try encoderContainer.encode(updateTime, forKey: .updateTime)
    }
}
/// 修改分类 
public class UpdateCategoryResult:NSObject,JdCloudResult
{
    /// 分类ID
    var id:Int64?

    /// 分类名称
    var name:String?

    /// 分类级别。取值范围为 [0, 3]，取值为 0 时为虚拟根节点
      /// 
    var level:Int?

    /// 父分类ID，取值为 0 或 null 时，表示该分类为一级分类
      /// 
    var parentId:Int64?

    /// 分类描述信息
    var descriptionValue:String?

    /// 创建时间
    var createTime:String?

    /// 修改时间
    var updateTime:String?



    public override init(){
        super.init()
    }

    enum UpdateCategoryResultCodingKeys: String, CodingKey {
        case id
        case name
        case level
        case parentId
        case descriptionValue = "description"
        case createTime
        case updateTime
    }

    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: UpdateCategoryResultCodingKeys.self)
        if decoderContainer.contains(.id)
        {
            self.id = try decoderContainer.decode(Int64?.self, forKey: .id)
        }
        if decoderContainer.contains(.name)
        {
            self.name = try decoderContainer.decode(String?.self, forKey: .name)
        }
        if decoderContainer.contains(.level)
        {
            self.level = try decoderContainer.decode(Int?.self, forKey: .level)
        }
        if decoderContainer.contains(.parentId)
        {
            self.parentId = try decoderContainer.decode(Int64?.self, forKey: .parentId)
        }
        if decoderContainer.contains(.descriptionValue)
        {
            self.descriptionValue = try decoderContainer.decode(String?.self, forKey: .descriptionValue)
        }
        if decoderContainer.contains(.createTime)
        {
            self.createTime = try decoderContainer.decode(String?.self, forKey: .createTime)
        }
        if decoderContainer.contains(.updateTime)
        {
            self.updateTime = try decoderContainer.decode(String?.self, forKey: .updateTime)
        }
    }
}
public extension UpdateCategoryResult{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: UpdateCategoryResultCodingKeys.self)
        try encoderContainer.encode(id, forKey: .id)
        try encoderContainer.encode(name, forKey: .name)
        try encoderContainer.encode(level, forKey: .level)
        try encoderContainer.encode(parentId, forKey: .parentId)
        try encoderContainer.encode(descriptionValue, forKey: .descriptionValue)
        try encoderContainer.encode(createTime, forKey: .createTime)
        try encoderContainer.encode(updateTime, forKey: .updateTime)
    }
}
/// 删除分类 
public class DeleteCategoryResult:NSObject,JdCloudResult
{
}
public class ListCategoriesResponse:NSObject,Codable
{
    var requestId:String?;

    var error:ServiceError?;

    var result:ListCategoriesResult?;

    enum ListCategoriesResponseCodingKeys: String, CodingKey {
        case requestId
        case error
        case result
    }

    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: ListCategoriesResponseCodingKeys.self)
        self.requestId = try decoderContainer.decodeIfPresent(String?.self, forKey: .requestId) ?? nil
        self.error = try decoderContainer.decodeIfPresent(ServiceError?.self, forKey: .error) ?? nil
        self.result = try decoderContainer.decodeIfPresent(ListCategoriesResult?.self, forKey: .result) ?? nil
    }
}

public extension ListCategoriesResponse{
        func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: ListCategoriesResponseCodingKeys.self)
        try encoderContainer.encode(requestId, forKey: .requestId)
        try encoderContainer.encode(error, forKey: .error)
        try encoderContainer.encode(result, forKey: .result)
    }
}    

///  修改分类
public class UpdateCategoryRequest:JdCloudRequest
{
    /// 分类名称
    var name:String?

    /// 父分类ID，取值为 0 或 null 时，表示该分类为一级分类
      /// 
    var parentId:Int64?

    /// 分类描述信息
    var descriptionValue:String?

    /// 分类ID
    var categoryId:Int64


    public init(regionId: String,categoryId:Int64){
        self.categoryId = categoryId
        super.init(regionId: regionId)
    }


    enum UpdateCategoryRequestRequestCodingKeys: String, CodingKey {
        case name
        case parentId
        case descriptionValue = "description"
        case categoryId
    }

    public override func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: UpdateCategoryRequestRequestCodingKeys.self)
        try encoderContainer.encode(name, forKey: .name)
        try encoderContainer.encode(parentId, forKey: .parentId)
        try encoderContainer.encode(descriptionValue, forKey: .descriptionValue)
        try encoderContainer.encode(categoryId, forKey: .categoryId)

    }
}


///  查询分类列表。按照分页方式，返回分类列表信息。
public class ListCategoriesRequest:JdCloudRequest
{
    /// 页码；默认值为 1
    var pageNumber:Int?

    /// 分页大小；默认值为 10；取值范围 [10, 100]
    var pageSize:Int?

    /// Sorts
    var sorts:[Sort?]?




    enum ListCategoriesRequestRequestCodingKeys: String, CodingKey {
        case pageNumber
        case pageSize
        case sorts
    }

    public override func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: ListCategoriesRequestRequestCodingKeys.self)
        try encoderContainer.encode(pageNumber, forKey: .pageNumber)
        try encoderContainer.encode(pageSize, forKey: .pageSize)
        try encoderContainer.encode(sorts, forKey: .sorts)

    }
}

public class UpdateCategoryResponse:NSObject,Codable
{
    var requestId:String?;

    var error:ServiceError?;

    var result:UpdateCategoryResult?;

    enum UpdateCategoryResponseCodingKeys: String, CodingKey {
        case requestId
        case error
        case result
    }

    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: UpdateCategoryResponseCodingKeys.self)
        self.requestId = try decoderContainer.decodeIfPresent(String?.self, forKey: .requestId) ?? nil
        self.error = try decoderContainer.decodeIfPresent(ServiceError?.self, forKey: .error) ?? nil
        self.result = try decoderContainer.decodeIfPresent(UpdateCategoryResult?.self, forKey: .result) ?? nil
    }
}

public extension UpdateCategoryResponse{
        func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: UpdateCategoryResponseCodingKeys.self)
        try encoderContainer.encode(requestId, forKey: .requestId)
        try encoderContainer.encode(error, forKey: .error)
        try encoderContainer.encode(result, forKey: .result)
    }
}    
/// 查询分类列表。按照分页方式，返回分类列表信息。 
public class ListCategoriesResult:NSObject,JdCloudResult
{
    /// 当前页码
    var pageNumber:Int?

    /// 每页数量
    var pageSize:Int?

    /// 查询总数
    var totalElements:Int?

    /// 总页数
    var totalPages:Int?

    /// 分页内容
    var content:[CategoryObject?]?



    public override init(){
        super.init()
    }

    enum ListCategoriesResultCodingKeys: String, CodingKey {
        case pageNumber
        case pageSize
        case totalElements
        case totalPages
        case content
    }

    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: ListCategoriesResultCodingKeys.self)
        if decoderContainer.contains(.pageNumber)
        {
            self.pageNumber = try decoderContainer.decode(Int?.self, forKey: .pageNumber)
        }
        if decoderContainer.contains(.pageSize)
        {
            self.pageSize = try decoderContainer.decode(Int?.self, forKey: .pageSize)
        }
        if decoderContainer.contains(.totalElements)
        {
            self.totalElements = try decoderContainer.decode(Int?.self, forKey: .totalElements)
        }
        if decoderContainer.contains(.totalPages)
        {
            self.totalPages = try decoderContainer.decode(Int?.self, forKey: .totalPages)
        }
        if decoderContainer.contains(.content)
        {
            self.content = try decoderContainer.decode([CategoryObject?]?.self, forKey: .content)
        }
    }
}
public extension ListCategoriesResult{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: ListCategoriesResultCodingKeys.self)
        try encoderContainer.encode(pageNumber, forKey: .pageNumber)
        try encoderContainer.encode(pageSize, forKey: .pageSize)
        try encoderContainer.encode(totalElements, forKey: .totalElements)
        try encoderContainer.encode(totalPages, forKey: .totalPages)
        try encoderContainer.encode(content, forKey: .content)
    }
}

///  查询分类
public class GetCategoryRequest:JdCloudRequest
{
    /// 分类ID
    var categoryId:Int64


    public init(regionId: String,categoryId:Int64){
        self.categoryId = categoryId
        super.init(regionId: regionId)
    }


    enum GetCategoryRequestRequestCodingKeys: String, CodingKey {
        case categoryId
    }

    public override func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: GetCategoryRequestRequestCodingKeys.self)
        try encoderContainer.encode(categoryId, forKey: .categoryId)

    }
}

/// 添加分类 
public class CreateCategoryResult:NSObject,JdCloudResult
{
    /// 分类ID
    var id:Int64?

    /// 分类名称
    var name:String?

    /// 分类级别。取值范围为 [0, 3]，取值为 0 时为虚拟根节点
      /// 
    var level:Int?

    /// 父分类ID，取值为 0 或 null 时，表示该分类为一级分类
      /// 
    var parentId:Int64?

    /// 分类描述信息
    var descriptionValue:String?

    /// 创建时间
    var createTime:String?

    /// 修改时间
    var updateTime:String?



    public override init(){
        super.init()
    }

    enum CreateCategoryResultCodingKeys: String, CodingKey {
        case id
        case name
        case level
        case parentId
        case descriptionValue = "description"
        case createTime
        case updateTime
    }

    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: CreateCategoryResultCodingKeys.self)
        if decoderContainer.contains(.id)
        {
            self.id = try decoderContainer.decode(Int64?.self, forKey: .id)
        }
        if decoderContainer.contains(.name)
        {
            self.name = try decoderContainer.decode(String?.self, forKey: .name)
        }
        if decoderContainer.contains(.level)
        {
            self.level = try decoderContainer.decode(Int?.self, forKey: .level)
        }
        if decoderContainer.contains(.parentId)
        {
            self.parentId = try decoderContainer.decode(Int64?.self, forKey: .parentId)
        }
        if decoderContainer.contains(.descriptionValue)
        {
            self.descriptionValue = try decoderContainer.decode(String?.self, forKey: .descriptionValue)
        }
        if decoderContainer.contains(.createTime)
        {
            self.createTime = try decoderContainer.decode(String?.self, forKey: .createTime)
        }
        if decoderContainer.contains(.updateTime)
        {
            self.updateTime = try decoderContainer.decode(String?.self, forKey: .updateTime)
        }
    }
}
public extension CreateCategoryResult{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: CreateCategoryResultCodingKeys.self)
        try encoderContainer.encode(id, forKey: .id)
        try encoderContainer.encode(name, forKey: .name)
        try encoderContainer.encode(level, forKey: .level)
        try encoderContainer.encode(parentId, forKey: .parentId)
        try encoderContainer.encode(descriptionValue, forKey: .descriptionValue)
        try encoderContainer.encode(createTime, forKey: .createTime)
        try encoderContainer.encode(updateTime, forKey: .updateTime)
    }
}
public class GetCategoryWithChildrenResponse:NSObject,Codable
{
    var requestId:String?;

    var error:ServiceError?;

    var result:GetCategoryWithChildrenResult?;

    enum GetCategoryWithChildrenResponseCodingKeys: String, CodingKey {
        case requestId
        case error
        case result
    }

    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: GetCategoryWithChildrenResponseCodingKeys.self)
        self.requestId = try decoderContainer.decodeIfPresent(String?.self, forKey: .requestId) ?? nil
        self.error = try decoderContainer.decodeIfPresent(ServiceError?.self, forKey: .error) ?? nil
        self.result = try decoderContainer.decodeIfPresent(GetCategoryWithChildrenResult?.self, forKey: .result) ?? nil
    }
}

public extension GetCategoryWithChildrenResponse{
        func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: GetCategoryWithChildrenResponseCodingKeys.self)
        try encoderContainer.encode(requestId, forKey: .requestId)
        try encoderContainer.encode(error, forKey: .error)
        try encoderContainer.encode(result, forKey: .result)
    }
}    
public class GetCategoryResponse:NSObject,Codable
{
    var requestId:String?;

    var error:ServiceError?;

    var result:GetCategoryResult?;

    enum GetCategoryResponseCodingKeys: String, CodingKey {
        case requestId
        case error
        case result
    }

    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: GetCategoryResponseCodingKeys.self)
        self.requestId = try decoderContainer.decodeIfPresent(String?.self, forKey: .requestId) ?? nil
        self.error = try decoderContainer.decodeIfPresent(ServiceError?.self, forKey: .error) ?? nil
        self.result = try decoderContainer.decodeIfPresent(GetCategoryResult?.self, forKey: .result) ?? nil
    }
}

public extension GetCategoryResponse{
        func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: GetCategoryResponseCodingKeys.self)
        try encoderContainer.encode(requestId, forKey: .requestId)
        try encoderContainer.encode(error, forKey: .error)
        try encoderContainer.encode(result, forKey: .result)
    }
}    
public class DeleteCategoryResponse:NSObject,Codable
{
    var requestId:String?;

    var error:ServiceError?;

    var result:DeleteCategoryResult?;

    enum DeleteCategoryResponseCodingKeys: String, CodingKey {
        case requestId
        case error
        case result
    }

    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: DeleteCategoryResponseCodingKeys.self)
        self.requestId = try decoderContainer.decodeIfPresent(String?.self, forKey: .requestId) ?? nil
        self.error = try decoderContainer.decodeIfPresent(ServiceError?.self, forKey: .error) ?? nil
        self.result = try decoderContainer.decodeIfPresent(DeleteCategoryResult?.self, forKey: .result) ?? nil
    }
}

public extension DeleteCategoryResponse{
        func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: DeleteCategoryResponseCodingKeys.self)
        try encoderContainer.encode(requestId, forKey: .requestId)
        try encoderContainer.encode(error, forKey: .error)
        try encoderContainer.encode(result, forKey: .result)
    }
}    

///  查询分类及其子分类，若指定的分类ID为0，则返回一个根分类及其子分类（即一级分类）.
public class GetCategoryWithChildrenRequest:JdCloudRequest
{
    /// 分类ID
    var categoryId:Int64


    public init(regionId: String,categoryId:Int64){
        self.categoryId = categoryId
        super.init(regionId: regionId)
    }


    enum GetCategoryWithChildrenRequestRequestCodingKeys: String, CodingKey {
        case categoryId
    }

    public override func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: GetCategoryWithChildrenRequestRequestCodingKeys.self)
        try encoderContainer.encode(categoryId, forKey: .categoryId)

    }
}


///  添加分类
public class CreateCategoryRequest:JdCloudRequest
{
    /// 分类名称
    var name:String

    /// 父分类ID，取值为 0 或 null 时，表示该分类为一级分类
      /// 
    var parentId:Int64?

    /// 分类描述信息
    var descriptionValue:String?


    public init(regionId: String,name:String){
        self.name = name
        super.init(regionId: regionId)
    }


    enum CreateCategoryRequestRequestCodingKeys: String, CodingKey {
        case name
        case parentId
        case descriptionValue = "description"
    }

    public override func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: CreateCategoryRequestRequestCodingKeys.self)
        try encoderContainer.encode(name, forKey: .name)
        try encoderContainer.encode(parentId, forKey: .parentId)
        try encoderContainer.encode(descriptionValue, forKey: .descriptionValue)

    }
}

/// 查询分类 
public class GetCategoryResult:NSObject,JdCloudResult
{
    /// 分类ID
    var id:Int64?

    /// 分类名称
    var name:String?

    /// 分类级别。取值范围为 [0, 3]，取值为 0 时为虚拟根节点
      /// 
    var level:Int?

    /// 父分类ID，取值为 0 或 null 时，表示该分类为一级分类
      /// 
    var parentId:Int64?

    /// 分类描述信息
    var descriptionValue:String?

    /// 创建时间
    var createTime:String?

    /// 修改时间
    var updateTime:String?



    public override init(){
        super.init()
    }

    enum GetCategoryResultCodingKeys: String, CodingKey {
        case id
        case name
        case level
        case parentId
        case descriptionValue = "description"
        case createTime
        case updateTime
    }

    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: GetCategoryResultCodingKeys.self)
        if decoderContainer.contains(.id)
        {
            self.id = try decoderContainer.decode(Int64?.self, forKey: .id)
        }
        if decoderContainer.contains(.name)
        {
            self.name = try decoderContainer.decode(String?.self, forKey: .name)
        }
        if decoderContainer.contains(.level)
        {
            self.level = try decoderContainer.decode(Int?.self, forKey: .level)
        }
        if decoderContainer.contains(.parentId)
        {
            self.parentId = try decoderContainer.decode(Int64?.self, forKey: .parentId)
        }
        if decoderContainer.contains(.descriptionValue)
        {
            self.descriptionValue = try decoderContainer.decode(String?.self, forKey: .descriptionValue)
        }
        if decoderContainer.contains(.createTime)
        {
            self.createTime = try decoderContainer.decode(String?.self, forKey: .createTime)
        }
        if decoderContainer.contains(.updateTime)
        {
            self.updateTime = try decoderContainer.decode(String?.self, forKey: .updateTime)
        }
    }
}
public extension GetCategoryResult{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: GetCategoryResultCodingKeys.self)
        try encoderContainer.encode(id, forKey: .id)
        try encoderContainer.encode(name, forKey: .name)
        try encoderContainer.encode(level, forKey: .level)
        try encoderContainer.encode(parentId, forKey: .parentId)
        try encoderContainer.encode(descriptionValue, forKey: .descriptionValue)
        try encoderContainer.encode(createTime, forKey: .createTime)
        try encoderContainer.encode(updateTime, forKey: .updateTime)
    }
}
public class CreateCategoryResponse:NSObject,Codable
{
    var requestId:String?;

    var error:ServiceError?;

    var result:CreateCategoryResult?;

    enum CreateCategoryResponseCodingKeys: String, CodingKey {
        case requestId
        case error
        case result
    }

    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: CreateCategoryResponseCodingKeys.self)
        self.requestId = try decoderContainer.decodeIfPresent(String?.self, forKey: .requestId) ?? nil
        self.error = try decoderContainer.decodeIfPresent(ServiceError?.self, forKey: .error) ?? nil
        self.result = try decoderContainer.decodeIfPresent(CreateCategoryResult?.self, forKey: .result) ?? nil
    }
}

public extension CreateCategoryResponse{
        func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: CreateCategoryResponseCodingKeys.self)
        try encoderContainer.encode(requestId, forKey: .requestId)
        try encoderContainer.encode(error, forKey: .error)
        try encoderContainer.encode(result, forKey: .result)
    }
}    

///  删除分类
public class DeleteCategoryRequest:JdCloudRequest
{
    /// 分类ID
    var categoryId:Int64


    public init(regionId: String,categoryId:Int64){
        self.categoryId = categoryId
        super.init(regionId: regionId)
    }


    enum DeleteCategoryRequestRequestCodingKeys: String, CodingKey {
        case categoryId
    }

    public override func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: DeleteCategoryRequestRequestCodingKeys.self)
        try encoderContainer.encode(categoryId, forKey: .categoryId)

    }
}

/// 查询单个视频信息 
public class GetVideoResult:NSObject,JdCloudResult
{
    /// 视频ID
    var id:String?

    /// 视频名称
    var name:String?

    /// 视频描述
    var descriptionValue:String?

    /// 封面图地址
    var coverUrl:String?

    /// 视频状态。取值范围：
      ///   transcoding - 转码中
      ///   transcode_failed - 转码失败
      ///   normal - 正常
      ///   uploaded - 上传完成（未转码）
      /// 
    var status:String?

    /// 文件大小，单位为 Byte
    var fileSize:Int64?

    /// 文件MD5校验和
    var checksum:String?

    /// 视频时长
    var duration:Int64?

    /// 标签集合
    var tags:[String?]?

    /// 分类ID
    var categoryId:Int64?

    /// 分类名称
    var categoryName:String?

    /// 转码截图
    var snapshots:[Snapshot?]?

    /// 创建时间
    var createTime:String?

    /// 修改时间
    var updateTime:String?



    public override init(){
        super.init()
    }

    enum GetVideoResultCodingKeys: String, CodingKey {
        case id
        case name
        case descriptionValue = "description"
        case coverUrl
        case status
        case fileSize
        case checksum
        case duration
        case tags
        case categoryId
        case categoryName
        case snapshots
        case createTime
        case updateTime
    }

    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: GetVideoResultCodingKeys.self)
        if decoderContainer.contains(.id)
        {
            self.id = try decoderContainer.decode(String?.self, forKey: .id)
        }
        if decoderContainer.contains(.name)
        {
            self.name = try decoderContainer.decode(String?.self, forKey: .name)
        }
        if decoderContainer.contains(.descriptionValue)
        {
            self.descriptionValue = try decoderContainer.decode(String?.self, forKey: .descriptionValue)
        }
        if decoderContainer.contains(.coverUrl)
        {
            self.coverUrl = try decoderContainer.decode(String?.self, forKey: .coverUrl)
        }
        if decoderContainer.contains(.status)
        {
            self.status = try decoderContainer.decode(String?.self, forKey: .status)
        }
        if decoderContainer.contains(.fileSize)
        {
            self.fileSize = try decoderContainer.decode(Int64?.self, forKey: .fileSize)
        }
        if decoderContainer.contains(.checksum)
        {
            self.checksum = try decoderContainer.decode(String?.self, forKey: .checksum)
        }
        if decoderContainer.contains(.duration)
        {
            self.duration = try decoderContainer.decode(Int64?.self, forKey: .duration)
        }
        if decoderContainer.contains(.tags)
        {
            self.tags = try decoderContainer.decode([String?]?.self, forKey: .tags)
        }
        if decoderContainer.contains(.categoryId)
        {
            self.categoryId = try decoderContainer.decode(Int64?.self, forKey: .categoryId)
        }
        if decoderContainer.contains(.categoryName)
        {
            self.categoryName = try decoderContainer.decode(String?.self, forKey: .categoryName)
        }
        if decoderContainer.contains(.snapshots)
        {
            self.snapshots = try decoderContainer.decode([Snapshot?]?.self, forKey: .snapshots)
        }
        if decoderContainer.contains(.createTime)
        {
            self.createTime = try decoderContainer.decode(String?.self, forKey: .createTime)
        }
        if decoderContainer.contains(.updateTime)
        {
            self.updateTime = try decoderContainer.decode(String?.self, forKey: .updateTime)
        }
    }
}
public extension GetVideoResult{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: GetVideoResultCodingKeys.self)
        try encoderContainer.encode(id, forKey: .id)
        try encoderContainer.encode(name, forKey: .name)
        try encoderContainer.encode(descriptionValue, forKey: .descriptionValue)
        try encoderContainer.encode(coverUrl, forKey: .coverUrl)
        try encoderContainer.encode(status, forKey: .status)
        try encoderContainer.encode(fileSize, forKey: .fileSize)
        try encoderContainer.encode(checksum, forKey: .checksum)
        try encoderContainer.encode(duration, forKey: .duration)
        try encoderContainer.encode(tags, forKey: .tags)
        try encoderContainer.encode(categoryId, forKey: .categoryId)
        try encoderContainer.encode(categoryName, forKey: .categoryName)
        try encoderContainer.encode(snapshots, forKey: .snapshots)
        try encoderContainer.encode(createTime, forKey: .createTime)
        try encoderContainer.encode(updateTime, forKey: .updateTime)
    }
}
public class ListVideosResponse:NSObject,Codable
{
    var requestId:String?;

    var error:ServiceError?;

    var result:ListVideosResult?;

    enum ListVideosResponseCodingKeys: String, CodingKey {
        case requestId
        case error
        case result
    }

    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: ListVideosResponseCodingKeys.self)
        self.requestId = try decoderContainer.decodeIfPresent(String?.self, forKey: .requestId) ?? nil
        self.error = try decoderContainer.decodeIfPresent(ServiceError?.self, forKey: .error) ?? nil
        self.result = try decoderContainer.decodeIfPresent(ListVideosResult?.self, forKey: .result) ?? nil
    }
}

public extension ListVideosResponse{
        func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: ListVideosResponseCodingKeys.self)
        try encoderContainer.encode(requestId, forKey: .requestId)
        try encoderContainer.encode(error, forKey: .error)
        try encoderContainer.encode(result, forKey: .result)
    }
}    
/// 删除视频，调用该接口会同时删除与指定视频相关的所有信息，包括转码任务信息、转码流数据等，同时清除云存储中相关文件资源。 
public class DeleteVideoResult:NSObject,JdCloudResult
{
}
public class GetVideoResponse:NSObject,Codable
{
    var requestId:String?;

    var error:ServiceError?;

    var result:GetVideoResult?;

    enum GetVideoResponseCodingKeys: String, CodingKey {
        case requestId
        case error
        case result
    }

    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: GetVideoResponseCodingKeys.self)
        self.requestId = try decoderContainer.decodeIfPresent(String?.self, forKey: .requestId) ?? nil
        self.error = try decoderContainer.decodeIfPresent(ServiceError?.self, forKey: .error) ?? nil
        self.result = try decoderContainer.decodeIfPresent(GetVideoResult?.self, forKey: .result) ?? nil
    }
}

public extension GetVideoResponse{
        func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: GetVideoResponseCodingKeys.self)
        try encoderContainer.encode(requestId, forKey: .requestId)
        try encoderContainer.encode(error, forKey: .error)
        try encoderContainer.encode(result, forKey: .result)
    }
}    

///  批量修改视频信息
public class BatchUpdateVideosRequest:JdCloudRequest
{
    /// 批量更新视频的条目集合
    var bulkItems:[BatchUpdateVideosBulkItem?]?


    public init(regionId: String,bulkItems:[BatchUpdateVideosBulkItem?]?){
        self.bulkItems = bulkItems
        super.init(regionId: regionId)
    }


    enum BatchUpdateVideosRequestRequestCodingKeys: String, CodingKey {
        case bulkItems
    }

    public override func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: BatchUpdateVideosRequestRequestCodingKeys.self)
        try encoderContainer.encode(bulkItems, forKey: .bulkItems)

    }
}


///  删除视频转码流
public class DeleteVideoStreamsRequest:JdCloudRequest
{
    /// TaskIds
    var taskIds:[Int64?]?

    /// 视频ID
    var videoId:String


    public init(regionId: String,taskIds:[Int64?]?,videoId:String){
        self.taskIds = taskIds
        self.videoId = videoId
        super.init(regionId: regionId)
    }


    enum DeleteVideoStreamsRequestRequestCodingKeys: String, CodingKey {
        case taskIds
        case videoId
    }

    public override func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: DeleteVideoStreamsRequestRequestCodingKeys.self)
        try encoderContainer.encode(taskIds, forKey: .taskIds)
        try encoderContainer.encode(videoId, forKey: .videoId)

    }
}


///  删除视频，调用该接口会同时删除与指定视频相关的所有信息，包括转码任务信息、转码流数据等，同时清除云存储中相关文件资源。
public class DeleteVideoRequest:JdCloudRequest
{
    /// 视频ID
    var videoId:String


    public init(regionId: String,videoId:String){
        self.videoId = videoId
        super.init(regionId: regionId)
    }


    enum DeleteVideoRequestRequestCodingKeys: String, CodingKey {
        case videoId
    }

    public override func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: DeleteVideoRequestRequestCodingKeys.self)
        try encoderContainer.encode(videoId, forKey: .videoId)

    }
}

public class DeleteVideoResponse:NSObject,Codable
{
    var requestId:String?;

    var error:ServiceError?;

    var result:DeleteVideoResult?;

    enum DeleteVideoResponseCodingKeys: String, CodingKey {
        case requestId
        case error
        case result
    }

    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: DeleteVideoResponseCodingKeys.self)
        self.requestId = try decoderContainer.decodeIfPresent(String?.self, forKey: .requestId) ?? nil
        self.error = try decoderContainer.decodeIfPresent(ServiceError?.self, forKey: .error) ?? nil
        self.result = try decoderContainer.decodeIfPresent(DeleteVideoResult?.self, forKey: .result) ?? nil
    }
}

public extension DeleteVideoResponse{
        func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: DeleteVideoResponseCodingKeys.self)
        try encoderContainer.encode(requestId, forKey: .requestId)
        try encoderContainer.encode(error, forKey: .error)
        try encoderContainer.encode(result, forKey: .result)
    }
}    
/// 批量删除视频，调用该接口会同时删除与指定视频相关的所有信息，包括转码任务信息、转码流数据等，同时清除云存储中相关文件资源。 
public class BatchDeleteVideosResult:NSObject,JdCloudResult
{
    /// 删除成功的视频ID集合
    var okVideoIds:[String?]?

    /// 未找到的视频ID集合
    var notFoundVideoIds:[String?]?

    /// 删除失败的视频ID集合
    var failedVideoIds:[String?]?



    public override init(){
        super.init()
    }

    enum BatchDeleteVideosResultCodingKeys: String, CodingKey {
        case okVideoIds
        case notFoundVideoIds
        case failedVideoIds
    }

    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: BatchDeleteVideosResultCodingKeys.self)
        if decoderContainer.contains(.okVideoIds)
        {
            self.okVideoIds = try decoderContainer.decode([String?]?.self, forKey: .okVideoIds)
        }
        if decoderContainer.contains(.notFoundVideoIds)
        {
            self.notFoundVideoIds = try decoderContainer.decode([String?]?.self, forKey: .notFoundVideoIds)
        }
        if decoderContainer.contains(.failedVideoIds)
        {
            self.failedVideoIds = try decoderContainer.decode([String?]?.self, forKey: .failedVideoIds)
        }
    }
}
public extension BatchDeleteVideosResult{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: BatchDeleteVideosResultCodingKeys.self)
        try encoderContainer.encode(okVideoIds, forKey: .okVideoIds)
        try encoderContainer.encode(notFoundVideoIds, forKey: .notFoundVideoIds)
        try encoderContainer.encode(failedVideoIds, forKey: .failedVideoIds)
    }
}
public class GetVideoPlayInfoResponse:NSObject,Codable
{
    var requestId:String?;

    var error:ServiceError?;

    var result:GetVideoPlayInfoResult?;

    enum GetVideoPlayInfoResponseCodingKeys: String, CodingKey {
        case requestId
        case error
        case result
    }

    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: GetVideoPlayInfoResponseCodingKeys.self)
        self.requestId = try decoderContainer.decodeIfPresent(String?.self, forKey: .requestId) ?? nil
        self.error = try decoderContainer.decodeIfPresent(ServiceError?.self, forKey: .error) ?? nil
        self.result = try decoderContainer.decodeIfPresent(GetVideoPlayInfoResult?.self, forKey: .result) ?? nil
    }
}

public extension GetVideoPlayInfoResponse{
        func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: GetVideoPlayInfoResponseCodingKeys.self)
        try encoderContainer.encode(requestId, forKey: .requestId)
        try encoderContainer.encode(error, forKey: .error)
        try encoderContainer.encode(result, forKey: .result)
    }
}    
/// 查询视频列表信息。
      ///       /// 允许通过条件过滤查询，支持的过滤字段如下：
      ///       ///   - status[eq] 按视频状态精确查询
      ///       ///   - categoryId[eq] 按分类ID精确查询
      ///       ///   - videoId[eq] 按视频ID精确查询
      ///       ///   - name[eq] 按视频名称精确查询
      ///       ///  
public class ListVideosResult:NSObject,JdCloudResult
{
    /// 当前页码
    var pageNumber:Int?

    /// 每页数量
    var pageSize:Int?

    /// 查询总数
    var totalElements:Int?

    /// 总页数
    var totalPages:Int?

    /// 分页内容
    var content:[VideoObject?]?



    public override init(){
        super.init()
    }

    enum ListVideosResultCodingKeys: String, CodingKey {
        case pageNumber
        case pageSize
        case totalElements
        case totalPages
        case content
    }

    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: ListVideosResultCodingKeys.self)
        if decoderContainer.contains(.pageNumber)
        {
            self.pageNumber = try decoderContainer.decode(Int?.self, forKey: .pageNumber)
        }
        if decoderContainer.contains(.pageSize)
        {
            self.pageSize = try decoderContainer.decode(Int?.self, forKey: .pageSize)
        }
        if decoderContainer.contains(.totalElements)
        {
            self.totalElements = try decoderContainer.decode(Int?.self, forKey: .totalElements)
        }
        if decoderContainer.contains(.totalPages)
        {
            self.totalPages = try decoderContainer.decode(Int?.self, forKey: .totalPages)
        }
        if decoderContainer.contains(.content)
        {
            self.content = try decoderContainer.decode([VideoObject?]?.self, forKey: .content)
        }
    }
}
public extension ListVideosResult{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: ListVideosResultCodingKeys.self)
        try encoderContainer.encode(pageNumber, forKey: .pageNumber)
        try encoderContainer.encode(pageSize, forKey: .pageSize)
        try encoderContainer.encode(totalElements, forKey: .totalElements)
        try encoderContainer.encode(totalPages, forKey: .totalPages)
        try encoderContainer.encode(content, forKey: .content)
    }
}

///  批量删除视频，调用该接口会同时删除与指定视频相关的所有信息，包括转码任务信息、转码流数据等，同时清除云存储中相关文件资源。
public class BatchDeleteVideosRequest:JdCloudRequest
{
    /// 视频ID集合
    var videoIds:[String?]?




    enum BatchDeleteVideosRequestRequestCodingKeys: String, CodingKey {
        case videoIds
    }

    public override func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: BatchDeleteVideosRequestRequestCodingKeys.self)
        try encoderContainer.encode(videoIds, forKey: .videoIds)

    }
}

/// 修改视频信息 
public class UpdateVideoResult:NSObject,JdCloudResult
{
    /// 视频ID
    var id:String?

    /// 视频名称
    var name:String?

    /// 视频描述
    var descriptionValue:String?

    /// 封面图地址
    var coverUrl:String?

    /// 视频状态。取值范围：
      ///   transcoding - 转码中
      ///   transcode_failed - 转码失败
      ///   normal - 正常
      ///   uploaded - 上传完成（未转码）
      /// 
    var status:String?

    /// 文件大小，单位为 Byte
    var fileSize:Int64?

    /// 文件MD5校验和
    var checksum:String?

    /// 视频时长
    var duration:Int64?

    /// 标签集合
    var tags:[String?]?

    /// 分类ID
    var categoryId:Int64?

    /// 分类名称
    var categoryName:String?

    /// 转码截图
    var snapshots:[Snapshot?]?

    /// 创建时间
    var createTime:String?

    /// 修改时间
    var updateTime:String?



    public override init(){
        super.init()
    }

    enum UpdateVideoResultCodingKeys: String, CodingKey {
        case id
        case name
        case descriptionValue = "description"
        case coverUrl
        case status
        case fileSize
        case checksum
        case duration
        case tags
        case categoryId
        case categoryName
        case snapshots
        case createTime
        case updateTime
    }

    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: UpdateVideoResultCodingKeys.self)
        if decoderContainer.contains(.id)
        {
            self.id = try decoderContainer.decode(String?.self, forKey: .id)
        }
        if decoderContainer.contains(.name)
        {
            self.name = try decoderContainer.decode(String?.self, forKey: .name)
        }
        if decoderContainer.contains(.descriptionValue)
        {
            self.descriptionValue = try decoderContainer.decode(String?.self, forKey: .descriptionValue)
        }
        if decoderContainer.contains(.coverUrl)
        {
            self.coverUrl = try decoderContainer.decode(String?.self, forKey: .coverUrl)
        }
        if decoderContainer.contains(.status)
        {
            self.status = try decoderContainer.decode(String?.self, forKey: .status)
        }
        if decoderContainer.contains(.fileSize)
        {
            self.fileSize = try decoderContainer.decode(Int64?.self, forKey: .fileSize)
        }
        if decoderContainer.contains(.checksum)
        {
            self.checksum = try decoderContainer.decode(String?.self, forKey: .checksum)
        }
        if decoderContainer.contains(.duration)
        {
            self.duration = try decoderContainer.decode(Int64?.self, forKey: .duration)
        }
        if decoderContainer.contains(.tags)
        {
            self.tags = try decoderContainer.decode([String?]?.self, forKey: .tags)
        }
        if decoderContainer.contains(.categoryId)
        {
            self.categoryId = try decoderContainer.decode(Int64?.self, forKey: .categoryId)
        }
        if decoderContainer.contains(.categoryName)
        {
            self.categoryName = try decoderContainer.decode(String?.self, forKey: .categoryName)
        }
        if decoderContainer.contains(.snapshots)
        {
            self.snapshots = try decoderContainer.decode([Snapshot?]?.self, forKey: .snapshots)
        }
        if decoderContainer.contains(.createTime)
        {
            self.createTime = try decoderContainer.decode(String?.self, forKey: .createTime)
        }
        if decoderContainer.contains(.updateTime)
        {
            self.updateTime = try decoderContainer.decode(String?.self, forKey: .updateTime)
        }
    }
}
public extension UpdateVideoResult{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: UpdateVideoResultCodingKeys.self)
        try encoderContainer.encode(id, forKey: .id)
        try encoderContainer.encode(name, forKey: .name)
        try encoderContainer.encode(descriptionValue, forKey: .descriptionValue)
        try encoderContainer.encode(coverUrl, forKey: .coverUrl)
        try encoderContainer.encode(status, forKey: .status)
        try encoderContainer.encode(fileSize, forKey: .fileSize)
        try encoderContainer.encode(checksum, forKey: .checksum)
        try encoderContainer.encode(duration, forKey: .duration)
        try encoderContainer.encode(tags, forKey: .tags)
        try encoderContainer.encode(categoryId, forKey: .categoryId)
        try encoderContainer.encode(categoryName, forKey: .categoryName)
        try encoderContainer.encode(snapshots, forKey: .snapshots)
        try encoderContainer.encode(createTime, forKey: .createTime)
        try encoderContainer.encode(updateTime, forKey: .updateTime)
    }
}
public class UpdateVideoResponse:NSObject,Codable
{
    var requestId:String?;

    var error:ServiceError?;

    var result:UpdateVideoResult?;

    enum UpdateVideoResponseCodingKeys: String, CodingKey {
        case requestId
        case error
        case result
    }

    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: UpdateVideoResponseCodingKeys.self)
        self.requestId = try decoderContainer.decodeIfPresent(String?.self, forKey: .requestId) ?? nil
        self.error = try decoderContainer.decodeIfPresent(ServiceError?.self, forKey: .error) ?? nil
        self.result = try decoderContainer.decodeIfPresent(UpdateVideoResult?.self, forKey: .result) ?? nil
    }
}

public extension UpdateVideoResponse{
        func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: UpdateVideoResponseCodingKeys.self)
        try encoderContainer.encode(requestId, forKey: .requestId)
        try encoderContainer.encode(error, forKey: .error)
        try encoderContainer.encode(result, forKey: .result)
    }
}    

///  修改视频信息
public class UpdateVideoRequest:JdCloudRequest
{
    /// 视频名称
    var name:String?

    /// 分类ID
    var categoryId:Int64?

    /// 标签
    var tags:[String?]?

    /// 封面地址
    var coverUrl:String?

    /// 视频描述信息
    var descriptionValue:String?

    /// 视频ID
    var videoId:String


    public init(regionId: String,videoId:String){
        self.videoId = videoId
        super.init(regionId: regionId)
    }


    enum UpdateVideoRequestRequestCodingKeys: String, CodingKey {
        case name
        case categoryId
        case tags
        case coverUrl
        case descriptionValue = "description"
        case videoId
    }

    public override func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: UpdateVideoRequestRequestCodingKeys.self)
        try encoderContainer.encode(name, forKey: .name)
        try encoderContainer.encode(categoryId, forKey: .categoryId)
        try encoderContainer.encode(tags, forKey: .tags)
        try encoderContainer.encode(coverUrl, forKey: .coverUrl)
        try encoderContainer.encode(descriptionValue, forKey: .descriptionValue)
        try encoderContainer.encode(videoId, forKey: .videoId)

    }
}

/// 删除视频转码流 
public class DeleteVideoStreamsResult:NSObject,JdCloudResult
{
    /// 删除成功的转码任务ID列表
    var okTaskIds:[Int64?]?

    /// 未找到的转码任务ID列表
    var notFoundTaskIds:[Int64?]?

    /// 删除失败的转码任务ID列表
    var failedTaskIds:[Int64?]?



    public override init(){
        super.init()
    }

    enum DeleteVideoStreamsResultCodingKeys: String, CodingKey {
        case okTaskIds
        case notFoundTaskIds
        case failedTaskIds
    }

    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: DeleteVideoStreamsResultCodingKeys.self)
        if decoderContainer.contains(.okTaskIds)
        {
            self.okTaskIds = try decoderContainer.decode([Int64?]?.self, forKey: .okTaskIds)
        }
        if decoderContainer.contains(.notFoundTaskIds)
        {
            self.notFoundTaskIds = try decoderContainer.decode([Int64?]?.self, forKey: .notFoundTaskIds)
        }
        if decoderContainer.contains(.failedTaskIds)
        {
            self.failedTaskIds = try decoderContainer.decode([Int64?]?.self, forKey: .failedTaskIds)
        }
    }
}
public extension DeleteVideoStreamsResult{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: DeleteVideoStreamsResultCodingKeys.self)
        try encoderContainer.encode(okTaskIds, forKey: .okTaskIds)
        try encoderContainer.encode(notFoundTaskIds, forKey: .notFoundTaskIds)
        try encoderContainer.encode(failedTaskIds, forKey: .failedTaskIds)
    }
}

///  查询单个视频信息
public class GetVideoRequest:JdCloudRequest
{
    /// 视频ID
    var videoId:String


    public init(regionId: String,videoId:String){
        self.videoId = videoId
        super.init(regionId: regionId)
    }


    enum GetVideoRequestRequestCodingKeys: String, CodingKey {
        case videoId
    }

    public override func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: GetVideoRequestRequestCodingKeys.self)
        try encoderContainer.encode(videoId, forKey: .videoId)

    }
}

public class BatchDeleteVideosResponse:NSObject,Codable
{
    var requestId:String?;

    var error:ServiceError?;

    var result:BatchDeleteVideosResult?;

    enum BatchDeleteVideosResponseCodingKeys: String, CodingKey {
        case requestId
        case error
        case result
    }

    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: BatchDeleteVideosResponseCodingKeys.self)
        self.requestId = try decoderContainer.decodeIfPresent(String?.self, forKey: .requestId) ?? nil
        self.error = try decoderContainer.decodeIfPresent(ServiceError?.self, forKey: .error) ?? nil
        self.result = try decoderContainer.decodeIfPresent(BatchDeleteVideosResult?.self, forKey: .result) ?? nil
    }
}

public extension BatchDeleteVideosResponse{
        func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: BatchDeleteVideosResponseCodingKeys.self)
        try encoderContainer.encode(requestId, forKey: .requestId)
        try encoderContainer.encode(error, forKey: .error)
        try encoderContainer.encode(result, forKey: .result)
    }
}    

///  获取视频播放信息
public class GetVideoPlayInfoRequest:JdCloudRequest
{
    /// 视频ID
    var videoId:String


    public init(regionId: String,videoId:String){
        self.videoId = videoId
        super.init(regionId: regionId)
    }


    enum GetVideoPlayInfoRequestRequestCodingKeys: String, CodingKey {
        case videoId
    }

    public override func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: GetVideoPlayInfoRequestRequestCodingKeys.self)
        try encoderContainer.encode(videoId, forKey: .videoId)

    }
}

/// 批量修改视频信息 
public class BatchUpdateVideosResult:NSObject,JdCloudResult
{
    /// 更新成功的视频ID列表
    var okVideoIds:[String?]?

    /// 未找到的视频ID列表
    var notFoundVideoIds:[String?]?

    /// 更新失败的视频ID列表
    var failedVideoIds:[String?]?



    public override init(){
        super.init()
    }

    enum BatchUpdateVideosResultCodingKeys: String, CodingKey {
        case okVideoIds
        case notFoundVideoIds
        case failedVideoIds
    }

    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: BatchUpdateVideosResultCodingKeys.self)
        if decoderContainer.contains(.okVideoIds)
        {
            self.okVideoIds = try decoderContainer.decode([String?]?.self, forKey: .okVideoIds)
        }
        if decoderContainer.contains(.notFoundVideoIds)
        {
            self.notFoundVideoIds = try decoderContainer.decode([String?]?.self, forKey: .notFoundVideoIds)
        }
        if decoderContainer.contains(.failedVideoIds)
        {
            self.failedVideoIds = try decoderContainer.decode([String?]?.self, forKey: .failedVideoIds)
        }
    }
}
public extension BatchUpdateVideosResult{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: BatchUpdateVideosResultCodingKeys.self)
        try encoderContainer.encode(okVideoIds, forKey: .okVideoIds)
        try encoderContainer.encode(notFoundVideoIds, forKey: .notFoundVideoIds)
        try encoderContainer.encode(failedVideoIds, forKey: .failedVideoIds)
    }
}
/// 获取视频播放信息 
public class GetVideoPlayInfoResult:NSObject,JdCloudResult
{
    /// 视频基础信息
    var baseInfo:VideoBaseInfo?

    /// 视频播放信息列表
    var playInfoList:[VideoPlayInfo?]?



    public override init(){
        super.init()
    }

    enum GetVideoPlayInfoResultCodingKeys: String, CodingKey {
        case baseInfo
        case playInfoList
    }

    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: GetVideoPlayInfoResultCodingKeys.self)
        if decoderContainer.contains(.baseInfo)
        {
            self.baseInfo = try decoderContainer.decode(VideoBaseInfo?.self, forKey: .baseInfo)
        }
        if decoderContainer.contains(.playInfoList)
        {
            self.playInfoList = try decoderContainer.decode([VideoPlayInfo?]?.self, forKey: .playInfoList)
        }
    }
}
public extension GetVideoPlayInfoResult{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: GetVideoPlayInfoResultCodingKeys.self)
        try encoderContainer.encode(baseInfo, forKey: .baseInfo)
        try encoderContainer.encode(playInfoList, forKey: .playInfoList)
    }
}
public class DeleteVideoStreamsResponse:NSObject,Codable
{
    var requestId:String?;

    var error:ServiceError?;

    var result:DeleteVideoStreamsResult?;

    enum DeleteVideoStreamsResponseCodingKeys: String, CodingKey {
        case requestId
        case error
        case result
    }

    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: DeleteVideoStreamsResponseCodingKeys.self)
        self.requestId = try decoderContainer.decodeIfPresent(String?.self, forKey: .requestId) ?? nil
        self.error = try decoderContainer.decodeIfPresent(ServiceError?.self, forKey: .error) ?? nil
        self.result = try decoderContainer.decodeIfPresent(DeleteVideoStreamsResult?.self, forKey: .result) ?? nil
    }
}

public extension DeleteVideoStreamsResponse{
        func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: DeleteVideoStreamsResponseCodingKeys.self)
        try encoderContainer.encode(requestId, forKey: .requestId)
        try encoderContainer.encode(error, forKey: .error)
        try encoderContainer.encode(result, forKey: .result)
    }
}    

///  查询视频列表信息。
      ///       /// 允许通过条件过滤查询，支持的过滤字段如下：
      ///       ///   - status[eq] 按视频状态精确查询
      ///       ///   - categoryId[eq] 按分类ID精确查询
      ///       ///   - videoId[eq] 按视频ID精确查询
      ///       ///   - name[eq] 按视频名称精确查询
      ///       /// 
public class ListVideosRequest:JdCloudRequest
{
    /// 页码；默认值为 1
    var pageNumber:Int?

    /// 分页大小；默认值为 10；取值范围 [10, 100]
    var pageSize:Int?

    /// Filters
    var filters:[Filter?]?

    /// Sorts
    var sorts:[Sort?]?




    enum ListVideosRequestRequestCodingKeys: String, CodingKey {
        case pageNumber
        case pageSize
        case filters
        case sorts
    }

    public override func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: ListVideosRequestRequestCodingKeys.self)
        try encoderContainer.encode(pageNumber, forKey: .pageNumber)
        try encoderContainer.encode(pageSize, forKey: .pageSize)
        try encoderContainer.encode(filters, forKey: .filters)
        try encoderContainer.encode(sorts, forKey: .sorts)

    }
}

public class BatchUpdateVideosResponse:NSObject,Codable
{
    var requestId:String?;

    var error:ServiceError?;

    var result:BatchUpdateVideosResult?;

    enum BatchUpdateVideosResponseCodingKeys: String, CodingKey {
        case requestId
        case error
        case result
    }

    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: BatchUpdateVideosResponseCodingKeys.self)
        self.requestId = try decoderContainer.decodeIfPresent(String?.self, forKey: .requestId) ?? nil
        self.error = try decoderContainer.decodeIfPresent(ServiceError?.self, forKey: .error) ?? nil
        self.result = try decoderContainer.decodeIfPresent(BatchUpdateVideosResult?.self, forKey: .result) ?? nil
    }
}

public extension BatchUpdateVideosResponse{
        func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: BatchUpdateVideosResponseCodingKeys.self)
        try encoderContainer.encode(requestId, forKey: .requestId)
        try encoderContainer.encode(error, forKey: .error)
        try encoderContainer.encode(result, forKey: .result)
    }
}    
/// 添加水印 
public class CreateWatermarkResult:NSObject,JdCloudResult
{
    /// 水印ID
    var id:Int64?

    /// 水印名称。只支持中英文、数字。长度不超过128个字符。UTF-8编码。
      /// 
    var name:String?

    /// 图片地址
    var imgUrl:String?

    /// 水印宽度。
      /// 当 sizeUnit &#x3D; pixel 时，取值范围为 [8, 4096] 整数
      /// 当 sizeUnit &#x3D; percent 时，取值范围为 [0, 100] 小数
      /// 
    var width:String?

    /// 水印高度。
      /// 当 sizeUnit &#x3D; pixel 时，取值范围为 [8, 4096] 整数
      /// 当 sizeUnit &#x3D; percent 时，取值范围为 [0, 100] 小数
      /// 
    var height:String?

    /// 尺寸单位。取值范围：
      ///   pixel - 像素
      ///   percent - 百分比
      /// 默认值为 pixel
      /// 
    var sizeUnit:String?

    /// 水印位置。取值范围：
      ///   LT - 左上
      ///   RT - 右上
      ///   LB - 左下
      ///   RB - 右下
    var position:String?

    /// 水平偏移。
      /// 当 offsetUnit &#x3D; pixel 时，取值范围为 [8, 4088] 整数
      /// 当 offsetUnit &#x3D; percent 时，取值范围为 [0, 100] 小数
      /// 
    var offsetX:String?

    /// 竖直偏移。
      /// 当 offsetUnit &#x3D; pixel 时，取值范围为 [8, 4088] 整数
      /// 当 offsetUnit &#x3D; percent 时，取值范围为 [0, 100] 小数
      /// 
    var offsetY:String?

    /// 偏移单位。取值范围：
      ///   pixel - 像素
      ///   percent - 百分比
      /// 默认值为 pixel
      /// 
    var offsetUnit:String?

    /// 创建时间
    var createTime:String?

    /// 修改时间
    var updateTime:String?



    public override init(){
        super.init()
    }

    enum CreateWatermarkResultCodingKeys: String, CodingKey {
        case id
        case name
        case imgUrl
        case width
        case height
        case sizeUnit
        case position
        case offsetX
        case offsetY
        case offsetUnit
        case createTime
        case updateTime
    }

    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: CreateWatermarkResultCodingKeys.self)
        if decoderContainer.contains(.id)
        {
            self.id = try decoderContainer.decode(Int64?.self, forKey: .id)
        }
        if decoderContainer.contains(.name)
        {
            self.name = try decoderContainer.decode(String?.self, forKey: .name)
        }
        if decoderContainer.contains(.imgUrl)
        {
            self.imgUrl = try decoderContainer.decode(String?.self, forKey: .imgUrl)
        }
        if decoderContainer.contains(.width)
        {
            self.width = try decoderContainer.decode(String?.self, forKey: .width)
        }
        if decoderContainer.contains(.height)
        {
            self.height = try decoderContainer.decode(String?.self, forKey: .height)
        }
        if decoderContainer.contains(.sizeUnit)
        {
            self.sizeUnit = try decoderContainer.decode(String?.self, forKey: .sizeUnit)
        }
        if decoderContainer.contains(.position)
        {
            self.position = try decoderContainer.decode(String?.self, forKey: .position)
        }
        if decoderContainer.contains(.offsetX)
        {
            self.offsetX = try decoderContainer.decode(String?.self, forKey: .offsetX)
        }
        if decoderContainer.contains(.offsetY)
        {
            self.offsetY = try decoderContainer.decode(String?.self, forKey: .offsetY)
        }
        if decoderContainer.contains(.offsetUnit)
        {
            self.offsetUnit = try decoderContainer.decode(String?.self, forKey: .offsetUnit)
        }
        if decoderContainer.contains(.createTime)
        {
            self.createTime = try decoderContainer.decode(String?.self, forKey: .createTime)
        }
        if decoderContainer.contains(.updateTime)
        {
            self.updateTime = try decoderContainer.decode(String?.self, forKey: .updateTime)
        }
    }
}
public extension CreateWatermarkResult{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: CreateWatermarkResultCodingKeys.self)
        try encoderContainer.encode(id, forKey: .id)
        try encoderContainer.encode(name, forKey: .name)
        try encoderContainer.encode(imgUrl, forKey: .imgUrl)
        try encoderContainer.encode(width, forKey: .width)
        try encoderContainer.encode(height, forKey: .height)
        try encoderContainer.encode(sizeUnit, forKey: .sizeUnit)
        try encoderContainer.encode(position, forKey: .position)
        try encoderContainer.encode(offsetX, forKey: .offsetX)
        try encoderContainer.encode(offsetY, forKey: .offsetY)
        try encoderContainer.encode(offsetUnit, forKey: .offsetUnit)
        try encoderContainer.encode(createTime, forKey: .createTime)
        try encoderContainer.encode(updateTime, forKey: .updateTime)
    }
}
/// 修改水印 
public class UpdateWatermarkResult:NSObject,JdCloudResult
{
    /// 水印ID
    var id:Int64?

    /// 水印名称。只支持中英文、数字。长度不超过128个字符。UTF-8编码。
      /// 
    var name:String?

    /// 图片地址
    var imgUrl:String?

    /// 水印宽度。
      /// 当 sizeUnit &#x3D; pixel 时，取值范围为 [8, 4096] 整数
      /// 当 sizeUnit &#x3D; percent 时，取值范围为 [0, 100] 小数
      /// 
    var width:String?

    /// 水印高度。
      /// 当 sizeUnit &#x3D; pixel 时，取值范围为 [8, 4096] 整数
      /// 当 sizeUnit &#x3D; percent 时，取值范围为 [0, 100] 小数
      /// 
    var height:String?

    /// 尺寸单位。取值范围：
      ///   pixel - 像素
      ///   percent - 百分比
      /// 默认值为 pixel
      /// 
    var sizeUnit:String?

    /// 水印位置。取值范围：
      ///   LT - 左上
      ///   RT - 右上
      ///   LB - 左下
      ///   RB - 右下
    var position:String?

    /// 水平偏移。
      /// 当 offsetUnit &#x3D; pixel 时，取值范围为 [8, 4088] 整数
      /// 当 offsetUnit &#x3D; percent 时，取值范围为 [0, 100] 小数
      /// 
    var offsetX:String?

    /// 竖直偏移。
      /// 当 offsetUnit &#x3D; pixel 时，取值范围为 [8, 4088] 整数
      /// 当 offsetUnit &#x3D; percent 时，取值范围为 [0, 100] 小数
      /// 
    var offsetY:String?

    /// 偏移单位。取值范围：
      ///   pixel - 像素
      ///   percent - 百分比
      /// 默认值为 pixel
      /// 
    var offsetUnit:String?

    /// 创建时间
    var createTime:String?

    /// 修改时间
    var updateTime:String?



    public override init(){
        super.init()
    }

    enum UpdateWatermarkResultCodingKeys: String, CodingKey {
        case id
        case name
        case imgUrl
        case width
        case height
        case sizeUnit
        case position
        case offsetX
        case offsetY
        case offsetUnit
        case createTime
        case updateTime
    }

    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: UpdateWatermarkResultCodingKeys.self)
        if decoderContainer.contains(.id)
        {
            self.id = try decoderContainer.decode(Int64?.self, forKey: .id)
        }
        if decoderContainer.contains(.name)
        {
            self.name = try decoderContainer.decode(String?.self, forKey: .name)
        }
        if decoderContainer.contains(.imgUrl)
        {
            self.imgUrl = try decoderContainer.decode(String?.self, forKey: .imgUrl)
        }
        if decoderContainer.contains(.width)
        {
            self.width = try decoderContainer.decode(String?.self, forKey: .width)
        }
        if decoderContainer.contains(.height)
        {
            self.height = try decoderContainer.decode(String?.self, forKey: .height)
        }
        if decoderContainer.contains(.sizeUnit)
        {
            self.sizeUnit = try decoderContainer.decode(String?.self, forKey: .sizeUnit)
        }
        if decoderContainer.contains(.position)
        {
            self.position = try decoderContainer.decode(String?.self, forKey: .position)
        }
        if decoderContainer.contains(.offsetX)
        {
            self.offsetX = try decoderContainer.decode(String?.self, forKey: .offsetX)
        }
        if decoderContainer.contains(.offsetY)
        {
            self.offsetY = try decoderContainer.decode(String?.self, forKey: .offsetY)
        }
        if decoderContainer.contains(.offsetUnit)
        {
            self.offsetUnit = try decoderContainer.decode(String?.self, forKey: .offsetUnit)
        }
        if decoderContainer.contains(.createTime)
        {
            self.createTime = try decoderContainer.decode(String?.self, forKey: .createTime)
        }
        if decoderContainer.contains(.updateTime)
        {
            self.updateTime = try decoderContainer.decode(String?.self, forKey: .updateTime)
        }
    }
}
public extension UpdateWatermarkResult{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: UpdateWatermarkResultCodingKeys.self)
        try encoderContainer.encode(id, forKey: .id)
        try encoderContainer.encode(name, forKey: .name)
        try encoderContainer.encode(imgUrl, forKey: .imgUrl)
        try encoderContainer.encode(width, forKey: .width)
        try encoderContainer.encode(height, forKey: .height)
        try encoderContainer.encode(sizeUnit, forKey: .sizeUnit)
        try encoderContainer.encode(position, forKey: .position)
        try encoderContainer.encode(offsetX, forKey: .offsetX)
        try encoderContainer.encode(offsetY, forKey: .offsetY)
        try encoderContainer.encode(offsetUnit, forKey: .offsetUnit)
        try encoderContainer.encode(createTime, forKey: .createTime)
        try encoderContainer.encode(updateTime, forKey: .updateTime)
    }
}
/// 删除水印 
public class DeleteWatermarkResult:NSObject,JdCloudResult
{
}
public class GetWatermarkResponse:NSObject,Codable
{
    var requestId:String?;

    var error:ServiceError?;

    var result:GetWatermarkResult?;

    enum GetWatermarkResponseCodingKeys: String, CodingKey {
        case requestId
        case error
        case result
    }

    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: GetWatermarkResponseCodingKeys.self)
        self.requestId = try decoderContainer.decodeIfPresent(String?.self, forKey: .requestId) ?? nil
        self.error = try decoderContainer.decodeIfPresent(ServiceError?.self, forKey: .error) ?? nil
        self.result = try decoderContainer.decodeIfPresent(GetWatermarkResult?.self, forKey: .result) ?? nil
    }
}

public extension GetWatermarkResponse{
        func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: GetWatermarkResponseCodingKeys.self)
        try encoderContainer.encode(requestId, forKey: .requestId)
        try encoderContainer.encode(error, forKey: .error)
        try encoderContainer.encode(result, forKey: .result)
    }
}    
public class DeleteWatermarkResponse:NSObject,Codable
{
    var requestId:String?;

    var error:ServiceError?;

    var result:DeleteWatermarkResult?;

    enum DeleteWatermarkResponseCodingKeys: String, CodingKey {
        case requestId
        case error
        case result
    }

    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: DeleteWatermarkResponseCodingKeys.self)
        self.requestId = try decoderContainer.decodeIfPresent(String?.self, forKey: .requestId) ?? nil
        self.error = try decoderContainer.decodeIfPresent(ServiceError?.self, forKey: .error) ?? nil
        self.result = try decoderContainer.decodeIfPresent(DeleteWatermarkResult?.self, forKey: .result) ?? nil
    }
}

public extension DeleteWatermarkResponse{
        func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: DeleteWatermarkResponseCodingKeys.self)
        try encoderContainer.encode(requestId, forKey: .requestId)
        try encoderContainer.encode(error, forKey: .error)
        try encoderContainer.encode(result, forKey: .result)
    }
}    
/// 查询水印列表 
public class ListWatermarksResult:NSObject,JdCloudResult
{
    /// 当前页码
    var pageNumber:Int?

    /// 每页数量
    var pageSize:Int?

    /// 查询总数
    var totalElements:Int?

    /// 总页数
    var totalPages:Int?

    /// 分页内容
    var content:[WatermarkObject?]?



    public override init(){
        super.init()
    }

    enum ListWatermarksResultCodingKeys: String, CodingKey {
        case pageNumber
        case pageSize
        case totalElements
        case totalPages
        case content
    }

    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: ListWatermarksResultCodingKeys.self)
        if decoderContainer.contains(.pageNumber)
        {
            self.pageNumber = try decoderContainer.decode(Int?.self, forKey: .pageNumber)
        }
        if decoderContainer.contains(.pageSize)
        {
            self.pageSize = try decoderContainer.decode(Int?.self, forKey: .pageSize)
        }
        if decoderContainer.contains(.totalElements)
        {
            self.totalElements = try decoderContainer.decode(Int?.self, forKey: .totalElements)
        }
        if decoderContainer.contains(.totalPages)
        {
            self.totalPages = try decoderContainer.decode(Int?.self, forKey: .totalPages)
        }
        if decoderContainer.contains(.content)
        {
            self.content = try decoderContainer.decode([WatermarkObject?]?.self, forKey: .content)
        }
    }
}
public extension ListWatermarksResult{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: ListWatermarksResultCodingKeys.self)
        try encoderContainer.encode(pageNumber, forKey: .pageNumber)
        try encoderContainer.encode(pageSize, forKey: .pageSize)
        try encoderContainer.encode(totalElements, forKey: .totalElements)
        try encoderContainer.encode(totalPages, forKey: .totalPages)
        try encoderContainer.encode(content, forKey: .content)
    }
}
/// 查询水印 
public class GetWatermarkResult:NSObject,JdCloudResult
{
    /// 水印ID
    var id:Int64?

    /// 水印名称。只支持中英文、数字。长度不超过128个字符。UTF-8编码。
      /// 
    var name:String?

    /// 图片地址
    var imgUrl:String?

    /// 水印宽度。
      /// 当 sizeUnit &#x3D; pixel 时，取值范围为 [8, 4096] 整数
      /// 当 sizeUnit &#x3D; percent 时，取值范围为 [0, 100] 小数
      /// 
    var width:String?

    /// 水印高度。
      /// 当 sizeUnit &#x3D; pixel 时，取值范围为 [8, 4096] 整数
      /// 当 sizeUnit &#x3D; percent 时，取值范围为 [0, 100] 小数
      /// 
    var height:String?

    /// 尺寸单位。取值范围：
      ///   pixel - 像素
      ///   percent - 百分比
      /// 默认值为 pixel
      /// 
    var sizeUnit:String?

    /// 水印位置。取值范围：
      ///   LT - 左上
      ///   RT - 右上
      ///   LB - 左下
      ///   RB - 右下
    var position:String?

    /// 水平偏移。
      /// 当 offsetUnit &#x3D; pixel 时，取值范围为 [8, 4088] 整数
      /// 当 offsetUnit &#x3D; percent 时，取值范围为 [0, 100] 小数
      /// 
    var offsetX:String?

    /// 竖直偏移。
      /// 当 offsetUnit &#x3D; pixel 时，取值范围为 [8, 4088] 整数
      /// 当 offsetUnit &#x3D; percent 时，取值范围为 [0, 100] 小数
      /// 
    var offsetY:String?

    /// 偏移单位。取值范围：
      ///   pixel - 像素
      ///   percent - 百分比
      /// 默认值为 pixel
      /// 
    var offsetUnit:String?

    /// 创建时间
    var createTime:String?

    /// 修改时间
    var updateTime:String?



    public override init(){
        super.init()
    }

    enum GetWatermarkResultCodingKeys: String, CodingKey {
        case id
        case name
        case imgUrl
        case width
        case height
        case sizeUnit
        case position
        case offsetX
        case offsetY
        case offsetUnit
        case createTime
        case updateTime
    }

    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: GetWatermarkResultCodingKeys.self)
        if decoderContainer.contains(.id)
        {
            self.id = try decoderContainer.decode(Int64?.self, forKey: .id)
        }
        if decoderContainer.contains(.name)
        {
            self.name = try decoderContainer.decode(String?.self, forKey: .name)
        }
        if decoderContainer.contains(.imgUrl)
        {
            self.imgUrl = try decoderContainer.decode(String?.self, forKey: .imgUrl)
        }
        if decoderContainer.contains(.width)
        {
            self.width = try decoderContainer.decode(String?.self, forKey: .width)
        }
        if decoderContainer.contains(.height)
        {
            self.height = try decoderContainer.decode(String?.self, forKey: .height)
        }
        if decoderContainer.contains(.sizeUnit)
        {
            self.sizeUnit = try decoderContainer.decode(String?.self, forKey: .sizeUnit)
        }
        if decoderContainer.contains(.position)
        {
            self.position = try decoderContainer.decode(String?.self, forKey: .position)
        }
        if decoderContainer.contains(.offsetX)
        {
            self.offsetX = try decoderContainer.decode(String?.self, forKey: .offsetX)
        }
        if decoderContainer.contains(.offsetY)
        {
            self.offsetY = try decoderContainer.decode(String?.self, forKey: .offsetY)
        }
        if decoderContainer.contains(.offsetUnit)
        {
            self.offsetUnit = try decoderContainer.decode(String?.self, forKey: .offsetUnit)
        }
        if decoderContainer.contains(.createTime)
        {
            self.createTime = try decoderContainer.decode(String?.self, forKey: .createTime)
        }
        if decoderContainer.contains(.updateTime)
        {
            self.updateTime = try decoderContainer.decode(String?.self, forKey: .updateTime)
        }
    }
}
public extension GetWatermarkResult{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: GetWatermarkResultCodingKeys.self)
        try encoderContainer.encode(id, forKey: .id)
        try encoderContainer.encode(name, forKey: .name)
        try encoderContainer.encode(imgUrl, forKey: .imgUrl)
        try encoderContainer.encode(width, forKey: .width)
        try encoderContainer.encode(height, forKey: .height)
        try encoderContainer.encode(sizeUnit, forKey: .sizeUnit)
        try encoderContainer.encode(position, forKey: .position)
        try encoderContainer.encode(offsetX, forKey: .offsetX)
        try encoderContainer.encode(offsetY, forKey: .offsetY)
        try encoderContainer.encode(offsetUnit, forKey: .offsetUnit)
        try encoderContainer.encode(createTime, forKey: .createTime)
        try encoderContainer.encode(updateTime, forKey: .updateTime)
    }
}

///  查询水印
public class GetWatermarkRequest:JdCloudRequest
{
    /// 水印ID
    var watermarkId:Int64


    public init(regionId: String,watermarkId:Int64){
        self.watermarkId = watermarkId
        super.init(regionId: regionId)
    }


    enum GetWatermarkRequestRequestCodingKeys: String, CodingKey {
        case watermarkId
    }

    public override func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: GetWatermarkRequestRequestCodingKeys.self)
        try encoderContainer.encode(watermarkId, forKey: .watermarkId)

    }
}

public class UpdateWatermarkResponse:NSObject,Codable
{
    var requestId:String?;

    var error:ServiceError?;

    var result:UpdateWatermarkResult?;

    enum UpdateWatermarkResponseCodingKeys: String, CodingKey {
        case requestId
        case error
        case result
    }

    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: UpdateWatermarkResponseCodingKeys.self)
        self.requestId = try decoderContainer.decodeIfPresent(String?.self, forKey: .requestId) ?? nil
        self.error = try decoderContainer.decodeIfPresent(ServiceError?.self, forKey: .error) ?? nil
        self.result = try decoderContainer.decodeIfPresent(UpdateWatermarkResult?.self, forKey: .result) ?? nil
    }
}

public extension UpdateWatermarkResponse{
        func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: UpdateWatermarkResponseCodingKeys.self)
        try encoderContainer.encode(requestId, forKey: .requestId)
        try encoderContainer.encode(error, forKey: .error)
        try encoderContainer.encode(result, forKey: .result)
    }
}    

///  查询水印列表
public class ListWatermarksRequest:JdCloudRequest
{
    /// 页码；默认值为 1
    var pageNumber:Int?

    /// 分页大小；默认值为 10；取值范围 [10, 100]
    var pageSize:Int?




    enum ListWatermarksRequestRequestCodingKeys: String, CodingKey {
        case pageNumber
        case pageSize
    }

    public override func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: ListWatermarksRequestRequestCodingKeys.self)
        try encoderContainer.encode(pageNumber, forKey: .pageNumber)
        try encoderContainer.encode(pageSize, forKey: .pageSize)

    }
}


///  修改水印
public class UpdateWatermarkRequest:JdCloudRequest
{
    /// 水印名称。只支持中英文、数字。长度不超过128个字符。UTF-8编码。
      /// 
    var name:String?

    /// 图片地址
    var imgUrl:String?

    /// 水印宽度。
      /// 当 sizeUnit &#x3D; pixel 时，取值范围为 [8, 4096] 整数
      /// 当 sizeUnit &#x3D; percent 时，取值范围为 [0, 100] 小数
      /// 
    var width:String?

    /// 水印高度。
      /// 当 sizeUnit &#x3D; pixel 时，取值范围为 [8, 4096] 整数
      /// 当 sizeUnit &#x3D; percent 时，取值范围为 [0, 100] 小数
      /// 
    var height:String?

    /// 尺寸单位。取值范围：
      ///   pixel - 像素
      ///   percent - 百分比
      /// 默认值为 pixel
      /// 
    var sizeUnit:String?

    /// 水印位置。取值范围：
      ///   LT - 左上
      ///   RT - 右上
      ///   LB - 左下
      ///   RB - 右下
      /// 
    var position:String?

    /// 水平偏移。
      /// 当 offsetUnit &#x3D; pixel 时，取值范围为 [8, 4088] 整数
      /// 当 offsetUnit &#x3D; percent 时，取值范围为 [0, 100] 小数
      /// 
    var offsetX:String?

    /// 竖直偏移。
      /// 当 offsetUnit &#x3D; pixel 时，取值范围为 [8, 4088] 整数
      /// 当 offsetUnit &#x3D; percent 时，取值范围为 [0, 100] 小数
      /// 
    var offsetY:String?

    /// 偏移单位。取值范围：
      ///   pixel - 像素
      ///   percent - 百分比
      /// 默认值为 pixel
      /// 
    var offsetUnit:String?

    /// 水印ID
    var watermarkId:Int64


    public init(regionId: String,watermarkId:Int64){
        self.watermarkId = watermarkId
        super.init(regionId: regionId)
    }


    enum UpdateWatermarkRequestRequestCodingKeys: String, CodingKey {
        case name
        case imgUrl
        case width
        case height
        case sizeUnit
        case position
        case offsetX
        case offsetY
        case offsetUnit
        case watermarkId
    }

    public override func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: UpdateWatermarkRequestRequestCodingKeys.self)
        try encoderContainer.encode(name, forKey: .name)
        try encoderContainer.encode(imgUrl, forKey: .imgUrl)
        try encoderContainer.encode(width, forKey: .width)
        try encoderContainer.encode(height, forKey: .height)
        try encoderContainer.encode(sizeUnit, forKey: .sizeUnit)
        try encoderContainer.encode(position, forKey: .position)
        try encoderContainer.encode(offsetX, forKey: .offsetX)
        try encoderContainer.encode(offsetY, forKey: .offsetY)
        try encoderContainer.encode(offsetUnit, forKey: .offsetUnit)
        try encoderContainer.encode(watermarkId, forKey: .watermarkId)

    }
}

public class CreateWatermarkResponse:NSObject,Codable
{
    var requestId:String?;

    var error:ServiceError?;

    var result:CreateWatermarkResult?;

    enum CreateWatermarkResponseCodingKeys: String, CodingKey {
        case requestId
        case error
        case result
    }

    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: CreateWatermarkResponseCodingKeys.self)
        self.requestId = try decoderContainer.decodeIfPresent(String?.self, forKey: .requestId) ?? nil
        self.error = try decoderContainer.decodeIfPresent(ServiceError?.self, forKey: .error) ?? nil
        self.result = try decoderContainer.decodeIfPresent(CreateWatermarkResult?.self, forKey: .result) ?? nil
    }
}

public extension CreateWatermarkResponse{
        func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: CreateWatermarkResponseCodingKeys.self)
        try encoderContainer.encode(requestId, forKey: .requestId)
        try encoderContainer.encode(error, forKey: .error)
        try encoderContainer.encode(result, forKey: .result)
    }
}    

///  删除水印
public class DeleteWatermarkRequest:JdCloudRequest
{
    /// 水印ID
    var watermarkId:Int64


    public init(regionId: String,watermarkId:Int64){
        self.watermarkId = watermarkId
        super.init(regionId: regionId)
    }


    enum DeleteWatermarkRequestRequestCodingKeys: String, CodingKey {
        case watermarkId
    }

    public override func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: DeleteWatermarkRequestRequestCodingKeys.self)
        try encoderContainer.encode(watermarkId, forKey: .watermarkId)

    }
}

public class ListWatermarksResponse:NSObject,Codable
{
    var requestId:String?;

    var error:ServiceError?;

    var result:ListWatermarksResult?;

    enum ListWatermarksResponseCodingKeys: String, CodingKey {
        case requestId
        case error
        case result
    }

    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: ListWatermarksResponseCodingKeys.self)
        self.requestId = try decoderContainer.decodeIfPresent(String?.self, forKey: .requestId) ?? nil
        self.error = try decoderContainer.decodeIfPresent(ServiceError?.self, forKey: .error) ?? nil
        self.result = try decoderContainer.decodeIfPresent(ListWatermarksResult?.self, forKey: .result) ?? nil
    }
}

public extension ListWatermarksResponse{
        func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: ListWatermarksResponseCodingKeys.self)
        try encoderContainer.encode(requestId, forKey: .requestId)
        try encoderContainer.encode(error, forKey: .error)
        try encoderContainer.encode(result, forKey: .result)
    }
}    

///  添加水印
public class CreateWatermarkRequest:JdCloudRequest
{
    /// 水印名称。只支持中英文、数字。长度不超过128个字符。UTF-8编码。
      /// 
    var name:String

    /// 图片地址
    var imgUrl:String

    /// 水印宽度。
      /// 当 sizeUnit &#x3D; pixel 时，取值范围为 [8, 4096] 整数
      /// 当 sizeUnit &#x3D; percent 时，取值范围为 [0, 100] 小数
      /// 
    var width:String

    /// 水印高度。
      /// 当 sizeUnit &#x3D; pixel 时，取值范围为 [8, 4096] 整数
      /// 当 sizeUnit &#x3D; percent 时，取值范围为 [0, 100] 小数
      /// 
    var height:String

    /// 尺寸单位。取值范围：
      ///   pixel - 像素
      ///   percent - 百分比
      /// 默认值为 pixel
      /// 
    var sizeUnit:String?

    /// 水印位置。取值范围：
      ///   LT - 左上
      ///   RT - 右上
      ///   LB - 左下
      ///   RB - 右下
      /// 
    var position:String

    /// 水平偏移。
      /// 当 offsetUnit &#x3D; pixel 时，取值范围为 [8, 4088] 整数
      /// 当 offsetUnit &#x3D; percent 时，取值范围为 [0, 100] 小数
      /// 
    var offsetX:String

    /// 竖直偏移。
      /// 当 offsetUnit &#x3D; pixel 时，取值范围为 [8, 4088] 整数
      /// 当 offsetUnit &#x3D; percent 时，取值范围为 [0, 100] 小数
      /// 
    var offsetY:String

    /// 偏移单位。取值范围：
      ///   pixel - 像素
      ///   percent - 百分比
      /// 默认值为 pixel
      /// 
    var offsetUnit:String?


    public init(regionId: String,name:String,imgUrl:String,width:String,height:String,position:String,offsetX:String,offsetY:String){
        self.name = name
        self.imgUrl = imgUrl
        self.width = width
        self.height = height
        self.position = position
        self.offsetX = offsetX
        self.offsetY = offsetY
        super.init(regionId: regionId)
    }


    enum CreateWatermarkRequestRequestCodingKeys: String, CodingKey {
        case name
        case imgUrl
        case width
        case height
        case sizeUnit
        case position
        case offsetX
        case offsetY
        case offsetUnit
    }

    public override func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: CreateWatermarkRequestRequestCodingKeys.self)
        try encoderContainer.encode(name, forKey: .name)
        try encoderContainer.encode(imgUrl, forKey: .imgUrl)
        try encoderContainer.encode(width, forKey: .width)
        try encoderContainer.encode(height, forKey: .height)
        try encoderContainer.encode(sizeUnit, forKey: .sizeUnit)
        try encoderContainer.encode(position, forKey: .position)
        try encoderContainer.encode(offsetX, forKey: .offsetX)
        try encoderContainer.encode(offsetY, forKey: .offsetY)
        try encoderContainer.encode(offsetUnit, forKey: .offsetUnit)

    }
}

public class CreateImageUploadTaskResponse:NSObject,Codable
{
    var requestId:String?;

    var error:ServiceError?;

    var result:CreateImageUploadTaskResult?;

    enum CreateImageUploadTaskResponseCodingKeys: String, CodingKey {
        case requestId
        case error
        case result
    }

    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: CreateImageUploadTaskResponseCodingKeys.self)
        self.requestId = try decoderContainer.decodeIfPresent(String?.self, forKey: .requestId) ?? nil
        self.error = try decoderContainer.decodeIfPresent(ServiceError?.self, forKey: .error) ?? nil
        self.result = try decoderContainer.decodeIfPresent(CreateImageUploadTaskResult?.self, forKey: .result) ?? nil
    }
}

public extension CreateImageUploadTaskResponse{
        func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: CreateImageUploadTaskResponseCodingKeys.self)
        try encoderContainer.encode(requestId, forKey: .requestId)
        try encoderContainer.encode(error, forKey: .error)
        try encoderContainer.encode(result, forKey: .result)
    }
}    

///  获取图片上传地址和凭证
public class CreateImageUploadTaskRequest:JdCloudRequest
{
    /// HTTP 请求方法，取值范围：GET、POST、PUT、DELETE、HEAD、PATCH，默认值为 PUT
    var httpMethod:String?

    /// 文件名称
    var fileName:String?

    /// 文件大小
    var fileSize:Int64?




    enum CreateImageUploadTaskRequestRequestCodingKeys: String, CodingKey {
        case httpMethod
        case fileName
        case fileSize
    }

    public override func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: CreateImageUploadTaskRequestRequestCodingKeys.self)
        try encoderContainer.encode(httpMethod, forKey: .httpMethod)
        try encoderContainer.encode(fileName, forKey: .fileName)
        try encoderContainer.encode(fileSize, forKey: .fileSize)

    }
}

/// 刷新视频上传地址和凭证 
public class RefreshVideoUploadTaskResult:NSObject,JdCloudResult
{
    /// 视频ID
    var videoId:String?

    /// 视频上传地址
    var uploadUrl:String?



    public override init(){
        super.init()
    }

    enum RefreshVideoUploadTaskResultCodingKeys: String, CodingKey {
        case videoId
        case uploadUrl
    }

    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: RefreshVideoUploadTaskResultCodingKeys.self)
        if decoderContainer.contains(.videoId)
        {
            self.videoId = try decoderContainer.decode(String?.self, forKey: .videoId)
        }
        if decoderContainer.contains(.uploadUrl)
        {
            self.uploadUrl = try decoderContainer.decode(String?.self, forKey: .uploadUrl)
        }
    }
}
public extension RefreshVideoUploadTaskResult{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: RefreshVideoUploadTaskResultCodingKeys.self)
        try encoderContainer.encode(videoId, forKey: .videoId)
        try encoderContainer.encode(uploadUrl, forKey: .uploadUrl)
    }
}
public class RefreshVideoUploadTaskResponse:NSObject,Codable
{
    var requestId:String?;

    var error:ServiceError?;

    var result:RefreshVideoUploadTaskResult?;

    enum RefreshVideoUploadTaskResponseCodingKeys: String, CodingKey {
        case requestId
        case error
        case result
    }

    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: RefreshVideoUploadTaskResponseCodingKeys.self)
        self.requestId = try decoderContainer.decodeIfPresent(String?.self, forKey: .requestId) ?? nil
        self.error = try decoderContainer.decodeIfPresent(ServiceError?.self, forKey: .error) ?? nil
        self.result = try decoderContainer.decodeIfPresent(RefreshVideoUploadTaskResult?.self, forKey: .result) ?? nil
    }
}

public extension RefreshVideoUploadTaskResponse{
        func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: RefreshVideoUploadTaskResponseCodingKeys.self)
        try encoderContainer.encode(requestId, forKey: .requestId)
        try encoderContainer.encode(error, forKey: .error)
        try encoderContainer.encode(result, forKey: .result)
    }
}    
/// 获取图片上传地址和凭证 
public class CreateImageUploadTaskResult:NSObject,JdCloudResult
{
    /// 图片ID
    var imageId:String?

    /// 图片上传地址
    var uploadUrl:String?



    public override init(){
        super.init()
    }

    enum CreateImageUploadTaskResultCodingKeys: String, CodingKey {
        case imageId
        case uploadUrl
    }

    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: CreateImageUploadTaskResultCodingKeys.self)
        if decoderContainer.contains(.imageId)
        {
            self.imageId = try decoderContainer.decode(String?.self, forKey: .imageId)
        }
        if decoderContainer.contains(.uploadUrl)
        {
            self.uploadUrl = try decoderContainer.decode(String?.self, forKey: .uploadUrl)
        }
    }
}
public extension CreateImageUploadTaskResult{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: CreateImageUploadTaskResultCodingKeys.self)
        try encoderContainer.encode(imageId, forKey: .imageId)
        try encoderContainer.encode(uploadUrl, forKey: .uploadUrl)
    }
}

///  刷新视频上传地址和凭证
public class RefreshVideoUploadTaskRequest:JdCloudRequest
{
    /// 视频地址
    var videoId:String


    public init(regionId: String,videoId:String){
        self.videoId = videoId
        super.init(regionId: regionId)
    }


    enum RefreshVideoUploadTaskRequestRequestCodingKeys: String, CodingKey {
        case videoId
    }

    public override func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: RefreshVideoUploadTaskRequestRequestCodingKeys.self)
        try encoderContainer.encode(videoId, forKey: .videoId)

    }
}

/// 获取视频上传地址和凭证 
public class CreateVideoUploadTaskResult:NSObject,JdCloudResult
{
    /// 视频ID
    var videoId:String?

    /// 视频上传地址
    var uploadUrl:String?



    public override init(){
        super.init()
    }

    enum CreateVideoUploadTaskResultCodingKeys: String, CodingKey {
        case videoId
        case uploadUrl
    }

    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: CreateVideoUploadTaskResultCodingKeys.self)
        if decoderContainer.contains(.videoId)
        {
            self.videoId = try decoderContainer.decode(String?.self, forKey: .videoId)
        }
        if decoderContainer.contains(.uploadUrl)
        {
            self.uploadUrl = try decoderContainer.decode(String?.self, forKey: .uploadUrl)
        }
    }
}
public extension CreateVideoUploadTaskResult{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: CreateVideoUploadTaskResultCodingKeys.self)
        try encoderContainer.encode(videoId, forKey: .videoId)
        try encoderContainer.encode(uploadUrl, forKey: .uploadUrl)
    }
}

///  获取视频上传地址和凭证
public class CreateVideoUploadTaskRequest:JdCloudRequest
{
    /// HTTP 请求方法，取值范围：GET、POST、PUT、DELETE、HEAD、PATCH，默认值为 PUT
    var httpMethod:String?

    /// 视频标题
    var title:String?

    /// 文件名称
    var fileName:String?

    /// 文件大小
    var fileSize:Int64?

    /// 封面地址
    var coverUrl:String?

    /// 视频描述
    var descriptionValue:String?

    /// 分类ID
    var categoryId:Int64?

    /// 视频标签集合
    var tags:[String?]?

    /// 转码模板ID集合
    var transcodeTemplateIds:[Int64?]?

    /// 水印ID集合
    var watermarkIds:[Int64?]?




    enum CreateVideoUploadTaskRequestRequestCodingKeys: String, CodingKey {
        case httpMethod
        case title
        case fileName
        case fileSize
        case coverUrl
        case descriptionValue = "description"
        case categoryId
        case tags
        case transcodeTemplateIds
        case watermarkIds
    }

    public override func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: CreateVideoUploadTaskRequestRequestCodingKeys.self)
        try encoderContainer.encode(httpMethod, forKey: .httpMethod)
        try encoderContainer.encode(title, forKey: .title)
        try encoderContainer.encode(fileName, forKey: .fileName)
        try encoderContainer.encode(fileSize, forKey: .fileSize)
        try encoderContainer.encode(coverUrl, forKey: .coverUrl)
        try encoderContainer.encode(descriptionValue, forKey: .descriptionValue)
        try encoderContainer.encode(categoryId, forKey: .categoryId)
        try encoderContainer.encode(tags, forKey: .tags)
        try encoderContainer.encode(transcodeTemplateIds, forKey: .transcodeTemplateIds)
        try encoderContainer.encode(watermarkIds, forKey: .watermarkIds)

    }
}

public class CreateVideoUploadTaskResponse:NSObject,Codable
{
    var requestId:String?;

    var error:ServiceError?;

    var result:CreateVideoUploadTaskResult?;

    enum CreateVideoUploadTaskResponseCodingKeys: String, CodingKey {
        case requestId
        case error
        case result
    }

    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: CreateVideoUploadTaskResponseCodingKeys.self)
        self.requestId = try decoderContainer.decodeIfPresent(String?.self, forKey: .requestId) ?? nil
        self.error = try decoderContainer.decodeIfPresent(ServiceError?.self, forKey: .error) ?? nil
        self.result = try decoderContainer.decodeIfPresent(CreateVideoUploadTaskResult?.self, forKey: .result) ?? nil
    }
}

public extension CreateVideoUploadTaskResponse{
        func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: CreateVideoUploadTaskResponseCodingKeys.self)
        try encoderContainer.encode(requestId, forKey: .requestId)
        try encoderContainer.encode(error, forKey: .error)
        try encoderContainer.encode(result, forKey: .result)
    }
}    

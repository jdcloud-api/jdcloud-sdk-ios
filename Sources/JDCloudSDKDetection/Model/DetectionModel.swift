/* Copyright 2018 JDCLOUD.COM

   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at

     http:#www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.

   Availability-Monitoring-APIs
   可用性监控相关接口，提供创建、查询、修改、删除可用性监控任务等功能

   OpenAPI spec version: v2
   Contact: 

   NOTE: This class is auto generated by the jdcloud code generator program.
 */


import Foundation
///  location
public class Location:NSObject,Codable{
    /// Sloc
    var sloc:String?
    /// SlocName
    var slocName:String?
    /// IsIpv6
    var isIpv6:Bool?



    public override init(){
            super.init()
    }

    enum LocationCodingKeys: String, CodingKey {
        case sloc
        case slocName
        case isIpv6
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: LocationCodingKeys.self)
        if decoderContainer.contains(.sloc)
        {
            self.sloc = try decoderContainer.decode(String?.self, forKey: .sloc)
        }
        if decoderContainer.contains(.slocName)
        {
            self.slocName = try decoderContainer.decode(String?.self, forKey: .slocName)
        }
        if decoderContainer.contains(.isIpv6)
        {
            self.isIpv6 = try decoderContainer.decode(Bool?.self, forKey: .isIpv6)
        }
    }
}
public extension Location{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: LocationCodingKeys.self)
         try encoderContainer.encode(sloc, forKey: .sloc)
         try encoderContainer.encode(slocName, forKey: .slocName)
         try encoderContainer.encode(isIpv6, forKey: .isIpv6)
    }
}
///  enableSiteMonitorSpec
public class EnableSiteMonitorSpec:NSObject,Codable{
    /// List
    var list:[EnableSiteMonitorReqItem?]?



    public override init(){
            super.init()
    }

    enum EnableSiteMonitorSpecCodingKeys: String, CodingKey {
        case list
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: EnableSiteMonitorSpecCodingKeys.self)
        if decoderContainer.contains(.list)
        {
            self.list = try decoderContainer.decode([EnableSiteMonitorReqItem?]?.self, forKey: .list)
        }
    }
}
public extension EnableSiteMonitorSpec{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: EnableSiteMonitorSpecCodingKeys.self)
         try encoderContainer.encode(list, forKey: .list)
    }
}
///  filter
public class Filter:NSObject,Codable{
    /// Name
    var name:String?
    /// Values
    var values:[String?]?



    public override init(){
            super.init()
    }

    enum FilterCodingKeys: String, CodingKey {
        case name
        case values
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: FilterCodingKeys.self)
        if decoderContainer.contains(.name)
        {
            self.name = try decoderContainer.decode(String?.self, forKey: .name)
        }
        if decoderContainer.contains(.values)
        {
            self.values = try decoderContainer.decode([String?]?.self, forKey: .values)
        }
    }
}
public extension Filter{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: FilterCodingKeys.self)
         try encoderContainer.encode(name, forKey: .name)
         try encoderContainer.encode(values, forKey: .values)
    }
}
///  siteMonitorSmtpOption
public class SiteMonitorSmtpOption:NSObject,Codable{
    /// 用户密码
    /// Required:true
    var passwd:String
    /// 协议类型，可选值：smtp、smtps
    /// Required:true
    var protocolValue:String
    /// Timeout
    var timeout:Int64?
    /// 用户名
    /// Required:true
    var user:String



    public  init(passwd:String,protocolValue:String,user:String){
             self.passwd = passwd
             self.protocolValue = protocolValue
             self.user = user
    }

    enum SiteMonitorSmtpOptionCodingKeys: String, CodingKey {
        case passwd
        case protocolValue = "protocol"
        case timeout
        case user
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: SiteMonitorSmtpOptionCodingKeys.self)
        self.passwd = try decoderContainer.decode(String.self, forKey: .passwd)
        self.protocolValue = try decoderContainer.decode(String.self, forKey: .protocolValue)
        if decoderContainer.contains(.timeout)
        {
            self.timeout = try decoderContainer.decode(Int64?.self, forKey: .timeout)
        }
        self.user = try decoderContainer.decode(String.self, forKey: .user)
    }
}
public extension SiteMonitorSmtpOption{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: SiteMonitorSmtpOptionCodingKeys.self)
         try encoderContainer.encode(passwd, forKey: .passwd)
         try encoderContainer.encode(protocolValue, forKey: .protocolValue)
         try encoderContainer.encode(timeout, forKey: .timeout)
         try encoderContainer.encode(user, forKey: .user)
    }
}
///  statsItem
public class StatsItem:NSObject,Codable{
    /// AggregateFunc
    var aggregateFunc:String?
    /// AggregateIntervalMin
    var aggregateIntervalMin:Int?
    /// CalculateUnit
    var calculateUnit:String?
    /// Dps
    var dps:[DataPoint?]?
    /// Metric
    var metric:String?
    /// MetricName
    var metricName:String?
    /// Resource
    var resource:Resource?
    /// Tags
    var tags:[String:String?]?



    public override init(){
            super.init()
    }

    enum StatsItemCodingKeys: String, CodingKey {
        case aggregateFunc
        case aggregateIntervalMin
        case calculateUnit
        case dps
        case metric
        case metricName
        case resource
        case tags
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: StatsItemCodingKeys.self)
        if decoderContainer.contains(.aggregateFunc)
        {
            self.aggregateFunc = try decoderContainer.decode(String?.self, forKey: .aggregateFunc)
        }
        if decoderContainer.contains(.aggregateIntervalMin)
        {
            self.aggregateIntervalMin = try decoderContainer.decode(Int?.self, forKey: .aggregateIntervalMin)
        }
        if decoderContainer.contains(.calculateUnit)
        {
            self.calculateUnit = try decoderContainer.decode(String?.self, forKey: .calculateUnit)
        }
        if decoderContainer.contains(.dps)
        {
            self.dps = try decoderContainer.decode([DataPoint?]?.self, forKey: .dps)
        }
        if decoderContainer.contains(.metric)
        {
            self.metric = try decoderContainer.decode(String?.self, forKey: .metric)
        }
        if decoderContainer.contains(.metricName)
        {
            self.metricName = try decoderContainer.decode(String?.self, forKey: .metricName)
        }
        if decoderContainer.contains(.resource)
        {
            self.resource = try decoderContainer.decode(Resource?.self, forKey: .resource)
        }
        if decoderContainer.contains(.tags)
        {
            self.tags = try decoderContainer.decode([String:String?]?.self, forKey: .tags)
        }
    }
}
public extension StatsItem{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: StatsItemCodingKeys.self)
         try encoderContainer.encode(aggregateFunc, forKey: .aggregateFunc)
         try encoderContainer.encode(aggregateIntervalMin, forKey: .aggregateIntervalMin)
         try encoderContainer.encode(calculateUnit, forKey: .calculateUnit)
         try encoderContainer.encode(dps, forKey: .dps)
         try encoderContainer.encode(metric, forKey: .metric)
         try encoderContainer.encode(metricName, forKey: .metricName)
         try encoderContainer.encode(resource, forKey: .resource)
         try encoderContainer.encode(tags, forKey: .tags)
    }
}
///  resource
public class Resource:NSObject,Codable{
    /// Name
    var name:String?
    /// RegionId
    var regionId:String?
    /// ResourceId
    var resourceId:String?



    public override init(){
            super.init()
    }

    enum ResourceCodingKeys: String, CodingKey {
        case name
        case regionId
        case resourceId
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: ResourceCodingKeys.self)
        if decoderContainer.contains(.name)
        {
            self.name = try decoderContainer.decode(String?.self, forKey: .name)
        }
        if decoderContainer.contains(.regionId)
        {
            self.regionId = try decoderContainer.decode(String?.self, forKey: .regionId)
        }
        if decoderContainer.contains(.resourceId)
        {
            self.resourceId = try decoderContainer.decode(String?.self, forKey: .resourceId)
        }
    }
}
public extension Resource{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: ResourceCodingKeys.self)
         try encoderContainer.encode(name, forKey: .name)
         try encoderContainer.encode(regionId, forKey: .regionId)
         try encoderContainer.encode(resourceId, forKey: .resourceId)
    }
}
///  siteMonitor
public class SiteMonitor:NSObject,Codable{
    /// Address
    var address:String?
    /// AdvanceChecked
    var advanceChecked:String?
    /// CreatedTime
    var createdTime:Int64?
    /// Cycle
    var cycle:Int64?
    /// DefaultSource
    var defaultSource:String?
    /// DnsOption
    var dnsOption:SiteMonitorDnsOption?
    /// Enabled
    var enabled:String?
    /// FtpOption
    var ftpOption:SiteMonitorFtpOption?
    /// HawkeyeId
    var hawkeyeId:Int64?
    /// HttpOption
    var httpOption:SiteMonitorHttpOption?
    /// Id
    var id:String?
    /// IsDeleted
    var isDeleted:String?
    /// Name
    var name:String?
    /// Pin
    var pin:String?
    /// PingOption
    var pingOption:SiteMonitorPingOption?
    /// Pop3Option
    var pop3Option:SiteMonitorPop3Option?
    /// Port
    var port:String?
    /// SmtpOption
    var smtpOption:SiteMonitorSmtpOption?
    /// Source
    var source:[SiteMonitorSource?]?
    /// Stats
    var stats:[String:AnyObject?]?
    /// 可选值：HTTP、PING 、TCP 、UDP、DNS、SMTP、POP3和FTP
    var taskType:String?
    /// TcpOption
    var tcpOption:SiteMonitorTcpOption?
    /// UdpOption
    var udpOption:SiteMonitorUdpOption?
    /// UpdatedTime
    var updatedTime:Int64?



    public override init(){
            super.init()
    }

    enum SiteMonitorCodingKeys: String, CodingKey {
        case address
        case advanceChecked
        case createdTime
        case cycle
        case defaultSource
        case dnsOption
        case enabled
        case ftpOption
        case hawkeyeId
        case httpOption
        case id
        case isDeleted
        case name
        case pin
        case pingOption
        case pop3Option
        case port
        case smtpOption
        case source
        case stats
        case taskType
        case tcpOption
        case udpOption
        case updatedTime
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: SiteMonitorCodingKeys.self)
        if decoderContainer.contains(.address)
        {
            self.address = try decoderContainer.decode(String?.self, forKey: .address)
        }
        if decoderContainer.contains(.advanceChecked)
        {
            self.advanceChecked = try decoderContainer.decode(String?.self, forKey: .advanceChecked)
        }
        if decoderContainer.contains(.createdTime)
        {
            self.createdTime = try decoderContainer.decode(Int64?.self, forKey: .createdTime)
        }
        if decoderContainer.contains(.cycle)
        {
            self.cycle = try decoderContainer.decode(Int64?.self, forKey: .cycle)
        }
        if decoderContainer.contains(.defaultSource)
        {
            self.defaultSource = try decoderContainer.decode(String?.self, forKey: .defaultSource)
        }
        if decoderContainer.contains(.dnsOption)
        {
            self.dnsOption = try decoderContainer.decode(SiteMonitorDnsOption?.self, forKey: .dnsOption)
        }
        if decoderContainer.contains(.enabled)
        {
            self.enabled = try decoderContainer.decode(String?.self, forKey: .enabled)
        }
        if decoderContainer.contains(.ftpOption)
        {
            self.ftpOption = try decoderContainer.decode(SiteMonitorFtpOption?.self, forKey: .ftpOption)
        }
        if decoderContainer.contains(.hawkeyeId)
        {
            self.hawkeyeId = try decoderContainer.decode(Int64?.self, forKey: .hawkeyeId)
        }
        if decoderContainer.contains(.httpOption)
        {
            self.httpOption = try decoderContainer.decode(SiteMonitorHttpOption?.self, forKey: .httpOption)
        }
        if decoderContainer.contains(.id)
        {
            self.id = try decoderContainer.decode(String?.self, forKey: .id)
        }
        if decoderContainer.contains(.isDeleted)
        {
            self.isDeleted = try decoderContainer.decode(String?.self, forKey: .isDeleted)
        }
        if decoderContainer.contains(.name)
        {
            self.name = try decoderContainer.decode(String?.self, forKey: .name)
        }
        if decoderContainer.contains(.pin)
        {
            self.pin = try decoderContainer.decode(String?.self, forKey: .pin)
        }
        if decoderContainer.contains(.pingOption)
        {
            self.pingOption = try decoderContainer.decode(SiteMonitorPingOption?.self, forKey: .pingOption)
        }
        if decoderContainer.contains(.pop3Option)
        {
            self.pop3Option = try decoderContainer.decode(SiteMonitorPop3Option?.self, forKey: .pop3Option)
        }
        if decoderContainer.contains(.port)
        {
            self.port = try decoderContainer.decode(String?.self, forKey: .port)
        }
        if decoderContainer.contains(.smtpOption)
        {
            self.smtpOption = try decoderContainer.decode(SiteMonitorSmtpOption?.self, forKey: .smtpOption)
        }
        if decoderContainer.contains(.source)
        {
            self.source = try decoderContainer.decode([SiteMonitorSource?]?.self, forKey: .source)
        }
        if decoderContainer.contains(.taskType)
        {
            self.taskType = try decoderContainer.decode(String?.self, forKey: .taskType)
        }
        if decoderContainer.contains(.tcpOption)
        {
            self.tcpOption = try decoderContainer.decode(SiteMonitorTcpOption?.self, forKey: .tcpOption)
        }
        if decoderContainer.contains(.udpOption)
        {
            self.udpOption = try decoderContainer.decode(SiteMonitorUdpOption?.self, forKey: .udpOption)
        }
        if decoderContainer.contains(.updatedTime)
        {
            self.updatedTime = try decoderContainer.decode(Int64?.self, forKey: .updatedTime)
        }
    }
}
public extension SiteMonitor{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: SiteMonitorCodingKeys.self)
         try encoderContainer.encode(address, forKey: .address)
         try encoderContainer.encode(advanceChecked, forKey: .advanceChecked)
         try encoderContainer.encode(createdTime, forKey: .createdTime)
         try encoderContainer.encode(cycle, forKey: .cycle)
         try encoderContainer.encode(defaultSource, forKey: .defaultSource)
         try encoderContainer.encode(dnsOption, forKey: .dnsOption)
         try encoderContainer.encode(enabled, forKey: .enabled)
         try encoderContainer.encode(ftpOption, forKey: .ftpOption)
         try encoderContainer.encode(hawkeyeId, forKey: .hawkeyeId)
         try encoderContainer.encode(httpOption, forKey: .httpOption)
         try encoderContainer.encode(id, forKey: .id)
         try encoderContainer.encode(isDeleted, forKey: .isDeleted)
         try encoderContainer.encode(name, forKey: .name)
         try encoderContainer.encode(pin, forKey: .pin)
         try encoderContainer.encode(pingOption, forKey: .pingOption)
         try encoderContainer.encode(pop3Option, forKey: .pop3Option)
         try encoderContainer.encode(port, forKey: .port)
         try encoderContainer.encode(smtpOption, forKey: .smtpOption)
         try encoderContainer.encode(source, forKey: .source)
         try encoderContainer.encode(taskType, forKey: .taskType)
         try encoderContainer.encode(tcpOption, forKey: .tcpOption)
         try encoderContainer.encode(udpOption, forKey: .udpOption)
         try encoderContainer.encode(updatedTime, forKey: .updatedTime)
    }
}
///  siteMonitorHttpOption
public class SiteMonitorHttpOption:NSObject,Codable{
    /// Cookie
    var cookie:[String:String?]?
    /// Header
    var header:[String:String?]?
    /// 请求方法，可选值：GET、POST、HEAD
    /// Required:true
    var method:String
    /// 请求内容
    var reqContent:String?
    /// 返回校验内容
    var resCheck:String?
    /// 返回校验方式，可选值：match、notmatch
    var resCheckType:String?



    public  init(method:String){
             self.method = method
    }

    enum SiteMonitorHttpOptionCodingKeys: String, CodingKey {
        case cookie
        case header
        case method
        case reqContent
        case resCheck
        case resCheckType
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: SiteMonitorHttpOptionCodingKeys.self)
        if decoderContainer.contains(.cookie)
        {
            self.cookie = try decoderContainer.decode([String:String?]?.self, forKey: .cookie)
        }
        if decoderContainer.contains(.header)
        {
            self.header = try decoderContainer.decode([String:String?]?.self, forKey: .header)
        }
        self.method = try decoderContainer.decode(String.self, forKey: .method)
        if decoderContainer.contains(.reqContent)
        {
            self.reqContent = try decoderContainer.decode(String?.self, forKey: .reqContent)
        }
        if decoderContainer.contains(.resCheck)
        {
            self.resCheck = try decoderContainer.decode(String?.self, forKey: .resCheck)
        }
        if decoderContainer.contains(.resCheckType)
        {
            self.resCheckType = try decoderContainer.decode(String?.self, forKey: .resCheckType)
        }
    }
}
public extension SiteMonitorHttpOption{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: SiteMonitorHttpOptionCodingKeys.self)
         try encoderContainer.encode(cookie, forKey: .cookie)
         try encoderContainer.encode(header, forKey: .header)
         try encoderContainer.encode(method, forKey: .method)
         try encoderContainer.encode(reqContent, forKey: .reqContent)
         try encoderContainer.encode(resCheck, forKey: .resCheck)
         try encoderContainer.encode(resCheckType, forKey: .resCheckType)
    }
}
///  createSiteMonitorSpec
public class CreateSiteMonitorSpec:NSObject,Codable{
    /// 地址
    /// Required:true
    var address:String
    /// AdvanceChecked
    var advanceChecked:String?
    /// CreatedTime
    var createdTime:Int64?
    /// 探测频率
    /// Required:true
    var cycle:Int64
    /// DefaultSource
    var defaultSource:String?
    /// DnsOption
    var dnsOption:SiteMonitorDnsOption?
    /// Enabled
    var enabled:String?
    /// FtpOption
    var ftpOption:SiteMonitorFtpOption?
    /// HawkeyeId
    var hawkeyeId:Int64?
    /// HttpOption
    var httpOption:SiteMonitorHttpOption?
    /// Id
    var id:String?
    /// IsDeleted
    var isDeleted:String?
    /// 任务名称
    /// Required:true
    var name:String
    /// Pin
    var pin:String?
    /// PingOption
    var pingOption:SiteMonitorPingOption?
    /// Pop3Option
    var pop3Option:SiteMonitorPop3Option?
    /// 端口
    var port:String?
    /// SmtpOption
    var smtpOption:SiteMonitorSmtpOption?
    /// 探测源
    /// Required:true
    var source:[SiteMonitorSource?]?
    /// Stats
    var stats:[String:AnyObject?]?
    /// 任务类型，可选值：HTTP、PING 、TCP 、UDP、DNS、SMTP、POP3和FTP
    /// Required:true
    var taskType:String
    /// TcpOption
    var tcpOption:SiteMonitorTcpOption?
    /// UdpOption
    var udpOption:SiteMonitorUdpOption?
    /// UpdatedTime
    var updatedTime:Int64?



    public  init(address:String,cycle:Int64,name:String,source:[SiteMonitorSource?]?,taskType:String){
             self.address = address
             self.cycle = cycle
             self.name = name
             self.source = source
             self.taskType = taskType
    }

    enum CreateSiteMonitorSpecCodingKeys: String, CodingKey {
        case address
        case advanceChecked
        case createdTime
        case cycle
        case defaultSource
        case dnsOption
        case enabled
        case ftpOption
        case hawkeyeId
        case httpOption
        case id
        case isDeleted
        case name
        case pin
        case pingOption
        case pop3Option
        case port
        case smtpOption
        case source
        case stats
        case taskType
        case tcpOption
        case udpOption
        case updatedTime
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: CreateSiteMonitorSpecCodingKeys.self)
        self.address = try decoderContainer.decode(String.self, forKey: .address)
        if decoderContainer.contains(.advanceChecked)
        {
            self.advanceChecked = try decoderContainer.decode(String?.self, forKey: .advanceChecked)
        }
        if decoderContainer.contains(.createdTime)
        {
            self.createdTime = try decoderContainer.decode(Int64?.self, forKey: .createdTime)
        }
        self.cycle = try decoderContainer.decode(Int64.self, forKey: .cycle)
        if decoderContainer.contains(.defaultSource)
        {
            self.defaultSource = try decoderContainer.decode(String?.self, forKey: .defaultSource)
        }
        if decoderContainer.contains(.dnsOption)
        {
            self.dnsOption = try decoderContainer.decode(SiteMonitorDnsOption?.self, forKey: .dnsOption)
        }
        if decoderContainer.contains(.enabled)
        {
            self.enabled = try decoderContainer.decode(String?.self, forKey: .enabled)
        }
        if decoderContainer.contains(.ftpOption)
        {
            self.ftpOption = try decoderContainer.decode(SiteMonitorFtpOption?.self, forKey: .ftpOption)
        }
        if decoderContainer.contains(.hawkeyeId)
        {
            self.hawkeyeId = try decoderContainer.decode(Int64?.self, forKey: .hawkeyeId)
        }
        if decoderContainer.contains(.httpOption)
        {
            self.httpOption = try decoderContainer.decode(SiteMonitorHttpOption?.self, forKey: .httpOption)
        }
        if decoderContainer.contains(.id)
        {
            self.id = try decoderContainer.decode(String?.self, forKey: .id)
        }
        if decoderContainer.contains(.isDeleted)
        {
            self.isDeleted = try decoderContainer.decode(String?.self, forKey: .isDeleted)
        }
        self.name = try decoderContainer.decode(String.self, forKey: .name)
        if decoderContainer.contains(.pin)
        {
            self.pin = try decoderContainer.decode(String?.self, forKey: .pin)
        }
        if decoderContainer.contains(.pingOption)
        {
            self.pingOption = try decoderContainer.decode(SiteMonitorPingOption?.self, forKey: .pingOption)
        }
        if decoderContainer.contains(.pop3Option)
        {
            self.pop3Option = try decoderContainer.decode(SiteMonitorPop3Option?.self, forKey: .pop3Option)
        }
        if decoderContainer.contains(.port)
        {
            self.port = try decoderContainer.decode(String?.self, forKey: .port)
        }
        if decoderContainer.contains(.smtpOption)
        {
            self.smtpOption = try decoderContainer.decode(SiteMonitorSmtpOption?.self, forKey: .smtpOption)
        }
        self.source = try decoderContainer.decode([SiteMonitorSource?]?.self, forKey: .source)
        self.taskType = try decoderContainer.decode(String.self, forKey: .taskType)
        if decoderContainer.contains(.tcpOption)
        {
            self.tcpOption = try decoderContainer.decode(SiteMonitorTcpOption?.self, forKey: .tcpOption)
        }
        if decoderContainer.contains(.udpOption)
        {
            self.udpOption = try decoderContainer.decode(SiteMonitorUdpOption?.self, forKey: .udpOption)
        }
        if decoderContainer.contains(.updatedTime)
        {
            self.updatedTime = try decoderContainer.decode(Int64?.self, forKey: .updatedTime)
        }
    }
}
public extension CreateSiteMonitorSpec{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: CreateSiteMonitorSpecCodingKeys.self)
         try encoderContainer.encode(address, forKey: .address)
         try encoderContainer.encode(advanceChecked, forKey: .advanceChecked)
         try encoderContainer.encode(createdTime, forKey: .createdTime)
         try encoderContainer.encode(cycle, forKey: .cycle)
         try encoderContainer.encode(defaultSource, forKey: .defaultSource)
         try encoderContainer.encode(dnsOption, forKey: .dnsOption)
         try encoderContainer.encode(enabled, forKey: .enabled)
         try encoderContainer.encode(ftpOption, forKey: .ftpOption)
         try encoderContainer.encode(hawkeyeId, forKey: .hawkeyeId)
         try encoderContainer.encode(httpOption, forKey: .httpOption)
         try encoderContainer.encode(id, forKey: .id)
         try encoderContainer.encode(isDeleted, forKey: .isDeleted)
         try encoderContainer.encode(name, forKey: .name)
         try encoderContainer.encode(pin, forKey: .pin)
         try encoderContainer.encode(pingOption, forKey: .pingOption)
         try encoderContainer.encode(pop3Option, forKey: .pop3Option)
         try encoderContainer.encode(port, forKey: .port)
         try encoderContainer.encode(smtpOption, forKey: .smtpOption)
         try encoderContainer.encode(source, forKey: .source)
         try encoderContainer.encode(taskType, forKey: .taskType)
         try encoderContainer.encode(tcpOption, forKey: .tcpOption)
         try encoderContainer.encode(udpOption, forKey: .udpOption)
         try encoderContainer.encode(updatedTime, forKey: .updatedTime)
    }
}
///  siteMonitorFtpOption
public class SiteMonitorFtpOption:NSObject,Codable{
    /// 登陆类型，可选值anonymous（匿名登陆）、login（身份校验）
    /// Required:true
    var loginType:String
    /// Passwd
    var passwd:String?
    /// Timeout
    var timeout:Int64?
    /// User
    var user:String?



    public  init(loginType:String){
             self.loginType = loginType
    }

    enum SiteMonitorFtpOptionCodingKeys: String, CodingKey {
        case loginType
        case passwd
        case timeout
        case user
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: SiteMonitorFtpOptionCodingKeys.self)
        self.loginType = try decoderContainer.decode(String.self, forKey: .loginType)
        if decoderContainer.contains(.passwd)
        {
            self.passwd = try decoderContainer.decode(String?.self, forKey: .passwd)
        }
        if decoderContainer.contains(.timeout)
        {
            self.timeout = try decoderContainer.decode(Int64?.self, forKey: .timeout)
        }
        if decoderContainer.contains(.user)
        {
            self.user = try decoderContainer.decode(String?.self, forKey: .user)
        }
    }
}
public extension SiteMonitorFtpOption{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: SiteMonitorFtpOptionCodingKeys.self)
         try encoderContainer.encode(loginType, forKey: .loginType)
         try encoderContainer.encode(passwd, forKey: .passwd)
         try encoderContainer.encode(timeout, forKey: .timeout)
         try encoderContainer.encode(user, forKey: .user)
    }
}
///  ispLocation
public class IspLocation:NSObject,Codable{
    /// Sisp
    var sisp:String?
    /// SispName
    var sispName:String?
    /// Slocs
    var slocs:[Location?]?



    public override init(){
            super.init()
    }

    enum IspLocationCodingKeys: String, CodingKey {
        case sisp
        case sispName
        case slocs
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: IspLocationCodingKeys.self)
        if decoderContainer.contains(.sisp)
        {
            self.sisp = try decoderContainer.decode(String?.self, forKey: .sisp)
        }
        if decoderContainer.contains(.sispName)
        {
            self.sispName = try decoderContainer.decode(String?.self, forKey: .sispName)
        }
        if decoderContainer.contains(.slocs)
        {
            self.slocs = try decoderContainer.decode([Location?]?.self, forKey: .slocs)
        }
    }
}
public extension IspLocation{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: IspLocationCodingKeys.self)
         try encoderContainer.encode(sisp, forKey: .sisp)
         try encoderContainer.encode(sispName, forKey: .sispName)
         try encoderContainer.encode(slocs, forKey: .slocs)
    }
}
///  siteMonitorPop3Option
public class SiteMonitorPop3Option:NSObject,Codable{
    /// Passwd
    /// Required:true
    var passwd:String
    /// 协议类型，可选值：pop3、pop3s
    /// Required:true
    var protocolValue:String
    /// Timeout
    var timeout:Int64?
    /// User
    /// Required:true
    var user:String



    public  init(passwd:String,protocolValue:String,user:String){
             self.passwd = passwd
             self.protocolValue = protocolValue
             self.user = user
    }

    enum SiteMonitorPop3OptionCodingKeys: String, CodingKey {
        case passwd
        case protocolValue = "protocol"
        case timeout
        case user
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: SiteMonitorPop3OptionCodingKeys.self)
        self.passwd = try decoderContainer.decode(String.self, forKey: .passwd)
        self.protocolValue = try decoderContainer.decode(String.self, forKey: .protocolValue)
        if decoderContainer.contains(.timeout)
        {
            self.timeout = try decoderContainer.decode(Int64?.self, forKey: .timeout)
        }
        self.user = try decoderContainer.decode(String.self, forKey: .user)
    }
}
public extension SiteMonitorPop3Option{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: SiteMonitorPop3OptionCodingKeys.self)
         try encoderContainer.encode(passwd, forKey: .passwd)
         try encoderContainer.encode(protocolValue, forKey: .protocolValue)
         try encoderContainer.encode(timeout, forKey: .timeout)
         try encoderContainer.encode(user, forKey: .user)
    }
}
///  dataPoint
public class DataPoint:NSObject,Codable{
    /// Timestamp
    var timestamp:Int64?
    /// Value
    var value:AnyObject?



    public override init(){
            super.init()
    }

    enum DataPointCodingKeys: String, CodingKey {
        case timestamp
        case value
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: DataPointCodingKeys.self)
        if decoderContainer.contains(.timestamp)
        {
            self.timestamp = try decoderContainer.decode(Int64?.self, forKey: .timestamp)
        }
    }
}
public extension DataPoint{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: DataPointCodingKeys.self)
         try encoderContainer.encode(timestamp, forKey: .timestamp)
    }
}
///  testSiteMonitorSpec
public class TestSiteMonitorSpec:NSObject,Codable{
    /// 地址
    /// Required:true
    var address:String
    /// AdvanceChecked
    var advanceChecked:String?
    /// CreatedTime
    var createdTime:Int64?
    /// 探测频率
    /// Required:true
    var cycle:Int64
    /// DefaultSource
    var defaultSource:String?
    /// DnsOption
    var dnsOption:SiteMonitorDnsOption?
    /// Enabled
    var enabled:String?
    /// FtpOption
    var ftpOption:SiteMonitorFtpOption?
    /// HawkeyeId
    var hawkeyeId:Int64?
    /// HttpOption
    var httpOption:SiteMonitorHttpOption?
    /// Id
    var id:String?
    /// IsDeleted
    var isDeleted:String?
    /// 任务名称
    /// Required:true
    var name:String
    /// Pin
    var pin:String?
    /// PingOption
    var pingOption:SiteMonitorPingOption?
    /// Pop3Option
    var pop3Option:SiteMonitorPop3Option?
    /// 端口
    var port:String?
    /// SmtpOption
    var smtpOption:SiteMonitorSmtpOption?
    /// 探测源
    /// Required:true
    var source:[SiteMonitorSource?]?
    /// Stats
    var stats:[String:AnyObject?]?
    /// 任务类型，可选值：HTTP、PING 、TCP 、UDP、DNS、SMTP、POP3和FTP
    /// Required:true
    var taskType:String
    /// TcpOption
    var tcpOption:SiteMonitorTcpOption?
    /// UdpOption
    var udpOption:SiteMonitorUdpOption?
    /// UpdatedTime
    var updatedTime:Int64?



    public  init(address:String,cycle:Int64,name:String,source:[SiteMonitorSource?]?,taskType:String){
             self.address = address
             self.cycle = cycle
             self.name = name
             self.source = source
             self.taskType = taskType
    }

    enum TestSiteMonitorSpecCodingKeys: String, CodingKey {
        case address
        case advanceChecked
        case createdTime
        case cycle
        case defaultSource
        case dnsOption
        case enabled
        case ftpOption
        case hawkeyeId
        case httpOption
        case id
        case isDeleted
        case name
        case pin
        case pingOption
        case pop3Option
        case port
        case smtpOption
        case source
        case stats
        case taskType
        case tcpOption
        case udpOption
        case updatedTime
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: TestSiteMonitorSpecCodingKeys.self)
        self.address = try decoderContainer.decode(String.self, forKey: .address)
        if decoderContainer.contains(.advanceChecked)
        {
            self.advanceChecked = try decoderContainer.decode(String?.self, forKey: .advanceChecked)
        }
        if decoderContainer.contains(.createdTime)
        {
            self.createdTime = try decoderContainer.decode(Int64?.self, forKey: .createdTime)
        }
        self.cycle = try decoderContainer.decode(Int64.self, forKey: .cycle)
        if decoderContainer.contains(.defaultSource)
        {
            self.defaultSource = try decoderContainer.decode(String?.self, forKey: .defaultSource)
        }
        if decoderContainer.contains(.dnsOption)
        {
            self.dnsOption = try decoderContainer.decode(SiteMonitorDnsOption?.self, forKey: .dnsOption)
        }
        if decoderContainer.contains(.enabled)
        {
            self.enabled = try decoderContainer.decode(String?.self, forKey: .enabled)
        }
        if decoderContainer.contains(.ftpOption)
        {
            self.ftpOption = try decoderContainer.decode(SiteMonitorFtpOption?.self, forKey: .ftpOption)
        }
        if decoderContainer.contains(.hawkeyeId)
        {
            self.hawkeyeId = try decoderContainer.decode(Int64?.self, forKey: .hawkeyeId)
        }
        if decoderContainer.contains(.httpOption)
        {
            self.httpOption = try decoderContainer.decode(SiteMonitorHttpOption?.self, forKey: .httpOption)
        }
        if decoderContainer.contains(.id)
        {
            self.id = try decoderContainer.decode(String?.self, forKey: .id)
        }
        if decoderContainer.contains(.isDeleted)
        {
            self.isDeleted = try decoderContainer.decode(String?.self, forKey: .isDeleted)
        }
        self.name = try decoderContainer.decode(String.self, forKey: .name)
        if decoderContainer.contains(.pin)
        {
            self.pin = try decoderContainer.decode(String?.self, forKey: .pin)
        }
        if decoderContainer.contains(.pingOption)
        {
            self.pingOption = try decoderContainer.decode(SiteMonitorPingOption?.self, forKey: .pingOption)
        }
        if decoderContainer.contains(.pop3Option)
        {
            self.pop3Option = try decoderContainer.decode(SiteMonitorPop3Option?.self, forKey: .pop3Option)
        }
        if decoderContainer.contains(.port)
        {
            self.port = try decoderContainer.decode(String?.self, forKey: .port)
        }
        if decoderContainer.contains(.smtpOption)
        {
            self.smtpOption = try decoderContainer.decode(SiteMonitorSmtpOption?.self, forKey: .smtpOption)
        }
        self.source = try decoderContainer.decode([SiteMonitorSource?]?.self, forKey: .source)
        self.taskType = try decoderContainer.decode(String.self, forKey: .taskType)
        if decoderContainer.contains(.tcpOption)
        {
            self.tcpOption = try decoderContainer.decode(SiteMonitorTcpOption?.self, forKey: .tcpOption)
        }
        if decoderContainer.contains(.udpOption)
        {
            self.udpOption = try decoderContainer.decode(SiteMonitorUdpOption?.self, forKey: .udpOption)
        }
        if decoderContainer.contains(.updatedTime)
        {
            self.updatedTime = try decoderContainer.decode(Int64?.self, forKey: .updatedTime)
        }
    }
}
public extension TestSiteMonitorSpec{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: TestSiteMonitorSpecCodingKeys.self)
         try encoderContainer.encode(address, forKey: .address)
         try encoderContainer.encode(advanceChecked, forKey: .advanceChecked)
         try encoderContainer.encode(createdTime, forKey: .createdTime)
         try encoderContainer.encode(cycle, forKey: .cycle)
         try encoderContainer.encode(defaultSource, forKey: .defaultSource)
         try encoderContainer.encode(dnsOption, forKey: .dnsOption)
         try encoderContainer.encode(enabled, forKey: .enabled)
         try encoderContainer.encode(ftpOption, forKey: .ftpOption)
         try encoderContainer.encode(hawkeyeId, forKey: .hawkeyeId)
         try encoderContainer.encode(httpOption, forKey: .httpOption)
         try encoderContainer.encode(id, forKey: .id)
         try encoderContainer.encode(isDeleted, forKey: .isDeleted)
         try encoderContainer.encode(name, forKey: .name)
         try encoderContainer.encode(pin, forKey: .pin)
         try encoderContainer.encode(pingOption, forKey: .pingOption)
         try encoderContainer.encode(pop3Option, forKey: .pop3Option)
         try encoderContainer.encode(port, forKey: .port)
         try encoderContainer.encode(smtpOption, forKey: .smtpOption)
         try encoderContainer.encode(source, forKey: .source)
         try encoderContainer.encode(taskType, forKey: .taskType)
         try encoderContainer.encode(tcpOption, forKey: .tcpOption)
         try encoderContainer.encode(udpOption, forKey: .udpOption)
         try encoderContainer.encode(updatedTime, forKey: .updatedTime)
    }
}
///  enableSiteMonitorReqItem
public class EnableSiteMonitorReqItem:NSObject,Codable{
    /// Enabled
    var enabled:String?
    /// Id
    var id:String?



    public override init(){
            super.init()
    }

    enum EnableSiteMonitorReqItemCodingKeys: String, CodingKey {
        case enabled
        case id
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: EnableSiteMonitorReqItemCodingKeys.self)
        if decoderContainer.contains(.enabled)
        {
            self.enabled = try decoderContainer.decode(String?.self, forKey: .enabled)
        }
        if decoderContainer.contains(.id)
        {
            self.id = try decoderContainer.decode(String?.self, forKey: .id)
        }
    }
}
public extension EnableSiteMonitorReqItem{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: EnableSiteMonitorReqItemCodingKeys.self)
         try encoderContainer.encode(enabled, forKey: .enabled)
         try encoderContainer.encode(id, forKey: .id)
    }
}
///  siteMonitorUdpOption
public class SiteMonitorUdpOption:NSObject,Codable{
    /// ReqContent
    var reqContent:String?
    /// ReqContentType
    var reqContentType:String?
    /// ResCheck
    var resCheck:String?
    /// ResCheckType
    var resCheckType:String?
    /// Timeout
    var timeout:Int64?



    public override init(){
            super.init()
    }

    enum SiteMonitorUdpOptionCodingKeys: String, CodingKey {
        case reqContent
        case reqContentType
        case resCheck
        case resCheckType
        case timeout
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: SiteMonitorUdpOptionCodingKeys.self)
        if decoderContainer.contains(.reqContent)
        {
            self.reqContent = try decoderContainer.decode(String?.self, forKey: .reqContent)
        }
        if decoderContainer.contains(.reqContentType)
        {
            self.reqContentType = try decoderContainer.decode(String?.self, forKey: .reqContentType)
        }
        if decoderContainer.contains(.resCheck)
        {
            self.resCheck = try decoderContainer.decode(String?.self, forKey: .resCheck)
        }
        if decoderContainer.contains(.resCheckType)
        {
            self.resCheckType = try decoderContainer.decode(String?.self, forKey: .resCheckType)
        }
        if decoderContainer.contains(.timeout)
        {
            self.timeout = try decoderContainer.decode(Int64?.self, forKey: .timeout)
        }
    }
}
public extension SiteMonitorUdpOption{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: SiteMonitorUdpOptionCodingKeys.self)
         try encoderContainer.encode(reqContent, forKey: .reqContent)
         try encoderContainer.encode(reqContentType, forKey: .reqContentType)
         try encoderContainer.encode(resCheck, forKey: .resCheck)
         try encoderContainer.encode(resCheckType, forKey: .resCheckType)
         try encoderContainer.encode(timeout, forKey: .timeout)
    }
}
///  updateSiteMonitorSpec
public class UpdateSiteMonitorSpec:NSObject,Codable{
    /// 地址
    /// Required:true
    var address:String
    /// AdvanceChecked
    var advanceChecked:String?
    /// CreatedTime
    var createdTime:Int64?
    /// 探测频率
    /// Required:true
    var cycle:Int64
    /// DefaultSource
    var defaultSource:String?
    /// DnsOption
    var dnsOption:SiteMonitorDnsOption?
    /// Enabled
    var enabled:String?
    /// FtpOption
    var ftpOption:SiteMonitorFtpOption?
    /// HawkeyeId
    var hawkeyeId:Int64?
    /// HttpOption
    var httpOption:SiteMonitorHttpOption?
    /// Id
    var id:String?
    /// IsDeleted
    var isDeleted:String?
    /// 任务名称
    /// Required:true
    var name:String
    /// Pin
    var pin:String?
    /// PingOption
    var pingOption:SiteMonitorPingOption?
    /// Pop3Option
    var pop3Option:SiteMonitorPop3Option?
    /// 端口
    var port:String?
    /// SmtpOption
    var smtpOption:SiteMonitorSmtpOption?
    /// 探测源
    /// Required:true
    var source:[SiteMonitorSource?]?
    /// Stats
    var stats:[String:AnyObject?]?
    /// 任务类型，可选值：HTTP、PING 、TCP 、UDP、DNS、SMTP、POP3和FTP
    /// Required:true
    var taskType:String
    /// TcpOption
    var tcpOption:SiteMonitorTcpOption?
    /// UdpOption
    var udpOption:SiteMonitorUdpOption?
    /// UpdatedTime
    var updatedTime:Int64?



    public  init(address:String,cycle:Int64,name:String,source:[SiteMonitorSource?]?,taskType:String){
             self.address = address
             self.cycle = cycle
             self.name = name
             self.source = source
             self.taskType = taskType
    }

    enum UpdateSiteMonitorSpecCodingKeys: String, CodingKey {
        case address
        case advanceChecked
        case createdTime
        case cycle
        case defaultSource
        case dnsOption
        case enabled
        case ftpOption
        case hawkeyeId
        case httpOption
        case id
        case isDeleted
        case name
        case pin
        case pingOption
        case pop3Option
        case port
        case smtpOption
        case source
        case stats
        case taskType
        case tcpOption
        case udpOption
        case updatedTime
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: UpdateSiteMonitorSpecCodingKeys.self)
        self.address = try decoderContainer.decode(String.self, forKey: .address)
        if decoderContainer.contains(.advanceChecked)
        {
            self.advanceChecked = try decoderContainer.decode(String?.self, forKey: .advanceChecked)
        }
        if decoderContainer.contains(.createdTime)
        {
            self.createdTime = try decoderContainer.decode(Int64?.self, forKey: .createdTime)
        }
        self.cycle = try decoderContainer.decode(Int64.self, forKey: .cycle)
        if decoderContainer.contains(.defaultSource)
        {
            self.defaultSource = try decoderContainer.decode(String?.self, forKey: .defaultSource)
        }
        if decoderContainer.contains(.dnsOption)
        {
            self.dnsOption = try decoderContainer.decode(SiteMonitorDnsOption?.self, forKey: .dnsOption)
        }
        if decoderContainer.contains(.enabled)
        {
            self.enabled = try decoderContainer.decode(String?.self, forKey: .enabled)
        }
        if decoderContainer.contains(.ftpOption)
        {
            self.ftpOption = try decoderContainer.decode(SiteMonitorFtpOption?.self, forKey: .ftpOption)
        }
        if decoderContainer.contains(.hawkeyeId)
        {
            self.hawkeyeId = try decoderContainer.decode(Int64?.self, forKey: .hawkeyeId)
        }
        if decoderContainer.contains(.httpOption)
        {
            self.httpOption = try decoderContainer.decode(SiteMonitorHttpOption?.self, forKey: .httpOption)
        }
        if decoderContainer.contains(.id)
        {
            self.id = try decoderContainer.decode(String?.self, forKey: .id)
        }
        if decoderContainer.contains(.isDeleted)
        {
            self.isDeleted = try decoderContainer.decode(String?.self, forKey: .isDeleted)
        }
        self.name = try decoderContainer.decode(String.self, forKey: .name)
        if decoderContainer.contains(.pin)
        {
            self.pin = try decoderContainer.decode(String?.self, forKey: .pin)
        }
        if decoderContainer.contains(.pingOption)
        {
            self.pingOption = try decoderContainer.decode(SiteMonitorPingOption?.self, forKey: .pingOption)
        }
        if decoderContainer.contains(.pop3Option)
        {
            self.pop3Option = try decoderContainer.decode(SiteMonitorPop3Option?.self, forKey: .pop3Option)
        }
        if decoderContainer.contains(.port)
        {
            self.port = try decoderContainer.decode(String?.self, forKey: .port)
        }
        if decoderContainer.contains(.smtpOption)
        {
            self.smtpOption = try decoderContainer.decode(SiteMonitorSmtpOption?.self, forKey: .smtpOption)
        }
        self.source = try decoderContainer.decode([SiteMonitorSource?]?.self, forKey: .source)
        self.taskType = try decoderContainer.decode(String.self, forKey: .taskType)
        if decoderContainer.contains(.tcpOption)
        {
            self.tcpOption = try decoderContainer.decode(SiteMonitorTcpOption?.self, forKey: .tcpOption)
        }
        if decoderContainer.contains(.udpOption)
        {
            self.udpOption = try decoderContainer.decode(SiteMonitorUdpOption?.self, forKey: .udpOption)
        }
        if decoderContainer.contains(.updatedTime)
        {
            self.updatedTime = try decoderContainer.decode(Int64?.self, forKey: .updatedTime)
        }
    }
}
public extension UpdateSiteMonitorSpec{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: UpdateSiteMonitorSpecCodingKeys.self)
         try encoderContainer.encode(address, forKey: .address)
         try encoderContainer.encode(advanceChecked, forKey: .advanceChecked)
         try encoderContainer.encode(createdTime, forKey: .createdTime)
         try encoderContainer.encode(cycle, forKey: .cycle)
         try encoderContainer.encode(defaultSource, forKey: .defaultSource)
         try encoderContainer.encode(dnsOption, forKey: .dnsOption)
         try encoderContainer.encode(enabled, forKey: .enabled)
         try encoderContainer.encode(ftpOption, forKey: .ftpOption)
         try encoderContainer.encode(hawkeyeId, forKey: .hawkeyeId)
         try encoderContainer.encode(httpOption, forKey: .httpOption)
         try encoderContainer.encode(id, forKey: .id)
         try encoderContainer.encode(isDeleted, forKey: .isDeleted)
         try encoderContainer.encode(name, forKey: .name)
         try encoderContainer.encode(pin, forKey: .pin)
         try encoderContainer.encode(pingOption, forKey: .pingOption)
         try encoderContainer.encode(pop3Option, forKey: .pop3Option)
         try encoderContainer.encode(port, forKey: .port)
         try encoderContainer.encode(smtpOption, forKey: .smtpOption)
         try encoderContainer.encode(source, forKey: .source)
         try encoderContainer.encode(taskType, forKey: .taskType)
         try encoderContainer.encode(tcpOption, forKey: .tcpOption)
         try encoderContainer.encode(udpOption, forKey: .udpOption)
         try encoderContainer.encode(updatedTime, forKey: .updatedTime)
    }
}
///  siteMonitorDnsOption
public class SiteMonitorDnsOption:NSObject,Codable{
    /// DNS查询类型，可选值：A、MX、NS、CNAME、TXT、ANY，不填默认为A
    var checkType:String?
    /// 期望解析别名，多个之间用逗号,分割
    var expectAlias:String?
    /// 期望解析ip，多个之间用逗号,分割
    var expectIP:String?
    /// DNS服务器
    var server:String?
    /// Timeout
    var timeout:Int64?



    public override init(){
            super.init()
    }

    enum SiteMonitorDnsOptionCodingKeys: String, CodingKey {
        case checkType
        case expectAlias
        case expectIP
        case server
        case timeout
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: SiteMonitorDnsOptionCodingKeys.self)
        if decoderContainer.contains(.checkType)
        {
            self.checkType = try decoderContainer.decode(String?.self, forKey: .checkType)
        }
        if decoderContainer.contains(.expectAlias)
        {
            self.expectAlias = try decoderContainer.decode(String?.self, forKey: .expectAlias)
        }
        if decoderContainer.contains(.expectIP)
        {
            self.expectIP = try decoderContainer.decode(String?.self, forKey: .expectIP)
        }
        if decoderContainer.contains(.server)
        {
            self.server = try decoderContainer.decode(String?.self, forKey: .server)
        }
        if decoderContainer.contains(.timeout)
        {
            self.timeout = try decoderContainer.decode(Int64?.self, forKey: .timeout)
        }
    }
}
public extension SiteMonitorDnsOption{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: SiteMonitorDnsOptionCodingKeys.self)
         try encoderContainer.encode(checkType, forKey: .checkType)
         try encoderContainer.encode(expectAlias, forKey: .expectAlias)
         try encoderContainer.encode(expectIP, forKey: .expectIP)
         try encoderContainer.encode(server, forKey: .server)
         try encoderContainer.encode(timeout, forKey: .timeout)
    }
}
///  siteMonitorSource
public class SiteMonitorSource:NSObject,Codable{
    /// Sisp
    var sisp:String?
    /// SispName
    var sispName:String?
    /// Sloc
    var sloc:String?
    /// SlocName
    var slocName:String?



    public override init(){
            super.init()
    }

    enum SiteMonitorSourceCodingKeys: String, CodingKey {
        case sisp
        case sispName
        case sloc
        case slocName
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: SiteMonitorSourceCodingKeys.self)
        if decoderContainer.contains(.sisp)
        {
            self.sisp = try decoderContainer.decode(String?.self, forKey: .sisp)
        }
        if decoderContainer.contains(.sispName)
        {
            self.sispName = try decoderContainer.decode(String?.self, forKey: .sispName)
        }
        if decoderContainer.contains(.sloc)
        {
            self.sloc = try decoderContainer.decode(String?.self, forKey: .sloc)
        }
        if decoderContainer.contains(.slocName)
        {
            self.slocName = try decoderContainer.decode(String?.self, forKey: .slocName)
        }
    }
}
public extension SiteMonitorSource{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: SiteMonitorSourceCodingKeys.self)
         try encoderContainer.encode(sisp, forKey: .sisp)
         try encoderContainer.encode(sispName, forKey: .sispName)
         try encoderContainer.encode(sloc, forKey: .sloc)
         try encoderContainer.encode(slocName, forKey: .slocName)
    }
}
///  siteMonitorTcpOption
public class SiteMonitorTcpOption:NSObject,Codable{
    /// 请求内容
    var reqContent:String?
    /// 请求内容类型，可选值text（文本）、hex（十六进制）
    var reqContentType:String?
    /// 返回校验内容
    var resCheck:String?
    /// 返回内容类型，可选值text（文本）、hex（十六进制）
    var resCheckType:String?
    /// Timeout
    var timeout:Int64?



    public override init(){
            super.init()
    }

    enum SiteMonitorTcpOptionCodingKeys: String, CodingKey {
        case reqContent
        case reqContentType
        case resCheck
        case resCheckType
        case timeout
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: SiteMonitorTcpOptionCodingKeys.self)
        if decoderContainer.contains(.reqContent)
        {
            self.reqContent = try decoderContainer.decode(String?.self, forKey: .reqContent)
        }
        if decoderContainer.contains(.reqContentType)
        {
            self.reqContentType = try decoderContainer.decode(String?.self, forKey: .reqContentType)
        }
        if decoderContainer.contains(.resCheck)
        {
            self.resCheck = try decoderContainer.decode(String?.self, forKey: .resCheck)
        }
        if decoderContainer.contains(.resCheckType)
        {
            self.resCheckType = try decoderContainer.decode(String?.self, forKey: .resCheckType)
        }
        if decoderContainer.contains(.timeout)
        {
            self.timeout = try decoderContainer.decode(Int64?.self, forKey: .timeout)
        }
    }
}
public extension SiteMonitorTcpOption{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: SiteMonitorTcpOptionCodingKeys.self)
         try encoderContainer.encode(reqContent, forKey: .reqContent)
         try encoderContainer.encode(reqContentType, forKey: .reqContentType)
         try encoderContainer.encode(resCheck, forKey: .resCheck)
         try encoderContainer.encode(resCheckType, forKey: .resCheckType)
         try encoderContainer.encode(timeout, forKey: .timeout)
    }
}
///  siteMonitorPingOption
public class SiteMonitorPingOption:NSObject,Codable{
    /// 包数，默认为20
    var packetCount:Int64?
    /// Timeout
    var timeout:Int64?



    public override init(){
            super.init()
    }

    enum SiteMonitorPingOptionCodingKeys: String, CodingKey {
        case packetCount
        case timeout
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: SiteMonitorPingOptionCodingKeys.self)
        if decoderContainer.contains(.packetCount)
        {
            self.packetCount = try decoderContainer.decode(Int64?.self, forKey: .packetCount)
        }
        if decoderContainer.contains(.timeout)
        {
            self.timeout = try decoderContainer.decode(Int64?.self, forKey: .timeout)
        }
    }
}
public extension SiteMonitorPingOption{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: SiteMonitorPingOptionCodingKeys.self)
         try encoderContainer.encode(packetCount, forKey: .packetCount)
         try encoderContainer.encode(timeout, forKey: .timeout)
    }
}
///  tasksInfo
public class TasksInfo:NSObject,Codable{
    /// task类型
    var confType:String?
    /// UID
    var confUID:String?
    /// 任务内容
    var content:AnyObject?
    /// 采集间隔
    var interval:Int64?
    /// meta信息，类型为map[string]string
    var meta:[String:String?]?



    public override init(){
            super.init()
    }

    enum TasksInfoCodingKeys: String, CodingKey {
        case confType
        case confUID
        case content
        case interval
        case meta
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: TasksInfoCodingKeys.self)
        if decoderContainer.contains(.confType)
        {
            self.confType = try decoderContainer.decode(String?.self, forKey: .confType)
        }
        if decoderContainer.contains(.confUID)
        {
            self.confUID = try decoderContainer.decode(String?.self, forKey: .confUID)
        }
        if decoderContainer.contains(.interval)
        {
            self.interval = try decoderContainer.decode(Int64?.self, forKey: .interval)
        }
        if decoderContainer.contains(.meta)
        {
            self.meta = try decoderContainer.decode([String:String?]?.self, forKey: .meta)
        }
    }
}
public extension TasksInfo{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: TasksInfoCodingKeys.self)
         try encoderContainer.encode(confType, forKey: .confType)
         try encoderContainer.encode(confUID, forKey: .confUID)
         try encoderContainer.encode(interval, forKey: .interval)
         try encoderContainer.encode(meta, forKey: .meta)
    }
}
///  templateOption
public class TemplateOption:NSObject,Codable{
    /// 模板Id
    var templateId:String?
    /// 模板类型.1-默认模板  2-自定义模板
    var templateType:Int64?



    public override init(){
            super.init()
    }

    enum TemplateOptionCodingKeys: String, CodingKey {
        case templateId
        case templateType
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: TemplateOptionCodingKeys.self)
        if decoderContainer.contains(.templateId)
        {
            self.templateId = try decoderContainer.decode(String?.self, forKey: .templateId)
        }
        if decoderContainer.contains(.templateType)
        {
            self.templateType = try decoderContainer.decode(Int64?.self, forKey: .templateType)
        }
    }
}
public extension TemplateOption{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: TemplateOptionCodingKeys.self)
         try encoderContainer.encode(templateId, forKey: .templateId)
         try encoderContainer.encode(templateType, forKey: .templateType)
    }
}
///  webHookOption
public class WebHookOption:NSObject,Codable{
    /// 回调content 注：仅webHookUrl和webHookProtocol均不为空时，才会创建webHook
    var webHookContent:String?
    /// webHook协议
    var webHookProtocol:String?
    /// 回调secret，用户请求签名，防伪造
    var webHookSecret:String?
    /// 回调url
    var webHookUrl:String?



    public override init(){
            super.init()
    }

    enum WebHookOptionCodingKeys: String, CodingKey {
        case webHookContent
        case webHookProtocol
        case webHookSecret
        case webHookUrl
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: WebHookOptionCodingKeys.self)
        if decoderContainer.contains(.webHookContent)
        {
            self.webHookContent = try decoderContainer.decode(String?.self, forKey: .webHookContent)
        }
        if decoderContainer.contains(.webHookProtocol)
        {
            self.webHookProtocol = try decoderContainer.decode(String?.self, forKey: .webHookProtocol)
        }
        if decoderContainer.contains(.webHookSecret)
        {
            self.webHookSecret = try decoderContainer.decode(String?.self, forKey: .webHookSecret)
        }
        if decoderContainer.contains(.webHookUrl)
        {
            self.webHookUrl = try decoderContainer.decode(String?.self, forKey: .webHookUrl)
        }
    }
}
public extension WebHookOption{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: WebHookOptionCodingKeys.self)
         try encoderContainer.encode(webHookContent, forKey: .webHookContent)
         try encoderContainer.encode(webHookProtocol, forKey: .webHookProtocol)
         try encoderContainer.encode(webHookSecret, forKey: .webHookSecret)
         try encoderContainer.encode(webHookUrl, forKey: .webHookUrl)
    }
}
///  updateAlarmSpec
public class UpdateAlarmSpec:NSObject,Codable{
    /// 弹性伸缩组Id。注：仅ag\asg产品线内部使用
    var autoScalingPolicyId:String?
    /// 告警通知联系人
    var baseContact:[BaseContact?]?
    /// 资源维度，可用的维度请使用 describeProductsForAlarm接口查询
    var dimension:String?
    /// 是否启用, 1表示启用规则，0表示禁用规则，默认为1
    var enabled:Int64?
    /// 通知策略
    var noticeOption:[NoticeOption?]?
    /// 资源类型, 可用的资源类型列表请使用 describeProductsForAlarm接口查询。
    /// Required:true
    var product:String
    /// ResourceOption
    /// Required:true
    var resourceOption:ResourceOption
    /// 规则名称，规则名称，最大长度42个字符，只允许中英文、数字、&#39;&#39;-&#39;&#39;和&quot;_&quot;
    /// Required:true
    var ruleName:String
    /// RuleOption
    /// Required:true
    var ruleOption:RuleOption
    /// 规则类型, 默认为resourceMonitor
    var ruleType:String?
    /// 资源维度，指定监控数据实例的维度标签,如resourceId&#x3D;id。(请确认资源的监控数据带有该标签，否则规则会报数据不足)
    var tags:[String:String?]?
    /// WebHookOption
    var webHookOption:WebHookOption?



    public  init(product:String,resourceOption:ResourceOption,ruleName:String,ruleOption:RuleOption){
             self.product = product
             self.resourceOption = resourceOption
             self.ruleName = ruleName
             self.ruleOption = ruleOption
    }

    enum UpdateAlarmSpecCodingKeys: String, CodingKey {
        case autoScalingPolicyId
        case baseContact
        case dimension
        case enabled
        case noticeOption
        case product
        case resourceOption
        case ruleName
        case ruleOption
        case ruleType
        case tags
        case webHookOption
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: UpdateAlarmSpecCodingKeys.self)
        if decoderContainer.contains(.autoScalingPolicyId)
        {
            self.autoScalingPolicyId = try decoderContainer.decode(String?.self, forKey: .autoScalingPolicyId)
        }
        if decoderContainer.contains(.baseContact)
        {
            self.baseContact = try decoderContainer.decode([BaseContact?]?.self, forKey: .baseContact)
        }
        if decoderContainer.contains(.dimension)
        {
            self.dimension = try decoderContainer.decode(String?.self, forKey: .dimension)
        }
        if decoderContainer.contains(.enabled)
        {
            self.enabled = try decoderContainer.decode(Int64?.self, forKey: .enabled)
        }
        if decoderContainer.contains(.noticeOption)
        {
            self.noticeOption = try decoderContainer.decode([NoticeOption?]?.self, forKey: .noticeOption)
        }
        self.product = try decoderContainer.decode(String.self, forKey: .product)
        self.resourceOption = try decoderContainer.decode(ResourceOption.self, forKey: .resourceOption)
        self.ruleName = try decoderContainer.decode(String.self, forKey: .ruleName)
        self.ruleOption = try decoderContainer.decode(RuleOption.self, forKey: .ruleOption)
        if decoderContainer.contains(.ruleType)
        {
            self.ruleType = try decoderContainer.decode(String?.self, forKey: .ruleType)
        }
        if decoderContainer.contains(.tags)
        {
            self.tags = try decoderContainer.decode([String:String?]?.self, forKey: .tags)
        }
        if decoderContainer.contains(.webHookOption)
        {
            self.webHookOption = try decoderContainer.decode(WebHookOption?.self, forKey: .webHookOption)
        }
    }
}
public extension UpdateAlarmSpec{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: UpdateAlarmSpecCodingKeys.self)
         try encoderContainer.encode(autoScalingPolicyId, forKey: .autoScalingPolicyId)
         try encoderContainer.encode(baseContact, forKey: .baseContact)
         try encoderContainer.encode(dimension, forKey: .dimension)
         try encoderContainer.encode(enabled, forKey: .enabled)
         try encoderContainer.encode(noticeOption, forKey: .noticeOption)
         try encoderContainer.encode(product, forKey: .product)
         try encoderContainer.encode(resourceOption, forKey: .resourceOption)
         try encoderContainer.encode(ruleName, forKey: .ruleName)
         try encoderContainer.encode(ruleOption, forKey: .ruleOption)
         try encoderContainer.encode(ruleType, forKey: .ruleType)
         try encoderContainer.encode(tags, forKey: .tags)
         try encoderContainer.encode(webHookOption, forKey: .webHookOption)
    }
}
///  noticeReceiver
public class NoticeReceiver:NSObject,Codable{
    /// Email
    var email:String?
    /// Mobile
    var mobile:String?
    /// PersonId
    var personId:Int64?
    /// Pin
    var pin:String?
    /// UserName
    var userName:String?



    public override init(){
            super.init()
    }

    enum NoticeReceiverCodingKeys: String, CodingKey {
        case email
        case mobile
        case personId
        case pin
        case userName
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: NoticeReceiverCodingKeys.self)
        if decoderContainer.contains(.email)
        {
            self.email = try decoderContainer.decode(String?.self, forKey: .email)
        }
        if decoderContainer.contains(.mobile)
        {
            self.mobile = try decoderContainer.decode(String?.self, forKey: .mobile)
        }
        if decoderContainer.contains(.personId)
        {
            self.personId = try decoderContainer.decode(Int64?.self, forKey: .personId)
        }
        if decoderContainer.contains(.pin)
        {
            self.pin = try decoderContainer.decode(String?.self, forKey: .pin)
        }
        if decoderContainer.contains(.userName)
        {
            self.userName = try decoderContainer.decode(String?.self, forKey: .userName)
        }
    }
}
public extension NoticeReceiver{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: NoticeReceiverCodingKeys.self)
         try encoderContainer.encode(email, forKey: .email)
         try encoderContainer.encode(mobile, forKey: .mobile)
         try encoderContainer.encode(personId, forKey: .personId)
         try encoderContainer.encode(pin, forKey: .pin)
         try encoderContainer.encode(userName, forKey: .userName)
    }
}
///  ruleOptionDetail
public class RuleOptionDetail:NSObject,Codable{
    /// 规则触发条件,与模块参数同时指定时，优先使用rules
    var rules:[BasicRuleDetail?]?
    /// TemplateOption
    var templateOption:TemplateOption?



    public override init(){
            super.init()
    }

    enum RuleOptionDetailCodingKeys: String, CodingKey {
        case rules
        case templateOption
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: RuleOptionDetailCodingKeys.self)
        if decoderContainer.contains(.rules)
        {
            self.rules = try decoderContainer.decode([BasicRuleDetail?]?.self, forKey: .rules)
        }
        if decoderContainer.contains(.templateOption)
        {
            self.templateOption = try decoderContainer.decode(TemplateOption?.self, forKey: .templateOption)
        }
    }
}
public extension RuleOptionDetail{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: RuleOptionDetailCodingKeys.self)
         try encoderContainer.encode(rules, forKey: .rules)
         try encoderContainer.encode(templateOption, forKey: .templateOption)
    }
}
///  baseContact
public class BaseContact:NSObject,Codable{
    /// 联系人id。  注：ReferenceType&#x3D;2时，联系人id请填0
    /// Required:true
    var referenceId:Int64
    /// 联系人id类型：0,联系人分组id;1,联系人id，2，pin帐号主联系人
    /// Required:true
    var referenceType:Int64



    public  init(referenceId:Int64,referenceType:Int64){
             self.referenceId = referenceId
             self.referenceType = referenceType
    }

    enum BaseContactCodingKeys: String, CodingKey {
        case referenceId
        case referenceType
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: BaseContactCodingKeys.self)
        self.referenceId = try decoderContainer.decode(Int64.self, forKey: .referenceId)
        self.referenceType = try decoderContainer.decode(Int64.self, forKey: .referenceType)
    }
}
public extension BaseContact{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: BaseContactCodingKeys.self)
         try encoderContainer.encode(referenceId, forKey: .referenceId)
         try encoderContainer.encode(referenceType, forKey: .referenceType)
    }
}
///  ruleOption
public class RuleOption:NSObject,Codable{
    /// 规则触发条件,与模块参数同时指定时，优先使用rules
    var rules:[BasicRule?]?
    /// TemplateOption
    var templateOption:TemplateOption?



    public override init(){
            super.init()
    }

    enum RuleOptionCodingKeys: String, CodingKey {
        case rules
        case templateOption
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: RuleOptionCodingKeys.self)
        if decoderContainer.contains(.rules)
        {
            self.rules = try decoderContainer.decode([BasicRule?]?.self, forKey: .rules)
        }
        if decoderContainer.contains(.templateOption)
        {
            self.templateOption = try decoderContainer.decode(TemplateOption?.self, forKey: .templateOption)
        }
    }
}
public extension RuleOption{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: RuleOptionCodingKeys.self)
         try encoderContainer.encode(rules, forKey: .rules)
         try encoderContainer.encode(templateOption, forKey: .templateOption)
    }
}
///  describeGroupAlarm
public class DescribeGroupAlarm:NSObject,Codable{
    /// 报警规则ID
    var alarmId:String?
    /// 规则状态，当一个规则下同时存在报警、数据不足、正常的资源时，规则状态按 报警&gt;数据不足&gt;正常的优先级展示
      /// 监控项状态：-1 未启用 1正常，2告警，4数据不足
    var alarmStatus:Int64?
    /// 规则的状态列表,可能同时存在多个：1正常，2告警，4数据不足
    var alarmStatusList:[Int64?]?
    /// 创建时间
    var createTime:String?
    /// 资源维度
    var dimension:String?
    /// 资源维度名称
    var dimensionName:String?
    /// 是否启用, 1表示启用规则，0表示禁用规则，默认为1
    var enabled:Int64?
    /// 资源类型
    /// Required:true
    var product:String
    /// 资源类型名称
    var productName:String?
    /// ResourceOption
    /// Required:true
    var resourceOption:ResourceOption
    /// 规则名称，规则名称，最大长度42个字符，只允许中英文、数字、&#39;&#39;-&#39;&#39;和&quot;_&quot;
    /// Required:true
    var ruleName:String
    /// RuleOption
    /// Required:true
    var ruleOption:RuleOptionDetail
    /// 规则类型, 默认为resourceMonitor
    var ruleType:String?
    /// 规则版本  v1  v2
    var ruleVersion:String?
    /// 资源维度，指定监控数据实例的维度标签,如resourceId&#x3D;id。(请确认资源的监控数据带有该标签，否则规则会报数据不足)
    var tags:[String:String?]?



    public  init(product:String,resourceOption:ResourceOption,ruleName:String,ruleOption:RuleOptionDetail){
             self.product = product
             self.resourceOption = resourceOption
             self.ruleName = ruleName
             self.ruleOption = ruleOption
    }

    enum DescribeGroupAlarmCodingKeys: String, CodingKey {
        case alarmId
        case alarmStatus
        case alarmStatusList
        case createTime
        case dimension
        case dimensionName
        case enabled
        case product
        case productName
        case resourceOption
        case ruleName
        case ruleOption
        case ruleType
        case ruleVersion
        case tags
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: DescribeGroupAlarmCodingKeys.self)
        if decoderContainer.contains(.alarmId)
        {
            self.alarmId = try decoderContainer.decode(String?.self, forKey: .alarmId)
        }
        if decoderContainer.contains(.alarmStatus)
        {
            self.alarmStatus = try decoderContainer.decode(Int64?.self, forKey: .alarmStatus)
        }
        if decoderContainer.contains(.alarmStatusList)
        {
            self.alarmStatusList = try decoderContainer.decode([Int64?]?.self, forKey: .alarmStatusList)
        }
        if decoderContainer.contains(.createTime)
        {
            self.createTime = try decoderContainer.decode(String?.self, forKey: .createTime)
        }
        if decoderContainer.contains(.dimension)
        {
            self.dimension = try decoderContainer.decode(String?.self, forKey: .dimension)
        }
        if decoderContainer.contains(.dimensionName)
        {
            self.dimensionName = try decoderContainer.decode(String?.self, forKey: .dimensionName)
        }
        if decoderContainer.contains(.enabled)
        {
            self.enabled = try decoderContainer.decode(Int64?.self, forKey: .enabled)
        }
        self.product = try decoderContainer.decode(String.self, forKey: .product)
        if decoderContainer.contains(.productName)
        {
            self.productName = try decoderContainer.decode(String?.self, forKey: .productName)
        }
        self.resourceOption = try decoderContainer.decode(ResourceOption.self, forKey: .resourceOption)
        self.ruleName = try decoderContainer.decode(String.self, forKey: .ruleName)
        self.ruleOption = try decoderContainer.decode(RuleOptionDetail.self, forKey: .ruleOption)
        if decoderContainer.contains(.ruleType)
        {
            self.ruleType = try decoderContainer.decode(String?.self, forKey: .ruleType)
        }
        if decoderContainer.contains(.ruleVersion)
        {
            self.ruleVersion = try decoderContainer.decode(String?.self, forKey: .ruleVersion)
        }
        if decoderContainer.contains(.tags)
        {
            self.tags = try decoderContainer.decode([String:String?]?.self, forKey: .tags)
        }
    }
}
public extension DescribeGroupAlarm{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: DescribeGroupAlarmCodingKeys.self)
         try encoderContainer.encode(alarmId, forKey: .alarmId)
         try encoderContainer.encode(alarmStatus, forKey: .alarmStatus)
         try encoderContainer.encode(alarmStatusList, forKey: .alarmStatusList)
         try encoderContainer.encode(createTime, forKey: .createTime)
         try encoderContainer.encode(dimension, forKey: .dimension)
         try encoderContainer.encode(dimensionName, forKey: .dimensionName)
         try encoderContainer.encode(enabled, forKey: .enabled)
         try encoderContainer.encode(product, forKey: .product)
         try encoderContainer.encode(productName, forKey: .productName)
         try encoderContainer.encode(resourceOption, forKey: .resourceOption)
         try encoderContainer.encode(ruleName, forKey: .ruleName)
         try encoderContainer.encode(ruleOption, forKey: .ruleOption)
         try encoderContainer.encode(ruleType, forKey: .ruleType)
         try encoderContainer.encode(ruleVersion, forKey: .ruleVersion)
         try encoderContainer.encode(tags, forKey: .tags)
    }
}
///  规则触发条件
public class BasicRule:NSObject,Codable{
    /// 统计方法，必须与定义的metric一致，可选值列表：avg,sum,max,min
    /// Required:true
    var calculation:String
    /// 降采样函数
    var downSample:String?
    /// 监控项唯一标识，可根据DescribeMetricsForCreateAlarm接口查询各产品线可用的监控项（创建规则时使用Metric字段）。格式：metric:downsample
    /// Required:true
    var metric:String
    /// NoticeLevel
    var noticeLevel:NoticeLevel?
    /// 报警比较符，只能为以下几种lte(&lt;&#x3D;),lt(&lt;),gt(&gt;),gte(&gt;&#x3D;),eq(&#x3D;&#x3D;),ne(!&#x3D;)
    /// Required:true
    var operation:String
    /// 查询指标的周期，单位为分钟,目前支持的取值：1,2，5，10,15，30，60
    /// Required:true
    var period:Int64
    /// 报警阈值，目前只开放数值类型功能
    /// Required:true
    var threshold:Double
    /// 连续探测几次都满足阈值条件时报警，可选值:1,2,3,5,10,15,30,60
    /// Required:true
    var times:Int64



    public  init(calculation:String,metric:String,operation:String,period:Int64,threshold:Double,times:Int64){
             self.calculation = calculation
             self.metric = metric
             self.operation = operation
             self.period = period
             self.threshold = threshold
             self.times = times
    }

    enum BasicRuleCodingKeys: String, CodingKey {
        case calculation
        case downSample
        case metric
        case noticeLevel
        case operation
        case period
        case threshold
        case times
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: BasicRuleCodingKeys.self)
        self.calculation = try decoderContainer.decode(String.self, forKey: .calculation)
        if decoderContainer.contains(.downSample)
        {
            self.downSample = try decoderContainer.decode(String?.self, forKey: .downSample)
        }
        self.metric = try decoderContainer.decode(String.self, forKey: .metric)
        if decoderContainer.contains(.noticeLevel)
        {
            self.noticeLevel = try decoderContainer.decode(NoticeLevel?.self, forKey: .noticeLevel)
        }
        self.operation = try decoderContainer.decode(String.self, forKey: .operation)
        self.period = try decoderContainer.decode(Int64.self, forKey: .period)
        self.threshold = try decoderContainer.decode(Double.self, forKey: .threshold)
        self.times = try decoderContainer.decode(Int64.self, forKey: .times)
    }
}
public extension BasicRule{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: BasicRuleCodingKeys.self)
         try encoderContainer.encode(calculation, forKey: .calculation)
         try encoderContainer.encode(downSample, forKey: .downSample)
         try encoderContainer.encode(metric, forKey: .metric)
         try encoderContainer.encode(noticeLevel, forKey: .noticeLevel)
         try encoderContainer.encode(operation, forKey: .operation)
         try encoderContainer.encode(period, forKey: .period)
         try encoderContainer.encode(threshold, forKey: .threshold)
         try encoderContainer.encode(times, forKey: .times)
    }
}
///  tagFilter
public class TagFilter:NSObject,Codable{
    /// Tag键
    var key:String?
    /// Tag值
    var values:[String?]?



    public override init(){
            super.init()
    }

    enum TagFilterCodingKeys: String, CodingKey {
        case key
        case values
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: TagFilterCodingKeys.self)
        if decoderContainer.contains(.key)
        {
            self.key = try decoderContainer.decode(String?.self, forKey: .key)
        }
        if decoderContainer.contains(.values)
        {
            self.values = try decoderContainer.decode([String?]?.self, forKey: .values)
        }
    }
}
public extension TagFilter{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: TagFilterCodingKeys.self)
         try encoderContainer.encode(key, forKey: .key)
         try encoderContainer.encode(values, forKey: .values)
    }
}
///  详情
public class RuleMetricDetail:NSObject,Codable{
    /// 指标的计算单位，比如bit/s、%、k等
    var calculateUnit:String?
    /// 维度标识
    var dimension:String?
    /// 监控项唯一标识，可根据DescribeMetricsForCreateAlarm接口查询各产品线可用的监控项（创建规则时使用Metric字段）。格式：metric:downsample
    var metric:String?
    /// 监控项名称
    var metricName:String?
    /// 产品标识
    var product:String?
    /// 产品线标识
    var serviceCode:String?



    public override init(){
            super.init()
    }

    enum RuleMetricDetailCodingKeys: String, CodingKey {
        case calculateUnit
        case dimension
        case metric
        case metricName
        case product
        case serviceCode
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: RuleMetricDetailCodingKeys.self)
        if decoderContainer.contains(.calculateUnit)
        {
            self.calculateUnit = try decoderContainer.decode(String?.self, forKey: .calculateUnit)
        }
        if decoderContainer.contains(.dimension)
        {
            self.dimension = try decoderContainer.decode(String?.self, forKey: .dimension)
        }
        if decoderContainer.contains(.metric)
        {
            self.metric = try decoderContainer.decode(String?.self, forKey: .metric)
        }
        if decoderContainer.contains(.metricName)
        {
            self.metricName = try decoderContainer.decode(String?.self, forKey: .metricName)
        }
        if decoderContainer.contains(.product)
        {
            self.product = try decoderContainer.decode(String?.self, forKey: .product)
        }
        if decoderContainer.contains(.serviceCode)
        {
            self.serviceCode = try decoderContainer.decode(String?.self, forKey: .serviceCode)
        }
    }
}
public extension RuleMetricDetail{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: RuleMetricDetailCodingKeys.self)
         try encoderContainer.encode(calculateUnit, forKey: .calculateUnit)
         try encoderContainer.encode(dimension, forKey: .dimension)
         try encoderContainer.encode(metric, forKey: .metric)
         try encoderContainer.encode(metricName, forKey: .metricName)
         try encoderContainer.encode(product, forKey: .product)
         try encoderContainer.encode(serviceCode, forKey: .serviceCode)
    }
}
///  ruleState
public class RuleState:NSObject,Codable{
    /// 资源id
    var resourceId:String?
    /// 规则个数
    var ruleCount:Int64?
    /// 资源的规则状态。1：正常、 2：报警、4：数据不足 -1:没有规则 -2:未启用
    var state:Int64?



    public override init(){
            super.init()
    }

    enum RuleStateCodingKeys: String, CodingKey {
        case resourceId
        case ruleCount
        case state
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: RuleStateCodingKeys.self)
        if decoderContainer.contains(.resourceId)
        {
            self.resourceId = try decoderContainer.decode(String?.self, forKey: .resourceId)
        }
        if decoderContainer.contains(.ruleCount)
        {
            self.ruleCount = try decoderContainer.decode(Int64?.self, forKey: .ruleCount)
        }
        if decoderContainer.contains(.state)
        {
            self.state = try decoderContainer.decode(Int64?.self, forKey: .state)
        }
    }
}
public extension RuleState{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: RuleStateCodingKeys.self)
         try encoderContainer.encode(resourceId, forKey: .resourceId)
         try encoderContainer.encode(ruleCount, forKey: .ruleCount)
         try encoderContainer.encode(state, forKey: .state)
    }
}
///  updateAlarmResourcesSpec
public class UpdateAlarmResourcesSpec:NSObject,Codable{
    /// 操作类型,默认为1，说明：1-覆盖  2-追加 3-删除
    var operatorType:Int64?
    /// ResourceOption
    /// Required:true
    var resourceOption:ResourceOption



    public  init(resourceOption:ResourceOption){
             self.resourceOption = resourceOption
    }

    enum UpdateAlarmResourcesSpecCodingKeys: String, CodingKey {
        case operatorType
        case resourceOption
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: UpdateAlarmResourcesSpecCodingKeys.self)
        if decoderContainer.contains(.operatorType)
        {
            self.operatorType = try decoderContainer.decode(Int64?.self, forKey: .operatorType)
        }
        self.resourceOption = try decoderContainer.decode(ResourceOption.self, forKey: .resourceOption)
    }
}
public extension UpdateAlarmResourcesSpec{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: UpdateAlarmResourcesSpecCodingKeys.self)
         try encoderContainer.encode(operatorType, forKey: .operatorType)
         try encoderContainer.encode(resourceOption, forKey: .resourceOption)
    }
}
///  noticeLevel
public class NoticeLevel:NSObject,Codable{
    /// 是否为用户自己定义的级别，自定义(true) or 固定(false)
    /// Required:true
    var custom:Bool
    /// 报警级别以及对应的阈值，是一个map[string]float64对象。key:common(一般)、critical(严重)、 fatal(紧急),value:各报警级别对应的阀值，要符合operation参数对应的递进关系。 eg: &quot;levels&quot;:{&quot;common&quot;:1000,&quot;critical&quot;:10000,&quot;fatal&quot;:15000}
    /// Required:true
    var levels:[String:Double?]?



    public  init(custom:Bool,levels:[String:Double?]?){
             self.custom = custom
             self.levels = levels
    }

    enum NoticeLevelCodingKeys: String, CodingKey {
        case custom
        case levels
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: NoticeLevelCodingKeys.self)
        self.custom = try decoderContainer.decode(Bool.self, forKey: .custom)
        self.levels = try decoderContainer.decode([String:Double?]?.self, forKey: .levels)
    }
}
public extension NoticeLevel{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: NoticeLevelCodingKeys.self)
         try encoderContainer.encode(custom, forKey: .custom)
         try encoderContainer.encode(levels, forKey: .levels)
    }
}
///  describedAlarmHistory
public class DescribedAlarmHistory:NSObject,Codable{
    /// 报警规则ID
    var alarmId:String?
    /// 资源维度
    var dimension:String?
    /// 资源维度名称
    var dimensionName:String?
    /// 告警持续次数
    var durationTimes:Int64?
    /// 告警持续时间，单位分钟
    var noticeDurationTime:Int64?
    /// 用于前端显示的‘触发告警级别’。从低到高分别为‘普通’, ‘紧急’, ‘严重’
    var noticeLevel:String?
    /// 触发的告警级别。从低到高分别为‘common’, ‘critical’, ‘fatal’
    var noticeLevelTriggered:String?
    /// 告警时间
    var noticeTime:String?
    /// 资源类型
    var product:String?
    /// 资源类型名称
    var productName:String?
    /// 告警通知人
    var receivers:[NoticeReceiver?]?
    /// 资源Id对应的region
    var region:String?
    /// 资源Id
    var resourceId:String?
    /// Rule
    var rule:BasicRuleDetail?
    /// 规则类型
    var ruleType:String?
    /// 告警类型  1-告警恢复  2-告警 4-数据不足
    var status:Int64?
    /// 资源tags
    var tags:[String:String?]?
    /// 告警值
    var value:Double?



    public override init(){
            super.init()
    }

    enum DescribedAlarmHistoryCodingKeys: String, CodingKey {
        case alarmId
        case dimension
        case dimensionName
        case durationTimes
        case noticeDurationTime
        case noticeLevel
        case noticeLevelTriggered
        case noticeTime
        case product
        case productName
        case receivers
        case region
        case resourceId
        case rule
        case ruleType
        case status
        case tags
        case value
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: DescribedAlarmHistoryCodingKeys.self)
        if decoderContainer.contains(.alarmId)
        {
            self.alarmId = try decoderContainer.decode(String?.self, forKey: .alarmId)
        }
        if decoderContainer.contains(.dimension)
        {
            self.dimension = try decoderContainer.decode(String?.self, forKey: .dimension)
        }
        if decoderContainer.contains(.dimensionName)
        {
            self.dimensionName = try decoderContainer.decode(String?.self, forKey: .dimensionName)
        }
        if decoderContainer.contains(.durationTimes)
        {
            self.durationTimes = try decoderContainer.decode(Int64?.self, forKey: .durationTimes)
        }
        if decoderContainer.contains(.noticeDurationTime)
        {
            self.noticeDurationTime = try decoderContainer.decode(Int64?.self, forKey: .noticeDurationTime)
        }
        if decoderContainer.contains(.noticeLevel)
        {
            self.noticeLevel = try decoderContainer.decode(String?.self, forKey: .noticeLevel)
        }
        if decoderContainer.contains(.noticeLevelTriggered)
        {
            self.noticeLevelTriggered = try decoderContainer.decode(String?.self, forKey: .noticeLevelTriggered)
        }
        if decoderContainer.contains(.noticeTime)
        {
            self.noticeTime = try decoderContainer.decode(String?.self, forKey: .noticeTime)
        }
        if decoderContainer.contains(.product)
        {
            self.product = try decoderContainer.decode(String?.self, forKey: .product)
        }
        if decoderContainer.contains(.productName)
        {
            self.productName = try decoderContainer.decode(String?.self, forKey: .productName)
        }
        if decoderContainer.contains(.receivers)
        {
            self.receivers = try decoderContainer.decode([NoticeReceiver?]?.self, forKey: .receivers)
        }
        if decoderContainer.contains(.region)
        {
            self.region = try decoderContainer.decode(String?.self, forKey: .region)
        }
        if decoderContainer.contains(.resourceId)
        {
            self.resourceId = try decoderContainer.decode(String?.self, forKey: .resourceId)
        }
        if decoderContainer.contains(.rule)
        {
            self.rule = try decoderContainer.decode(BasicRuleDetail?.self, forKey: .rule)
        }
        if decoderContainer.contains(.ruleType)
        {
            self.ruleType = try decoderContainer.decode(String?.self, forKey: .ruleType)
        }
        if decoderContainer.contains(.status)
        {
            self.status = try decoderContainer.decode(Int64?.self, forKey: .status)
        }
        if decoderContainer.contains(.tags)
        {
            self.tags = try decoderContainer.decode([String:String?]?.self, forKey: .tags)
        }
        if decoderContainer.contains(.value)
        {
            self.value = try decoderContainer.decode(Double?.self, forKey: .value)
        }
    }
}
public extension DescribedAlarmHistory{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: DescribedAlarmHistoryCodingKeys.self)
         try encoderContainer.encode(alarmId, forKey: .alarmId)
         try encoderContainer.encode(dimension, forKey: .dimension)
         try encoderContainer.encode(dimensionName, forKey: .dimensionName)
         try encoderContainer.encode(durationTimes, forKey: .durationTimes)
         try encoderContainer.encode(noticeDurationTime, forKey: .noticeDurationTime)
         try encoderContainer.encode(noticeLevel, forKey: .noticeLevel)
         try encoderContainer.encode(noticeLevelTriggered, forKey: .noticeLevelTriggered)
         try encoderContainer.encode(noticeTime, forKey: .noticeTime)
         try encoderContainer.encode(product, forKey: .product)
         try encoderContainer.encode(productName, forKey: .productName)
         try encoderContainer.encode(receivers, forKey: .receivers)
         try encoderContainer.encode(region, forKey: .region)
         try encoderContainer.encode(resourceId, forKey: .resourceId)
         try encoderContainer.encode(rule, forKey: .rule)
         try encoderContainer.encode(ruleType, forKey: .ruleType)
         try encoderContainer.encode(status, forKey: .status)
         try encoderContainer.encode(tags, forKey: .tags)
         try encoderContainer.encode(value, forKey: .value)
    }
}
///  resourceOption
public class ResourceOption:NSObject,Codable{
    /// 指定具体资源ID设置报警规则，每次最多100个。优先resourceItems生效
    var resourceItems:[ResourceItem?]?
    /// TagsOption
    var tagsOption:TagsOption?



    public override init(){
            super.init()
    }

    enum ResourceOptionCodingKeys: String, CodingKey {
        case resourceItems
        case tagsOption
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: ResourceOptionCodingKeys.self)
        if decoderContainer.contains(.resourceItems)
        {
            self.resourceItems = try decoderContainer.decode([ResourceItem?]?.self, forKey: .resourceItems)
        }
        if decoderContainer.contains(.tagsOption)
        {
            self.tagsOption = try decoderContainer.decode(TagsOption?.self, forKey: .tagsOption)
        }
    }
}
public extension ResourceOption{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: ResourceOptionCodingKeys.self)
         try encoderContainer.encode(resourceItems, forKey: .resourceItems)
         try encoderContainer.encode(tagsOption, forKey: .tagsOption)
    }
}
///  createAlarmSpec
public class CreateAlarmSpec:NSObject,Codable{
    /// 弹性伸缩组Id。注：仅ag\asg产品线内部使用
    var autoScalingPolicyId:String?
    /// 告警通知联系人
    var baseContact:[BaseContact?]?
    /// 幂等性校验参数,最长36位,若两个请求clientToken相等，则返回第一次创建的规则id，只创建一次规则
    /// Required:true
    var clientToken:String
    /// 资源维度，可用的维度请使用 describeProductsForAlarm接口查询
    var dimension:String?
    /// 是否启用, 1表示启用规则，0表示禁用规则，默认为1
    var enabled:Int64?
    /// 通知策略
    var noticeOption:[NoticeOption?]?
    /// 资源类型, 可用的资源类型列表请使用 describeProductsForAlarm接口查询。
    /// Required:true
    var product:String
    /// ResourceOption
    /// Required:true
    var resourceOption:ResourceOption
    /// 规则名称，规则名称，最大长度42个字符，只允许中英文、数字、&#39;&#39;-&#39;&#39;和&quot;_&quot;
    /// Required:true
    var ruleName:String
    /// RuleOption
    /// Required:true
    var ruleOption:RuleOption
    /// 规则类型, 默认为resourceMonitor
    var ruleType:String?
    /// 资源维度，指定监控数据实例的维度标签,如resourceId&#x3D;id。(请确认资源的监控数据带有该标签，否则规则会报数据不足)
    var tags:[String:String?]?
    /// WebHookOption
    var webHookOption:WebHookOption?



    public  init(clientToken:String,product:String,resourceOption:ResourceOption,ruleName:String,ruleOption:RuleOption){
             self.clientToken = clientToken
             self.product = product
             self.resourceOption = resourceOption
             self.ruleName = ruleName
             self.ruleOption = ruleOption
    }

    enum CreateAlarmSpecCodingKeys: String, CodingKey {
        case autoScalingPolicyId
        case baseContact
        case clientToken
        case dimension
        case enabled
        case noticeOption
        case product
        case resourceOption
        case ruleName
        case ruleOption
        case ruleType
        case tags
        case webHookOption
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: CreateAlarmSpecCodingKeys.self)
        if decoderContainer.contains(.autoScalingPolicyId)
        {
            self.autoScalingPolicyId = try decoderContainer.decode(String?.self, forKey: .autoScalingPolicyId)
        }
        if decoderContainer.contains(.baseContact)
        {
            self.baseContact = try decoderContainer.decode([BaseContact?]?.self, forKey: .baseContact)
        }
        self.clientToken = try decoderContainer.decode(String.self, forKey: .clientToken)
        if decoderContainer.contains(.dimension)
        {
            self.dimension = try decoderContainer.decode(String?.self, forKey: .dimension)
        }
        if decoderContainer.contains(.enabled)
        {
            self.enabled = try decoderContainer.decode(Int64?.self, forKey: .enabled)
        }
        if decoderContainer.contains(.noticeOption)
        {
            self.noticeOption = try decoderContainer.decode([NoticeOption?]?.self, forKey: .noticeOption)
        }
        self.product = try decoderContainer.decode(String.self, forKey: .product)
        self.resourceOption = try decoderContainer.decode(ResourceOption.self, forKey: .resourceOption)
        self.ruleName = try decoderContainer.decode(String.self, forKey: .ruleName)
        self.ruleOption = try decoderContainer.decode(RuleOption.self, forKey: .ruleOption)
        if decoderContainer.contains(.ruleType)
        {
            self.ruleType = try decoderContainer.decode(String?.self, forKey: .ruleType)
        }
        if decoderContainer.contains(.tags)
        {
            self.tags = try decoderContainer.decode([String:String?]?.self, forKey: .tags)
        }
        if decoderContainer.contains(.webHookOption)
        {
            self.webHookOption = try decoderContainer.decode(WebHookOption?.self, forKey: .webHookOption)
        }
    }
}
public extension CreateAlarmSpec{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: CreateAlarmSpecCodingKeys.self)
         try encoderContainer.encode(autoScalingPolicyId, forKey: .autoScalingPolicyId)
         try encoderContainer.encode(baseContact, forKey: .baseContact)
         try encoderContainer.encode(clientToken, forKey: .clientToken)
         try encoderContainer.encode(dimension, forKey: .dimension)
         try encoderContainer.encode(enabled, forKey: .enabled)
         try encoderContainer.encode(noticeOption, forKey: .noticeOption)
         try encoderContainer.encode(product, forKey: .product)
         try encoderContainer.encode(resourceOption, forKey: .resourceOption)
         try encoderContainer.encode(ruleName, forKey: .ruleName)
         try encoderContainer.encode(ruleOption, forKey: .ruleOption)
         try encoderContainer.encode(ruleType, forKey: .ruleType)
         try encoderContainer.encode(tags, forKey: .tags)
         try encoderContainer.encode(webHookOption, forKey: .webHookOption)
    }
}
///  resourceItem
public class ResourceItem:NSObject,Codable{
    /// 资源所属的region
    /// Required:true
    var region:String
    /// 资源id
    /// Required:true
    var resourceId:String



    public  init(region:String,resourceId:String){
             self.region = region
             self.resourceId = resourceId
    }

    enum ResourceItemCodingKeys: String, CodingKey {
        case region
        case resourceId
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: ResourceItemCodingKeys.self)
        self.region = try decoderContainer.decode(String.self, forKey: .region)
        self.resourceId = try decoderContainer.decode(String.self, forKey: .resourceId)
    }
}
public extension ResourceItem{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: ResourceItemCodingKeys.self)
         try encoderContainer.encode(region, forKey: .region)
         try encoderContainer.encode(resourceId, forKey: .resourceId)
    }
}
///  updateWebHookSpec
public class UpdateWebHookSpec:NSObject,Codable{
    /// 是否启用, 1表示启用webHook，0表示禁用webHook，默认为1
    var active:Int64?
    /// webHook content
    var content:String?
    /// webHook 协议,http或者https
    /// Required:true
    var protocolValue:String
    /// webHook secret，用户请求签名，防伪造
    var secret:String?
    /// webHook url
    /// Required:true
    var url:String



    public  init(protocolValue:String,url:String){
             self.protocolValue = protocolValue
             self.url = url
    }

    enum UpdateWebHookSpecCodingKeys: String, CodingKey {
        case active
        case content
        case protocolValue = "protocol"
        case secret
        case url
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: UpdateWebHookSpecCodingKeys.self)
        if decoderContainer.contains(.active)
        {
            self.active = try decoderContainer.decode(Int64?.self, forKey: .active)
        }
        if decoderContainer.contains(.content)
        {
            self.content = try decoderContainer.decode(String?.self, forKey: .content)
        }
        self.protocolValue = try decoderContainer.decode(String.self, forKey: .protocolValue)
        if decoderContainer.contains(.secret)
        {
            self.secret = try decoderContainer.decode(String?.self, forKey: .secret)
        }
        self.url = try decoderContainer.decode(String.self, forKey: .url)
    }
}
public extension UpdateWebHookSpec{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: UpdateWebHookSpecCodingKeys.self)
         try encoderContainer.encode(active, forKey: .active)
         try encoderContainer.encode(content, forKey: .content)
         try encoderContainer.encode(protocolValue, forKey: .protocolValue)
         try encoderContainer.encode(secret, forKey: .secret)
         try encoderContainer.encode(url, forKey: .url)
    }
}
///  NoticeContacts NoticeContacts
public class DescribedNoticeContacts:NSObject,Codable{
    /// 联系人ID
    var referenceId:Int64?
    /// 联系人类型。 0 - 联系人分组id， 1 - 联系人id
    var referenceType:Int64?



    public override init(){
            super.init()
    }

    enum DescribedNoticeContactsCodingKeys: String, CodingKey {
        case referenceId
        case referenceType
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: DescribedNoticeContactsCodingKeys.self)
        if decoderContainer.contains(.referenceId)
        {
            self.referenceId = try decoderContainer.decode(Int64?.self, forKey: .referenceId)
        }
        if decoderContainer.contains(.referenceType)
        {
            self.referenceType = try decoderContainer.decode(Int64?.self, forKey: .referenceType)
        }
    }
}
public extension DescribedNoticeContacts{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: DescribedNoticeContactsCodingKeys.self)
         try encoderContainer.encode(referenceId, forKey: .referenceId)
         try encoderContainer.encode(referenceType, forKey: .referenceType)
    }
}
///  noticeOption
public class NoticeOption:NSObject,Codable{
    /// 生效截止时间，默认值:23:59
    var effectiveIntervalEnd:String?
    /// 生效起始时间，默认值:00:00
    var effectiveIntervalStart:String?
    /// 通知条件 1-告警 2-数据不足3-告警恢复
    var noticeCondition:[Int64?]?
    /// 通知沉默周期,单位:分钟，默认值：24小时,目前支持的取值“24小时、12小时、6小时、3小时、1小时、30分钟、15分钟、10分钟、5分钟”
    var noticePeriod:Int64?
    /// 通知方法    1-短信 2-邮件
    var noticeWay:[Int64?]?



    public override init(){
            super.init()
    }

    enum NoticeOptionCodingKeys: String, CodingKey {
        case effectiveIntervalEnd
        case effectiveIntervalStart
        case noticeCondition
        case noticePeriod
        case noticeWay
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: NoticeOptionCodingKeys.self)
        if decoderContainer.contains(.effectiveIntervalEnd)
        {
            self.effectiveIntervalEnd = try decoderContainer.decode(String?.self, forKey: .effectiveIntervalEnd)
        }
        if decoderContainer.contains(.effectiveIntervalStart)
        {
            self.effectiveIntervalStart = try decoderContainer.decode(String?.self, forKey: .effectiveIntervalStart)
        }
        if decoderContainer.contains(.noticeCondition)
        {
            self.noticeCondition = try decoderContainer.decode([Int64?]?.self, forKey: .noticeCondition)
        }
        if decoderContainer.contains(.noticePeriod)
        {
            self.noticePeriod = try decoderContainer.decode(Int64?.self, forKey: .noticePeriod)
        }
        if decoderContainer.contains(.noticeWay)
        {
            self.noticeWay = try decoderContainer.decode([Int64?]?.self, forKey: .noticeWay)
        }
    }
}
public extension NoticeOption{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: NoticeOptionCodingKeys.self)
         try encoderContainer.encode(effectiveIntervalEnd, forKey: .effectiveIntervalEnd)
         try encoderContainer.encode(effectiveIntervalStart, forKey: .effectiveIntervalStart)
         try encoderContainer.encode(noticeCondition, forKey: .noticeCondition)
         try encoderContainer.encode(noticePeriod, forKey: .noticePeriod)
         try encoderContainer.encode(noticeWay, forKey: .noticeWay)
    }
}
///  动态标签资源,对指定标签服务的tag下的资源设置报警规则
public class TagsOption:NSObject,Codable{
    /// 操作项(多个tagFilter之间关关系)默认是or
    var operatorValue:String?
    /// 资源标签,对所有符合该标签的资源设置报警规则，对于新加入该标签的资源自动生效
    var tags:[TagFilter?]?



    public override init(){
            super.init()
    }

    enum TagsOptionCodingKeys: String, CodingKey {
        case operatorValue = "operator"
        case tags
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: TagsOptionCodingKeys.self)
        if decoderContainer.contains(.operatorValue)
        {
            self.operatorValue = try decoderContainer.decode(String?.self, forKey: .operatorValue)
        }
        if decoderContainer.contains(.tags)
        {
            self.tags = try decoderContainer.decode([TagFilter?]?.self, forKey: .tags)
        }
    }
}
public extension TagsOption{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: TagsOptionCodingKeys.self)
         try encoderContainer.encode(operatorValue, forKey: .operatorValue)
         try encoderContainer.encode(tags, forKey: .tags)
    }
}
///  ruleCounting
public class RuleCounting:NSObject,Codable{
    /// 处于报警状态的规则个数  status:2
    var alarmRuleCount:Int64?
    /// 未启用的规则 数量
    var disableRuleCount:Int64?
    /// 处于正常状态的规则个数  status：1
    var normalRuleCount:Int64?
    /// 产品标识
    var product:String?
    /// 监控规则 总数
    var totalRuleCount:Int64?
    /// 处于数据不足状态的规则 个数  status:4
    var unknownRuleCount:Int64?



    public override init(){
            super.init()
    }

    enum RuleCountingCodingKeys: String, CodingKey {
        case alarmRuleCount
        case disableRuleCount
        case normalRuleCount
        case product
        case totalRuleCount
        case unknownRuleCount
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: RuleCountingCodingKeys.self)
        if decoderContainer.contains(.alarmRuleCount)
        {
            self.alarmRuleCount = try decoderContainer.decode(Int64?.self, forKey: .alarmRuleCount)
        }
        if decoderContainer.contains(.disableRuleCount)
        {
            self.disableRuleCount = try decoderContainer.decode(Int64?.self, forKey: .disableRuleCount)
        }
        if decoderContainer.contains(.normalRuleCount)
        {
            self.normalRuleCount = try decoderContainer.decode(Int64?.self, forKey: .normalRuleCount)
        }
        if decoderContainer.contains(.product)
        {
            self.product = try decoderContainer.decode(String?.self, forKey: .product)
        }
        if decoderContainer.contains(.totalRuleCount)
        {
            self.totalRuleCount = try decoderContainer.decode(Int64?.self, forKey: .totalRuleCount)
        }
        if decoderContainer.contains(.unknownRuleCount)
        {
            self.unknownRuleCount = try decoderContainer.decode(Int64?.self, forKey: .unknownRuleCount)
        }
    }
}
public extension RuleCounting{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: RuleCountingCodingKeys.self)
         try encoderContainer.encode(alarmRuleCount, forKey: .alarmRuleCount)
         try encoderContainer.encode(disableRuleCount, forKey: .disableRuleCount)
         try encoderContainer.encode(normalRuleCount, forKey: .normalRuleCount)
         try encoderContainer.encode(product, forKey: .product)
         try encoderContainer.encode(totalRuleCount, forKey: .totalRuleCount)
         try encoderContainer.encode(unknownRuleCount, forKey: .unknownRuleCount)
    }
}
///  basicRuleDetail
public class BasicRuleDetail:NSObject,Codable{
    /// 指标的计算单位，比如bit/s、%、k等
    var calculateUnit:String?
    /// 统计方法，必须与定义的metric一致，可选值列表：avg,sum,max,min
    /// Required:true
    var calculation:String
    /// 降采样函数
    var downSample:String?
    /// 监控项唯一标识，可根据DescribeMetricsForCreateAlarm接口查询各产品线可用的监控项（创建规则时使用Metric字段）。格式：metric:downsample
    /// Required:true
    var metric:String
    /// 监控项名称
    /// Required:true
    var metricName:String
    /// NoticeLevel
    var noticeLevel:NoticeLevel?
    /// 报警比较符，只能为以下几种lte(&lt;&#x3D;),lt(&lt;),gt(&gt;),gte(&gt;&#x3D;),eq(&#x3D;&#x3D;),ne(!&#x3D;)
    /// Required:true
    var operation:String
    /// 查询指标的周期，单位为分钟,目前支持的取值：1,2，5，10,15，30，60
    /// Required:true
    var period:Int64
    /// 报警阈值，目前只开放数值类型功能
    /// Required:true
    var threshold:Double
    /// 连续探测几次都满足阈值条件时报警，可选值:1,2,3,5,10,15,30,60
    /// Required:true
    var times:Int64



    public  init(calculation:String,metric:String,metricName:String,operation:String,period:Int64,threshold:Double,times:Int64){
             self.calculation = calculation
             self.metric = metric
             self.metricName = metricName
             self.operation = operation
             self.period = period
             self.threshold = threshold
             self.times = times
    }

    enum BasicRuleDetailCodingKeys: String, CodingKey {
        case calculateUnit
        case calculation
        case downSample
        case metric
        case metricName
        case noticeLevel
        case operation
        case period
        case threshold
        case times
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: BasicRuleDetailCodingKeys.self)
        if decoderContainer.contains(.calculateUnit)
        {
            self.calculateUnit = try decoderContainer.decode(String?.self, forKey: .calculateUnit)
        }
        self.calculation = try decoderContainer.decode(String.self, forKey: .calculation)
        if decoderContainer.contains(.downSample)
        {
            self.downSample = try decoderContainer.decode(String?.self, forKey: .downSample)
        }
        self.metric = try decoderContainer.decode(String.self, forKey: .metric)
        self.metricName = try decoderContainer.decode(String.self, forKey: .metricName)
        if decoderContainer.contains(.noticeLevel)
        {
            self.noticeLevel = try decoderContainer.decode(NoticeLevel?.self, forKey: .noticeLevel)
        }
        self.operation = try decoderContainer.decode(String.self, forKey: .operation)
        self.period = try decoderContainer.decode(Int64.self, forKey: .period)
        self.threshold = try decoderContainer.decode(Double.self, forKey: .threshold)
        self.times = try decoderContainer.decode(Int64.self, forKey: .times)
    }
}
public extension BasicRuleDetail{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: BasicRuleDetailCodingKeys.self)
         try encoderContainer.encode(calculateUnit, forKey: .calculateUnit)
         try encoderContainer.encode(calculation, forKey: .calculation)
         try encoderContainer.encode(downSample, forKey: .downSample)
         try encoderContainer.encode(metric, forKey: .metric)
         try encoderContainer.encode(metricName, forKey: .metricName)
         try encoderContainer.encode(noticeLevel, forKey: .noticeLevel)
         try encoderContainer.encode(operation, forKey: .operation)
         try encoderContainer.encode(period, forKey: .period)
         try encoderContainer.encode(threshold, forKey: .threshold)
         try encoderContainer.encode(times, forKey: .times)
    }
}
///  createProbeTaskParam
public class CreateProbeTaskParam:NSObject,Codable{
    /// 探测地址，探测类型为http：内容为url（校验http或https头）；探测类型为telnet：内容为ip或域名（只允许中英文 、数字、中划线（-）、小数点（.）、开头及结尾均不能含有“-”）
    /// Required:true
    var address:String
    /// http body：选择探测类型为1&#x3D;http时有效，最长不超过1024字节
      /// in: query
    var httpBody:String?
    /// http cookie：选择探测类型为1&#x3D;http时有效，最大允许20个key、value对，最长不超过1024字节
    var httpCookie:[KeyValue?]?
    /// http header：选择探测类型为1&#x3D;http时有效，最大允许20个key、value对，最长不超过1024字节
    var httpHeader:[KeyValue?]?
    /// http探测方法：选择探测类型为1&#x3D;http时有效，默认值为1&#x3D;get，可选值：1:get、2:post、3:head
    var httpType:Int64?
    /// task名称，不允许重复，长度不超过32字符，只允许中英文、数字、下划线_、中划线-, [0-9][a-z] [A-Z] [- _ ]
    /// Required:true
    var name:String
    /// 探测端口，探测类型为telnet时必填，取值范围 [1-65535]，http类型忽略该参数
      /// in: query
    var port:Int64?
    /// 探测类型：1&#x3D;http、2&#x3D;telnet
    /// Required:true
    var probeType:Int64
    /// 探测源（发起对探测目标探测的云主机，需安装相应的agent才能探测）
    /// Required:true
    var probes:[Probe?]?
    /// 探测目标id：该探测对象的uuid，任务类型为2：rds、3：redis时必填，
    var targetId:String?
    /// 探测目标region：该探测对象所在region，任务类型为2：rds、3：redis时必填
      /// in: query
    var targetRegion:String?
    /// task类型：1&#x3D;url/ip、2&#x3D;RDS、3&#x3D;redis
    /// Required:true
    var taskType:Int64



    public  init(address:String,name:String,probeType:Int64,probes:[Probe?]?,taskType:Int64){
             self.address = address
             self.name = name
             self.probeType = probeType
             self.probes = probes
             self.taskType = taskType
    }

    enum CreateProbeTaskParamCodingKeys: String, CodingKey {
        case address
        case httpBody
        case httpCookie
        case httpHeader
        case httpType
        case name
        case port
        case probeType
        case probes
        case targetId
        case targetRegion
        case taskType
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: CreateProbeTaskParamCodingKeys.self)
        self.address = try decoderContainer.decode(String.self, forKey: .address)
        if decoderContainer.contains(.httpBody)
        {
            self.httpBody = try decoderContainer.decode(String?.self, forKey: .httpBody)
        }
        if decoderContainer.contains(.httpCookie)
        {
            self.httpCookie = try decoderContainer.decode([KeyValue?]?.self, forKey: .httpCookie)
        }
        if decoderContainer.contains(.httpHeader)
        {
            self.httpHeader = try decoderContainer.decode([KeyValue?]?.self, forKey: .httpHeader)
        }
        if decoderContainer.contains(.httpType)
        {
            self.httpType = try decoderContainer.decode(Int64?.self, forKey: .httpType)
        }
        self.name = try decoderContainer.decode(String.self, forKey: .name)
        if decoderContainer.contains(.port)
        {
            self.port = try decoderContainer.decode(Int64?.self, forKey: .port)
        }
        self.probeType = try decoderContainer.decode(Int64.self, forKey: .probeType)
        self.probes = try decoderContainer.decode([Probe?]?.self, forKey: .probes)
        if decoderContainer.contains(.targetId)
        {
            self.targetId = try decoderContainer.decode(String?.self, forKey: .targetId)
        }
        if decoderContainer.contains(.targetRegion)
        {
            self.targetRegion = try decoderContainer.decode(String?.self, forKey: .targetRegion)
        }
        self.taskType = try decoderContainer.decode(Int64.self, forKey: .taskType)
    }
}
public extension CreateProbeTaskParam{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: CreateProbeTaskParamCodingKeys.self)
         try encoderContainer.encode(address, forKey: .address)
         try encoderContainer.encode(httpBody, forKey: .httpBody)
         try encoderContainer.encode(httpCookie, forKey: .httpCookie)
         try encoderContainer.encode(httpHeader, forKey: .httpHeader)
         try encoderContainer.encode(httpType, forKey: .httpType)
         try encoderContainer.encode(name, forKey: .name)
         try encoderContainer.encode(port, forKey: .port)
         try encoderContainer.encode(probeType, forKey: .probeType)
         try encoderContainer.encode(probes, forKey: .probes)
         try encoderContainer.encode(targetId, forKey: .targetId)
         try encoderContainer.encode(targetRegion, forKey: .targetRegion)
         try encoderContainer.encode(taskType, forKey: .taskType)
    }
}
///  updateProbeTaskSpec
public class UpdateProbeTaskSpec:NSObject,Codable{
    /// http body：选择探测类型为1&#x3D;http时有效，最长不超过1024字节
    var httpBody:String?
    /// http cookie：选择探测类型为1&#x3D;http时有效，最大允许20个key、value对，最长不超过1024字节
    var httpCookie:[KeyValue?]?
    /// http header：选择探测类型为1&#x3D;http时有效，最大允许20个key、value对，最长不超过1024字节
    var httpHeader:[KeyValue?]?
    /// http探测方法,可选值：1:get、2:post、3:head
    var httpType:Int64?
    /// task名称，不允许重复，长度不超过32字符，只允许中英文、数字、下划线_、中划线-, [0-9][a-z] [A-Z] [- _ ]
    var name:String?
    /// 探测源（发起对探测目标探测的云主机，需安装相应的agent才能探测）
    /// Required:true
    var probes:[Probe?]?



    public  init(probes:[Probe?]?){
             self.probes = probes
    }

    enum UpdateProbeTaskSpecCodingKeys: String, CodingKey {
        case httpBody
        case httpCookie
        case httpHeader
        case httpType
        case name
        case probes
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: UpdateProbeTaskSpecCodingKeys.self)
        if decoderContainer.contains(.httpBody)
        {
            self.httpBody = try decoderContainer.decode(String?.self, forKey: .httpBody)
        }
        if decoderContainer.contains(.httpCookie)
        {
            self.httpCookie = try decoderContainer.decode([KeyValue?]?.self, forKey: .httpCookie)
        }
        if decoderContainer.contains(.httpHeader)
        {
            self.httpHeader = try decoderContainer.decode([KeyValue?]?.self, forKey: .httpHeader)
        }
        if decoderContainer.contains(.httpType)
        {
            self.httpType = try decoderContainer.decode(Int64?.self, forKey: .httpType)
        }
        if decoderContainer.contains(.name)
        {
            self.name = try decoderContainer.decode(String?.self, forKey: .name)
        }
        self.probes = try decoderContainer.decode([Probe?]?.self, forKey: .probes)
    }
}
public extension UpdateProbeTaskSpec{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: UpdateProbeTaskSpecCodingKeys.self)
         try encoderContainer.encode(httpBody, forKey: .httpBody)
         try encoderContainer.encode(httpCookie, forKey: .httpCookie)
         try encoderContainer.encode(httpHeader, forKey: .httpHeader)
         try encoderContainer.encode(httpType, forKey: .httpType)
         try encoderContainer.encode(name, forKey: .name)
         try encoderContainer.encode(probes, forKey: .probes)
    }
}
///  createProbeTaskSpec
public class CreateProbeTaskSpec:NSObject,Codable{
    /// 幂等性校验参数,最长36位
    /// Required:true
    var clientToken:String
    /// CreateProbeTaskSpecValue
    /// Required:true
    var createProbeTaskSpecValue:CreateProbeTaskParam



    public  init(clientToken:String,createProbeTaskSpecValue:CreateProbeTaskParam){
             self.clientToken = clientToken
             self.createProbeTaskSpecValue = createProbeTaskSpecValue
    }

    enum CreateProbeTaskSpecCodingKeys: String, CodingKey {
        case clientToken
        case createProbeTaskSpecValue = "createProbeTaskSpec"
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: CreateProbeTaskSpecCodingKeys.self)
        self.clientToken = try decoderContainer.decode(String.self, forKey: .clientToken)
        self.createProbeTaskSpecValue = try decoderContainer.decode(CreateProbeTaskParam.self, forKey: .createProbeTaskSpecValue)
    }
}
public extension CreateProbeTaskSpec{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: CreateProbeTaskSpecCodingKeys.self)
         try encoderContainer.encode(clientToken, forKey: .clientToken)
         try encoderContainer.encode(createProbeTaskSpecValue, forKey: .createProbeTaskSpecValue)
    }
}
///  keyValue
public class KeyValue:NSObject,Codable{
    /// key
    var key:String?
    /// value
    var value:String?



    public override init(){
            super.init()
    }

    enum KeyValueCodingKeys: String, CodingKey {
        case key
        case value
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: KeyValueCodingKeys.self)
        if decoderContainer.contains(.key)
        {
            self.key = try decoderContainer.decode(String?.self, forKey: .key)
        }
        if decoderContainer.contains(.value)
        {
            self.value = try decoderContainer.decode(String?.self, forKey: .value)
        }
    }
}
public extension KeyValue{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: KeyValueCodingKeys.self)
         try encoderContainer.encode(key, forKey: .key)
         try encoderContainer.encode(value, forKey: .value)
    }
}
///  probeTaskEnableSpec
public class ProbeTaskEnableSpec:NSObject,Codable{
    /// 默认：禁用； true：启用，false：禁用
    var enabled:Bool?
    /// 要启用或禁用的探测任务的task_id列表，列表长度[1，100)
    /// Required:true
    var taskId:[String?]?



    public  init(taskId:[String?]?){
             self.taskId = taskId
    }

    enum ProbeTaskEnableSpecCodingKeys: String, CodingKey {
        case enabled
        case taskId
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: ProbeTaskEnableSpecCodingKeys.self)
        if decoderContainer.contains(.enabled)
        {
            self.enabled = try decoderContainer.decode(Bool?.self, forKey: .enabled)
        }
        self.taskId = try decoderContainer.decode([String?]?.self, forKey: .taskId)
    }
}
public extension ProbeTaskEnableSpec{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: ProbeTaskEnableSpecCodingKeys.self)
         try encoderContainer.encode(enabled, forKey: .enabled)
         try encoderContainer.encode(taskId, forKey: .taskId)
    }
}
///  probe
public class Probe:NSObject,Codable{
    /// 探测源所在云主机内网ip
    /// Required:true
    var privateIp:String
    /// 探测源所在云主机公网ip
    var publicIp:String?
    /// 探测源所在region
    /// Required:true
    var region:String
    /// 探测源所在云主机的uuid
    /// Required:true
    var uuid:String



    public  init(privateIp:String,region:String,uuid:String){
             self.privateIp = privateIp
             self.region = region
             self.uuid = uuid
    }

    enum ProbeCodingKeys: String, CodingKey {
        case privateIp
        case publicIp
        case region
        case uuid
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: ProbeCodingKeys.self)
        self.privateIp = try decoderContainer.decode(String.self, forKey: .privateIp)
        if decoderContainer.contains(.publicIp)
        {
            self.publicIp = try decoderContainer.decode(String?.self, forKey: .publicIp)
        }
        self.region = try decoderContainer.decode(String.self, forKey: .region)
        self.uuid = try decoderContainer.decode(String.self, forKey: .uuid)
    }
}
public extension Probe{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: ProbeCodingKeys.self)
         try encoderContainer.encode(privateIp, forKey: .privateIp)
         try encoderContainer.encode(publicIp, forKey: .publicIp)
         try encoderContainer.encode(region, forKey: .region)
         try encoderContainer.encode(uuid, forKey: .uuid)
    }
}
///  tag
public class Tag:NSObject,Codable{
    /// TagKey
    var tagKey:String?
    /// TagValue
    var tagValue:String?



    public override init(){
            super.init()
    }

    enum TagCodingKeys: String, CodingKey {
        case tagKey
        case tagValue
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: TagCodingKeys.self)
        if decoderContainer.contains(.tagKey)
        {
            self.tagKey = try decoderContainer.decode(String?.self, forKey: .tagKey)
        }
        if decoderContainer.contains(.tagValue)
        {
            self.tagValue = try decoderContainer.decode(String?.self, forKey: .tagValue)
        }
    }
}
public extension Tag{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: TagCodingKeys.self)
         try encoderContainer.encode(tagKey, forKey: .tagKey)
         try encoderContainer.encode(tagValue, forKey: .tagValue)
    }
}
///  taskInfo
public class TaskInfo:NSObject,Codable{
    /// 探测异常数  ，null代表缺值。只统计探测失败，超时的个数。
    var abnormalCount:Int64?
    /// task的探测地址
    var address:String?
    /// 该task状态[true:被删除]
    var deleted:Bool?
    /// 任务状态[false：己禁用，true：己启用]
    var enabled:Bool?
    /// task名称
    var name:String?
    /// task的可用率
    var probeAvailability:Double?
    /// 该task的探测源个数
    var probeCount:Int64?
    /// task的探测类型，1：http，2：telnet
    var probeType:Int64?
    /// task的探测平均响应时间
    var responseTime:Double?
    /// task的id
    var taskId:String?



    public override init(){
            super.init()
    }

    enum TaskInfoCodingKeys: String, CodingKey {
        case abnormalCount
        case address
        case deleted
        case enabled
        case name
        case probeAvailability
        case probeCount
        case probeType
        case responseTime
        case taskId
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: TaskInfoCodingKeys.self)
        if decoderContainer.contains(.abnormalCount)
        {
            self.abnormalCount = try decoderContainer.decode(Int64?.self, forKey: .abnormalCount)
        }
        if decoderContainer.contains(.address)
        {
            self.address = try decoderContainer.decode(String?.self, forKey: .address)
        }
        if decoderContainer.contains(.deleted)
        {
            self.deleted = try decoderContainer.decode(Bool?.self, forKey: .deleted)
        }
        if decoderContainer.contains(.enabled)
        {
            self.enabled = try decoderContainer.decode(Bool?.self, forKey: .enabled)
        }
        if decoderContainer.contains(.name)
        {
            self.name = try decoderContainer.decode(String?.self, forKey: .name)
        }
        if decoderContainer.contains(.probeAvailability)
        {
            self.probeAvailability = try decoderContainer.decode(Double?.self, forKey: .probeAvailability)
        }
        if decoderContainer.contains(.probeCount)
        {
            self.probeCount = try decoderContainer.decode(Int64?.self, forKey: .probeCount)
        }
        if decoderContainer.contains(.probeType)
        {
            self.probeType = try decoderContainer.decode(Int64?.self, forKey: .probeType)
        }
        if decoderContainer.contains(.responseTime)
        {
            self.responseTime = try decoderContainer.decode(Double?.self, forKey: .responseTime)
        }
        if decoderContainer.contains(.taskId)
        {
            self.taskId = try decoderContainer.decode(String?.self, forKey: .taskId)
        }
    }
}
public extension TaskInfo{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: TaskInfoCodingKeys.self)
         try encoderContainer.encode(abnormalCount, forKey: .abnormalCount)
         try encoderContainer.encode(address, forKey: .address)
         try encoderContainer.encode(deleted, forKey: .deleted)
         try encoderContainer.encode(enabled, forKey: .enabled)
         try encoderContainer.encode(name, forKey: .name)
         try encoderContainer.encode(probeAvailability, forKey: .probeAvailability)
         try encoderContainer.encode(probeCount, forKey: .probeCount)
         try encoderContainer.encode(probeType, forKey: .probeType)
         try encoderContainer.encode(responseTime, forKey: .responseTime)
         try encoderContainer.encode(taskId, forKey: .taskId)
    }
}
///  metricData
public class MetricData:NSObject,Codable{
    /// Data
    var data:[DataPoint?]?
    /// Metric
    var metric:Metric?
    /// Tags
    var tags:[Tag?]?



    public override init(){
            super.init()
    }

    enum MetricDataCodingKeys: String, CodingKey {
        case data
        case metric
        case tags
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: MetricDataCodingKeys.self)
        if decoderContainer.contains(.data)
        {
            self.data = try decoderContainer.decode([DataPoint?]?.self, forKey: .data)
        }
        if decoderContainer.contains(.metric)
        {
            self.metric = try decoderContainer.decode(Metric?.self, forKey: .metric)
        }
        if decoderContainer.contains(.tags)
        {
            self.tags = try decoderContainer.decode([Tag?]?.self, forKey: .tags)
        }
    }
}
public extension MetricData{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: MetricDataCodingKeys.self)
         try encoderContainer.encode(data, forKey: .data)
         try encoderContainer.encode(metric, forKey: .metric)
         try encoderContainer.encode(tags, forKey: .tags)
    }
}
///  agentStatus
public class AgentStatus:NSObject,Codable{
    /// agent id
    var uuid:String?
    /// agent状态。1-正常 2-异常、
    var value:Int64?



    public override init(){
            super.init()
    }

    enum AgentStatusCodingKeys: String, CodingKey {
        case uuid
        case value
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: AgentStatusCodingKeys.self)
        if decoderContainer.contains(.uuid)
        {
            self.uuid = try decoderContainer.decode(String?.self, forKey: .uuid)
        }
        if decoderContainer.contains(.value)
        {
            self.value = try decoderContainer.decode(Int64?.self, forKey: .value)
        }
    }
}
public extension AgentStatus{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: AgentStatusCodingKeys.self)
         try encoderContainer.encode(uuid, forKey: .uuid)
         try encoderContainer.encode(value, forKey: .value)
    }
}
///  metric
public class Metric:NSObject,Codable{
    /// Aggregator
    var aggregator:String?
    /// CalculateUnit
    var calculateUnit:String?
    /// MetricValue
    var metricValue:String?
    /// MetricName
    var metricName:String?
    /// Period
    var period:String?



    public override init(){
            super.init()
    }

    enum MetricCodingKeys: String, CodingKey {
        case aggregator
        case calculateUnit
        case metricValue = "metric"
        case metricName
        case period
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: MetricCodingKeys.self)
        if decoderContainer.contains(.aggregator)
        {
            self.aggregator = try decoderContainer.decode(String?.self, forKey: .aggregator)
        }
        if decoderContainer.contains(.calculateUnit)
        {
            self.calculateUnit = try decoderContainer.decode(String?.self, forKey: .calculateUnit)
        }
        if decoderContainer.contains(.metricValue)
        {
            self.metricValue = try decoderContainer.decode(String?.self, forKey: .metricValue)
        }
        if decoderContainer.contains(.metricName)
        {
            self.metricName = try decoderContainer.decode(String?.self, forKey: .metricName)
        }
        if decoderContainer.contains(.period)
        {
            self.period = try decoderContainer.decode(String?.self, forKey: .period)
        }
    }
}
public extension Metric{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: MetricCodingKeys.self)
         try encoderContainer.encode(aggregator, forKey: .aggregator)
         try encoderContainer.encode(calculateUnit, forKey: .calculateUnit)
         try encoderContainer.encode(metricValue, forKey: .metricValue)
         try encoderContainer.encode(metricName, forKey: .metricName)
         try encoderContainer.encode(period, forKey: .period)
    }
}
///  probeInfo
public class ProbeInfo:NSObject,Codable{
    /// 探测源的所在主机名称
    var name:String?
    /// 探测源的内网ip
    var privateIp:String?
    /// 探测结果,缺点返回null,对应前端显示 &quot;--&quot; ,1:探测正常，2：探测失败，3：探测超时
    var probeResult:Int64?
    /// 插件状态，  1：正常，2：异常
    var probeStatus:Int64?
    /// 探测源的公网ip
    var publicIp:String?
    /// 探测目标状态，1：正常，2：异常(探测失败、探测超时)，缺点返回null,对应前端显示 &quot;--&quot;
    var targetStatus:Int64?
    /// 探测源主机的uuid
    var uuid:String?
    /// 云主机状态，对应云主机的状态,当找不到云主机，状态为&quot;unExist&quot;
    var vmStatus:String?



    public override init(){
            super.init()
    }

    enum ProbeInfoCodingKeys: String, CodingKey {
        case name
        case privateIp
        case probeResult
        case probeStatus
        case publicIp
        case targetStatus
        case uuid
        case vmStatus
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: ProbeInfoCodingKeys.self)
        if decoderContainer.contains(.name)
        {
            self.name = try decoderContainer.decode(String?.self, forKey: .name)
        }
        if decoderContainer.contains(.privateIp)
        {
            self.privateIp = try decoderContainer.decode(String?.self, forKey: .privateIp)
        }
        if decoderContainer.contains(.probeResult)
        {
            self.probeResult = try decoderContainer.decode(Int64?.self, forKey: .probeResult)
        }
        if decoderContainer.contains(.probeStatus)
        {
            self.probeStatus = try decoderContainer.decode(Int64?.self, forKey: .probeStatus)
        }
        if decoderContainer.contains(.publicIp)
        {
            self.publicIp = try decoderContainer.decode(String?.self, forKey: .publicIp)
        }
        if decoderContainer.contains(.targetStatus)
        {
            self.targetStatus = try decoderContainer.decode(Int64?.self, forKey: .targetStatus)
        }
        if decoderContainer.contains(.uuid)
        {
            self.uuid = try decoderContainer.decode(String?.self, forKey: .uuid)
        }
        if decoderContainer.contains(.vmStatus)
        {
            self.vmStatus = try decoderContainer.decode(String?.self, forKey: .vmStatus)
        }
    }
}
public extension ProbeInfo{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: ProbeInfoCodingKeys.self)
         try encoderContainer.encode(name, forKey: .name)
         try encoderContainer.encode(privateIp, forKey: .privateIp)
         try encoderContainer.encode(probeResult, forKey: .probeResult)
         try encoderContainer.encode(probeStatus, forKey: .probeStatus)
         try encoderContainer.encode(publicIp, forKey: .publicIp)
         try encoderContainer.encode(targetStatus, forKey: .targetStatus)
         try encoderContainer.encode(uuid, forKey: .uuid)
         try encoderContainer.encode(vmStatus, forKey: .vmStatus)
    }
}
///  event
public class Event:NSObject,Codable{
    /// 探测结果 1:探测成功  2：探测失败  3：探测超时
    var probeResult:Int64?
    /// 插件状态 1：正常  2：异常
    var probeStatus:Int64?
    /// 时间戳
    var timestamp:Int64?



    public override init(){
            super.init()
    }

    enum EventCodingKeys: String, CodingKey {
        case probeResult
        case probeStatus
        case timestamp
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: EventCodingKeys.self)
        if decoderContainer.contains(.probeResult)
        {
            self.probeResult = try decoderContainer.decode(Int64?.self, forKey: .probeResult)
        }
        if decoderContainer.contains(.probeStatus)
        {
            self.probeStatus = try decoderContainer.decode(Int64?.self, forKey: .probeStatus)
        }
        if decoderContainer.contains(.timestamp)
        {
            self.timestamp = try decoderContainer.decode(Int64?.self, forKey: .timestamp)
        }
    }
}
public extension Event{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: EventCodingKeys.self)
         try encoderContainer.encode(probeResult, forKey: .probeResult)
         try encoderContainer.encode(probeStatus, forKey: .probeStatus)
         try encoderContainer.encode(timestamp, forKey: .timestamp)
    }
}
///  updateWebHookOut
public class UpdateWebHookOut:NSObject,Codable{
    /// Success
    var success:Bool?



    public override init(){
            super.init()
    }

    enum UpdateWebHookOutCodingKeys: String, CodingKey {
        case success
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: UpdateWebHookOutCodingKeys.self)
        if decoderContainer.contains(.success)
        {
            self.success = try decoderContainer.decode(Bool?.self, forKey: .success)
        }
    }
}
public extension UpdateWebHookOut{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: UpdateWebHookOutCodingKeys.self)
         try encoderContainer.encode(success, forKey: .success)
    }
}
///  err
public class Err:NSObject,Codable{
    /// Code
    var code:Int64?
    /// Details
    var details:AnyObject?
    /// Message
    var message:String?
    /// Status
    var status:String?



    public override init(){
            super.init()
    }

    enum ErrCodingKeys: String, CodingKey {
        case code
        case details
        case message
        case status
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: ErrCodingKeys.self)
        if decoderContainer.contains(.code)
        {
            self.code = try decoderContainer.decode(Int64?.self, forKey: .code)
        }
        if decoderContainer.contains(.message)
        {
            self.message = try decoderContainer.decode(String?.self, forKey: .message)
        }
        if decoderContainer.contains(.status)
        {
            self.status = try decoderContainer.decode(String?.self, forKey: .status)
        }
    }
}
public extension Err{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: ErrCodingKeys.self)
         try encoderContainer.encode(code, forKey: .code)
         try encoderContainer.encode(message, forKey: .message)
         try encoderContainer.encode(status, forKey: .status)
    }
}

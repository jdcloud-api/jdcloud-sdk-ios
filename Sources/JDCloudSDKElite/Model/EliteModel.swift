/* Copyright 2018 JDCLOUD.COM

   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at

     http:#www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.

   jdx价格相关接口
   jdx价格相关接口

   OpenAPI spec version: v1
   Contact: 

   NOTE: This class is auto generated by the jdcloud code generator program.
 */


import Foundation
///  jdxProductVo
public class JdxProductVo:NSObject,Codable{
    /// 产品ID
    var productId:Int?
    /// 商品名称
    var productName:String?
    /// 商标图片地址
    var trademarkUrl:String?
    /// 所属一级分类名称
    var categoryLevel1Name:String?
    /// 所属二级分类名称
    var categoryLevel2Name:String?
    /// 交付形态
    var deliveryForm:Int?
    /// 交付形态名称
    var deliveryFormName:String?
    /// 商品简介
    var introduction:String?
    /// 商品定价模式 1:按套次、2:按周期、3:按套餐包
    var sellType:Int?
    /// 商品定价模式名称
    var sellTypeName:String?
    /// -1:不允许退款， 单位：天， 默认-1
    var refundDays:Int?
    /// pc端商品详情
    var pcProductDetail:String?
    /// m端商品详情
    var mProductDetail:String?
    /// sku详情信息
    var productSkuList:[JdxProductSkuVo?]?



    public override init(){
            super.init()
    }

    enum JdxProductVoCodingKeys: String, CodingKey {
        case productId
        case productName
        case trademarkUrl
        case categoryLevel1Name
        case categoryLevel2Name
        case deliveryForm
        case deliveryFormName
        case introduction
        case sellType
        case sellTypeName
        case refundDays
        case pcProductDetail
        case mProductDetail
        case productSkuList
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: JdxProductVoCodingKeys.self)
        if decoderContainer.contains(.productId)
        {
            self.productId = try decoderContainer.decode(Int?.self, forKey: .productId)
        }
        if decoderContainer.contains(.productName)
        {
            self.productName = try decoderContainer.decode(String?.self, forKey: .productName)
        }
        if decoderContainer.contains(.trademarkUrl)
        {
            self.trademarkUrl = try decoderContainer.decode(String?.self, forKey: .trademarkUrl)
        }
        if decoderContainer.contains(.categoryLevel1Name)
        {
            self.categoryLevel1Name = try decoderContainer.decode(String?.self, forKey: .categoryLevel1Name)
        }
        if decoderContainer.contains(.categoryLevel2Name)
        {
            self.categoryLevel2Name = try decoderContainer.decode(String?.self, forKey: .categoryLevel2Name)
        }
        if decoderContainer.contains(.deliveryForm)
        {
            self.deliveryForm = try decoderContainer.decode(Int?.self, forKey: .deliveryForm)
        }
        if decoderContainer.contains(.deliveryFormName)
        {
            self.deliveryFormName = try decoderContainer.decode(String?.self, forKey: .deliveryFormName)
        }
        if decoderContainer.contains(.introduction)
        {
            self.introduction = try decoderContainer.decode(String?.self, forKey: .introduction)
        }
        if decoderContainer.contains(.sellType)
        {
            self.sellType = try decoderContainer.decode(Int?.self, forKey: .sellType)
        }
        if decoderContainer.contains(.sellTypeName)
        {
            self.sellTypeName = try decoderContainer.decode(String?.self, forKey: .sellTypeName)
        }
        if decoderContainer.contains(.refundDays)
        {
            self.refundDays = try decoderContainer.decode(Int?.self, forKey: .refundDays)
        }
        if decoderContainer.contains(.pcProductDetail)
        {
            self.pcProductDetail = try decoderContainer.decode(String?.self, forKey: .pcProductDetail)
        }
        if decoderContainer.contains(.mProductDetail)
        {
            self.mProductDetail = try decoderContainer.decode(String?.self, forKey: .mProductDetail)
        }
        if decoderContainer.contains(.productSkuList)
        {
            self.productSkuList = try decoderContainer.decode([JdxProductSkuVo?]?.self, forKey: .productSkuList)
        }
    }
}
public extension JdxProductVo{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: JdxProductVoCodingKeys.self)
         try encoderContainer.encode(productId, forKey: .productId)
         try encoderContainer.encode(productName, forKey: .productName)
         try encoderContainer.encode(trademarkUrl, forKey: .trademarkUrl)
         try encoderContainer.encode(categoryLevel1Name, forKey: .categoryLevel1Name)
         try encoderContainer.encode(categoryLevel2Name, forKey: .categoryLevel2Name)
         try encoderContainer.encode(deliveryForm, forKey: .deliveryForm)
         try encoderContainer.encode(deliveryFormName, forKey: .deliveryFormName)
         try encoderContainer.encode(introduction, forKey: .introduction)
         try encoderContainer.encode(sellType, forKey: .sellType)
         try encoderContainer.encode(sellTypeName, forKey: .sellTypeName)
         try encoderContainer.encode(refundDays, forKey: .refundDays)
         try encoderContainer.encode(pcProductDetail, forKey: .pcProductDetail)
         try encoderContainer.encode(mProductDetail, forKey: .mProductDetail)
         try encoderContainer.encode(productSkuList, forKey: .productSkuList)
    }
}
///  jdxSkuExtraChargeVo
public class JdxSkuExtraChargeVo:NSObject,Codable{
    /// 额外计费项名称
    var extraChargeName:String?
    /// 额外计费项单位
    var extraChargeUnit:String?
    /// 售价
    var sellingPrice:Double?
    /// 1、范围 2、枚举
    var numType:Int?
    /// 1,100逗号分隔,numType&#x3D;1表示可购买数量的范围,numType&#x3D;2表示只支持购买特定数量
    var num:String?



    public override init(){
            super.init()
    }

    enum JdxSkuExtraChargeVoCodingKeys: String, CodingKey {
        case extraChargeName
        case extraChargeUnit
        case sellingPrice
        case numType
        case num
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: JdxSkuExtraChargeVoCodingKeys.self)
        if decoderContainer.contains(.extraChargeName)
        {
            self.extraChargeName = try decoderContainer.decode(String?.self, forKey: .extraChargeName)
        }
        if decoderContainer.contains(.extraChargeUnit)
        {
            self.extraChargeUnit = try decoderContainer.decode(String?.self, forKey: .extraChargeUnit)
        }
        if decoderContainer.contains(.sellingPrice)
        {
            self.sellingPrice = try decoderContainer.decode(Double?.self, forKey: .sellingPrice)
        }
        if decoderContainer.contains(.numType)
        {
            self.numType = try decoderContainer.decode(Int?.self, forKey: .numType)
        }
        if decoderContainer.contains(.num)
        {
            self.num = try decoderContainer.decode(String?.self, forKey: .num)
        }
    }
}
public extension JdxSkuExtraChargeVo{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: JdxSkuExtraChargeVoCodingKeys.self)
         try encoderContainer.encode(extraChargeName, forKey: .extraChargeName)
         try encoderContainer.encode(extraChargeUnit, forKey: .extraChargeUnit)
         try encoderContainer.encode(sellingPrice, forKey: .sellingPrice)
         try encoderContainer.encode(numType, forKey: .numType)
         try encoderContainer.encode(num, forKey: .num)
    }
}
///  jdxProductVoListData
public class JdxProductVoListData:NSObject,Codable{
    /// 页码
    var pageNo:Int?
    /// 每页记录数
    var pageSize:Int?
    /// 总记录数
    var totalRecord:Int?
    /// 总页数
    var totalPage:Int?
    /// 商品信息列表
    var dataList:[JdxProductVo?]?



    public override init(){
            super.init()
    }

    enum JdxProductVoListDataCodingKeys: String, CodingKey {
        case pageNo
        case pageSize
        case totalRecord
        case totalPage
        case dataList
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: JdxProductVoListDataCodingKeys.self)
        if decoderContainer.contains(.pageNo)
        {
            self.pageNo = try decoderContainer.decode(Int?.self, forKey: .pageNo)
        }
        if decoderContainer.contains(.pageSize)
        {
            self.pageSize = try decoderContainer.decode(Int?.self, forKey: .pageSize)
        }
        if decoderContainer.contains(.totalRecord)
        {
            self.totalRecord = try decoderContainer.decode(Int?.self, forKey: .totalRecord)
        }
        if decoderContainer.contains(.totalPage)
        {
            self.totalPage = try decoderContainer.decode(Int?.self, forKey: .totalPage)
        }
        if decoderContainer.contains(.dataList)
        {
            self.dataList = try decoderContainer.decode([JdxProductVo?]?.self, forKey: .dataList)
        }
    }
}
public extension JdxProductVoListData{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: JdxProductVoListDataCodingKeys.self)
         try encoderContainer.encode(pageNo, forKey: .pageNo)
         try encoderContainer.encode(pageSize, forKey: .pageSize)
         try encoderContainer.encode(totalRecord, forKey: .totalRecord)
         try encoderContainer.encode(totalPage, forKey: .totalPage)
         try encoderContainer.encode(dataList, forKey: .dataList)
    }
}
///  jdxProductSkuVo
public class JdxProductSkuVo:NSObject,Codable{
    /// sku ID
    var skuId:Int?
    /// sku名称
    var skuName:String?
    /// 销售属性json字符串,version表示版本(套次、周期、套餐包类商品均有该属性),validity表示周期(周期和套餐包类商品有该属性),packageNum表示条数(只有套餐包类商品有该属性)：例如[{&quot;attrCode&quot;:&quot;version&quot;,&quot;attrValue&quot;:&quot;升级版&quot;},{&quot;attrCode&quot;:&quot;validity&quot;,&quot;attrValue&quot;:365},{&quot;attrCode&quot;:&quot;packageNum&quot;,&quot;attrValue&quot;:1000}]
    var saleAttributes:String?
    /// 最大购买数量
    var maxBuyNum:Int?
    /// 最小购买数量
    var minBuyNum:Int?
    /// sku 售价
    var skuSellingPrice:Double?
    /// 额外计费项信息
    var skuExtraChargeList:[JdxSkuExtraChargeVo?]?



    public override init(){
            super.init()
    }

    enum JdxProductSkuVoCodingKeys: String, CodingKey {
        case skuId
        case skuName
        case saleAttributes
        case maxBuyNum
        case minBuyNum
        case skuSellingPrice
        case skuExtraChargeList
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: JdxProductSkuVoCodingKeys.self)
        if decoderContainer.contains(.skuId)
        {
            self.skuId = try decoderContainer.decode(Int?.self, forKey: .skuId)
        }
        if decoderContainer.contains(.skuName)
        {
            self.skuName = try decoderContainer.decode(String?.self, forKey: .skuName)
        }
        if decoderContainer.contains(.saleAttributes)
        {
            self.saleAttributes = try decoderContainer.decode(String?.self, forKey: .saleAttributes)
        }
        if decoderContainer.contains(.maxBuyNum)
        {
            self.maxBuyNum = try decoderContainer.decode(Int?.self, forKey: .maxBuyNum)
        }
        if decoderContainer.contains(.minBuyNum)
        {
            self.minBuyNum = try decoderContainer.decode(Int?.self, forKey: .minBuyNum)
        }
        if decoderContainer.contains(.skuSellingPrice)
        {
            self.skuSellingPrice = try decoderContainer.decode(Double?.self, forKey: .skuSellingPrice)
        }
        if decoderContainer.contains(.skuExtraChargeList)
        {
            self.skuExtraChargeList = try decoderContainer.decode([JdxSkuExtraChargeVo?]?.self, forKey: .skuExtraChargeList)
        }
    }
}
public extension JdxProductSkuVo{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: JdxProductSkuVoCodingKeys.self)
         try encoderContainer.encode(skuId, forKey: .skuId)
         try encoderContainer.encode(skuName, forKey: .skuName)
         try encoderContainer.encode(saleAttributes, forKey: .saleAttributes)
         try encoderContainer.encode(maxBuyNum, forKey: .maxBuyNum)
         try encoderContainer.encode(minBuyNum, forKey: .minBuyNum)
         try encoderContainer.encode(skuSellingPrice, forKey: .skuSellingPrice)
         try encoderContainer.encode(skuExtraChargeList, forKey: .skuExtraChargeList)
    }
}
///  productServiceVo
public class ProductServiceVo:NSObject,Codable{
    /// 交付单号
    var deliverNumber:String?
    /// 订单号
    var orderNumber:String?
    /// 续费订单所关联的新购订单号，该字段只针对续费单有效，新购单该字段为null
    var refOrderNumber:String?
    /// 订单类型
    var orderType:Int?
    /// 订单类型名称
    var orderTypeName:String?
    /// 购买人
    var buyerPin:String?
    /// 映射编号
    var mappingCode:String?
    /// 是否支持自动交付：0表示不支持，1表示支持
    var supportAutoDeliver:Int?
    /// 产品ID
    var productId:Int?
    /// sku ID
    var skuId:Int?
    /// sku名称
    var skuName:String?
    /// 服务code
    var serviceCode:String?
    /// 数量
    var num:Int?
    /// 周期
    var period:Int?
    /// 周期类型
    var periodType:Int?
    /// 周期类型名称
    var periodTypeName:String?
    /// 账号数量
    var accountNum:Int?
    /// 交付状态
    var deliverStatus:Int?
    /// 交付状态名称
    var deliverStatusName:String?
    /// 服务生效时间，格式：yyyy-MM-dd HH:mm:ss
    var effectiveDt:String?
    /// 服务过期时间，格式：yyyy-MM-dd HH:mm:ss
    var failureDt:String?
    /// 商品属性
    var extraInfo:String?
    /// 交付单备注
    var remark:String?
    /// 订单金额
    var orderTotalFee:String?
    /// 订单实付金额
    var orderActualFee:String?
    /// 订单支付时间
    var paymentDt:String?
    /// 额外计费项信息
    var extraChargeInfo:String?
    /// 额外计费详情信息
    var orderItemExtraChargeInfos:[OrderItemExtraChargeInfo?]?



    public override init(){
            super.init()
    }

    enum ProductServiceVoCodingKeys: String, CodingKey {
        case deliverNumber
        case orderNumber
        case refOrderNumber
        case orderType
        case orderTypeName
        case buyerPin
        case mappingCode
        case supportAutoDeliver
        case productId
        case skuId
        case skuName
        case serviceCode
        case num
        case period
        case periodType
        case periodTypeName
        case accountNum
        case deliverStatus
        case deliverStatusName
        case effectiveDt
        case failureDt
        case extraInfo
        case remark
        case orderTotalFee
        case orderActualFee
        case paymentDt
        case extraChargeInfo
        case orderItemExtraChargeInfos
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: ProductServiceVoCodingKeys.self)
        if decoderContainer.contains(.deliverNumber)
        {
            self.deliverNumber = try decoderContainer.decode(String?.self, forKey: .deliverNumber)
        }
        if decoderContainer.contains(.orderNumber)
        {
            self.orderNumber = try decoderContainer.decode(String?.self, forKey: .orderNumber)
        }
        if decoderContainer.contains(.refOrderNumber)
        {
            self.refOrderNumber = try decoderContainer.decode(String?.self, forKey: .refOrderNumber)
        }
        if decoderContainer.contains(.orderType)
        {
            self.orderType = try decoderContainer.decode(Int?.self, forKey: .orderType)
        }
        if decoderContainer.contains(.orderTypeName)
        {
            self.orderTypeName = try decoderContainer.decode(String?.self, forKey: .orderTypeName)
        }
        if decoderContainer.contains(.buyerPin)
        {
            self.buyerPin = try decoderContainer.decode(String?.self, forKey: .buyerPin)
        }
        if decoderContainer.contains(.mappingCode)
        {
            self.mappingCode = try decoderContainer.decode(String?.self, forKey: .mappingCode)
        }
        if decoderContainer.contains(.supportAutoDeliver)
        {
            self.supportAutoDeliver = try decoderContainer.decode(Int?.self, forKey: .supportAutoDeliver)
        }
        if decoderContainer.contains(.productId)
        {
            self.productId = try decoderContainer.decode(Int?.self, forKey: .productId)
        }
        if decoderContainer.contains(.skuId)
        {
            self.skuId = try decoderContainer.decode(Int?.self, forKey: .skuId)
        }
        if decoderContainer.contains(.skuName)
        {
            self.skuName = try decoderContainer.decode(String?.self, forKey: .skuName)
        }
        if decoderContainer.contains(.serviceCode)
        {
            self.serviceCode = try decoderContainer.decode(String?.self, forKey: .serviceCode)
        }
        if decoderContainer.contains(.num)
        {
            self.num = try decoderContainer.decode(Int?.self, forKey: .num)
        }
        if decoderContainer.contains(.period)
        {
            self.period = try decoderContainer.decode(Int?.self, forKey: .period)
        }
        if decoderContainer.contains(.periodType)
        {
            self.periodType = try decoderContainer.decode(Int?.self, forKey: .periodType)
        }
        if decoderContainer.contains(.periodTypeName)
        {
            self.periodTypeName = try decoderContainer.decode(String?.self, forKey: .periodTypeName)
        }
        if decoderContainer.contains(.accountNum)
        {
            self.accountNum = try decoderContainer.decode(Int?.self, forKey: .accountNum)
        }
        if decoderContainer.contains(.deliverStatus)
        {
            self.deliverStatus = try decoderContainer.decode(Int?.self, forKey: .deliverStatus)
        }
        if decoderContainer.contains(.deliverStatusName)
        {
            self.deliverStatusName = try decoderContainer.decode(String?.self, forKey: .deliverStatusName)
        }
        if decoderContainer.contains(.effectiveDt)
        {
            self.effectiveDt = try decoderContainer.decode(String?.self, forKey: .effectiveDt)
        }
        if decoderContainer.contains(.failureDt)
        {
            self.failureDt = try decoderContainer.decode(String?.self, forKey: .failureDt)
        }
        if decoderContainer.contains(.extraInfo)
        {
            self.extraInfo = try decoderContainer.decode(String?.self, forKey: .extraInfo)
        }
        if decoderContainer.contains(.remark)
        {
            self.remark = try decoderContainer.decode(String?.self, forKey: .remark)
        }
        if decoderContainer.contains(.orderTotalFee)
        {
            self.orderTotalFee = try decoderContainer.decode(String?.self, forKey: .orderTotalFee)
        }
        if decoderContainer.contains(.orderActualFee)
        {
            self.orderActualFee = try decoderContainer.decode(String?.self, forKey: .orderActualFee)
        }
        if decoderContainer.contains(.paymentDt)
        {
            self.paymentDt = try decoderContainer.decode(String?.self, forKey: .paymentDt)
        }
        if decoderContainer.contains(.extraChargeInfo)
        {
            self.extraChargeInfo = try decoderContainer.decode(String?.self, forKey: .extraChargeInfo)
        }
        if decoderContainer.contains(.orderItemExtraChargeInfos)
        {
            self.orderItemExtraChargeInfos = try decoderContainer.decode([OrderItemExtraChargeInfo?]?.self, forKey: .orderItemExtraChargeInfos)
        }
    }
}
public extension ProductServiceVo{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: ProductServiceVoCodingKeys.self)
         try encoderContainer.encode(deliverNumber, forKey: .deliverNumber)
         try encoderContainer.encode(orderNumber, forKey: .orderNumber)
         try encoderContainer.encode(refOrderNumber, forKey: .refOrderNumber)
         try encoderContainer.encode(orderType, forKey: .orderType)
         try encoderContainer.encode(orderTypeName, forKey: .orderTypeName)
         try encoderContainer.encode(buyerPin, forKey: .buyerPin)
         try encoderContainer.encode(mappingCode, forKey: .mappingCode)
         try encoderContainer.encode(supportAutoDeliver, forKey: .supportAutoDeliver)
         try encoderContainer.encode(productId, forKey: .productId)
         try encoderContainer.encode(skuId, forKey: .skuId)
         try encoderContainer.encode(skuName, forKey: .skuName)
         try encoderContainer.encode(serviceCode, forKey: .serviceCode)
         try encoderContainer.encode(num, forKey: .num)
         try encoderContainer.encode(period, forKey: .period)
         try encoderContainer.encode(periodType, forKey: .periodType)
         try encoderContainer.encode(periodTypeName, forKey: .periodTypeName)
         try encoderContainer.encode(accountNum, forKey: .accountNum)
         try encoderContainer.encode(deliverStatus, forKey: .deliverStatus)
         try encoderContainer.encode(deliverStatusName, forKey: .deliverStatusName)
         try encoderContainer.encode(effectiveDt, forKey: .effectiveDt)
         try encoderContainer.encode(failureDt, forKey: .failureDt)
         try encoderContainer.encode(extraInfo, forKey: .extraInfo)
         try encoderContainer.encode(remark, forKey: .remark)
         try encoderContainer.encode(orderTotalFee, forKey: .orderTotalFee)
         try encoderContainer.encode(orderActualFee, forKey: .orderActualFee)
         try encoderContainer.encode(paymentDt, forKey: .paymentDt)
         try encoderContainer.encode(extraChargeInfo, forKey: .extraChargeInfo)
         try encoderContainer.encode(orderItemExtraChargeInfos, forKey: .orderItemExtraChargeInfos)
    }
}
///  productServiceVoListData
public class ProductServiceVoListData:NSObject,Codable{
    /// 页码
    var pageNo:Int?
    /// 每页记录数
    var pageSize:Int?
    /// 总记录数
    var totalRecord:Int?
    /// 总页数
    var totalPage:Int?
    /// 交付单信息列表
    var dataList:[ProductServiceVo?]?



    public override init(){
            super.init()
    }

    enum ProductServiceVoListDataCodingKeys: String, CodingKey {
        case pageNo
        case pageSize
        case totalRecord
        case totalPage
        case dataList
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: ProductServiceVoListDataCodingKeys.self)
        if decoderContainer.contains(.pageNo)
        {
            self.pageNo = try decoderContainer.decode(Int?.self, forKey: .pageNo)
        }
        if decoderContainer.contains(.pageSize)
        {
            self.pageSize = try decoderContainer.decode(Int?.self, forKey: .pageSize)
        }
        if decoderContainer.contains(.totalRecord)
        {
            self.totalRecord = try decoderContainer.decode(Int?.self, forKey: .totalRecord)
        }
        if decoderContainer.contains(.totalPage)
        {
            self.totalPage = try decoderContainer.decode(Int?.self, forKey: .totalPage)
        }
        if decoderContainer.contains(.dataList)
        {
            self.dataList = try decoderContainer.decode([ProductServiceVo?]?.self, forKey: .dataList)
        }
    }
}
public extension ProductServiceVoListData{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: ProductServiceVoListDataCodingKeys.self)
         try encoderContainer.encode(pageNo, forKey: .pageNo)
         try encoderContainer.encode(pageSize, forKey: .pageSize)
         try encoderContainer.encode(totalRecord, forKey: .totalRecord)
         try encoderContainer.encode(totalPage, forKey: .totalPage)
         try encoderContainer.encode(dataList, forKey: .dataList)
    }
}
///  confirmDeliveryInfo
public class ConfirmDeliveryInfo:NSObject,Codable{
    /// 交付单号
    var deliverNumber:String?
    /// 交付单备注，填写交付时的信息，比如网址，账号等
    var remark:String?



    public override init(){
            super.init()
    }

    enum ConfirmDeliveryInfoCodingKeys: String, CodingKey {
        case deliverNumber
        case remark
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: ConfirmDeliveryInfoCodingKeys.self)
        if decoderContainer.contains(.deliverNumber)
        {
            self.deliverNumber = try decoderContainer.decode(String?.self, forKey: .deliverNumber)
        }
        if decoderContainer.contains(.remark)
        {
            self.remark = try decoderContainer.decode(String?.self, forKey: .remark)
        }
    }
}
public extension ConfirmDeliveryInfo{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: ConfirmDeliveryInfoCodingKeys.self)
         try encoderContainer.encode(deliverNumber, forKey: .deliverNumber)
         try encoderContainer.encode(remark, forKey: .remark)
    }
}
///  orderItemExtraChargeInfo
public class OrderItemExtraChargeInfo:NSObject,Codable{
    /// 购买用户pin
    var name:String?
    /// 单位
    var unit:String?
    /// 购买数量
    var buyNum:Int?
    /// 销售价格
    var sellingPrice:String?
    /// 结算价格
    var settlementPrice:String?



    public override init(){
            super.init()
    }

    enum OrderItemExtraChargeInfoCodingKeys: String, CodingKey {
        case name
        case unit
        case buyNum
        case sellingPrice
        case settlementPrice
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: OrderItemExtraChargeInfoCodingKeys.self)
        if decoderContainer.contains(.name)
        {
            self.name = try decoderContainer.decode(String?.self, forKey: .name)
        }
        if decoderContainer.contains(.unit)
        {
            self.unit = try decoderContainer.decode(String?.self, forKey: .unit)
        }
        if decoderContainer.contains(.buyNum)
        {
            self.buyNum = try decoderContainer.decode(Int?.self, forKey: .buyNum)
        }
        if decoderContainer.contains(.sellingPrice)
        {
            self.sellingPrice = try decoderContainer.decode(String?.self, forKey: .sellingPrice)
        }
        if decoderContainer.contains(.settlementPrice)
        {
            self.settlementPrice = try decoderContainer.decode(String?.self, forKey: .settlementPrice)
        }
    }
}
public extension OrderItemExtraChargeInfo{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: OrderItemExtraChargeInfoCodingKeys.self)
         try encoderContainer.encode(name, forKey: .name)
         try encoderContainer.encode(unit, forKey: .unit)
         try encoderContainer.encode(buyNum, forKey: .buyNum)
         try encoderContainer.encode(sellingPrice, forKey: .sellingPrice)
         try encoderContainer.encode(settlementPrice, forKey: .settlementPrice)
    }
}
///  queryDeliveryInfoResultVo
public class QueryDeliveryInfoResultVo:NSObject,Codable{
    /// 交付信息
    var remark:String?
    /// 生效时间，格式：yyyy-MM-dd HH:mm:ss
    var effectiveDt:String?
    /// 失效时间，格式：yyyy-MM-dd HH:mm:ss
    var failureDt:String?



    public override init(){
            super.init()
    }

    enum QueryDeliveryInfoResultVoCodingKeys: String, CodingKey {
        case remark
        case effectiveDt
        case failureDt
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: QueryDeliveryInfoResultVoCodingKeys.self)
        if decoderContainer.contains(.remark)
        {
            self.remark = try decoderContainer.decode(String?.self, forKey: .remark)
        }
        if decoderContainer.contains(.effectiveDt)
        {
            self.effectiveDt = try decoderContainer.decode(String?.self, forKey: .effectiveDt)
        }
        if decoderContainer.contains(.failureDt)
        {
            self.failureDt = try decoderContainer.decode(String?.self, forKey: .failureDt)
        }
    }
}
public extension QueryDeliveryInfoResultVo{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: QueryDeliveryInfoResultVoCodingKeys.self)
         try encoderContainer.encode(remark, forKey: .remark)
         try encoderContainer.encode(effectiveDt, forKey: .effectiveDt)
         try encoderContainer.encode(failureDt, forKey: .failureDt)
    }
}
///  storeServiceVo
public class StoreServiceVo:NSObject,Codable{
    /// 购买用户pin
    var buyerPin:String?
    /// 业务数据，下单时传入的
    var businessData:String?
    /// 云存服务明细列表
    var storeServiceDetails:[StoreServiceDetailVo?]?
    /// 订单数量
    var orderNum:Int?
    /// 更新时间，格式：yyyy-MM-dd HH:mm:ss
    var updateTime:String?



    public override init(){
            super.init()
    }

    enum StoreServiceVoCodingKeys: String, CodingKey {
        case buyerPin
        case businessData
        case storeServiceDetails
        case orderNum
        case updateTime
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: StoreServiceVoCodingKeys.self)
        if decoderContainer.contains(.buyerPin)
        {
            self.buyerPin = try decoderContainer.decode(String?.self, forKey: .buyerPin)
        }
        if decoderContainer.contains(.businessData)
        {
            self.businessData = try decoderContainer.decode(String?.self, forKey: .businessData)
        }
        if decoderContainer.contains(.storeServiceDetails)
        {
            self.storeServiceDetails = try decoderContainer.decode([StoreServiceDetailVo?]?.self, forKey: .storeServiceDetails)
        }
        if decoderContainer.contains(.orderNum)
        {
            self.orderNum = try decoderContainer.decode(Int?.self, forKey: .orderNum)
        }
        if decoderContainer.contains(.updateTime)
        {
            self.updateTime = try decoderContainer.decode(String?.self, forKey: .updateTime)
        }
    }
}
public extension StoreServiceVo{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: StoreServiceVoCodingKeys.self)
         try encoderContainer.encode(buyerPin, forKey: .buyerPin)
         try encoderContainer.encode(businessData, forKey: .businessData)
         try encoderContainer.encode(storeServiceDetails, forKey: .storeServiceDetails)
         try encoderContainer.encode(orderNum, forKey: .orderNum)
         try encoderContainer.encode(updateTime, forKey: .updateTime)
    }
}
///  storeServiceDetailVo
public class StoreServiceDetailVo:NSObject,Codable{
    /// 商品spu对应的id
    var spuId:Int?
    /// 商品sku对应的id
    var skuId:Int?
    /// 滚存天数
    var storeDays:Int?
    /// 开始时间，格式：yyyy-MM-dd HH:mm:ss
    var startTime:String?
    /// 结束时间，格式：yyyy-MM-dd HH:mm:ss
    var endTime:String?



    public override init(){
            super.init()
    }

    enum StoreServiceDetailVoCodingKeys: String, CodingKey {
        case spuId
        case skuId
        case storeDays
        case startTime
        case endTime
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: StoreServiceDetailVoCodingKeys.self)
        if decoderContainer.contains(.spuId)
        {
            self.spuId = try decoderContainer.decode(Int?.self, forKey: .spuId)
        }
        if decoderContainer.contains(.skuId)
        {
            self.skuId = try decoderContainer.decode(Int?.self, forKey: .skuId)
        }
        if decoderContainer.contains(.storeDays)
        {
            self.storeDays = try decoderContainer.decode(Int?.self, forKey: .storeDays)
        }
        if decoderContainer.contains(.startTime)
        {
            self.startTime = try decoderContainer.decode(String?.self, forKey: .startTime)
        }
        if decoderContainer.contains(.endTime)
        {
            self.endTime = try decoderContainer.decode(String?.self, forKey: .endTime)
        }
    }
}
public extension StoreServiceDetailVo{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: StoreServiceDetailVoCodingKeys.self)
         try encoderContainer.encode(spuId, forKey: .spuId)
         try encoderContainer.encode(skuId, forKey: .skuId)
         try encoderContainer.encode(storeDays, forKey: .storeDays)
         try encoderContainer.encode(startTime, forKey: .startTime)
         try encoderContainer.encode(endTime, forKey: .endTime)
    }
}
///  createOrderResultVo
public class CreateOrderResultVo:NSObject,Codable{
    /// 订单号
    var orderNumber:String?



    public override init(){
            super.init()
    }

    enum CreateOrderResultVoCodingKeys: String, CodingKey {
        case orderNumber
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: CreateOrderResultVoCodingKeys.self)
        if decoderContainer.contains(.orderNumber)
        {
            self.orderNumber = try decoderContainer.decode(String?.self, forKey: .orderNumber)
        }
    }
}
public extension CreateOrderResultVo{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: CreateOrderResultVoCodingKeys.self)
         try encoderContainer.encode(orderNumber, forKey: .orderNumber)
    }
}
///  createOrderInfo
public class CreateOrderInfo:NSObject,Codable{
    /// spu ID
    /// Required:true
    var productId:Int
    /// sku ID
    /// Required:true
    var skuId:Int
    /// 购买数量
    /// Required:true
    var buyNum:Int
    /// 备注
    var remark:String?
    /// 额外计费项信息
    var cartExtraChargeVos:[CartExtraChargeVo?]?



    public  init(productId:Int,skuId:Int,buyNum:Int){
             self.productId = productId
             self.skuId = skuId
             self.buyNum = buyNum
    }

    enum CreateOrderInfoCodingKeys: String, CodingKey {
        case productId
        case skuId
        case buyNum
        case remark
        case cartExtraChargeVos
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: CreateOrderInfoCodingKeys.self)
        self.productId = try decoderContainer.decode(Int.self, forKey: .productId)
        self.skuId = try decoderContainer.decode(Int.self, forKey: .skuId)
        self.buyNum = try decoderContainer.decode(Int.self, forKey: .buyNum)
        if decoderContainer.contains(.remark)
        {
            self.remark = try decoderContainer.decode(String?.self, forKey: .remark)
        }
        if decoderContainer.contains(.cartExtraChargeVos)
        {
            self.cartExtraChargeVos = try decoderContainer.decode([CartExtraChargeVo?]?.self, forKey: .cartExtraChargeVos)
        }
    }
}
public extension CreateOrderInfo{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: CreateOrderInfoCodingKeys.self)
         try encoderContainer.encode(productId, forKey: .productId)
         try encoderContainer.encode(skuId, forKey: .skuId)
         try encoderContainer.encode(buyNum, forKey: .buyNum)
         try encoderContainer.encode(remark, forKey: .remark)
         try encoderContainer.encode(cartExtraChargeVos, forKey: .cartExtraChargeVos)
    }
}
///  reportOrderInfo
public class ReportOrderInfo:NSObject,Codable{
    /// 订单号
    /// Required:true
    var orderNumber:String
    /// 经销商账号
    var distributorAccount:String?
    /// 经销商名称
    var distributorName:String?
    /// 补充信息，填写当前订单的一些描述信息
    var extraInfo:String?



    public  init(orderNumber:String){
             self.orderNumber = orderNumber
    }

    enum ReportOrderInfoCodingKeys: String, CodingKey {
        case orderNumber
        case distributorAccount
        case distributorName
        case extraInfo
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: ReportOrderInfoCodingKeys.self)
        self.orderNumber = try decoderContainer.decode(String.self, forKey: .orderNumber)
        if decoderContainer.contains(.distributorAccount)
        {
            self.distributorAccount = try decoderContainer.decode(String?.self, forKey: .distributorAccount)
        }
        if decoderContainer.contains(.distributorName)
        {
            self.distributorName = try decoderContainer.decode(String?.self, forKey: .distributorName)
        }
        if decoderContainer.contains(.extraInfo)
        {
            self.extraInfo = try decoderContainer.decode(String?.self, forKey: .extraInfo)
        }
    }
}
public extension ReportOrderInfo{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: ReportOrderInfoCodingKeys.self)
         try encoderContainer.encode(orderNumber, forKey: .orderNumber)
         try encoderContainer.encode(distributorAccount, forKey: .distributorAccount)
         try encoderContainer.encode(distributorName, forKey: .distributorName)
         try encoderContainer.encode(extraInfo, forKey: .extraInfo)
    }
}
///  cartExtraChargeVo
public class CartExtraChargeVo:NSObject,Codable{
    /// 额外计费项名称
    var name:String?
    /// 购买数量
    var buyNum:Int?



    public override init(){
            super.init()
    }

    enum CartExtraChargeVoCodingKeys: String, CodingKey {
        case name
        case buyNum
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: CartExtraChargeVoCodingKeys.self)
        if decoderContainer.contains(.name)
        {
            self.name = try decoderContainer.decode(String?.self, forKey: .name)
        }
        if decoderContainer.contains(.buyNum)
        {
            self.buyNum = try decoderContainer.decode(Int?.self, forKey: .buyNum)
        }
    }
}
public extension CartExtraChargeVo{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: CartExtraChargeVoCodingKeys.self)
         try encoderContainer.encode(name, forKey: .name)
         try encoderContainer.encode(buyNum, forKey: .buyNum)
    }
}
///  queryPriceParam
public class QueryPriceParam:NSObject,Codable{
    /// 操作类型 1:创建 2:续费 3:升降配
    /// Required:true
    var cmd:Int
    /// 打包购买包数
    /// Required:true
    var packageCount:Int
    /// OrderList
    /// Required:true
    var orderList:[OrderPriceProtocolVo?]?



    public  init(cmd:Int,packageCount:Int,orderList:[OrderPriceProtocolVo?]?){
             self.cmd = cmd
             self.packageCount = packageCount
             self.orderList = orderList
    }

    enum QueryPriceParamCodingKeys: String, CodingKey {
        case cmd
        case packageCount
        case orderList
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: QueryPriceParamCodingKeys.self)
        self.cmd = try decoderContainer.decode(Int.self, forKey: .cmd)
        self.packageCount = try decoderContainer.decode(Int.self, forKey: .packageCount)
        self.orderList = try decoderContainer.decode([OrderPriceProtocolVo?]?.self, forKey: .orderList)
    }
}
public extension QueryPriceParam{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: QueryPriceParamCodingKeys.self)
         try encoderContainer.encode(cmd, forKey: .cmd)
         try encoderContainer.encode(packageCount, forKey: .packageCount)
         try encoderContainer.encode(orderList, forKey: .orderList)
    }
}
///  orderPriceProtocolVo
public class OrderPriceProtocolVo:NSObject,Codable{
    /// 资源id，续费和升降配时必传，其他非必传
    var resourceId:String?
    /// 资源的类型，取值vm,disk,ip等，具体取值请在对接时联系我们
    /// Required:true
    var serviceCode:String
    /// 资源所在区域，取值cn-north-1,cn-east-1,cn-east-2,cn-south-1
    /// Required:true
    var region:String
    /// 计费类型，1:按配置 2:按用量 3:包年包月
    /// Required:true
    var billingType:Int
    /// 资源配置项列表
    var formula:[OrderResourceFormulaVo?]?
    /// 资源数量
    /// Required:true
    var count:Int
    /// 资源使用时长
    /// Required:true
    var timeSpan:Int
    /// 资源使用时长类型，1:小时 2:天 3:月 4:年
    /// Required:true
    var timeUnit:Int
    /// 资源网络类型，0:无 1:non-BGP 2:BGP，当资源类型是ip时，则需要填写1或者2，其他资源类型填写0
    /// Required:true
    var networkOperator:Int
    /// 用户pin，如有优惠用户，则填写优惠用户的pin，否则不用填写
    var pin:String?
    /// 开始时间，格式：yyyy-MM-dd HH:mm:ss
    /// Required:true
    var startTime:String
    /// 结束时间，格式：yyyy-MM-dd HH:mm:ss
    var endTime:String?



    public  init(serviceCode:String,region:String,billingType:Int,count:Int,timeSpan:Int,timeUnit:Int,networkOperator:Int,startTime:String){
             self.serviceCode = serviceCode
             self.region = region
             self.billingType = billingType
             self.count = count
             self.timeSpan = timeSpan
             self.timeUnit = timeUnit
             self.networkOperator = networkOperator
             self.startTime = startTime
    }

    enum OrderPriceProtocolVoCodingKeys: String, CodingKey {
        case resourceId
        case serviceCode
        case region
        case billingType
        case formula
        case count
        case timeSpan
        case timeUnit
        case networkOperator
        case pin
        case startTime
        case endTime
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: OrderPriceProtocolVoCodingKeys.self)
        if decoderContainer.contains(.resourceId)
        {
            self.resourceId = try decoderContainer.decode(String?.self, forKey: .resourceId)
        }
        self.serviceCode = try decoderContainer.decode(String.self, forKey: .serviceCode)
        self.region = try decoderContainer.decode(String.self, forKey: .region)
        self.billingType = try decoderContainer.decode(Int.self, forKey: .billingType)
        if decoderContainer.contains(.formula)
        {
            self.formula = try decoderContainer.decode([OrderResourceFormulaVo?]?.self, forKey: .formula)
        }
        self.count = try decoderContainer.decode(Int.self, forKey: .count)
        self.timeSpan = try decoderContainer.decode(Int.self, forKey: .timeSpan)
        self.timeUnit = try decoderContainer.decode(Int.self, forKey: .timeUnit)
        self.networkOperator = try decoderContainer.decode(Int.self, forKey: .networkOperator)
        if decoderContainer.contains(.pin)
        {
            self.pin = try decoderContainer.decode(String?.self, forKey: .pin)
        }
        self.startTime = try decoderContainer.decode(String.self, forKey: .startTime)
        if decoderContainer.contains(.endTime)
        {
            self.endTime = try decoderContainer.decode(String?.self, forKey: .endTime)
        }
    }
}
public extension OrderPriceProtocolVo{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: OrderPriceProtocolVoCodingKeys.self)
         try encoderContainer.encode(resourceId, forKey: .resourceId)
         try encoderContainer.encode(serviceCode, forKey: .serviceCode)
         try encoderContainer.encode(region, forKey: .region)
         try encoderContainer.encode(billingType, forKey: .billingType)
         try encoderContainer.encode(formula, forKey: .formula)
         try encoderContainer.encode(count, forKey: .count)
         try encoderContainer.encode(timeSpan, forKey: .timeSpan)
         try encoderContainer.encode(timeUnit, forKey: .timeUnit)
         try encoderContainer.encode(networkOperator, forKey: .networkOperator)
         try encoderContainer.encode(pin, forKey: .pin)
         try encoderContainer.encode(startTime, forKey: .startTime)
         try encoderContainer.encode(endTime, forKey: .endTime)
    }
}
///  orderResourceFormulaVo
public class OrderResourceFormulaVo:NSObject,Codable{
    /// 资源配置项编码，具体取值请在对接时联系我们
    /// Required:true
    var key:String
    /// 资源配置项数量
    /// Required:true
    var value:Double



    public  init(key:String,value:Double){
             self.key = key
             self.value = value
    }

    enum OrderResourceFormulaVoCodingKeys: String, CodingKey {
        case key
        case value
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: OrderResourceFormulaVoCodingKeys.self)
        self.key = try decoderContainer.decode(String.self, forKey: .key)
        self.value = try decoderContainer.decode(Double.self, forKey: .value)
    }
}
public extension OrderResourceFormulaVo{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: OrderResourceFormulaVoCodingKeys.self)
         try encoderContainer.encode(key, forKey: .key)
         try encoderContainer.encode(value, forKey: .value)
    }
}
///  queryPriceResultVo
public class QueryPriceResultVo:NSObject,Codable{
    /// 总金额，小数后2位精度
    var totalPrice:Double?
    /// 总金额，小数后4位精度
    var totalPriceScale4:Double?
    /// 折扣后总金额
    var discountedTotalPrice:Double?
    /// 折扣优惠金额
    var totalDiscount:Double?
    /// 订单原价
    var totalOriginalPrice:Double?
    /// 备注
    var remark:String?



    public override init(){
            super.init()
    }

    enum QueryPriceResultVoCodingKeys: String, CodingKey {
        case totalPrice
        case totalPriceScale4
        case discountedTotalPrice
        case totalDiscount
        case totalOriginalPrice
        case remark
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: QueryPriceResultVoCodingKeys.self)
        if decoderContainer.contains(.totalPrice)
        {
            self.totalPrice = try decoderContainer.decode(Double?.self, forKey: .totalPrice)
        }
        if decoderContainer.contains(.totalPriceScale4)
        {
            self.totalPriceScale4 = try decoderContainer.decode(Double?.self, forKey: .totalPriceScale4)
        }
        if decoderContainer.contains(.discountedTotalPrice)
        {
            self.discountedTotalPrice = try decoderContainer.decode(Double?.self, forKey: .discountedTotalPrice)
        }
        if decoderContainer.contains(.totalDiscount)
        {
            self.totalDiscount = try decoderContainer.decode(Double?.self, forKey: .totalDiscount)
        }
        if decoderContainer.contains(.totalOriginalPrice)
        {
            self.totalOriginalPrice = try decoderContainer.decode(Double?.self, forKey: .totalOriginalPrice)
        }
        if decoderContainer.contains(.remark)
        {
            self.remark = try decoderContainer.decode(String?.self, forKey: .remark)
        }
    }
}
public extension QueryPriceResultVo{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: QueryPriceResultVoCodingKeys.self)
         try encoderContainer.encode(totalPrice, forKey: .totalPrice)
         try encoderContainer.encode(totalPriceScale4, forKey: .totalPriceScale4)
         try encoderContainer.encode(discountedTotalPrice, forKey: .discountedTotalPrice)
         try encoderContainer.encode(totalDiscount, forKey: .totalDiscount)
         try encoderContainer.encode(totalOriginalPrice, forKey: .totalOriginalPrice)
         try encoderContainer.encode(remark, forKey: .remark)
    }
}

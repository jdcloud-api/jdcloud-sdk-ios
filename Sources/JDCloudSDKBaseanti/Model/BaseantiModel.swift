/* Copyright 2018 JDCLOUD.COM

   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at

     http:#www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.

   Attack Log APIs
   Anti DDoS Basic Attack Log APIs

   OpenAPI spec version: v1
   Contact: 

   NOTE: This class is auto generated by the jdcloud code generator program.
 */


import Foundation
///  ipResource
public class IpResource:NSObject,Codable{
    /// 公网 IP 所在区域编码
    var region:String?
    /// 公网 IP 类型或绑定资源类型:
      ///   0: 未知类型,
      ///   1: 弹性公网 IP(IP 为弹性公网 IP, 绑定资源类型未知),
      ///   10: 弹性公网 IP(IP 为弹性公网 IP, 但未绑定资源),
      ///   11: 云主机,
      ///   12: 负载均衡,
      ///   13: 原生容器实例,
      ///   14: 原生容器 Pod,
      ///   2: 云物理服务器,
      /// 
    var resourceType:Int?
    /// 公网 IP 地址
    var ip:String?
    /// 带宽上限, 单位 Mbps
    var bandwidth:Int64?
    /// 每秒请求流量
    var cleanThresholdBps:Int64?
    /// 每秒报文请求数
    var cleanThresholdPps:Int64?
    /// 黑洞阈值
    var blackHoleThreshold:Int64?
    /// 绑定防护包 ID, 为空字符串时表示未绑定防护包
    var instanceId:String?
    /// 绑定防护包名称, 为空字符串时表示未绑定防护包
    var instanceName:String?
    /// 套餐类型, 1: 独享 IP, 2: 共享 IP, 为 0 时未绑定防护包
    var instanceType:Int?
    /// 安全状态, 0: 安全, 1: 清洗, 2: 黑洞
    var safeStatus:Int?



    public override init(){
            super.init()
    }

    enum IpResourceCodingKeys: String, CodingKey {
        case region
        case resourceType
        case ip
        case bandwidth
        case cleanThresholdBps
        case cleanThresholdPps
        case blackHoleThreshold
        case instanceId
        case instanceName
        case instanceType
        case safeStatus
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: IpResourceCodingKeys.self)
        if decoderContainer.contains(.region)
        {
            self.region = try decoderContainer.decode(String?.self, forKey: .region)
        }
        if decoderContainer.contains(.resourceType)
        {
            self.resourceType = try decoderContainer.decode(Int?.self, forKey: .resourceType)
        }
        if decoderContainer.contains(.ip)
        {
            self.ip = try decoderContainer.decode(String?.self, forKey: .ip)
        }
        if decoderContainer.contains(.bandwidth)
        {
            self.bandwidth = try decoderContainer.decode(Int64?.self, forKey: .bandwidth)
        }
        if decoderContainer.contains(.cleanThresholdBps)
        {
            self.cleanThresholdBps = try decoderContainer.decode(Int64?.self, forKey: .cleanThresholdBps)
        }
        if decoderContainer.contains(.cleanThresholdPps)
        {
            self.cleanThresholdPps = try decoderContainer.decode(Int64?.self, forKey: .cleanThresholdPps)
        }
        if decoderContainer.contains(.blackHoleThreshold)
        {
            self.blackHoleThreshold = try decoderContainer.decode(Int64?.self, forKey: .blackHoleThreshold)
        }
        if decoderContainer.contains(.instanceId)
        {
            self.instanceId = try decoderContainer.decode(String?.self, forKey: .instanceId)
        }
        if decoderContainer.contains(.instanceName)
        {
            self.instanceName = try decoderContainer.decode(String?.self, forKey: .instanceName)
        }
        if decoderContainer.contains(.instanceType)
        {
            self.instanceType = try decoderContainer.decode(Int?.self, forKey: .instanceType)
        }
        if decoderContainer.contains(.safeStatus)
        {
            self.safeStatus = try decoderContainer.decode(Int?.self, forKey: .safeStatus)
        }
    }
}
public extension IpResource{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: IpResourceCodingKeys.self)
         try encoderContainer.encode(region, forKey: .region)
         try encoderContainer.encode(resourceType, forKey: .resourceType)
         try encoderContainer.encode(ip, forKey: .ip)
         try encoderContainer.encode(bandwidth, forKey: .bandwidth)
         try encoderContainer.encode(cleanThresholdBps, forKey: .cleanThresholdBps)
         try encoderContainer.encode(cleanThresholdPps, forKey: .cleanThresholdPps)
         try encoderContainer.encode(blackHoleThreshold, forKey: .blackHoleThreshold)
         try encoderContainer.encode(instanceId, forKey: .instanceId)
         try encoderContainer.encode(instanceName, forKey: .instanceName)
         try encoderContainer.encode(instanceType, forKey: .instanceType)
         try encoderContainer.encode(safeStatus, forKey: .safeStatus)
    }
}
///  cleanThresholdSpec
public class CleanThresholdSpec:NSObject,Codable{
    /// 触发清洗的流量速率, 单位 bps. 取值范围由 &lt;a href&#x3D;&quot;http://docs.jdcloud.com/anti-ddos-basic/api/describeipcleanthresholdrange&quot;&gt;describeIpCleanThresholdRange&lt;/a&gt; 接口查询可知
      /// 
    /// Required:true
    var cleanThresholdBps:Int64
    /// 触发清洗的报文流量速率, 单位 bps. 取值范围由 &lt;a href&#x3D;&quot;http://docs.jdcloud.com/anti-ddos-basic/api/describeipcleanthresholdrange&quot;&gt;describeIpCleanThresholdRange&lt;/a&gt; 接口查询可知
      /// 
    /// Required:true
    var cleanThresholdPps:Int64



    public  init(cleanThresholdBps:Int64,cleanThresholdPps:Int64){
             self.cleanThresholdBps = cleanThresholdBps
             self.cleanThresholdPps = cleanThresholdPps
    }

    enum CleanThresholdSpecCodingKeys: String, CodingKey {
        case cleanThresholdBps
        case cleanThresholdPps
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: CleanThresholdSpecCodingKeys.self)
        self.cleanThresholdBps = try decoderContainer.decode(Int64.self, forKey: .cleanThresholdBps)
        self.cleanThresholdPps = try decoderContainer.decode(Int64.self, forKey: .cleanThresholdPps)
    }
}
public extension CleanThresholdSpec{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: CleanThresholdSpecCodingKeys.self)
         try encoderContainer.encode(cleanThresholdBps, forKey: .cleanThresholdBps)
         try encoderContainer.encode(cleanThresholdPps, forKey: .cleanThresholdPps)
    }
}
///  ipSafetyInfo
public class IpSafetyInfo:NSObject,Codable{
    /// 公网 IP 地址
    var ip:String?
    /// 安全状态, 0-&gt;安全, 1-&gt;清洗, 2-&gt;黑洞
    var safetyStatus:Int?
    /// 地域编码
    var region:String?
    /// 黑洞阈值, 单位 bps
    var blackHoleThreshold:Int64?
    /// 触发清洗的流量速率, 单位 bps
    var cleanThresholdBps:Int64?
    /// 触发清洗的包速率, 单位 pps
    var cleanThresholdPps:Int64?



    public override init(){
            super.init()
    }

    enum IpSafetyInfoCodingKeys: String, CodingKey {
        case ip
        case safetyStatus
        case region
        case blackHoleThreshold
        case cleanThresholdBps
        case cleanThresholdPps
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: IpSafetyInfoCodingKeys.self)
        if decoderContainer.contains(.ip)
        {
            self.ip = try decoderContainer.decode(String?.self, forKey: .ip)
        }
        if decoderContainer.contains(.safetyStatus)
        {
            self.safetyStatus = try decoderContainer.decode(Int?.self, forKey: .safetyStatus)
        }
        if decoderContainer.contains(.region)
        {
            self.region = try decoderContainer.decode(String?.self, forKey: .region)
        }
        if decoderContainer.contains(.blackHoleThreshold)
        {
            self.blackHoleThreshold = try decoderContainer.decode(Int64?.self, forKey: .blackHoleThreshold)
        }
        if decoderContainer.contains(.cleanThresholdBps)
        {
            self.cleanThresholdBps = try decoderContainer.decode(Int64?.self, forKey: .cleanThresholdBps)
        }
        if decoderContainer.contains(.cleanThresholdPps)
        {
            self.cleanThresholdPps = try decoderContainer.decode(Int64?.self, forKey: .cleanThresholdPps)
        }
    }
}
public extension IpSafetyInfo{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: IpSafetyInfoCodingKeys.self)
         try encoderContainer.encode(ip, forKey: .ip)
         try encoderContainer.encode(safetyStatus, forKey: .safetyStatus)
         try encoderContainer.encode(region, forKey: .region)
         try encoderContainer.encode(blackHoleThreshold, forKey: .blackHoleThreshold)
         try encoderContainer.encode(cleanThresholdBps, forKey: .cleanThresholdBps)
         try encoderContainer.encode(cleanThresholdPps, forKey: .cleanThresholdPps)
    }
}
///  ipResourceFlow
public class IpResourceFlow:NSObject,Codable{
    /// UTC 时间, 格式: yyyy-MM-dd&#39;T&#39;HH:mm:ssZ
    var time:[String?]?
    /// 防护后流量
    var postProtect:[Double?]?
    /// 防护前流量
    var preProtect:[Double?]?
    /// 流量单位
    var unit:String?



    public override init(){
            super.init()
    }

    enum IpResourceFlowCodingKeys: String, CodingKey {
        case time
        case postProtect
        case preProtect
        case unit
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: IpResourceFlowCodingKeys.self)
        if decoderContainer.contains(.time)
        {
            self.time = try decoderContainer.decode([String?]?.self, forKey: .time)
        }
        if decoderContainer.contains(.postProtect)
        {
            self.postProtect = try decoderContainer.decode([Double?]?.self, forKey: .postProtect)
        }
        if decoderContainer.contains(.preProtect)
        {
            self.preProtect = try decoderContainer.decode([Double?]?.self, forKey: .preProtect)
        }
        if decoderContainer.contains(.unit)
        {
            self.unit = try decoderContainer.decode(String?.self, forKey: .unit)
        }
    }
}
public extension IpResourceFlow{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: IpResourceFlowCodingKeys.self)
         try encoderContainer.encode(time, forKey: .time)
         try encoderContainer.encode(postProtect, forKey: .postProtect)
         try encoderContainer.encode(preProtect, forKey: .preProtect)
         try encoderContainer.encode(unit, forKey: .unit)
    }
}
///  ipResourceInfo
public class IpResourceInfo:NSObject,Codable{
    /// 公网 IP 地址
    var ip:String?
    /// 安全状态, 0: 安全, 1: 清洗, 2: 黑洞
    var safeStatus:Int?
    /// 公网 IP 所属地域编码
    var region:String?
    /// 黑洞阈值，单位 bps
    var blackHoleThreshold:Int64?
    /// 触发清洗的流量速率，单位 bps
    var cleanThresholdBps:Int64?
    /// 触发清洗的包速率，单位 pps
    var cleanThresholdPps:Int64?



    public override init(){
            super.init()
    }

    enum IpResourceInfoCodingKeys: String, CodingKey {
        case ip
        case safeStatus
        case region
        case blackHoleThreshold
        case cleanThresholdBps
        case cleanThresholdPps
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: IpResourceInfoCodingKeys.self)
        if decoderContainer.contains(.ip)
        {
            self.ip = try decoderContainer.decode(String?.self, forKey: .ip)
        }
        if decoderContainer.contains(.safeStatus)
        {
            self.safeStatus = try decoderContainer.decode(Int?.self, forKey: .safeStatus)
        }
        if decoderContainer.contains(.region)
        {
            self.region = try decoderContainer.decode(String?.self, forKey: .region)
        }
        if decoderContainer.contains(.blackHoleThreshold)
        {
            self.blackHoleThreshold = try decoderContainer.decode(Int64?.self, forKey: .blackHoleThreshold)
        }
        if decoderContainer.contains(.cleanThresholdBps)
        {
            self.cleanThresholdBps = try decoderContainer.decode(Int64?.self, forKey: .cleanThresholdBps)
        }
        if decoderContainer.contains(.cleanThresholdPps)
        {
            self.cleanThresholdPps = try decoderContainer.decode(Int64?.self, forKey: .cleanThresholdPps)
        }
    }
}
public extension IpResourceInfo{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: IpResourceInfoCodingKeys.self)
         try encoderContainer.encode(ip, forKey: .ip)
         try encoderContainer.encode(safeStatus, forKey: .safeStatus)
         try encoderContainer.encode(region, forKey: .region)
         try encoderContainer.encode(blackHoleThreshold, forKey: .blackHoleThreshold)
         try encoderContainer.encode(cleanThresholdBps, forKey: .cleanThresholdBps)
         try encoderContainer.encode(cleanThresholdPps, forKey: .cleanThresholdPps)
    }
}
///  ipCleanThresholdSpec
public class IpCleanThresholdSpec:NSObject,Codable{
    /// 基础防护已防护公网 IP, 支持 ipv4 和 ipv6.
      /// - 使用 &lt;a href&#x3D;&quot;http://docs.jdcloud.com/anti-ddos-basic/api/describeelasticipresources&quot;&gt;describeElasticIpResources&lt;/a&gt; 接口查询基础防护已防护的私有网络弹性公网 IP
      /// - 使用 &lt;a href&#x3D;&quot;http://docs.jdcloud.com/anti-ddos-basic/api/describecpsipresources&quot;&gt;describeCpsIpResources&lt;/a&gt; 接口查询基础防护已防护的云物理服务器公网IP 和 弹性公网 IP
      /// 
    /// Required:true
    var ip:String
    /// 触发清洗的流量速率, 单位 bps. 取值范围由 &lt;a href&#x3D;&quot;http://docs.jdcloud.com/anti-ddos-basic/api/describeipcleanthresholdrange&quot;&gt;describeIpCleanThresholdRange&lt;/a&gt; 接口查询可知
      /// 
    /// Required:true
    var cleanThresholdBps:Int64
    /// 触发清洗的报文流量速率, 单位 pps. 取值范围由 &lt;a href&#x3D;&quot;http://docs.jdcloud.com/anti-ddos-basic/api/describeipcleanthresholdrange&quot;&gt;describeIpCleanThresholdRange&lt;/a&gt; 接口查询可知
      /// 
    /// Required:true
    var cleanThresholdPps:Int64



    public  init(ip:String,cleanThresholdBps:Int64,cleanThresholdPps:Int64){
             self.ip = ip
             self.cleanThresholdBps = cleanThresholdBps
             self.cleanThresholdPps = cleanThresholdPps
    }

    enum IpCleanThresholdSpecCodingKeys: String, CodingKey {
        case ip
        case cleanThresholdBps
        case cleanThresholdPps
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: IpCleanThresholdSpecCodingKeys.self)
        self.ip = try decoderContainer.decode(String.self, forKey: .ip)
        self.cleanThresholdBps = try decoderContainer.decode(Int64.self, forKey: .cleanThresholdBps)
        self.cleanThresholdPps = try decoderContainer.decode(Int64.self, forKey: .cleanThresholdPps)
    }
}
public extension IpCleanThresholdSpec{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: IpCleanThresholdSpecCodingKeys.self)
         try encoderContainer.encode(ip, forKey: .ip)
         try encoderContainer.encode(cleanThresholdBps, forKey: .cleanThresholdBps)
         try encoderContainer.encode(cleanThresholdPps, forKey: .cleanThresholdPps)
    }
}
///  ipResourceProtectInfo
public class IpResourceProtectInfo:NSObject,Codable{
    /// 攻击开始时间
    var startTime:String?
    /// 攻击结束时间
    var endTime:String?
    /// 安全状态, 0: 安全, 1: 清洗, 2: 黑洞
    var status:Int?
    /// 触发原因，0-&gt;未知 1-&gt;四层 2-&gt;七层 3-&gt;四和7层
    var cause:Int?



    public override init(){
            super.init()
    }

    enum IpResourceProtectInfoCodingKeys: String, CodingKey {
        case startTime
        case endTime
        case status
        case cause
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: IpResourceProtectInfoCodingKeys.self)
        if decoderContainer.contains(.startTime)
        {
            self.startTime = try decoderContainer.decode(String?.self, forKey: .startTime)
        }
        if decoderContainer.contains(.endTime)
        {
            self.endTime = try decoderContainer.decode(String?.self, forKey: .endTime)
        }
        if decoderContainer.contains(.status)
        {
            self.status = try decoderContainer.decode(Int?.self, forKey: .status)
        }
        if decoderContainer.contains(.cause)
        {
            self.cause = try decoderContainer.decode(Int?.self, forKey: .cause)
        }
    }
}
public extension IpResourceProtectInfo{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: IpResourceProtectInfoCodingKeys.self)
         try encoderContainer.encode(startTime, forKey: .startTime)
         try encoderContainer.encode(endTime, forKey: .endTime)
         try encoderContainer.encode(status, forKey: .status)
         try encoderContainer.encode(cause, forKey: .cause)
    }
}
///  ipCleanThresholdRange
public class IpCleanThresholdRange:NSObject,Codable{
    /// 清洗流量可设置最大值
    var ipCleanThresholdBpsMax:Double?
    /// 清洗流量可设置最小值
    var ipCleanThresholdBpsMin:Double?
    /// 清洗报文流量可设置最大值
    var ipCleanThresholdPpsMax:Double?
    /// 清洗报文流量可设置最小值
    var ipCleanThresholdPpsMin:Double?



    public override init(){
            super.init()
    }

    enum IpCleanThresholdRangeCodingKeys: String, CodingKey {
        case ipCleanThresholdBpsMax
        case ipCleanThresholdBpsMin
        case ipCleanThresholdPpsMax
        case ipCleanThresholdPpsMin
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: IpCleanThresholdRangeCodingKeys.self)
        if decoderContainer.contains(.ipCleanThresholdBpsMax)
        {
            self.ipCleanThresholdBpsMax = try decoderContainer.decode(Double?.self, forKey: .ipCleanThresholdBpsMax)
        }
        if decoderContainer.contains(.ipCleanThresholdBpsMin)
        {
            self.ipCleanThresholdBpsMin = try decoderContainer.decode(Double?.self, forKey: .ipCleanThresholdBpsMin)
        }
        if decoderContainer.contains(.ipCleanThresholdPpsMax)
        {
            self.ipCleanThresholdPpsMax = try decoderContainer.decode(Double?.self, forKey: .ipCleanThresholdPpsMax)
        }
        if decoderContainer.contains(.ipCleanThresholdPpsMin)
        {
            self.ipCleanThresholdPpsMin = try decoderContainer.decode(Double?.self, forKey: .ipCleanThresholdPpsMin)
        }
    }
}
public extension IpCleanThresholdRange{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: IpCleanThresholdRangeCodingKeys.self)
         try encoderContainer.encode(ipCleanThresholdBpsMax, forKey: .ipCleanThresholdBpsMax)
         try encoderContainer.encode(ipCleanThresholdBpsMin, forKey: .ipCleanThresholdBpsMin)
         try encoderContainer.encode(ipCleanThresholdPpsMax, forKey: .ipCleanThresholdPpsMax)
         try encoderContainer.encode(ipCleanThresholdPpsMin, forKey: .ipCleanThresholdPpsMin)
    }
}
///  attackTypeCount
public class AttackTypeCount:NSObject,Codable{
    /// 攻击类型
    var type:String?
    /// 攻击次数
    var count:Int?



    public override init(){
            super.init()
    }

    enum AttackTypeCountCodingKeys: String, CodingKey {
        case type
        case count
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: AttackTypeCountCodingKeys.self)
        if decoderContainer.contains(.type)
        {
            self.type = try decoderContainer.decode(String?.self, forKey: .type)
        }
        if decoderContainer.contains(.count)
        {
            self.count = try decoderContainer.decode(Int?.self, forKey: .count)
        }
    }
}
public extension AttackTypeCount{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: AttackTypeCountCodingKeys.self)
         try encoderContainer.encode(type, forKey: .type)
         try encoderContainer.encode(count, forKey: .count)
    }
}
///  attackLog
public class AttackLog:NSObject,Codable{
    /// 公网 IP 地址
    var ip:String?
    /// 公网 IP 类型或绑定资源类型:
      ///   0: 未知类型,
      ///   1: 弹性公网 IP(IP 为弹性公网 IP, 绑定资源类型未知),
      ///   10: 弹性公网 IP(IP 为弹性公网 IP, 但未绑定资源),
      ///   11: 云主机,
      ///   12: 负载均衡,
      ///   13: 原生容器实例,
      ///   14: 原生容器 Pod,
      ///   2: 云物理服务器,
      /// 
    var resourceType:Int?
    /// 攻击记录 ID
    var attackLogId:String?
    /// 攻击开始时间, UTC 时间, 格式: yyyy-MM-dd&#39;T&#39;HH:mm:ssZ
    var startTime:String?
    /// 攻击结束时间, UTC 时间, 格式: yyyy-MM-dd&#39;T&#39;HH:mm:ssZ
    var endTime:String?
    /// 触发原因:
      /// 0: 未知,
      /// 1: 四层,
      /// 2: 七层,
      /// 3: 四层和七层
      /// 
    var cause:Int?
    /// 状态, 0: 清洗完成, 1: 清洗中, 2: 黑洞中
    var status:Int?
    /// 是否黑洞
    var blackHole:Bool?
    /// 攻击流量峰值
    var peak:Double?
    /// 攻击流量峰值单位
    var unit:String?
    /// 攻击类型
    var attackType:[String?]?



    public override init(){
            super.init()
    }

    enum AttackLogCodingKeys: String, CodingKey {
        case ip
        case resourceType
        case attackLogId
        case startTime
        case endTime
        case cause
        case status
        case blackHole
        case peak
        case unit
        case attackType
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: AttackLogCodingKeys.self)
        if decoderContainer.contains(.ip)
        {
            self.ip = try decoderContainer.decode(String?.self, forKey: .ip)
        }
        if decoderContainer.contains(.resourceType)
        {
            self.resourceType = try decoderContainer.decode(Int?.self, forKey: .resourceType)
        }
        if decoderContainer.contains(.attackLogId)
        {
            self.attackLogId = try decoderContainer.decode(String?.self, forKey: .attackLogId)
        }
        if decoderContainer.contains(.startTime)
        {
            self.startTime = try decoderContainer.decode(String?.self, forKey: .startTime)
        }
        if decoderContainer.contains(.endTime)
        {
            self.endTime = try decoderContainer.decode(String?.self, forKey: .endTime)
        }
        if decoderContainer.contains(.cause)
        {
            self.cause = try decoderContainer.decode(Int?.self, forKey: .cause)
        }
        if decoderContainer.contains(.status)
        {
            self.status = try decoderContainer.decode(Int?.self, forKey: .status)
        }
        if decoderContainer.contains(.blackHole)
        {
            self.blackHole = try decoderContainer.decode(Bool?.self, forKey: .blackHole)
        }
        if decoderContainer.contains(.peak)
        {
            self.peak = try decoderContainer.decode(Double?.self, forKey: .peak)
        }
        if decoderContainer.contains(.unit)
        {
            self.unit = try decoderContainer.decode(String?.self, forKey: .unit)
        }
        if decoderContainer.contains(.attackType)
        {
            self.attackType = try decoderContainer.decode([String?]?.self, forKey: .attackType)
        }
    }
}
public extension AttackLog{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: AttackLogCodingKeys.self)
         try encoderContainer.encode(ip, forKey: .ip)
         try encoderContainer.encode(resourceType, forKey: .resourceType)
         try encoderContainer.encode(attackLogId, forKey: .attackLogId)
         try encoderContainer.encode(startTime, forKey: .startTime)
         try encoderContainer.encode(endTime, forKey: .endTime)
         try encoderContainer.encode(cause, forKey: .cause)
         try encoderContainer.encode(status, forKey: .status)
         try encoderContainer.encode(blackHole, forKey: .blackHole)
         try encoderContainer.encode(peak, forKey: .peak)
         try encoderContainer.encode(unit, forKey: .unit)
         try encoderContainer.encode(attackType, forKey: .attackType)
    }
}

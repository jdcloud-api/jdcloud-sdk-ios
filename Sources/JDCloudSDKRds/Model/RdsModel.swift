/* Copyright 2018 JDCLOUD.COM

   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at

     http:#www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.

   参数组管理
   参数组管理相关接口

   OpenAPI spec version: v1
   Contact: 

   NOTE: This class is auto generated by the jdcloud code generator program.
 */


import Foundation
import JDCloudSDKCharge
///  backupSpec
public class BackupSpec:NSObject,Codable{
    /// 备份名称&lt;br&gt;SQL Server：最长支持64个英文字符或等长的中文字符&lt;br&gt;MySQL：只允许数字、小写字母及英文下划线“_”,不超过32字符
    var backupName:String?
    /// 需要备份的数据库名称列表。如不填，则备份整个实例&lt;br&gt;- **MySQL：不支持该参数**&lt;br&gt;- **SQL Server：支持**
    var dbNames:[String?]?



    public override init(){
            super.init()
    }

    enum BackupSpecCodingKeys: String, CodingKey {
        case backupName
        case dbNames
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: BackupSpecCodingKeys.self)
        if decoderContainer.contains(.backupName)
        {
            self.backupName = try decoderContainer.decode(String?.self, forKey: .backupName)
        }
        if decoderContainer.contains(.dbNames)
        {
            self.dbNames = try decoderContainer.decode([String?]?.self, forKey: .dbNames)
        }
    }
}
public extension BackupSpec{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: BackupSpecCodingKeys.self)
         try encoderContainer.encode(backupName, forKey: .backupName)
         try encoderContainer.encode(dbNames, forKey: .dbNames)
    }
}
///  backup
public class Backup:NSObject,Codable{
    /// 备份ID
    var backupId:String?
    /// 备份名称，最长支持64个英文字符或等长的中文字符
    var backupName:String?
    /// 备份所属实例ID
    var instanceId:String?
    /// 备份状态，请查看[枚举参数定义](../Enum-Definitions/Enum-Definitions.md)
    var backupStatus:String?
    /// 备份开始时间，格式为：YYYY-MM-DD HH:mm:ss
    var backupStartTime:String?
    /// 备份结束时间，格式为：YYYY-MM-DD HH:mm:ss&lt;br&gt;- **SQL Server支持**&lt;br&gt;- **MySQL不支持**
    var backupEndTime:String?
    /// 备份类型，全量备份或增量备份，请查看[枚举参数定义](../Enum-Definitions/Enum-Definitions.md)&lt;br&gt;- **SQL Server支持**&lt;br&gt;- **MySQL不支持**
    var backupType:String?
    /// 备份模式，系统自动备份或手动备份，请查看[枚举参数定义](../Enum-Definitions/Enum-Definitions.md)
    var backupMode:String?
    /// 备份粒度，实例备份或者多库备份，请查看[枚举参数定义](../Enum-Definitions/Enum-Definitions.md)&lt;br&gt;- **SQL Server支持**&lt;br&gt;- **MySQL不支持**
    var backupUnit:String?
    /// 备份文件列表&lt;br&gt;- **SQL Server支持**,备份可以有多个文件，文件名的命名规则为:&lt;br&gt;（1）全备：数据库名+.bak&lt;br&gt;（2）增量：数据库名+.diff&lt;br&gt;- **MySQL不支持**
    var backupFiles:[String?]?
    /// 整个备份集大小，单位：Byte
    var backupSizeByte:Int64?



    public override init(){
            super.init()
    }

    enum BackupCodingKeys: String, CodingKey {
        case backupId
        case backupName
        case instanceId
        case backupStatus
        case backupStartTime
        case backupEndTime
        case backupType
        case backupMode
        case backupUnit
        case backupFiles
        case backupSizeByte
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: BackupCodingKeys.self)
        if decoderContainer.contains(.backupId)
        {
            self.backupId = try decoderContainer.decode(String?.self, forKey: .backupId)
        }
        if decoderContainer.contains(.backupName)
        {
            self.backupName = try decoderContainer.decode(String?.self, forKey: .backupName)
        }
        if decoderContainer.contains(.instanceId)
        {
            self.instanceId = try decoderContainer.decode(String?.self, forKey: .instanceId)
        }
        if decoderContainer.contains(.backupStatus)
        {
            self.backupStatus = try decoderContainer.decode(String?.self, forKey: .backupStatus)
        }
        if decoderContainer.contains(.backupStartTime)
        {
            self.backupStartTime = try decoderContainer.decode(String?.self, forKey: .backupStartTime)
        }
        if decoderContainer.contains(.backupEndTime)
        {
            self.backupEndTime = try decoderContainer.decode(String?.self, forKey: .backupEndTime)
        }
        if decoderContainer.contains(.backupType)
        {
            self.backupType = try decoderContainer.decode(String?.self, forKey: .backupType)
        }
        if decoderContainer.contains(.backupMode)
        {
            self.backupMode = try decoderContainer.decode(String?.self, forKey: .backupMode)
        }
        if decoderContainer.contains(.backupUnit)
        {
            self.backupUnit = try decoderContainer.decode(String?.self, forKey: .backupUnit)
        }
        if decoderContainer.contains(.backupFiles)
        {
            self.backupFiles = try decoderContainer.decode([String?]?.self, forKey: .backupFiles)
        }
        if decoderContainer.contains(.backupSizeByte)
        {
            self.backupSizeByte = try decoderContainer.decode(Int64?.self, forKey: .backupSizeByte)
        }
    }
}
public extension Backup{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: BackupCodingKeys.self)
         try encoderContainer.encode(backupId, forKey: .backupId)
         try encoderContainer.encode(backupName, forKey: .backupName)
         try encoderContainer.encode(instanceId, forKey: .instanceId)
         try encoderContainer.encode(backupStatus, forKey: .backupStatus)
         try encoderContainer.encode(backupStartTime, forKey: .backupStartTime)
         try encoderContainer.encode(backupEndTime, forKey: .backupEndTime)
         try encoderContainer.encode(backupType, forKey: .backupType)
         try encoderContainer.encode(backupMode, forKey: .backupMode)
         try encoderContainer.encode(backupUnit, forKey: .backupUnit)
         try encoderContainer.encode(backupFiles, forKey: .backupFiles)
         try encoderContainer.encode(backupSizeByte, forKey: .backupSizeByte)
    }
}
///  errorLog
public class ErrorLog:NSObject,Codable{
    /// 错误日志文件名称
    var name:String?
    /// 错误日志文件大小，单位Byte
    var sizeByte:Int64?
    /// 错误日志最后更新时间，格式为：YYYY-MM-DD HH:mm:ss
    var lastUpdateTime:String?
    /// 错误日志上传时间，格式为：YYYY-MM-DD HH:mm:ss
    var uploadTime:String?
    /// 公网下载链接
    var publicURL:String?
    /// 内网下载链接
    var internalURL:String?



    public override init(){
            super.init()
    }

    enum ErrorLogCodingKeys: String, CodingKey {
        case name
        case sizeByte
        case lastUpdateTime
        case uploadTime
        case publicURL
        case internalURL
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: ErrorLogCodingKeys.self)
        if decoderContainer.contains(.name)
        {
            self.name = try decoderContainer.decode(String?.self, forKey: .name)
        }
        if decoderContainer.contains(.sizeByte)
        {
            self.sizeByte = try decoderContainer.decode(Int64?.self, forKey: .sizeByte)
        }
        if decoderContainer.contains(.lastUpdateTime)
        {
            self.lastUpdateTime = try decoderContainer.decode(String?.self, forKey: .lastUpdateTime)
        }
        if decoderContainer.contains(.uploadTime)
        {
            self.uploadTime = try decoderContainer.decode(String?.self, forKey: .uploadTime)
        }
        if decoderContainer.contains(.publicURL)
        {
            self.publicURL = try decoderContainer.decode(String?.self, forKey: .publicURL)
        }
        if decoderContainer.contains(.internalURL)
        {
            self.internalURL = try decoderContainer.decode(String?.self, forKey: .internalURL)
        }
    }
}
public extension ErrorLog{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: ErrorLogCodingKeys.self)
         try encoderContainer.encode(name, forKey: .name)
         try encoderContainer.encode(sizeByte, forKey: .sizeByte)
         try encoderContainer.encode(lastUpdateTime, forKey: .lastUpdateTime)
         try encoderContainer.encode(uploadTime, forKey: .uploadTime)
         try encoderContainer.encode(publicURL, forKey: .publicURL)
         try encoderContainer.encode(internalURL, forKey: .internalURL)
    }
}
///  interceptResult
public class InterceptResult:NSObject,Codable{
    /// SQL开始执行时间
    var startTime:String?
    /// 源IP
    var ip:String?
    /// 账号名
    var accountName:String?
    /// 线程ID
    var threadId:String?
    /// 数据库名
    var dbName:String?
    /// sql语句
    var sql:String?



    public override init(){
            super.init()
    }

    enum InterceptResultCodingKeys: String, CodingKey {
        case startTime
        case ip
        case accountName
        case threadId
        case dbName
        case sql
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: InterceptResultCodingKeys.self)
        if decoderContainer.contains(.startTime)
        {
            self.startTime = try decoderContainer.decode(String?.self, forKey: .startTime)
        }
        if decoderContainer.contains(.ip)
        {
            self.ip = try decoderContainer.decode(String?.self, forKey: .ip)
        }
        if decoderContainer.contains(.accountName)
        {
            self.accountName = try decoderContainer.decode(String?.self, forKey: .accountName)
        }
        if decoderContainer.contains(.threadId)
        {
            self.threadId = try decoderContainer.decode(String?.self, forKey: .threadId)
        }
        if decoderContainer.contains(.dbName)
        {
            self.dbName = try decoderContainer.decode(String?.self, forKey: .dbName)
        }
        if decoderContainer.contains(.sql)
        {
            self.sql = try decoderContainer.decode(String?.self, forKey: .sql)
        }
    }
}
public extension InterceptResult{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: InterceptResultCodingKeys.self)
         try encoderContainer.encode(startTime, forKey: .startTime)
         try encoderContainer.encode(ip, forKey: .ip)
         try encoderContainer.encode(accountName, forKey: .accountName)
         try encoderContainer.encode(threadId, forKey: .threadId)
         try encoderContainer.encode(dbName, forKey: .dbName)
         try encoderContainer.encode(sql, forKey: .sql)
    }
}
///  auditResult
public class AuditResult:NSObject,Codable{
    /// SQL开始执行时间
    var startTime:String?
    /// 源IP
    var ip:String?
    /// 账号名
    var accountName:String?
    /// 操作类型
    var operation:String?
    /// 线程ID
    var threadId:String?
    /// 数据库名
    var dbName:String?
    /// sql语句
    var sql:String?



    public override init(){
            super.init()
    }

    enum AuditResultCodingKeys: String, CodingKey {
        case startTime
        case ip
        case accountName
        case operation
        case threadId
        case dbName
        case sql
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: AuditResultCodingKeys.self)
        if decoderContainer.contains(.startTime)
        {
            self.startTime = try decoderContainer.decode(String?.self, forKey: .startTime)
        }
        if decoderContainer.contains(.ip)
        {
            self.ip = try decoderContainer.decode(String?.self, forKey: .ip)
        }
        if decoderContainer.contains(.accountName)
        {
            self.accountName = try decoderContainer.decode(String?.self, forKey: .accountName)
        }
        if decoderContainer.contains(.operation)
        {
            self.operation = try decoderContainer.decode(String?.self, forKey: .operation)
        }
        if decoderContainer.contains(.threadId)
        {
            self.threadId = try decoderContainer.decode(String?.self, forKey: .threadId)
        }
        if decoderContainer.contains(.dbName)
        {
            self.dbName = try decoderContainer.decode(String?.self, forKey: .dbName)
        }
        if decoderContainer.contains(.sql)
        {
            self.sql = try decoderContainer.decode(String?.self, forKey: .sql)
        }
    }
}
public extension AuditResult{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: AuditResultCodingKeys.self)
         try encoderContainer.encode(startTime, forKey: .startTime)
         try encoderContainer.encode(ip, forKey: .ip)
         try encoderContainer.encode(accountName, forKey: .accountName)
         try encoderContainer.encode(operation, forKey: .operation)
         try encoderContainer.encode(threadId, forKey: .threadId)
         try encoderContainer.encode(dbName, forKey: .dbName)
         try encoderContainer.encode(sql, forKey: .sql)
    }
}
///  auditFile
public class AuditFile:NSObject,Codable{
    /// 审计日志文件名称
    var name:String?
    /// 审计日志文件大小，单位Byte
    var sizeByte:Int64?
    /// 审计日志文件最后更新时间
    var lastUpdateTime:String?
    /// 审计日志文件上传时间
    var uploadTime:String?



    public override init(){
            super.init()
    }

    enum AuditFileCodingKeys: String, CodingKey {
        case name
        case sizeByte
        case lastUpdateTime
        case uploadTime
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: AuditFileCodingKeys.self)
        if decoderContainer.contains(.name)
        {
            self.name = try decoderContainer.decode(String?.self, forKey: .name)
        }
        if decoderContainer.contains(.sizeByte)
        {
            self.sizeByte = try decoderContainer.decode(Int64?.self, forKey: .sizeByte)
        }
        if decoderContainer.contains(.lastUpdateTime)
        {
            self.lastUpdateTime = try decoderContainer.decode(String?.self, forKey: .lastUpdateTime)
        }
        if decoderContainer.contains(.uploadTime)
        {
            self.uploadTime = try decoderContainer.decode(String?.self, forKey: .uploadTime)
        }
    }
}
public extension AuditFile{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: AuditFileCodingKeys.self)
         try encoderContainer.encode(name, forKey: .name)
         try encoderContainer.encode(sizeByte, forKey: .sizeByte)
         try encoderContainer.encode(lastUpdateTime, forKey: .lastUpdateTime)
         try encoderContainer.encode(uploadTime, forKey: .uploadTime)
    }
}
///  binlog
public class Binlog:NSObject,Codable{
    /// binlog日志备份ID
    var binlogBackupId:String?
    /// binlog日志名称
    var binlogName:String?
    /// binlog日志大小，单位KB
    var binlogSizeKB:Int64?
    /// binlog开始时间,格式为：YYYY-MM-DD HH:mm:ss
    var binlogStartTime:String?
    /// binlog结束时间,格式为：YYYY-MM-DD HH:mm:ss
    var binlogEndTime:String?



    public override init(){
            super.init()
    }

    enum BinlogCodingKeys: String, CodingKey {
        case binlogBackupId
        case binlogName
        case binlogSizeKB
        case binlogStartTime
        case binlogEndTime
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: BinlogCodingKeys.self)
        if decoderContainer.contains(.binlogBackupId)
        {
            self.binlogBackupId = try decoderContainer.decode(String?.self, forKey: .binlogBackupId)
        }
        if decoderContainer.contains(.binlogName)
        {
            self.binlogName = try decoderContainer.decode(String?.self, forKey: .binlogName)
        }
        if decoderContainer.contains(.binlogSizeKB)
        {
            self.binlogSizeKB = try decoderContainer.decode(Int64?.self, forKey: .binlogSizeKB)
        }
        if decoderContainer.contains(.binlogStartTime)
        {
            self.binlogStartTime = try decoderContainer.decode(String?.self, forKey: .binlogStartTime)
        }
        if decoderContainer.contains(.binlogEndTime)
        {
            self.binlogEndTime = try decoderContainer.decode(String?.self, forKey: .binlogEndTime)
        }
    }
}
public extension Binlog{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: BinlogCodingKeys.self)
         try encoderContainer.encode(binlogBackupId, forKey: .binlogBackupId)
         try encoderContainer.encode(binlogName, forKey: .binlogName)
         try encoderContainer.encode(binlogSizeKB, forKey: .binlogSizeKB)
         try encoderContainer.encode(binlogStartTime, forKey: .binlogStartTime)
         try encoderContainer.encode(binlogEndTime, forKey: .binlogEndTime)
    }
}
///  importFile
public class ImportFile:NSObject,Codable{
    /// 文件名称
    var name:String?
    /// 如果该文件是共享文件，则有全局ID，如不是共享文件，则为空。该全局ID在文件删除时，需要用到
    var sharedFileGid:String?
    /// 文件大小，单位Byte
    var sizeByte:Int?
    /// 文件上传完成时间，格式为：YYYY-MM-DD HH:mm:ss
    var uploadTime:String?
    /// 是否所属当前实例.&lt;br&gt; 1：当前实例；&lt;br&gt;0：不是当前实例，为共享文件
    var isLocal:String?
    /// 文件状态&lt;br&gt;- 仅支持SQL Server
    var status:String?
    /// 导入完成时间,格式为：YYYY-MM-DD HH:mm:ss&lt;br&gt;- 仅支持SQL Server
    var importTime:String?



    public override init(){
            super.init()
    }

    enum ImportFileCodingKeys: String, CodingKey {
        case name
        case sharedFileGid
        case sizeByte
        case uploadTime
        case isLocal
        case status
        case importTime
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: ImportFileCodingKeys.self)
        if decoderContainer.contains(.name)
        {
            self.name = try decoderContainer.decode(String?.self, forKey: .name)
        }
        if decoderContainer.contains(.sharedFileGid)
        {
            self.sharedFileGid = try decoderContainer.decode(String?.self, forKey: .sharedFileGid)
        }
        if decoderContainer.contains(.sizeByte)
        {
            self.sizeByte = try decoderContainer.decode(Int?.self, forKey: .sizeByte)
        }
        if decoderContainer.contains(.uploadTime)
        {
            self.uploadTime = try decoderContainer.decode(String?.self, forKey: .uploadTime)
        }
        if decoderContainer.contains(.isLocal)
        {
            self.isLocal = try decoderContainer.decode(String?.self, forKey: .isLocal)
        }
        if decoderContainer.contains(.status)
        {
            self.status = try decoderContainer.decode(String?.self, forKey: .status)
        }
        if decoderContainer.contains(.importTime)
        {
            self.importTime = try decoderContainer.decode(String?.self, forKey: .importTime)
        }
    }
}
public extension ImportFile{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: ImportFileCodingKeys.self)
         try encoderContainer.encode(name, forKey: .name)
         try encoderContainer.encode(sharedFileGid, forKey: .sharedFileGid)
         try encoderContainer.encode(sizeByte, forKey: .sizeByte)
         try encoderContainer.encode(uploadTime, forKey: .uploadTime)
         try encoderContainer.encode(isLocal, forKey: .isLocal)
         try encoderContainer.encode(status, forKey: .status)
         try encoderContainer.encode(importTime, forKey: .importTime)
    }
}
///  whiteList
public class WhiteList:NSObject,Codable{
    /// 白名单名称
    var name:String?
    /// IP或IP段，不同的IP/IP段之间用英文逗号分隔，例如0.0.0.0/0,192.168.0.10
    var ips:String?



    public override init(){
            super.init()
    }

    enum WhiteListCodingKeys: String, CodingKey {
        case name
        case ips
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: WhiteListCodingKeys.self)
        if decoderContainer.contains(.name)
        {
            self.name = try decoderContainer.decode(String?.self, forKey: .name)
        }
        if decoderContainer.contains(.ips)
        {
            self.ips = try decoderContainer.decode(String?.self, forKey: .ips)
        }
    }
}
public extension WhiteList{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: WhiteListCodingKeys.self)
         try encoderContainer.encode(name, forKey: .name)
         try encoderContainer.encode(ips, forKey: .ips)
    }
}
///  log
public class Log:NSObject,Codable{
    /// 日志文件id
    var id:String?
    /// 日志文件名称
    var name:String?
    /// 日志文件大小，单位Byte
    var sizeByte:Int?
    /// 日志最后更改时间
    var lastModified:String?
    /// 公网下载链接
    var publicURL:String?
    /// 内网下载链接
    var internalURL:String?



    public override init(){
            super.init()
    }

    enum LogCodingKeys: String, CodingKey {
        case id
        case name
        case sizeByte
        case lastModified
        case publicURL
        case internalURL
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: LogCodingKeys.self)
        if decoderContainer.contains(.id)
        {
            self.id = try decoderContainer.decode(String?.self, forKey: .id)
        }
        if decoderContainer.contains(.name)
        {
            self.name = try decoderContainer.decode(String?.self, forKey: .name)
        }
        if decoderContainer.contains(.sizeByte)
        {
            self.sizeByte = try decoderContainer.decode(Int?.self, forKey: .sizeByte)
        }
        if decoderContainer.contains(.lastModified)
        {
            self.lastModified = try decoderContainer.decode(String?.self, forKey: .lastModified)
        }
        if decoderContainer.contains(.publicURL)
        {
            self.publicURL = try decoderContainer.decode(String?.self, forKey: .publicURL)
        }
        if decoderContainer.contains(.internalURL)
        {
            self.internalURL = try decoderContainer.decode(String?.self, forKey: .internalURL)
        }
    }
}
public extension Log{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: LogCodingKeys.self)
         try encoderContainer.encode(id, forKey: .id)
         try encoderContainer.encode(name, forKey: .name)
         try encoderContainer.encode(sizeByte, forKey: .sizeByte)
         try encoderContainer.encode(lastModified, forKey: .lastModified)
         try encoderContainer.encode(publicURL, forKey: .publicURL)
         try encoderContainer.encode(internalURL, forKey: .internalURL)
    }
}
///  restoredNewDBInstanceSpec
public class RestoredNewDBInstanceSpec:NSObject,Codable{
    /// 数据库实例名，名称的限制可参考[帮助中心文档](../../../documentation/Database-and-Cache-Service/RDS/Introduction/Restrictions/SQLServer-Restrictions.md)
    var instanceName:String?
    /// 实例规格代码，可以查看文档[MySQL 实例规格](../Instance-Specifications/Instance-Specifications-MySQL.md)、[SQL Server实例规格](../Instance-Specifications/Instance-Specifications-SQLServer.md)
    /// Required:true
    var instanceClass:String
    /// 磁盘大小，单位GB
    /// Required:true
    var instanceStorageGB:Int
    /// 可用区ID， 第一个ID必须为主实例所在的可用区。如两个可用区一样，也需输入两个azId
    /// Required:true
    var azId:[String?]?
    /// VPC的ID
    /// Required:true
    var vpcId:String
    /// 子网ID
    /// Required:true
    var subnetId:String
    /// 参数组ID, 缺省系统会创建一个默认参数组&lt;br&gt;- 仅支持MySQL
    var parameterGroup:String?
    /// 计费规格，包括计费类型，计费周期等
    /// Required:true
    var chargeSpec:ChargeSpec
    /// 存储类型，参见[枚举参数定义](../Enum-Definitions/Enum-Definitions.md), 缺省值为：LOCAL_SSD&lt;br&gt;- 仅支持MySQL
    var instanceStorageType:String?
    /// 应用访问端口, 仅支持 MySQL，Percona, MariaDB, 默认值为 3306
    var instancePort:String?
    /// 实例数据加密(存储类型为云硬盘才支持数据加密)。false：不加密，true：加密，缺省为false&lt;br&gt;- 仅支持MySQL
    var storageEncrypted:Bool?
    /// 实例的高可用架构。standalone：单机，cluster：主备双机架构，缺省为cluster&lt;br&gt;- 仅支持SQL Server
    var instanceType:String?



    public  init(instanceClass:String,instanceStorageGB:Int,azId:[String?]?,vpcId:String,subnetId:String,chargeSpec:ChargeSpec){
             self.instanceClass = instanceClass
             self.instanceStorageGB = instanceStorageGB
             self.azId = azId
             self.vpcId = vpcId
             self.subnetId = subnetId
             self.chargeSpec = chargeSpec
    }

    enum RestoredNewDBInstanceSpecCodingKeys: String, CodingKey {
        case instanceName
        case instanceClass
        case instanceStorageGB
        case azId
        case vpcId
        case subnetId
        case parameterGroup
        case chargeSpec
        case instanceStorageType
        case instancePort
        case storageEncrypted
        case instanceType
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: RestoredNewDBInstanceSpecCodingKeys.self)
        if decoderContainer.contains(.instanceName)
        {
            self.instanceName = try decoderContainer.decode(String?.self, forKey: .instanceName)
        }
        self.instanceClass = try decoderContainer.decode(String.self, forKey: .instanceClass)
        self.instanceStorageGB = try decoderContainer.decode(Int.self, forKey: .instanceStorageGB)
        self.azId = try decoderContainer.decode([String?]?.self, forKey: .azId)
        self.vpcId = try decoderContainer.decode(String.self, forKey: .vpcId)
        self.subnetId = try decoderContainer.decode(String.self, forKey: .subnetId)
        if decoderContainer.contains(.parameterGroup)
        {
            self.parameterGroup = try decoderContainer.decode(String?.self, forKey: .parameterGroup)
        }
        self.chargeSpec = try decoderContainer.decode(ChargeSpec.self, forKey: .chargeSpec)
        if decoderContainer.contains(.instanceStorageType)
        {
            self.instanceStorageType = try decoderContainer.decode(String?.self, forKey: .instanceStorageType)
        }
        if decoderContainer.contains(.instancePort)
        {
            self.instancePort = try decoderContainer.decode(String?.self, forKey: .instancePort)
        }
        if decoderContainer.contains(.storageEncrypted)
        {
            self.storageEncrypted = try decoderContainer.decode(Bool?.self, forKey: .storageEncrypted)
        }
        if decoderContainer.contains(.instanceType)
        {
            self.instanceType = try decoderContainer.decode(String?.self, forKey: .instanceType)
        }
    }
}
public extension RestoredNewDBInstanceSpec{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: RestoredNewDBInstanceSpecCodingKeys.self)
         try encoderContainer.encode(instanceName, forKey: .instanceName)
         try encoderContainer.encode(instanceClass, forKey: .instanceClass)
         try encoderContainer.encode(instanceStorageGB, forKey: .instanceStorageGB)
         try encoderContainer.encode(azId, forKey: .azId)
         try encoderContainer.encode(vpcId, forKey: .vpcId)
         try encoderContainer.encode(subnetId, forKey: .subnetId)
         try encoderContainer.encode(parameterGroup, forKey: .parameterGroup)
         try encoderContainer.encode(chargeSpec, forKey: .chargeSpec)
         try encoderContainer.encode(instanceStorageType, forKey: .instanceStorageType)
         try encoderContainer.encode(instancePort, forKey: .instancePort)
         try encoderContainer.encode(storageEncrypted, forKey: .storageEncrypted)
         try encoderContainer.encode(instanceType, forKey: .instanceType)
    }
}
///  backupSynchronicityAbstract
public class BackupSynchronicityAbstract:NSObject,Codable{
    /// 跨地域备份同步服务ID
    var serviceId:String?
    /// 备份同步的目标地域
    var destRegion:String?



    public override init(){
            super.init()
    }

    enum BackupSynchronicityAbstractCodingKeys: String, CodingKey {
        case serviceId
        case destRegion
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: BackupSynchronicityAbstractCodingKeys.self)
        if decoderContainer.contains(.serviceId)
        {
            self.serviceId = try decoderContainer.decode(String?.self, forKey: .serviceId)
        }
        if decoderContainer.contains(.destRegion)
        {
            self.destRegion = try decoderContainer.decode(String?.self, forKey: .destRegion)
        }
    }
}
public extension BackupSynchronicityAbstract{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: BackupSynchronicityAbstractCodingKeys.self)
         try encoderContainer.encode(serviceId, forKey: .serviceId)
         try encoderContainer.encode(destRegion, forKey: .destRegion)
    }
}
///  tag
public class Tag:NSObject,Codable{
    /// 标签键
    var key:String?
    /// 标签值
    var value:String?



    public override init(){
            super.init()
    }

    enum TagCodingKeys: String, CodingKey {
        case key
        case value
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: TagCodingKeys.self)
        if decoderContainer.contains(.key)
        {
            self.key = try decoderContainer.decode(String?.self, forKey: .key)
        }
        if decoderContainer.contains(.value)
        {
            self.value = try decoderContainer.decode(String?.self, forKey: .value)
        }
    }
}
public extension Tag{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: TagCodingKeys.self)
         try encoderContainer.encode(key, forKey: .key)
         try encoderContainer.encode(value, forKey: .value)
    }
}
///  dBInstance
public class DBInstance:NSObject,Codable{
    /// 实例ID
    var instanceId:String?
    /// 实例名称，具体规则可参见帮助中心文档:[名称及密码限制](../../../documentation/Database-and-Cache-Service/RDS/Introduction/Restrictions/SQLServer-Restrictions.md)
    var instanceName:String?
    /// 实例类别，例如主实例，只读实例等，参见[枚举参数定义](../Enum-Definitions/Enum-Definitions.md)
    var instanceType:String?
    /// 实例引擎类型，如MySQL或SQL Server等，参见[枚举参数定义](../Enum-Definitions/Enum-Definitions.md)
    var engine:String?
    /// 实例引擎版本，参见[枚举参数定义](../Enum-Definitions/Enum-Definitions.md)
    var engineVersion:String?
    /// 实例规格代码
    var instanceClass:String?
    /// 磁盘，单位GB
    var instanceStorageGB:Int?
    /// CPU核数
    var instanceCPU:Int?
    /// 内存，单位MB
    var instanceMemoryMB:Int?
    /// 地域ID，参见[地域及可用区对照表](../Enum-Definitions/Regions-AZ.md)
    var regionId:String?
    /// 可用区ID，第一个为主实例在的可用区，参见[地域及可用区对照表](../Enum-Definitions/Regions-AZ.md)
    var azId:[String?]?
    /// VPC的ID
    var vpcId:String?
    /// 子网的ID
    var subnetId:String?
    /// 实例状态，参见[枚举参数定义](../Enum-Definitions/Enum-Definitions.md)
    var instanceStatus:String?
    /// 实例公网域名&lt;br&gt;- 仅支持MySQL
    var publicDomainName:String?
    /// 实例内网域名&lt;br&gt;- 仅支持MySQL
    var internalDomainName:String?
    /// 实例创建时间
    var createTime:String?
    /// 实例跨地域备份服务开启相关信息
    var backupSynchronicity:[BackupSynchronicityAbstract?]?
    /// 计费配置
    var charge:Charge?
    /// 标签信息
    var tags:[Tag?]?
    /// MySQL、PostgreSQL只读实例对应的主实例ID
    var sourceInstanceId:String?



    public override init(){
            super.init()
    }

    enum DBInstanceCodingKeys: String, CodingKey {
        case instanceId
        case instanceName
        case instanceType
        case engine
        case engineVersion
        case instanceClass
        case instanceStorageGB
        case instanceCPU
        case instanceMemoryMB
        case regionId
        case azId
        case vpcId
        case subnetId
        case instanceStatus
        case publicDomainName
        case internalDomainName
        case createTime
        case backupSynchronicity
        case charge
        case tags
        case sourceInstanceId
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: DBInstanceCodingKeys.self)
        if decoderContainer.contains(.instanceId)
        {
            self.instanceId = try decoderContainer.decode(String?.self, forKey: .instanceId)
        }
        if decoderContainer.contains(.instanceName)
        {
            self.instanceName = try decoderContainer.decode(String?.self, forKey: .instanceName)
        }
        if decoderContainer.contains(.instanceType)
        {
            self.instanceType = try decoderContainer.decode(String?.self, forKey: .instanceType)
        }
        if decoderContainer.contains(.engine)
        {
            self.engine = try decoderContainer.decode(String?.self, forKey: .engine)
        }
        if decoderContainer.contains(.engineVersion)
        {
            self.engineVersion = try decoderContainer.decode(String?.self, forKey: .engineVersion)
        }
        if decoderContainer.contains(.instanceClass)
        {
            self.instanceClass = try decoderContainer.decode(String?.self, forKey: .instanceClass)
        }
        if decoderContainer.contains(.instanceStorageGB)
        {
            self.instanceStorageGB = try decoderContainer.decode(Int?.self, forKey: .instanceStorageGB)
        }
        if decoderContainer.contains(.instanceCPU)
        {
            self.instanceCPU = try decoderContainer.decode(Int?.self, forKey: .instanceCPU)
        }
        if decoderContainer.contains(.instanceMemoryMB)
        {
            self.instanceMemoryMB = try decoderContainer.decode(Int?.self, forKey: .instanceMemoryMB)
        }
        if decoderContainer.contains(.regionId)
        {
            self.regionId = try decoderContainer.decode(String?.self, forKey: .regionId)
        }
        if decoderContainer.contains(.azId)
        {
            self.azId = try decoderContainer.decode([String?]?.self, forKey: .azId)
        }
        if decoderContainer.contains(.vpcId)
        {
            self.vpcId = try decoderContainer.decode(String?.self, forKey: .vpcId)
        }
        if decoderContainer.contains(.subnetId)
        {
            self.subnetId = try decoderContainer.decode(String?.self, forKey: .subnetId)
        }
        if decoderContainer.contains(.instanceStatus)
        {
            self.instanceStatus = try decoderContainer.decode(String?.self, forKey: .instanceStatus)
        }
        if decoderContainer.contains(.publicDomainName)
        {
            self.publicDomainName = try decoderContainer.decode(String?.self, forKey: .publicDomainName)
        }
        if decoderContainer.contains(.internalDomainName)
        {
            self.internalDomainName = try decoderContainer.decode(String?.self, forKey: .internalDomainName)
        }
        if decoderContainer.contains(.createTime)
        {
            self.createTime = try decoderContainer.decode(String?.self, forKey: .createTime)
        }
        if decoderContainer.contains(.backupSynchronicity)
        {
            self.backupSynchronicity = try decoderContainer.decode([BackupSynchronicityAbstract?]?.self, forKey: .backupSynchronicity)
        }
        if decoderContainer.contains(.charge)
        {
            self.charge = try decoderContainer.decode(Charge?.self, forKey: .charge)
        }
        if decoderContainer.contains(.tags)
        {
            self.tags = try decoderContainer.decode([Tag?]?.self, forKey: .tags)
        }
        if decoderContainer.contains(.sourceInstanceId)
        {
            self.sourceInstanceId = try decoderContainer.decode(String?.self, forKey: .sourceInstanceId)
        }
    }
}
public extension DBInstance{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: DBInstanceCodingKeys.self)
         try encoderContainer.encode(instanceId, forKey: .instanceId)
         try encoderContainer.encode(instanceName, forKey: .instanceName)
         try encoderContainer.encode(instanceType, forKey: .instanceType)
         try encoderContainer.encode(engine, forKey: .engine)
         try encoderContainer.encode(engineVersion, forKey: .engineVersion)
         try encoderContainer.encode(instanceClass, forKey: .instanceClass)
         try encoderContainer.encode(instanceStorageGB, forKey: .instanceStorageGB)
         try encoderContainer.encode(instanceCPU, forKey: .instanceCPU)
         try encoderContainer.encode(instanceMemoryMB, forKey: .instanceMemoryMB)
         try encoderContainer.encode(regionId, forKey: .regionId)
         try encoderContainer.encode(azId, forKey: .azId)
         try encoderContainer.encode(vpcId, forKey: .vpcId)
         try encoderContainer.encode(subnetId, forKey: .subnetId)
         try encoderContainer.encode(instanceStatus, forKey: .instanceStatus)
         try encoderContainer.encode(publicDomainName, forKey: .publicDomainName)
         try encoderContainer.encode(internalDomainName, forKey: .internalDomainName)
         try encoderContainer.encode(createTime, forKey: .createTime)
         try encoderContainer.encode(backupSynchronicity, forKey: .backupSynchronicity)
         try encoderContainer.encode(charge, forKey: .charge)
         try encoderContainer.encode(tags, forKey: .tags)
         try encoderContainer.encode(sourceInstanceId, forKey: .sourceInstanceId)
    }
}
///  resourceInfo
public class ResourceInfo:NSObject,Codable{
    /// 实例id
    var resourceId:String?
    /// 实例名称
    var resourceName:String?



    public override init(){
            super.init()
    }

    enum ResourceInfoCodingKeys: String, CodingKey {
        case resourceId
        case resourceName
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: ResourceInfoCodingKeys.self)
        if decoderContainer.contains(.resourceId)
        {
            self.resourceId = try decoderContainer.decode(String?.self, forKey: .resourceId)
        }
        if decoderContainer.contains(.resourceName)
        {
            self.resourceName = try decoderContainer.decode(String?.self, forKey: .resourceName)
        }
    }
}
public extension ResourceInfo{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: ResourceInfoCodingKeys.self)
         try encoderContainer.encode(resourceId, forKey: .resourceId)
         try encoderContainer.encode(resourceName, forKey: .resourceName)
    }
}
///  dBInstanceNode
public class DBInstanceNode:NSObject,Codable{
    /// 节点id
    var id:String?
    /// 节点名称
    var name:String?
    /// 节点状态
    var status:String?



    public override init(){
            super.init()
    }

    enum DBInstanceNodeCodingKeys: String, CodingKey {
        case id
        case name
        case status
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: DBInstanceNodeCodingKeys.self)
        if decoderContainer.contains(.id)
        {
            self.id = try decoderContainer.decode(String?.self, forKey: .id)
        }
        if decoderContainer.contains(.name)
        {
            self.name = try decoderContainer.decode(String?.self, forKey: .name)
        }
        if decoderContainer.contains(.status)
        {
            self.status = try decoderContainer.decode(String?.self, forKey: .status)
        }
    }
}
public extension DBInstanceNode{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: DBInstanceNodeCodingKeys.self)
         try encoderContainer.encode(id, forKey: .id)
         try encoderContainer.encode(name, forKey: .name)
         try encoderContainer.encode(status, forKey: .status)
    }
}
///  dBInstanceAttribute
public class DBInstanceAttribute:NSObject,Codable{
    /// 实例ID
    var instanceId:String?
    /// 实例名称，具体规则可参见帮助中心文档:[名称及密码限制](../../../documentation/Database-and-Cache-Service/RDS/Introduction/Restrictions/SQLServer-Restrictions.md)
    var instanceName:String?
    /// 实例类型，例如主实例，只读实例等，参见[枚举参数定义](../Enum-Definitions/Enum-Definitions.md)
    var instanceType:String?
    /// 实例引擎类型，如MySQL或SQL Server等，参见[枚举参数定义](../Enum-Definitions/Enum-Definitions.md)
    var engine:String?
    /// 实例引擎版本，参见[枚举参数定义](../Enum-Definitions/Enum-Definitions.md)
    var engineVersion:String?
    /// 实例规格代码
    var instanceClass:String?
    /// 存储类型，参见[枚举参数定义](../Enum-Definitions/Enum-Definitions.md)
    var instanceStorageType:String?
    /// 实例数据加密. false：不加密; true：加密
    var storageEncrypted:Bool?
    /// 磁盘，单位GB
    var instanceStorageGB:Int?
    /// CPU核数
    var instanceCPU:Int?
    /// 内存大小，单位MB
    var instanceMemoryMB:Int?
    /// 地域ID，参见[地域及可用区对照表](../Enum-Definitions/Regions-AZ.md)
    var regionId:String?
    /// 可用区ID，第一个为主实例在的可用区，参见[地域及可用区对照表](../Enum-Definitions/Regions-AZ.md)
    var azId:[String?]?
    /// VPC的ID
    var vpcId:String?
    /// 子网的ID
    var subnetId:String?
    /// 参数组的ID&lt;br&gt;- 仅支持MySQL
    var parameterGroupId:String?
    /// 参数组的名称&lt;br&gt;- 仅支持MySQL
    var parameterGroupName:String?
    /// 参数的状态，参见[枚举参数定义](../Enum-Definitions/Enum-Definitions.md)&lt;br&gt;- 仅支持MySQL
    var parameterStatus:String?
    /// 实例内网域名
    var internalDomainName:String?
    /// 实例公网域名
    var publicDomainName:String?
    /// 应用访问端口
    var instancePort:String?
    /// 访问模式，参见[枚举参数定义](../Enum-Definitions/Enum-Definitions.md)&lt;br&gt;- 仅支持MySQL
    var connectionMode:String?
    /// 审计状态，参见[枚举参数定义](../Enum-Definitions/Enum-Definitions.md)&lt;br&gt;- 仅支持MySQL
    var auditStatus:String?
    /// 实例状态，参见[枚举参数定义](../Enum-Definitions/Enum-Definitions.md)
    var instanceStatus:String?
    /// 实例创建时间
    var createTime:String?
    /// 计费配置
    var charge:Charge?
    /// MySQL只读实例对应的主实例ID&lt;br&gt;- 仅支持MySQL
    var sourceInstanceId:String?
    /// 只读实例ID列表&lt;br&gt;- 仅支持MySQL
    var roInstanceIds:[String?]?
    /// 高可用集群中主节点的信息&lt;br&gt;- 仅支持SQL Server
    var primaryNode:DBInstanceNode?
    /// 高可用集群中从节点的信息&lt;br&gt;- 仅支持SQL Server
    var secondaryNode:DBInstanceNode?
    /// 标签信息
    var tags:[Tag?]?



    public override init(){
            super.init()
    }

    enum DBInstanceAttributeCodingKeys: String, CodingKey {
        case instanceId
        case instanceName
        case instanceType
        case engine
        case engineVersion
        case instanceClass
        case instanceStorageType
        case storageEncrypted
        case instanceStorageGB
        case instanceCPU
        case instanceMemoryMB
        case regionId
        case azId
        case vpcId
        case subnetId
        case parameterGroupId
        case parameterGroupName
        case parameterStatus
        case internalDomainName
        case publicDomainName
        case instancePort
        case connectionMode
        case auditStatus
        case instanceStatus
        case createTime
        case charge
        case sourceInstanceId
        case roInstanceIds
        case primaryNode
        case secondaryNode
        case tags
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: DBInstanceAttributeCodingKeys.self)
        if decoderContainer.contains(.instanceId)
        {
            self.instanceId = try decoderContainer.decode(String?.self, forKey: .instanceId)
        }
        if decoderContainer.contains(.instanceName)
        {
            self.instanceName = try decoderContainer.decode(String?.self, forKey: .instanceName)
        }
        if decoderContainer.contains(.instanceType)
        {
            self.instanceType = try decoderContainer.decode(String?.self, forKey: .instanceType)
        }
        if decoderContainer.contains(.engine)
        {
            self.engine = try decoderContainer.decode(String?.self, forKey: .engine)
        }
        if decoderContainer.contains(.engineVersion)
        {
            self.engineVersion = try decoderContainer.decode(String?.self, forKey: .engineVersion)
        }
        if decoderContainer.contains(.instanceClass)
        {
            self.instanceClass = try decoderContainer.decode(String?.self, forKey: .instanceClass)
        }
        if decoderContainer.contains(.instanceStorageType)
        {
            self.instanceStorageType = try decoderContainer.decode(String?.self, forKey: .instanceStorageType)
        }
        if decoderContainer.contains(.storageEncrypted)
        {
            self.storageEncrypted = try decoderContainer.decode(Bool?.self, forKey: .storageEncrypted)
        }
        if decoderContainer.contains(.instanceStorageGB)
        {
            self.instanceStorageGB = try decoderContainer.decode(Int?.self, forKey: .instanceStorageGB)
        }
        if decoderContainer.contains(.instanceCPU)
        {
            self.instanceCPU = try decoderContainer.decode(Int?.self, forKey: .instanceCPU)
        }
        if decoderContainer.contains(.instanceMemoryMB)
        {
            self.instanceMemoryMB = try decoderContainer.decode(Int?.self, forKey: .instanceMemoryMB)
        }
        if decoderContainer.contains(.regionId)
        {
            self.regionId = try decoderContainer.decode(String?.self, forKey: .regionId)
        }
        if decoderContainer.contains(.azId)
        {
            self.azId = try decoderContainer.decode([String?]?.self, forKey: .azId)
        }
        if decoderContainer.contains(.vpcId)
        {
            self.vpcId = try decoderContainer.decode(String?.self, forKey: .vpcId)
        }
        if decoderContainer.contains(.subnetId)
        {
            self.subnetId = try decoderContainer.decode(String?.self, forKey: .subnetId)
        }
        if decoderContainer.contains(.parameterGroupId)
        {
            self.parameterGroupId = try decoderContainer.decode(String?.self, forKey: .parameterGroupId)
        }
        if decoderContainer.contains(.parameterGroupName)
        {
            self.parameterGroupName = try decoderContainer.decode(String?.self, forKey: .parameterGroupName)
        }
        if decoderContainer.contains(.parameterStatus)
        {
            self.parameterStatus = try decoderContainer.decode(String?.self, forKey: .parameterStatus)
        }
        if decoderContainer.contains(.internalDomainName)
        {
            self.internalDomainName = try decoderContainer.decode(String?.self, forKey: .internalDomainName)
        }
        if decoderContainer.contains(.publicDomainName)
        {
            self.publicDomainName = try decoderContainer.decode(String?.self, forKey: .publicDomainName)
        }
        if decoderContainer.contains(.instancePort)
        {
            self.instancePort = try decoderContainer.decode(String?.self, forKey: .instancePort)
        }
        if decoderContainer.contains(.connectionMode)
        {
            self.connectionMode = try decoderContainer.decode(String?.self, forKey: .connectionMode)
        }
        if decoderContainer.contains(.auditStatus)
        {
            self.auditStatus = try decoderContainer.decode(String?.self, forKey: .auditStatus)
        }
        if decoderContainer.contains(.instanceStatus)
        {
            self.instanceStatus = try decoderContainer.decode(String?.self, forKey: .instanceStatus)
        }
        if decoderContainer.contains(.createTime)
        {
            self.createTime = try decoderContainer.decode(String?.self, forKey: .createTime)
        }
        if decoderContainer.contains(.charge)
        {
            self.charge = try decoderContainer.decode(Charge?.self, forKey: .charge)
        }
        if decoderContainer.contains(.sourceInstanceId)
        {
            self.sourceInstanceId = try decoderContainer.decode(String?.self, forKey: .sourceInstanceId)
        }
        if decoderContainer.contains(.roInstanceIds)
        {
            self.roInstanceIds = try decoderContainer.decode([String?]?.self, forKey: .roInstanceIds)
        }
        if decoderContainer.contains(.primaryNode)
        {
            self.primaryNode = try decoderContainer.decode(DBInstanceNode?.self, forKey: .primaryNode)
        }
        if decoderContainer.contains(.secondaryNode)
        {
            self.secondaryNode = try decoderContainer.decode(DBInstanceNode?.self, forKey: .secondaryNode)
        }
        if decoderContainer.contains(.tags)
        {
            self.tags = try decoderContainer.decode([Tag?]?.self, forKey: .tags)
        }
    }
}
public extension DBInstanceAttribute{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: DBInstanceAttributeCodingKeys.self)
         try encoderContainer.encode(instanceId, forKey: .instanceId)
         try encoderContainer.encode(instanceName, forKey: .instanceName)
         try encoderContainer.encode(instanceType, forKey: .instanceType)
         try encoderContainer.encode(engine, forKey: .engine)
         try encoderContainer.encode(engineVersion, forKey: .engineVersion)
         try encoderContainer.encode(instanceClass, forKey: .instanceClass)
         try encoderContainer.encode(instanceStorageType, forKey: .instanceStorageType)
         try encoderContainer.encode(storageEncrypted, forKey: .storageEncrypted)
         try encoderContainer.encode(instanceStorageGB, forKey: .instanceStorageGB)
         try encoderContainer.encode(instanceCPU, forKey: .instanceCPU)
         try encoderContainer.encode(instanceMemoryMB, forKey: .instanceMemoryMB)
         try encoderContainer.encode(regionId, forKey: .regionId)
         try encoderContainer.encode(azId, forKey: .azId)
         try encoderContainer.encode(vpcId, forKey: .vpcId)
         try encoderContainer.encode(subnetId, forKey: .subnetId)
         try encoderContainer.encode(parameterGroupId, forKey: .parameterGroupId)
         try encoderContainer.encode(parameterGroupName, forKey: .parameterGroupName)
         try encoderContainer.encode(parameterStatus, forKey: .parameterStatus)
         try encoderContainer.encode(internalDomainName, forKey: .internalDomainName)
         try encoderContainer.encode(publicDomainName, forKey: .publicDomainName)
         try encoderContainer.encode(instancePort, forKey: .instancePort)
         try encoderContainer.encode(connectionMode, forKey: .connectionMode)
         try encoderContainer.encode(auditStatus, forKey: .auditStatus)
         try encoderContainer.encode(instanceStatus, forKey: .instanceStatus)
         try encoderContainer.encode(createTime, forKey: .createTime)
         try encoderContainer.encode(charge, forKey: .charge)
         try encoderContainer.encode(sourceInstanceId, forKey: .sourceInstanceId)
         try encoderContainer.encode(roInstanceIds, forKey: .roInstanceIds)
         try encoderContainer.encode(primaryNode, forKey: .primaryNode)
         try encoderContainer.encode(secondaryNode, forKey: .secondaryNode)
         try encoderContainer.encode(tags, forKey: .tags)
    }
}
///  dBInstanceSpecWithoutCharge
public class DBInstanceSpecWithoutCharge:NSObject,Codable{
    /// 实例名，具体规则可参见帮助中心文档:[名称及密码限制](https://docs.jdcloud.com/cn/rds/sqlserver-restrictions)
    /// Required:true
    var instanceName:String
    /// 实例引擎类型，参见[枚举参数定义](https://docs.jdcloud.com/cn/rds/api/enum-definitions)
    /// Required:true
    var engine:String
    /// 实例引擎版本，参见[枚举参数定义](https://docs.jdcloud.com/cn/rds/api/enum-definitions)
    /// Required:true
    var engineVersion:String
    /// 实例规格代码，可以查看文档[MySQL 实例规格](https://docs.jdcloud.com/cn/rds/api/instance-specifications-mysql)、[SQL Server实例规格](https://docs.jdcloud.com/cn/rds/api/instance-specifications-sqlserver)
    /// Required:true
    var instanceClass:String
    /// 磁盘大小，单位GB，可以查看文档[MySQL 实例规格](https://docs.jdcloud.com/cn/rds/api/instance-specifications-mysql)、[SQL Server实例规格](https://docs.jdcloud.com/cn/rds/api/instance-specifications-sqlserver)
    /// Required:true
    var instanceStorageGB:Int
    /// 可用区ID， 第一个ID必须为主实例所在的可用区。如两个可用区一样，也需输入两个azId
    /// Required:true
    var azId:[String?]?
    /// VPC的ID
    /// Required:true
    var vpcId:String
    /// 子网ID
    /// Required:true
    var subnetId:String
    /// 参数组ID, 缺省系统会创建一个默认参数组&lt;br&gt;- 仅支持MySQL
    var parameterGroup:String?
    /// 存储类型，参见[枚举参数定义](../Enum-Definitions/Enum-Definitions.md), 缺省值为：LOCAL_SSD&lt;br&gt;- 仅支持MySQL
    var instanceStorageType:String?
    /// 实例数据加密(存储类型为云硬盘才支持数据加密)。false：不加密，true：加密，缺省为false&lt;br&gt;- 仅支持MySQL
    var storageEncrypted:Bool?
    /// 实例的高可用架构。standalone：单机，cluster：主备双机架构，缺省为cluster&lt;br&gt;- 仅支持SQL Server
    var instanceType:String?



    public  init(instanceName:String,engine:String,engineVersion:String,instanceClass:String,instanceStorageGB:Int,azId:[String?]?,vpcId:String,subnetId:String){
             self.instanceName = instanceName
             self.engine = engine
             self.engineVersion = engineVersion
             self.instanceClass = instanceClass
             self.instanceStorageGB = instanceStorageGB
             self.azId = azId
             self.vpcId = vpcId
             self.subnetId = subnetId
    }

    enum DBInstanceSpecWithoutChargeCodingKeys: String, CodingKey {
        case instanceName
        case engine
        case engineVersion
        case instanceClass
        case instanceStorageGB
        case azId
        case vpcId
        case subnetId
        case parameterGroup
        case instanceStorageType
        case storageEncrypted
        case instanceType
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: DBInstanceSpecWithoutChargeCodingKeys.self)
        self.instanceName = try decoderContainer.decode(String.self, forKey: .instanceName)
        self.engine = try decoderContainer.decode(String.self, forKey: .engine)
        self.engineVersion = try decoderContainer.decode(String.self, forKey: .engineVersion)
        self.instanceClass = try decoderContainer.decode(String.self, forKey: .instanceClass)
        self.instanceStorageGB = try decoderContainer.decode(Int.self, forKey: .instanceStorageGB)
        self.azId = try decoderContainer.decode([String?]?.self, forKey: .azId)
        self.vpcId = try decoderContainer.decode(String.self, forKey: .vpcId)
        self.subnetId = try decoderContainer.decode(String.self, forKey: .subnetId)
        if decoderContainer.contains(.parameterGroup)
        {
            self.parameterGroup = try decoderContainer.decode(String?.self, forKey: .parameterGroup)
        }
        if decoderContainer.contains(.instanceStorageType)
        {
            self.instanceStorageType = try decoderContainer.decode(String?.self, forKey: .instanceStorageType)
        }
        if decoderContainer.contains(.storageEncrypted)
        {
            self.storageEncrypted = try decoderContainer.decode(Bool?.self, forKey: .storageEncrypted)
        }
        if decoderContainer.contains(.instanceType)
        {
            self.instanceType = try decoderContainer.decode(String?.self, forKey: .instanceType)
        }
    }
}
public extension DBInstanceSpecWithoutCharge{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: DBInstanceSpecWithoutChargeCodingKeys.self)
         try encoderContainer.encode(instanceName, forKey: .instanceName)
         try encoderContainer.encode(engine, forKey: .engine)
         try encoderContainer.encode(engineVersion, forKey: .engineVersion)
         try encoderContainer.encode(instanceClass, forKey: .instanceClass)
         try encoderContainer.encode(instanceStorageGB, forKey: .instanceStorageGB)
         try encoderContainer.encode(azId, forKey: .azId)
         try encoderContainer.encode(vpcId, forKey: .vpcId)
         try encoderContainer.encode(subnetId, forKey: .subnetId)
         try encoderContainer.encode(parameterGroup, forKey: .parameterGroup)
         try encoderContainer.encode(instanceStorageType, forKey: .instanceStorageType)
         try encoderContainer.encode(storageEncrypted, forKey: .storageEncrypted)
         try encoderContainer.encode(instanceType, forKey: .instanceType)
    }
}
///  dBInstanceInternal
public class DBInstanceInternal:NSObject,Codable{
    /// 实例ID
    var instanceId:String?
    /// 实例名称，具体规则可参见帮助中心文档:[名称及密码限制](../../../documentation/Database-and-Cache-Service/RDS/Introduction/Restrictions/SQLServer-Restrictions.md)
    var instanceName:String?
    /// 实例引擎类型，如MySQL或SQL Server等，参见[枚举参数定义](../Enum-Definitions/Enum-Definitions.md)
    var engine:String?
    /// 实例类别，例如主实例，只读实例等，参见[枚举参数定义](../Enum-Definitions/Enum-Definitions.md)
    var instanceType:String?
    /// 实例状态，参见[枚举参数定义](../Enum-Definitions/Enum-Definitions.md)
    var instanceStatus:String?



    public override init(){
            super.init()
    }

    enum DBInstanceInternalCodingKeys: String, CodingKey {
        case instanceId
        case instanceName
        case engine
        case instanceType
        case instanceStatus
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: DBInstanceInternalCodingKeys.self)
        if decoderContainer.contains(.instanceId)
        {
            self.instanceId = try decoderContainer.decode(String?.self, forKey: .instanceId)
        }
        if decoderContainer.contains(.instanceName)
        {
            self.instanceName = try decoderContainer.decode(String?.self, forKey: .instanceName)
        }
        if decoderContainer.contains(.engine)
        {
            self.engine = try decoderContainer.decode(String?.self, forKey: .engine)
        }
        if decoderContainer.contains(.instanceType)
        {
            self.instanceType = try decoderContainer.decode(String?.self, forKey: .instanceType)
        }
        if decoderContainer.contains(.instanceStatus)
        {
            self.instanceStatus = try decoderContainer.decode(String?.self, forKey: .instanceStatus)
        }
    }
}
public extension DBInstanceInternal{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: DBInstanceInternalCodingKeys.self)
         try encoderContainer.encode(instanceId, forKey: .instanceId)
         try encoderContainer.encode(instanceName, forKey: .instanceName)
         try encoderContainer.encode(engine, forKey: .engine)
         try encoderContainer.encode(instanceType, forKey: .instanceType)
         try encoderContainer.encode(instanceStatus, forKey: .instanceStatus)
    }
}
///  dBInstanceSpec
public class DBInstanceSpec:NSObject,Codable{
    /// 实例名，具体规则可参见帮助中心文档:[名称及密码限制](../../../documentation/Database-and-Cache-Service/RDS/Introduction/Restrictions/SQLServer-Restrictions.md)
    var instanceName:String?
    /// 实例引擎类型，参见[枚举参数定义](../Enum-Definitions/Enum-Definitions.md)
    /// Required:true
    var engine:String
    /// 实例引擎版本，参见[枚举参数定义](../Enum-Definitions/Enum-Definitions.md)
    /// Required:true
    var engineVersion:String
    /// 实例规格代码，可以查看文档[MySQL 实例规格](../Instance-Specifications/Instance-Specifications-MySQL.md)、[SQL Server实例规格](../Instance-Specifications/Instance-Specifications-SQLServer.md)
    /// Required:true
    var instanceClass:String
    /// 磁盘大小，单位GB，可以查看文档[MySQL 实例规格](../Instance-Specifications/Instance-Specifications-MySQL.md)、[SQL Server实例规格](../Instance-Specifications/Instance-Specifications-SQLServer.md)
    /// Required:true
    var instanceStorageGB:Int
    /// 可用区ID， 第一个ID必须为主实例所在的可用区。如两个可用区一样，也需输入两个azId
    /// Required:true
    var azId:[String?]?
    /// VPC的ID
    /// Required:true
    var vpcId:String
    /// 子网ID
    /// Required:true
    var subnetId:String
    /// 参数组ID, 缺省系统会创建一个默认参数组&lt;br&gt;- 仅支持MySQL
    var parameterGroup:String?
    /// 计费规格，包括计费类型，计费周期等
    /// Required:true
    var chargeSpec:ChargeSpec
    /// 存储类型，参见[枚举参数定义](../Enum-Definitions/Enum-Definitions.md), 缺省值为：LOCAL_SSD&lt;br&gt;- 仅支持MySQL
    var instanceStorageType:String?
    /// 应用访问端口, 仅支持 MySQL，Percona, MariaDB, 默认值为 3306
    var instancePort:String?
    /// 实例数据加密(存储类型为云硬盘才支持数据加密)。false：不加密，true：加密，缺省为false&lt;br&gt;- 仅支持MySQL
    var storageEncrypted:Bool?
    /// 实例的高可用架构。standalone：单机，cluster：主备双机架构，缺省为cluster&lt;br&gt;- 仅支持SQL Server
    var instanceType:String?



    public  init(engine:String,engineVersion:String,instanceClass:String,instanceStorageGB:Int,azId:[String?]?,vpcId:String,subnetId:String,chargeSpec:ChargeSpec){
             self.engine = engine
             self.engineVersion = engineVersion
             self.instanceClass = instanceClass
             self.instanceStorageGB = instanceStorageGB
             self.azId = azId
             self.vpcId = vpcId
             self.subnetId = subnetId
             self.chargeSpec = chargeSpec
    }

    enum DBInstanceSpecCodingKeys: String, CodingKey {
        case instanceName
        case engine
        case engineVersion
        case instanceClass
        case instanceStorageGB
        case azId
        case vpcId
        case subnetId
        case parameterGroup
        case chargeSpec
        case instanceStorageType
        case instancePort
        case storageEncrypted
        case instanceType
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: DBInstanceSpecCodingKeys.self)
        if decoderContainer.contains(.instanceName)
        {
            self.instanceName = try decoderContainer.decode(String?.self, forKey: .instanceName)
        }
        self.engine = try decoderContainer.decode(String.self, forKey: .engine)
        self.engineVersion = try decoderContainer.decode(String.self, forKey: .engineVersion)
        self.instanceClass = try decoderContainer.decode(String.self, forKey: .instanceClass)
        self.instanceStorageGB = try decoderContainer.decode(Int.self, forKey: .instanceStorageGB)
        self.azId = try decoderContainer.decode([String?]?.self, forKey: .azId)
        self.vpcId = try decoderContainer.decode(String.self, forKey: .vpcId)
        self.subnetId = try decoderContainer.decode(String.self, forKey: .subnetId)
        if decoderContainer.contains(.parameterGroup)
        {
            self.parameterGroup = try decoderContainer.decode(String?.self, forKey: .parameterGroup)
        }
        self.chargeSpec = try decoderContainer.decode(ChargeSpec.self, forKey: .chargeSpec)
        if decoderContainer.contains(.instanceStorageType)
        {
            self.instanceStorageType = try decoderContainer.decode(String?.self, forKey: .instanceStorageType)
        }
        if decoderContainer.contains(.instancePort)
        {
            self.instancePort = try decoderContainer.decode(String?.self, forKey: .instancePort)
        }
        if decoderContainer.contains(.storageEncrypted)
        {
            self.storageEncrypted = try decoderContainer.decode(Bool?.self, forKey: .storageEncrypted)
        }
        if decoderContainer.contains(.instanceType)
        {
            self.instanceType = try decoderContainer.decode(String?.self, forKey: .instanceType)
        }
    }
}
public extension DBInstanceSpec{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: DBInstanceSpecCodingKeys.self)
         try encoderContainer.encode(instanceName, forKey: .instanceName)
         try encoderContainer.encode(engine, forKey: .engine)
         try encoderContainer.encode(engineVersion, forKey: .engineVersion)
         try encoderContainer.encode(instanceClass, forKey: .instanceClass)
         try encoderContainer.encode(instanceStorageGB, forKey: .instanceStorageGB)
         try encoderContainer.encode(azId, forKey: .azId)
         try encoderContainer.encode(vpcId, forKey: .vpcId)
         try encoderContainer.encode(subnetId, forKey: .subnetId)
         try encoderContainer.encode(parameterGroup, forKey: .parameterGroup)
         try encoderContainer.encode(chargeSpec, forKey: .chargeSpec)
         try encoderContainer.encode(instanceStorageType, forKey: .instanceStorageType)
         try encoderContainer.encode(instancePort, forKey: .instancePort)
         try encoderContainer.encode(storageEncrypted, forKey: .storageEncrypted)
         try encoderContainer.encode(instanceType, forKey: .instanceType)
    }
}
///  database
public class Database:NSObject,Codable{
    /// 数据库名称，具体规则可参见帮助中心文档:[名称及密码限制](../../../documentation/Database-and-Cache-Service/RDS/Introduction/Restrictions/SQLServer-Restrictions.md)
    var dbName:String?
    /// 数据库状态，参见[枚举参数定义](../Enum-Definitions/Enum-Definitions.md)&lt;br&gt;- **MySQL：不支持，不返回该字段**&lt;br&gt;- **SQL Server：返回该字段**
    var dbStatus:String?
    /// 字符集，参见[枚举参数定义](../Enum-Definitions/Enum-Definitions.md)
    var characterSetName:String?
    /// 数据库创建时间，格式YYYY-MM-DD HH:mm:ss&lt;br&gt;- 仅支持SQL Server
    var createTime:String?
    /// 该数据库相关账户权限列表
    var accessPrivilege:[DBAccessPrivilege?]?



    public override init(){
            super.init()
    }

    enum DatabaseCodingKeys: String, CodingKey {
        case dbName
        case dbStatus
        case characterSetName
        case createTime
        case accessPrivilege
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: DatabaseCodingKeys.self)
        if decoderContainer.contains(.dbName)
        {
            self.dbName = try decoderContainer.decode(String?.self, forKey: .dbName)
        }
        if decoderContainer.contains(.dbStatus)
        {
            self.dbStatus = try decoderContainer.decode(String?.self, forKey: .dbStatus)
        }
        if decoderContainer.contains(.characterSetName)
        {
            self.characterSetName = try decoderContainer.decode(String?.self, forKey: .characterSetName)
        }
        if decoderContainer.contains(.createTime)
        {
            self.createTime = try decoderContainer.decode(String?.self, forKey: .createTime)
        }
        if decoderContainer.contains(.accessPrivilege)
        {
            self.accessPrivilege = try decoderContainer.decode([DBAccessPrivilege?]?.self, forKey: .accessPrivilege)
        }
    }
}
public extension Database{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: DatabaseCodingKeys.self)
         try encoderContainer.encode(dbName, forKey: .dbName)
         try encoderContainer.encode(dbStatus, forKey: .dbStatus)
         try encoderContainer.encode(characterSetName, forKey: .characterSetName)
         try encoderContainer.encode(createTime, forKey: .createTime)
         try encoderContainer.encode(accessPrivilege, forKey: .accessPrivilege)
    }
}
///  dBAccessPrivilege
public class DBAccessPrivilege:NSObject,Codable{
    /// 账号名称
    var accountName:String?
    /// 该账号对数据库具有的权限，权限的具体定义可以参见[枚举参数定义](../Enum-Definitions/Enum-Definitions.md)
    var privilege:String?



    public override init(){
            super.init()
    }

    enum DBAccessPrivilegeCodingKeys: String, CodingKey {
        case accountName
        case privilege
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: DBAccessPrivilegeCodingKeys.self)
        if decoderContainer.contains(.accountName)
        {
            self.accountName = try decoderContainer.decode(String?.self, forKey: .accountName)
        }
        if decoderContainer.contains(.privilege)
        {
            self.privilege = try decoderContainer.decode(String?.self, forKey: .privilege)
        }
    }
}
public extension DBAccessPrivilege{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: DBAccessPrivilegeCodingKeys.self)
         try encoderContainer.encode(accountName, forKey: .accountName)
         try encoderContainer.encode(privilege, forKey: .privilege)
    }
}
///  backupSynchronicity
public class BackupSynchronicity:NSObject,Codable{
    /// 跨地域备份同步服务ID
    var serviceId:String?
    /// RDS 实例ID
    var instanceId:String?
    /// 跨地域备份同步服务状态，正常，running；错误，error
    var serviceStatus:String?
    /// 源实例所在地域
    var srcRegion:String?
    /// 备份同步的目标地域
    var destRegion:String?
    /// 数据库类型
    var engine:String?
    /// 数据库版本
    var engineVersion:String?
    /// 创建时间
    var createTime:String?
    /// 跨地域备份的最新数据时间点
    var newestDataTime:String?



    public override init(){
            super.init()
    }

    enum BackupSynchronicityCodingKeys: String, CodingKey {
        case serviceId
        case instanceId
        case serviceStatus
        case srcRegion
        case destRegion
        case engine
        case engineVersion
        case createTime
        case newestDataTime
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: BackupSynchronicityCodingKeys.self)
        if decoderContainer.contains(.serviceId)
        {
            self.serviceId = try decoderContainer.decode(String?.self, forKey: .serviceId)
        }
        if decoderContainer.contains(.instanceId)
        {
            self.instanceId = try decoderContainer.decode(String?.self, forKey: .instanceId)
        }
        if decoderContainer.contains(.serviceStatus)
        {
            self.serviceStatus = try decoderContainer.decode(String?.self, forKey: .serviceStatus)
        }
        if decoderContainer.contains(.srcRegion)
        {
            self.srcRegion = try decoderContainer.decode(String?.self, forKey: .srcRegion)
        }
        if decoderContainer.contains(.destRegion)
        {
            self.destRegion = try decoderContainer.decode(String?.self, forKey: .destRegion)
        }
        if decoderContainer.contains(.engine)
        {
            self.engine = try decoderContainer.decode(String?.self, forKey: .engine)
        }
        if decoderContainer.contains(.engineVersion)
        {
            self.engineVersion = try decoderContainer.decode(String?.self, forKey: .engineVersion)
        }
        if decoderContainer.contains(.createTime)
        {
            self.createTime = try decoderContainer.decode(String?.self, forKey: .createTime)
        }
        if decoderContainer.contains(.newestDataTime)
        {
            self.newestDataTime = try decoderContainer.decode(String?.self, forKey: .newestDataTime)
        }
    }
}
public extension BackupSynchronicity{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: BackupSynchronicityCodingKeys.self)
         try encoderContainer.encode(serviceId, forKey: .serviceId)
         try encoderContainer.encode(instanceId, forKey: .instanceId)
         try encoderContainer.encode(serviceStatus, forKey: .serviceStatus)
         try encoderContainer.encode(srcRegion, forKey: .srcRegion)
         try encoderContainer.encode(destRegion, forKey: .destRegion)
         try encoderContainer.encode(engine, forKey: .engine)
         try encoderContainer.encode(engineVersion, forKey: .engineVersion)
         try encoderContainer.encode(createTime, forKey: .createTime)
         try encoderContainer.encode(newestDataTime, forKey: .newestDataTime)
    }
}
///  account
public class Account:NSObject,Codable{
    /// 账号名，账号名的具体规则可参见帮助中心文档:[名称及密码限制](../../../documentation/Database-and-Cache-Service/RDS/Introduction/Restrictions/SQLServer-Restrictions.md)
    var accountName:String?
    /// 账号状态，参见[枚举参数定义](../Enum-Definitions/Enum-Definitions.md)&lt;br&gt;- **MySQL：不支持，不返回该字段**&lt;br&gt;- **SQL Server：返回该字段**
    var accountStatus:String?
    /// 具有的权限
    var accountPrivileges:[AccountPrivilege?]?



    public override init(){
            super.init()
    }

    enum AccountCodingKeys: String, CodingKey {
        case accountName
        case accountStatus
        case accountPrivileges
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: AccountCodingKeys.self)
        if decoderContainer.contains(.accountName)
        {
            self.accountName = try decoderContainer.decode(String?.self, forKey: .accountName)
        }
        if decoderContainer.contains(.accountStatus)
        {
            self.accountStatus = try decoderContainer.decode(String?.self, forKey: .accountStatus)
        }
        if decoderContainer.contains(.accountPrivileges)
        {
            self.accountPrivileges = try decoderContainer.decode([AccountPrivilege?]?.self, forKey: .accountPrivileges)
        }
    }
}
public extension Account{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: AccountCodingKeys.self)
         try encoderContainer.encode(accountName, forKey: .accountName)
         try encoderContainer.encode(accountStatus, forKey: .accountStatus)
         try encoderContainer.encode(accountPrivileges, forKey: .accountPrivileges)
    }
}
///  accountPrivilege
public class AccountPrivilege:NSObject,Codable{
    /// 数据库名称，具体规则可参见帮助中心文档:[名称及密码限制](../../../documentation/Database-and-Cache-Service/RDS/Introduction/Restrictions/SQLServer-Restrictions.md)
    var dbName:String?
    /// 账号对数据库所具有的权限，权限的具体定义可以参见[枚举参数定义](../Enum-Definitions/Enum-Definitions.md)
    var privilege:String?



    public override init(){
            super.init()
    }

    enum AccountPrivilegeCodingKeys: String, CodingKey {
        case dbName
        case privilege
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: AccountPrivilegeCodingKeys.self)
        if decoderContainer.contains(.dbName)
        {
            self.dbName = try decoderContainer.decode(String?.self, forKey: .dbName)
        }
        if decoderContainer.contains(.privilege)
        {
            self.privilege = try decoderContainer.decode(String?.self, forKey: .privilege)
        }
    }
}
public extension AccountPrivilege{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: AccountPrivilegeCodingKeys.self)
         try encoderContainer.encode(dbName, forKey: .dbName)
         try encoderContainer.encode(privilege, forKey: .privilege)
    }
}
///  missingIndexResult
public class MissingIndexResult:NSObject,Codable{
    /// 数据库名
    var db:String?
    /// 表名
    var table:String?
    /// 构成相等谓词的列的逗号分隔列表，谓词的形式如下：&lt;br&gt;table.column &#x3D;constant_value
    var equalityColumns:String?
    /// 用于查询的涵盖列的逗号分隔列表,即创建索引的SQL语句中，Include后的字段
    var inequalityColumns:String?
    /// 构成不等谓词的列的逗号分隔列表，例如以下形式的谓词：&lt;br&gt;table.column &gt; constant_value&lt;br&gt;“&#x3D;”之外的任何比较运算符都表示不相等。
    var includedColumns:String?
    /// 实现此缺失索引后，用户查询可能获得的平均百分比收益。 该值表示如果实现此缺失索引，则查询成本将按此百分比平均下降。
    var avgUserImpact:Double?
    /// 由可能使用了组中建议索引的用户查询所导致的扫描次数。
    var userScans:Int?
    /// 由可能使用了组中建议索引的用户查询所导致的搜索次数。
    var userSeeks:Int?



    public override init(){
            super.init()
    }

    enum MissingIndexResultCodingKeys: String, CodingKey {
        case db
        case table
        case equalityColumns
        case inequalityColumns
        case includedColumns
        case avgUserImpact
        case userScans
        case userSeeks
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: MissingIndexResultCodingKeys.self)
        if decoderContainer.contains(.db)
        {
            self.db = try decoderContainer.decode(String?.self, forKey: .db)
        }
        if decoderContainer.contains(.table)
        {
            self.table = try decoderContainer.decode(String?.self, forKey: .table)
        }
        if decoderContainer.contains(.equalityColumns)
        {
            self.equalityColumns = try decoderContainer.decode(String?.self, forKey: .equalityColumns)
        }
        if decoderContainer.contains(.inequalityColumns)
        {
            self.inequalityColumns = try decoderContainer.decode(String?.self, forKey: .inequalityColumns)
        }
        if decoderContainer.contains(.includedColumns)
        {
            self.includedColumns = try decoderContainer.decode(String?.self, forKey: .includedColumns)
        }
        if decoderContainer.contains(.avgUserImpact)
        {
            self.avgUserImpact = try decoderContainer.decode(Double?.self, forKey: .avgUserImpact)
        }
        if decoderContainer.contains(.userScans)
        {
            self.userScans = try decoderContainer.decode(Int?.self, forKey: .userScans)
        }
        if decoderContainer.contains(.userSeeks)
        {
            self.userSeeks = try decoderContainer.decode(Int?.self, forKey: .userSeeks)
        }
    }
}
public extension MissingIndexResult{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: MissingIndexResultCodingKeys.self)
         try encoderContainer.encode(db, forKey: .db)
         try encoderContainer.encode(table, forKey: .table)
         try encoderContainer.encode(equalityColumns, forKey: .equalityColumns)
         try encoderContainer.encode(inequalityColumns, forKey: .inequalityColumns)
         try encoderContainer.encode(includedColumns, forKey: .includedColumns)
         try encoderContainer.encode(avgUserImpact, forKey: .avgUserImpact)
         try encoderContainer.encode(userScans, forKey: .userScans)
         try encoderContainer.encode(userSeeks, forKey: .userSeeks)
    }
}
///  queryPerformanceResult
public class QueryPerformanceResult:NSObject,Codable{
    /// sql语句
    var sql:String?
    /// 上次执行时间，格式为YYYY-MM-DD hh:mm:ss
    var lastExecutionTime:String?
    /// 平均执行时长，单位毫秒(ms)
    var elapsedTime:Int?
    /// 执行次数
    var executionCount:Int?
    /// 平均CPU使用时间，单位毫秒(ms)
    var workerTime:Int?
    /// 平均逻辑读次数
    var logicalReads:Int?
    /// 平均逻辑写次数
    var logicalWrites:Int?
    /// 平均物理读次数
    var physicalReads:Int?
    /// 上次返回记录数
    var lastRows:Int?



    public override init(){
            super.init()
    }

    enum QueryPerformanceResultCodingKeys: String, CodingKey {
        case sql
        case lastExecutionTime
        case elapsedTime
        case executionCount
        case workerTime
        case logicalReads
        case logicalWrites
        case physicalReads
        case lastRows
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: QueryPerformanceResultCodingKeys.self)
        if decoderContainer.contains(.sql)
        {
            self.sql = try decoderContainer.decode(String?.self, forKey: .sql)
        }
        if decoderContainer.contains(.lastExecutionTime)
        {
            self.lastExecutionTime = try decoderContainer.decode(String?.self, forKey: .lastExecutionTime)
        }
        if decoderContainer.contains(.elapsedTime)
        {
            self.elapsedTime = try decoderContainer.decode(Int?.self, forKey: .elapsedTime)
        }
        if decoderContainer.contains(.executionCount)
        {
            self.executionCount = try decoderContainer.decode(Int?.self, forKey: .executionCount)
        }
        if decoderContainer.contains(.workerTime)
        {
            self.workerTime = try decoderContainer.decode(Int?.self, forKey: .workerTime)
        }
        if decoderContainer.contains(.logicalReads)
        {
            self.logicalReads = try decoderContainer.decode(Int?.self, forKey: .logicalReads)
        }
        if decoderContainer.contains(.logicalWrites)
        {
            self.logicalWrites = try decoderContainer.decode(Int?.self, forKey: .logicalWrites)
        }
        if decoderContainer.contains(.physicalReads)
        {
            self.physicalReads = try decoderContainer.decode(Int?.self, forKey: .physicalReads)
        }
        if decoderContainer.contains(.lastRows)
        {
            self.lastRows = try decoderContainer.decode(Int?.self, forKey: .lastRows)
        }
    }
}
public extension QueryPerformanceResult{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: QueryPerformanceResultCodingKeys.self)
         try encoderContainer.encode(sql, forKey: .sql)
         try encoderContainer.encode(lastExecutionTime, forKey: .lastExecutionTime)
         try encoderContainer.encode(elapsedTime, forKey: .elapsedTime)
         try encoderContainer.encode(executionCount, forKey: .executionCount)
         try encoderContainer.encode(workerTime, forKey: .workerTime)
         try encoderContainer.encode(logicalReads, forKey: .logicalReads)
         try encoderContainer.encode(logicalWrites, forKey: .logicalWrites)
         try encoderContainer.encode(physicalReads, forKey: .physicalReads)
         try encoderContainer.encode(lastRows, forKey: .lastRows)
    }
}
///  slowLogDigest
public class SlowLogDigest:NSObject,Codable{
    /// 数据库名，表示该SQL是在哪个数据库中执行的
    var dbName:String?
    /// SQL语句
    var sql:String?
    /// SQL语句执行的开始时间，格式为YYYY-MM-DD hh:mm:ss
    var executionTime:String?
    /// SQL语句的执行次数
    var executionCount:Int?
    /// SQL语句执行的时长，单位秒
    var elapsedTime:DigestData?
    /// SQL语句等待锁的时间，单位秒
    var lockTime:DigestData?
    /// SQL语句的长度
    var sqlLength:DigestData?
    /// SQL语句扫描的行数
    var rowsExamined:DigestData?
    /// SQL语句返回的行数
    var rowsReturned:DigestData?



    public override init(){
            super.init()
    }

    enum SlowLogDigestCodingKeys: String, CodingKey {
        case dbName
        case sql
        case executionTime
        case executionCount
        case elapsedTime
        case lockTime
        case sqlLength
        case rowsExamined
        case rowsReturned
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: SlowLogDigestCodingKeys.self)
        if decoderContainer.contains(.dbName)
        {
            self.dbName = try decoderContainer.decode(String?.self, forKey: .dbName)
        }
        if decoderContainer.contains(.sql)
        {
            self.sql = try decoderContainer.decode(String?.self, forKey: .sql)
        }
        if decoderContainer.contains(.executionTime)
        {
            self.executionTime = try decoderContainer.decode(String?.self, forKey: .executionTime)
        }
        if decoderContainer.contains(.executionCount)
        {
            self.executionCount = try decoderContainer.decode(Int?.self, forKey: .executionCount)
        }
        if decoderContainer.contains(.elapsedTime)
        {
            self.elapsedTime = try decoderContainer.decode(DigestData?.self, forKey: .elapsedTime)
        }
        if decoderContainer.contains(.lockTime)
        {
            self.lockTime = try decoderContainer.decode(DigestData?.self, forKey: .lockTime)
        }
        if decoderContainer.contains(.sqlLength)
        {
            self.sqlLength = try decoderContainer.decode(DigestData?.self, forKey: .sqlLength)
        }
        if decoderContainer.contains(.rowsExamined)
        {
            self.rowsExamined = try decoderContainer.decode(DigestData?.self, forKey: .rowsExamined)
        }
        if decoderContainer.contains(.rowsReturned)
        {
            self.rowsReturned = try decoderContainer.decode(DigestData?.self, forKey: .rowsReturned)
        }
    }
}
public extension SlowLogDigest{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: SlowLogDigestCodingKeys.self)
         try encoderContainer.encode(dbName, forKey: .dbName)
         try encoderContainer.encode(sql, forKey: .sql)
         try encoderContainer.encode(executionTime, forKey: .executionTime)
         try encoderContainer.encode(executionCount, forKey: .executionCount)
         try encoderContainer.encode(elapsedTime, forKey: .elapsedTime)
         try encoderContainer.encode(lockTime, forKey: .lockTime)
         try encoderContainer.encode(sqlLength, forKey: .sqlLength)
         try encoderContainer.encode(rowsExamined, forKey: .rowsExamined)
         try encoderContainer.encode(rowsReturned, forKey: .rowsReturned)
    }
}
///  indexPerformanceResult
public class IndexPerformanceResult:NSObject,Codable{
    /// 数据库名
    var db:String?
    /// 表名
    var table:String?
    /// 索引名
    var index:String?
    /// 索引大小，单位KB
    var sizeKB:Int?
    /// 服务器启动以来，累计索引搜索次数
    var userSeeks:Int?
    /// 服务器启动以来，累计表扫描次数
    var userScans:Int?
    /// 服务器启动以来，累计索引更新次数
    var userUpdates:Int?
    /// 最近索引搜索时间，格式为YYYY-MM-DD hh:mm:ss
    var lastUserSeek:String?
    /// 最近表扫描时间，格式为YYYY-MM-DD hh:mm:ss
    var lastUserScan:String?
    /// 最近索引更新时间，格式为YYYY-MM-DD hh:mm:ss
    var lastUserUpdate:String?



    public override init(){
            super.init()
    }

    enum IndexPerformanceResultCodingKeys: String, CodingKey {
        case db
        case table
        case index
        case sizeKB
        case userSeeks
        case userScans
        case userUpdates
        case lastUserSeek
        case lastUserScan
        case lastUserUpdate
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: IndexPerformanceResultCodingKeys.self)
        if decoderContainer.contains(.db)
        {
            self.db = try decoderContainer.decode(String?.self, forKey: .db)
        }
        if decoderContainer.contains(.table)
        {
            self.table = try decoderContainer.decode(String?.self, forKey: .table)
        }
        if decoderContainer.contains(.index)
        {
            self.index = try decoderContainer.decode(String?.self, forKey: .index)
        }
        if decoderContainer.contains(.sizeKB)
        {
            self.sizeKB = try decoderContainer.decode(Int?.self, forKey: .sizeKB)
        }
        if decoderContainer.contains(.userSeeks)
        {
            self.userSeeks = try decoderContainer.decode(Int?.self, forKey: .userSeeks)
        }
        if decoderContainer.contains(.userScans)
        {
            self.userScans = try decoderContainer.decode(Int?.self, forKey: .userScans)
        }
        if decoderContainer.contains(.userUpdates)
        {
            self.userUpdates = try decoderContainer.decode(Int?.self, forKey: .userUpdates)
        }
        if decoderContainer.contains(.lastUserSeek)
        {
            self.lastUserSeek = try decoderContainer.decode(String?.self, forKey: .lastUserSeek)
        }
        if decoderContainer.contains(.lastUserScan)
        {
            self.lastUserScan = try decoderContainer.decode(String?.self, forKey: .lastUserScan)
        }
        if decoderContainer.contains(.lastUserUpdate)
        {
            self.lastUserUpdate = try decoderContainer.decode(String?.self, forKey: .lastUserUpdate)
        }
    }
}
public extension IndexPerformanceResult{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: IndexPerformanceResultCodingKeys.self)
         try encoderContainer.encode(db, forKey: .db)
         try encoderContainer.encode(table, forKey: .table)
         try encoderContainer.encode(index, forKey: .index)
         try encoderContainer.encode(sizeKB, forKey: .sizeKB)
         try encoderContainer.encode(userSeeks, forKey: .userSeeks)
         try encoderContainer.encode(userScans, forKey: .userScans)
         try encoderContainer.encode(userUpdates, forKey: .userUpdates)
         try encoderContainer.encode(lastUserSeek, forKey: .lastUserSeek)
         try encoderContainer.encode(lastUserScan, forKey: .lastUserScan)
         try encoderContainer.encode(lastUserUpdate, forKey: .lastUserUpdate)
    }
}
///  activeQueryPerformanceResult
public class ActiveQueryPerformanceResult:NSObject,Codable{
    /// sql语句
    var sql:String?
    /// 开始执行时间，格式为YYYY-MM-DD hh:mm:ss
    var startTime:String?
    /// 执行时长，单位秒
    var elapsedTime:Int?
    /// 数据库名
    var db:String?
    /// 该SQL执行时的Session ID
    var sessionId:String?
    /// 执行该SQL的用户名
    var user:String?
    /// SQL 的执行状态
    var status:String?



    public override init(){
            super.init()
    }

    enum ActiveQueryPerformanceResultCodingKeys: String, CodingKey {
        case sql
        case startTime
        case elapsedTime
        case db
        case sessionId
        case user
        case status
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: ActiveQueryPerformanceResultCodingKeys.self)
        if decoderContainer.contains(.sql)
        {
            self.sql = try decoderContainer.decode(String?.self, forKey: .sql)
        }
        if decoderContainer.contains(.startTime)
        {
            self.startTime = try decoderContainer.decode(String?.self, forKey: .startTime)
        }
        if decoderContainer.contains(.elapsedTime)
        {
            self.elapsedTime = try decoderContainer.decode(Int?.self, forKey: .elapsedTime)
        }
        if decoderContainer.contains(.db)
        {
            self.db = try decoderContainer.decode(String?.self, forKey: .db)
        }
        if decoderContainer.contains(.sessionId)
        {
            self.sessionId = try decoderContainer.decode(String?.self, forKey: .sessionId)
        }
        if decoderContainer.contains(.user)
        {
            self.user = try decoderContainer.decode(String?.self, forKey: .user)
        }
        if decoderContainer.contains(.status)
        {
            self.status = try decoderContainer.decode(String?.self, forKey: .status)
        }
    }
}
public extension ActiveQueryPerformanceResult{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: ActiveQueryPerformanceResultCodingKeys.self)
         try encoderContainer.encode(sql, forKey: .sql)
         try encoderContainer.encode(startTime, forKey: .startTime)
         try encoderContainer.encode(elapsedTime, forKey: .elapsedTime)
         try encoderContainer.encode(db, forKey: .db)
         try encoderContainer.encode(sessionId, forKey: .sessionId)
         try encoderContainer.encode(user, forKey: .user)
         try encoderContainer.encode(status, forKey: .status)
    }
}
///  digestData
public class DigestData:NSObject,Codable{
    /// 表示执行结果中95% 数据小于或等于此数值
    var pct95:Double?
    /// 执行结果的最大值
    var max:Double?
    /// 执行结果的平均值
    var avg:Double?
    /// 执行结果的最小值
    var min:Double?
    /// 执行结果的合计值
    var total:Double?



    public override init(){
            super.init()
    }

    enum DigestDataCodingKeys: String, CodingKey {
        case pct95
        case max
        case avg
        case min
        case total
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: DigestDataCodingKeys.self)
        if decoderContainer.contains(.pct95)
        {
            self.pct95 = try decoderContainer.decode(Double?.self, forKey: .pct95)
        }
        if decoderContainer.contains(.max)
        {
            self.max = try decoderContainer.decode(Double?.self, forKey: .max)
        }
        if decoderContainer.contains(.avg)
        {
            self.avg = try decoderContainer.decode(Double?.self, forKey: .avg)
        }
        if decoderContainer.contains(.min)
        {
            self.min = try decoderContainer.decode(Double?.self, forKey: .min)
        }
        if decoderContainer.contains(.total)
        {
            self.total = try decoderContainer.decode(Double?.self, forKey: .total)
        }
    }
}
public extension DigestData{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: DigestDataCodingKeys.self)
         try encoderContainer.encode(pct95, forKey: .pct95)
         try encoderContainer.encode(max, forKey: .max)
         try encoderContainer.encode(avg, forKey: .avg)
         try encoderContainer.encode(min, forKey: .min)
         try encoderContainer.encode(total, forKey: .total)
    }
}
///  slowLogAttributes
public class SlowLogAttributes:NSObject,Codable{
    /// 数据库名，表示该SQL是在哪个数据库中执行的
    var dbName:String?
    /// SQL语句
    var sql:String?
    /// SQL语句执行的开始时间，格式为YYYY-MM-DD hh:mm:ss
    var executionTime:String?
    /// SQL语句执行的时长，单位秒
    var elapsedTime:Double?
    /// SQL语句等待锁的时间，单位秒
    var lockTime:Double?
    /// SQL语句扫描的行数
    var rowsExamined:Int?
    /// SQL语句返回的行数
    var rowsReturned:Int?



    public override init(){
            super.init()
    }

    enum SlowLogAttributesCodingKeys: String, CodingKey {
        case dbName
        case sql
        case executionTime
        case elapsedTime
        case lockTime
        case rowsExamined
        case rowsReturned
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: SlowLogAttributesCodingKeys.self)
        if decoderContainer.contains(.dbName)
        {
            self.dbName = try decoderContainer.decode(String?.self, forKey: .dbName)
        }
        if decoderContainer.contains(.sql)
        {
            self.sql = try decoderContainer.decode(String?.self, forKey: .sql)
        }
        if decoderContainer.contains(.executionTime)
        {
            self.executionTime = try decoderContainer.decode(String?.self, forKey: .executionTime)
        }
        if decoderContainer.contains(.elapsedTime)
        {
            self.elapsedTime = try decoderContainer.decode(Double?.self, forKey: .elapsedTime)
        }
        if decoderContainer.contains(.lockTime)
        {
            self.lockTime = try decoderContainer.decode(Double?.self, forKey: .lockTime)
        }
        if decoderContainer.contains(.rowsExamined)
        {
            self.rowsExamined = try decoderContainer.decode(Int?.self, forKey: .rowsExamined)
        }
        if decoderContainer.contains(.rowsReturned)
        {
            self.rowsReturned = try decoderContainer.decode(Int?.self, forKey: .rowsReturned)
        }
    }
}
public extension SlowLogAttributes{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: SlowLogAttributesCodingKeys.self)
         try encoderContainer.encode(dbName, forKey: .dbName)
         try encoderContainer.encode(sql, forKey: .sql)
         try encoderContainer.encode(executionTime, forKey: .executionTime)
         try encoderContainer.encode(elapsedTime, forKey: .elapsedTime)
         try encoderContainer.encode(lockTime, forKey: .lockTime)
         try encoderContainer.encode(rowsExamined, forKey: .rowsExamined)
         try encoderContainer.encode(rowsReturned, forKey: .rowsReturned)
    }
}
///  dBInstanceParameter
public class DBInstanceParameter:NSObject,Codable{
    /// 参数名称
    var name:String?
    /// 参数描述
    var descriptionValue:String?
    /// 参数修改后的数值，但不一定生效，需要视该参数生效是否需要重启
    var configureValue:String?
    /// 当前在实例中生效的数值
    var runningValue:String?
    /// 该参数数值的允许范围
    var range:String?
    /// 修改是否需要重启生效.- true:参数需要重启才能生效- false:参数生效无需重启
    var needRestart:String?



    public override init(){
            super.init()
    }

    enum DBInstanceParameterCodingKeys: String, CodingKey {
        case name
        case descriptionValue = "description"
        case configureValue
        case runningValue
        case range
        case needRestart
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: DBInstanceParameterCodingKeys.self)
        if decoderContainer.contains(.name)
        {
            self.name = try decoderContainer.decode(String?.self, forKey: .name)
        }
        if decoderContainer.contains(.descriptionValue)
        {
            self.descriptionValue = try decoderContainer.decode(String?.self, forKey: .descriptionValue)
        }
        if decoderContainer.contains(.configureValue)
        {
            self.configureValue = try decoderContainer.decode(String?.self, forKey: .configureValue)
        }
        if decoderContainer.contains(.runningValue)
        {
            self.runningValue = try decoderContainer.decode(String?.self, forKey: .runningValue)
        }
        if decoderContainer.contains(.range)
        {
            self.range = try decoderContainer.decode(String?.self, forKey: .range)
        }
        if decoderContainer.contains(.needRestart)
        {
            self.needRestart = try decoderContainer.decode(String?.self, forKey: .needRestart)
        }
    }
}
public extension DBInstanceParameter{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: DBInstanceParameterCodingKeys.self)
         try encoderContainer.encode(name, forKey: .name)
         try encoderContainer.encode(descriptionValue, forKey: .descriptionValue)
         try encoderContainer.encode(configureValue, forKey: .configureValue)
         try encoderContainer.encode(runningValue, forKey: .runningValue)
         try encoderContainer.encode(range, forKey: .range)
         try encoderContainer.encode(needRestart, forKey: .needRestart)
    }
}
///  parameter
public class Parameter:NSObject,Codable{
    /// 参数名称
    /// Required:true
    var name:String
    /// 参数修改值
    /// Required:true
    var value:String



    public  init(name:String,value:String){
             self.name = name
             self.value = value
    }

    enum ParameterCodingKeys: String, CodingKey {
        case name
        case value
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: ParameterCodingKeys.self)
        self.name = try decoderContainer.decode(String.self, forKey: .name)
        self.value = try decoderContainer.decode(String.self, forKey: .value)
    }
}
public extension Parameter{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: ParameterCodingKeys.self)
         try encoderContainer.encode(name, forKey: .name)
         try encoderContainer.encode(value, forKey: .value)
    }
}
///  parameterGroupParameter
public class ParameterGroupParameter:NSObject,Codable{
    /// 参数名称
    var name:String?
    /// 参数描述
    var descriptionValue:String?
    /// 参数修改后的数值，但不一定生效，需要视该参数生效是否需要重启
    var configureValue:String?
    /// 参数默认值
    var defaultValue:String?
    /// 该参数数值的允许修改范围
    var range:String?
    /// 参数数值的类型
    var type:String?
    /// 参数修改是否需要重启生效.- true:参数需要重启才能生效- false:参数生效无需重启
    var needRestart:String?



    public override init(){
            super.init()
    }

    enum ParameterGroupParameterCodingKeys: String, CodingKey {
        case name
        case descriptionValue = "description"
        case configureValue
        case defaultValue
        case range
        case type
        case needRestart
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: ParameterGroupParameterCodingKeys.self)
        if decoderContainer.contains(.name)
        {
            self.name = try decoderContainer.decode(String?.self, forKey: .name)
        }
        if decoderContainer.contains(.descriptionValue)
        {
            self.descriptionValue = try decoderContainer.decode(String?.self, forKey: .descriptionValue)
        }
        if decoderContainer.contains(.configureValue)
        {
            self.configureValue = try decoderContainer.decode(String?.self, forKey: .configureValue)
        }
        if decoderContainer.contains(.defaultValue)
        {
            self.defaultValue = try decoderContainer.decode(String?.self, forKey: .defaultValue)
        }
        if decoderContainer.contains(.range)
        {
            self.range = try decoderContainer.decode(String?.self, forKey: .range)
        }
        if decoderContainer.contains(.type)
        {
            self.type = try decoderContainer.decode(String?.self, forKey: .type)
        }
        if decoderContainer.contains(.needRestart)
        {
            self.needRestart = try decoderContainer.decode(String?.self, forKey: .needRestart)
        }
    }
}
public extension ParameterGroupParameter{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: ParameterGroupParameterCodingKeys.self)
         try encoderContainer.encode(name, forKey: .name)
         try encoderContainer.encode(descriptionValue, forKey: .descriptionValue)
         try encoderContainer.encode(configureValue, forKey: .configureValue)
         try encoderContainer.encode(defaultValue, forKey: .defaultValue)
         try encoderContainer.encode(range, forKey: .range)
         try encoderContainer.encode(type, forKey: .type)
         try encoderContainer.encode(needRestart, forKey: .needRestart)
    }
}
///  parameterGroup
public class ParameterGroup:NSObject,Codable{
    /// 参数组ID
    var parameterGroupId:String?
    /// 参数组名称
    var parameterGroupName:String?
    /// 参数组状态
    var parameterGroupStatus:String?
    /// 参数组描述
    var descriptionValue:String?
    /// 实例引擎类型
    var engine:String?
    /// 数据库版本
    var engineVersion:String?
    /// 地域代码，取值范围参见[《各地域及可用区对照表》](../Enum-Definitions/Regions-AZ.md)
    var regionId:String?
    /// 参数组创建时间
    var createTime:String?



    public override init(){
            super.init()
    }

    enum ParameterGroupCodingKeys: String, CodingKey {
        case parameterGroupId
        case parameterGroupName
        case parameterGroupStatus
        case descriptionValue = "description"
        case engine
        case engineVersion
        case regionId
        case createTime
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: ParameterGroupCodingKeys.self)
        if decoderContainer.contains(.parameterGroupId)
        {
            self.parameterGroupId = try decoderContainer.decode(String?.self, forKey: .parameterGroupId)
        }
        if decoderContainer.contains(.parameterGroupName)
        {
            self.parameterGroupName = try decoderContainer.decode(String?.self, forKey: .parameterGroupName)
        }
        if decoderContainer.contains(.parameterGroupStatus)
        {
            self.parameterGroupStatus = try decoderContainer.decode(String?.self, forKey: .parameterGroupStatus)
        }
        if decoderContainer.contains(.descriptionValue)
        {
            self.descriptionValue = try decoderContainer.decode(String?.self, forKey: .descriptionValue)
        }
        if decoderContainer.contains(.engine)
        {
            self.engine = try decoderContainer.decode(String?.self, forKey: .engine)
        }
        if decoderContainer.contains(.engineVersion)
        {
            self.engineVersion = try decoderContainer.decode(String?.self, forKey: .engineVersion)
        }
        if decoderContainer.contains(.regionId)
        {
            self.regionId = try decoderContainer.decode(String?.self, forKey: .regionId)
        }
        if decoderContainer.contains(.createTime)
        {
            self.createTime = try decoderContainer.decode(String?.self, forKey: .createTime)
        }
    }
}
public extension ParameterGroup{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: ParameterGroupCodingKeys.self)
         try encoderContainer.encode(parameterGroupId, forKey: .parameterGroupId)
         try encoderContainer.encode(parameterGroupName, forKey: .parameterGroupName)
         try encoderContainer.encode(parameterGroupStatus, forKey: .parameterGroupStatus)
         try encoderContainer.encode(descriptionValue, forKey: .descriptionValue)
         try encoderContainer.encode(engine, forKey: .engine)
         try encoderContainer.encode(engineVersion, forKey: .engineVersion)
         try encoderContainer.encode(regionId, forKey: .regionId)
         try encoderContainer.encode(createTime, forKey: .createTime)
    }
}
///  parameterModifyRecords
public class ParameterModifyRecords:NSObject,Codable{
    /// 参数名称
    var name:String?
    /// 修改前的参数值
    var preModify:String?
    /// 修改后的参数值
    var postModify:String?
    /// 修改时间
    var updateTime:String?



    public override init(){
            super.init()
    }

    enum ParameterModifyRecordsCodingKeys: String, CodingKey {
        case name
        case preModify
        case postModify
        case updateTime
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: ParameterModifyRecordsCodingKeys.self)
        if decoderContainer.contains(.name)
        {
            self.name = try decoderContainer.decode(String?.self, forKey: .name)
        }
        if decoderContainer.contains(.preModify)
        {
            self.preModify = try decoderContainer.decode(String?.self, forKey: .preModify)
        }
        if decoderContainer.contains(.postModify)
        {
            self.postModify = try decoderContainer.decode(String?.self, forKey: .postModify)
        }
        if decoderContainer.contains(.updateTime)
        {
            self.updateTime = try decoderContainer.decode(String?.self, forKey: .updateTime)
        }
    }
}
public extension ParameterModifyRecords{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: ParameterModifyRecordsCodingKeys.self)
         try encoderContainer.encode(name, forKey: .name)
         try encoderContainer.encode(preModify, forKey: .preModify)
         try encoderContainer.encode(postModify, forKey: .postModify)
         try encoderContainer.encode(updateTime, forKey: .updateTime)
    }
}
///  attachedDBInstance
public class AttachedDBInstance:NSObject,Codable{
    /// 实例ID
    var instanceId:String?
    /// 实例名称，具体规则可参见帮助中心文档:[名称及密码限制](../../../documentation/Database-and-Cache-Service/RDS/Introduction/Restrictions/SQLServer-Restrictions.md)
    var instanceName:String?
    /// 实例类型，例如主实例，只读实例等，参见[枚举参数定义](../Enum-Definitions/Enum-Definitions.md)
    var instanceType:String?
    /// 实例引擎类型，如MySQL或SQL Server等，参见[枚举参数定义](../Enum-Definitions/Enum-Definitions.md)
    var engine:String?
    /// 实例引擎版本，参见[枚举参数定义](../Enum-Definitions/Enum-Definitions.md)
    var engineVersion:String?
    /// 参数组ID
    var parameterGroupId:String?
    /// 参数的状态，参见[枚举参数定义](../Enum-Definitions/Enum-Definitions.md)
    var parameterStatus:String?
    /// 实例状态，参见[枚举参数定义](../Enum-Definitions/Enum-Definitions.md)
    var instanceStatus:String?
    /// 实例创建时间
    var createTime:String?



    public override init(){
            super.init()
    }

    enum AttachedDBInstanceCodingKeys: String, CodingKey {
        case instanceId
        case instanceName
        case instanceType
        case engine
        case engineVersion
        case parameterGroupId
        case parameterStatus
        case instanceStatus
        case createTime
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: AttachedDBInstanceCodingKeys.self)
        if decoderContainer.contains(.instanceId)
        {
            self.instanceId = try decoderContainer.decode(String?.self, forKey: .instanceId)
        }
        if decoderContainer.contains(.instanceName)
        {
            self.instanceName = try decoderContainer.decode(String?.self, forKey: .instanceName)
        }
        if decoderContainer.contains(.instanceType)
        {
            self.instanceType = try decoderContainer.decode(String?.self, forKey: .instanceType)
        }
        if decoderContainer.contains(.engine)
        {
            self.engine = try decoderContainer.decode(String?.self, forKey: .engine)
        }
        if decoderContainer.contains(.engineVersion)
        {
            self.engineVersion = try decoderContainer.decode(String?.self, forKey: .engineVersion)
        }
        if decoderContainer.contains(.parameterGroupId)
        {
            self.parameterGroupId = try decoderContainer.decode(String?.self, forKey: .parameterGroupId)
        }
        if decoderContainer.contains(.parameterStatus)
        {
            self.parameterStatus = try decoderContainer.decode(String?.self, forKey: .parameterStatus)
        }
        if decoderContainer.contains(.instanceStatus)
        {
            self.instanceStatus = try decoderContainer.decode(String?.self, forKey: .instanceStatus)
        }
        if decoderContainer.contains(.createTime)
        {
            self.createTime = try decoderContainer.decode(String?.self, forKey: .createTime)
        }
    }
}
public extension AttachedDBInstance{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: AttachedDBInstanceCodingKeys.self)
         try encoderContainer.encode(instanceId, forKey: .instanceId)
         try encoderContainer.encode(instanceName, forKey: .instanceName)
         try encoderContainer.encode(instanceType, forKey: .instanceType)
         try encoderContainer.encode(engine, forKey: .engine)
         try encoderContainer.encode(engineVersion, forKey: .engineVersion)
         try encoderContainer.encode(parameterGroupId, forKey: .parameterGroupId)
         try encoderContainer.encode(parameterStatus, forKey: .parameterStatus)
         try encoderContainer.encode(instanceStatus, forKey: .instanceStatus)
         try encoderContainer.encode(createTime, forKey: .createTime)
    }
}
///  fileDownloadURL
public class FileDownloadURL:NSObject,Codable{
    /// 公网下载链接，若当前不可下载，则为空串
    var publicURL:String?
    /// 内网下载链接，若当前不可下载，则为空串
    var internalURL:String?



    public override init(){
            super.init()
    }

    enum FileDownloadURLCodingKeys: String, CodingKey {
        case publicURL
        case internalURL
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: FileDownloadURLCodingKeys.self)
        if decoderContainer.contains(.publicURL)
        {
            self.publicURL = try decoderContainer.decode(String?.self, forKey: .publicURL)
        }
        if decoderContainer.contains(.internalURL)
        {
            self.internalURL = try decoderContainer.decode(String?.self, forKey: .internalURL)
        }
    }
}
public extension FileDownloadURL{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: FileDownloadURLCodingKeys.self)
         try encoderContainer.encode(publicURL, forKey: .publicURL)
         try encoderContainer.encode(internalURL, forKey: .internalURL)
    }
}
///  file
public class File:NSObject,Codable{
    /// 文件名
    var name:String?
    /// 文件大小，单位Byte
    var sizeByte:Int?



    public override init(){
            super.init()
    }

    enum FileCodingKeys: String, CodingKey {
        case name
        case sizeByte
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: FileCodingKeys.self)
        if decoderContainer.contains(.name)
        {
            self.name = try decoderContainer.decode(String?.self, forKey: .name)
        }
        if decoderContainer.contains(.sizeByte)
        {
            self.sizeByte = try decoderContainer.decode(Int?.self, forKey: .sizeByte)
        }
    }
}
public extension File{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: FileCodingKeys.self)
         try encoderContainer.encode(name, forKey: .name)
         try encoderContainer.encode(sizeByte, forKey: .sizeByte)
    }
}

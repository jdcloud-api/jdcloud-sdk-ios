/* Copyright 2018 JDCLOUD.COM

   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at

     http:#www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.

   
   

   
   Contact: 

   NOTE: This class is auto generated by the jdcloud code generator program.
 */


import Foundation

///  backup
@objc(Backup)
public class Backup:NSObject,Codable{
    /// 备份ID
    var backupId:String?
    /// 备份名称，最长支持64个英文字符或等长的中文字符
    var backupName:String?
    /// 备份所属实例ID
    var instanceId:String?
    /// 备份状态，请查看[枚举参数定义](../Enum-Definitions/Enum-Definitions.md)
    var backupStatus:String?
    /// 备份开始时间，格式为：YYYY-MM-DD HH:mm:ss
    var backupStartTime:String?
    /// 备份结束时间，格式为：YYYY-MM-DD HH:mm:ss&lt;br&gt;- **SQL Server支持**&lt;br&gt;- **MySQL不支持**
    var backupEndTime:String?
    /// 备份类型，全量备份或增量备份，请查看[枚举参数定义](../Enum-Definitions/Enum-Definitions.md)&lt;br&gt;- **SQL Server支持**&lt;br&gt;- **MySQL不支持**
    var backupType:String?
    /// 备份模式，系统自动备份或手动备份，请查看[枚举参数定义](../Enum-Definitions/Enum-Definitions.md)
    var backupMode:String?
    /// 备份粒度，实例备份或者多库备份，请查看[枚举参数定义](../Enum-Definitions/Enum-Definitions.md)&lt;br&gt;- **SQL Server支持**&lt;br&gt;- **MySQL不支持**
    var backupUnit:String?
    /// 备份文件列表&lt;br&gt;- **SQL Server支持**,备份可以有多个文件，文件名的命名规则为:&lt;br&gt;（1）全备：数据库名+.bak&lt;br&gt;（2）增量：数据库名+.diff&lt;br&gt;- **MySQL不支持**
    var backupFiles:[String?]?
    /// 整个备份集大小，单位：Byte
    var backupSizeByte:Int?



    public override init(){
            super.init()
    }

    enum BackupCodingKeys: String, CodingKey {
        case backupId
        case backupName
        case instanceId
        case backupStatus
        case backupStartTime
        case backupEndTime
        case backupType
        case backupMode
        case backupUnit
        case backupFiles
        case backupSizeByte
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: BackupCodingKeys.self)
        if decoderContainer.contains(.backupId)
        {
            self.backupId = try decoderContainer.decode(String?.self, forKey: .backupId)
        }
        if decoderContainer.contains(.backupName)
        {
            self.backupName = try decoderContainer.decode(String?.self, forKey: .backupName)
        }
        if decoderContainer.contains(.instanceId)
        {
            self.instanceId = try decoderContainer.decode(String?.self, forKey: .instanceId)
        }
        if decoderContainer.contains(.backupStatus)
        {
            self.backupStatus = try decoderContainer.decode(String?.self, forKey: .backupStatus)
        }
        if decoderContainer.contains(.backupStartTime)
        {
            self.backupStartTime = try decoderContainer.decode(String?.self, forKey: .backupStartTime)
        }
        if decoderContainer.contains(.backupEndTime)
        {
            self.backupEndTime = try decoderContainer.decode(String?.self, forKey: .backupEndTime)
        }
        if decoderContainer.contains(.backupType)
        {
            self.backupType = try decoderContainer.decode(String?.self, forKey: .backupType)
        }
        if decoderContainer.contains(.backupMode)
        {
            self.backupMode = try decoderContainer.decode(String?.self, forKey: .backupMode)
        }
        if decoderContainer.contains(.backupUnit)
        {
            self.backupUnit = try decoderContainer.decode(String?.self, forKey: .backupUnit)
        }
        if decoderContainer.contains(.backupFiles)
        {
            self.backupFiles = try decoderContainer.decode([String?]?.self, forKey: .backupFiles)
        }
        if decoderContainer.contains(.backupSizeByte)
        {
            self.backupSizeByte = try decoderContainer.decode(Int?.self, forKey: .backupSizeByte)
        }
    }
}
public extension Backup{
    public func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: BackupCodingKeys.self)
         try encoderContainer.encode(backupId, forKey: .backupId)
         try encoderContainer.encode(backupName, forKey: .backupName)
         try encoderContainer.encode(instanceId, forKey: .instanceId)
         try encoderContainer.encode(backupStatus, forKey: .backupStatus)
         try encoderContainer.encode(backupStartTime, forKey: .backupStartTime)
         try encoderContainer.encode(backupEndTime, forKey: .backupEndTime)
         try encoderContainer.encode(backupType, forKey: .backupType)
         try encoderContainer.encode(backupMode, forKey: .backupMode)
         try encoderContainer.encode(backupUnit, forKey: .backupUnit)
         try encoderContainer.encode(backupFiles, forKey: .backupFiles)
         try encoderContainer.encode(backupSizeByte, forKey: .backupSizeByte)
    }
}

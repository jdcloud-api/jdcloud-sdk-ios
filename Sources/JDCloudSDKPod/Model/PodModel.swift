/* Copyright 2018 JDCLOUD.COM

   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at

     http:#www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.

   Pod
   Pod 相关接口

   OpenAPI spec version: v1
   Contact: 

   NOTE: This class is auto generated by the jdcloud code generator program.
 */


import Foundation
import JDCloudSDKCharge
import JDCloudSDKVpc
///  quota
public class Quota:NSObject,Codable{
    /// 类型
    var resourceType:String?
    /// 配额
    var limit:Int?
    /// 已使用的数目
    var used:Int?



    public override init(){
            super.init()
    }

    enum QuotaCodingKeys: String, CodingKey {
        case resourceType
        case limit
        case used
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: QuotaCodingKeys.self)
        if decoderContainer.contains(.resourceType)
        {
            self.resourceType = try decoderContainer.decode(String?.self, forKey: .resourceType)
        }
        if decoderContainer.contains(.limit)
        {
            self.limit = try decoderContainer.decode(Int?.self, forKey: .limit)
        }
        if decoderContainer.contains(.used)
        {
            self.used = try decoderContainer.decode(Int?.self, forKey: .used)
        }
    }
}
public extension Quota{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: QuotaCodingKeys.self)
         try encoderContainer.encode(resourceType, forKey: .resourceType)
         try encoderContainer.encode(limit, forKey: .limit)
         try encoderContainer.encode(used, forKey: .used)
    }
}
///  instanceTypeState
public class InstanceTypeState:NSObject,Codable{
    /// 可用区
    var az:String?
    /// 可售卖情况，true:可售卖、false:已售罄不可用
    var inStock:Bool?
    /// 在线情况，true:在线、false:已下线不可用
    var online:Bool?



    public override init(){
            super.init()
    }

    enum InstanceTypeStateCodingKeys: String, CodingKey {
        case az
        case inStock
        case online
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: InstanceTypeStateCodingKeys.self)
        if decoderContainer.contains(.az)
        {
            self.az = try decoderContainer.decode(String?.self, forKey: .az)
        }
        if decoderContainer.contains(.inStock)
        {
            self.inStock = try decoderContainer.decode(Bool?.self, forKey: .inStock)
        }
        if decoderContainer.contains(.online)
        {
            self.online = try decoderContainer.decode(Bool?.self, forKey: .online)
        }
    }
}
public extension InstanceTypeState{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: InstanceTypeStateCodingKeys.self)
         try encoderContainer.encode(az, forKey: .az)
         try encoderContainer.encode(inStock, forKey: .inStock)
         try encoderContainer.encode(online, forKey: .online)
    }
}
///  instanceType
public class InstanceType:NSObject,Codable{
    /// 实例规格类型
    var family:String?
    /// 实例规格，比如g.b1.2xlarge
    var instanceTypeValue:String?
    /// cpu个数
    var cpu:Int?
    /// 内存大小
    var memoryMB:Int?
    /// 支持弹性网卡的数量
    var nicLimit:Int?
    /// 描述
    var desc:String?
    /// 规格状态
    var state:[InstanceTypeState?]?



    public override init(){
            super.init()
    }

    enum InstanceTypeCodingKeys: String, CodingKey {
        case family
        case instanceTypeValue = "instanceType"
        case cpu
        case memoryMB
        case nicLimit
        case desc
        case state
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: InstanceTypeCodingKeys.self)
        if decoderContainer.contains(.family)
        {
            self.family = try decoderContainer.decode(String?.self, forKey: .family)
        }
        if decoderContainer.contains(.instanceTypeValue)
        {
            self.instanceTypeValue = try decoderContainer.decode(String?.self, forKey: .instanceTypeValue)
        }
        if decoderContainer.contains(.cpu)
        {
            self.cpu = try decoderContainer.decode(Int?.self, forKey: .cpu)
        }
        if decoderContainer.contains(.memoryMB)
        {
            self.memoryMB = try decoderContainer.decode(Int?.self, forKey: .memoryMB)
        }
        if decoderContainer.contains(.nicLimit)
        {
            self.nicLimit = try decoderContainer.decode(Int?.self, forKey: .nicLimit)
        }
        if decoderContainer.contains(.desc)
        {
            self.desc = try decoderContainer.decode(String?.self, forKey: .desc)
        }
        if decoderContainer.contains(.state)
        {
            self.state = try decoderContainer.decode([InstanceTypeState?]?.self, forKey: .state)
        }
    }
}
public extension InstanceType{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: InstanceTypeCodingKeys.self)
         try encoderContainer.encode(family, forKey: .family)
         try encoderContainer.encode(instanceTypeValue, forKey: .instanceTypeValue)
         try encoderContainer.encode(cpu, forKey: .cpu)
         try encoderContainer.encode(memoryMB, forKey: .memoryMB)
         try encoderContainer.encode(nicLimit, forKey: .nicLimit)
         try encoderContainer.encode(desc, forKey: .desc)
         try encoderContainer.encode(state, forKey: .state)
    }
}
///  容器必需的计算资源
public class Request:NSObject,Codable{
    /// 容器必需的计算资源
    var cpu:String?
    /// 容器使用计算资源上限
    var memoryMB:String?



    public override init(){
            super.init()
    }

    enum RequestCodingKeys: String, CodingKey {
        case cpu
        case memoryMB
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: RequestCodingKeys.self)
        if decoderContainer.contains(.cpu)
        {
            self.cpu = try decoderContainer.decode(String?.self, forKey: .cpu)
        }
        if decoderContainer.contains(.memoryMB)
        {
            self.memoryMB = try decoderContainer.decode(String?.self, forKey: .memoryMB)
        }
    }
}
public extension Request{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: RequestCodingKeys.self)
         try encoderContainer.encode(cpu, forKey: .cpu)
         try encoderContainer.encode(memoryMB, forKey: .memoryMB)
    }
}
///  pod 中的容器状态
public class ContainerStatus:NSObject,Codable{
    /// 容器名称
    var name:String?
    /// 容器被重新启动的次数
    var restartCount:Int?
    /// 容器是否通过了就绪探针探测
    var ready:Bool?
    /// 关于容器当前状态详细信息
    var state:ContainerState?
    /// 关于容器最后一次termination详细信息
    var lastState:ContainerState?



    public override init(){
            super.init()
    }

    enum ContainerStatusCodingKeys: String, CodingKey {
        case name
        case restartCount
        case ready
        case state
        case lastState
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: ContainerStatusCodingKeys.self)
        if decoderContainer.contains(.name)
        {
            self.name = try decoderContainer.decode(String?.self, forKey: .name)
        }
        if decoderContainer.contains(.restartCount)
        {
            self.restartCount = try decoderContainer.decode(Int?.self, forKey: .restartCount)
        }
        if decoderContainer.contains(.ready)
        {
            self.ready = try decoderContainer.decode(Bool?.self, forKey: .ready)
        }
        if decoderContainer.contains(.state)
        {
            self.state = try decoderContainer.decode(ContainerState?.self, forKey: .state)
        }
        if decoderContainer.contains(.lastState)
        {
            self.lastState = try decoderContainer.decode(ContainerState?.self, forKey: .lastState)
        }
    }
}
public extension ContainerStatus{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: ContainerStatusCodingKeys.self)
         try encoderContainer.encode(name, forKey: .name)
         try encoderContainer.encode(restartCount, forKey: .restartCount)
         try encoderContainer.encode(ready, forKey: .ready)
         try encoderContainer.encode(state, forKey: .state)
         try encoderContainer.encode(lastState, forKey: .lastState)
    }
}
///  容器计算资源信息
      ///   - 容器必需的 CPU 展示为 0m 时，实际按照 2m 处理
      /// 
public class ResourceRequests:NSObject,Codable{
    /// 容器必需的计算资源
    var requests:Request?
    /// 容器使用计算资源上限
    var limits:Request?



    public override init(){
            super.init()
    }

    enum ResourceRequestsCodingKeys: String, CodingKey {
        case requests
        case limits
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: ResourceRequestsCodingKeys.self)
        if decoderContainer.contains(.requests)
        {
            self.requests = try decoderContainer.decode(Request?.self, forKey: .requests)
        }
        if decoderContainer.contains(.limits)
        {
            self.limits = try decoderContainer.decode(Request?.self, forKey: .limits)
        }
    }
}
public extension ResourceRequests{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: ResourceRequestsCodingKeys.self)
         try encoderContainer.encode(requests, forKey: .requests)
         try encoderContainer.encode(limits, forKey: .limits)
    }
}
///  tcpSocket
public class TcpSocket:NSObject,Codable{
    /// 端口号，范围：[1-65535]
    var port:Int?



    public override init(){
            super.init()
    }

    enum TcpSocketCodingKeys: String, CodingKey {
        case port
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: TcpSocketCodingKeys.self)
        if decoderContainer.contains(.port)
        {
            self.port = try decoderContainer.decode(Int?.self, forKey: .port)
        }
    }
}
public extension TcpSocket{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: TcpSocketCodingKeys.self)
         try encoderContainer.encode(port, forKey: .port)
    }
}
///  容器运行的详细信息
public class ContainerStateRunning:NSObject,Codable{
    /// 容器最后一次重启或启动的时间。
    var startedAt:String?



    public override init(){
            super.init()
    }

    enum ContainerStateRunningCodingKeys: String, CodingKey {
        case startedAt
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: ContainerStateRunningCodingKeys.self)
        if decoderContainer.contains(.startedAt)
        {
            self.startedAt = try decoderContainer.decode(String?.self, forKey: .startedAt)
        }
    }
}
public extension ContainerStateRunning{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: ContainerStateRunningCodingKeys.self)
         try encoderContainer.encode(startedAt, forKey: .startedAt)
    }
}
///  httpHeader
public class Hh:NSObject,Codable{
    /// http header 键
    var name:String?
    /// http header 值
    var value:String?



    public override init(){
            super.init()
    }

    enum HhCodingKeys: String, CodingKey {
        case name
        case value
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: HhCodingKeys.self)
        if decoderContainer.contains(.name)
        {
            self.name = try decoderContainer.decode(String?.self, forKey: .name)
        }
        if decoderContainer.contains(.value)
        {
            self.value = try decoderContainer.decode(String?.self, forKey: .value)
        }
    }
}
public extension Hh{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: HhCodingKeys.self)
         try encoderContainer.encode(name, forKey: .name)
         try encoderContainer.encode(value, forKey: .value)
    }
}
///  容器的状态信息
public class ContainerState:NSObject,Codable{
    /// 容器运行的详细信息
    var running:ContainerStateRunning?
    /// 容器终止的详细信息
    var terminated:ContainerStateTerminated?
    /// 容器等待的详细信息
    var waiting:ContainerStateWaiting?



    public override init(){
            super.init()
    }

    enum ContainerStateCodingKeys: String, CodingKey {
        case running
        case terminated
        case waiting
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: ContainerStateCodingKeys.self)
        if decoderContainer.contains(.running)
        {
            self.running = try decoderContainer.decode(ContainerStateRunning?.self, forKey: .running)
        }
        if decoderContainer.contains(.terminated)
        {
            self.terminated = try decoderContainer.decode(ContainerStateTerminated?.self, forKey: .terminated)
        }
        if decoderContainer.contains(.waiting)
        {
            self.waiting = try decoderContainer.decode(ContainerStateWaiting?.self, forKey: .waiting)
        }
    }
}
public extension ContainerState{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: ContainerStateCodingKeys.self)
         try encoderContainer.encode(running, forKey: .running)
         try encoderContainer.encode(terminated, forKey: .terminated)
         try encoderContainer.encode(waiting, forKey: .waiting)
    }
}
///  容器等待的详细信息
public class ContainerStateWaiting:NSObject,Codable{
    /// （简要）容器还没有运行原因。&lt;br&gt;
      /// eg ContainerCreating     
      /// 
    var reason:String?
    /// 容器还没有运行的详细信息。
    var message:String?



    public override init(){
            super.init()
    }

    enum ContainerStateWaitingCodingKeys: String, CodingKey {
        case reason
        case message
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: ContainerStateWaitingCodingKeys.self)
        if decoderContainer.contains(.reason)
        {
            self.reason = try decoderContainer.decode(String?.self, forKey: .reason)
        }
        if decoderContainer.contains(.message)
        {
            self.message = try decoderContainer.decode(String?.self, forKey: .message)
        }
    }
}
public extension ContainerStateWaiting{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: ContainerStateWaitingCodingKeys.self)
         try encoderContainer.encode(reason, forKey: .reason)
         try encoderContainer.encode(message, forKey: .message)
    }
}
///  httpGet
public class Hg:NSObject,Codable{
    /// 默认值：http。
    var scheme:String?
    /// 连接到pod的host信息。
    var host:String?
    /// 端口号。
    var port:Int?
    /// HTTP的路径。
    var path:String?
    /// 自定义Http headers
    var httpHeader:[Hh?]?



    public override init(){
            super.init()
    }

    enum HgCodingKeys: String, CodingKey {
        case scheme
        case host
        case port
        case path
        case httpHeader
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: HgCodingKeys.self)
        if decoderContainer.contains(.scheme)
        {
            self.scheme = try decoderContainer.decode(String?.self, forKey: .scheme)
        }
        if decoderContainer.contains(.host)
        {
            self.host = try decoderContainer.decode(String?.self, forKey: .host)
        }
        if decoderContainer.contains(.port)
        {
            self.port = try decoderContainer.decode(Int?.self, forKey: .port)
        }
        if decoderContainer.contains(.path)
        {
            self.path = try decoderContainer.decode(String?.self, forKey: .path)
        }
        if decoderContainer.contains(.httpHeader)
        {
            self.httpHeader = try decoderContainer.decode([Hh?]?.self, forKey: .httpHeader)
        }
    }
}
public extension Hg{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: HgCodingKeys.self)
         try encoderContainer.encode(scheme, forKey: .scheme)
         try encoderContainer.encode(host, forKey: .host)
         try encoderContainer.encode(port, forKey: .port)
         try encoderContainer.encode(path, forKey: .path)
         try encoderContainer.encode(httpHeader, forKey: .httpHeader)
    }
}
///  容器终止的详细信息
public class ContainerStateTerminated:NSObject,Codable{
    /// 容器被终止的信号。
    var signal:Int?
    /// 容器被终止的退出码。
    var exitCode:Int?
    /// （简要）容器被终止的原因。
    var reason:String?
    /// 容器被终止的详细信息。
    var message:String?
    /// 容器被终止的时间。
    var finishedAt:String?
    /// 容器开始执行的时间。
    var startedAt:String?



    public override init(){
            super.init()
    }

    enum ContainerStateTerminatedCodingKeys: String, CodingKey {
        case signal
        case exitCode
        case reason
        case message
        case finishedAt
        case startedAt
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: ContainerStateTerminatedCodingKeys.self)
        if decoderContainer.contains(.signal)
        {
            self.signal = try decoderContainer.decode(Int?.self, forKey: .signal)
        }
        if decoderContainer.contains(.exitCode)
        {
            self.exitCode = try decoderContainer.decode(Int?.self, forKey: .exitCode)
        }
        if decoderContainer.contains(.reason)
        {
            self.reason = try decoderContainer.decode(String?.self, forKey: .reason)
        }
        if decoderContainer.contains(.message)
        {
            self.message = try decoderContainer.decode(String?.self, forKey: .message)
        }
        if decoderContainer.contains(.finishedAt)
        {
            self.finishedAt = try decoderContainer.decode(String?.self, forKey: .finishedAt)
        }
        if decoderContainer.contains(.startedAt)
        {
            self.startedAt = try decoderContainer.decode(String?.self, forKey: .startedAt)
        }
    }
}
public extension ContainerStateTerminated{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: ContainerStateTerminatedCodingKeys.self)
         try encoderContainer.encode(signal, forKey: .signal)
         try encoderContainer.encode(exitCode, forKey: .exitCode)
         try encoderContainer.encode(reason, forKey: .reason)
         try encoderContainer.encode(message, forKey: .message)
         try encoderContainer.encode(finishedAt, forKey: .finishedAt)
         try encoderContainer.encode(startedAt, forKey: .startedAt)
    }
}
///  容器探活方式。
public class Probe:NSObject,Codable{
    /// 容器启动多久后触发探针。
    var initialDelaySeconds:Int?
    /// 探测的时间间隔。
    var periodSeconds:Int?
    /// 探测的超时时间。
    var timeoutSeconds:Int?
    /// 在成功状态后，连续探活失败的次数，认为探活失败。
    var failureThreshold:Int?
    /// 在失败状态后，连续探活成功的次数，认为探活成功。
    var successThreshold:Int?
    /// 在容器内执行指定命令；如果命令退出时返回码为 0 则认为诊断成功。
    var exec:Exec?
    /// 对指定的端口和路径上的容器的 IP 地址执行 HTTP Get 请求。如果响应的状态码大于等于 200 且小于 400，则认为诊断成功。
    var httpGet:Hg?
    /// 对指定端口上的容器的 IP 地址进行 TCP 检查；如果端口打开，则认为诊断成功。
    var tcpSocket:TcpSocket?



    public override init(){
            super.init()
    }

    enum ProbeCodingKeys: String, CodingKey {
        case initialDelaySeconds
        case periodSeconds
        case timeoutSeconds
        case failureThreshold
        case successThreshold
        case exec
        case httpGet
        case tcpSocket
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: ProbeCodingKeys.self)
        if decoderContainer.contains(.initialDelaySeconds)
        {
            self.initialDelaySeconds = try decoderContainer.decode(Int?.self, forKey: .initialDelaySeconds)
        }
        if decoderContainer.contains(.periodSeconds)
        {
            self.periodSeconds = try decoderContainer.decode(Int?.self, forKey: .periodSeconds)
        }
        if decoderContainer.contains(.timeoutSeconds)
        {
            self.timeoutSeconds = try decoderContainer.decode(Int?.self, forKey: .timeoutSeconds)
        }
        if decoderContainer.contains(.failureThreshold)
        {
            self.failureThreshold = try decoderContainer.decode(Int?.self, forKey: .failureThreshold)
        }
        if decoderContainer.contains(.successThreshold)
        {
            self.successThreshold = try decoderContainer.decode(Int?.self, forKey: .successThreshold)
        }
        if decoderContainer.contains(.exec)
        {
            self.exec = try decoderContainer.decode(Exec?.self, forKey: .exec)
        }
        if decoderContainer.contains(.httpGet)
        {
            self.httpGet = try decoderContainer.decode(Hg?.self, forKey: .httpGet)
        }
        if decoderContainer.contains(.tcpSocket)
        {
            self.tcpSocket = try decoderContainer.decode(TcpSocket?.self, forKey: .tcpSocket)
        }
    }
}
public extension Probe{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: ProbeCodingKeys.self)
         try encoderContainer.encode(initialDelaySeconds, forKey: .initialDelaySeconds)
         try encoderContainer.encode(periodSeconds, forKey: .periodSeconds)
         try encoderContainer.encode(timeoutSeconds, forKey: .timeoutSeconds)
         try encoderContainer.encode(failureThreshold, forKey: .failureThreshold)
         try encoderContainer.encode(successThreshold, forKey: .successThreshold)
         try encoderContainer.encode(exec, forKey: .exec)
         try encoderContainer.encode(httpGet, forKey: .httpGet)
         try encoderContainer.encode(tcpSocket, forKey: .tcpSocket)
    }
}
///  exec
public class Exec:NSObject,Codable{
    /// 执行的命令。
    var command:[String?]?



    public override init(){
            super.init()
    }

    enum ExecCodingKeys: String, CodingKey {
        case command
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: ExecCodingKeys.self)
        if decoderContainer.contains(.command)
        {
            self.command = try decoderContainer.decode([String?]?.self, forKey: .command)
        }
    }
}
public extension Exec{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: ExecCodingKeys.self)
         try encoderContainer.encode(command, forKey: .command)
    }
}
///  容器挂载信息
public class VolumeMount:NSObject,Codable{
    /// 挂载的云盘在pod中的名称。
    var name:String?
    /// 容器内挂载点。
    var mountPath:String?
    /// 是否以只读方式挂载。
    var readOnly:Bool?



    public override init(){
            super.init()
    }

    enum VolumeMountCodingKeys: String, CodingKey {
        case name
        case mountPath
        case readOnly
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: VolumeMountCodingKeys.self)
        if decoderContainer.contains(.name)
        {
            self.name = try decoderContainer.decode(String?.self, forKey: .name)
        }
        if decoderContainer.contains(.mountPath)
        {
            self.mountPath = try decoderContainer.decode(String?.self, forKey: .mountPath)
        }
        if decoderContainer.contains(.readOnly)
        {
            self.readOnly = try decoderContainer.decode(Bool?.self, forKey: .readOnly)
        }
    }
}
public extension VolumeMount{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: VolumeMountCodingKeys.self)
         try encoderContainer.encode(name, forKey: .name)
         try encoderContainer.encode(mountPath, forKey: .mountPath)
         try encoderContainer.encode(readOnly, forKey: .readOnly)
    }
}
///  容器系统盘配置
public class CloudDisk:NSObject,Codable{
    /// 云盘ID。
    var volumeId:String?
    /// 云盘快照ID。
    var snapshotId:String?
    /// 云盘类型：hdd.std1,ssd.gp1,ssd.io1。
    var diskType:String?
    /// 云盘size,单位 GB。
    var sizeGB:Int?
    /// 指定volume文件系统类型，目前支持[xfs, ext4]。
    var fsType:String?
    /// 云盘的 iops 值，目前只有 ssd.io1 类型有效。
    var iops:Int?
    /// 是否随pod删除。
    var autoDelete:Bool?



    public override init(){
            super.init()
    }

    enum CloudDiskCodingKeys: String, CodingKey {
        case volumeId
        case snapshotId
        case diskType
        case sizeGB
        case fsType
        case iops
        case autoDelete
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: CloudDiskCodingKeys.self)
        if decoderContainer.contains(.volumeId)
        {
            self.volumeId = try decoderContainer.decode(String?.self, forKey: .volumeId)
        }
        if decoderContainer.contains(.snapshotId)
        {
            self.snapshotId = try decoderContainer.decode(String?.self, forKey: .snapshotId)
        }
        if decoderContainer.contains(.diskType)
        {
            self.diskType = try decoderContainer.decode(String?.self, forKey: .diskType)
        }
        if decoderContainer.contains(.sizeGB)
        {
            self.sizeGB = try decoderContainer.decode(Int?.self, forKey: .sizeGB)
        }
        if decoderContainer.contains(.fsType)
        {
            self.fsType = try decoderContainer.decode(String?.self, forKey: .fsType)
        }
        if decoderContainer.contains(.iops)
        {
            self.iops = try decoderContainer.decode(Int?.self, forKey: .iops)
        }
        if decoderContainer.contains(.autoDelete)
        {
            self.autoDelete = try decoderContainer.decode(Bool?.self, forKey: .autoDelete)
        }
    }
}
public extension CloudDisk{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: CloudDiskCodingKeys.self)
         try encoderContainer.encode(volumeId, forKey: .volumeId)
         try encoderContainer.encode(snapshotId, forKey: .snapshotId)
         try encoderContainer.encode(diskType, forKey: .diskType)
         try encoderContainer.encode(sizeGB, forKey: .sizeGB)
         try encoderContainer.encode(fsType, forKey: .fsType)
         try encoderContainer.encode(iops, forKey: .iops)
         try encoderContainer.encode(autoDelete, forKey: .autoDelete)
    }
}
///  容器详情
public class Container:NSObject,Codable{
    /// 容器名称
    var name:String?
    /// 容器执行的命令。
    var command:[String?]?
    /// 容器执行命令的参数。
    var args:[String?]?
    /// 容器执行的环境变量。
    var env:[Env?]?
    /// 容器镜像名称。
    var image:String?
    /// 容器镜像仓库认证信息。
    var secret:String?
    /// 容器是否分配tty。
    var tty:Bool?
    /// 容器的工作目录。
    var workingDir:String?
    /// 容器存活探针配置
    var livenessProbe:Probe?
    /// 容器服务就绪探针配置
    var readinessProbe:Probe?
    /// 容器计算资源配置
    var resources:ResourceRequests?
    /// 容器计算资源配置
    var systemDisk:CloudDisk?
    /// 容器计算资源配置
    var volumeMounts:[VolumeMount?]?
    /// 容器状态信息
    var containerStatus:ContainerStatus?



    public override init(){
            super.init()
    }

    enum ContainerCodingKeys: String, CodingKey {
        case name
        case command
        case args
        case env
        case image
        case secret
        case tty
        case workingDir
        case livenessProbe
        case readinessProbe
        case resources
        case systemDisk
        case volumeMounts
        case containerStatus
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: ContainerCodingKeys.self)
        if decoderContainer.contains(.name)
        {
            self.name = try decoderContainer.decode(String?.self, forKey: .name)
        }
        if decoderContainer.contains(.command)
        {
            self.command = try decoderContainer.decode([String?]?.self, forKey: .command)
        }
        if decoderContainer.contains(.args)
        {
            self.args = try decoderContainer.decode([String?]?.self, forKey: .args)
        }
        if decoderContainer.contains(.env)
        {
            self.env = try decoderContainer.decode([Env?]?.self, forKey: .env)
        }
        if decoderContainer.contains(.image)
        {
            self.image = try decoderContainer.decode(String?.self, forKey: .image)
        }
        if decoderContainer.contains(.secret)
        {
            self.secret = try decoderContainer.decode(String?.self, forKey: .secret)
        }
        if decoderContainer.contains(.tty)
        {
            self.tty = try decoderContainer.decode(Bool?.self, forKey: .tty)
        }
        if decoderContainer.contains(.workingDir)
        {
            self.workingDir = try decoderContainer.decode(String?.self, forKey: .workingDir)
        }
        if decoderContainer.contains(.livenessProbe)
        {
            self.livenessProbe = try decoderContainer.decode(Probe?.self, forKey: .livenessProbe)
        }
        if decoderContainer.contains(.readinessProbe)
        {
            self.readinessProbe = try decoderContainer.decode(Probe?.self, forKey: .readinessProbe)
        }
        if decoderContainer.contains(.resources)
        {
            self.resources = try decoderContainer.decode(ResourceRequests?.self, forKey: .resources)
        }
        if decoderContainer.contains(.systemDisk)
        {
            self.systemDisk = try decoderContainer.decode(CloudDisk?.self, forKey: .systemDisk)
        }
        if decoderContainer.contains(.volumeMounts)
        {
            self.volumeMounts = try decoderContainer.decode([VolumeMount?]?.self, forKey: .volumeMounts)
        }
        if decoderContainer.contains(.containerStatus)
        {
            self.containerStatus = try decoderContainer.decode(ContainerStatus?.self, forKey: .containerStatus)
        }
    }
}
public extension Container{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: ContainerCodingKeys.self)
         try encoderContainer.encode(name, forKey: .name)
         try encoderContainer.encode(command, forKey: .command)
         try encoderContainer.encode(args, forKey: .args)
         try encoderContainer.encode(env, forKey: .env)
         try encoderContainer.encode(image, forKey: .image)
         try encoderContainer.encode(secret, forKey: .secret)
         try encoderContainer.encode(tty, forKey: .tty)
         try encoderContainer.encode(workingDir, forKey: .workingDir)
         try encoderContainer.encode(livenessProbe, forKey: .livenessProbe)
         try encoderContainer.encode(readinessProbe, forKey: .readinessProbe)
         try encoderContainer.encode(resources, forKey: .resources)
         try encoderContainer.encode(systemDisk, forKey: .systemDisk)
         try encoderContainer.encode(volumeMounts, forKey: .volumeMounts)
         try encoderContainer.encode(containerStatus, forKey: .containerStatus)
    }
}
///  容器环境变量。
public class Env:NSObject,Codable{
    /// 环境变量名称（ASCII）。
    var name:String?
    /// 环境变量取值。
    var value:String?



    public override init(){
            super.init()
    }

    enum EnvCodingKeys: String, CodingKey {
        case name
        case value
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: EnvCodingKeys.self)
        if decoderContainer.contains(.name)
        {
            self.name = try decoderContainer.decode(String?.self, forKey: .name)
        }
        if decoderContainer.contains(.value)
        {
            self.value = try decoderContainer.decode(String?.self, forKey: .value)
        }
    }
}
public extension Env{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: EnvCodingKeys.self)
         try encoderContainer.encode(name, forKey: .name)
         try encoderContainer.encode(value, forKey: .value)
    }
}
///  secret 的数据
public class DockerRegistryData:NSObject,Codable{
    /// registry服务器地址
    /// Required:true
    var server:String
    /// 用户名
    /// Required:true
    var username:String
    /// 密码
    /// Required:true
    var password:String
    /// 邮件地址
    var email:String?



    public  init(server:String,username:String,password:String){
             self.server = server
             self.username = username
             self.password = password
    }

    enum DockerRegistryDataCodingKeys: String, CodingKey {
        case server
        case username
        case password
        case email
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: DockerRegistryDataCodingKeys.self)
        self.server = try decoderContainer.decode(String.self, forKey: .server)
        self.username = try decoderContainer.decode(String.self, forKey: .username)
        self.password = try decoderContainer.decode(String.self, forKey: .password)
        if decoderContainer.contains(.email)
        {
            self.email = try decoderContainer.decode(String?.self, forKey: .email)
        }
    }
}
public extension DockerRegistryData{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: DockerRegistryDataCodingKeys.self)
         try encoderContainer.encode(server, forKey: .server)
         try encoderContainer.encode(username, forKey: .username)
         try encoderContainer.encode(password, forKey: .password)
         try encoderContainer.encode(email, forKey: .email)
    }
}
///  镜像仓库认证信息
public class Secret:NSObject,Codable{
    /// 镜像仓库认证信息名称
    var name:String?
    /// 镜像仓库认证信息类型
    var type:String?
    /// 镜像仓库认证信息创建时间
    var createdAt:String?
    /// 镜像仓库认证信息数据
    var data:DockerRegistryData?



    public override init(){
            super.init()
    }

    enum SecretCodingKeys: String, CodingKey {
        case name
        case type
        case createdAt
        case data
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: SecretCodingKeys.self)
        if decoderContainer.contains(.name)
        {
            self.name = try decoderContainer.decode(String?.self, forKey: .name)
        }
        if decoderContainer.contains(.type)
        {
            self.type = try decoderContainer.decode(String?.self, forKey: .type)
        }
        if decoderContainer.contains(.createdAt)
        {
            self.createdAt = try decoderContainer.decode(String?.self, forKey: .createdAt)
        }
        if decoderContainer.contains(.data)
        {
            self.data = try decoderContainer.decode(DockerRegistryData?.self, forKey: .data)
        }
    }
}
public extension Secret{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: SecretCodingKeys.self)
         try encoderContainer.encode(name, forKey: .name)
         try encoderContainer.encode(type, forKey: .type)
         try encoderContainer.encode(createdAt, forKey: .createdAt)
         try encoderContainer.encode(data, forKey: .data)
    }
}
///  instanceInfo
public class InstanceInfo:NSObject,Codable{
    /// pod ID
    var resourceId:String?
    /// pod 名称
    var resourceName:String?
    /// 备注信息
    var remark:String?
    /// 绑定资源
    var bind:[BindInfo?]?



    public override init(){
            super.init()
    }

    enum InstanceInfoCodingKeys: String, CodingKey {
        case resourceId
        case resourceName
        case remark
        case bind
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: InstanceInfoCodingKeys.self)
        if decoderContainer.contains(.resourceId)
        {
            self.resourceId = try decoderContainer.decode(String?.self, forKey: .resourceId)
        }
        if decoderContainer.contains(.resourceName)
        {
            self.resourceName = try decoderContainer.decode(String?.self, forKey: .resourceName)
        }
        if decoderContainer.contains(.remark)
        {
            self.remark = try decoderContainer.decode(String?.self, forKey: .remark)
        }
        if decoderContainer.contains(.bind)
        {
            self.bind = try decoderContainer.decode([BindInfo?]?.self, forKey: .bind)
        }
    }
}
public extension InstanceInfo{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: InstanceInfoCodingKeys.self)
         try encoderContainer.encode(resourceId, forKey: .resourceId)
         try encoderContainer.encode(resourceName, forKey: .resourceName)
         try encoderContainer.encode(remark, forKey: .remark)
         try encoderContainer.encode(bind, forKey: .bind)
    }
}
///  bindInfo
public class BindInfo:NSObject,Codable{
    /// pod ID
    var resourceId:String?
    /// pod 名称
    var resourceName:String?
    /// 备注信息
    var remark:String?



    public override init(){
            super.init()
    }

    enum BindInfoCodingKeys: String, CodingKey {
        case resourceId
        case resourceName
        case remark
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: BindInfoCodingKeys.self)
        if decoderContainer.contains(.resourceId)
        {
            self.resourceId = try decoderContainer.decode(String?.self, forKey: .resourceId)
        }
        if decoderContainer.contains(.resourceName)
        {
            self.resourceName = try decoderContainer.decode(String?.self, forKey: .resourceName)
        }
        if decoderContainer.contains(.remark)
        {
            self.remark = try decoderContainer.decode(String?.self, forKey: .remark)
        }
    }
}
public extension BindInfo{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: BindInfoCodingKeys.self)
         try encoderContainer.encode(resourceId, forKey: .resourceId)
         try encoderContainer.encode(resourceName, forKey: .resourceName)
         try encoderContainer.encode(remark, forKey: .remark)
    }
}
///  描述网卡安全组的基本信息
public class SecurityGroupSimple:NSObject,Codable{
    /// 安全组ID
    var groupId:String?
    /// 安全组名称
    var groupName:String?



    public override init(){
            super.init()
    }

    enum SecurityGroupSimpleCodingKeys: String, CodingKey {
        case groupId
        case groupName
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: SecurityGroupSimpleCodingKeys.self)
        if decoderContainer.contains(.groupId)
        {
            self.groupId = try decoderContainer.decode(String?.self, forKey: .groupId)
        }
        if decoderContainer.contains(.groupName)
        {
            self.groupName = try decoderContainer.decode(String?.self, forKey: .groupName)
        }
    }
}
public extension SecurityGroupSimple{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: SecurityGroupSimpleCodingKeys.self)
         try encoderContainer.encode(groupId, forKey: .groupId)
         try encoderContainer.encode(groupName, forKey: .groupName)
    }
}
///  DNS解析器选项。
public class PodDnsConfigOptionSpec:NSObject,Codable{
    /// 长度范围：[1-63]，需满足linux resolver限制
    /// Required:true
    var name:String
    /// 长度范围：[0-100]，仅限timeout, attempts, ndots
    var value:String?



    public  init(name:String){
             self.name = name
    }

    enum PodDnsConfigOptionSpecCodingKeys: String, CodingKey {
        case name
        case value
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: PodDnsConfigOptionSpecCodingKeys.self)
        self.name = try decoderContainer.decode(String.self, forKey: .name)
        if decoderContainer.contains(.value)
        {
            self.value = try decoderContainer.decode(String?.self, forKey: .value)
        }
    }
}
public extension PodDnsConfigOptionSpec{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: PodDnsConfigOptionSpecCodingKeys.self)
         try encoderContainer.encode(name, forKey: .name)
         try encoderContainer.encode(value, forKey: .value)
    }
}
///  tagFilter
public class TagFilter:NSObject,Codable{
    /// Tag键
    /// Required:true
    var key:String
    /// Tag值
    var values:[String?]?



    public  init(key:String){
             self.key = key
    }

    enum TagFilterCodingKeys: String, CodingKey {
        case key
        case values
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: TagFilterCodingKeys.self)
        self.key = try decoderContainer.decode(String.self, forKey: .key)
        if decoderContainer.contains(.values)
        {
            self.values = try decoderContainer.decode([String?]?.self, forKey: .values)
        }
    }
}
public extension TagFilter{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: TagFilterCodingKeys.self)
         try encoderContainer.encode(key, forKey: .key)
         try encoderContainer.encode(values, forKey: .values)
    }
}
///  pod 中的 dns 配置。
public class DnsConfig:NSObject,Codable{
    /// DNS服务器IP地址列表。
      /// 
    var nameservers:[String?]?
    /// DNS搜索域列表，用于主机名查找。
      /// 
    var searches:[String?]?
    /// DNS解析器选项列表。
    var options:[PodDnsConfigOption?]?



    public override init(){
            super.init()
    }

    enum DnsConfigCodingKeys: String, CodingKey {
        case nameservers
        case searches
        case options
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: DnsConfigCodingKeys.self)
        if decoderContainer.contains(.nameservers)
        {
            self.nameservers = try decoderContainer.decode([String?]?.self, forKey: .nameservers)
        }
        if decoderContainer.contains(.searches)
        {
            self.searches = try decoderContainer.decode([String?]?.self, forKey: .searches)
        }
        if decoderContainer.contains(.options)
        {
            self.options = try decoderContainer.decode([PodDnsConfigOption?]?.self, forKey: .options)
        }
    }
}
public extension DnsConfig{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: DnsConfigCodingKeys.self)
         try encoderContainer.encode(nameservers, forKey: .nameservers)
         try encoderContainer.encode(searches, forKey: .searches)
         try encoderContainer.encode(options, forKey: .options)
    }
}
///  容器必需的计算资源
public class RequestSpec:NSObject,Codable{
    /// 容器必需的计算资源，例：300m，1000m
    var cpu:String?
    /// 容器使用计算资源上限，例：1024Mi，16384Mi
    var memoryMB:String?



    public override init(){
            super.init()
    }

    enum RequestSpecCodingKeys: String, CodingKey {
        case cpu
        case memoryMB
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: RequestSpecCodingKeys.self)
        if decoderContainer.contains(.cpu)
        {
            self.cpu = try decoderContainer.decode(String?.self, forKey: .cpu)
        }
        if decoderContainer.contains(.memoryMB)
        {
            self.memoryMB = try decoderContainer.decode(String?.self, forKey: .memoryMB)
        }
    }
}
public extension RequestSpec{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: RequestSpecCodingKeys.self)
         try encoderContainer.encode(cpu, forKey: .cpu)
         try encoderContainer.encode(memoryMB, forKey: .memoryMB)
    }
}
///  容器日志
public class Logs:NSObject,Codable{
    /// 容器日志内容，最多返回4KB
    var content:String?



    public override init(){
            super.init()
    }

    enum LogsCodingKeys: String, CodingKey {
        case content
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: LogsCodingKeys.self)
        if decoderContainer.contains(.content)
        {
            self.content = try decoderContainer.decode(String?.self, forKey: .content)
        }
    }
}
public extension Logs{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: LogsCodingKeys.self)
         try encoderContainer.encode(content, forKey: .content)
    }
}
///  pod 状态
public class PodCondition:NSObject,Codable{
    /// 最后一次探测状态的时间
    var lastProbeTime:String?
    /// 最后一次改变状态的时间
    var lastTransitionTime:String?
    /// 最后一次状态改变的简要原因
    var reason:String?
    /// Status is the status of the condition. Can be True, False, Unknown.
    var status:String?
    /// 最后一次状态改变的信息
    var message:String?
    /// 状态的条件。目前仅限 Ready.
    var conditionType:String?



    public override init(){
            super.init()
    }

    enum PodConditionCodingKeys: String, CodingKey {
        case lastProbeTime
        case lastTransitionTime
        case reason
        case status
        case message
        case conditionType
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: PodConditionCodingKeys.self)
        if decoderContainer.contains(.lastProbeTime)
        {
            self.lastProbeTime = try decoderContainer.decode(String?.self, forKey: .lastProbeTime)
        }
        if decoderContainer.contains(.lastTransitionTime)
        {
            self.lastTransitionTime = try decoderContainer.decode(String?.self, forKey: .lastTransitionTime)
        }
        if decoderContainer.contains(.reason)
        {
            self.reason = try decoderContainer.decode(String?.self, forKey: .reason)
        }
        if decoderContainer.contains(.status)
        {
            self.status = try decoderContainer.decode(String?.self, forKey: .status)
        }
        if decoderContainer.contains(.message)
        {
            self.message = try decoderContainer.decode(String?.self, forKey: .message)
        }
        if decoderContainer.contains(.conditionType)
        {
            self.conditionType = try decoderContainer.decode(String?.self, forKey: .conditionType)
        }
    }
}
public extension PodCondition{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: PodConditionCodingKeys.self)
         try encoderContainer.encode(lastProbeTime, forKey: .lastProbeTime)
         try encoderContainer.encode(lastTransitionTime, forKey: .lastTransitionTime)
         try encoderContainer.encode(reason, forKey: .reason)
         try encoderContainer.encode(status, forKey: .status)
         try encoderContainer.encode(message, forKey: .message)
         try encoderContainer.encode(conditionType, forKey: .conditionType)
    }
}
///  指定的创建 pod 参数
public class PodSpec:NSObject,Codable{
    /// Pod名称
    /// Required:true
    var name:String
    /// 描述信息，默认为空；允许输入UTF-8编码下的全部字符，不超过256字符。
    var descriptionValue:String?
    /// 主机名；范围：[1-63]个ASCII字符，默认值为 podId
    var hostname:String?
    /// pod中容器重启策略；Always, OnFailure, Never；默认：Always
    var restartPolicy:String?
    /// 优雅关机宽限时长，如果超时，则触发强制关机。默认：30s，值不能是负数，范围：[0-300]
    var terminationGracePeriodSeconds:Int?
    /// 实例类型；参考[文档](https://www.jdcloud.com/help/detail/1992/isCatalog/1)
    /// Required:true
    var instanceType:String
    /// 容器所属可用区
    /// Required:true
    var az:String
    /// pod内容器的/etc/resolv.conf配置
    var dnsConfig:DnsConfigSpec?
    /// 容器日志配置信息；默认会在本地分配10MB的存储空间
    var logConfig:LogConfigSpec?
    /// 域名和IP映射的信息；&lt;/br&gt; 最大10个alias
    var hostAliases:[HostAliasSpec?]?
    /// Pod的volume列表，可以挂载到container上。长度范围：[0,7]
    var volumes:[VolumeSpec?]?
    /// Pod的容器列表，至少一个容器。长度范围[1,8]
    /// Required:true
    var containers:[ContainerSpec?]?
    /// 计费模式：包年包月预付费（prepaid_by_duration）, 按配置后付费（postpaid_by_duration）。默认：按配置后付费
    var charge:ChargeSpec?
    /// 主网卡主IP关联的弹性IP规格
    var elasticIp:ElasticIpSpec?
    /// 主网卡配置信息
    /// Required:true
    var primaryNetworkInterface:NetworkInterfaceAttachmentSpec



    public  init(name:String,instanceType:String,az:String,containers:[ContainerSpec?]?,primaryNetworkInterface:NetworkInterfaceAttachmentSpec){
             self.name = name
             self.instanceType = instanceType
             self.az = az
             self.containers = containers
             self.primaryNetworkInterface = primaryNetworkInterface
    }

    enum PodSpecCodingKeys: String, CodingKey {
        case name
        case descriptionValue = "description"
        case hostname
        case restartPolicy
        case terminationGracePeriodSeconds
        case instanceType
        case az
        case dnsConfig
        case logConfig
        case hostAliases
        case volumes
        case containers
        case charge
        case elasticIp
        case primaryNetworkInterface
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: PodSpecCodingKeys.self)
        self.name = try decoderContainer.decode(String.self, forKey: .name)
        if decoderContainer.contains(.descriptionValue)
        {
            self.descriptionValue = try decoderContainer.decode(String?.self, forKey: .descriptionValue)
        }
        if decoderContainer.contains(.hostname)
        {
            self.hostname = try decoderContainer.decode(String?.self, forKey: .hostname)
        }
        if decoderContainer.contains(.restartPolicy)
        {
            self.restartPolicy = try decoderContainer.decode(String?.self, forKey: .restartPolicy)
        }
        if decoderContainer.contains(.terminationGracePeriodSeconds)
        {
            self.terminationGracePeriodSeconds = try decoderContainer.decode(Int?.self, forKey: .terminationGracePeriodSeconds)
        }
        self.instanceType = try decoderContainer.decode(String.self, forKey: .instanceType)
        self.az = try decoderContainer.decode(String.self, forKey: .az)
        if decoderContainer.contains(.dnsConfig)
        {
            self.dnsConfig = try decoderContainer.decode(DnsConfigSpec?.self, forKey: .dnsConfig)
        }
        if decoderContainer.contains(.logConfig)
        {
            self.logConfig = try decoderContainer.decode(LogConfigSpec?.self, forKey: .logConfig)
        }
        if decoderContainer.contains(.hostAliases)
        {
            self.hostAliases = try decoderContainer.decode([HostAliasSpec?]?.self, forKey: .hostAliases)
        }
        if decoderContainer.contains(.volumes)
        {
            self.volumes = try decoderContainer.decode([VolumeSpec?]?.self, forKey: .volumes)
        }
        self.containers = try decoderContainer.decode([ContainerSpec?]?.self, forKey: .containers)
        if decoderContainer.contains(.charge)
        {
            self.charge = try decoderContainer.decode(ChargeSpec?.self, forKey: .charge)
        }
        if decoderContainer.contains(.elasticIp)
        {
            self.elasticIp = try decoderContainer.decode(ElasticIpSpec?.self, forKey: .elasticIp)
        }
        self.primaryNetworkInterface = try decoderContainer.decode(NetworkInterfaceAttachmentSpec.self, forKey: .primaryNetworkInterface)
    }
}
public extension PodSpec{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: PodSpecCodingKeys.self)
         try encoderContainer.encode(name, forKey: .name)
         try encoderContainer.encode(descriptionValue, forKey: .descriptionValue)
         try encoderContainer.encode(hostname, forKey: .hostname)
         try encoderContainer.encode(restartPolicy, forKey: .restartPolicy)
         try encoderContainer.encode(terminationGracePeriodSeconds, forKey: .terminationGracePeriodSeconds)
         try encoderContainer.encode(instanceType, forKey: .instanceType)
         try encoderContainer.encode(az, forKey: .az)
         try encoderContainer.encode(dnsConfig, forKey: .dnsConfig)
         try encoderContainer.encode(logConfig, forKey: .logConfig)
         try encoderContainer.encode(hostAliases, forKey: .hostAliases)
         try encoderContainer.encode(volumes, forKey: .volumes)
         try encoderContainer.encode(containers, forKey: .containers)
         try encoderContainer.encode(charge, forKey: .charge)
         try encoderContainer.encode(elasticIp, forKey: .elasticIp)
         try encoderContainer.encode(primaryNetworkInterface, forKey: .primaryNetworkInterface)
    }
}
///  容器日志配置信息。
public class LogConfig:NSObject,Codable{
    /// 日志Driver名称。
    var logDriver:String?



    public override init(){
            super.init()
    }

    enum LogConfigCodingKeys: String, CodingKey {
        case logDriver
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: LogConfigCodingKeys.self)
        if decoderContainer.contains(.logDriver)
        {
            self.logDriver = try decoderContainer.decode(String?.self, forKey: .logDriver)
        }
    }
}
public extension LogConfig{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: LogConfigCodingKeys.self)
         try encoderContainer.encode(logDriver, forKey: .logDriver)
    }
}
///  重置 container 相关参数
public class RebuildContainerSpec:NSObject,Codable{
    /// 容器名称
    /// Required:true
    var name:String
    /// 容器执行命令，如果不指定默认是docker镜像的ENTRYPOINT。总长度256个字符。
    var command:[String?]?
    /// 容器执行命令的参数，如果不指定默认是docker镜像的CMD。总长度2048个字符。
    var args:[String?]?
    /// 容器执行的环境变量；如果和镜像中的环境变量Key相同，会覆盖镜像中的值。长度范围：[0-100]
    var env:[EnvSpec?]?
    /// 镜像名称 &lt;/br&gt;
      /// 容器镜像名字。 nginx:latest。长度范围：[1-639]
      /// 1. Docker Hub官方镜像通过类似nginx, mysql/mysql-server的名字指定 &lt;/br&gt; 
      /// 2. repository长度最大256个字符，tag最大128个字符，registry最大255个字符 &lt;/br&gt; 
      /// 
    /// Required:true
    var image:String
    /// 镜像仓库认证信息。如果目前不传，默认选择dockerHub镜像
    var secret:String?
    /// 容器是否分配tty。默认不分配
    var tty:Bool?
    /// 容器的工作目录。如果不指定，默认是根目录（/）；必须是绝对路径；长度范围：[0-1024]
    var workingDir:String?
    /// 容器存活探针配置
    var livenessProbe:ProbeSpec?
    /// 容器服务就绪探针配置
    var readinessProbe:ProbeSpec?
    /// 云盘挂载信息
    var volumeMounts:[VolumeMountSpec?]?



    public  init(name:String,image:String){
             self.name = name
             self.image = image
    }

    enum RebuildContainerSpecCodingKeys: String, CodingKey {
        case name
        case command
        case args
        case env
        case image
        case secret
        case tty
        case workingDir
        case livenessProbe
        case readinessProbe
        case volumeMounts
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: RebuildContainerSpecCodingKeys.self)
        self.name = try decoderContainer.decode(String.self, forKey: .name)
        if decoderContainer.contains(.command)
        {
            self.command = try decoderContainer.decode([String?]?.self, forKey: .command)
        }
        if decoderContainer.contains(.args)
        {
            self.args = try decoderContainer.decode([String?]?.self, forKey: .args)
        }
        if decoderContainer.contains(.env)
        {
            self.env = try decoderContainer.decode([EnvSpec?]?.self, forKey: .env)
        }
        self.image = try decoderContainer.decode(String.self, forKey: .image)
        if decoderContainer.contains(.secret)
        {
            self.secret = try decoderContainer.decode(String?.self, forKey: .secret)
        }
        if decoderContainer.contains(.tty)
        {
            self.tty = try decoderContainer.decode(Bool?.self, forKey: .tty)
        }
        if decoderContainer.contains(.workingDir)
        {
            self.workingDir = try decoderContainer.decode(String?.self, forKey: .workingDir)
        }
        if decoderContainer.contains(.livenessProbe)
        {
            self.livenessProbe = try decoderContainer.decode(ProbeSpec?.self, forKey: .livenessProbe)
        }
        if decoderContainer.contains(.readinessProbe)
        {
            self.readinessProbe = try decoderContainer.decode(ProbeSpec?.self, forKey: .readinessProbe)
        }
        if decoderContainer.contains(.volumeMounts)
        {
            self.volumeMounts = try decoderContainer.decode([VolumeMountSpec?]?.self, forKey: .volumeMounts)
        }
    }
}
public extension RebuildContainerSpec{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: RebuildContainerSpecCodingKeys.self)
         try encoderContainer.encode(name, forKey: .name)
         try encoderContainer.encode(command, forKey: .command)
         try encoderContainer.encode(args, forKey: .args)
         try encoderContainer.encode(env, forKey: .env)
         try encoderContainer.encode(image, forKey: .image)
         try encoderContainer.encode(secret, forKey: .secret)
         try encoderContainer.encode(tty, forKey: .tty)
         try encoderContainer.encode(workingDir, forKey: .workingDir)
         try encoderContainer.encode(livenessProbe, forKey: .livenessProbe)
         try encoderContainer.encode(readinessProbe, forKey: .readinessProbe)
         try encoderContainer.encode(volumeMounts, forKey: .volumeMounts)
    }
}
///  弹性 ip 详情
public class ElasticIp:NSObject,Codable{
    /// 弹性ip的Id
    var elasticIpId:String?
    /// 弹性ip地址
    var elasticIpAddress:String?



    public override init(){
            super.init()
    }

    enum ElasticIpCodingKeys: String, CodingKey {
        case elasticIpId
        case elasticIpAddress
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: ElasticIpCodingKeys.self)
        if decoderContainer.contains(.elasticIpId)
        {
            self.elasticIpId = try decoderContainer.decode(String?.self, forKey: .elasticIpId)
        }
        if decoderContainer.contains(.elasticIpAddress)
        {
            self.elasticIpAddress = try decoderContainer.decode(String?.self, forKey: .elasticIpAddress)
        }
    }
}
public extension ElasticIp{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: ElasticIpCodingKeys.self)
         try encoderContainer.encode(elasticIpId, forKey: .elasticIpId)
         try encoderContainer.encode(elasticIpAddress, forKey: .elasticIpAddress)
    }
}
///  pod 详情
public class Pod:NSObject,Codable{
    /// pod ID
    var podId:String?
    /// pod 名称
    var name:String?
    /// 描述信息，默认为空。
    var descriptionValue:String?
    /// 可用区
    var az:String?
    /// 主机名
    var hostname:String?
    /// pod 所需的计算资源规格
    var instanceType:String?
    /// pod重启策略
    var restartPolicy:String?
    /// 优雅关闭的时间
    var terminationGracePeriodSeconds:Int?
    /// 主网卡所属vpcId
    var vpcId:String?
    /// 主网卡所属子网的ID
    var subnetId:String?
    /// 主网卡主IP地址
    var privateIpAddress:String?
    /// pod内容器的/etc/resolv.conf配置
    var dnsConfig:DnsConfig?
    /// 容器日志配置信息；默认会在本地分配10MB的存储空间
    var logConfig:LogConfig?
    /// pod内容器的/etc/hosts配置
    var hostAliases:[HostAlias?]?
    /// 属于Pod的volume列表，提供挂载到containers上。
    var volumes:[Volume?]?
    /// pod内的容器信息
    var containers:[Container?]?
    /// pod状态信息
    var podStatus:PodStatus?
    /// 主网卡主IP关联的弹性IP规格
    var elasticIp:ElasticIp?
    /// 主网卡配置信息
    var primaryNetworkInterface:NetworkInterfaceAttachment?
    /// Tags
    var tags:[Tag?]?
    /// 计费配置；如不指定，默认计费类型是后付费-按使用时常付费
    var charge:Charge?
    /// Pod创建时间
    var createTime:String?



    public override init(){
            super.init()
    }

    enum PodCodingKeys: String, CodingKey {
        case podId
        case name
        case descriptionValue = "description"
        case az
        case hostname
        case instanceType
        case restartPolicy
        case terminationGracePeriodSeconds
        case vpcId
        case subnetId
        case privateIpAddress
        case dnsConfig
        case logConfig
        case hostAliases
        case volumes
        case containers
        case podStatus
        case elasticIp
        case primaryNetworkInterface
        case tags
        case charge
        case createTime
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: PodCodingKeys.self)
        if decoderContainer.contains(.podId)
        {
            self.podId = try decoderContainer.decode(String?.self, forKey: .podId)
        }
        if decoderContainer.contains(.name)
        {
            self.name = try decoderContainer.decode(String?.self, forKey: .name)
        }
        if decoderContainer.contains(.descriptionValue)
        {
            self.descriptionValue = try decoderContainer.decode(String?.self, forKey: .descriptionValue)
        }
        if decoderContainer.contains(.az)
        {
            self.az = try decoderContainer.decode(String?.self, forKey: .az)
        }
        if decoderContainer.contains(.hostname)
        {
            self.hostname = try decoderContainer.decode(String?.self, forKey: .hostname)
        }
        if decoderContainer.contains(.instanceType)
        {
            self.instanceType = try decoderContainer.decode(String?.self, forKey: .instanceType)
        }
        if decoderContainer.contains(.restartPolicy)
        {
            self.restartPolicy = try decoderContainer.decode(String?.self, forKey: .restartPolicy)
        }
        if decoderContainer.contains(.terminationGracePeriodSeconds)
        {
            self.terminationGracePeriodSeconds = try decoderContainer.decode(Int?.self, forKey: .terminationGracePeriodSeconds)
        }
        if decoderContainer.contains(.vpcId)
        {
            self.vpcId = try decoderContainer.decode(String?.self, forKey: .vpcId)
        }
        if decoderContainer.contains(.subnetId)
        {
            self.subnetId = try decoderContainer.decode(String?.self, forKey: .subnetId)
        }
        if decoderContainer.contains(.privateIpAddress)
        {
            self.privateIpAddress = try decoderContainer.decode(String?.self, forKey: .privateIpAddress)
        }
        if decoderContainer.contains(.dnsConfig)
        {
            self.dnsConfig = try decoderContainer.decode(DnsConfig?.self, forKey: .dnsConfig)
        }
        if decoderContainer.contains(.logConfig)
        {
            self.logConfig = try decoderContainer.decode(LogConfig?.self, forKey: .logConfig)
        }
        if decoderContainer.contains(.hostAliases)
        {
            self.hostAliases = try decoderContainer.decode([HostAlias?]?.self, forKey: .hostAliases)
        }
        if decoderContainer.contains(.volumes)
        {
            self.volumes = try decoderContainer.decode([Volume?]?.self, forKey: .volumes)
        }
        if decoderContainer.contains(.containers)
        {
            self.containers = try decoderContainer.decode([Container?]?.self, forKey: .containers)
        }
        if decoderContainer.contains(.podStatus)
        {
            self.podStatus = try decoderContainer.decode(PodStatus?.self, forKey: .podStatus)
        }
        if decoderContainer.contains(.elasticIp)
        {
            self.elasticIp = try decoderContainer.decode(ElasticIp?.self, forKey: .elasticIp)
        }
        if decoderContainer.contains(.primaryNetworkInterface)
        {
            self.primaryNetworkInterface = try decoderContainer.decode(NetworkInterfaceAttachment?.self, forKey: .primaryNetworkInterface)
        }
        if decoderContainer.contains(.tags)
        {
            self.tags = try decoderContainer.decode([Tag?]?.self, forKey: .tags)
        }
        if decoderContainer.contains(.charge)
        {
            self.charge = try decoderContainer.decode(Charge?.self, forKey: .charge)
        }
        if decoderContainer.contains(.createTime)
        {
            self.createTime = try decoderContainer.decode(String?.self, forKey: .createTime)
        }
    }
}
public extension Pod{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: PodCodingKeys.self)
         try encoderContainer.encode(podId, forKey: .podId)
         try encoderContainer.encode(name, forKey: .name)
         try encoderContainer.encode(descriptionValue, forKey: .descriptionValue)
         try encoderContainer.encode(az, forKey: .az)
         try encoderContainer.encode(hostname, forKey: .hostname)
         try encoderContainer.encode(instanceType, forKey: .instanceType)
         try encoderContainer.encode(restartPolicy, forKey: .restartPolicy)
         try encoderContainer.encode(terminationGracePeriodSeconds, forKey: .terminationGracePeriodSeconds)
         try encoderContainer.encode(vpcId, forKey: .vpcId)
         try encoderContainer.encode(subnetId, forKey: .subnetId)
         try encoderContainer.encode(privateIpAddress, forKey: .privateIpAddress)
         try encoderContainer.encode(dnsConfig, forKey: .dnsConfig)
         try encoderContainer.encode(logConfig, forKey: .logConfig)
         try encoderContainer.encode(hostAliases, forKey: .hostAliases)
         try encoderContainer.encode(volumes, forKey: .volumes)
         try encoderContainer.encode(containers, forKey: .containers)
         try encoderContainer.encode(podStatus, forKey: .podStatus)
         try encoderContainer.encode(elasticIp, forKey: .elasticIp)
         try encoderContainer.encode(primaryNetworkInterface, forKey: .primaryNetworkInterface)
         try encoderContainer.encode(tags, forKey: .tags)
         try encoderContainer.encode(charge, forKey: .charge)
         try encoderContainer.encode(createTime, forKey: .createTime)
    }
}
///  pod 中容器的计算资源配置。
      /// - resources 中，limit 和 request 不传，继续使用原有大小，建议调整实例类型同时调整 resources；
      /// - resources 中，request不传且原有的 request &#x3D; 0 时，request仍为 0；limit不传且原有limit为flavor最大值时，调整limit为新flavor最大值；
      /// - 无论是否扩、缩容，调整后的 containerResources 不可超过实例类型限制。
      /// 
public class ContainerResourceSpec:NSObject,Codable{
    /// 容器名称
    /// Required:true
    var name:String
    /// 容器计算资源配置
    /// Required:true
    var resources:ResourceRequestsSpec



    public  init(name:String,resources:ResourceRequestsSpec){
             self.name = name
             self.resources = resources
    }

    enum ContainerResourceSpecCodingKeys: String, CodingKey {
        case name
        case resources
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: ContainerResourceSpecCodingKeys.self)
        self.name = try decoderContainer.decode(String.self, forKey: .name)
        self.resources = try decoderContainer.decode(ResourceRequestsSpec.self, forKey: .resources)
    }
}
public extension ContainerResourceSpec{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: ContainerResourceSpecCodingKeys.self)
         try encoderContainer.encode(name, forKey: .name)
         try encoderContainer.encode(resources, forKey: .resources)
    }
}
///  pod volume 规格
public class Volume:NSObject,Codable{
    /// volume名字，在一个Pod唯一。
    var name:String?
    /// 提供给Pod的cloud disk.
    var jdcloudDisk:JDCloudVolumeSource?



    public override init(){
            super.init()
    }

    enum VolumeCodingKeys: String, CodingKey {
        case name
        case jdcloudDisk
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: VolumeCodingKeys.self)
        if decoderContainer.contains(.name)
        {
            self.name = try decoderContainer.decode(String?.self, forKey: .name)
        }
        if decoderContainer.contains(.jdcloudDisk)
        {
            self.jdcloudDisk = try decoderContainer.decode(JDCloudVolumeSource?.self, forKey: .jdcloudDisk)
        }
    }
}
public extension Volume{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: VolumeCodingKeys.self)
         try encoderContainer.encode(name, forKey: .name)
         try encoderContainer.encode(jdcloudDisk, forKey: .jdcloudDisk)
    }
}
///  容器规格
public class ContainerSpec:NSObject,Codable{
    /// 容器名称，符合DNS-1123 label规范，在一个Pod内不能重复。
    /// Required:true
    var name:String
    /// 容器执行命令，如果不指定默认是docker镜像的ENTRYPOINT。总长度256个字符。
    var command:[String?]?
    /// 容器执行命令的参数，如果不指定默认是docker镜像的CMD。总长度2048个字符。
    var args:[String?]?
    /// 容器执行的环境变量；如果和镜像中的环境变量Key相同，会覆盖镜像中的值。数组范围：[0-100]
    var env:[EnvSpec?]?
    /// 镜像名称 &lt;/br&gt;
      /// 容器镜像名字。 nginx:latest。长度范围：[1-639]
      /// 1. Docker Hub官方镜像通过类似nginx, mysql/mysql-server的名字指定 &lt;/br&gt; 
      /// 2. repository长度最大256个字符，tag最大128个字符，registry最大255个字符 &lt;/br&gt; 
      /// 
    /// Required:true
    var image:String
    /// 镜像仓库认证信息。如果目前不传，默认选择dockerHub镜像
    var secret:String?
    /// 容器是否分配tty。默认不分配
    var tty:Bool?
    /// 容器的工作目录。如果不指定，默认是根目录（/）；必须是绝对路径；长度范围：[0-1024]
    var workingDir:String?
    /// 容器存活探针配置
    var livenessProbe:ProbeSpec?
    /// 容器服务就绪探针配置
    var readinessProbe:ProbeSpec?
    /// 容器计算资源配置
    var resources:ResourceRequestsSpec?
    /// 容器计算资源配置
    /// Required:true
    var systemDisk:CloudDiskSpec
    /// 云盘挂载信息
    var volumeMounts:[VolumeMountSpec?]?



    public  init(name:String,image:String,systemDisk:CloudDiskSpec){
             self.name = name
             self.image = image
             self.systemDisk = systemDisk
    }

    enum ContainerSpecCodingKeys: String, CodingKey {
        case name
        case command
        case args
        case env
        case image
        case secret
        case tty
        case workingDir
        case livenessProbe
        case readinessProbe
        case resources
        case systemDisk
        case volumeMounts
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: ContainerSpecCodingKeys.self)
        self.name = try decoderContainer.decode(String.self, forKey: .name)
        if decoderContainer.contains(.command)
        {
            self.command = try decoderContainer.decode([String?]?.self, forKey: .command)
        }
        if decoderContainer.contains(.args)
        {
            self.args = try decoderContainer.decode([String?]?.self, forKey: .args)
        }
        if decoderContainer.contains(.env)
        {
            self.env = try decoderContainer.decode([EnvSpec?]?.self, forKey: .env)
        }
        self.image = try decoderContainer.decode(String.self, forKey: .image)
        if decoderContainer.contains(.secret)
        {
            self.secret = try decoderContainer.decode(String?.self, forKey: .secret)
        }
        if decoderContainer.contains(.tty)
        {
            self.tty = try decoderContainer.decode(Bool?.self, forKey: .tty)
        }
        if decoderContainer.contains(.workingDir)
        {
            self.workingDir = try decoderContainer.decode(String?.self, forKey: .workingDir)
        }
        if decoderContainer.contains(.livenessProbe)
        {
            self.livenessProbe = try decoderContainer.decode(ProbeSpec?.self, forKey: .livenessProbe)
        }
        if decoderContainer.contains(.readinessProbe)
        {
            self.readinessProbe = try decoderContainer.decode(ProbeSpec?.self, forKey: .readinessProbe)
        }
        if decoderContainer.contains(.resources)
        {
            self.resources = try decoderContainer.decode(ResourceRequestsSpec?.self, forKey: .resources)
        }
        self.systemDisk = try decoderContainer.decode(CloudDiskSpec.self, forKey: .systemDisk)
        if decoderContainer.contains(.volumeMounts)
        {
            self.volumeMounts = try decoderContainer.decode([VolumeMountSpec?]?.self, forKey: .volumeMounts)
        }
    }
}
public extension ContainerSpec{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: ContainerSpecCodingKeys.self)
         try encoderContainer.encode(name, forKey: .name)
         try encoderContainer.encode(command, forKey: .command)
         try encoderContainer.encode(args, forKey: .args)
         try encoderContainer.encode(env, forKey: .env)
         try encoderContainer.encode(image, forKey: .image)
         try encoderContainer.encode(secret, forKey: .secret)
         try encoderContainer.encode(tty, forKey: .tty)
         try encoderContainer.encode(workingDir, forKey: .workingDir)
         try encoderContainer.encode(livenessProbe, forKey: .livenessProbe)
         try encoderContainer.encode(readinessProbe, forKey: .readinessProbe)
         try encoderContainer.encode(resources, forKey: .resources)
         try encoderContainer.encode(systemDisk, forKey: .systemDisk)
         try encoderContainer.encode(volumeMounts, forKey: .volumeMounts)
    }
}
///  描述实例的网卡信息
public class InstanceNetworkInterface:NSObject,Codable{
    /// 弹性网卡ID
    var networkInterfaceId:String?
    /// 以太网地址
    var macAddress:String?
    /// 虚拟网络ID
    var vpcId:String?
    /// 子网ID
    var subnetId:String?
    /// 描述
    var descriptionValue:String?
    /// 安全组列表
    var securityGroups:[SecurityGroupSimple?]?
    /// 源和目标IP地址校验，取值为0或者1
    var sanityCheck:Bool?
    /// 网卡主IP
    var primaryIp:NetworkInterfacePrivateIp?
    /// SecondaryIps
    var secondaryIps:[NetworkInterfacePrivateIp?]?



    public override init(){
            super.init()
    }

    enum InstanceNetworkInterfaceCodingKeys: String, CodingKey {
        case networkInterfaceId
        case macAddress
        case vpcId
        case subnetId
        case descriptionValue = "description"
        case securityGroups
        case sanityCheck
        case primaryIp
        case secondaryIps
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: InstanceNetworkInterfaceCodingKeys.self)
        if decoderContainer.contains(.networkInterfaceId)
        {
            self.networkInterfaceId = try decoderContainer.decode(String?.self, forKey: .networkInterfaceId)
        }
        if decoderContainer.contains(.macAddress)
        {
            self.macAddress = try decoderContainer.decode(String?.self, forKey: .macAddress)
        }
        if decoderContainer.contains(.vpcId)
        {
            self.vpcId = try decoderContainer.decode(String?.self, forKey: .vpcId)
        }
        if decoderContainer.contains(.subnetId)
        {
            self.subnetId = try decoderContainer.decode(String?.self, forKey: .subnetId)
        }
        if decoderContainer.contains(.descriptionValue)
        {
            self.descriptionValue = try decoderContainer.decode(String?.self, forKey: .descriptionValue)
        }
        if decoderContainer.contains(.securityGroups)
        {
            self.securityGroups = try decoderContainer.decode([SecurityGroupSimple?]?.self, forKey: .securityGroups)
        }
        if decoderContainer.contains(.sanityCheck)
        {
            self.sanityCheck = try decoderContainer.decode(Bool?.self, forKey: .sanityCheck)
        }
        if decoderContainer.contains(.primaryIp)
        {
            self.primaryIp = try decoderContainer.decode(NetworkInterfacePrivateIp?.self, forKey: .primaryIp)
        }
        if decoderContainer.contains(.secondaryIps)
        {
            self.secondaryIps = try decoderContainer.decode([NetworkInterfacePrivateIp?]?.self, forKey: .secondaryIps)
        }
    }
}
public extension InstanceNetworkInterface{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: InstanceNetworkInterfaceCodingKeys.self)
         try encoderContainer.encode(networkInterfaceId, forKey: .networkInterfaceId)
         try encoderContainer.encode(macAddress, forKey: .macAddress)
         try encoderContainer.encode(vpcId, forKey: .vpcId)
         try encoderContainer.encode(subnetId, forKey: .subnetId)
         try encoderContainer.encode(descriptionValue, forKey: .descriptionValue)
         try encoderContainer.encode(securityGroups, forKey: .securityGroups)
         try encoderContainer.encode(sanityCheck, forKey: .sanityCheck)
         try encoderContainer.encode(primaryIp, forKey: .primaryIp)
         try encoderContainer.encode(secondaryIps, forKey: .secondaryIps)
    }
}
///  pod 状态
public class PodStatus:NSObject,Codable{
    /// pod当前状态
    var phase:String?
    /// （简要）pod处于当前状态的原因
    var reason:String?
    /// pod处于当前状态原因的详细信息
    var message:String?
    /// 分配给pod的IP地址。至少在集群内是可路由的。未分配则为空。
    var podIP:String?
    /// 目前pod的状态。
    var conditions:[PodCondition?]?
    /// Pod生命周期开始的时间。
    var startTime:String?



    public override init(){
            super.init()
    }

    enum PodStatusCodingKeys: String, CodingKey {
        case phase
        case reason
        case message
        case podIP
        case conditions
        case startTime
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: PodStatusCodingKeys.self)
        if decoderContainer.contains(.phase)
        {
            self.phase = try decoderContainer.decode(String?.self, forKey: .phase)
        }
        if decoderContainer.contains(.reason)
        {
            self.reason = try decoderContainer.decode(String?.self, forKey: .reason)
        }
        if decoderContainer.contains(.message)
        {
            self.message = try decoderContainer.decode(String?.self, forKey: .message)
        }
        if decoderContainer.contains(.podIP)
        {
            self.podIP = try decoderContainer.decode(String?.self, forKey: .podIP)
        }
        if decoderContainer.contains(.conditions)
        {
            self.conditions = try decoderContainer.decode([PodCondition?]?.self, forKey: .conditions)
        }
        if decoderContainer.contains(.startTime)
        {
            self.startTime = try decoderContainer.decode(String?.self, forKey: .startTime)
        }
    }
}
public extension PodStatus{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: PodStatusCodingKeys.self)
         try encoderContainer.encode(phase, forKey: .phase)
         try encoderContainer.encode(reason, forKey: .reason)
         try encoderContainer.encode(message, forKey: .message)
         try encoderContainer.encode(podIP, forKey: .podIP)
         try encoderContainer.encode(conditions, forKey: .conditions)
         try encoderContainer.encode(startTime, forKey: .startTime)
    }
}
///  jDCloudVolumeSource
public class JDCloudVolumeSource:NSObject,Codable{
    /// 云盘id，使用已有云盘
    var volumeId:String?
    /// 云盘快照id，根据云盘快照创建云盘。
    var snapshotId:String?
    /// 云盘类型：hdd.std1,ssd.gp1,ssd.io1
    var diskType:String?
    /// 云盘size,单位 GB,要求
    var sizeGB:Int?
    /// 指定volume文件系统类型，目前支持[xfs, ext4]；如果新创建的盘，不指定文件系统类型默认格式化成xfs
    var fsType:String?
    /// 随容器自动创建的新盘，会自动格式化成指定的文件系统类型；挂载已有的盘，默认不会格式化，只会按照指定的fsType去挂载；如果希望格式化，必须设置此字段为true
    var formatVolume:Bool?
    /// 云盘的 iops 值，目前只有 ssd.io1 类型有效
    var iops:Int?
    /// 是否随pod删除。默认：true
    var autoDelete:Bool?



    public override init(){
            super.init()
    }

    enum JDCloudVolumeSourceCodingKeys: String, CodingKey {
        case volumeId
        case snapshotId
        case diskType
        case sizeGB
        case fsType
        case formatVolume
        case iops
        case autoDelete
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: JDCloudVolumeSourceCodingKeys.self)
        if decoderContainer.contains(.volumeId)
        {
            self.volumeId = try decoderContainer.decode(String?.self, forKey: .volumeId)
        }
        if decoderContainer.contains(.snapshotId)
        {
            self.snapshotId = try decoderContainer.decode(String?.self, forKey: .snapshotId)
        }
        if decoderContainer.contains(.diskType)
        {
            self.diskType = try decoderContainer.decode(String?.self, forKey: .diskType)
        }
        if decoderContainer.contains(.sizeGB)
        {
            self.sizeGB = try decoderContainer.decode(Int?.self, forKey: .sizeGB)
        }
        if decoderContainer.contains(.fsType)
        {
            self.fsType = try decoderContainer.decode(String?.self, forKey: .fsType)
        }
        if decoderContainer.contains(.formatVolume)
        {
            self.formatVolume = try decoderContainer.decode(Bool?.self, forKey: .formatVolume)
        }
        if decoderContainer.contains(.iops)
        {
            self.iops = try decoderContainer.decode(Int?.self, forKey: .iops)
        }
        if decoderContainer.contains(.autoDelete)
        {
            self.autoDelete = try decoderContainer.decode(Bool?.self, forKey: .autoDelete)
        }
    }
}
public extension JDCloudVolumeSource{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: JDCloudVolumeSourceCodingKeys.self)
         try encoderContainer.encode(volumeId, forKey: .volumeId)
         try encoderContainer.encode(snapshotId, forKey: .snapshotId)
         try encoderContainer.encode(diskType, forKey: .diskType)
         try encoderContainer.encode(sizeGB, forKey: .sizeGB)
         try encoderContainer.encode(fsType, forKey: .fsType)
         try encoderContainer.encode(formatVolume, forKey: .formatVolume)
         try encoderContainer.encode(iops, forKey: .iops)
         try encoderContainer.encode(autoDelete, forKey: .autoDelete)
    }
}
///  jDCloudVolumeSourceSpec
public class JDCloudVolumeSourceSpec:NSObject,Codable{
    /// 云盘id，使用已有云盘
    var volumeId:String?
    /// 云盘名称
    var name:String?
    /// 云盘快照id，根据云盘快照创建云盘。
    var snapshotId:String?
    /// 云盘类型：hdd.std1,ssd.gp1,ssd.io1
    var diskType:String?
    /// 云盘size,单位 GB
    var sizeGB:Int?
    /// 指定volume文件系统类型，目前支持[xfs, ext4]；如果新创建的盘，不指定文件系统类型默认格式化成xfs。
    /// Required:true
    var fsType:String
    /// 随容器自动创建的新盘，会自动格式化成指定的文件系统类型；挂载已有的盘，默认不会格式化，只会按照指定的fsType去挂载；如果希望格式化，必须设置此字段为true。
    var formatVolume:Bool?
    /// 云盘的 iops 值，目前只有 ssd.io1 类型有效。
    var iops:Int?
    /// 是否随pod删除。默认：true
    var autoDelete:Bool?



    public  init(fsType:String){
             self.fsType = fsType
    }

    enum JDCloudVolumeSourceSpecCodingKeys: String, CodingKey {
        case volumeId
        case name
        case snapshotId
        case diskType
        case sizeGB
        case fsType
        case formatVolume
        case iops
        case autoDelete
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: JDCloudVolumeSourceSpecCodingKeys.self)
        if decoderContainer.contains(.volumeId)
        {
            self.volumeId = try decoderContainer.decode(String?.self, forKey: .volumeId)
        }
        if decoderContainer.contains(.name)
        {
            self.name = try decoderContainer.decode(String?.self, forKey: .name)
        }
        if decoderContainer.contains(.snapshotId)
        {
            self.snapshotId = try decoderContainer.decode(String?.self, forKey: .snapshotId)
        }
        if decoderContainer.contains(.diskType)
        {
            self.diskType = try decoderContainer.decode(String?.self, forKey: .diskType)
        }
        if decoderContainer.contains(.sizeGB)
        {
            self.sizeGB = try decoderContainer.decode(Int?.self, forKey: .sizeGB)
        }
        self.fsType = try decoderContainer.decode(String.self, forKey: .fsType)
        if decoderContainer.contains(.formatVolume)
        {
            self.formatVolume = try decoderContainer.decode(Bool?.self, forKey: .formatVolume)
        }
        if decoderContainer.contains(.iops)
        {
            self.iops = try decoderContainer.decode(Int?.self, forKey: .iops)
        }
        if decoderContainer.contains(.autoDelete)
        {
            self.autoDelete = try decoderContainer.decode(Bool?.self, forKey: .autoDelete)
        }
    }
}
public extension JDCloudVolumeSourceSpec{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: JDCloudVolumeSourceSpecCodingKeys.self)
         try encoderContainer.encode(volumeId, forKey: .volumeId)
         try encoderContainer.encode(name, forKey: .name)
         try encoderContainer.encode(snapshotId, forKey: .snapshotId)
         try encoderContainer.encode(diskType, forKey: .diskType)
         try encoderContainer.encode(sizeGB, forKey: .sizeGB)
         try encoderContainer.encode(fsType, forKey: .fsType)
         try encoderContainer.encode(formatVolume, forKey: .formatVolume)
         try encoderContainer.encode(iops, forKey: .iops)
         try encoderContainer.encode(autoDelete, forKey: .autoDelete)
    }
}
///  tcpSocketSpec
public class TcpSocketSpec:NSObject,Codable{
    /// 端口号，范围：[1-65535]
    /// Required:true
    var port:Int



    public  init(port:Int){
             self.port = port
    }

    enum TcpSocketSpecCodingKeys: String, CodingKey {
        case port
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: TcpSocketSpecCodingKeys.self)
        self.port = try decoderContainer.decode(Int.self, forKey: .port)
    }
}
public extension TcpSocketSpec{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: TcpSocketSpecCodingKeys.self)
         try encoderContainer.encode(port, forKey: .port)
    }
}
///  tag
public class Tag:NSObject,Codable{
    /// Tag键
    var key:String?
    /// Tag值
    var value:String?



    public override init(){
            super.init()
    }

    enum TagCodingKeys: String, CodingKey {
        case key
        case value
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: TagCodingKeys.self)
        if decoderContainer.contains(.key)
        {
            self.key = try decoderContainer.decode(String?.self, forKey: .key)
        }
        if decoderContainer.contains(.value)
        {
            self.value = try decoderContainer.decode(String?.self, forKey: .value)
        }
    }
}
public extension Tag{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: TagCodingKeys.self)
         try encoderContainer.encode(key, forKey: .key)
         try encoderContainer.encode(value, forKey: .value)
    }
}
///  容器日志配置信息。
public class LogConfigSpec:NSObject,Codable{
    /// 日志Driver名称，目前只支持默认为每一个容器在本地分配10MB的存储空间，自动rotate。目前仅支持default。默认值：default。
    var logDriver:String?



    public override init(){
            super.init()
    }

    enum LogConfigSpecCodingKeys: String, CodingKey {
        case logDriver
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: LogConfigSpecCodingKeys.self)
        if decoderContainer.contains(.logDriver)
        {
            self.logDriver = try decoderContainer.decode(String?.self, forKey: .logDriver)
        }
    }
}
public extension LogConfigSpec{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: LogConfigSpecCodingKeys.self)
         try encoderContainer.encode(logDriver, forKey: .logDriver)
    }
}
///  域名和IP映射的信息
public class HostAliasSpec:NSObject,Codable{
    /// 域名列表。&lt;br&gt;
      /// eg  [&quot;foo.local&quot;, &quot;bar.local&quot;]。长度范围 1-10; 元素符合hostname命名规范。
      /// 
    /// Required:true
    var hostnames:[String?]?
    /// ipv4地址；eg &quot;127.0.0.1&quot;
    /// Required:true
    var ip:String



    public  init(hostnames:[String?]?,ip:String){
             self.hostnames = hostnames
             self.ip = ip
    }

    enum HostAliasSpecCodingKeys: String, CodingKey {
        case hostnames
        case ip
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: HostAliasSpecCodingKeys.self)
        self.hostnames = try decoderContainer.decode([String?]?.self, forKey: .hostnames)
        self.ip = try decoderContainer.decode(String.self, forKey: .ip)
    }
}
public extension HostAliasSpec{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: HostAliasSpecCodingKeys.self)
         try encoderContainer.encode(hostnames, forKey: .hostnames)
         try encoderContainer.encode(ip, forKey: .ip)
    }
}
///  httpGetSpec
public class HgSpec:NSObject,Codable{
    /// 默认值：http；可选值 http, https, HTTP, HTTPS。
    var scheme:String?
    /// 连接到pod的host信息，默认使用pod_ip，满足hostname或者ipv4格式. 长度范围:[0-253]
    var host:String?
    /// 端口号。范围：[1-65535]
    /// Required:true
    var port:Int
    /// HTTP的路径。范围：[1-256]
    /// Required:true
    var path:String
    /// 自定义Http headers
    var httpHeader:[HhSpec?]?



    public  init(port:Int,path:String){
             self.port = port
             self.path = path
    }

    enum HgSpecCodingKeys: String, CodingKey {
        case scheme
        case host
        case port
        case path
        case httpHeader
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: HgSpecCodingKeys.self)
        if decoderContainer.contains(.scheme)
        {
            self.scheme = try decoderContainer.decode(String?.self, forKey: .scheme)
        }
        if decoderContainer.contains(.host)
        {
            self.host = try decoderContainer.decode(String?.self, forKey: .host)
        }
        self.port = try decoderContainer.decode(Int.self, forKey: .port)
        self.path = try decoderContainer.decode(String.self, forKey: .path)
        if decoderContainer.contains(.httpHeader)
        {
            self.httpHeader = try decoderContainer.decode([HhSpec?]?.self, forKey: .httpHeader)
        }
    }
}
public extension HgSpec{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: HgSpecCodingKeys.self)
         try encoderContainer.encode(scheme, forKey: .scheme)
         try encoderContainer.encode(host, forKey: .host)
         try encoderContainer.encode(port, forKey: .port)
         try encoderContainer.encode(path, forKey: .path)
         try encoderContainer.encode(httpHeader, forKey: .httpHeader)
    }
}
///  DNS解析器选项。
public class PodDnsConfigOption:NSObject,Codable{
    /// 长度范围：[1-63]，需满足linux resolver限制
    var name:String?
    /// 长度范围：[0-100]，仅限timeout, attempts, ndots
    var value:String?



    public override init(){
            super.init()
    }

    enum PodDnsConfigOptionCodingKeys: String, CodingKey {
        case name
        case value
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: PodDnsConfigOptionCodingKeys.self)
        if decoderContainer.contains(.name)
        {
            self.name = try decoderContainer.decode(String?.self, forKey: .name)
        }
        if decoderContainer.contains(.value)
        {
            self.value = try decoderContainer.decode(String?.self, forKey: .value)
        }
    }
}
public extension PodDnsConfigOption{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: PodDnsConfigOptionCodingKeys.self)
         try encoderContainer.encode(name, forKey: .name)
         try encoderContainer.encode(value, forKey: .value)
    }
}
///  容器环境变量。
public class EnvSpec:NSObject,Codable{
    /// 环境变量名称（ASCII）。范围：[1-64]。必须为字母、数字、下划线(_)，正则为&#x60;^[a-zA-Z0-9]*$&#x60;。
    /// Required:true
    var name:String
    /// 环境变量取值。范围：[0-1024]
    var value:String?



    public  init(name:String){
             self.name = name
    }

    enum EnvSpecCodingKeys: String, CodingKey {
        case name
        case value
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: EnvSpecCodingKeys.self)
        self.name = try decoderContainer.decode(String.self, forKey: .name)
        if decoderContainer.contains(.value)
        {
            self.value = try decoderContainer.decode(String?.self, forKey: .value)
        }
    }
}
public extension EnvSpec{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: EnvSpecCodingKeys.self)
         try encoderContainer.encode(name, forKey: .name)
         try encoderContainer.encode(value, forKey: .value)
    }
}
///  容器系统盘配置
public class CloudDiskSpec:NSObject,Codable{
    /// 云盘ID，指定使用已有云盘
    var volumeId:String?
    /// 云盘名称
    var name:String?
    /// 云盘快照ID，根据云盘快照创建云盘。
    var snapshotId:String?
    /// 云盘类型：hdd.std1,ssd.gp1,ssd.io1
    var diskType:String?
    /// 云盘size,单位 GB,要求
    var sizeGB:Int?
    /// 指定volume文件系统类型，目前支持[xfs, ext4]；如果新创建的盘，不指定文件系统类型默认格式化成xfs
    var fsType:String?
    /// 云盘的 iops 值，目前只有 ssd.io1 类型有效
    var iops:Int?
    /// 是否随pod删除。默认：true
    var autoDelete:Bool?



    public override init(){
            super.init()
    }

    enum CloudDiskSpecCodingKeys: String, CodingKey {
        case volumeId
        case name
        case snapshotId
        case diskType
        case sizeGB
        case fsType
        case iops
        case autoDelete
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: CloudDiskSpecCodingKeys.self)
        if decoderContainer.contains(.volumeId)
        {
            self.volumeId = try decoderContainer.decode(String?.self, forKey: .volumeId)
        }
        if decoderContainer.contains(.name)
        {
            self.name = try decoderContainer.decode(String?.self, forKey: .name)
        }
        if decoderContainer.contains(.snapshotId)
        {
            self.snapshotId = try decoderContainer.decode(String?.self, forKey: .snapshotId)
        }
        if decoderContainer.contains(.diskType)
        {
            self.diskType = try decoderContainer.decode(String?.self, forKey: .diskType)
        }
        if decoderContainer.contains(.sizeGB)
        {
            self.sizeGB = try decoderContainer.decode(Int?.self, forKey: .sizeGB)
        }
        if decoderContainer.contains(.fsType)
        {
            self.fsType = try decoderContainer.decode(String?.self, forKey: .fsType)
        }
        if decoderContainer.contains(.iops)
        {
            self.iops = try decoderContainer.decode(Int?.self, forKey: .iops)
        }
        if decoderContainer.contains(.autoDelete)
        {
            self.autoDelete = try decoderContainer.decode(Bool?.self, forKey: .autoDelete)
        }
    }
}
public extension CloudDiskSpec{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: CloudDiskSpecCodingKeys.self)
         try encoderContainer.encode(volumeId, forKey: .volumeId)
         try encoderContainer.encode(name, forKey: .name)
         try encoderContainer.encode(snapshotId, forKey: .snapshotId)
         try encoderContainer.encode(diskType, forKey: .diskType)
         try encoderContainer.encode(sizeGB, forKey: .sizeGB)
         try encoderContainer.encode(fsType, forKey: .fsType)
         try encoderContainer.encode(iops, forKey: .iops)
         try encoderContainer.encode(autoDelete, forKey: .autoDelete)
    }
}
///  httpHeaderSpec
public class HhSpec:NSObject,Codable{
    /// http header 键，需满足http的规则。长度范围:[1-64]
    /// Required:true
    var name:String
    /// http header 值
    /// Required:true
    var value:String



    public  init(name:String,value:String){
             self.name = name
             self.value = value
    }

    enum HhSpecCodingKeys: String, CodingKey {
        case name
        case value
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: HhSpecCodingKeys.self)
        self.name = try decoderContainer.decode(String.self, forKey: .name)
        self.value = try decoderContainer.decode(String.self, forKey: .value)
    }
}
public extension HhSpec{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: HhSpecCodingKeys.self)
         try encoderContainer.encode(name, forKey: .name)
         try encoderContainer.encode(value, forKey: .value)
    }
}
///  execSpec
public class ExecSpec:NSObject,Codable{
    /// 执行的命令，总长度256个字符。
    /// Required:true
    var command:[String?]?



    public  init(command:[String?]?){
             self.command = command
    }

    enum ExecSpecCodingKeys: String, CodingKey {
        case command
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: ExecSpecCodingKeys.self)
        self.command = try decoderContainer.decode([String?]?.self, forKey: .command)
    }
}
public extension ExecSpec{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: ExecSpecCodingKeys.self)
         try encoderContainer.encode(command, forKey: .command)
    }
}
///  主网卡配置信息。
public class NetworkInterfaceAttachmentSpec:NSObject,Codable{
    /// 指明删除pod时是否删除网卡，默认True；当前只能是True
    var autoDelete:Bool?
    /// 设备Index，目前pod只支持一个网卡，所以只能设置为1
    var deviceIndex:Int?
    /// 网卡接口规范
    /// Required:true
    var networkInterface:NetworkInterfaceSpec



    public  init(networkInterface:NetworkInterfaceSpec){
             self.networkInterface = networkInterface
    }

    enum NetworkInterfaceAttachmentSpecCodingKeys: String, CodingKey {
        case autoDelete
        case deviceIndex
        case networkInterface
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: NetworkInterfaceAttachmentSpecCodingKeys.self)
        if decoderContainer.contains(.autoDelete)
        {
            self.autoDelete = try decoderContainer.decode(Bool?.self, forKey: .autoDelete)
        }
        if decoderContainer.contains(.deviceIndex)
        {
            self.deviceIndex = try decoderContainer.decode(Int?.self, forKey: .deviceIndex)
        }
        self.networkInterface = try decoderContainer.decode(NetworkInterfaceSpec.self, forKey: .networkInterface)
    }
}
public extension NetworkInterfaceAttachmentSpec{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: NetworkInterfaceAttachmentSpecCodingKeys.self)
         try encoderContainer.encode(autoDelete, forKey: .autoDelete)
         try encoderContainer.encode(deviceIndex, forKey: .deviceIndex)
         try encoderContainer.encode(networkInterface, forKey: .networkInterface)
    }
}
///  主网卡配置信息。
public class NetworkInterfaceAttachment:NSObject,Codable{
    /// 指明删除pod时是否删除网卡。
    var autoDelete:Bool?
    /// 设备Index，目前pod只支持一个网卡，所以只能设置为1
    var deviceIndex:Int?
    /// 绑定状态
    var attachStatus:String?
    /// 绑定时间
    var attachTime:String?
    /// 网卡接口规范
    var networkInterface:InstanceNetworkInterface?



    public override init(){
            super.init()
    }

    enum NetworkInterfaceAttachmentCodingKeys: String, CodingKey {
        case autoDelete
        case deviceIndex
        case attachStatus
        case attachTime
        case networkInterface
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: NetworkInterfaceAttachmentCodingKeys.self)
        if decoderContainer.contains(.autoDelete)
        {
            self.autoDelete = try decoderContainer.decode(Bool?.self, forKey: .autoDelete)
        }
        if decoderContainer.contains(.deviceIndex)
        {
            self.deviceIndex = try decoderContainer.decode(Int?.self, forKey: .deviceIndex)
        }
        if decoderContainer.contains(.attachStatus)
        {
            self.attachStatus = try decoderContainer.decode(String?.self, forKey: .attachStatus)
        }
        if decoderContainer.contains(.attachTime)
        {
            self.attachTime = try decoderContainer.decode(String?.self, forKey: .attachTime)
        }
        if decoderContainer.contains(.networkInterface)
        {
            self.networkInterface = try decoderContainer.decode(InstanceNetworkInterface?.self, forKey: .networkInterface)
        }
    }
}
public extension NetworkInterfaceAttachment{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: NetworkInterfaceAttachmentCodingKeys.self)
         try encoderContainer.encode(autoDelete, forKey: .autoDelete)
         try encoderContainer.encode(deviceIndex, forKey: .deviceIndex)
         try encoderContainer.encode(attachStatus, forKey: .attachStatus)
         try encoderContainer.encode(attachTime, forKey: .attachTime)
         try encoderContainer.encode(networkInterface, forKey: .networkInterface)
    }
}
///  域名和IP映射的信息
public class HostAlias:NSObject,Codable{
    /// 域名列表。
      /// 
    var hostnames:[String?]?
    /// ipv4地址。
    var ip:String?



    public override init(){
            super.init()
    }

    enum HostAliasCodingKeys: String, CodingKey {
        case hostnames
        case ip
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: HostAliasCodingKeys.self)
        if decoderContainer.contains(.hostnames)
        {
            self.hostnames = try decoderContainer.decode([String?]?.self, forKey: .hostnames)
        }
        if decoderContainer.contains(.ip)
        {
            self.ip = try decoderContainer.decode(String?.self, forKey: .ip)
        }
    }
}
public extension HostAlias{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: HostAliasCodingKeys.self)
         try encoderContainer.encode(hostnames, forKey: .hostnames)
         try encoderContainer.encode(ip, forKey: .ip)
    }
}
///  描述网卡私有Ip资源的信息
public class NetworkInterfacePrivateIp:NSObject,Codable{
    /// 私有IP的IPV4地址
    var privateIpAddress:String?
    /// 弹性IP ID
    var elasticIpId:String?
    /// 弹性IP实例地址
    var elasticIpAddress:String?



    public override init(){
            super.init()
    }

    enum NetworkInterfacePrivateIpCodingKeys: String, CodingKey {
        case privateIpAddress
        case elasticIpId
        case elasticIpAddress
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: NetworkInterfacePrivateIpCodingKeys.self)
        if decoderContainer.contains(.privateIpAddress)
        {
            self.privateIpAddress = try decoderContainer.decode(String?.self, forKey: .privateIpAddress)
        }
        if decoderContainer.contains(.elasticIpId)
        {
            self.elasticIpId = try decoderContainer.decode(String?.self, forKey: .elasticIpId)
        }
        if decoderContainer.contains(.elasticIpAddress)
        {
            self.elasticIpAddress = try decoderContainer.decode(String?.self, forKey: .elasticIpAddress)
        }
    }
}
public extension NetworkInterfacePrivateIp{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: NetworkInterfacePrivateIpCodingKeys.self)
         try encoderContainer.encode(privateIpAddress, forKey: .privateIpAddress)
         try encoderContainer.encode(elasticIpId, forKey: .elasticIpId)
         try encoderContainer.encode(elasticIpAddress, forKey: .elasticIpAddress)
    }
}
///  容器计算资源信息
      ///   - 容器必需的 CPU，不指定时按照 2m 处理
      /// 
public class ResourceRequestsSpec:NSObject,Codable{
    /// 容器必需的计算资源
    var requests:RequestSpec?
    /// 容器使用计算资源上限
    var limits:RequestSpec?



    public override init(){
            super.init()
    }

    enum ResourceRequestsSpecCodingKeys: String, CodingKey {
        case requests
        case limits
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: ResourceRequestsSpecCodingKeys.self)
        if decoderContainer.contains(.requests)
        {
            self.requests = try decoderContainer.decode(RequestSpec?.self, forKey: .requests)
        }
        if decoderContainer.contains(.limits)
        {
            self.limits = try decoderContainer.decode(RequestSpec?.self, forKey: .limits)
        }
    }
}
public extension ResourceRequestsSpec{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: ResourceRequestsSpecCodingKeys.self)
         try encoderContainer.encode(requests, forKey: .requests)
         try encoderContainer.encode(limits, forKey: .limits)
    }
}
///  pod volume 规格
public class VolumeSpec:NSObject,Codable{
    /// volume名字，符合DNS-1123 label规范，在一个Pod内唯一。
    /// Required:true
    var name:String
    /// 提供给Pod的cloud disk.
    /// Required:true
    var jdcloudDisk:JDCloudVolumeSourceSpec



    public  init(name:String,jdcloudDisk:JDCloudVolumeSourceSpec){
             self.name = name
             self.jdcloudDisk = jdcloudDisk
    }

    enum VolumeSpecCodingKeys: String, CodingKey {
        case name
        case jdcloudDisk
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: VolumeSpecCodingKeys.self)
        self.name = try decoderContainer.decode(String.self, forKey: .name)
        self.jdcloudDisk = try decoderContainer.decode(JDCloudVolumeSourceSpec.self, forKey: .jdcloudDisk)
    }
}
public extension VolumeSpec{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: VolumeSpecCodingKeys.self)
         try encoderContainer.encode(name, forKey: .name)
         try encoderContainer.encode(jdcloudDisk, forKey: .jdcloudDisk)
    }
}
///  容器挂载信息
public class VolumeMountSpec:NSObject,Codable{
    /// 要挂载的云盘，必须使用pod volumeSpec.name。
    /// Required:true
    var name:String
    /// 容器内挂载点，绝对路径，不得重复和嵌套挂载，不得挂载到根目录(&quot;/&quot;)。长度范围：[1-1024]
    /// Required:true
    var mountPath:String
    /// 是否以只读方式挂载。默认 读写模式
    var readOnly:Bool?



    public  init(name:String,mountPath:String){
             self.name = name
             self.mountPath = mountPath
    }

    enum VolumeMountSpecCodingKeys: String, CodingKey {
        case name
        case mountPath
        case readOnly
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: VolumeMountSpecCodingKeys.self)
        self.name = try decoderContainer.decode(String.self, forKey: .name)
        self.mountPath = try decoderContainer.decode(String.self, forKey: .mountPath)
        if decoderContainer.contains(.readOnly)
        {
            self.readOnly = try decoderContainer.decode(Bool?.self, forKey: .readOnly)
        }
    }
}
public extension VolumeMountSpec{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: VolumeMountSpecCodingKeys.self)
         try encoderContainer.encode(name, forKey: .name)
         try encoderContainer.encode(mountPath, forKey: .mountPath)
         try encoderContainer.encode(readOnly, forKey: .readOnly)
    }
}
///  pod 中的 dns 配置。
public class DnsConfigSpec:NSObject,Codable{
    /// DNS服务器IP地址列表，重复的将会被移除。&lt;br&gt;
      /// eg [&quot;8.8.8.8&quot;, &quot;4.2.2.2&quot;]。列表长度：[0-20]，列表中元素符合IPv4格式。
      /// 
    var nameservers:[String?]?
    /// DNS搜索域列表，用于主机名查找。&lt;br&gt;
      /// eg [&quot;ns1.svc.cluster.local&quot;, &quot;my.dns.search.suffix&quot;]。列表长度：[0-6]，列表中所有字符总长度不超过256个。
      /// 
    var searches:[String?]?
    /// DNS解析器选项列表。&lt;br&gt;
      /// eg [&quot;ndots&quot;:&quot;2&quot;, &quot;edns0&quot;:&quot;&quot;]。列表长度：[0-10]
    var options:[PodDnsConfigOptionSpec?]?



    public override init(){
            super.init()
    }

    enum DnsConfigSpecCodingKeys: String, CodingKey {
        case nameservers
        case searches
        case options
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: DnsConfigSpecCodingKeys.self)
        if decoderContainer.contains(.nameservers)
        {
            self.nameservers = try decoderContainer.decode([String?]?.self, forKey: .nameservers)
        }
        if decoderContainer.contains(.searches)
        {
            self.searches = try decoderContainer.decode([String?]?.self, forKey: .searches)
        }
        if decoderContainer.contains(.options)
        {
            self.options = try decoderContainer.decode([PodDnsConfigOptionSpec?]?.self, forKey: .options)
        }
    }
}
public extension DnsConfigSpec{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: DnsConfigSpecCodingKeys.self)
         try encoderContainer.encode(nameservers, forKey: .nameservers)
         try encoderContainer.encode(searches, forKey: .searches)
         try encoderContainer.encode(options, forKey: .options)
    }
}
///  弹性 ip 详情
public class ElasticIpSpec:NSObject,Codable{
    /// 弹性公网IP的限速（单位：MB）
    /// Required:true
    var bandwidthMbps:Int
    /// IP服务商，取值为bgp或no_bgp，默认：bgp
    var provider:String?
    /// 预付费（prepaid_by_duration）, 按配置后付费（postpaid_by_duration）。默认：按配置后付费
    var chargeSpec:ChargeSpec?



    public  init(bandwidthMbps:Int){
             self.bandwidthMbps = bandwidthMbps
    }

    enum ElasticIpSpecCodingKeys: String, CodingKey {
        case bandwidthMbps
        case provider
        case chargeSpec
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: ElasticIpSpecCodingKeys.self)
        self.bandwidthMbps = try decoderContainer.decode(Int.self, forKey: .bandwidthMbps)
        if decoderContainer.contains(.provider)
        {
            self.provider = try decoderContainer.decode(String?.self, forKey: .provider)
        }
        if decoderContainer.contains(.chargeSpec)
        {
            self.chargeSpec = try decoderContainer.decode(ChargeSpec?.self, forKey: .chargeSpec)
        }
    }
}
public extension ElasticIpSpec{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: ElasticIpSpecCodingKeys.self)
         try encoderContainer.encode(bandwidthMbps, forKey: .bandwidthMbps)
         try encoderContainer.encode(provider, forKey: .provider)
         try encoderContainer.encode(chargeSpec, forKey: .chargeSpec)
    }
}
///  容器探活方式。
public class ProbeSpec:NSObject,Codable{
    /// 容器启动多长时间后，触发探针。默认值：10秒；范围:[0-300]
    var initialDelaySeconds:Int?
    /// 探测的时间间隔。默认值 10秒，范围:[1-300]
    var periodSeconds:Int?
    /// 探测的超时时间。默认值 1秒；范围:[1-300]
    var timeoutSeconds:Int?
    /// 在成功状态后，连续探活失败的次数，认为探活失败。默认值 3次；范围:[1-10]
    var failureThreshold:Int?
    /// 在失败状态后，连续探活成功的次数，认为探活成功。默认值 1次；范围:[1-10]
    var successThreshold:Int?
    /// 在容器内执行指定命令；如果命令退出时返回码为 0 则认为诊断成功。
    var exec:ExecSpec?
    /// 对指定的端口和路径上的容器的 IP 地址执行 HTTP Get 请求。&lt;br&gt;
      /// 如果响应的状态码大于等于200 且小于 400，则诊断被认为是成功的。 
      /// 
    var httpGet:HgSpec?
    /// 对指定端口上的容器的 IP 地址进行 TCP 检查；如果端口打开，则诊断被认为是成功的。
    var tcpSocket:TcpSocketSpec?



    public override init(){
            super.init()
    }

    enum ProbeSpecCodingKeys: String, CodingKey {
        case initialDelaySeconds
        case periodSeconds
        case timeoutSeconds
        case failureThreshold
        case successThreshold
        case exec
        case httpGet
        case tcpSocket
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: ProbeSpecCodingKeys.self)
        if decoderContainer.contains(.initialDelaySeconds)
        {
            self.initialDelaySeconds = try decoderContainer.decode(Int?.self, forKey: .initialDelaySeconds)
        }
        if decoderContainer.contains(.periodSeconds)
        {
            self.periodSeconds = try decoderContainer.decode(Int?.self, forKey: .periodSeconds)
        }
        if decoderContainer.contains(.timeoutSeconds)
        {
            self.timeoutSeconds = try decoderContainer.decode(Int?.self, forKey: .timeoutSeconds)
        }
        if decoderContainer.contains(.failureThreshold)
        {
            self.failureThreshold = try decoderContainer.decode(Int?.self, forKey: .failureThreshold)
        }
        if decoderContainer.contains(.successThreshold)
        {
            self.successThreshold = try decoderContainer.decode(Int?.self, forKey: .successThreshold)
        }
        if decoderContainer.contains(.exec)
        {
            self.exec = try decoderContainer.decode(ExecSpec?.self, forKey: .exec)
        }
        if decoderContainer.contains(.httpGet)
        {
            self.httpGet = try decoderContainer.decode(HgSpec?.self, forKey: .httpGet)
        }
        if decoderContainer.contains(.tcpSocket)
        {
            self.tcpSocket = try decoderContainer.decode(TcpSocketSpec?.self, forKey: .tcpSocket)
        }
    }
}
public extension ProbeSpec{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: ProbeSpecCodingKeys.self)
         try encoderContainer.encode(initialDelaySeconds, forKey: .initialDelaySeconds)
         try encoderContainer.encode(periodSeconds, forKey: .periodSeconds)
         try encoderContainer.encode(timeoutSeconds, forKey: .timeoutSeconds)
         try encoderContainer.encode(failureThreshold, forKey: .failureThreshold)
         try encoderContainer.encode(successThreshold, forKey: .successThreshold)
         try encoderContainer.encode(exec, forKey: .exec)
         try encoderContainer.encode(httpGet, forKey: .httpGet)
         try encoderContainer.encode(tcpSocket, forKey: .tcpSocket)
    }
}

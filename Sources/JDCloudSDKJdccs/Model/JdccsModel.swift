/* Copyright 2018 JDCLOUD.COM

   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at

     http:#www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.

   Console Permission API
   云托管服务的控制台权限API

   OpenAPI spec version: v1
   Contact: 

   NOTE: This class is auto generated by the jdcloud code generator program.
 */


import Foundation
///  带宽（出口）流量
public class BandwidthTraffic:NSObject,Codable{
    /// 机房英文标识
    var idc:String?
    /// 机房名称
    var idcName:String?
    /// 带宽实例ID
    var bandwidthId:String?
    /// 带宽名称
    var bandwidthName:String?
    /// 总上行实时流量
    var totalTrafficIn:Double?
    /// 总下行实时流量
    var totalTrafficOut:Double?
    /// 总带宽
    var bandwidth:Int?
    /// 线路类型 bgp:BGP telecom:电信单线 unicom:联通单线 mobile:移动单线
    var lineType:String?
    /// 关联的公网IP
    var relatedIp:[AnyObject?]?
    /// Switchboard
    var switchboard:[AnyObject?]?



    public override init(){
            super.init()
    }

    enum BandwidthTrafficCodingKeys: String, CodingKey {
        case idc
        case idcName
        case bandwidthId
        case bandwidthName
        case totalTrafficIn
        case totalTrafficOut
        case bandwidth
        case lineType
        case relatedIp
        case switchboard
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: BandwidthTrafficCodingKeys.self)
        if decoderContainer.contains(.idc)
        {
            self.idc = try decoderContainer.decode(String?.self, forKey: .idc)
        }
        if decoderContainer.contains(.idcName)
        {
            self.idcName = try decoderContainer.decode(String?.self, forKey: .idcName)
        }
        if decoderContainer.contains(.bandwidthId)
        {
            self.bandwidthId = try decoderContainer.decode(String?.self, forKey: .bandwidthId)
        }
        if decoderContainer.contains(.bandwidthName)
        {
            self.bandwidthName = try decoderContainer.decode(String?.self, forKey: .bandwidthName)
        }
        if decoderContainer.contains(.totalTrafficIn)
        {
            self.totalTrafficIn = try decoderContainer.decode(Double?.self, forKey: .totalTrafficIn)
        }
        if decoderContainer.contains(.totalTrafficOut)
        {
            self.totalTrafficOut = try decoderContainer.decode(Double?.self, forKey: .totalTrafficOut)
        }
        if decoderContainer.contains(.bandwidth)
        {
            self.bandwidth = try decoderContainer.decode(Int?.self, forKey: .bandwidth)
        }
        if decoderContainer.contains(.lineType)
        {
            self.lineType = try decoderContainer.decode(String?.self, forKey: .lineType)
        }
    }
}
public extension BandwidthTraffic{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: BandwidthTrafficCodingKeys.self)
         try encoderContainer.encode(idc, forKey: .idc)
         try encoderContainer.encode(idcName, forKey: .idcName)
         try encoderContainer.encode(bandwidthId, forKey: .bandwidthId)
         try encoderContainer.encode(bandwidthName, forKey: .bandwidthName)
         try encoderContainer.encode(totalTrafficIn, forKey: .totalTrafficIn)
         try encoderContainer.encode(totalTrafficOut, forKey: .totalTrafficOut)
         try encoderContainer.encode(bandwidth, forKey: .bandwidth)
         try encoderContainer.encode(lineType, forKey: .lineType)
    }
}
///  统计值
public class Statistic:NSObject,Codable{
    /// 最大值
    var max:Double?
    /// 最小值
    var min:Double?
    /// 平均值
    var avg:Double?



    public override init(){
            super.init()
    }

    enum StatisticCodingKeys: String, CodingKey {
        case max
        case min
        case avg
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: StatisticCodingKeys.self)
        if decoderContainer.contains(.max)
        {
            self.max = try decoderContainer.decode(Double?.self, forKey: .max)
        }
        if decoderContainer.contains(.min)
        {
            self.min = try decoderContainer.decode(Double?.self, forKey: .min)
        }
        if decoderContainer.contains(.avg)
        {
            self.avg = try decoderContainer.decode(Double?.self, forKey: .avg)
        }
    }
}
public extension Statistic{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: StatisticCodingKeys.self)
         try encoderContainer.encode(max, forKey: .max)
         try encoderContainer.encode(min, forKey: .min)
         try encoderContainer.encode(avg, forKey: .avg)
    }
}
///  带宽（出口）流量
public class DescribeBandwidthTraffic:NSObject,Codable{
    /// 机房英文标识
    var idc:String?
    /// 机房名称
    var idcName:String?
    /// 带宽实例ID
    var bandwidthId:String?
    /// 带宽名称
    var bandwidthName:String?
    /// 总上行实时流量
    var totalTrafficIn:Double?
    /// 总下行实时流量
    var totalTrafficOut:Double?
    /// 总带宽
    var bandwidth:Int?



    public override init(){
            super.init()
    }

    enum DescribeBandwidthTrafficCodingKeys: String, CodingKey {
        case idc
        case idcName
        case bandwidthId
        case bandwidthName
        case totalTrafficIn
        case totalTrafficOut
        case bandwidth
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: DescribeBandwidthTrafficCodingKeys.self)
        if decoderContainer.contains(.idc)
        {
            self.idc = try decoderContainer.decode(String?.self, forKey: .idc)
        }
        if decoderContainer.contains(.idcName)
        {
            self.idcName = try decoderContainer.decode(String?.self, forKey: .idcName)
        }
        if decoderContainer.contains(.bandwidthId)
        {
            self.bandwidthId = try decoderContainer.decode(String?.self, forKey: .bandwidthId)
        }
        if decoderContainer.contains(.bandwidthName)
        {
            self.bandwidthName = try decoderContainer.decode(String?.self, forKey: .bandwidthName)
        }
        if decoderContainer.contains(.totalTrafficIn)
        {
            self.totalTrafficIn = try decoderContainer.decode(Double?.self, forKey: .totalTrafficIn)
        }
        if decoderContainer.contains(.totalTrafficOut)
        {
            self.totalTrafficOut = try decoderContainer.decode(Double?.self, forKey: .totalTrafficOut)
        }
        if decoderContainer.contains(.bandwidth)
        {
            self.bandwidth = try decoderContainer.decode(Int?.self, forKey: .bandwidth)
        }
    }
}
public extension DescribeBandwidthTraffic{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: DescribeBandwidthTrafficCodingKeys.self)
         try encoderContainer.encode(idc, forKey: .idc)
         try encoderContainer.encode(idcName, forKey: .idcName)
         try encoderContainer.encode(bandwidthId, forKey: .bandwidthId)
         try encoderContainer.encode(bandwidthName, forKey: .bandwidthName)
         try encoderContainer.encode(totalTrafficIn, forKey: .totalTrafficIn)
         try encoderContainer.encode(totalTrafficOut, forKey: .totalTrafficOut)
         try encoderContainer.encode(bandwidth, forKey: .bandwidth)
    }
}
///  监控项
public class Metric:NSObject,Codable{
    /// 监控项英文标识
    var metricValue:String?
    /// 监控项名称
    var metricName:String?



    public override init(){
            super.init()
    }

    enum MetricCodingKeys: String, CodingKey {
        case metricValue = "metric"
        case metricName
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: MetricCodingKeys.self)
        if decoderContainer.contains(.metricValue)
        {
            self.metricValue = try decoderContainer.decode(String?.self, forKey: .metricValue)
        }
        if decoderContainer.contains(.metricName)
        {
            self.metricName = try decoderContainer.decode(String?.self, forKey: .metricName)
        }
    }
}
public extension Metric{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: MetricCodingKeys.self)
         try encoderContainer.encode(metricValue, forKey: .metricValue)
         try encoderContainer.encode(metricName, forKey: .metricName)
    }
}
///  监控项数据
public class MetricData:NSObject,Codable{
    /// Data
    var data:[DataPoint?]?
    /// Statistic
    var statistic:Statistic?
    /// Metric
    var metric:Metric?



    public override init(){
            super.init()
    }

    enum MetricDataCodingKeys: String, CodingKey {
        case data
        case statistic
        case metric
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: MetricDataCodingKeys.self)
        if decoderContainer.contains(.data)
        {
            self.data = try decoderContainer.decode([DataPoint?]?.self, forKey: .data)
        }
        if decoderContainer.contains(.statistic)
        {
            self.statistic = try decoderContainer.decode(Statistic?.self, forKey: .statistic)
        }
        if decoderContainer.contains(.metric)
        {
            self.metric = try decoderContainer.decode(Metric?.self, forKey: .metric)
        }
    }
}
public extension MetricData{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: MetricDataCodingKeys.self)
         try encoderContainer.encode(data, forKey: .data)
         try encoderContainer.encode(statistic, forKey: .statistic)
         try encoderContainer.encode(metric, forKey: .metric)
    }
}
///  时点数据
public class DataPoint:NSObject,Codable{
    /// UNIX时间戳
    var timestamp:Int?
    /// 采样值
    var value:Double?



    public override init(){
            super.init()
    }

    enum DataPointCodingKeys: String, CodingKey {
        case timestamp
        case value
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: DataPointCodingKeys.self)
        if decoderContainer.contains(.timestamp)
        {
            self.timestamp = try decoderContainer.decode(Int?.self, forKey: .timestamp)
        }
        if decoderContainer.contains(.value)
        {
            self.value = try decoderContainer.decode(Double?.self, forKey: .value)
        }
    }
}
public extension DataPoint{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: DataPointCodingKeys.self)
         try encoderContainer.encode(timestamp, forKey: .timestamp)
         try encoderContainer.encode(value, forKey: .value)
    }
}
///  最后一个采样点数据
public class LastDownsampleRespItem:NSObject,Codable{
    /// 监控项英文标识
    var metric:String?
    /// 资源ID
    var resourceId:String?
    /// 采样值
    var value:Double?



    public override init(){
            super.init()
    }

    enum LastDownsampleRespItemCodingKeys: String, CodingKey {
        case metric
        case resourceId
        case value
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: LastDownsampleRespItemCodingKeys.self)
        if decoderContainer.contains(.metric)
        {
            self.metric = try decoderContainer.decode(String?.self, forKey: .metric)
        }
        if decoderContainer.contains(.resourceId)
        {
            self.resourceId = try decoderContainer.decode(String?.self, forKey: .resourceId)
        }
        if decoderContainer.contains(.value)
        {
            self.value = try decoderContainer.decode(Double?.self, forKey: .value)
        }
    }
}
public extension LastDownsampleRespItem{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: LastDownsampleRespItemCodingKeys.self)
         try encoderContainer.encode(metric, forKey: .metric)
         try encoderContainer.encode(resourceId, forKey: .resourceId)
         try encoderContainer.encode(value, forKey: .value)
    }
}
///  报警历史
public class AlarmHistory:NSObject,Codable{
    /// 规则实例ID
    var alarmId:String?
    /// 规则名称
    var name:String?
    /// 机房英文标识
    var idc:String?
    /// 机房名称
    var idcName:String?
    /// 资源类型 bandwidth:带宽
    var resourceType:String?
    /// 资源ID
    var resourceId:String?
    /// 资源名称
    var resourceName:String?
    /// 监控项英文标识
    var metric:String?
    /// 监控项名称
    var metricName:String?
    /// 统计周期（单位：分钟）
    var period:Int?
    /// 统计方法：平均值&#x3D;avg、最大值&#x3D;max、最小值&#x3D;min
    var statisticMethod:String?
    /// 计算方式 &gt;&#x3D;、&gt;、&lt;、&lt;&#x3D;、&#x3D;、！&#x3D;
    var operatorValue:String?
    /// 阈值
    var threshold:Double?
    /// 连续多少次后报警
    var times:Int?
    /// 通知周期 单位：小时
    var noticePeriod:Int?
    /// 规则状态 disabled:禁用 enabled:启用
    var status:String?
    /// Switchboard
    var switchboard:[AnyObject?]?
    /// 报警状态 normal:正常 alarm:报警
    var alarmStatus:String?
    /// 报警值
    var value:Double?
    /// 报警时间 遵循ISO8601标准，使用UTC时间，格式为：YYYY-MM-DDTHH:mm:ssZ
    var noticeTime:String?



    public override init(){
            super.init()
    }

    enum AlarmHistoryCodingKeys: String, CodingKey {
        case alarmId
        case name
        case idc
        case idcName
        case resourceType
        case resourceId
        case resourceName
        case metric
        case metricName
        case period
        case statisticMethod
        case operatorValue = "operator"
        case threshold
        case times
        case noticePeriod
        case status
        case switchboard
        case alarmStatus
        case value
        case noticeTime
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: AlarmHistoryCodingKeys.self)
        if decoderContainer.contains(.alarmId)
        {
            self.alarmId = try decoderContainer.decode(String?.self, forKey: .alarmId)
        }
        if decoderContainer.contains(.name)
        {
            self.name = try decoderContainer.decode(String?.self, forKey: .name)
        }
        if decoderContainer.contains(.idc)
        {
            self.idc = try decoderContainer.decode(String?.self, forKey: .idc)
        }
        if decoderContainer.contains(.idcName)
        {
            self.idcName = try decoderContainer.decode(String?.self, forKey: .idcName)
        }
        if decoderContainer.contains(.resourceType)
        {
            self.resourceType = try decoderContainer.decode(String?.self, forKey: .resourceType)
        }
        if decoderContainer.contains(.resourceId)
        {
            self.resourceId = try decoderContainer.decode(String?.self, forKey: .resourceId)
        }
        if decoderContainer.contains(.resourceName)
        {
            self.resourceName = try decoderContainer.decode(String?.self, forKey: .resourceName)
        }
        if decoderContainer.contains(.metric)
        {
            self.metric = try decoderContainer.decode(String?.self, forKey: .metric)
        }
        if decoderContainer.contains(.metricName)
        {
            self.metricName = try decoderContainer.decode(String?.self, forKey: .metricName)
        }
        if decoderContainer.contains(.period)
        {
            self.period = try decoderContainer.decode(Int?.self, forKey: .period)
        }
        if decoderContainer.contains(.statisticMethod)
        {
            self.statisticMethod = try decoderContainer.decode(String?.self, forKey: .statisticMethod)
        }
        if decoderContainer.contains(.operatorValue)
        {
            self.operatorValue = try decoderContainer.decode(String?.self, forKey: .operatorValue)
        }
        if decoderContainer.contains(.threshold)
        {
            self.threshold = try decoderContainer.decode(Double?.self, forKey: .threshold)
        }
        if decoderContainer.contains(.times)
        {
            self.times = try decoderContainer.decode(Int?.self, forKey: .times)
        }
        if decoderContainer.contains(.noticePeriod)
        {
            self.noticePeriod = try decoderContainer.decode(Int?.self, forKey: .noticePeriod)
        }
        if decoderContainer.contains(.status)
        {
            self.status = try decoderContainer.decode(String?.self, forKey: .status)
        }
        if decoderContainer.contains(.alarmStatus)
        {
            self.alarmStatus = try decoderContainer.decode(String?.self, forKey: .alarmStatus)
        }
        if decoderContainer.contains(.value)
        {
            self.value = try decoderContainer.decode(Double?.self, forKey: .value)
        }
        if decoderContainer.contains(.noticeTime)
        {
            self.noticeTime = try decoderContainer.decode(String?.self, forKey: .noticeTime)
        }
    }
}
public extension AlarmHistory{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: AlarmHistoryCodingKeys.self)
         try encoderContainer.encode(alarmId, forKey: .alarmId)
         try encoderContainer.encode(name, forKey: .name)
         try encoderContainer.encode(idc, forKey: .idc)
         try encoderContainer.encode(idcName, forKey: .idcName)
         try encoderContainer.encode(resourceType, forKey: .resourceType)
         try encoderContainer.encode(resourceId, forKey: .resourceId)
         try encoderContainer.encode(resourceName, forKey: .resourceName)
         try encoderContainer.encode(metric, forKey: .metric)
         try encoderContainer.encode(metricName, forKey: .metricName)
         try encoderContainer.encode(period, forKey: .period)
         try encoderContainer.encode(statisticMethod, forKey: .statisticMethod)
         try encoderContainer.encode(operatorValue, forKey: .operatorValue)
         try encoderContainer.encode(threshold, forKey: .threshold)
         try encoderContainer.encode(times, forKey: .times)
         try encoderContainer.encode(noticePeriod, forKey: .noticePeriod)
         try encoderContainer.encode(status, forKey: .status)
         try encoderContainer.encode(alarmStatus, forKey: .alarmStatus)
         try encoderContainer.encode(value, forKey: .value)
         try encoderContainer.encode(noticeTime, forKey: .noticeTime)
    }
}
///  报警规则
public class DescribeAlarm:NSObject,Codable{
    /// 规则实例ID
    var alarmId:String?
    /// 规则名称
    var name:String?
    /// 机房英文标识
    var idc:String?
    /// 机房名称
    var idcName:String?
    /// 资源类型 bandwidth:带宽
    var resourceType:String?
    /// 资源ID
    var resourceId:String?
    /// 资源名称
    var resourceName:String?
    /// 监控项英文标识
    var metric:String?
    /// 监控项名称
    var metricName:String?
    /// 统计周期（单位：分钟）
    var period:Int?
    /// 统计方法：平均值&#x3D;avg、最大值&#x3D;max、最小值&#x3D;min
    var statisticMethod:String?
    /// 计算方式 &gt;&#x3D;、&gt;、&lt;、&lt;&#x3D;、&#x3D;、！&#x3D;
    var operatorValue:String?
    /// 阈值
    var threshold:Double?
    /// 连续多少次后报警
    var times:Int?
    /// 通知周期 单位：小时
    var noticePeriod:Int?
    /// 规则状态 disabled:禁用 enabled:启用
    var status:String?



    public override init(){
            super.init()
    }

    enum DescribeAlarmCodingKeys: String, CodingKey {
        case alarmId
        case name
        case idc
        case idcName
        case resourceType
        case resourceId
        case resourceName
        case metric
        case metricName
        case period
        case statisticMethod
        case operatorValue = "operator"
        case threshold
        case times
        case noticePeriod
        case status
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: DescribeAlarmCodingKeys.self)
        if decoderContainer.contains(.alarmId)
        {
            self.alarmId = try decoderContainer.decode(String?.self, forKey: .alarmId)
        }
        if decoderContainer.contains(.name)
        {
            self.name = try decoderContainer.decode(String?.self, forKey: .name)
        }
        if decoderContainer.contains(.idc)
        {
            self.idc = try decoderContainer.decode(String?.self, forKey: .idc)
        }
        if decoderContainer.contains(.idcName)
        {
            self.idcName = try decoderContainer.decode(String?.self, forKey: .idcName)
        }
        if decoderContainer.contains(.resourceType)
        {
            self.resourceType = try decoderContainer.decode(String?.self, forKey: .resourceType)
        }
        if decoderContainer.contains(.resourceId)
        {
            self.resourceId = try decoderContainer.decode(String?.self, forKey: .resourceId)
        }
        if decoderContainer.contains(.resourceName)
        {
            self.resourceName = try decoderContainer.decode(String?.self, forKey: .resourceName)
        }
        if decoderContainer.contains(.metric)
        {
            self.metric = try decoderContainer.decode(String?.self, forKey: .metric)
        }
        if decoderContainer.contains(.metricName)
        {
            self.metricName = try decoderContainer.decode(String?.self, forKey: .metricName)
        }
        if decoderContainer.contains(.period)
        {
            self.period = try decoderContainer.decode(Int?.self, forKey: .period)
        }
        if decoderContainer.contains(.statisticMethod)
        {
            self.statisticMethod = try decoderContainer.decode(String?.self, forKey: .statisticMethod)
        }
        if decoderContainer.contains(.operatorValue)
        {
            self.operatorValue = try decoderContainer.decode(String?.self, forKey: .operatorValue)
        }
        if decoderContainer.contains(.threshold)
        {
            self.threshold = try decoderContainer.decode(Double?.self, forKey: .threshold)
        }
        if decoderContainer.contains(.times)
        {
            self.times = try decoderContainer.decode(Int?.self, forKey: .times)
        }
        if decoderContainer.contains(.noticePeriod)
        {
            self.noticePeriod = try decoderContainer.decode(Int?.self, forKey: .noticePeriod)
        }
        if decoderContainer.contains(.status)
        {
            self.status = try decoderContainer.decode(String?.self, forKey: .status)
        }
    }
}
public extension DescribeAlarm{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: DescribeAlarmCodingKeys.self)
         try encoderContainer.encode(alarmId, forKey: .alarmId)
         try encoderContainer.encode(name, forKey: .name)
         try encoderContainer.encode(idc, forKey: .idc)
         try encoderContainer.encode(idcName, forKey: .idcName)
         try encoderContainer.encode(resourceType, forKey: .resourceType)
         try encoderContainer.encode(resourceId, forKey: .resourceId)
         try encoderContainer.encode(resourceName, forKey: .resourceName)
         try encoderContainer.encode(metric, forKey: .metric)
         try encoderContainer.encode(metricName, forKey: .metricName)
         try encoderContainer.encode(period, forKey: .period)
         try encoderContainer.encode(statisticMethod, forKey: .statisticMethod)
         try encoderContainer.encode(operatorValue, forKey: .operatorValue)
         try encoderContainer.encode(threshold, forKey: .threshold)
         try encoderContainer.encode(times, forKey: .times)
         try encoderContainer.encode(noticePeriod, forKey: .noticePeriod)
         try encoderContainer.encode(status, forKey: .status)
    }
}
///  报警规则
public class Alarm:NSObject,Codable{
    /// 规则实例ID
    var alarmId:String?
    /// 规则名称
    var name:String?
    /// 机房英文标识
    var idc:String?
    /// 机房名称
    var idcName:String?
    /// 资源类型 bandwidth:带宽
    var resourceType:String?
    /// 资源ID
    var resourceId:String?
    /// 资源名称
    var resourceName:String?
    /// 监控项英文标识
    var metric:String?
    /// 监控项名称
    var metricName:String?
    /// 统计周期（单位：分钟）
    var period:Int?
    /// 统计方法：平均值&#x3D;avg、最大值&#x3D;max、最小值&#x3D;min
    var statisticMethod:String?
    /// 计算方式 &gt;&#x3D;、&gt;、&lt;、&lt;&#x3D;、&#x3D;、！&#x3D;
    var operatorValue:String?
    /// 阈值
    var threshold:Double?
    /// 连续多少次后报警
    var times:Int?
    /// 通知周期 单位：小时
    var noticePeriod:Int?
    /// 规则状态 disabled:禁用 enabled:启用
    var status:String?
    /// Switchboard
    var switchboard:[AnyObject?]?



    public override init(){
            super.init()
    }

    enum AlarmCodingKeys: String, CodingKey {
        case alarmId
        case name
        case idc
        case idcName
        case resourceType
        case resourceId
        case resourceName
        case metric
        case metricName
        case period
        case statisticMethod
        case operatorValue = "operator"
        case threshold
        case times
        case noticePeriod
        case status
        case switchboard
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: AlarmCodingKeys.self)
        if decoderContainer.contains(.alarmId)
        {
            self.alarmId = try decoderContainer.decode(String?.self, forKey: .alarmId)
        }
        if decoderContainer.contains(.name)
        {
            self.name = try decoderContainer.decode(String?.self, forKey: .name)
        }
        if decoderContainer.contains(.idc)
        {
            self.idc = try decoderContainer.decode(String?.self, forKey: .idc)
        }
        if decoderContainer.contains(.idcName)
        {
            self.idcName = try decoderContainer.decode(String?.self, forKey: .idcName)
        }
        if decoderContainer.contains(.resourceType)
        {
            self.resourceType = try decoderContainer.decode(String?.self, forKey: .resourceType)
        }
        if decoderContainer.contains(.resourceId)
        {
            self.resourceId = try decoderContainer.decode(String?.self, forKey: .resourceId)
        }
        if decoderContainer.contains(.resourceName)
        {
            self.resourceName = try decoderContainer.decode(String?.self, forKey: .resourceName)
        }
        if decoderContainer.contains(.metric)
        {
            self.metric = try decoderContainer.decode(String?.self, forKey: .metric)
        }
        if decoderContainer.contains(.metricName)
        {
            self.metricName = try decoderContainer.decode(String?.self, forKey: .metricName)
        }
        if decoderContainer.contains(.period)
        {
            self.period = try decoderContainer.decode(Int?.self, forKey: .period)
        }
        if decoderContainer.contains(.statisticMethod)
        {
            self.statisticMethod = try decoderContainer.decode(String?.self, forKey: .statisticMethod)
        }
        if decoderContainer.contains(.operatorValue)
        {
            self.operatorValue = try decoderContainer.decode(String?.self, forKey: .operatorValue)
        }
        if decoderContainer.contains(.threshold)
        {
            self.threshold = try decoderContainer.decode(Double?.self, forKey: .threshold)
        }
        if decoderContainer.contains(.times)
        {
            self.times = try decoderContainer.decode(Int?.self, forKey: .times)
        }
        if decoderContainer.contains(.noticePeriod)
        {
            self.noticePeriod = try decoderContainer.decode(Int?.self, forKey: .noticePeriod)
        }
        if decoderContainer.contains(.status)
        {
            self.status = try decoderContainer.decode(String?.self, forKey: .status)
        }
    }
}
public extension Alarm{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: AlarmCodingKeys.self)
         try encoderContainer.encode(alarmId, forKey: .alarmId)
         try encoderContainer.encode(name, forKey: .name)
         try encoderContainer.encode(idc, forKey: .idc)
         try encoderContainer.encode(idcName, forKey: .idcName)
         try encoderContainer.encode(resourceType, forKey: .resourceType)
         try encoderContainer.encode(resourceId, forKey: .resourceId)
         try encoderContainer.encode(resourceName, forKey: .resourceName)
         try encoderContainer.encode(metric, forKey: .metric)
         try encoderContainer.encode(metricName, forKey: .metricName)
         try encoderContainer.encode(period, forKey: .period)
         try encoderContainer.encode(statisticMethod, forKey: .statisticMethod)
         try encoderContainer.encode(operatorValue, forKey: .operatorValue)
         try encoderContainer.encode(threshold, forKey: .threshold)
         try encoderContainer.encode(times, forKey: .times)
         try encoderContainer.encode(noticePeriod, forKey: .noticePeriod)
         try encoderContainer.encode(status, forKey: .status)
    }
}
///  工单
public class Ticket:NSObject,Codable{
    /// 工单编号
    var ticketNo:String?
    /// 工单名称
    var ticketTemplateName:String?
    /// 工单模板CODE
    var ticketTemplateCode:String?
    /// 工单类型
    var ticketTypeName:String?
    /// 工单状态 pendingReview:待审核 已撤销 revoked:已撤销 processing:处理中 pendingVerification:待核验 pendingClose:待关单 rejected:已拒绝 completed:已完成 cancelled:已取消 draft:草稿中
    var status:String?
    /// 描述
    var descriptionValue:String?
    /// 创建时间，遵循ISO8601标准，使用UTC时间，格式为：YYYY-MM-DDTHH:mm:ssZ
    var createdTime:String?
    /// 关闭时间，遵循ISO8601标准，使用UTC时间，格式为：YYYY-MM-DDTHH:mm:ssZ
    var closedTime:String?
    /// 电话
    var phone:String?
    /// 邮箱
    var email:String?
    /// 机房英文标识
    var idc:String?
    /// 机房名称
    var idcName:String?



    public override init(){
            super.init()
    }

    enum TicketCodingKeys: String, CodingKey {
        case ticketNo
        case ticketTemplateName
        case ticketTemplateCode
        case ticketTypeName
        case status
        case descriptionValue = "description"
        case createdTime
        case closedTime
        case phone
        case email
        case idc
        case idcName
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: TicketCodingKeys.self)
        if decoderContainer.contains(.ticketNo)
        {
            self.ticketNo = try decoderContainer.decode(String?.self, forKey: .ticketNo)
        }
        if decoderContainer.contains(.ticketTemplateName)
        {
            self.ticketTemplateName = try decoderContainer.decode(String?.self, forKey: .ticketTemplateName)
        }
        if decoderContainer.contains(.ticketTemplateCode)
        {
            self.ticketTemplateCode = try decoderContainer.decode(String?.self, forKey: .ticketTemplateCode)
        }
        if decoderContainer.contains(.ticketTypeName)
        {
            self.ticketTypeName = try decoderContainer.decode(String?.self, forKey: .ticketTypeName)
        }
        if decoderContainer.contains(.status)
        {
            self.status = try decoderContainer.decode(String?.self, forKey: .status)
        }
        if decoderContainer.contains(.descriptionValue)
        {
            self.descriptionValue = try decoderContainer.decode(String?.self, forKey: .descriptionValue)
        }
        if decoderContainer.contains(.createdTime)
        {
            self.createdTime = try decoderContainer.decode(String?.self, forKey: .createdTime)
        }
        if decoderContainer.contains(.closedTime)
        {
            self.closedTime = try decoderContainer.decode(String?.self, forKey: .closedTime)
        }
        if decoderContainer.contains(.phone)
        {
            self.phone = try decoderContainer.decode(String?.self, forKey: .phone)
        }
        if decoderContainer.contains(.email)
        {
            self.email = try decoderContainer.decode(String?.self, forKey: .email)
        }
        if decoderContainer.contains(.idc)
        {
            self.idc = try decoderContainer.decode(String?.self, forKey: .idc)
        }
        if decoderContainer.contains(.idcName)
        {
            self.idcName = try decoderContainer.decode(String?.self, forKey: .idcName)
        }
    }
}
public extension Ticket{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: TicketCodingKeys.self)
         try encoderContainer.encode(ticketNo, forKey: .ticketNo)
         try encoderContainer.encode(ticketTemplateName, forKey: .ticketTemplateName)
         try encoderContainer.encode(ticketTemplateCode, forKey: .ticketTemplateCode)
         try encoderContainer.encode(ticketTypeName, forKey: .ticketTypeName)
         try encoderContainer.encode(status, forKey: .status)
         try encoderContainer.encode(descriptionValue, forKey: .descriptionValue)
         try encoderContainer.encode(createdTime, forKey: .createdTime)
         try encoderContainer.encode(closedTime, forKey: .closedTime)
         try encoderContainer.encode(phone, forKey: .phone)
         try encoderContainer.encode(email, forKey: .email)
         try encoderContainer.encode(idc, forKey: .idc)
         try encoderContainer.encode(idcName, forKey: .idcName)
    }
}
///  带宽（出口）
public class Bandwidth:NSObject,Codable{
    /// 机房英文标识
    var idc:String?
    /// 机房名称
    var idcName:String?
    /// 带宽实例ID
    var bandwidthId:String?
    /// 带宽名称
    var bandwidthName:String?
    /// 状态 normal:正常 abnormal:异常
    var status:String?
    /// 线路类型 bgp:BGP telecom:电信单线 unicom:联通单线 mobile:移动单线
    var lineType:Int?
    /// 合同带宽（Mbps）
    var bandwidthValue:Int?
    /// 关联的公网IP
    var relatedIp:[AnyObject?]?
    /// 交换机信息
    var switchboard:[AnyObject?]?



    public override init(){
            super.init()
    }

    enum BandwidthCodingKeys: String, CodingKey {
        case idc
        case idcName
        case bandwidthId
        case bandwidthName
        case status
        case lineType
        case bandwidthValue = "bandwidth"
        case relatedIp
        case switchboard
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: BandwidthCodingKeys.self)
        if decoderContainer.contains(.idc)
        {
            self.idc = try decoderContainer.decode(String?.self, forKey: .idc)
        }
        if decoderContainer.contains(.idcName)
        {
            self.idcName = try decoderContainer.decode(String?.self, forKey: .idcName)
        }
        if decoderContainer.contains(.bandwidthId)
        {
            self.bandwidthId = try decoderContainer.decode(String?.self, forKey: .bandwidthId)
        }
        if decoderContainer.contains(.bandwidthName)
        {
            self.bandwidthName = try decoderContainer.decode(String?.self, forKey: .bandwidthName)
        }
        if decoderContainer.contains(.status)
        {
            self.status = try decoderContainer.decode(String?.self, forKey: .status)
        }
        if decoderContainer.contains(.lineType)
        {
            self.lineType = try decoderContainer.decode(Int?.self, forKey: .lineType)
        }
        if decoderContainer.contains(.bandwidthValue)
        {
            self.bandwidthValue = try decoderContainer.decode(Int?.self, forKey: .bandwidthValue)
        }
    }
}
public extension Bandwidth{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: BandwidthCodingKeys.self)
         try encoderContainer.encode(idc, forKey: .idc)
         try encoderContainer.encode(idcName, forKey: .idcName)
         try encoderContainer.encode(bandwidthId, forKey: .bandwidthId)
         try encoderContainer.encode(bandwidthName, forKey: .bandwidthName)
         try encoderContainer.encode(status, forKey: .status)
         try encoderContainer.encode(lineType, forKey: .lineType)
         try encoderContainer.encode(bandwidthValue, forKey: .bandwidthValue)
    }
}
///  设备
public class DescribeDevice:NSObject,Codable{
    /// 机房英文标识
    var idc:String?
    /// 机房名称
    var idcName:String?
    /// 设备Id
    var deviceId:String?
    /// 设备SN号
    var snNo:String?
    /// 机柜编码
    var cabinetNo:String?
    /// 所在U位
    var rackUIndex:String?
    /// U数（U）
    var uNum:Int?
    /// 品牌
    var brand:String?
    /// 型号
    var model:String?
    /// 设备类型 server:服务器 network:网络设备 storage:存储设备 other:其他设备
    var deviceType:String?
    /// 资产归属 own:自备 lease:租赁
    var assetBelong:String?
    /// 资产状态 inWarehouse:已入库 launched:已上架
    var assetStatus:String?



    public override init(){
            super.init()
    }

    enum DescribeDeviceCodingKeys: String, CodingKey {
        case idc
        case idcName
        case deviceId
        case snNo
        case cabinetNo
        case rackUIndex
        case uNum
        case brand
        case model
        case deviceType
        case assetBelong
        case assetStatus
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: DescribeDeviceCodingKeys.self)
        if decoderContainer.contains(.idc)
        {
            self.idc = try decoderContainer.decode(String?.self, forKey: .idc)
        }
        if decoderContainer.contains(.idcName)
        {
            self.idcName = try decoderContainer.decode(String?.self, forKey: .idcName)
        }
        if decoderContainer.contains(.deviceId)
        {
            self.deviceId = try decoderContainer.decode(String?.self, forKey: .deviceId)
        }
        if decoderContainer.contains(.snNo)
        {
            self.snNo = try decoderContainer.decode(String?.self, forKey: .snNo)
        }
        if decoderContainer.contains(.cabinetNo)
        {
            self.cabinetNo = try decoderContainer.decode(String?.self, forKey: .cabinetNo)
        }
        if decoderContainer.contains(.rackUIndex)
        {
            self.rackUIndex = try decoderContainer.decode(String?.self, forKey: .rackUIndex)
        }
        if decoderContainer.contains(.uNum)
        {
            self.uNum = try decoderContainer.decode(Int?.self, forKey: .uNum)
        }
        if decoderContainer.contains(.brand)
        {
            self.brand = try decoderContainer.decode(String?.self, forKey: .brand)
        }
        if decoderContainer.contains(.model)
        {
            self.model = try decoderContainer.decode(String?.self, forKey: .model)
        }
        if decoderContainer.contains(.deviceType)
        {
            self.deviceType = try decoderContainer.decode(String?.self, forKey: .deviceType)
        }
        if decoderContainer.contains(.assetBelong)
        {
            self.assetBelong = try decoderContainer.decode(String?.self, forKey: .assetBelong)
        }
        if decoderContainer.contains(.assetStatus)
        {
            self.assetStatus = try decoderContainer.decode(String?.self, forKey: .assetStatus)
        }
    }
}
public extension DescribeDevice{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: DescribeDeviceCodingKeys.self)
         try encoderContainer.encode(idc, forKey: .idc)
         try encoderContainer.encode(idcName, forKey: .idcName)
         try encoderContainer.encode(deviceId, forKey: .deviceId)
         try encoderContainer.encode(snNo, forKey: .snNo)
         try encoderContainer.encode(cabinetNo, forKey: .cabinetNo)
         try encoderContainer.encode(rackUIndex, forKey: .rackUIndex)
         try encoderContainer.encode(uNum, forKey: .uNum)
         try encoderContainer.encode(brand, forKey: .brand)
         try encoderContainer.encode(model, forKey: .model)
         try encoderContainer.encode(deviceType, forKey: .deviceType)
         try encoderContainer.encode(assetBelong, forKey: .assetBelong)
         try encoderContainer.encode(assetStatus, forKey: .assetStatus)
    }
}
///  房间号
public class Room:NSObject,Codable{
    /// 机房英文标识
    var idc:String?
    /// 机房名称
    var idcName:String?
    /// 房间号
    var roomNo:String?



    public override init(){
            super.init()
    }

    enum RoomCodingKeys: String, CodingKey {
        case idc
        case idcName
        case roomNo
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: RoomCodingKeys.self)
        if decoderContainer.contains(.idc)
        {
            self.idc = try decoderContainer.decode(String?.self, forKey: .idc)
        }
        if decoderContainer.contains(.idcName)
        {
            self.idcName = try decoderContainer.decode(String?.self, forKey: .idcName)
        }
        if decoderContainer.contains(.roomNo)
        {
            self.roomNo = try decoderContainer.decode(String?.self, forKey: .roomNo)
        }
    }
}
public extension Room{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: RoomCodingKeys.self)
         try encoderContainer.encode(idc, forKey: .idc)
         try encoderContainer.encode(idcName, forKey: .idcName)
         try encoderContainer.encode(roomNo, forKey: .roomNo)
    }
}
///  带宽（出口）
public class DescribeBandwidth:NSObject,Codable{
    /// 机房英文标识
    var idc:String?
    /// 机房名称
    var idcName:String?
    /// 带宽实例ID
    var bandwidthId:String?
    /// 带宽名称
    var bandwidthName:String?
    /// 状态 normal:正常 abnormal:异常
    var status:String?
    /// 线路类型 bgp:BGP telecom:电信单线 unicom:联通单线 mobile:移动单线
    var lineType:Int?
    /// 合同带宽（Mbps）
    var bandwidth:Int?
    /// 关联的公网IP
    var relatedIp:[AnyObject?]?



    public override init(){
            super.init()
    }

    enum DescribeBandwidthCodingKeys: String, CodingKey {
        case idc
        case idcName
        case bandwidthId
        case bandwidthName
        case status
        case lineType
        case bandwidth
        case relatedIp
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: DescribeBandwidthCodingKeys.self)
        if decoderContainer.contains(.idc)
        {
            self.idc = try decoderContainer.decode(String?.self, forKey: .idc)
        }
        if decoderContainer.contains(.idcName)
        {
            self.idcName = try decoderContainer.decode(String?.self, forKey: .idcName)
        }
        if decoderContainer.contains(.bandwidthId)
        {
            self.bandwidthId = try decoderContainer.decode(String?.self, forKey: .bandwidthId)
        }
        if decoderContainer.contains(.bandwidthName)
        {
            self.bandwidthName = try decoderContainer.decode(String?.self, forKey: .bandwidthName)
        }
        if decoderContainer.contains(.status)
        {
            self.status = try decoderContainer.decode(String?.self, forKey: .status)
        }
        if decoderContainer.contains(.lineType)
        {
            self.lineType = try decoderContainer.decode(Int?.self, forKey: .lineType)
        }
        if decoderContainer.contains(.bandwidth)
        {
            self.bandwidth = try decoderContainer.decode(Int?.self, forKey: .bandwidth)
        }
    }
}
public extension DescribeBandwidth{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: DescribeBandwidthCodingKeys.self)
         try encoderContainer.encode(idc, forKey: .idc)
         try encoderContainer.encode(idcName, forKey: .idcName)
         try encoderContainer.encode(bandwidthId, forKey: .bandwidthId)
         try encoderContainer.encode(bandwidthName, forKey: .bandwidthName)
         try encoderContainer.encode(status, forKey: .status)
         try encoderContainer.encode(lineType, forKey: .lineType)
         try encoderContainer.encode(bandwidth, forKey: .bandwidth)
    }
}
///  机柜
public class Cabinet:NSObject,Codable{
    /// 机房英文标识
    var idc:String?
    /// 机房名称
    var idcName:String?
    /// 机柜Id
    var cabinetId:String?
    /// 机柜编码
    var cabinetNo:String?
    /// 房间号
    var roomNo:String?
    /// 机柜空间(U)
    var cabinetSpace:Int?
    /// 额定电流(A)
    var cabinetPower:Int?
    /// 机柜类型 formal:正式机柜 reserved:预留机柜
    var cabinetType:String?
    /// 机柜开通状态 disabled:未开通 enabling:开通中 enabled:已开通 disabling:关闭中
    var cabinetOpenStatus:String?
    /// 开通时间，遵循ISO8601标准，使用UTC时间，格式为：YYYY-MM-DDTHH:mm:ssZ
    var cabinetOpenTime:String?
    /// 起租时间，遵循ISO8601标准，使用UTC时间，格式为：YYYY-MM-DDTHH:mm:ssZ
    var startTime:String?
    /// 退租时间，遵循ISO8601标准，使用UTC时间，格式为：YYYY-MM-DDTHH:mm:ssZ
    var endTime:String?
    /// 设备数量
    var deviceNum:Int?
    /// 占用U数(U)
    var rackUOccupy:Int?
    /// 空闲U数(U)
    var rackUFree:Int?



    public override init(){
            super.init()
    }

    enum CabinetCodingKeys: String, CodingKey {
        case idc
        case idcName
        case cabinetId
        case cabinetNo
        case roomNo
        case cabinetSpace
        case cabinetPower
        case cabinetType
        case cabinetOpenStatus
        case cabinetOpenTime
        case startTime
        case endTime
        case deviceNum
        case rackUOccupy
        case rackUFree
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: CabinetCodingKeys.self)
        if decoderContainer.contains(.idc)
        {
            self.idc = try decoderContainer.decode(String?.self, forKey: .idc)
        }
        if decoderContainer.contains(.idcName)
        {
            self.idcName = try decoderContainer.decode(String?.self, forKey: .idcName)
        }
        if decoderContainer.contains(.cabinetId)
        {
            self.cabinetId = try decoderContainer.decode(String?.self, forKey: .cabinetId)
        }
        if decoderContainer.contains(.cabinetNo)
        {
            self.cabinetNo = try decoderContainer.decode(String?.self, forKey: .cabinetNo)
        }
        if decoderContainer.contains(.roomNo)
        {
            self.roomNo = try decoderContainer.decode(String?.self, forKey: .roomNo)
        }
        if decoderContainer.contains(.cabinetSpace)
        {
            self.cabinetSpace = try decoderContainer.decode(Int?.self, forKey: .cabinetSpace)
        }
        if decoderContainer.contains(.cabinetPower)
        {
            self.cabinetPower = try decoderContainer.decode(Int?.self, forKey: .cabinetPower)
        }
        if decoderContainer.contains(.cabinetType)
        {
            self.cabinetType = try decoderContainer.decode(String?.self, forKey: .cabinetType)
        }
        if decoderContainer.contains(.cabinetOpenStatus)
        {
            self.cabinetOpenStatus = try decoderContainer.decode(String?.self, forKey: .cabinetOpenStatus)
        }
        if decoderContainer.contains(.cabinetOpenTime)
        {
            self.cabinetOpenTime = try decoderContainer.decode(String?.self, forKey: .cabinetOpenTime)
        }
        if decoderContainer.contains(.startTime)
        {
            self.startTime = try decoderContainer.decode(String?.self, forKey: .startTime)
        }
        if decoderContainer.contains(.endTime)
        {
            self.endTime = try decoderContainer.decode(String?.self, forKey: .endTime)
        }
        if decoderContainer.contains(.deviceNum)
        {
            self.deviceNum = try decoderContainer.decode(Int?.self, forKey: .deviceNum)
        }
        if decoderContainer.contains(.rackUOccupy)
        {
            self.rackUOccupy = try decoderContainer.decode(Int?.self, forKey: .rackUOccupy)
        }
        if decoderContainer.contains(.rackUFree)
        {
            self.rackUFree = try decoderContainer.decode(Int?.self, forKey: .rackUFree)
        }
    }
}
public extension Cabinet{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: CabinetCodingKeys.self)
         try encoderContainer.encode(idc, forKey: .idc)
         try encoderContainer.encode(idcName, forKey: .idcName)
         try encoderContainer.encode(cabinetId, forKey: .cabinetId)
         try encoderContainer.encode(cabinetNo, forKey: .cabinetNo)
         try encoderContainer.encode(roomNo, forKey: .roomNo)
         try encoderContainer.encode(cabinetSpace, forKey: .cabinetSpace)
         try encoderContainer.encode(cabinetPower, forKey: .cabinetPower)
         try encoderContainer.encode(cabinetType, forKey: .cabinetType)
         try encoderContainer.encode(cabinetOpenStatus, forKey: .cabinetOpenStatus)
         try encoderContainer.encode(cabinetOpenTime, forKey: .cabinetOpenTime)
         try encoderContainer.encode(startTime, forKey: .startTime)
         try encoderContainer.encode(endTime, forKey: .endTime)
         try encoderContainer.encode(deviceNum, forKey: .deviceNum)
         try encoderContainer.encode(rackUOccupy, forKey: .rackUOccupy)
         try encoderContainer.encode(rackUFree, forKey: .rackUFree)
    }
}
///  设备
public class Device:NSObject,Codable{
    /// 机房英文标识
    var idc:String?
    /// 机房名称
    var idcName:String?
    /// 设备Id
    var deviceId:String?
    /// 设备SN号
    var snNo:String?
    /// 机柜编码
    var cabinetNo:String?
    /// 所在U位
    var rackUIndex:String?
    /// U数（U）
    var uNum:Int?
    /// 品牌
    var brand:String?
    /// 型号
    var model:String?
    /// 设备类型 server:服务器 network:网络设备 storage:存储设备 other:其他设备
    var deviceType:String?
    /// 资产归属 own:自备 lease:租赁
    var assetBelong:String?
    /// 资产状态 inWarehouse:已入库 launched:已上架
    var assetStatus:String?
    /// CPU逻辑核数(核)
    var cpuCore:String?
    /// 内存总容量(GB)
    var memory:String?
    /// 硬盘总容量(GB)
    var disk:String?
    /// 网卡带宽(Mbps)
    var networkCardBandwidth:String?
    /// 起租时间，遵循ISO8601标准，使用UTC时间，格式为：YYYY-MM-DDTHH:mm:ssZ
    var startTime:String?
    /// 退租时间，遵循ISO8601标准，使用UTC时间，格式为：YYYY-MM-DDTHH:mm:ssZ
    var endTime:String?



    public override init(){
            super.init()
    }

    enum DeviceCodingKeys: String, CodingKey {
        case idc
        case idcName
        case deviceId
        case snNo
        case cabinetNo
        case rackUIndex
        case uNum
        case brand
        case model
        case deviceType
        case assetBelong
        case assetStatus
        case cpuCore
        case memory
        case disk
        case networkCardBandwidth
        case startTime
        case endTime
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: DeviceCodingKeys.self)
        if decoderContainer.contains(.idc)
        {
            self.idc = try decoderContainer.decode(String?.self, forKey: .idc)
        }
        if decoderContainer.contains(.idcName)
        {
            self.idcName = try decoderContainer.decode(String?.self, forKey: .idcName)
        }
        if decoderContainer.contains(.deviceId)
        {
            self.deviceId = try decoderContainer.decode(String?.self, forKey: .deviceId)
        }
        if decoderContainer.contains(.snNo)
        {
            self.snNo = try decoderContainer.decode(String?.self, forKey: .snNo)
        }
        if decoderContainer.contains(.cabinetNo)
        {
            self.cabinetNo = try decoderContainer.decode(String?.self, forKey: .cabinetNo)
        }
        if decoderContainer.contains(.rackUIndex)
        {
            self.rackUIndex = try decoderContainer.decode(String?.self, forKey: .rackUIndex)
        }
        if decoderContainer.contains(.uNum)
        {
            self.uNum = try decoderContainer.decode(Int?.self, forKey: .uNum)
        }
        if decoderContainer.contains(.brand)
        {
            self.brand = try decoderContainer.decode(String?.self, forKey: .brand)
        }
        if decoderContainer.contains(.model)
        {
            self.model = try decoderContainer.decode(String?.self, forKey: .model)
        }
        if decoderContainer.contains(.deviceType)
        {
            self.deviceType = try decoderContainer.decode(String?.self, forKey: .deviceType)
        }
        if decoderContainer.contains(.assetBelong)
        {
            self.assetBelong = try decoderContainer.decode(String?.self, forKey: .assetBelong)
        }
        if decoderContainer.contains(.assetStatus)
        {
            self.assetStatus = try decoderContainer.decode(String?.self, forKey: .assetStatus)
        }
        if decoderContainer.contains(.cpuCore)
        {
            self.cpuCore = try decoderContainer.decode(String?.self, forKey: .cpuCore)
        }
        if decoderContainer.contains(.memory)
        {
            self.memory = try decoderContainer.decode(String?.self, forKey: .memory)
        }
        if decoderContainer.contains(.disk)
        {
            self.disk = try decoderContainer.decode(String?.self, forKey: .disk)
        }
        if decoderContainer.contains(.networkCardBandwidth)
        {
            self.networkCardBandwidth = try decoderContainer.decode(String?.self, forKey: .networkCardBandwidth)
        }
        if decoderContainer.contains(.startTime)
        {
            self.startTime = try decoderContainer.decode(String?.self, forKey: .startTime)
        }
        if decoderContainer.contains(.endTime)
        {
            self.endTime = try decoderContainer.decode(String?.self, forKey: .endTime)
        }
    }
}
public extension Device{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: DeviceCodingKeys.self)
         try encoderContainer.encode(idc, forKey: .idc)
         try encoderContainer.encode(idcName, forKey: .idcName)
         try encoderContainer.encode(deviceId, forKey: .deviceId)
         try encoderContainer.encode(snNo, forKey: .snNo)
         try encoderContainer.encode(cabinetNo, forKey: .cabinetNo)
         try encoderContainer.encode(rackUIndex, forKey: .rackUIndex)
         try encoderContainer.encode(uNum, forKey: .uNum)
         try encoderContainer.encode(brand, forKey: .brand)
         try encoderContainer.encode(model, forKey: .model)
         try encoderContainer.encode(deviceType, forKey: .deviceType)
         try encoderContainer.encode(assetBelong, forKey: .assetBelong)
         try encoderContainer.encode(assetStatus, forKey: .assetStatus)
         try encoderContainer.encode(cpuCore, forKey: .cpuCore)
         try encoderContainer.encode(memory, forKey: .memory)
         try encoderContainer.encode(disk, forKey: .disk)
         try encoderContainer.encode(networkCardBandwidth, forKey: .networkCardBandwidth)
         try encoderContainer.encode(startTime, forKey: .startTime)
         try encoderContainer.encode(endTime, forKey: .endTime)
    }
}
///  机柜
public class DescribeCabinet:NSObject,Codable{
    /// 机房英文标识
    var idc:String?
    /// 机房名称
    var idcName:String?
    /// 机柜Id
    var cabinetId:String?
    /// 机柜编码
    var cabinetNo:String?
    /// 房间号
    var roomNo:String?
    /// 机柜空间(U)
    var cabinetSpace:Int?
    /// 额定电流(A)
    var cabinetPower:Int?
    /// 机柜类型 formal:正式机柜 reserved:预留机柜
    var cabinetType:String?
    /// 机柜开通状态 disabled:未开通 enabling:开通中 enabled:已开通 disabling:关闭中
    var cabinetOpenStatus:String?
    /// 开通时间，遵循ISO8601标准，使用UTC时间，格式为：YYYY-MM-DDTHH:mm:ssZ
    var cabinetOpenTime:String?
    /// 起租时间，遵循ISO8601标准，使用UTC时间，格式为：YYYY-MM-DDTHH:mm:ssZ
    var startTime:String?
    /// 退租时间，遵循ISO8601标准，使用UTC时间，格式为：YYYY-MM-DDTHH:mm:ssZ
    var endTime:String?



    public override init(){
            super.init()
    }

    enum DescribeCabinetCodingKeys: String, CodingKey {
        case idc
        case idcName
        case cabinetId
        case cabinetNo
        case roomNo
        case cabinetSpace
        case cabinetPower
        case cabinetType
        case cabinetOpenStatus
        case cabinetOpenTime
        case startTime
        case endTime
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: DescribeCabinetCodingKeys.self)
        if decoderContainer.contains(.idc)
        {
            self.idc = try decoderContainer.decode(String?.self, forKey: .idc)
        }
        if decoderContainer.contains(.idcName)
        {
            self.idcName = try decoderContainer.decode(String?.self, forKey: .idcName)
        }
        if decoderContainer.contains(.cabinetId)
        {
            self.cabinetId = try decoderContainer.decode(String?.self, forKey: .cabinetId)
        }
        if decoderContainer.contains(.cabinetNo)
        {
            self.cabinetNo = try decoderContainer.decode(String?.self, forKey: .cabinetNo)
        }
        if decoderContainer.contains(.roomNo)
        {
            self.roomNo = try decoderContainer.decode(String?.self, forKey: .roomNo)
        }
        if decoderContainer.contains(.cabinetSpace)
        {
            self.cabinetSpace = try decoderContainer.decode(Int?.self, forKey: .cabinetSpace)
        }
        if decoderContainer.contains(.cabinetPower)
        {
            self.cabinetPower = try decoderContainer.decode(Int?.self, forKey: .cabinetPower)
        }
        if decoderContainer.contains(.cabinetType)
        {
            self.cabinetType = try decoderContainer.decode(String?.self, forKey: .cabinetType)
        }
        if decoderContainer.contains(.cabinetOpenStatus)
        {
            self.cabinetOpenStatus = try decoderContainer.decode(String?.self, forKey: .cabinetOpenStatus)
        }
        if decoderContainer.contains(.cabinetOpenTime)
        {
            self.cabinetOpenTime = try decoderContainer.decode(String?.self, forKey: .cabinetOpenTime)
        }
        if decoderContainer.contains(.startTime)
        {
            self.startTime = try decoderContainer.decode(String?.self, forKey: .startTime)
        }
        if decoderContainer.contains(.endTime)
        {
            self.endTime = try decoderContainer.decode(String?.self, forKey: .endTime)
        }
    }
}
public extension DescribeCabinet{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: DescribeCabinetCodingKeys.self)
         try encoderContainer.encode(idc, forKey: .idc)
         try encoderContainer.encode(idcName, forKey: .idcName)
         try encoderContainer.encode(cabinetId, forKey: .cabinetId)
         try encoderContainer.encode(cabinetNo, forKey: .cabinetNo)
         try encoderContainer.encode(roomNo, forKey: .roomNo)
         try encoderContainer.encode(cabinetSpace, forKey: .cabinetSpace)
         try encoderContainer.encode(cabinetPower, forKey: .cabinetPower)
         try encoderContainer.encode(cabinetType, forKey: .cabinetType)
         try encoderContainer.encode(cabinetOpenStatus, forKey: .cabinetOpenStatus)
         try encoderContainer.encode(cabinetOpenTime, forKey: .cabinetOpenTime)
         try encoderContainer.encode(startTime, forKey: .startTime)
         try encoderContainer.encode(endTime, forKey: .endTime)
    }
}
///  机房
public class Idc:NSObject,Codable{
    /// 机房英文标识
    var idcValue:String?
    /// 机房名称
    var idcName:String?



    public override init(){
            super.init()
    }

    enum IdcCodingKeys: String, CodingKey {
        case idcValue = "idc"
        case idcName
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: IdcCodingKeys.self)
        if decoderContainer.contains(.idcValue)
        {
            self.idcValue = try decoderContainer.decode(String?.self, forKey: .idcValue)
        }
        if decoderContainer.contains(.idcName)
        {
            self.idcName = try decoderContainer.decode(String?.self, forKey: .idcName)
        }
    }
}
public extension Idc{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: IdcCodingKeys.self)
         try encoderContainer.encode(idcValue, forKey: .idcValue)
         try encoderContainer.encode(idcName, forKey: .idcName)
    }
}
///  公网IP
public class Ip:NSObject,Codable{
    /// 机房英文标识
    var idc:String?
    /// 机房名称
    var idcName:String?
    /// 公网IP实例ID
    var ipId:String?
    /// IP地址段
    var cidrAddr:String?
    /// 网络位地址
    var networkAddr:String?
    /// 网关地址
    var gatewayAddr:Int?
    /// 广播地址
    var broadcastAddr:Int?
    /// 状态 normal:正常 abnormal:异常
    var status:String?



    public override init(){
            super.init()
    }

    enum IpCodingKeys: String, CodingKey {
        case idc
        case idcName
        case ipId
        case cidrAddr
        case networkAddr
        case gatewayAddr
        case broadcastAddr
        case status
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: IpCodingKeys.self)
        if decoderContainer.contains(.idc)
        {
            self.idc = try decoderContainer.decode(String?.self, forKey: .idc)
        }
        if decoderContainer.contains(.idcName)
        {
            self.idcName = try decoderContainer.decode(String?.self, forKey: .idcName)
        }
        if decoderContainer.contains(.ipId)
        {
            self.ipId = try decoderContainer.decode(String?.self, forKey: .ipId)
        }
        if decoderContainer.contains(.cidrAddr)
        {
            self.cidrAddr = try decoderContainer.decode(String?.self, forKey: .cidrAddr)
        }
        if decoderContainer.contains(.networkAddr)
        {
            self.networkAddr = try decoderContainer.decode(String?.self, forKey: .networkAddr)
        }
        if decoderContainer.contains(.gatewayAddr)
        {
            self.gatewayAddr = try decoderContainer.decode(Int?.self, forKey: .gatewayAddr)
        }
        if decoderContainer.contains(.broadcastAddr)
        {
            self.broadcastAddr = try decoderContainer.decode(Int?.self, forKey: .broadcastAddr)
        }
        if decoderContainer.contains(.status)
        {
            self.status = try decoderContainer.decode(String?.self, forKey: .status)
        }
    }
}
public extension Ip{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: IpCodingKeys.self)
         try encoderContainer.encode(idc, forKey: .idc)
         try encoderContainer.encode(idcName, forKey: .idcName)
         try encoderContainer.encode(ipId, forKey: .ipId)
         try encoderContainer.encode(cidrAddr, forKey: .cidrAddr)
         try encoderContainer.encode(networkAddr, forKey: .networkAddr)
         try encoderContainer.encode(gatewayAddr, forKey: .gatewayAddr)
         try encoderContainer.encode(broadcastAddr, forKey: .broadcastAddr)
         try encoderContainer.encode(status, forKey: .status)
    }
}

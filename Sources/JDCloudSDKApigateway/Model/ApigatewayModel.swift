/* Copyright 2018 JDCLOUD.COM

   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at

     http:#www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.

   Hu-Fu
   关于虎符的相关接口

   OpenAPI spec version: v1
   Contact: 

   NOTE: This class is auto generated by the jdcloud code generator program.
 */


import Foundation
///  backendParameter
public class BackendParameter:NSObject,Codable{
    /// 后端参数名称
    var backendName:String?
    /// 后端参数位置
    var backendParamLocation:String?
    /// 入参名称
    var name:String?
    /// 入参位置
    var paramLocation:String?
    /// 入参类型
    var paramType:String?



    public override init(){
            super.init()
    }

    enum BackendParameterCodingKeys: String, CodingKey {
        case backendName
        case backendParamLocation
        case name
        case paramLocation
        case paramType
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: BackendParameterCodingKeys.self)
        if decoderContainer.contains(.backendName)
        {
            self.backendName = try decoderContainer.decode(String?.self, forKey: .backendName)
        }
        if decoderContainer.contains(.backendParamLocation)
        {
            self.backendParamLocation = try decoderContainer.decode(String?.self, forKey: .backendParamLocation)
        }
        if decoderContainer.contains(.name)
        {
            self.name = try decoderContainer.decode(String?.self, forKey: .name)
        }
        if decoderContainer.contains(.paramLocation)
        {
            self.paramLocation = try decoderContainer.decode(String?.self, forKey: .paramLocation)
        }
        if decoderContainer.contains(.paramType)
        {
            self.paramType = try decoderContainer.decode(String?.self, forKey: .paramType)
        }
    }
}
public extension BackendParameter{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: BackendParameterCodingKeys.self)
         try encoderContainer.encode(backendName, forKey: .backendName)
         try encoderContainer.encode(backendParamLocation, forKey: .backendParamLocation)
         try encoderContainer.encode(name, forKey: .name)
         try encoderContainer.encode(paramLocation, forKey: .paramLocation)
         try encoderContainer.encode(paramType, forKey: .paramType)
    }
}
///  apiBackendConfig
public class ApiBackendConfig:NSObject,Codable{
    /// 后端路径
    var backendPath:String?
    /// 后端请求方式
    var backendAction:String?
    /// 后端参数列表
    var backendParams:[BackendParameter?]?
    /// 后端常量参数列表
    var backendConstParams:[Parameter?]?



    public override init(){
            super.init()
    }

    enum ApiBackendConfigCodingKeys: String, CodingKey {
        case backendPath
        case backendAction
        case backendParams
        case backendConstParams
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: ApiBackendConfigCodingKeys.self)
        if decoderContainer.contains(.backendPath)
        {
            self.backendPath = try decoderContainer.decode(String?.self, forKey: .backendPath)
        }
        if decoderContainer.contains(.backendAction)
        {
            self.backendAction = try decoderContainer.decode(String?.self, forKey: .backendAction)
        }
        if decoderContainer.contains(.backendParams)
        {
            self.backendParams = try decoderContainer.decode([BackendParameter?]?.self, forKey: .backendParams)
        }
        if decoderContainer.contains(.backendConstParams)
        {
            self.backendConstParams = try decoderContainer.decode([Parameter?]?.self, forKey: .backendConstParams)
        }
    }
}
public extension ApiBackendConfig{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: ApiBackendConfigCodingKeys.self)
         try encoderContainer.encode(backendPath, forKey: .backendPath)
         try encoderContainer.encode(backendAction, forKey: .backendAction)
         try encoderContainer.encode(backendParams, forKey: .backendParams)
         try encoderContainer.encode(backendConstParams, forKey: .backendConstParams)
    }
}
///  modifyApi
public class ModifyApi:NSObject,Codable{
    /// waf状态，如：observe,deny,off
    var wafStatus:String?



    public override init(){
            super.init()
    }

    enum ModifyApiCodingKeys: String, CodingKey {
        case wafStatus
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: ModifyApiCodingKeys.self)
        if decoderContainer.contains(.wafStatus)
        {
            self.wafStatus = try decoderContainer.decode(String?.self, forKey: .wafStatus)
        }
    }
}
public extension ModifyApi{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: ModifyApiCodingKeys.self)
         try encoderContainer.encode(wafStatus, forKey: .wafStatus)
    }
}
///  createApi
public class CreateApi:NSObject,Codable{
    /// 分组ID
    /// Required:true
    var apiGroupId:String
    /// 名称
    /// Required:true
    var apiName:String
    /// 动作
    /// Required:true
    var action:String
    /// 请求路径
    /// Required:true
    var path:String
    /// 匹配模式：1.&quot;absolute&quot;(绝对匹配); 2.&quot;prefix&quot;（前缀匹配）;
    /// Required:true
    var matchType:String
    /// 描述
    var descriptionValue:String?
    /// 请求参数列表
    var reqParams:[Parameter?]?
    /// 请求格式
    var reqBody:String?
    /// 返回格式
    var resBody:String?
    /// 请求格式类型,1:application/json,2:text/xml,3:其他
    /// Required:true
    var reqBodyType:Int
    /// 返回格式类型,1:application/json,2:text/xml,3:其他
    var resBodyType:Int?
    /// api后端配置
    var apiBackendConfig:ApiBackendConfig?
    /// 后端服务类型，如HTTP/HTTPS,mock,funcion等
    var backServiceType:String?
    /// 后端服务地址，如后端服务地址，funtion路径等
    var backServicePath:String?
    /// 后端服务ID，如函数ID等
    var backServiceId:String?
    /// 后端服务名称，如函数名称
    var backServiceName:String?
    /// 后端地址
    var backUrl:String?
    /// 后端服务配置，为true时，采用与分组统一的配置，初始创建api时请设置为True。
    /// Required:true
    var backServiceConfig:Bool
    /// 后端服务版本，如函数版本名称
    var backServiceVersion:String?
    /// 应用类型ID,云鼎业务线专用
    var hufuAppTypeId:Int?
    /// 请求格式类型,当reqBodyType等于3时,使用该请求格式类型
    var editableReqBodyType:String?
    /// 响应格式类型,当resBodyType等于3时,使用该响应格式类型
    var editableResBodyType:String?



    public  init(apiGroupId:String,apiName:String,action:String,path:String,matchType:String,reqBodyType:Int,backServiceConfig:Bool){
             self.apiGroupId = apiGroupId
             self.apiName = apiName
             self.action = action
             self.path = path
             self.matchType = matchType
             self.reqBodyType = reqBodyType
             self.backServiceConfig = backServiceConfig
    }

    enum CreateApiCodingKeys: String, CodingKey {
        case apiGroupId
        case apiName
        case action
        case path
        case matchType
        case descriptionValue = "description"
        case reqParams
        case reqBody
        case resBody
        case reqBodyType
        case resBodyType
        case apiBackendConfig
        case backServiceType
        case backServicePath
        case backServiceId
        case backServiceName
        case backUrl
        case backServiceConfig
        case backServiceVersion
        case hufuAppTypeId
        case editableReqBodyType
        case editableResBodyType
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: CreateApiCodingKeys.self)
        self.apiGroupId = try decoderContainer.decode(String.self, forKey: .apiGroupId)
        self.apiName = try decoderContainer.decode(String.self, forKey: .apiName)
        self.action = try decoderContainer.decode(String.self, forKey: .action)
        self.path = try decoderContainer.decode(String.self, forKey: .path)
        self.matchType = try decoderContainer.decode(String.self, forKey: .matchType)
        if decoderContainer.contains(.descriptionValue)
        {
            self.descriptionValue = try decoderContainer.decode(String?.self, forKey: .descriptionValue)
        }
        if decoderContainer.contains(.reqParams)
        {
            self.reqParams = try decoderContainer.decode([Parameter?]?.self, forKey: .reqParams)
        }
        if decoderContainer.contains(.reqBody)
        {
            self.reqBody = try decoderContainer.decode(String?.self, forKey: .reqBody)
        }
        if decoderContainer.contains(.resBody)
        {
            self.resBody = try decoderContainer.decode(String?.self, forKey: .resBody)
        }
        self.reqBodyType = try decoderContainer.decode(Int.self, forKey: .reqBodyType)
        if decoderContainer.contains(.resBodyType)
        {
            self.resBodyType = try decoderContainer.decode(Int?.self, forKey: .resBodyType)
        }
        if decoderContainer.contains(.apiBackendConfig)
        {
            self.apiBackendConfig = try decoderContainer.decode(ApiBackendConfig?.self, forKey: .apiBackendConfig)
        }
        if decoderContainer.contains(.backServiceType)
        {
            self.backServiceType = try decoderContainer.decode(String?.self, forKey: .backServiceType)
        }
        if decoderContainer.contains(.backServicePath)
        {
            self.backServicePath = try decoderContainer.decode(String?.self, forKey: .backServicePath)
        }
        if decoderContainer.contains(.backServiceId)
        {
            self.backServiceId = try decoderContainer.decode(String?.self, forKey: .backServiceId)
        }
        if decoderContainer.contains(.backServiceName)
        {
            self.backServiceName = try decoderContainer.decode(String?.self, forKey: .backServiceName)
        }
        if decoderContainer.contains(.backUrl)
        {
            self.backUrl = try decoderContainer.decode(String?.self, forKey: .backUrl)
        }
        self.backServiceConfig = try decoderContainer.decode(Bool.self, forKey: .backServiceConfig)
        if decoderContainer.contains(.backServiceVersion)
        {
            self.backServiceVersion = try decoderContainer.decode(String?.self, forKey: .backServiceVersion)
        }
        if decoderContainer.contains(.hufuAppTypeId)
        {
            self.hufuAppTypeId = try decoderContainer.decode(Int?.self, forKey: .hufuAppTypeId)
        }
        if decoderContainer.contains(.editableReqBodyType)
        {
            self.editableReqBodyType = try decoderContainer.decode(String?.self, forKey: .editableReqBodyType)
        }
        if decoderContainer.contains(.editableResBodyType)
        {
            self.editableResBodyType = try decoderContainer.decode(String?.self, forKey: .editableResBodyType)
        }
    }
}
public extension CreateApi{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: CreateApiCodingKeys.self)
         try encoderContainer.encode(apiGroupId, forKey: .apiGroupId)
         try encoderContainer.encode(apiName, forKey: .apiName)
         try encoderContainer.encode(action, forKey: .action)
         try encoderContainer.encode(path, forKey: .path)
         try encoderContainer.encode(matchType, forKey: .matchType)
         try encoderContainer.encode(descriptionValue, forKey: .descriptionValue)
         try encoderContainer.encode(reqParams, forKey: .reqParams)
         try encoderContainer.encode(reqBody, forKey: .reqBody)
         try encoderContainer.encode(resBody, forKey: .resBody)
         try encoderContainer.encode(reqBodyType, forKey: .reqBodyType)
         try encoderContainer.encode(resBodyType, forKey: .resBodyType)
         try encoderContainer.encode(apiBackendConfig, forKey: .apiBackendConfig)
         try encoderContainer.encode(backServiceType, forKey: .backServiceType)
         try encoderContainer.encode(backServicePath, forKey: .backServicePath)
         try encoderContainer.encode(backServiceId, forKey: .backServiceId)
         try encoderContainer.encode(backServiceName, forKey: .backServiceName)
         try encoderContainer.encode(backUrl, forKey: .backUrl)
         try encoderContainer.encode(backServiceConfig, forKey: .backServiceConfig)
         try encoderContainer.encode(backServiceVersion, forKey: .backServiceVersion)
         try encoderContainer.encode(hufuAppTypeId, forKey: .hufuAppTypeId)
         try encoderContainer.encode(editableReqBodyType, forKey: .editableReqBodyType)
         try encoderContainer.encode(editableResBodyType, forKey: .editableResBodyType)
    }
}
///  parameter
public class Parameter:NSObject,Codable{
    /// 名称
    var name:String?
    /// 描述
    var descriptionValue:String?
    /// 参数位置
    var paramLocation:String?
    /// 参数类型
    var paramType:String?
    /// 默认值
    var defaultValue:String?
    /// 默认值
    var isRequired:Bool?



    public override init(){
            super.init()
    }

    enum ParameterCodingKeys: String, CodingKey {
        case name
        case descriptionValue = "description"
        case paramLocation
        case paramType
        case defaultValue
        case isRequired
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: ParameterCodingKeys.self)
        if decoderContainer.contains(.name)
        {
            self.name = try decoderContainer.decode(String?.self, forKey: .name)
        }
        if decoderContainer.contains(.descriptionValue)
        {
            self.descriptionValue = try decoderContainer.decode(String?.self, forKey: .descriptionValue)
        }
        if decoderContainer.contains(.paramLocation)
        {
            self.paramLocation = try decoderContainer.decode(String?.self, forKey: .paramLocation)
        }
        if decoderContainer.contains(.paramType)
        {
            self.paramType = try decoderContainer.decode(String?.self, forKey: .paramType)
        }
        if decoderContainer.contains(.defaultValue)
        {
            self.defaultValue = try decoderContainer.decode(String?.self, forKey: .defaultValue)
        }
        if decoderContainer.contains(.isRequired)
        {
            self.isRequired = try decoderContainer.decode(Bool?.self, forKey: .isRequired)
        }
    }
}
public extension Parameter{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: ParameterCodingKeys.self)
         try encoderContainer.encode(name, forKey: .name)
         try encoderContainer.encode(descriptionValue, forKey: .descriptionValue)
         try encoderContainer.encode(paramLocation, forKey: .paramLocation)
         try encoderContainer.encode(paramType, forKey: .paramType)
         try encoderContainer.encode(defaultValue, forKey: .defaultValue)
         try encoderContainer.encode(isRequired, forKey: .isRequired)
    }
}
///  importApi
public class ImportApi:NSObject,Codable{
    /// api接口定义
    /// Required:true
    var apiDefine:String



    public  init(apiDefine:String){
             self.apiDefine = apiDefine
    }

    enum ImportApiCodingKeys: String, CodingKey {
        case apiDefine
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: ImportApiCodingKeys.self)
        self.apiDefine = try decoderContainer.decode(String.self, forKey: .apiDefine)
    }
}
public extension ImportApi{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: ImportApiCodingKeys.self)
         try encoderContainer.encode(apiDefine, forKey: .apiDefine)
    }
}
///  api
public class Api:NSObject,Codable{
    /// apiId
    var apiId:String?
    /// 分组ID
    var apiGroupId:String?
    /// 名称
    var apiName:String?
    /// 动作
    var action:String?
    /// 请求路径
    var path:String?
    /// 匹配模式：1.&quot;absolute&quot;(绝对匹配); 2.&quot;prefix&quot;（前缀匹配）;
    var matchType:String?
    /// 后端类型，为空或null时前端显示未设置
    var backServiceType:String?
    /// 描述
    var descriptionValue:String?
    /// 请求参数列表
    var reqParams:[Parameter?]?
    /// 请求格式
    var reqBody:String?
    /// 返回格式
    var resBody:String?
    /// 请求格式类型,1:application/json,2:text/xml,3:其他
    var reqBodyType:Int?
    /// 返回格式类型,1:application/json,2:text/xml,3:其他
    var resBodyType:Int?
    /// api后端配置
    var apiBackendConfig:ApiBackendConfig?
    /// 应用类型ID,云鼎业务线专用
    var hufuAppTypeId:Int?
    /// 当前分组版本，发布的环境信息
    var deploymentEnvironment:[String?]?
    /// 请求格式类型,当reqBodyType等于3时,使用该请求格式类型
    var editableReqBodyType:String?
    /// 响应格式类型,当resBodyType等于3时,使用该响应格式类型
    var editableResBodyType:String?
    /// waf状态，如：observe,deny,off
    var wafStatus:String?



    public override init(){
            super.init()
    }

    enum ApiCodingKeys: String, CodingKey {
        case apiId
        case apiGroupId
        case apiName
        case action
        case path
        case matchType
        case backServiceType
        case descriptionValue = "description"
        case reqParams
        case reqBody
        case resBody
        case reqBodyType
        case resBodyType
        case apiBackendConfig
        case hufuAppTypeId
        case deploymentEnvironment
        case editableReqBodyType
        case editableResBodyType
        case wafStatus
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: ApiCodingKeys.self)
        if decoderContainer.contains(.apiId)
        {
            self.apiId = try decoderContainer.decode(String?.self, forKey: .apiId)
        }
        if decoderContainer.contains(.apiGroupId)
        {
            self.apiGroupId = try decoderContainer.decode(String?.self, forKey: .apiGroupId)
        }
        if decoderContainer.contains(.apiName)
        {
            self.apiName = try decoderContainer.decode(String?.self, forKey: .apiName)
        }
        if decoderContainer.contains(.action)
        {
            self.action = try decoderContainer.decode(String?.self, forKey: .action)
        }
        if decoderContainer.contains(.path)
        {
            self.path = try decoderContainer.decode(String?.self, forKey: .path)
        }
        if decoderContainer.contains(.matchType)
        {
            self.matchType = try decoderContainer.decode(String?.self, forKey: .matchType)
        }
        if decoderContainer.contains(.backServiceType)
        {
            self.backServiceType = try decoderContainer.decode(String?.self, forKey: .backServiceType)
        }
        if decoderContainer.contains(.descriptionValue)
        {
            self.descriptionValue = try decoderContainer.decode(String?.self, forKey: .descriptionValue)
        }
        if decoderContainer.contains(.reqParams)
        {
            self.reqParams = try decoderContainer.decode([Parameter?]?.self, forKey: .reqParams)
        }
        if decoderContainer.contains(.reqBody)
        {
            self.reqBody = try decoderContainer.decode(String?.self, forKey: .reqBody)
        }
        if decoderContainer.contains(.resBody)
        {
            self.resBody = try decoderContainer.decode(String?.self, forKey: .resBody)
        }
        if decoderContainer.contains(.reqBodyType)
        {
            self.reqBodyType = try decoderContainer.decode(Int?.self, forKey: .reqBodyType)
        }
        if decoderContainer.contains(.resBodyType)
        {
            self.resBodyType = try decoderContainer.decode(Int?.self, forKey: .resBodyType)
        }
        if decoderContainer.contains(.apiBackendConfig)
        {
            self.apiBackendConfig = try decoderContainer.decode(ApiBackendConfig?.self, forKey: .apiBackendConfig)
        }
        if decoderContainer.contains(.hufuAppTypeId)
        {
            self.hufuAppTypeId = try decoderContainer.decode(Int?.self, forKey: .hufuAppTypeId)
        }
        if decoderContainer.contains(.deploymentEnvironment)
        {
            self.deploymentEnvironment = try decoderContainer.decode([String?]?.self, forKey: .deploymentEnvironment)
        }
        if decoderContainer.contains(.editableReqBodyType)
        {
            self.editableReqBodyType = try decoderContainer.decode(String?.self, forKey: .editableReqBodyType)
        }
        if decoderContainer.contains(.editableResBodyType)
        {
            self.editableResBodyType = try decoderContainer.decode(String?.self, forKey: .editableResBodyType)
        }
        if decoderContainer.contains(.wafStatus)
        {
            self.wafStatus = try decoderContainer.decode(String?.self, forKey: .wafStatus)
        }
    }
}
public extension Api{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: ApiCodingKeys.self)
         try encoderContainer.encode(apiId, forKey: .apiId)
         try encoderContainer.encode(apiGroupId, forKey: .apiGroupId)
         try encoderContainer.encode(apiName, forKey: .apiName)
         try encoderContainer.encode(action, forKey: .action)
         try encoderContainer.encode(path, forKey: .path)
         try encoderContainer.encode(matchType, forKey: .matchType)
         try encoderContainer.encode(backServiceType, forKey: .backServiceType)
         try encoderContainer.encode(descriptionValue, forKey: .descriptionValue)
         try encoderContainer.encode(reqParams, forKey: .reqParams)
         try encoderContainer.encode(reqBody, forKey: .reqBody)
         try encoderContainer.encode(resBody, forKey: .resBody)
         try encoderContainer.encode(reqBodyType, forKey: .reqBodyType)
         try encoderContainer.encode(resBodyType, forKey: .resBodyType)
         try encoderContainer.encode(apiBackendConfig, forKey: .apiBackendConfig)
         try encoderContainer.encode(hufuAppTypeId, forKey: .hufuAppTypeId)
         try encoderContainer.encode(deploymentEnvironment, forKey: .deploymentEnvironment)
         try encoderContainer.encode(editableReqBodyType, forKey: .editableReqBodyType)
         try encoderContainer.encode(editableResBodyType, forKey: .editableResBodyType)
         try encoderContainer.encode(wafStatus, forKey: .wafStatus)
    }
}
///  hufuApi
public class HufuApi:NSObject,Codable{
    /// API ID
    var apiId:String?
    /// 分组ID
    var apiGroupId:String?
    /// api状态
    var apiStatus:String?
    /// 名称
    var apiName:String?
    /// 描述
    var descriptionValue:String?
    /// 应用类型ID,云鼎业务线专用
    var hufuAppTypeId:Int?



    public override init(){
            super.init()
    }

    enum HufuApiCodingKeys: String, CodingKey {
        case apiId
        case apiGroupId
        case apiStatus
        case apiName
        case descriptionValue = "description"
        case hufuAppTypeId
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: HufuApiCodingKeys.self)
        if decoderContainer.contains(.apiId)
        {
            self.apiId = try decoderContainer.decode(String?.self, forKey: .apiId)
        }
        if decoderContainer.contains(.apiGroupId)
        {
            self.apiGroupId = try decoderContainer.decode(String?.self, forKey: .apiGroupId)
        }
        if decoderContainer.contains(.apiStatus)
        {
            self.apiStatus = try decoderContainer.decode(String?.self, forKey: .apiStatus)
        }
        if decoderContainer.contains(.apiName)
        {
            self.apiName = try decoderContainer.decode(String?.self, forKey: .apiName)
        }
        if decoderContainer.contains(.descriptionValue)
        {
            self.descriptionValue = try decoderContainer.decode(String?.self, forKey: .descriptionValue)
        }
        if decoderContainer.contains(.hufuAppTypeId)
        {
            self.hufuAppTypeId = try decoderContainer.decode(Int?.self, forKey: .hufuAppTypeId)
        }
    }
}
public extension HufuApi{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: HufuApiCodingKeys.self)
         try encoderContainer.encode(apiId, forKey: .apiId)
         try encoderContainer.encode(apiGroupId, forKey: .apiGroupId)
         try encoderContainer.encode(apiStatus, forKey: .apiStatus)
         try encoderContainer.encode(apiName, forKey: .apiName)
         try encoderContainer.encode(descriptionValue, forKey: .descriptionValue)
         try encoderContainer.encode(hufuAppTypeId, forKey: .hufuAppTypeId)
    }
}
///  debugApi
public class DebugApi:NSObject,Codable{
    /// assessKey：京东云用户、API调用者、订阅密钥key
    var assessKey:String?
    /// secretKey：京东云用户、API调用者
    var secretKey:String?
    /// 请求host
    /// Required:true
    var host:String
    /// 请求uri,分组路径前缀+API请求路径，如：/todo/api/v1/creatApi
    /// Required:true
    var uri:String
    /// 请求方式
    /// Required:true
    var method:String
    /// 访问授权方式：None（免鉴权）,jd_cloud（京东云用户），jd_apikms（API调用者），jd_subscription_key（订阅密钥）
    /// Required:true
    var authType:String
    /// api所属region
    /// Required:true
    var region:String
    /// query参数，用&amp;分隔，如：id&#x3D;1&amp;version&#x3D;v1
    var queryString:String?
    /// body参数，传json字符串的base64编码，例如body的值为：{&quot;title&quot;:&quot;desk&quot;,&quot;desc&quot;:&quot;cheap&quot;}，应传值为：&quot;eyJ0aXRsZSI6ImRlc2siLCJkZXNjIjoiY2hlYXAifQ&#x3D;&#x3D;&quot;
    var body:String?
    /// 请求格式类型,1:application/json,2:text/xml,3:其他
    /// Required:true
    var reqBodyType:String
    /// 请求格式类型,当reqBodyType等于3时,使用该请求格式类型
    var editableReqBodyType:String?
    /// header参数，传json字符串
    var headerString:String?
    /// 发布的环境信息，如：online,preview,test
    /// Required:true
    var environment:String
    /// 是否API产品, 1为是
    var isApiProduct:String?



    public  init(host:String,uri:String,method:String,authType:String,region:String,reqBodyType:String,environment:String){
             self.host = host
             self.uri = uri
             self.method = method
             self.authType = authType
             self.region = region
             self.reqBodyType = reqBodyType
             self.environment = environment
    }

    enum DebugApiCodingKeys: String, CodingKey {
        case assessKey
        case secretKey
        case host
        case uri
        case method
        case authType
        case region
        case queryString
        case body
        case reqBodyType
        case editableReqBodyType
        case headerString
        case environment
        case isApiProduct
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: DebugApiCodingKeys.self)
        if decoderContainer.contains(.assessKey)
        {
            self.assessKey = try decoderContainer.decode(String?.self, forKey: .assessKey)
        }
        if decoderContainer.contains(.secretKey)
        {
            self.secretKey = try decoderContainer.decode(String?.self, forKey: .secretKey)
        }
        self.host = try decoderContainer.decode(String.self, forKey: .host)
        self.uri = try decoderContainer.decode(String.self, forKey: .uri)
        self.method = try decoderContainer.decode(String.self, forKey: .method)
        self.authType = try decoderContainer.decode(String.self, forKey: .authType)
        self.region = try decoderContainer.decode(String.self, forKey: .region)
        if decoderContainer.contains(.queryString)
        {
            self.queryString = try decoderContainer.decode(String?.self, forKey: .queryString)
        }
        if decoderContainer.contains(.body)
        {
            self.body = try decoderContainer.decode(String?.self, forKey: .body)
        }
        self.reqBodyType = try decoderContainer.decode(String.self, forKey: .reqBodyType)
        if decoderContainer.contains(.editableReqBodyType)
        {
            self.editableReqBodyType = try decoderContainer.decode(String?.self, forKey: .editableReqBodyType)
        }
        if decoderContainer.contains(.headerString)
        {
            self.headerString = try decoderContainer.decode(String?.self, forKey: .headerString)
        }
        self.environment = try decoderContainer.decode(String.self, forKey: .environment)
        if decoderContainer.contains(.isApiProduct)
        {
            self.isApiProduct = try decoderContainer.decode(String?.self, forKey: .isApiProduct)
        }
    }
}
public extension DebugApi{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: DebugApiCodingKeys.self)
         try encoderContainer.encode(assessKey, forKey: .assessKey)
         try encoderContainer.encode(secretKey, forKey: .secretKey)
         try encoderContainer.encode(host, forKey: .host)
         try encoderContainer.encode(uri, forKey: .uri)
         try encoderContainer.encode(method, forKey: .method)
         try encoderContainer.encode(authType, forKey: .authType)
         try encoderContainer.encode(region, forKey: .region)
         try encoderContainer.encode(queryString, forKey: .queryString)
         try encoderContainer.encode(body, forKey: .body)
         try encoderContainer.encode(reqBodyType, forKey: .reqBodyType)
         try encoderContainer.encode(editableReqBodyType, forKey: .editableReqBodyType)
         try encoderContainer.encode(headerString, forKey: .headerString)
         try encoderContainer.encode(environment, forKey: .environment)
         try encoderContainer.encode(isApiProduct, forKey: .isApiProduct)
    }
}
///  API分组
public class ApiGroup:NSObject,Codable{
    /// 分组ID
    var apiGroupId:String?
    /// 名称
    var groupName:String?
    /// 描述
    var descriptionValue:String?
    /// 分组路径前缀
    var prefix:String?
    /// 版本号
    var version:String?
    /// 区域
    var regionId:String?
    /// 域名
    var domain:String?
    /// 发布环境信息，若为空或null，则未发布
    var environment:String?
    /// 密钥验证方式：check_exist（密钥必须在访问授权中已配置）、no_check_exist（无需事先配置）
    var keyCheck:String?
    /// 访问授权方式：None（免鉴权）、jd_cloud（开启访问授权，且必须使用京东云的AK、SK验签）、hufu（虎符用户）
    var authType:String?
    /// 是否转发分组路径到后端服务：0（不转发）、1（转发）
    var prefixStrip:Int?
    /// 分组类型：api_group（api分组）、jdsf_group（微服务分组）
    var groupType:String?
    /// 微服务网关名称
    var jdsfName:String?
    /// 微服务注册中心ID
    var jdsfRegistryName:String?
    /// 微服务网关ID
    var jdsfId:String?
    /// 分组是否已发布：0（未发布）、1（发布）
    var deploy:Int?



    public override init(){
            super.init()
    }

    enum ApiGroupCodingKeys: String, CodingKey {
        case apiGroupId
        case groupName
        case descriptionValue = "description"
        case prefix
        case version
        case regionId
        case domain
        case environment
        case keyCheck
        case authType
        case prefixStrip
        case groupType
        case jdsfName
        case jdsfRegistryName
        case jdsfId
        case deploy
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: ApiGroupCodingKeys.self)
        if decoderContainer.contains(.apiGroupId)
        {
            self.apiGroupId = try decoderContainer.decode(String?.self, forKey: .apiGroupId)
        }
        if decoderContainer.contains(.groupName)
        {
            self.groupName = try decoderContainer.decode(String?.self, forKey: .groupName)
        }
        if decoderContainer.contains(.descriptionValue)
        {
            self.descriptionValue = try decoderContainer.decode(String?.self, forKey: .descriptionValue)
        }
        if decoderContainer.contains(.prefix)
        {
            self.prefix = try decoderContainer.decode(String?.self, forKey: .prefix)
        }
        if decoderContainer.contains(.version)
        {
            self.version = try decoderContainer.decode(String?.self, forKey: .version)
        }
        if decoderContainer.contains(.regionId)
        {
            self.regionId = try decoderContainer.decode(String?.self, forKey: .regionId)
        }
        if decoderContainer.contains(.domain)
        {
            self.domain = try decoderContainer.decode(String?.self, forKey: .domain)
        }
        if decoderContainer.contains(.environment)
        {
            self.environment = try decoderContainer.decode(String?.self, forKey: .environment)
        }
        if decoderContainer.contains(.keyCheck)
        {
            self.keyCheck = try decoderContainer.decode(String?.self, forKey: .keyCheck)
        }
        if decoderContainer.contains(.authType)
        {
            self.authType = try decoderContainer.decode(String?.self, forKey: .authType)
        }
        if decoderContainer.contains(.prefixStrip)
        {
            self.prefixStrip = try decoderContainer.decode(Int?.self, forKey: .prefixStrip)
        }
        if decoderContainer.contains(.groupType)
        {
            self.groupType = try decoderContainer.decode(String?.self, forKey: .groupType)
        }
        if decoderContainer.contains(.jdsfName)
        {
            self.jdsfName = try decoderContainer.decode(String?.self, forKey: .jdsfName)
        }
        if decoderContainer.contains(.jdsfRegistryName)
        {
            self.jdsfRegistryName = try decoderContainer.decode(String?.self, forKey: .jdsfRegistryName)
        }
        if decoderContainer.contains(.jdsfId)
        {
            self.jdsfId = try decoderContainer.decode(String?.self, forKey: .jdsfId)
        }
        if decoderContainer.contains(.deploy)
        {
            self.deploy = try decoderContainer.decode(Int?.self, forKey: .deploy)
        }
    }
}
public extension ApiGroup{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: ApiGroupCodingKeys.self)
         try encoderContainer.encode(apiGroupId, forKey: .apiGroupId)
         try encoderContainer.encode(groupName, forKey: .groupName)
         try encoderContainer.encode(descriptionValue, forKey: .descriptionValue)
         try encoderContainer.encode(prefix, forKey: .prefix)
         try encoderContainer.encode(version, forKey: .version)
         try encoderContainer.encode(regionId, forKey: .regionId)
         try encoderContainer.encode(domain, forKey: .domain)
         try encoderContainer.encode(environment, forKey: .environment)
         try encoderContainer.encode(keyCheck, forKey: .keyCheck)
         try encoderContainer.encode(authType, forKey: .authType)
         try encoderContainer.encode(prefixStrip, forKey: .prefixStrip)
         try encoderContainer.encode(groupType, forKey: .groupType)
         try encoderContainer.encode(jdsfName, forKey: .jdsfName)
         try encoderContainer.encode(jdsfRegistryName, forKey: .jdsfRegistryName)
         try encoderContainer.encode(jdsfId, forKey: .jdsfId)
         try encoderContainer.encode(deploy, forKey: .deploy)
    }
}
///  pinAuthManage
public class PinAuthManage:NSObject,Codable{
    /// 被管理用户的名称
    var subordinatesName:String?
    /// 被管理用户的pin
    /// Required:true
    var subordinatesPin:String



    public  init(subordinatesPin:String){
             self.subordinatesPin = subordinatesPin
    }

    enum PinAuthManageCodingKeys: String, CodingKey {
        case subordinatesName
        case subordinatesPin
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: PinAuthManageCodingKeys.self)
        if decoderContainer.contains(.subordinatesName)
        {
            self.subordinatesName = try decoderContainer.decode(String?.self, forKey: .subordinatesName)
        }
        self.subordinatesPin = try decoderContainer.decode(String.self, forKey: .subordinatesPin)
    }
}
public extension PinAuthManage{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: PinAuthManageCodingKeys.self)
         try encoderContainer.encode(subordinatesName, forKey: .subordinatesName)
         try encoderContainer.encode(subordinatesPin, forKey: .subordinatesPin)
    }
}
///  发布
public class Deploy:NSObject,Codable{
    /// 发布的修订版本号
    /// Required:true
    var revision:String
    /// 环境：test、preview、online
    /// Required:true
    var environment:String
    /// 后端服务类型：mock、unique、vpc
    var backendServiceType:String?
    /// 后端地址
    var backendUrl:String?
    /// 描述
    var descriptionValue:String?
    /// 微服务网关名称
    var jdsfName:String?
    /// 微服务注册中心ID
    var jdsfRegistryName:String?
    /// 微服务ID
    var jdsfId:String?



    public  init(revision:String,environment:String){
             self.revision = revision
             self.environment = environment
    }

    enum DeployCodingKeys: String, CodingKey {
        case revision
        case environment
        case backendServiceType
        case backendUrl
        case descriptionValue = "description"
        case jdsfName
        case jdsfRegistryName
        case jdsfId
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: DeployCodingKeys.self)
        self.revision = try decoderContainer.decode(String.self, forKey: .revision)
        self.environment = try decoderContainer.decode(String.self, forKey: .environment)
        if decoderContainer.contains(.backendServiceType)
        {
            self.backendServiceType = try decoderContainer.decode(String?.self, forKey: .backendServiceType)
        }
        if decoderContainer.contains(.backendUrl)
        {
            self.backendUrl = try decoderContainer.decode(String?.self, forKey: .backendUrl)
        }
        if decoderContainer.contains(.descriptionValue)
        {
            self.descriptionValue = try decoderContainer.decode(String?.self, forKey: .descriptionValue)
        }
        if decoderContainer.contains(.jdsfName)
        {
            self.jdsfName = try decoderContainer.decode(String?.self, forKey: .jdsfName)
        }
        if decoderContainer.contains(.jdsfRegistryName)
        {
            self.jdsfRegistryName = try decoderContainer.decode(String?.self, forKey: .jdsfRegistryName)
        }
        if decoderContainer.contains(.jdsfId)
        {
            self.jdsfId = try decoderContainer.decode(String?.self, forKey: .jdsfId)
        }
    }
}
public extension Deploy{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: DeployCodingKeys.self)
         try encoderContainer.encode(revision, forKey: .revision)
         try encoderContainer.encode(environment, forKey: .environment)
         try encoderContainer.encode(backendServiceType, forKey: .backendServiceType)
         try encoderContainer.encode(backendUrl, forKey: .backendUrl)
         try encoderContainer.encode(descriptionValue, forKey: .descriptionValue)
         try encoderContainer.encode(jdsfName, forKey: .jdsfName)
         try encoderContainer.encode(jdsfRegistryName, forKey: .jdsfRegistryName)
         try encoderContainer.encode(jdsfId, forKey: .jdsfId)
    }
}
///  部署列表
public class Deployment:NSObject,Codable{
    /// 部署ID
    var deploymentId:String?
    /// 发布的修订版本号
    var revision:String?
    /// 路径
    var path:String?
    /// 环境：test、preview、online
    var environment:String?
    /// 后端服务类型：mock、unique、vpc
    var backendServiceType:String?
    /// 后端地址
    var backendUrl:String?
    /// 描述
    var descriptionValue:String?
    /// 发布日期，格式为毫秒级时间戳
    var createTime:Int64?
    /// 微服务网关名称
    var jdsfName:String?
    /// 微服务注册中心ID
    var jdsfRegistryName:String?
    /// 微服务ID
    var jdsfId:String?



    public override init(){
            super.init()
    }

    enum DeploymentCodingKeys: String, CodingKey {
        case deploymentId
        case revision
        case path
        case environment
        case backendServiceType
        case backendUrl
        case descriptionValue = "description"
        case createTime
        case jdsfName
        case jdsfRegistryName
        case jdsfId
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: DeploymentCodingKeys.self)
        if decoderContainer.contains(.deploymentId)
        {
            self.deploymentId = try decoderContainer.decode(String?.self, forKey: .deploymentId)
        }
        if decoderContainer.contains(.revision)
        {
            self.revision = try decoderContainer.decode(String?.self, forKey: .revision)
        }
        if decoderContainer.contains(.path)
        {
            self.path = try decoderContainer.decode(String?.self, forKey: .path)
        }
        if decoderContainer.contains(.environment)
        {
            self.environment = try decoderContainer.decode(String?.self, forKey: .environment)
        }
        if decoderContainer.contains(.backendServiceType)
        {
            self.backendServiceType = try decoderContainer.decode(String?.self, forKey: .backendServiceType)
        }
        if decoderContainer.contains(.backendUrl)
        {
            self.backendUrl = try decoderContainer.decode(String?.self, forKey: .backendUrl)
        }
        if decoderContainer.contains(.descriptionValue)
        {
            self.descriptionValue = try decoderContainer.decode(String?.self, forKey: .descriptionValue)
        }
        if decoderContainer.contains(.createTime)
        {
            self.createTime = try decoderContainer.decode(Int64?.self, forKey: .createTime)
        }
        if decoderContainer.contains(.jdsfName)
        {
            self.jdsfName = try decoderContainer.decode(String?.self, forKey: .jdsfName)
        }
        if decoderContainer.contains(.jdsfRegistryName)
        {
            self.jdsfRegistryName = try decoderContainer.decode(String?.self, forKey: .jdsfRegistryName)
        }
        if decoderContainer.contains(.jdsfId)
        {
            self.jdsfId = try decoderContainer.decode(String?.self, forKey: .jdsfId)
        }
    }
}
public extension Deployment{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: DeploymentCodingKeys.self)
         try encoderContainer.encode(deploymentId, forKey: .deploymentId)
         try encoderContainer.encode(revision, forKey: .revision)
         try encoderContainer.encode(path, forKey: .path)
         try encoderContainer.encode(environment, forKey: .environment)
         try encoderContainer.encode(backendServiceType, forKey: .backendServiceType)
         try encoderContainer.encode(backendUrl, forKey: .backendUrl)
         try encoderContainer.encode(descriptionValue, forKey: .descriptionValue)
         try encoderContainer.encode(createTime, forKey: .createTime)
         try encoderContainer.encode(jdsfName, forKey: .jdsfName)
         try encoderContainer.encode(jdsfRegistryName, forKey: .jdsfRegistryName)
         try encoderContainer.encode(jdsfId, forKey: .jdsfId)
    }
}
///  API产品
public class ApiProduct:NSObject,Codable{
    /// 分组ID
    var apiGroupId:String?
    /// 名称
    var groupName:String?
    /// 描述
    var descriptionValue:String?
    /// 版本号
    var version:String?
    /// 区域
    var regionId:String?
    /// 计价方式
    var price:String?
    /// 发布日期，格式为毫秒级时间戳
    var deploymentDate:Int64?
    /// 购买状态，1已购买，0未购买
    var isBuyed:Int?
    /// 发布日期，格式为毫秒级时间戳
    var buyDate:Int64?



    public override init(){
            super.init()
    }

    enum ApiProductCodingKeys: String, CodingKey {
        case apiGroupId
        case groupName
        case descriptionValue = "description"
        case version
        case regionId
        case price
        case deploymentDate
        case isBuyed
        case buyDate
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: ApiProductCodingKeys.self)
        if decoderContainer.contains(.apiGroupId)
        {
            self.apiGroupId = try decoderContainer.decode(String?.self, forKey: .apiGroupId)
        }
        if decoderContainer.contains(.groupName)
        {
            self.groupName = try decoderContainer.decode(String?.self, forKey: .groupName)
        }
        if decoderContainer.contains(.descriptionValue)
        {
            self.descriptionValue = try decoderContainer.decode(String?.self, forKey: .descriptionValue)
        }
        if decoderContainer.contains(.version)
        {
            self.version = try decoderContainer.decode(String?.self, forKey: .version)
        }
        if decoderContainer.contains(.regionId)
        {
            self.regionId = try decoderContainer.decode(String?.self, forKey: .regionId)
        }
        if decoderContainer.contains(.price)
        {
            self.price = try decoderContainer.decode(String?.self, forKey: .price)
        }
        if decoderContainer.contains(.deploymentDate)
        {
            self.deploymentDate = try decoderContainer.decode(Int64?.self, forKey: .deploymentDate)
        }
        if decoderContainer.contains(.isBuyed)
        {
            self.isBuyed = try decoderContainer.decode(Int?.self, forKey: .isBuyed)
        }
        if decoderContainer.contains(.buyDate)
        {
            self.buyDate = try decoderContainer.decode(Int64?.self, forKey: .buyDate)
        }
    }
}
public extension ApiProduct{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: ApiProductCodingKeys.self)
         try encoderContainer.encode(apiGroupId, forKey: .apiGroupId)
         try encoderContainer.encode(groupName, forKey: .groupName)
         try encoderContainer.encode(descriptionValue, forKey: .descriptionValue)
         try encoderContainer.encode(version, forKey: .version)
         try encoderContainer.encode(regionId, forKey: .regionId)
         try encoderContainer.encode(price, forKey: .price)
         try encoderContainer.encode(deploymentDate, forKey: .deploymentDate)
         try encoderContainer.encode(isBuyed, forKey: .isBuyed)
         try encoderContainer.encode(buyDate, forKey: .buyDate)
    }
}
///  function
public class Function:NSObject,Codable{
    /// 函数名称
    /// Required:true
    var functionName:String
    /// 函数版本名称
    var versionName:String?



    public  init(functionName:String){
             self.functionName = functionName
    }

    enum FunctionCodingKeys: String, CodingKey {
        case functionName
        case versionName
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: FunctionCodingKeys.self)
        self.functionName = try decoderContainer.decode(String.self, forKey: .functionName)
        if decoderContainer.contains(.versionName)
        {
            self.versionName = try decoderContainer.decode(String?.self, forKey: .versionName)
        }
    }
}
public extension Function{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: FunctionCodingKeys.self)
         try encoderContainer.encode(functionName, forKey: .functionName)
         try encoderContainer.encode(versionName, forKey: .versionName)
    }
}
///  funtionApi
public class FuntionApi:NSObject,Codable{
    /// 接口ID
    var apiId:String?
    /// 分组ID
    var apiGroupId:String?
    /// 分组名称
    var groupName:String?
    /// 修订版本号
    var revision:String?
    /// API名称
    var apiName:String?
    /// 请求方式
    var action:String?
    /// 请求路径，同时发布多个环境后会有多个路径
    var path:[String?]?
    /// API描述
    var descriptionValue:String?
    /// 部署状态(1:已部署)
    var deploymentStatus:Int?



    public override init(){
            super.init()
    }

    enum FuntionApiCodingKeys: String, CodingKey {
        case apiId
        case apiGroupId
        case groupName
        case revision
        case apiName
        case action
        case path
        case descriptionValue = "description"
        case deploymentStatus
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: FuntionApiCodingKeys.self)
        if decoderContainer.contains(.apiId)
        {
            self.apiId = try decoderContainer.decode(String?.self, forKey: .apiId)
        }
        if decoderContainer.contains(.apiGroupId)
        {
            self.apiGroupId = try decoderContainer.decode(String?.self, forKey: .apiGroupId)
        }
        if decoderContainer.contains(.groupName)
        {
            self.groupName = try decoderContainer.decode(String?.self, forKey: .groupName)
        }
        if decoderContainer.contains(.revision)
        {
            self.revision = try decoderContainer.decode(String?.self, forKey: .revision)
        }
        if decoderContainer.contains(.apiName)
        {
            self.apiName = try decoderContainer.decode(String?.self, forKey: .apiName)
        }
        if decoderContainer.contains(.action)
        {
            self.action = try decoderContainer.decode(String?.self, forKey: .action)
        }
        if decoderContainer.contains(.path)
        {
            self.path = try decoderContainer.decode([String?]?.self, forKey: .path)
        }
        if decoderContainer.contains(.descriptionValue)
        {
            self.descriptionValue = try decoderContainer.decode(String?.self, forKey: .descriptionValue)
        }
        if decoderContainer.contains(.deploymentStatus)
        {
            self.deploymentStatus = try decoderContainer.decode(Int?.self, forKey: .deploymentStatus)
        }
    }
}
public extension FuntionApi{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: FuntionApiCodingKeys.self)
         try encoderContainer.encode(apiId, forKey: .apiId)
         try encoderContainer.encode(apiGroupId, forKey: .apiGroupId)
         try encoderContainer.encode(groupName, forKey: .groupName)
         try encoderContainer.encode(revision, forKey: .revision)
         try encoderContainer.encode(apiName, forKey: .apiName)
         try encoderContainer.encode(action, forKey: .action)
         try encoderContainer.encode(path, forKey: .path)
         try encoderContainer.encode(descriptionValue, forKey: .descriptionValue)
         try encoderContainer.encode(deploymentStatus, forKey: .deploymentStatus)
    }
}
///  rateLimitPolicyView
public class RateLimitPolicyView:NSObject,Codable{
    /// 策略名称
    var policyName:String?
    /// 时间单位
    var timeUnit:String?
    /// api流量限制次数
    var apiLimitCount:Int?
    /// 用户流量限制次数
    var userLimitCount:Int?
    /// 应用流量限制次数
    var appLimitCount:Int?
    /// 描述
    var descriptionValue:String?



    public override init(){
            super.init()
    }

    enum RateLimitPolicyViewCodingKeys: String, CodingKey {
        case policyName
        case timeUnit
        case apiLimitCount
        case userLimitCount
        case appLimitCount
        case descriptionValue = "description"
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: RateLimitPolicyViewCodingKeys.self)
        if decoderContainer.contains(.policyName)
        {
            self.policyName = try decoderContainer.decode(String?.self, forKey: .policyName)
        }
        if decoderContainer.contains(.timeUnit)
        {
            self.timeUnit = try decoderContainer.decode(String?.self, forKey: .timeUnit)
        }
        if decoderContainer.contains(.apiLimitCount)
        {
            self.apiLimitCount = try decoderContainer.decode(Int?.self, forKey: .apiLimitCount)
        }
        if decoderContainer.contains(.userLimitCount)
        {
            self.userLimitCount = try decoderContainer.decode(Int?.self, forKey: .userLimitCount)
        }
        if decoderContainer.contains(.appLimitCount)
        {
            self.appLimitCount = try decoderContainer.decode(Int?.self, forKey: .appLimitCount)
        }
        if decoderContainer.contains(.descriptionValue)
        {
            self.descriptionValue = try decoderContainer.decode(String?.self, forKey: .descriptionValue)
        }
    }
}
public extension RateLimitPolicyView{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: RateLimitPolicyViewCodingKeys.self)
         try encoderContainer.encode(policyName, forKey: .policyName)
         try encoderContainer.encode(timeUnit, forKey: .timeUnit)
         try encoderContainer.encode(apiLimitCount, forKey: .apiLimitCount)
         try encoderContainer.encode(userLimitCount, forKey: .userLimitCount)
         try encoderContainer.encode(appLimitCount, forKey: .appLimitCount)
         try encoderContainer.encode(descriptionValue, forKey: .descriptionValue)
    }
}
///  bindGroups
public class BindGroups:NSObject,Codable{
    /// 部署ID
    var deploymentId:String?
    /// 分组名称
    var groupName:String?
    /// 环境：test、preview、online
    var environment:String?



    public override init(){
            super.init()
    }

    enum BindGroupsCodingKeys: String, CodingKey {
        case deploymentId
        case groupName
        case environment
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: BindGroupsCodingKeys.self)
        if decoderContainer.contains(.deploymentId)
        {
            self.deploymentId = try decoderContainer.decode(String?.self, forKey: .deploymentId)
        }
        if decoderContainer.contains(.groupName)
        {
            self.groupName = try decoderContainer.decode(String?.self, forKey: .groupName)
        }
        if decoderContainer.contains(.environment)
        {
            self.environment = try decoderContainer.decode(String?.self, forKey: .environment)
        }
    }
}
public extension BindGroups{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: BindGroupsCodingKeys.self)
         try encoderContainer.encode(deploymentId, forKey: .deploymentId)
         try encoderContainer.encode(groupName, forKey: .groupName)
         try encoderContainer.encode(environment, forKey: .environment)
    }
}
///  rateLimitPolicy
public class RateLimitPolicy:NSObject,Codable{
    /// 策略id
    var policyId:String?
    /// 策略名称
    var policyName:String?
    /// 时间单位
    var timeUnit:String?
    /// api流量限制次数
    var apiLimitCount:Int?
    /// 用户流量限制次数
    var userLimitCount:Int?
    /// 应用流量限制次数
    var appLimitCount:Int?
    /// 用户ID
    var userId:String?
    /// 用户名
    var pin:String?
    /// 描述
    var descriptionValue:String?
    /// 绑定分组，以逗号隔开的分组id存储，以逗号隔开的分组name返回
    var bindGroups:String?



    public override init(){
            super.init()
    }

    enum RateLimitPolicyCodingKeys: String, CodingKey {
        case policyId
        case policyName
        case timeUnit
        case apiLimitCount
        case userLimitCount
        case appLimitCount
        case userId
        case pin
        case descriptionValue = "description"
        case bindGroups
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: RateLimitPolicyCodingKeys.self)
        if decoderContainer.contains(.policyId)
        {
            self.policyId = try decoderContainer.decode(String?.self, forKey: .policyId)
        }
        if decoderContainer.contains(.policyName)
        {
            self.policyName = try decoderContainer.decode(String?.self, forKey: .policyName)
        }
        if decoderContainer.contains(.timeUnit)
        {
            self.timeUnit = try decoderContainer.decode(String?.self, forKey: .timeUnit)
        }
        if decoderContainer.contains(.apiLimitCount)
        {
            self.apiLimitCount = try decoderContainer.decode(Int?.self, forKey: .apiLimitCount)
        }
        if decoderContainer.contains(.userLimitCount)
        {
            self.userLimitCount = try decoderContainer.decode(Int?.self, forKey: .userLimitCount)
        }
        if decoderContainer.contains(.appLimitCount)
        {
            self.appLimitCount = try decoderContainer.decode(Int?.self, forKey: .appLimitCount)
        }
        if decoderContainer.contains(.userId)
        {
            self.userId = try decoderContainer.decode(String?.self, forKey: .userId)
        }
        if decoderContainer.contains(.pin)
        {
            self.pin = try decoderContainer.decode(String?.self, forKey: .pin)
        }
        if decoderContainer.contains(.descriptionValue)
        {
            self.descriptionValue = try decoderContainer.decode(String?.self, forKey: .descriptionValue)
        }
        if decoderContainer.contains(.bindGroups)
        {
            self.bindGroups = try decoderContainer.decode(String?.self, forKey: .bindGroups)
        }
    }
}
public extension RateLimitPolicy{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: RateLimitPolicyCodingKeys.self)
         try encoderContainer.encode(policyId, forKey: .policyId)
         try encoderContainer.encode(policyName, forKey: .policyName)
         try encoderContainer.encode(timeUnit, forKey: .timeUnit)
         try encoderContainer.encode(apiLimitCount, forKey: .apiLimitCount)
         try encoderContainer.encode(userLimitCount, forKey: .userLimitCount)
         try encoderContainer.encode(appLimitCount, forKey: .appLimitCount)
         try encoderContainer.encode(userId, forKey: .userId)
         try encoderContainer.encode(pin, forKey: .pin)
         try encoderContainer.encode(descriptionValue, forKey: .descriptionValue)
         try encoderContainer.encode(bindGroups, forKey: .bindGroups)
    }
}
///  simpleParameter
public class SimpleParameter:NSObject,Codable{
    /// 名称
    var name:String?
    /// 值
    var value:String?



    public override init(){
            super.init()
    }

    enum SimpleParameterCodingKeys: String, CodingKey {
        case name
        case value
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: SimpleParameterCodingKeys.self)
        if decoderContainer.contains(.name)
        {
            self.name = try decoderContainer.decode(String?.self, forKey: .name)
        }
        if decoderContainer.contains(.value)
        {
            self.value = try decoderContainer.decode(String?.self, forKey: .value)
        }
    }
}
public extension SimpleParameter{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: SimpleParameterCodingKeys.self)
         try encoderContainer.encode(name, forKey: .name)
         try encoderContainer.encode(value, forKey: .value)
    }
}
///  backendConfig
public class BackendConfig:NSObject,Codable{
    /// 接口ID
    var backendConfigId:String?
    /// 分组ID
    var baseGroupId:String?
    /// 环境：test、preview、online
    /// Required:true
    var environment:String
    /// 后端地址
    var backendUrl:String?
    /// 后端服务类型：mock、HTTP/HTTPS
    /// Required:true
    var backendServiceType:String
    /// header参数列表
    var headerParams:[SimpleParameter?]?
    /// query参数列表
    var queryParams:[SimpleParameter?]?
    /// 描述
    var descriptionValue:String?
    /// 发布日期，格式为毫秒级时间戳
    var createTime:Int64?
    /// 排序，赋值0时为默认的后端配置
    /// Required:true
    var sort:Int32
    /// 排序，用于展示使用
    var userSort:Int32?
    /// vpc网关id
    var jdsfId:String?
    /// vpc后端地址
    var jdsfParam:String?
    /// vpc网关所属region
    var jdsfRegion:String?
    /// vpc网关创建者的pin
    var jdsfPin:String?



    public  init(environment:String,backendServiceType:String,sort:Int32){
             self.environment = environment
             self.backendServiceType = backendServiceType
             self.sort = sort
    }

    enum BackendConfigCodingKeys: String, CodingKey {
        case backendConfigId
        case baseGroupId
        case environment
        case backendUrl
        case backendServiceType
        case headerParams
        case queryParams
        case descriptionValue = "description"
        case createTime
        case sort
        case userSort
        case jdsfId
        case jdsfParam
        case jdsfRegion
        case jdsfPin
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: BackendConfigCodingKeys.self)
        if decoderContainer.contains(.backendConfigId)
        {
            self.backendConfigId = try decoderContainer.decode(String?.self, forKey: .backendConfigId)
        }
        if decoderContainer.contains(.baseGroupId)
        {
            self.baseGroupId = try decoderContainer.decode(String?.self, forKey: .baseGroupId)
        }
        self.environment = try decoderContainer.decode(String.self, forKey: .environment)
        if decoderContainer.contains(.backendUrl)
        {
            self.backendUrl = try decoderContainer.decode(String?.self, forKey: .backendUrl)
        }
        self.backendServiceType = try decoderContainer.decode(String.self, forKey: .backendServiceType)
        if decoderContainer.contains(.headerParams)
        {
            self.headerParams = try decoderContainer.decode([SimpleParameter?]?.self, forKey: .headerParams)
        }
        if decoderContainer.contains(.queryParams)
        {
            self.queryParams = try decoderContainer.decode([SimpleParameter?]?.self, forKey: .queryParams)
        }
        if decoderContainer.contains(.descriptionValue)
        {
            self.descriptionValue = try decoderContainer.decode(String?.self, forKey: .descriptionValue)
        }
        if decoderContainer.contains(.createTime)
        {
            self.createTime = try decoderContainer.decode(Int64?.self, forKey: .createTime)
        }
        self.sort = try decoderContainer.decode(Int32.self, forKey: .sort)
        if decoderContainer.contains(.userSort)
        {
            self.userSort = try decoderContainer.decode(Int32?.self, forKey: .userSort)
        }
        if decoderContainer.contains(.jdsfId)
        {
            self.jdsfId = try decoderContainer.decode(String?.self, forKey: .jdsfId)
        }
        if decoderContainer.contains(.jdsfParam)
        {
            self.jdsfParam = try decoderContainer.decode(String?.self, forKey: .jdsfParam)
        }
        if decoderContainer.contains(.jdsfRegion)
        {
            self.jdsfRegion = try decoderContainer.decode(String?.self, forKey: .jdsfRegion)
        }
        if decoderContainer.contains(.jdsfPin)
        {
            self.jdsfPin = try decoderContainer.decode(String?.self, forKey: .jdsfPin)
        }
    }
}
public extension BackendConfig{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: BackendConfigCodingKeys.self)
         try encoderContainer.encode(backendConfigId, forKey: .backendConfigId)
         try encoderContainer.encode(baseGroupId, forKey: .baseGroupId)
         try encoderContainer.encode(environment, forKey: .environment)
         try encoderContainer.encode(backendUrl, forKey: .backendUrl)
         try encoderContainer.encode(backendServiceType, forKey: .backendServiceType)
         try encoderContainer.encode(headerParams, forKey: .headerParams)
         try encoderContainer.encode(queryParams, forKey: .queryParams)
         try encoderContainer.encode(descriptionValue, forKey: .descriptionValue)
         try encoderContainer.encode(createTime, forKey: .createTime)
         try encoderContainer.encode(sort, forKey: .sort)
         try encoderContainer.encode(userSort, forKey: .userSort)
         try encoderContainer.encode(jdsfId, forKey: .jdsfId)
         try encoderContainer.encode(jdsfParam, forKey: .jdsfParam)
         try encoderContainer.encode(jdsfRegion, forKey: .jdsfRegion)
         try encoderContainer.encode(jdsfPin, forKey: .jdsfPin)
    }
}
///  updatebackendConfig
public class UpdatebackendConfig:NSObject,Codable{
    /// 分组ID
    var baseGroupId:String?
    /// 环境：test、preview、online
    /// Required:true
    var environment:String
    /// 后端地址
    var backendUrl:String?
    /// 后端服务类型：mock、HTTP/HTTPS
    /// Required:true
    var backendServiceType:String
    /// header参数列表
    var headerParams:[SimpleParameter?]?
    /// query参数列表
    var queryParams:[SimpleParameter?]?
    /// 描述
    var descriptionValue:String?
    /// 发布日期，格式为毫秒级时间戳
    var createTime:Int64?
    /// 排序，赋值0时为默认的后端配置
    /// Required:true
    var sort:Int32
    /// 排序，用于展示使用
    var userSort:Int32?
    /// vpc网关id
    var jdsfId:String?
    /// vpc后端地址
    var jdsfParam:String?
    /// vpc网关所属region
    var jdsfRegion:String?
    /// vpc网关创建者的pin
    var jdsfPin:String?



    public  init(environment:String,backendServiceType:String,sort:Int32){
             self.environment = environment
             self.backendServiceType = backendServiceType
             self.sort = sort
    }

    enum UpdatebackendConfigCodingKeys: String, CodingKey {
        case baseGroupId
        case environment
        case backendUrl
        case backendServiceType
        case headerParams
        case queryParams
        case descriptionValue = "description"
        case createTime
        case sort
        case userSort
        case jdsfId
        case jdsfParam
        case jdsfRegion
        case jdsfPin
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: UpdatebackendConfigCodingKeys.self)
        if decoderContainer.contains(.baseGroupId)
        {
            self.baseGroupId = try decoderContainer.decode(String?.self, forKey: .baseGroupId)
        }
        self.environment = try decoderContainer.decode(String.self, forKey: .environment)
        if decoderContainer.contains(.backendUrl)
        {
            self.backendUrl = try decoderContainer.decode(String?.self, forKey: .backendUrl)
        }
        self.backendServiceType = try decoderContainer.decode(String.self, forKey: .backendServiceType)
        if decoderContainer.contains(.headerParams)
        {
            self.headerParams = try decoderContainer.decode([SimpleParameter?]?.self, forKey: .headerParams)
        }
        if decoderContainer.contains(.queryParams)
        {
            self.queryParams = try decoderContainer.decode([SimpleParameter?]?.self, forKey: .queryParams)
        }
        if decoderContainer.contains(.descriptionValue)
        {
            self.descriptionValue = try decoderContainer.decode(String?.self, forKey: .descriptionValue)
        }
        if decoderContainer.contains(.createTime)
        {
            self.createTime = try decoderContainer.decode(Int64?.self, forKey: .createTime)
        }
        self.sort = try decoderContainer.decode(Int32.self, forKey: .sort)
        if decoderContainer.contains(.userSort)
        {
            self.userSort = try decoderContainer.decode(Int32?.self, forKey: .userSort)
        }
        if decoderContainer.contains(.jdsfId)
        {
            self.jdsfId = try decoderContainer.decode(String?.self, forKey: .jdsfId)
        }
        if decoderContainer.contains(.jdsfParam)
        {
            self.jdsfParam = try decoderContainer.decode(String?.self, forKey: .jdsfParam)
        }
        if decoderContainer.contains(.jdsfRegion)
        {
            self.jdsfRegion = try decoderContainer.decode(String?.self, forKey: .jdsfRegion)
        }
        if decoderContainer.contains(.jdsfPin)
        {
            self.jdsfPin = try decoderContainer.decode(String?.self, forKey: .jdsfPin)
        }
    }
}
public extension UpdatebackendConfig{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: UpdatebackendConfigCodingKeys.self)
         try encoderContainer.encode(baseGroupId, forKey: .baseGroupId)
         try encoderContainer.encode(environment, forKey: .environment)
         try encoderContainer.encode(backendUrl, forKey: .backendUrl)
         try encoderContainer.encode(backendServiceType, forKey: .backendServiceType)
         try encoderContainer.encode(headerParams, forKey: .headerParams)
         try encoderContainer.encode(queryParams, forKey: .queryParams)
         try encoderContainer.encode(descriptionValue, forKey: .descriptionValue)
         try encoderContainer.encode(createTime, forKey: .createTime)
         try encoderContainer.encode(sort, forKey: .sort)
         try encoderContainer.encode(userSort, forKey: .userSort)
         try encoderContainer.encode(jdsfId, forKey: .jdsfId)
         try encoderContainer.encode(jdsfParam, forKey: .jdsfParam)
         try encoderContainer.encode(jdsfRegion, forKey: .jdsfRegion)
         try encoderContainer.encode(jdsfPin, forKey: .jdsfPin)
    }
}
///  修订版本列表
public class RevisionList:NSObject,Codable{
    /// 版本Id
    var revisionId:String?
    /// 修订版本号
    var revision:String?
    /// 基于此版本
    var baseRevision:String?
    /// 发布环境
    var environment:String?
    /// 修订日期
    var createdAt:String?
    /// 修订备注
    var revisionNote:String?



    public override init(){
            super.init()
    }

    enum RevisionListCodingKeys: String, CodingKey {
        case revisionId
        case revision
        case baseRevision
        case environment
        case createdAt
        case revisionNote
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: RevisionListCodingKeys.self)
        if decoderContainer.contains(.revisionId)
        {
            self.revisionId = try decoderContainer.decode(String?.self, forKey: .revisionId)
        }
        if decoderContainer.contains(.revision)
        {
            self.revision = try decoderContainer.decode(String?.self, forKey: .revision)
        }
        if decoderContainer.contains(.baseRevision)
        {
            self.baseRevision = try decoderContainer.decode(String?.self, forKey: .baseRevision)
        }
        if decoderContainer.contains(.environment)
        {
            self.environment = try decoderContainer.decode(String?.self, forKey: .environment)
        }
        if decoderContainer.contains(.createdAt)
        {
            self.createdAt = try decoderContainer.decode(String?.self, forKey: .createdAt)
        }
        if decoderContainer.contains(.revisionNote)
        {
            self.revisionNote = try decoderContainer.decode(String?.self, forKey: .revisionNote)
        }
    }
}
public extension RevisionList{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: RevisionListCodingKeys.self)
         try encoderContainer.encode(revisionId, forKey: .revisionId)
         try encoderContainer.encode(revision, forKey: .revision)
         try encoderContainer.encode(baseRevision, forKey: .baseRevision)
         try encoderContainer.encode(environment, forKey: .environment)
         try encoderContainer.encode(createdAt, forKey: .createdAt)
         try encoderContainer.encode(revisionNote, forKey: .revisionNote)
    }
}
///  修订版本
public class UpdateRevision:NSObject,Codable{
    /// 修订备注
    var revisionNote:String?



    public override init(){
            super.init()
    }

    enum UpdateRevisionCodingKeys: String, CodingKey {
        case revisionNote
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: UpdateRevisionCodingKeys.self)
        if decoderContainer.contains(.revisionNote)
        {
            self.revisionNote = try decoderContainer.decode(String?.self, forKey: .revisionNote)
        }
    }
}
public extension UpdateRevision{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: UpdateRevisionCodingKeys.self)
         try encoderContainer.encode(revisionNote, forKey: .revisionNote)
    }
}
///  创建修订版本
public class CreateRevision:NSObject,Codable{
    /// 修订版本号，如果创建版本时传回修订版本，此为必填项
    var revision:String?
    /// 基于此版本，如果创建版本时传回修订版本，此为必填项
    var baseRevision:String?
    /// 修订备注
    var revisionNote:String?



    public override init(){
            super.init()
    }

    enum CreateRevisionCodingKeys: String, CodingKey {
        case revision
        case baseRevision
        case revisionNote
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: CreateRevisionCodingKeys.self)
        if decoderContainer.contains(.revision)
        {
            self.revision = try decoderContainer.decode(String?.self, forKey: .revision)
        }
        if decoderContainer.contains(.baseRevision)
        {
            self.baseRevision = try decoderContainer.decode(String?.self, forKey: .baseRevision)
        }
        if decoderContainer.contains(.revisionNote)
        {
            self.revisionNote = try decoderContainer.decode(String?.self, forKey: .revisionNote)
        }
    }
}
public extension CreateRevision{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: CreateRevisionCodingKeys.self)
         try encoderContainer.encode(revision, forKey: .revision)
         try encoderContainer.encode(baseRevision, forKey: .baseRevision)
         try encoderContainer.encode(revisionNote, forKey: .revisionNote)
    }
}
///  ucAccessKey
public class UcAccessKey:NSObject,Codable{
    /// 密钥转态
    var accessKeyStatus:String?
    /// Access Key
    var accessKey:String?



    public override init(){
            super.init()
    }

    enum UcAccessKeyCodingKeys: String, CodingKey {
        case accessKeyStatus
        case accessKey
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: UcAccessKeyCodingKeys.self)
        if decoderContainer.contains(.accessKeyStatus)
        {
            self.accessKeyStatus = try decoderContainer.decode(String?.self, forKey: .accessKeyStatus)
        }
        if decoderContainer.contains(.accessKey)
        {
            self.accessKey = try decoderContainer.decode(String?.self, forKey: .accessKey)
        }
    }
}
public extension UcAccessKey{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: UcAccessKeyCodingKeys.self)
         try encoderContainer.encode(accessKeyStatus, forKey: .accessKeyStatus)
         try encoderContainer.encode(accessKey, forKey: .accessKey)
    }
}
///  formula
public class Formula:NSObject,Codable{
    /// key
    /// Required:true
    var key:String
    /// value
    /// Required:true
    var value:String
    /// 单位
    var unit:String?



    public  init(key:String,value:String){
             self.key = key
             self.value = value
    }

    enum FormulaCodingKeys: String, CodingKey {
        case key
        case value
        case unit
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: FormulaCodingKeys.self)
        self.key = try decoderContainer.decode(String.self, forKey: .key)
        self.value = try decoderContainer.decode(String.self, forKey: .value)
        if decoderContainer.contains(.unit)
        {
            self.unit = try decoderContainer.decode(String?.self, forKey: .unit)
        }
    }
}
public extension Formula{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: FormulaCodingKeys.self)
         try encoderContainer.encode(key, forKey: .key)
         try encoderContainer.encode(value, forKey: .value)
         try encoderContainer.encode(unit, forKey: .unit)
    }
}
///  apiChargeSpec
public class ApiChargeSpec:NSObject,Codable{
    /// API ID
    /// Required:true
    var apiId:String
    /// 计费项
    var formulas:[Formula?]?



    public  init(apiId:String){
             self.apiId = apiId
    }

    enum ApiChargeSpecCodingKeys: String, CodingKey {
        case apiId
        case formulas
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: ApiChargeSpecCodingKeys.self)
        self.apiId = try decoderContainer.decode(String.self, forKey: .apiId)
        if decoderContainer.contains(.formulas)
        {
            self.formulas = try decoderContainer.decode([Formula?]?.self, forKey: .formulas)
        }
    }
}
public extension ApiChargeSpec{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: ApiChargeSpecCodingKeys.self)
         try encoderContainer.encode(apiId, forKey: .apiId)
         try encoderContainer.encode(formulas, forKey: .formulas)
    }
}
///  chargeAuth
public class ChargeAuth:NSObject,Codable{
    /// 用户pin
    /// Required:true
    var userPin:String
    /// 资源的uuid
    /// Required:true
    var resourceId:String



    public  init(userPin:String,resourceId:String){
             self.userPin = userPin
             self.resourceId = resourceId
    }

    enum ChargeAuthCodingKeys: String, CodingKey {
        case userPin
        case resourceId
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: ChargeAuthCodingKeys.self)
        self.userPin = try decoderContainer.decode(String.self, forKey: .userPin)
        self.resourceId = try decoderContainer.decode(String.self, forKey: .resourceId)
    }
}
public extension ChargeAuth{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: ChargeAuthCodingKeys.self)
         try encoderContainer.encode(userPin, forKey: .userPin)
         try encoderContainer.encode(resourceId, forKey: .resourceId)
    }
}
///  apiChargeSpecView
public class ApiChargeSpecView:NSObject,Codable{
    /// appCode
    var appCode:String?
    /// serviceCode
    var serviceCode:String?
    /// api中心展示，1展示，0 不展示 默认不展示
    var showStatus:Int?
    /// 计费类型 0 标准计费 1 阶梯计费
    var chargeType:Int?
    /// 计费方式 0 200请求计费 1 后端处理计费
    var accessSuccessType:Int?
    /// 请求参数列表
    /// Required:true
    var apiChargeSpecs:[ApiChargeSpec?]?



    public  init(apiChargeSpecs:[ApiChargeSpec?]?){
             self.apiChargeSpecs = apiChargeSpecs
    }

    enum ApiChargeSpecViewCodingKeys: String, CodingKey {
        case appCode
        case serviceCode
        case showStatus
        case chargeType
        case accessSuccessType
        case apiChargeSpecs
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: ApiChargeSpecViewCodingKeys.self)
        if decoderContainer.contains(.appCode)
        {
            self.appCode = try decoderContainer.decode(String?.self, forKey: .appCode)
        }
        if decoderContainer.contains(.serviceCode)
        {
            self.serviceCode = try decoderContainer.decode(String?.self, forKey: .serviceCode)
        }
        if decoderContainer.contains(.showStatus)
        {
            self.showStatus = try decoderContainer.decode(Int?.self, forKey: .showStatus)
        }
        if decoderContainer.contains(.chargeType)
        {
            self.chargeType = try decoderContainer.decode(Int?.self, forKey: .chargeType)
        }
        if decoderContainer.contains(.accessSuccessType)
        {
            self.accessSuccessType = try decoderContainer.decode(Int?.self, forKey: .accessSuccessType)
        }
        self.apiChargeSpecs = try decoderContainer.decode([ApiChargeSpec?]?.self, forKey: .apiChargeSpecs)
    }
}
public extension ApiChargeSpecView{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: ApiChargeSpecViewCodingKeys.self)
         try encoderContainer.encode(appCode, forKey: .appCode)
         try encoderContainer.encode(serviceCode, forKey: .serviceCode)
         try encoderContainer.encode(showStatus, forKey: .showStatus)
         try encoderContainer.encode(chargeType, forKey: .chargeType)
         try encoderContainer.encode(accessSuccessType, forKey: .accessSuccessType)
         try encoderContainer.encode(apiChargeSpecs, forKey: .apiChargeSpecs)
    }
}
///  keyInfo
public class KeyInfo:NSObject,Codable{
    /// userid
    var userId:String?
    /// keyid
    var keyId:String?
    /// keyname
    var keyName:String?
    /// ak
    var accessKey:String?
    /// sk
    var secretKey:String?
    /// key描述信息
    var keyDesc:String?
    /// 创建时间
    var createTime:String?



    public override init(){
            super.init()
    }

    enum KeyInfoCodingKeys: String, CodingKey {
        case userId
        case keyId
        case keyName
        case accessKey
        case secretKey
        case keyDesc
        case createTime
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: KeyInfoCodingKeys.self)
        if decoderContainer.contains(.userId)
        {
            self.userId = try decoderContainer.decode(String?.self, forKey: .userId)
        }
        if decoderContainer.contains(.keyId)
        {
            self.keyId = try decoderContainer.decode(String?.self, forKey: .keyId)
        }
        if decoderContainer.contains(.keyName)
        {
            self.keyName = try decoderContainer.decode(String?.self, forKey: .keyName)
        }
        if decoderContainer.contains(.accessKey)
        {
            self.accessKey = try decoderContainer.decode(String?.self, forKey: .accessKey)
        }
        if decoderContainer.contains(.secretKey)
        {
            self.secretKey = try decoderContainer.decode(String?.self, forKey: .secretKey)
        }
        if decoderContainer.contains(.keyDesc)
        {
            self.keyDesc = try decoderContainer.decode(String?.self, forKey: .keyDesc)
        }
        if decoderContainer.contains(.createTime)
        {
            self.createTime = try decoderContainer.decode(String?.self, forKey: .createTime)
        }
    }
}
public extension KeyInfo{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: KeyInfoCodingKeys.self)
         try encoderContainer.encode(userId, forKey: .userId)
         try encoderContainer.encode(keyId, forKey: .keyId)
         try encoderContainer.encode(keyName, forKey: .keyName)
         try encoderContainer.encode(accessKey, forKey: .accessKey)
         try encoderContainer.encode(secretKey, forKey: .secretKey)
         try encoderContainer.encode(keyDesc, forKey: .keyDesc)
         try encoderContainer.encode(createTime, forKey: .createTime)
    }
}
///  API分组
public class BindApiGroup:NSObject,Codable{
    /// 分组ID
    var apiGroupId:String?
    /// 名称
    var groupName:String?
    /// 描述
    var descriptionValue:String?
    /// 分组路径前缀
    var prefix:String?
    /// 版本号
    var version:String?
    /// 区域
    var regionId:String?
    /// 域名
    var domain:String?
    /// 网关绑定分组的环境信息
    var environment:String?
    /// 密钥验证方式：check_exist（密钥必须在访问授权中已配置）、no_check_exist（无需事先配置）
    var keyCheck:String?
    /// 访问授权方式：None（免鉴权）、jd_cloud（开启访问授权，且必须使用京东云的AK、SK验签）、hufu（虎符用户）
    var authType:String?
    /// 是否转发分组路径到后端服务：0（不转发）、1（转发）
    var prefixStrip:Int?
    /// 分组类型：api_group（api分组）、jdsf_group（微服务分组）
    var groupType:String?
    /// 微服务网关名称
    var jdsfName:String?
    /// 微服务注册中心ID
    var jdsfRegistryName:String?
    /// 微服务网关ID
    var jdsfId:String?
    /// 分组是否已发布：0（未发布）、1（发布）
    var deploy:Int?



    public override init(){
            super.init()
    }

    enum BindApiGroupCodingKeys: String, CodingKey {
        case apiGroupId
        case groupName
        case descriptionValue = "description"
        case prefix
        case version
        case regionId
        case domain
        case environment
        case keyCheck
        case authType
        case prefixStrip
        case groupType
        case jdsfName
        case jdsfRegistryName
        case jdsfId
        case deploy
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: BindApiGroupCodingKeys.self)
        if decoderContainer.contains(.apiGroupId)
        {
            self.apiGroupId = try decoderContainer.decode(String?.self, forKey: .apiGroupId)
        }
        if decoderContainer.contains(.groupName)
        {
            self.groupName = try decoderContainer.decode(String?.self, forKey: .groupName)
        }
        if decoderContainer.contains(.descriptionValue)
        {
            self.descriptionValue = try decoderContainer.decode(String?.self, forKey: .descriptionValue)
        }
        if decoderContainer.contains(.prefix)
        {
            self.prefix = try decoderContainer.decode(String?.self, forKey: .prefix)
        }
        if decoderContainer.contains(.version)
        {
            self.version = try decoderContainer.decode(String?.self, forKey: .version)
        }
        if decoderContainer.contains(.regionId)
        {
            self.regionId = try decoderContainer.decode(String?.self, forKey: .regionId)
        }
        if decoderContainer.contains(.domain)
        {
            self.domain = try decoderContainer.decode(String?.self, forKey: .domain)
        }
        if decoderContainer.contains(.environment)
        {
            self.environment = try decoderContainer.decode(String?.self, forKey: .environment)
        }
        if decoderContainer.contains(.keyCheck)
        {
            self.keyCheck = try decoderContainer.decode(String?.self, forKey: .keyCheck)
        }
        if decoderContainer.contains(.authType)
        {
            self.authType = try decoderContainer.decode(String?.self, forKey: .authType)
        }
        if decoderContainer.contains(.prefixStrip)
        {
            self.prefixStrip = try decoderContainer.decode(Int?.self, forKey: .prefixStrip)
        }
        if decoderContainer.contains(.groupType)
        {
            self.groupType = try decoderContainer.decode(String?.self, forKey: .groupType)
        }
        if decoderContainer.contains(.jdsfName)
        {
            self.jdsfName = try decoderContainer.decode(String?.self, forKey: .jdsfName)
        }
        if decoderContainer.contains(.jdsfRegistryName)
        {
            self.jdsfRegistryName = try decoderContainer.decode(String?.self, forKey: .jdsfRegistryName)
        }
        if decoderContainer.contains(.jdsfId)
        {
            self.jdsfId = try decoderContainer.decode(String?.self, forKey: .jdsfId)
        }
        if decoderContainer.contains(.deploy)
        {
            self.deploy = try decoderContainer.decode(Int?.self, forKey: .deploy)
        }
    }
}
public extension BindApiGroup{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: BindApiGroupCodingKeys.self)
         try encoderContainer.encode(apiGroupId, forKey: .apiGroupId)
         try encoderContainer.encode(groupName, forKey: .groupName)
         try encoderContainer.encode(descriptionValue, forKey: .descriptionValue)
         try encoderContainer.encode(prefix, forKey: .prefix)
         try encoderContainer.encode(version, forKey: .version)
         try encoderContainer.encode(regionId, forKey: .regionId)
         try encoderContainer.encode(domain, forKey: .domain)
         try encoderContainer.encode(environment, forKey: .environment)
         try encoderContainer.encode(keyCheck, forKey: .keyCheck)
         try encoderContainer.encode(authType, forKey: .authType)
         try encoderContainer.encode(prefixStrip, forKey: .prefixStrip)
         try encoderContainer.encode(groupType, forKey: .groupType)
         try encoderContainer.encode(jdsfName, forKey: .jdsfName)
         try encoderContainer.encode(jdsfRegistryName, forKey: .jdsfRegistryName)
         try encoderContainer.encode(jdsfId, forKey: .jdsfId)
         try encoderContainer.encode(deploy, forKey: .deploy)
    }
}
///  生成信息
public class GenerateInfo:NSObject,Codable{
    /// 语言
    var language:String?
    /// 文件状态,0:未生成，1:生成中，2:生成完成
    var fileStatus:Int?
    /// 下载地址
    var fileUrl:String?



    public override init(){
            super.init()
    }

    enum GenerateInfoCodingKeys: String, CodingKey {
        case language
        case fileStatus
        case fileUrl
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: GenerateInfoCodingKeys.self)
        if decoderContainer.contains(.language)
        {
            self.language = try decoderContainer.decode(String?.self, forKey: .language)
        }
        if decoderContainer.contains(.fileStatus)
        {
            self.fileStatus = try decoderContainer.decode(Int?.self, forKey: .fileStatus)
        }
        if decoderContainer.contains(.fileUrl)
        {
            self.fileUrl = try decoderContainer.decode(String?.self, forKey: .fileUrl)
        }
    }
}
public extension GenerateInfo{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: GenerateInfoCodingKeys.self)
         try encoderContainer.encode(language, forKey: .language)
         try encoderContainer.encode(fileStatus, forKey: .fileStatus)
         try encoderContainer.encode(fileUrl, forKey: .fileUrl)
    }
}
///  API分组
public class UpdateApiGroup:NSObject,Codable{
    /// 名称
    var groupName:String?
    /// 描述
    var descriptionValue:String?
    /// 分组路径前缀
    var prefix:String?
    /// 密钥验证方式：check_exist（密钥必须在访问授权中已配置）、no_check_exist（无需事先配置）
    var keyCheck:String?
    /// 访问授权方式：None（免鉴权）、jd_cloud（开启访问授权，且必须使用京东云的AK、SK验签）、hufu（虎符用户）
    var authType:String?
    /// 是否转发分组路径到后端服务：0（不转发）、1（转发）默认为1
    var prefixStrip:Int?
    /// 分组类型：api_group（api分组）、jdsf_group（微服务分组）默认为 api_group
    var groupType:String?
    /// 微服务网关名称
    var jdsfName:String?
    /// 微服务注册中心ID
    var jdsfRegistryName:String?
    /// 微服务网关ID
    var jdsfId:String?



    public override init(){
            super.init()
    }

    enum UpdateApiGroupCodingKeys: String, CodingKey {
        case groupName
        case descriptionValue = "description"
        case prefix
        case keyCheck
        case authType
        case prefixStrip
        case groupType
        case jdsfName
        case jdsfRegistryName
        case jdsfId
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: UpdateApiGroupCodingKeys.self)
        if decoderContainer.contains(.groupName)
        {
            self.groupName = try decoderContainer.decode(String?.self, forKey: .groupName)
        }
        if decoderContainer.contains(.descriptionValue)
        {
            self.descriptionValue = try decoderContainer.decode(String?.self, forKey: .descriptionValue)
        }
        if decoderContainer.contains(.prefix)
        {
            self.prefix = try decoderContainer.decode(String?.self, forKey: .prefix)
        }
        if decoderContainer.contains(.keyCheck)
        {
            self.keyCheck = try decoderContainer.decode(String?.self, forKey: .keyCheck)
        }
        if decoderContainer.contains(.authType)
        {
            self.authType = try decoderContainer.decode(String?.self, forKey: .authType)
        }
        if decoderContainer.contains(.prefixStrip)
        {
            self.prefixStrip = try decoderContainer.decode(Int?.self, forKey: .prefixStrip)
        }
        if decoderContainer.contains(.groupType)
        {
            self.groupType = try decoderContainer.decode(String?.self, forKey: .groupType)
        }
        if decoderContainer.contains(.jdsfName)
        {
            self.jdsfName = try decoderContainer.decode(String?.self, forKey: .jdsfName)
        }
        if decoderContainer.contains(.jdsfRegistryName)
        {
            self.jdsfRegistryName = try decoderContainer.decode(String?.self, forKey: .jdsfRegistryName)
        }
        if decoderContainer.contains(.jdsfId)
        {
            self.jdsfId = try decoderContainer.decode(String?.self, forKey: .jdsfId)
        }
    }
}
public extension UpdateApiGroup{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: UpdateApiGroupCodingKeys.self)
         try encoderContainer.encode(groupName, forKey: .groupName)
         try encoderContainer.encode(descriptionValue, forKey: .descriptionValue)
         try encoderContainer.encode(prefix, forKey: .prefix)
         try encoderContainer.encode(keyCheck, forKey: .keyCheck)
         try encoderContainer.encode(authType, forKey: .authType)
         try encoderContainer.encode(prefixStrip, forKey: .prefixStrip)
         try encoderContainer.encode(groupType, forKey: .groupType)
         try encoderContainer.encode(jdsfName, forKey: .jdsfName)
         try encoderContainer.encode(jdsfRegistryName, forKey: .jdsfRegistryName)
         try encoderContainer.encode(jdsfId, forKey: .jdsfId)
    }
}
///  提供给Tag组展示的api分组，仅包含id，region和name
public class ApiGroupEx:NSObject,Codable{
    /// 分组ID
    var apiGroupId:String?
    /// 名称
    var groupName:String?
    /// 区域
    var regionId:String?



    public override init(){
            super.init()
    }

    enum ApiGroupExCodingKeys: String, CodingKey {
        case apiGroupId
        case groupName
        case regionId
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: ApiGroupExCodingKeys.self)
        if decoderContainer.contains(.apiGroupId)
        {
            self.apiGroupId = try decoderContainer.decode(String?.self, forKey: .apiGroupId)
        }
        if decoderContainer.contains(.groupName)
        {
            self.groupName = try decoderContainer.decode(String?.self, forKey: .groupName)
        }
        if decoderContainer.contains(.regionId)
        {
            self.regionId = try decoderContainer.decode(String?.self, forKey: .regionId)
        }
    }
}
public extension ApiGroupEx{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: ApiGroupExCodingKeys.self)
         try encoderContainer.encode(apiGroupId, forKey: .apiGroupId)
         try encoderContainer.encode(groupName, forKey: .groupName)
         try encoderContainer.encode(regionId, forKey: .regionId)
    }
}
///  API分组
public class CreateApiGroup:NSObject,Codable{
    /// 名称
    /// Required:true
    var groupName:String
    /// 描述
    var descriptionValue:String?
    /// 分组路径前缀，无需添加/
    var prefix:String?
    /// 密钥验证方式：check_exist（密钥必须在访问授权中已配置）、no_check_exist（无需事先配置）
    var keyCheck:String?
    /// 访问授权方式：None（免鉴权）、jd_cloud（开启访问授权，且必须使用京东云的AK、SK验签）、hufu（虎符用户）
    /// Required:true
    var authType:String
    /// 是否转发分组路径到后端服务：0（不转发）、1（转发）默认为1
    var prefixStrip:Int?
    /// 分组类型：api_group（api分组）、jdsf_group（微服务分组）默认为 api_group
    var groupType:String?
    /// 微服务网关名称
    var jdsfName:String?
    /// 微服务注册中心ID
    var jdsfRegistryName:String?
    /// 微服务网关ID
    var jdsfId:String?



    public  init(groupName:String,authType:String){
             self.groupName = groupName
             self.authType = authType
    }

    enum CreateApiGroupCodingKeys: String, CodingKey {
        case groupName
        case descriptionValue = "description"
        case prefix
        case keyCheck
        case authType
        case prefixStrip
        case groupType
        case jdsfName
        case jdsfRegistryName
        case jdsfId
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: CreateApiGroupCodingKeys.self)
        self.groupName = try decoderContainer.decode(String.self, forKey: .groupName)
        if decoderContainer.contains(.descriptionValue)
        {
            self.descriptionValue = try decoderContainer.decode(String?.self, forKey: .descriptionValue)
        }
        if decoderContainer.contains(.prefix)
        {
            self.prefix = try decoderContainer.decode(String?.self, forKey: .prefix)
        }
        if decoderContainer.contains(.keyCheck)
        {
            self.keyCheck = try decoderContainer.decode(String?.self, forKey: .keyCheck)
        }
        self.authType = try decoderContainer.decode(String.self, forKey: .authType)
        if decoderContainer.contains(.prefixStrip)
        {
            self.prefixStrip = try decoderContainer.decode(Int?.self, forKey: .prefixStrip)
        }
        if decoderContainer.contains(.groupType)
        {
            self.groupType = try decoderContainer.decode(String?.self, forKey: .groupType)
        }
        if decoderContainer.contains(.jdsfName)
        {
            self.jdsfName = try decoderContainer.decode(String?.self, forKey: .jdsfName)
        }
        if decoderContainer.contains(.jdsfRegistryName)
        {
            self.jdsfRegistryName = try decoderContainer.decode(String?.self, forKey: .jdsfRegistryName)
        }
        if decoderContainer.contains(.jdsfId)
        {
            self.jdsfId = try decoderContainer.decode(String?.self, forKey: .jdsfId)
        }
    }
}
public extension CreateApiGroup{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: CreateApiGroupCodingKeys.self)
         try encoderContainer.encode(groupName, forKey: .groupName)
         try encoderContainer.encode(descriptionValue, forKey: .descriptionValue)
         try encoderContainer.encode(prefix, forKey: .prefix)
         try encoderContainer.encode(keyCheck, forKey: .keyCheck)
         try encoderContainer.encode(authType, forKey: .authType)
         try encoderContainer.encode(prefixStrip, forKey: .prefixStrip)
         try encoderContainer.encode(groupType, forKey: .groupType)
         try encoderContainer.encode(jdsfName, forKey: .jdsfName)
         try encoderContainer.encode(jdsfRegistryName, forKey: .jdsfRegistryName)
         try encoderContainer.encode(jdsfId, forKey: .jdsfId)
    }
}
///  API分组
public class ApiGroupMonitor:NSObject,Codable{
    /// 分组ID
    var apiGroupId:String?
    /// 分组名称
    var groupName:String?
    /// 后端服务地址
    var backendUrl:String?
    /// 分组路径
    var groupPath:String?
    /// 版本号
    var version:String?
    /// API总数
    var apiCount:String?
    /// 发布日期，格式为毫秒级时间戳
    var deploymentDate:Int64?



    public override init(){
            super.init()
    }

    enum ApiGroupMonitorCodingKeys: String, CodingKey {
        case apiGroupId
        case groupName
        case backendUrl
        case groupPath
        case version
        case apiCount
        case deploymentDate
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: ApiGroupMonitorCodingKeys.self)
        if decoderContainer.contains(.apiGroupId)
        {
            self.apiGroupId = try decoderContainer.decode(String?.self, forKey: .apiGroupId)
        }
        if decoderContainer.contains(.groupName)
        {
            self.groupName = try decoderContainer.decode(String?.self, forKey: .groupName)
        }
        if decoderContainer.contains(.backendUrl)
        {
            self.backendUrl = try decoderContainer.decode(String?.self, forKey: .backendUrl)
        }
        if decoderContainer.contains(.groupPath)
        {
            self.groupPath = try decoderContainer.decode(String?.self, forKey: .groupPath)
        }
        if decoderContainer.contains(.version)
        {
            self.version = try decoderContainer.decode(String?.self, forKey: .version)
        }
        if decoderContainer.contains(.apiCount)
        {
            self.apiCount = try decoderContainer.decode(String?.self, forKey: .apiCount)
        }
        if decoderContainer.contains(.deploymentDate)
        {
            self.deploymentDate = try decoderContainer.decode(Int64?.self, forKey: .deploymentDate)
        }
    }
}
public extension ApiGroupMonitor{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: ApiGroupMonitorCodingKeys.self)
         try encoderContainer.encode(apiGroupId, forKey: .apiGroupId)
         try encoderContainer.encode(groupName, forKey: .groupName)
         try encoderContainer.encode(backendUrl, forKey: .backendUrl)
         try encoderContainer.encode(groupPath, forKey: .groupPath)
         try encoderContainer.encode(version, forKey: .version)
         try encoderContainer.encode(apiCount, forKey: .apiCount)
         try encoderContainer.encode(deploymentDate, forKey: .deploymentDate)
    }
}
///  API分组
public class ApiGroupMonitorDetail:NSObject,Codable{
    /// 分组名称
    var groupName:String?
    /// 后端服务地址
    var backendUrl:String?
    /// 分组路径
    var groupPath:String?
    /// 版本号
    var version:String?
    /// 描述
    var descriptionValue:String?
    /// 发布日期，格式为毫秒级时间戳
    var deploymentDate:Int64?



    public override init(){
            super.init()
    }

    enum ApiGroupMonitorDetailCodingKeys: String, CodingKey {
        case groupName
        case backendUrl
        case groupPath
        case version
        case descriptionValue = "description"
        case deploymentDate
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: ApiGroupMonitorDetailCodingKeys.self)
        if decoderContainer.contains(.groupName)
        {
            self.groupName = try decoderContainer.decode(String?.self, forKey: .groupName)
        }
        if decoderContainer.contains(.backendUrl)
        {
            self.backendUrl = try decoderContainer.decode(String?.self, forKey: .backendUrl)
        }
        if decoderContainer.contains(.groupPath)
        {
            self.groupPath = try decoderContainer.decode(String?.self, forKey: .groupPath)
        }
        if decoderContainer.contains(.version)
        {
            self.version = try decoderContainer.decode(String?.self, forKey: .version)
        }
        if decoderContainer.contains(.descriptionValue)
        {
            self.descriptionValue = try decoderContainer.decode(String?.self, forKey: .descriptionValue)
        }
        if decoderContainer.contains(.deploymentDate)
        {
            self.deploymentDate = try decoderContainer.decode(Int64?.self, forKey: .deploymentDate)
        }
    }
}
public extension ApiGroupMonitorDetail{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: ApiGroupMonitorDetailCodingKeys.self)
         try encoderContainer.encode(groupName, forKey: .groupName)
         try encoderContainer.encode(backendUrl, forKey: .backendUrl)
         try encoderContainer.encode(groupPath, forKey: .groupPath)
         try encoderContainer.encode(version, forKey: .version)
         try encoderContainer.encode(descriptionValue, forKey: .descriptionValue)
         try encoderContainer.encode(deploymentDate, forKey: .deploymentDate)
    }
}
///  网关绑定的分组数量
public class ApiGroupCount:NSObject,Codable{
    /// 网关ID
    var gatewayId:String?
    /// 分组数量
    var count:Int?



    public override init(){
            super.init()
    }

    enum ApiGroupCountCodingKeys: String, CodingKey {
        case gatewayId
        case count
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: ApiGroupCountCodingKeys.self)
        if decoderContainer.contains(.gatewayId)
        {
            self.gatewayId = try decoderContainer.decode(String?.self, forKey: .gatewayId)
        }
        if decoderContainer.contains(.count)
        {
            self.count = try decoderContainer.decode(Int?.self, forKey: .count)
        }
    }
}
public extension ApiGroupCount{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: ApiGroupCountCodingKeys.self)
         try encoderContainer.encode(gatewayId, forKey: .gatewayId)
         try encoderContainer.encode(count, forKey: .count)
    }
}
///  API分组
public class BindJdsfGroup:NSObject,Codable{
    /// 微服务网关名称
    var jdsfName:String?
    /// 微服务注册中心ID
    var jdsfRegistryName:String?
    /// 环境信息
    /// Required:true
    var environment:String
    /// 微服务网关ID
    /// Required:true
    var jdsfId:String
    /// VPC类型时，传vpc对应的IP:port
    var jdsfParam:String?
    /// 微服务网关region ID
    var jdsfRegion:String?
    /// 分组类型：api_group（api分组）、jdsf_group（微服务分组）默认api_group
    var groupType:String?



    public  init(environment:String,jdsfId:String){
             self.environment = environment
             self.jdsfId = jdsfId
    }

    enum BindJdsfGroupCodingKeys: String, CodingKey {
        case jdsfName
        case jdsfRegistryName
        case environment
        case jdsfId
        case jdsfParam
        case jdsfRegion
        case groupType
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: BindJdsfGroupCodingKeys.self)
        if decoderContainer.contains(.jdsfName)
        {
            self.jdsfName = try decoderContainer.decode(String?.self, forKey: .jdsfName)
        }
        if decoderContainer.contains(.jdsfRegistryName)
        {
            self.jdsfRegistryName = try decoderContainer.decode(String?.self, forKey: .jdsfRegistryName)
        }
        self.environment = try decoderContainer.decode(String.self, forKey: .environment)
        self.jdsfId = try decoderContainer.decode(String.self, forKey: .jdsfId)
        if decoderContainer.contains(.jdsfParam)
        {
            self.jdsfParam = try decoderContainer.decode(String?.self, forKey: .jdsfParam)
        }
        if decoderContainer.contains(.jdsfRegion)
        {
            self.jdsfRegion = try decoderContainer.decode(String?.self, forKey: .jdsfRegion)
        }
        if decoderContainer.contains(.groupType)
        {
            self.groupType = try decoderContainer.decode(String?.self, forKey: .groupType)
        }
    }
}
public extension BindJdsfGroup{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: BindJdsfGroupCodingKeys.self)
         try encoderContainer.encode(jdsfName, forKey: .jdsfName)
         try encoderContainer.encode(jdsfRegistryName, forKey: .jdsfRegistryName)
         try encoderContainer.encode(environment, forKey: .environment)
         try encoderContainer.encode(jdsfId, forKey: .jdsfId)
         try encoderContainer.encode(jdsfParam, forKey: .jdsfParam)
         try encoderContainer.encode(jdsfRegion, forKey: .jdsfRegion)
         try encoderContainer.encode(groupType, forKey: .groupType)
    }
}
///  null
public class UpdateGroupVpcPathModel:NSObject,Codable{
    /// 微服务网关ID
    /// Required:true
    var jdsfGwId:String
    /// vpc内ip:port,如：192.168.1.2:8000
    /// Required:true
    var vpcPath:String



    public  init(jdsfGwId:String,vpcPath:String){
             self.jdsfGwId = jdsfGwId
             self.vpcPath = vpcPath
    }

    enum UpdateGroupVpcPathModelCodingKeys: String, CodingKey {
        case jdsfGwId
        case vpcPath
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: UpdateGroupVpcPathModelCodingKeys.self)
        self.jdsfGwId = try decoderContainer.decode(String.self, forKey: .jdsfGwId)
        self.vpcPath = try decoderContainer.decode(String.self, forKey: .vpcPath)
    }
}
public extension UpdateGroupVpcPathModel{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: UpdateGroupVpcPathModelCodingKeys.self)
         try encoderContainer.encode(jdsfGwId, forKey: .jdsfGwId)
         try encoderContainer.encode(vpcPath, forKey: .vpcPath)
    }
}
///  domainInfo
public class DomainInfo:NSObject,Codable{
    /// api分组id
    var apiGroupId:String?
    /// 域名id
    var domainId:String?
    /// 域名
    var domain:String?
    /// 解析的cname
    var cname:String?
    /// 域名使用的协议
    var protocolValue:String?
    /// 域名创建时间
    var createTime:String?
    /// 域名状态
    var status:String?



    public override init(){
            super.init()
    }

    enum DomainInfoCodingKeys: String, CodingKey {
        case apiGroupId
        case domainId
        case domain
        case cname
        case protocolValue = "protocol"
        case createTime
        case status
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: DomainInfoCodingKeys.self)
        if decoderContainer.contains(.apiGroupId)
        {
            self.apiGroupId = try decoderContainer.decode(String?.self, forKey: .apiGroupId)
        }
        if decoderContainer.contains(.domainId)
        {
            self.domainId = try decoderContainer.decode(String?.self, forKey: .domainId)
        }
        if decoderContainer.contains(.domain)
        {
            self.domain = try decoderContainer.decode(String?.self, forKey: .domain)
        }
        if decoderContainer.contains(.cname)
        {
            self.cname = try decoderContainer.decode(String?.self, forKey: .cname)
        }
        if decoderContainer.contains(.protocolValue)
        {
            self.protocolValue = try decoderContainer.decode(String?.self, forKey: .protocolValue)
        }
        if decoderContainer.contains(.createTime)
        {
            self.createTime = try decoderContainer.decode(String?.self, forKey: .createTime)
        }
        if decoderContainer.contains(.status)
        {
            self.status = try decoderContainer.decode(String?.self, forKey: .status)
        }
    }
}
public extension DomainInfo{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: DomainInfoCodingKeys.self)
         try encoderContainer.encode(apiGroupId, forKey: .apiGroupId)
         try encoderContainer.encode(domainId, forKey: .domainId)
         try encoderContainer.encode(domain, forKey: .domain)
         try encoderContainer.encode(cname, forKey: .cname)
         try encoderContainer.encode(protocolValue, forKey: .protocolValue)
         try encoderContainer.encode(createTime, forKey: .createTime)
         try encoderContainer.encode(status, forKey: .status)
    }
}
///  serviceError
public class ServiceError:NSObject,Codable{
    /// Code
    /// Required:true
    var code:Int32
    /// Details
    /// Required:true
    var details:String
    /// Message
    /// Required:true
    var message:String
    /// Status
    /// Required:true
    var status:String



    public  init(code:Int32,details:String,message:String,status:String){
             self.code = code
             self.details = details
             self.message = message
             self.status = status
    }

    enum ServiceErrorCodingKeys: String, CodingKey {
        case code
        case details
        case message
        case status
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: ServiceErrorCodingKeys.self)
        self.code = try decoderContainer.decode(Int32.self, forKey: .code)
        self.details = try decoderContainer.decode(String.self, forKey: .details)
        self.message = try decoderContainer.decode(String.self, forKey: .message)
        self.status = try decoderContainer.decode(String.self, forKey: .status)
    }
}
public extension ServiceError{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: ServiceErrorCodingKeys.self)
         try encoderContainer.encode(code, forKey: .code)
         try encoderContainer.encode(details, forKey: .details)
         try encoderContainer.encode(message, forKey: .message)
         try encoderContainer.encode(status, forKey: .status)
    }
}
///  createAccessKey
public class CreateAccessKey:NSObject,Codable{
    /// 描述
    var descriptionValue:String?
    /// 密钥类型
    var accessKeyType:String?
    /// Access Key
    var accessKey:String?



    public override init(){
            super.init()
    }

    enum CreateAccessKeyCodingKeys: String, CodingKey {
        case descriptionValue = "description"
        case accessKeyType
        case accessKey
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: CreateAccessKeyCodingKeys.self)
        if decoderContainer.contains(.descriptionValue)
        {
            self.descriptionValue = try decoderContainer.decode(String?.self, forKey: .descriptionValue)
        }
        if decoderContainer.contains(.accessKeyType)
        {
            self.accessKeyType = try decoderContainer.decode(String?.self, forKey: .accessKeyType)
        }
        if decoderContainer.contains(.accessKey)
        {
            self.accessKey = try decoderContainer.decode(String?.self, forKey: .accessKey)
        }
    }
}
public extension CreateAccessKey{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: CreateAccessKeyCodingKeys.self)
         try encoderContainer.encode(descriptionValue, forKey: .descriptionValue)
         try encoderContainer.encode(accessKeyType, forKey: .accessKeyType)
         try encoderContainer.encode(accessKey, forKey: .accessKey)
    }
}
///  accessKey
public class AccessKey:NSObject,Codable{
    /// Access Key id
    var accessKeyId:String?
    /// 描述
    var descriptionValue:String?
    /// 密钥类型
    var accessKeyType:String?
    /// Access Key
    var accessKeyValue:String?
    /// 绑定分组
    var bindGroups:[BindGroups?]?



    public override init(){
            super.init()
    }

    enum AccessKeyCodingKeys: String, CodingKey {
        case accessKeyId
        case descriptionValue = "description"
        case accessKeyType
        case accessKeyValue = "accessKey"
        case bindGroups
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: AccessKeyCodingKeys.self)
        if decoderContainer.contains(.accessKeyId)
        {
            self.accessKeyId = try decoderContainer.decode(String?.self, forKey: .accessKeyId)
        }
        if decoderContainer.contains(.descriptionValue)
        {
            self.descriptionValue = try decoderContainer.decode(String?.self, forKey: .descriptionValue)
        }
        if decoderContainer.contains(.accessKeyType)
        {
            self.accessKeyType = try decoderContainer.decode(String?.self, forKey: .accessKeyType)
        }
        if decoderContainer.contains(.accessKeyValue)
        {
            self.accessKeyValue = try decoderContainer.decode(String?.self, forKey: .accessKeyValue)
        }
        if decoderContainer.contains(.bindGroups)
        {
            self.bindGroups = try decoderContainer.decode([BindGroups?]?.self, forKey: .bindGroups)
        }
    }
}
public extension AccessKey{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: AccessKeyCodingKeys.self)
         try encoderContainer.encode(accessKeyId, forKey: .accessKeyId)
         try encoderContainer.encode(descriptionValue, forKey: .descriptionValue)
         try encoderContainer.encode(accessKeyType, forKey: .accessKeyType)
         try encoderContainer.encode(accessKeyValue, forKey: .accessKeyValue)
         try encoderContainer.encode(bindGroups, forKey: .bindGroups)
    }
}
///  accessAuth
public class AccessAuth:NSObject,Codable{
    /// 访问授权ID
    var accessAuthId:String?
    /// 授权用户类型
    var authUserType:String?
    /// Access Key
    var accessKey:String?
    /// 描述
    var descriptionValue:String?
    /// 绑定分组,用英文逗号分隔
    var bindGroups:String?
    /// api调用者的appid
    var appId:String?



    public override init(){
            super.init()
    }

    enum AccessAuthCodingKeys: String, CodingKey {
        case accessAuthId
        case authUserType
        case accessKey
        case descriptionValue = "description"
        case bindGroups
        case appId
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: AccessAuthCodingKeys.self)
        if decoderContainer.contains(.accessAuthId)
        {
            self.accessAuthId = try decoderContainer.decode(String?.self, forKey: .accessAuthId)
        }
        if decoderContainer.contains(.authUserType)
        {
            self.authUserType = try decoderContainer.decode(String?.self, forKey: .authUserType)
        }
        if decoderContainer.contains(.accessKey)
        {
            self.accessKey = try decoderContainer.decode(String?.self, forKey: .accessKey)
        }
        if decoderContainer.contains(.descriptionValue)
        {
            self.descriptionValue = try decoderContainer.decode(String?.self, forKey: .descriptionValue)
        }
        if decoderContainer.contains(.bindGroups)
        {
            self.bindGroups = try decoderContainer.decode(String?.self, forKey: .bindGroups)
        }
        if decoderContainer.contains(.appId)
        {
            self.appId = try decoderContainer.decode(String?.self, forKey: .appId)
        }
    }
}
public extension AccessAuth{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: AccessAuthCodingKeys.self)
         try encoderContainer.encode(accessAuthId, forKey: .accessAuthId)
         try encoderContainer.encode(authUserType, forKey: .authUserType)
         try encoderContainer.encode(accessKey, forKey: .accessKey)
         try encoderContainer.encode(descriptionValue, forKey: .descriptionValue)
         try encoderContainer.encode(bindGroups, forKey: .bindGroups)
         try encoderContainer.encode(appId, forKey: .appId)
    }
}
///  userBindedGroups
public class UserBindedGroups:NSObject,Codable{
    /// 分组ID
    var apiGroupId:String?
    /// 分组名称
    var groupName:String?
    /// 区域
    var region:String?
    /// 授权时间
    var authtime:String?
    /// 授权用户类型
    var authUserType:String?
    /// Access Key
    var accessKey:String?
    /// api调用者的appid
    var appId:String?
    /// api部署的环境
    var environment:String?
    /// api版本
    var revision:String?



    public override init(){
            super.init()
    }

    enum UserBindedGroupsCodingKeys: String, CodingKey {
        case apiGroupId
        case groupName
        case region
        case authtime
        case authUserType
        case accessKey
        case appId
        case environment
        case revision
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: UserBindedGroupsCodingKeys.self)
        if decoderContainer.contains(.apiGroupId)
        {
            self.apiGroupId = try decoderContainer.decode(String?.self, forKey: .apiGroupId)
        }
        if decoderContainer.contains(.groupName)
        {
            self.groupName = try decoderContainer.decode(String?.self, forKey: .groupName)
        }
        if decoderContainer.contains(.region)
        {
            self.region = try decoderContainer.decode(String?.self, forKey: .region)
        }
        if decoderContainer.contains(.authtime)
        {
            self.authtime = try decoderContainer.decode(String?.self, forKey: .authtime)
        }
        if decoderContainer.contains(.authUserType)
        {
            self.authUserType = try decoderContainer.decode(String?.self, forKey: .authUserType)
        }
        if decoderContainer.contains(.accessKey)
        {
            self.accessKey = try decoderContainer.decode(String?.self, forKey: .accessKey)
        }
        if decoderContainer.contains(.appId)
        {
            self.appId = try decoderContainer.decode(String?.self, forKey: .appId)
        }
        if decoderContainer.contains(.environment)
        {
            self.environment = try decoderContainer.decode(String?.self, forKey: .environment)
        }
        if decoderContainer.contains(.revision)
        {
            self.revision = try decoderContainer.decode(String?.self, forKey: .revision)
        }
    }
}
public extension UserBindedGroups{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: UserBindedGroupsCodingKeys.self)
         try encoderContainer.encode(apiGroupId, forKey: .apiGroupId)
         try encoderContainer.encode(groupName, forKey: .groupName)
         try encoderContainer.encode(region, forKey: .region)
         try encoderContainer.encode(authtime, forKey: .authtime)
         try encoderContainer.encode(authUserType, forKey: .authUserType)
         try encoderContainer.encode(accessKey, forKey: .accessKey)
         try encoderContainer.encode(appId, forKey: .appId)
         try encoderContainer.encode(environment, forKey: .environment)
         try encoderContainer.encode(revision, forKey: .revision)
    }
}
///  accessAuthView
public class AccessAuthView:NSObject,Codable{
    /// 授权用户类型
    var authUserType:String?
    /// Access Key
    var accessKey:String?
    /// 待绑定的部署ids逗号隔开
    var deploymentIds:String?
    /// 描述
    var descriptionValue:String?



    public override init(){
            super.init()
    }

    enum AccessAuthViewCodingKeys: String, CodingKey {
        case authUserType
        case accessKey
        case deploymentIds
        case descriptionValue = "description"
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: AccessAuthViewCodingKeys.self)
        if decoderContainer.contains(.authUserType)
        {
            self.authUserType = try decoderContainer.decode(String?.self, forKey: .authUserType)
        }
        if decoderContainer.contains(.accessKey)
        {
            self.accessKey = try decoderContainer.decode(String?.self, forKey: .accessKey)
        }
        if decoderContainer.contains(.deploymentIds)
        {
            self.deploymentIds = try decoderContainer.decode(String?.self, forKey: .deploymentIds)
        }
        if decoderContainer.contains(.descriptionValue)
        {
            self.descriptionValue = try decoderContainer.decode(String?.self, forKey: .descriptionValue)
        }
    }
}
public extension AccessAuthView{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: AccessAuthViewCodingKeys.self)
         try encoderContainer.encode(authUserType, forKey: .authUserType)
         try encoderContainer.encode(accessKey, forKey: .accessKey)
         try encoderContainer.encode(deploymentIds, forKey: .deploymentIds)
         try encoderContainer.encode(descriptionValue, forKey: .descriptionValue)
    }
}
///  createSubscriptionKey
public class CreateSubscriptionKey:NSObject,Codable{
    /// 描述
    var descriptionValue:String?
    /// 密钥名称
    var name:String?



    public override init(){
            super.init()
    }

    enum CreateSubscriptionKeyCodingKeys: String, CodingKey {
        case descriptionValue = "description"
        case name
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: CreateSubscriptionKeyCodingKeys.self)
        if decoderContainer.contains(.descriptionValue)
        {
            self.descriptionValue = try decoderContainer.decode(String?.self, forKey: .descriptionValue)
        }
        if decoderContainer.contains(.name)
        {
            self.name = try decoderContainer.decode(String?.self, forKey: .name)
        }
    }
}
public extension CreateSubscriptionKey{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: CreateSubscriptionKeyCodingKeys.self)
         try encoderContainer.encode(descriptionValue, forKey: .descriptionValue)
         try encoderContainer.encode(name, forKey: .name)
    }
}
///  subscriptionKey
public class SubscriptionKey:NSObject,Codable{
    /// subscription Key id
    var subscriptionKeyId:String?
    /// 描述
    var descriptionValue:String?
    /// subscription Key
    var subscriptionKeyValue:String?
    /// 密钥名称
    var name:String?
    /// 密钥创建时间
    var createTime:String?
    /// 绑定分组
    var bindGroups:[BindGroups?]?



    public override init(){
            super.init()
    }

    enum SubscriptionKeyCodingKeys: String, CodingKey {
        case subscriptionKeyId
        case descriptionValue = "description"
        case subscriptionKeyValue = "subscriptionKey"
        case name
        case createTime
        case bindGroups
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: SubscriptionKeyCodingKeys.self)
        if decoderContainer.contains(.subscriptionKeyId)
        {
            self.subscriptionKeyId = try decoderContainer.decode(String?.self, forKey: .subscriptionKeyId)
        }
        if decoderContainer.contains(.descriptionValue)
        {
            self.descriptionValue = try decoderContainer.decode(String?.self, forKey: .descriptionValue)
        }
        if decoderContainer.contains(.subscriptionKeyValue)
        {
            self.subscriptionKeyValue = try decoderContainer.decode(String?.self, forKey: .subscriptionKeyValue)
        }
        if decoderContainer.contains(.name)
        {
            self.name = try decoderContainer.decode(String?.self, forKey: .name)
        }
        if decoderContainer.contains(.createTime)
        {
            self.createTime = try decoderContainer.decode(String?.self, forKey: .createTime)
        }
        if decoderContainer.contains(.bindGroups)
        {
            self.bindGroups = try decoderContainer.decode([BindGroups?]?.self, forKey: .bindGroups)
        }
    }
}
public extension SubscriptionKey{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: SubscriptionKeyCodingKeys.self)
         try encoderContainer.encode(subscriptionKeyId, forKey: .subscriptionKeyId)
         try encoderContainer.encode(descriptionValue, forKey: .descriptionValue)
         try encoderContainer.encode(subscriptionKeyValue, forKey: .subscriptionKeyValue)
         try encoderContainer.encode(name, forKey: .name)
         try encoderContainer.encode(createTime, forKey: .createTime)
         try encoderContainer.encode(bindGroups, forKey: .bindGroups)
    }
}
///  debugReturnMessage
public class DebugReturnMessage:NSObject,Codable{
    /// 请求地址
    var requestUrl:String?
    /// request中header信息
    var requestHeader:String?
    /// request中body信息
    var requestBody:String?
    /// 响应状态码
    var responseCodeStatus:String?
    /// header返回值
    var responseHeaderValue:String?
    /// body返回值
    var responseBody:String?



    public override init(){
            super.init()
    }

    enum DebugReturnMessageCodingKeys: String, CodingKey {
        case requestUrl
        case requestHeader
        case requestBody
        case responseCodeStatus
        case responseHeaderValue
        case responseBody
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: DebugReturnMessageCodingKeys.self)
        if decoderContainer.contains(.requestUrl)
        {
            self.requestUrl = try decoderContainer.decode(String?.self, forKey: .requestUrl)
        }
        if decoderContainer.contains(.requestHeader)
        {
            self.requestHeader = try decoderContainer.decode(String?.self, forKey: .requestHeader)
        }
        if decoderContainer.contains(.requestBody)
        {
            self.requestBody = try decoderContainer.decode(String?.self, forKey: .requestBody)
        }
        if decoderContainer.contains(.responseCodeStatus)
        {
            self.responseCodeStatus = try decoderContainer.decode(String?.self, forKey: .responseCodeStatus)
        }
        if decoderContainer.contains(.responseHeaderValue)
        {
            self.responseHeaderValue = try decoderContainer.decode(String?.self, forKey: .responseHeaderValue)
        }
        if decoderContainer.contains(.responseBody)
        {
            self.responseBody = try decoderContainer.decode(String?.self, forKey: .responseBody)
        }
    }
}
public extension DebugReturnMessage{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: DebugReturnMessageCodingKeys.self)
         try encoderContainer.encode(requestUrl, forKey: .requestUrl)
         try encoderContainer.encode(requestHeader, forKey: .requestHeader)
         try encoderContainer.encode(requestBody, forKey: .requestBody)
         try encoderContainer.encode(responseCodeStatus, forKey: .responseCodeStatus)
         try encoderContainer.encode(responseHeaderValue, forKey: .responseHeaderValue)
         try encoderContainer.encode(responseBody, forKey: .responseBody)
    }
}
///  授权API分组
public class BindedGroup:NSObject,Codable{
    /// 分组ID
    var apiGroupId:String?
    /// 名称
    var groupName:String?
    /// 区域
    var region:String?
    /// 环境
    var environment:String?
    /// 授权时间
    var bindedTime:String?



    public override init(){
            super.init()
    }

    enum BindedGroupCodingKeys: String, CodingKey {
        case apiGroupId
        case groupName
        case region
        case environment
        case bindedTime
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: BindedGroupCodingKeys.self)
        if decoderContainer.contains(.apiGroupId)
        {
            self.apiGroupId = try decoderContainer.decode(String?.self, forKey: .apiGroupId)
        }
        if decoderContainer.contains(.groupName)
        {
            self.groupName = try decoderContainer.decode(String?.self, forKey: .groupName)
        }
        if decoderContainer.contains(.region)
        {
            self.region = try decoderContainer.decode(String?.self, forKey: .region)
        }
        if decoderContainer.contains(.environment)
        {
            self.environment = try decoderContainer.decode(String?.self, forKey: .environment)
        }
        if decoderContainer.contains(.bindedTime)
        {
            self.bindedTime = try decoderContainer.decode(String?.self, forKey: .bindedTime)
        }
    }
}
public extension BindedGroup{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: BindedGroupCodingKeys.self)
         try encoderContainer.encode(apiGroupId, forKey: .apiGroupId)
         try encoderContainer.encode(groupName, forKey: .groupName)
         try encoderContainer.encode(region, forKey: .region)
         try encoderContainer.encode(environment, forKey: .environment)
         try encoderContainer.encode(bindedTime, forKey: .bindedTime)
    }
}

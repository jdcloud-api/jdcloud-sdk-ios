/* Copyright 2018 JDCLOUD.COM

   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at

     http:#www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.

   SSL Certificate Manager
   SSL数字证书信息管理接口

   OpenAPI spec version: v1
   Contact: 

   NOTE: This class is auto generated by the jdcloud code generator program.
 */


import Foundation
import JDCloudSDKCore

/// 修改证书名称 
public class UpdateCertNameResult:NSObject,JdCloudResult
{
    /// 状态码
    var code:Int?

    /// 消息
    var message:String?



    public override init(){
        super.init()
    }

    enum UpdateCertNameResultCodingKeys: String, CodingKey {
        case code
        case message
    }

    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: UpdateCertNameResultCodingKeys.self)
        if decoderContainer.contains(.code)
        {
            self.code = try decoderContainer.decode(Int?.self, forKey: .code)
        }
        if decoderContainer.contains(.message)
        {
            self.message = try decoderContainer.decode(String?.self, forKey: .message)
        }
    }
}
public extension UpdateCertNameResult{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: UpdateCertNameResultCodingKeys.self)
        try encoderContainer.encode(code, forKey: .code)
        try encoderContainer.encode(message, forKey: .message)
    }
}

///  查看证书详情
public class DescribeCertRequest:JdCloudRequest
{
    /// 第几页，从1开始计数
    var pageNumber:Int?

    /// 每页显示的数目
    var pageSize:Int?

    /// 证书 Id
    var certId:String


    public init(regionId: String,certId:String){
        self.certId = certId
        super.init(regionId: regionId)
    }


    enum DescribeCertRequestRequestCodingKeys: String, CodingKey {
        case pageNumber
        case pageSize
        case certId
    }

    public override func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: DescribeCertRequestRequestCodingKeys.self)
        try encoderContainer.encode(pageNumber, forKey: .pageNumber)
        try encoderContainer.encode(pageSize, forKey: .pageSize)
        try encoderContainer.encode(certId, forKey: .certId)

    }
}

public class DescribeCertResponse:NSObject,Codable
{
    var requestId:String?;

    var error:ServiceError?;

    var result:DescribeCertResult?;

    enum DescribeCertResponseCodingKeys: String, CodingKey {
        case requestId
        case error
        case result
    }

    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: DescribeCertResponseCodingKeys.self)
        self.requestId = try decoderContainer.decodeIfPresent(String?.self, forKey: .requestId) ?? nil
        self.error = try decoderContainer.decodeIfPresent(ServiceError?.self, forKey: .error) ?? nil
        self.result = try decoderContainer.decodeIfPresent(DescribeCertResult?.self, forKey: .result) ?? nil
    }
}

public extension DescribeCertResponse{
        func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: DescribeCertResponseCodingKeys.self)
        try encoderContainer.encode(requestId, forKey: .requestId)
        try encoderContainer.encode(error, forKey: .error)
        try encoderContainer.encode(result, forKey: .result)
    }
}    

///  下载证书 [MFA enabled]
public class DownloadCertRequest:JdCloudRequest
{
    /// 证书应用的服务器类型(Nginx Apache Tomcat IIS Other)
    var serverType:String

    /// 证书 Id
    var certId:String


    public init(regionId: String,serverType:String,certId:String){
        self.serverType = serverType
        self.certId = certId
        super.init(regionId: regionId)
    }


    enum DownloadCertRequestRequestCodingKeys: String, CodingKey {
        case serverType
        case certId
    }

    public override func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: DownloadCertRequestRequestCodingKeys.self)
        try encoderContainer.encode(serverType, forKey: .serverType)
        try encoderContainer.encode(certId, forKey: .certId)

    }
}

/// 更新证书 [MFA enabled] 
public class UpdateCertResult:NSObject,JdCloudResult
{
    /// 待更新证书ID
    var certId:String?

    /// 对私钥文件使用sha256算法计算的摘要信息
    var digest:String?



    public override init(){
        super.init()
    }

    enum UpdateCertResultCodingKeys: String, CodingKey {
        case certId
        case digest
    }

    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: UpdateCertResultCodingKeys.self)
        if decoderContainer.contains(.certId)
        {
            self.certId = try decoderContainer.decode(String?.self, forKey: .certId)
        }
        if decoderContainer.contains(.digest)
        {
            self.digest = try decoderContainer.decode(String?.self, forKey: .digest)
        }
    }
}
public extension UpdateCertResult{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: UpdateCertResultCodingKeys.self)
        try encoderContainer.encode(certId, forKey: .certId)
        try encoderContainer.encode(digest, forKey: .digest)
    }
}
public class UploadCertResponse:NSObject,Codable
{
    var requestId:String?;

    var error:ServiceError?;

    var result:UploadCertResult?;

    enum UploadCertResponseCodingKeys: String, CodingKey {
        case requestId
        case error
        case result
    }

    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: UploadCertResponseCodingKeys.self)
        self.requestId = try decoderContainer.decodeIfPresent(String?.self, forKey: .requestId) ?? nil
        self.error = try decoderContainer.decodeIfPresent(ServiceError?.self, forKey: .error) ?? nil
        self.result = try decoderContainer.decodeIfPresent(UploadCertResult?.self, forKey: .result) ?? nil
    }
}

public extension UploadCertResponse{
        func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: UploadCertResponseCodingKeys.self)
        try encoderContainer.encode(requestId, forKey: .requestId)
        try encoderContainer.encode(error, forKey: .error)
        try encoderContainer.encode(result, forKey: .result)
    }
}    
/// 删除证书 [MFA enabled] 
public class DeleteCertsResult:NSObject,JdCloudResult
{
    /// 状态码
    var code:Int?

    /// 消息
    var message:String?



    public override init(){
        super.init()
    }

    enum DeleteCertsResultCodingKeys: String, CodingKey {
        case code
        case message
    }

    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: DeleteCertsResultCodingKeys.self)
        if decoderContainer.contains(.code)
        {
            self.code = try decoderContainer.decode(Int?.self, forKey: .code)
        }
        if decoderContainer.contains(.message)
        {
            self.message = try decoderContainer.decode(String?.self, forKey: .message)
        }
    }
}
public extension DeleteCertsResult{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: DeleteCertsResultCodingKeys.self)
        try encoderContainer.encode(code, forKey: .code)
        try encoderContainer.encode(message, forKey: .message)
    }
}
/// 下载证书 [MFA enabled] 
public class DownloadCertResult:NSObject,JdCloudResult
{
    /// CertDesc
    var certDesc:[DownloadCertDesc?]?



    public override init(){
        super.init()
    }

    enum DownloadCertResultCodingKeys: String, CodingKey {
        case certDesc
    }

    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: DownloadCertResultCodingKeys.self)
        if decoderContainer.contains(.certDesc)
        {
            self.certDesc = try decoderContainer.decode([DownloadCertDesc?]?.self, forKey: .certDesc)
        }
    }
}
public extension DownloadCertResult{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: DownloadCertResultCodingKeys.self)
        try encoderContainer.encode(certDesc, forKey: .certDesc)
    }
}
public class DownloadCertResponse:NSObject,Codable
{
    var requestId:String?;

    var error:ServiceError?;

    var result:DownloadCertResult?;

    enum DownloadCertResponseCodingKeys: String, CodingKey {
        case requestId
        case error
        case result
    }

    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: DownloadCertResponseCodingKeys.self)
        self.requestId = try decoderContainer.decodeIfPresent(String?.self, forKey: .requestId) ?? nil
        self.error = try decoderContainer.decodeIfPresent(ServiceError?.self, forKey: .error) ?? nil
        self.result = try decoderContainer.decodeIfPresent(DownloadCertResult?.self, forKey: .result) ?? nil
    }
}

public extension DownloadCertResponse{
        func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: DownloadCertResponseCodingKeys.self)
        try encoderContainer.encode(requestId, forKey: .requestId)
        try encoderContainer.encode(error, forKey: .error)
        try encoderContainer.encode(result, forKey: .result)
    }
}    
/// 上传证书 
public class UploadCertResult:NSObject,JdCloudResult
{
    /// CertId
    var certId:String?

    /// 对私钥文件使用sha256算法计算的摘要信息
    var digest:String?



    public override init(){
        super.init()
    }

    enum UploadCertResultCodingKeys: String, CodingKey {
        case certId
        case digest
    }

    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: UploadCertResultCodingKeys.self)
        if decoderContainer.contains(.certId)
        {
            self.certId = try decoderContainer.decode(String?.self, forKey: .certId)
        }
        if decoderContainer.contains(.digest)
        {
            self.digest = try decoderContainer.decode(String?.self, forKey: .digest)
        }
    }
}
public extension UploadCertResult{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: UploadCertResultCodingKeys.self)
        try encoderContainer.encode(certId, forKey: .certId)
        try encoderContainer.encode(digest, forKey: .digest)
    }
}
public class DeleteCertsResponse:NSObject,Codable
{
    var requestId:String?;

    var error:ServiceError?;

    var result:DeleteCertsResult?;

    enum DeleteCertsResponseCodingKeys: String, CodingKey {
        case requestId
        case error
        case result
    }

    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: DeleteCertsResponseCodingKeys.self)
        self.requestId = try decoderContainer.decodeIfPresent(String?.self, forKey: .requestId) ?? nil
        self.error = try decoderContainer.decodeIfPresent(ServiceError?.self, forKey: .error) ?? nil
        self.result = try decoderContainer.decodeIfPresent(DeleteCertsResult?.self, forKey: .result) ?? nil
    }
}

public extension DeleteCertsResponse{
        func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: DeleteCertsResponseCodingKeys.self)
        try encoderContainer.encode(requestId, forKey: .requestId)
        try encoderContainer.encode(error, forKey: .error)
        try encoderContainer.encode(result, forKey: .result)
    }
}    

///  更新证书 [MFA enabled]
public class UpdateCertRequest:JdCloudRequest
{
    /// 证书ID
    var certId:String

    /// 私钥
    var keyFile:String

    /// 证书
    var certFile:String


    public init(regionId: String,certId:String,keyFile:String,certFile:String){
        self.certId = certId
        self.keyFile = keyFile
        self.certFile = certFile
        super.init(regionId: regionId)
    }


    enum UpdateCertRequestRequestCodingKeys: String, CodingKey {
        case certId
        case keyFile
        case certFile
    }

    public override func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: UpdateCertRequestRequestCodingKeys.self)
        try encoderContainer.encode(certId, forKey: .certId)
        try encoderContainer.encode(keyFile, forKey: .keyFile)
        try encoderContainer.encode(certFile, forKey: .certFile)

    }
}


///  修改证书名称
public class UpdateCertNameRequest:JdCloudRequest
{
    /// 证书Id
    var certId:String

    /// 证书名称
    var certName:String


    public init(regionId: String,certId:String,certName:String){
        self.certId = certId
        self.certName = certName
        super.init(regionId: regionId)
    }


    enum UpdateCertNameRequestRequestCodingKeys: String, CodingKey {
        case certId
        case certName
    }

    public override func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: UpdateCertNameRequestRequestCodingKeys.self)
        try encoderContainer.encode(certId, forKey: .certId)
        try encoderContainer.encode(certName, forKey: .certName)

    }
}

public class UpdateCertNameResponse:NSObject,Codable
{
    var requestId:String?;

    var error:ServiceError?;

    var result:UpdateCertNameResult?;

    enum UpdateCertNameResponseCodingKeys: String, CodingKey {
        case requestId
        case error
        case result
    }

    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: UpdateCertNameResponseCodingKeys.self)
        self.requestId = try decoderContainer.decodeIfPresent(String?.self, forKey: .requestId) ?? nil
        self.error = try decoderContainer.decodeIfPresent(ServiceError?.self, forKey: .error) ?? nil
        self.result = try decoderContainer.decodeIfPresent(UpdateCertNameResult?.self, forKey: .result) ?? nil
    }
}

public extension UpdateCertNameResponse{
        func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: UpdateCertNameResponseCodingKeys.self)
        try encoderContainer.encode(requestId, forKey: .requestId)
        try encoderContainer.encode(error, forKey: .error)
        try encoderContainer.encode(result, forKey: .result)
    }
}    
public class UpdateCertResponse:NSObject,Codable
{
    var requestId:String?;

    var error:ServiceError?;

    var result:UpdateCertResult?;

    enum UpdateCertResponseCodingKeys: String, CodingKey {
        case requestId
        case error
        case result
    }

    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: UpdateCertResponseCodingKeys.self)
        self.requestId = try decoderContainer.decodeIfPresent(String?.self, forKey: .requestId) ?? nil
        self.error = try decoderContainer.decodeIfPresent(ServiceError?.self, forKey: .error) ?? nil
        self.result = try decoderContainer.decodeIfPresent(UpdateCertResult?.self, forKey: .result) ?? nil
    }
}

public extension UpdateCertResponse{
        func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: UpdateCertResponseCodingKeys.self)
        try encoderContainer.encode(requestId, forKey: .requestId)
        try encoderContainer.encode(error, forKey: .error)
        try encoderContainer.encode(result, forKey: .result)
    }
}    
public class DescribeCertsResponse:NSObject,Codable
{
    var requestId:String?;

    var error:ServiceError?;

    var result:DescribeCertsResult?;

    enum DescribeCertsResponseCodingKeys: String, CodingKey {
        case requestId
        case error
        case result
    }

    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: DescribeCertsResponseCodingKeys.self)
        self.requestId = try decoderContainer.decodeIfPresent(String?.self, forKey: .requestId) ?? nil
        self.error = try decoderContainer.decodeIfPresent(ServiceError?.self, forKey: .error) ?? nil
        self.result = try decoderContainer.decodeIfPresent(DescribeCertsResult?.self, forKey: .result) ?? nil
    }
}

public extension DescribeCertsResponse{
        func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: DescribeCertsResponseCodingKeys.self)
        try encoderContainer.encode(requestId, forKey: .requestId)
        try encoderContainer.encode(error, forKey: .error)
        try encoderContainer.encode(result, forKey: .result)
    }
}    

///  上传证书
public class UploadCertRequest:JdCloudRequest
{
    /// 证书名称
    var certName:String

    /// 私钥
    var keyFile:String

    /// 证书
    var certFile:String

    /// 证书别名
    var aliasName:String?


    public init(regionId: String,certName:String,keyFile:String,certFile:String){
        self.certName = certName
        self.keyFile = keyFile
        self.certFile = certFile
        super.init(regionId: regionId)
    }


    enum UploadCertRequestRequestCodingKeys: String, CodingKey {
        case certName
        case keyFile
        case certFile
        case aliasName
    }

    public override func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: UploadCertRequestRequestCodingKeys.self)
        try encoderContainer.encode(certName, forKey: .certName)
        try encoderContainer.encode(keyFile, forKey: .keyFile)
        try encoderContainer.encode(certFile, forKey: .certFile)
        try encoderContainer.encode(aliasName, forKey: .aliasName)

    }
}

/// 查看证书列表 
public class DescribeCertsResult:NSObject,JdCloudResult
{
    /// 证书列表详情
    var certListDetails:[CertListDetail?]?

    /// 总数量
    var totalCount:Int?



    public override init(){
        super.init()
    }

    enum DescribeCertsResultCodingKeys: String, CodingKey {
        case certListDetails
        case totalCount
    }

    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: DescribeCertsResultCodingKeys.self)
        if decoderContainer.contains(.certListDetails)
        {
            self.certListDetails = try decoderContainer.decode([CertListDetail?]?.self, forKey: .certListDetails)
        }
        if decoderContainer.contains(.totalCount)
        {
            self.totalCount = try decoderContainer.decode(Int?.self, forKey: .totalCount)
        }
    }
}
public extension DescribeCertsResult{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: DescribeCertsResultCodingKeys.self)
        try encoderContainer.encode(certListDetails, forKey: .certListDetails)
        try encoderContainer.encode(totalCount, forKey: .totalCount)
    }
}

///  查看证书列表
public class DescribeCertsRequest:JdCloudRequest
{
    /// 第几页，从1开始计数
    var pageNumber:Int?

    /// 每页显示的数目
    var pageSize:Int?

    /// 域名，支持按照域名检索证书
    var domainName:String?

    /// 证书id/别名
    var certIds:String?




    enum DescribeCertsRequestRequestCodingKeys: String, CodingKey {
        case pageNumber
        case pageSize
        case domainName
        case certIds
    }

    public override func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: DescribeCertsRequestRequestCodingKeys.self)
        try encoderContainer.encode(pageNumber, forKey: .pageNumber)
        try encoderContainer.encode(pageSize, forKey: .pageSize)
        try encoderContainer.encode(domainName, forKey: .domainName)
        try encoderContainer.encode(certIds, forKey: .certIds)

    }
}


///  删除证书 [MFA enabled]
public class DeleteCertsRequest:JdCloudRequest
{
    /// 证书 Id
    var certId:String


    public init(regionId: String,certId:String){
        self.certId = certId
        super.init(regionId: regionId)
    }


    enum DeleteCertsRequestRequestCodingKeys: String, CodingKey {
        case certId
    }

    public override func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: DeleteCertsRequestRequestCodingKeys.self)
        try encoderContainer.encode(certId, forKey: .certId)

    }
}

/// 查看证书详情 
public class DescribeCertResult:NSObject,JdCloudResult
{
    /// 证书Id
    var certId:String?

    /// 证书名称
    var certName:String?

    /// 绑定域名
    var commonName:String?

    /// 证书类型
    var certType:String?

    /// 签发者
    var issuer:String?

    /// 开始时间
    var startTime:String?

    /// 结束时间
    var endTime:String?

    /// 域名
    var dnsNames:[String?]?

    /// 对私钥文件使用sha256算法计算的摘要信息
    var digest:String?

    /// 绑定信息的总数量
    var totalCount:Int?

    /// 证书关联信息
    var usedBy:[CertBindInfo?]?



    public override init(){
        super.init()
    }

    enum DescribeCertResultCodingKeys: String, CodingKey {
        case certId
        case certName
        case commonName
        case certType
        case issuer
        case startTime
        case endTime
        case dnsNames
        case digest
        case totalCount
        case usedBy
    }

    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: DescribeCertResultCodingKeys.self)
        if decoderContainer.contains(.certId)
        {
            self.certId = try decoderContainer.decode(String?.self, forKey: .certId)
        }
        if decoderContainer.contains(.certName)
        {
            self.certName = try decoderContainer.decode(String?.self, forKey: .certName)
        }
        if decoderContainer.contains(.commonName)
        {
            self.commonName = try decoderContainer.decode(String?.self, forKey: .commonName)
        }
        if decoderContainer.contains(.certType)
        {
            self.certType = try decoderContainer.decode(String?.self, forKey: .certType)
        }
        if decoderContainer.contains(.issuer)
        {
            self.issuer = try decoderContainer.decode(String?.self, forKey: .issuer)
        }
        if decoderContainer.contains(.startTime)
        {
            self.startTime = try decoderContainer.decode(String?.self, forKey: .startTime)
        }
        if decoderContainer.contains(.endTime)
        {
            self.endTime = try decoderContainer.decode(String?.self, forKey: .endTime)
        }
        if decoderContainer.contains(.dnsNames)
        {
            self.dnsNames = try decoderContainer.decode([String?]?.self, forKey: .dnsNames)
        }
        if decoderContainer.contains(.digest)
        {
            self.digest = try decoderContainer.decode(String?.self, forKey: .digest)
        }
        if decoderContainer.contains(.totalCount)
        {
            self.totalCount = try decoderContainer.decode(Int?.self, forKey: .totalCount)
        }
        if decoderContainer.contains(.usedBy)
        {
            self.usedBy = try decoderContainer.decode([CertBindInfo?]?.self, forKey: .usedBy)
        }
    }
}
public extension DescribeCertResult{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: DescribeCertResultCodingKeys.self)
        try encoderContainer.encode(certId, forKey: .certId)
        try encoderContainer.encode(certName, forKey: .certName)
        try encoderContainer.encode(commonName, forKey: .commonName)
        try encoderContainer.encode(certType, forKey: .certType)
        try encoderContainer.encode(issuer, forKey: .issuer)
        try encoderContainer.encode(startTime, forKey: .startTime)
        try encoderContainer.encode(endTime, forKey: .endTime)
        try encoderContainer.encode(dnsNames, forKey: .dnsNames)
        try encoderContainer.encode(digest, forKey: .digest)
        try encoderContainer.encode(totalCount, forKey: .totalCount)
        try encoderContainer.encode(usedBy, forKey: .usedBy)
    }
}

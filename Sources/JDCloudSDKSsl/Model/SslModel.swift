/* Copyright 2018 JDCLOUD.COM

   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at

     http:#www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.

   SSL Certificate Manager
   SSL数字证书信息管理接口

   OpenAPI spec version: v1
   Contact: 

   NOTE: This class is auto generated by the jdcloud code generator program.
 */


import Foundation
///  recordListDetail
public class RecordListDetail:NSObject,Codable{
    /// 证书申购记录Id
    var recordId:String?
    /// 交易系统订单Id
    var orderId:String?
    /// 证书绑定域名
    var commonName:String?
    /// 证书供应商
    var supplier:String?
    /// 证书品牌
    var brand:String?
    /// 证书类型
    var certType:String?
    /// 证书年限
    var certValidity:Int?
    /// 证书状态,1:未支付,2:待补全信息,3:待下单,4:待域名验证,5:已完成,6:审核不通过,7:已取消
    var state:Int?
    /// 厂商订单ID
    var partnerOrderId:String?
    /// 购买域名数量
    var domainCount:Int?
    /// 购买泛域名数量
    var wildcardDomainCount:Int?
    /// 备用域名
    var dnsNames:[String?]?
    /// 证书Id
    var certId:String?



    public override init(){
            super.init()
    }

    enum RecordListDetailCodingKeys: String, CodingKey {
        case recordId
        case orderId
        case commonName
        case supplier
        case brand
        case certType
        case certValidity
        case state
        case partnerOrderId
        case domainCount
        case wildcardDomainCount
        case dnsNames
        case certId
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: RecordListDetailCodingKeys.self)
        if decoderContainer.contains(.recordId)
        {
            self.recordId = try decoderContainer.decode(String?.self, forKey: .recordId)
        }
        if decoderContainer.contains(.orderId)
        {
            self.orderId = try decoderContainer.decode(String?.self, forKey: .orderId)
        }
        if decoderContainer.contains(.commonName)
        {
            self.commonName = try decoderContainer.decode(String?.self, forKey: .commonName)
        }
        if decoderContainer.contains(.supplier)
        {
            self.supplier = try decoderContainer.decode(String?.self, forKey: .supplier)
        }
        if decoderContainer.contains(.brand)
        {
            self.brand = try decoderContainer.decode(String?.self, forKey: .brand)
        }
        if decoderContainer.contains(.certType)
        {
            self.certType = try decoderContainer.decode(String?.self, forKey: .certType)
        }
        if decoderContainer.contains(.certValidity)
        {
            self.certValidity = try decoderContainer.decode(Int?.self, forKey: .certValidity)
        }
        if decoderContainer.contains(.state)
        {
            self.state = try decoderContainer.decode(Int?.self, forKey: .state)
        }
        if decoderContainer.contains(.partnerOrderId)
        {
            self.partnerOrderId = try decoderContainer.decode(String?.self, forKey: .partnerOrderId)
        }
        if decoderContainer.contains(.domainCount)
        {
            self.domainCount = try decoderContainer.decode(Int?.self, forKey: .domainCount)
        }
        if decoderContainer.contains(.wildcardDomainCount)
        {
            self.wildcardDomainCount = try decoderContainer.decode(Int?.self, forKey: .wildcardDomainCount)
        }
        if decoderContainer.contains(.dnsNames)
        {
            self.dnsNames = try decoderContainer.decode([String?]?.self, forKey: .dnsNames)
        }
        if decoderContainer.contains(.certId)
        {
            self.certId = try decoderContainer.decode(String?.self, forKey: .certId)
        }
    }
}
public extension RecordListDetail{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: RecordListDetailCodingKeys.self)
         try encoderContainer.encode(recordId, forKey: .recordId)
         try encoderContainer.encode(orderId, forKey: .orderId)
         try encoderContainer.encode(commonName, forKey: .commonName)
         try encoderContainer.encode(supplier, forKey: .supplier)
         try encoderContainer.encode(brand, forKey: .brand)
         try encoderContainer.encode(certType, forKey: .certType)
         try encoderContainer.encode(certValidity, forKey: .certValidity)
         try encoderContainer.encode(state, forKey: .state)
         try encoderContainer.encode(partnerOrderId, forKey: .partnerOrderId)
         try encoderContainer.encode(domainCount, forKey: .domainCount)
         try encoderContainer.encode(wildcardDomainCount, forKey: .wildcardDomainCount)
         try encoderContainer.encode(dnsNames, forKey: .dnsNames)
         try encoderContainer.encode(certId, forKey: .certId)
    }
}
///  discountDetailList
public class DiscountDetailList:NSObject,Codable{
    /// 服务code
    var serviceCode:String?
    /// 购买时长
    var billPeriod:Int?
    /// 折扣信息
    var message:String?
    /// 折扣
    var discount:Double?



    public override init(){
            super.init()
    }

    enum DiscountDetailListCodingKeys: String, CodingKey {
        case serviceCode
        case billPeriod
        case message
        case discount
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: DiscountDetailListCodingKeys.self)
        if decoderContainer.contains(.serviceCode)
        {
            self.serviceCode = try decoderContainer.decode(String?.self, forKey: .serviceCode)
        }
        if decoderContainer.contains(.billPeriod)
        {
            self.billPeriod = try decoderContainer.decode(Int?.self, forKey: .billPeriod)
        }
        if decoderContainer.contains(.message)
        {
            self.message = try decoderContainer.decode(String?.self, forKey: .message)
        }
        if decoderContainer.contains(.discount)
        {
            self.discount = try decoderContainer.decode(Double?.self, forKey: .discount)
        }
    }
}
public extension DiscountDetailList{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: DiscountDetailListCodingKeys.self)
         try encoderContainer.encode(serviceCode, forKey: .serviceCode)
         try encoderContainer.encode(billPeriod, forKey: .billPeriod)
         try encoderContainer.encode(message, forKey: .message)
         try encoderContainer.encode(discount, forKey: .discount)
    }
}
///  validateQueryResult
public class ValidateQueryResult:NSObject,Codable{
    /// 校验Key
    var validateKey:String?
    /// 校验内容
    var validateValue:String?



    public override init(){
            super.init()
    }

    enum ValidateQueryResultCodingKeys: String, CodingKey {
        case validateKey
        case validateValue
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: ValidateQueryResultCodingKeys.self)
        if decoderContainer.contains(.validateKey)
        {
            self.validateKey = try decoderContainer.decode(String?.self, forKey: .validateKey)
        }
        if decoderContainer.contains(.validateValue)
        {
            self.validateValue = try decoderContainer.decode(String?.self, forKey: .validateValue)
        }
    }
}
public extension ValidateQueryResult{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: ValidateQueryResultCodingKeys.self)
         try encoderContainer.encode(validateKey, forKey: .validateKey)
         try encoderContainer.encode(validateValue, forKey: .validateValue)
    }
}
///  recordDescDetail
public class RecordDescDetail:NSObject,Codable{
    /// 证书申购记录Id
    var recordId:String?
    /// 交易系统订单Id
    var orderId:String?
    /// 证书名称
    var certName:String?
    /// 证书品牌
    var brand:String?
    /// 证书类型
    var certType:String?
    /// 域名的个数
    var domainCount:Int?
    /// 泛域名的个数
    var wildcardDomainCount:Int?
    /// 证书年限
    var certValidity:Int?
    /// 证书绑定域名
    var commonName:String?
    /// 证书状态,1:未支付,2:待补全信息,3:待下单,4:待域名验证,5:已完成,6:审核不通过,7:已取消
    var state:Int?
    /// 分销商返回的信息，代表订单被取消的原因
    var canceledReason:String?
    /// RecordValidate
    var recordValidate:RecordValidate?
    /// 公司名称
    var corpName:String?
    /// 公司地址
    var corpAddr:String?
    /// 备用域名
    var dnsNames:[String?]?
    /// 联系人邮箱
    var email:String?
    /// 自动DNS验证结果信息
    var errorMessage:String?



    public override init(){
            super.init()
    }

    enum RecordDescDetailCodingKeys: String, CodingKey {
        case recordId
        case orderId
        case certName
        case brand
        case certType
        case domainCount
        case wildcardDomainCount
        case certValidity
        case commonName
        case state
        case canceledReason
        case recordValidate
        case corpName
        case corpAddr
        case dnsNames
        case email
        case errorMessage
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: RecordDescDetailCodingKeys.self)
        if decoderContainer.contains(.recordId)
        {
            self.recordId = try decoderContainer.decode(String?.self, forKey: .recordId)
        }
        if decoderContainer.contains(.orderId)
        {
            self.orderId = try decoderContainer.decode(String?.self, forKey: .orderId)
        }
        if decoderContainer.contains(.certName)
        {
            self.certName = try decoderContainer.decode(String?.self, forKey: .certName)
        }
        if decoderContainer.contains(.brand)
        {
            self.brand = try decoderContainer.decode(String?.self, forKey: .brand)
        }
        if decoderContainer.contains(.certType)
        {
            self.certType = try decoderContainer.decode(String?.self, forKey: .certType)
        }
        if decoderContainer.contains(.domainCount)
        {
            self.domainCount = try decoderContainer.decode(Int?.self, forKey: .domainCount)
        }
        if decoderContainer.contains(.wildcardDomainCount)
        {
            self.wildcardDomainCount = try decoderContainer.decode(Int?.self, forKey: .wildcardDomainCount)
        }
        if decoderContainer.contains(.certValidity)
        {
            self.certValidity = try decoderContainer.decode(Int?.self, forKey: .certValidity)
        }
        if decoderContainer.contains(.commonName)
        {
            self.commonName = try decoderContainer.decode(String?.self, forKey: .commonName)
        }
        if decoderContainer.contains(.state)
        {
            self.state = try decoderContainer.decode(Int?.self, forKey: .state)
        }
        if decoderContainer.contains(.canceledReason)
        {
            self.canceledReason = try decoderContainer.decode(String?.self, forKey: .canceledReason)
        }
        if decoderContainer.contains(.recordValidate)
        {
            self.recordValidate = try decoderContainer.decode(RecordValidate?.self, forKey: .recordValidate)
        }
        if decoderContainer.contains(.corpName)
        {
            self.corpName = try decoderContainer.decode(String?.self, forKey: .corpName)
        }
        if decoderContainer.contains(.corpAddr)
        {
            self.corpAddr = try decoderContainer.decode(String?.self, forKey: .corpAddr)
        }
        if decoderContainer.contains(.dnsNames)
        {
            self.dnsNames = try decoderContainer.decode([String?]?.self, forKey: .dnsNames)
        }
        if decoderContainer.contains(.email)
        {
            self.email = try decoderContainer.decode(String?.self, forKey: .email)
        }
        if decoderContainer.contains(.errorMessage)
        {
            self.errorMessage = try decoderContainer.decode(String?.self, forKey: .errorMessage)
        }
    }
}
public extension RecordDescDetail{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: RecordDescDetailCodingKeys.self)
         try encoderContainer.encode(recordId, forKey: .recordId)
         try encoderContainer.encode(orderId, forKey: .orderId)
         try encoderContainer.encode(certName, forKey: .certName)
         try encoderContainer.encode(brand, forKey: .brand)
         try encoderContainer.encode(certType, forKey: .certType)
         try encoderContainer.encode(domainCount, forKey: .domainCount)
         try encoderContainer.encode(wildcardDomainCount, forKey: .wildcardDomainCount)
         try encoderContainer.encode(certValidity, forKey: .certValidity)
         try encoderContainer.encode(commonName, forKey: .commonName)
         try encoderContainer.encode(state, forKey: .state)
         try encoderContainer.encode(canceledReason, forKey: .canceledReason)
         try encoderContainer.encode(recordValidate, forKey: .recordValidate)
         try encoderContainer.encode(corpName, forKey: .corpName)
         try encoderContainer.encode(corpAddr, forKey: .corpAddr)
         try encoderContainer.encode(dnsNames, forKey: .dnsNames)
         try encoderContainer.encode(email, forKey: .email)
         try encoderContainer.encode(errorMessage, forKey: .errorMessage)
    }
}
///  downloadCertDesc
public class DownloadCertDesc:NSObject,Codable{
    /// 证书Id
    var certId:String?
    /// 证书名称
    var certName:String?
    /// 私钥
    var keyFile:String?
    /// 证书
    var certFile:String?
    /// 对私钥文件使用sha256算法计算的摘要信息
    var digest:String?
    /// 中间证书
    var caCertFile:String?
    /// 证书应用服务器类型
    var serverType:String?
    /// 证书加密密码
    var certEncryptePassword:String?
    /// 域名
    var commonName:String?



    public override init(){
            super.init()
    }

    enum DownloadCertDescCodingKeys: String, CodingKey {
        case certId
        case certName
        case keyFile
        case certFile
        case digest
        case caCertFile
        case serverType
        case certEncryptePassword
        case commonName
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: DownloadCertDescCodingKeys.self)
        if decoderContainer.contains(.certId)
        {
            self.certId = try decoderContainer.decode(String?.self, forKey: .certId)
        }
        if decoderContainer.contains(.certName)
        {
            self.certName = try decoderContainer.decode(String?.self, forKey: .certName)
        }
        if decoderContainer.contains(.keyFile)
        {
            self.keyFile = try decoderContainer.decode(String?.self, forKey: .keyFile)
        }
        if decoderContainer.contains(.certFile)
        {
            self.certFile = try decoderContainer.decode(String?.self, forKey: .certFile)
        }
        if decoderContainer.contains(.digest)
        {
            self.digest = try decoderContainer.decode(String?.self, forKey: .digest)
        }
        if decoderContainer.contains(.caCertFile)
        {
            self.caCertFile = try decoderContainer.decode(String?.self, forKey: .caCertFile)
        }
        if decoderContainer.contains(.serverType)
        {
            self.serverType = try decoderContainer.decode(String?.self, forKey: .serverType)
        }
        if decoderContainer.contains(.certEncryptePassword)
        {
            self.certEncryptePassword = try decoderContainer.decode(String?.self, forKey: .certEncryptePassword)
        }
        if decoderContainer.contains(.commonName)
        {
            self.commonName = try decoderContainer.decode(String?.self, forKey: .commonName)
        }
    }
}
public extension DownloadCertDesc{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: DownloadCertDescCodingKeys.self)
         try encoderContainer.encode(certId, forKey: .certId)
         try encoderContainer.encode(certName, forKey: .certName)
         try encoderContainer.encode(keyFile, forKey: .keyFile)
         try encoderContainer.encode(certFile, forKey: .certFile)
         try encoderContainer.encode(digest, forKey: .digest)
         try encoderContainer.encode(caCertFile, forKey: .caCertFile)
         try encoderContainer.encode(serverType, forKey: .serverType)
         try encoderContainer.encode(certEncryptePassword, forKey: .certEncryptePassword)
         try encoderContainer.encode(commonName, forKey: .commonName)
    }
}
///  certListDetail
public class CertListDetail:NSObject,Codable{
    /// 证书Id
    var certId:String?
    /// 证书名称
    var certName:String?
    /// 绑定域名
    var commonName:String?
    /// 证书类型
    var certType:String?
    /// 开始时间
    var startTime:String?
    /// 结束时间
    var endTime:String?
    /// 是否允许被删除,1允许,0不允许
    var deletable:Int?
    /// 对私钥文件使用sha256算法计算的摘要信息
    var digest:String?
    /// 证书别名
    var aliasName:String?
    /// 域名
    var dnsNames:[String?]?
    /// 是否允许被下载,0-&gt;不允许,1-&gt;允许
    var downloadable:Int?
    /// 是否允许被更新,0-&gt;不允许,1-&gt;允许
    var updateable:Int?
    /// 证书状态
    var certStatus:Int?



    public override init(){
            super.init()
    }

    enum CertListDetailCodingKeys: String, CodingKey {
        case certId
        case certName
        case commonName
        case certType
        case startTime
        case endTime
        case deletable
        case digest
        case aliasName
        case dnsNames
        case downloadable
        case updateable
        case certStatus
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: CertListDetailCodingKeys.self)
        if decoderContainer.contains(.certId)
        {
            self.certId = try decoderContainer.decode(String?.self, forKey: .certId)
        }
        if decoderContainer.contains(.certName)
        {
            self.certName = try decoderContainer.decode(String?.self, forKey: .certName)
        }
        if decoderContainer.contains(.commonName)
        {
            self.commonName = try decoderContainer.decode(String?.self, forKey: .commonName)
        }
        if decoderContainer.contains(.certType)
        {
            self.certType = try decoderContainer.decode(String?.self, forKey: .certType)
        }
        if decoderContainer.contains(.startTime)
        {
            self.startTime = try decoderContainer.decode(String?.self, forKey: .startTime)
        }
        if decoderContainer.contains(.endTime)
        {
            self.endTime = try decoderContainer.decode(String?.self, forKey: .endTime)
        }
        if decoderContainer.contains(.deletable)
        {
            self.deletable = try decoderContainer.decode(Int?.self, forKey: .deletable)
        }
        if decoderContainer.contains(.digest)
        {
            self.digest = try decoderContainer.decode(String?.self, forKey: .digest)
        }
        if decoderContainer.contains(.aliasName)
        {
            self.aliasName = try decoderContainer.decode(String?.self, forKey: .aliasName)
        }
        if decoderContainer.contains(.dnsNames)
        {
            self.dnsNames = try decoderContainer.decode([String?]?.self, forKey: .dnsNames)
        }
        if decoderContainer.contains(.downloadable)
        {
            self.downloadable = try decoderContainer.decode(Int?.self, forKey: .downloadable)
        }
        if decoderContainer.contains(.updateable)
        {
            self.updateable = try decoderContainer.decode(Int?.self, forKey: .updateable)
        }
        if decoderContainer.contains(.certStatus)
        {
            self.certStatus = try decoderContainer.decode(Int?.self, forKey: .certStatus)
        }
    }
}
public extension CertListDetail{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: CertListDetailCodingKeys.self)
         try encoderContainer.encode(certId, forKey: .certId)
         try encoderContainer.encode(certName, forKey: .certName)
         try encoderContainer.encode(commonName, forKey: .commonName)
         try encoderContainer.encode(certType, forKey: .certType)
         try encoderContainer.encode(startTime, forKey: .startTime)
         try encoderContainer.encode(endTime, forKey: .endTime)
         try encoderContainer.encode(deletable, forKey: .deletable)
         try encoderContainer.encode(digest, forKey: .digest)
         try encoderContainer.encode(aliasName, forKey: .aliasName)
         try encoderContainer.encode(dnsNames, forKey: .dnsNames)
         try encoderContainer.encode(downloadable, forKey: .downloadable)
         try encoderContainer.encode(updateable, forKey: .updateable)
         try encoderContainer.encode(certStatus, forKey: .certStatus)
    }
}
///  certBindInfo
public class CertBindInfo:NSObject,Codable{
    /// 绑定名称
    var bindFrom:String?
    /// 绑定Id
    var bindId:String?
    /// 绑定资源所在的Region
    var bindRegion:String?
    /// 绑定资源所在的可用区
    var bindZone:String?



    public override init(){
            super.init()
    }

    enum CertBindInfoCodingKeys: String, CodingKey {
        case bindFrom
        case bindId
        case bindRegion
        case bindZone
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: CertBindInfoCodingKeys.self)
        if decoderContainer.contains(.bindFrom)
        {
            self.bindFrom = try decoderContainer.decode(String?.self, forKey: .bindFrom)
        }
        if decoderContainer.contains(.bindId)
        {
            self.bindId = try decoderContainer.decode(String?.self, forKey: .bindId)
        }
        if decoderContainer.contains(.bindRegion)
        {
            self.bindRegion = try decoderContainer.decode(String?.self, forKey: .bindRegion)
        }
        if decoderContainer.contains(.bindZone)
        {
            self.bindZone = try decoderContainer.decode(String?.self, forKey: .bindZone)
        }
    }
}
public extension CertBindInfo{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: CertBindInfoCodingKeys.self)
         try encoderContainer.encode(bindFrom, forKey: .bindFrom)
         try encoderContainer.encode(bindId, forKey: .bindId)
         try encoderContainer.encode(bindRegion, forKey: .bindRegion)
         try encoderContainer.encode(bindZone, forKey: .bindZone)
    }
}
///  certDescDetail
public class CertDescDetail:NSObject,Codable{
    /// 证书Id
    var certId:String?
    /// 证书名称
    var certName:String?
    /// 绑定域名
    var commonName:String?
    /// 证书类型
    var certType:String?
    /// 签发者
    var issuer:String?
    /// 开始时间
    var startTime:String?
    /// 结束时间
    var endTime:String?
    /// 域名
    var dnsNames:[String?]?
    /// 对私钥文件使用sha256算法计算的摘要信息
    var digest:String?
    /// 绑定信息的总数量
    var totalCount:Int?
    /// 证书关联信息
    var usedBy:[CertBindInfo?]?



    public override init(){
            super.init()
    }

    enum CertDescDetailCodingKeys: String, CodingKey {
        case certId
        case certName
        case commonName
        case certType
        case issuer
        case startTime
        case endTime
        case dnsNames
        case digest
        case totalCount
        case usedBy
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: CertDescDetailCodingKeys.self)
        if decoderContainer.contains(.certId)
        {
            self.certId = try decoderContainer.decode(String?.self, forKey: .certId)
        }
        if decoderContainer.contains(.certName)
        {
            self.certName = try decoderContainer.decode(String?.self, forKey: .certName)
        }
        if decoderContainer.contains(.commonName)
        {
            self.commonName = try decoderContainer.decode(String?.self, forKey: .commonName)
        }
        if decoderContainer.contains(.certType)
        {
            self.certType = try decoderContainer.decode(String?.self, forKey: .certType)
        }
        if decoderContainer.contains(.issuer)
        {
            self.issuer = try decoderContainer.decode(String?.self, forKey: .issuer)
        }
        if decoderContainer.contains(.startTime)
        {
            self.startTime = try decoderContainer.decode(String?.self, forKey: .startTime)
        }
        if decoderContainer.contains(.endTime)
        {
            self.endTime = try decoderContainer.decode(String?.self, forKey: .endTime)
        }
        if decoderContainer.contains(.dnsNames)
        {
            self.dnsNames = try decoderContainer.decode([String?]?.self, forKey: .dnsNames)
        }
        if decoderContainer.contains(.digest)
        {
            self.digest = try decoderContainer.decode(String?.self, forKey: .digest)
        }
        if decoderContainer.contains(.totalCount)
        {
            self.totalCount = try decoderContainer.decode(Int?.self, forKey: .totalCount)
        }
        if decoderContainer.contains(.usedBy)
        {
            self.usedBy = try decoderContainer.decode([CertBindInfo?]?.self, forKey: .usedBy)
        }
    }
}
public extension CertDescDetail{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: CertDescDetailCodingKeys.self)
         try encoderContainer.encode(certId, forKey: .certId)
         try encoderContainer.encode(certName, forKey: .certName)
         try encoderContainer.encode(commonName, forKey: .commonName)
         try encoderContainer.encode(certType, forKey: .certType)
         try encoderContainer.encode(issuer, forKey: .issuer)
         try encoderContainer.encode(startTime, forKey: .startTime)
         try encoderContainer.encode(endTime, forKey: .endTime)
         try encoderContainer.encode(dnsNames, forKey: .dnsNames)
         try encoderContainer.encode(digest, forKey: .digest)
         try encoderContainer.encode(totalCount, forKey: .totalCount)
         try encoderContainer.encode(usedBy, forKey: .usedBy)
    }
}
///  recordValidate
public class RecordValidate:NSObject,Codable{
    /// 校验类型，DNS或File
    var validateType:String?
    /// 校验Key
    var validateKey:String?
    /// 记录类型
    var recordType:String?
    /// 校验Value
    var validateValue:String?



    public override init(){
            super.init()
    }

    enum RecordValidateCodingKeys: String, CodingKey {
        case validateType
        case validateKey
        case recordType
        case validateValue
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: RecordValidateCodingKeys.self)
        if decoderContainer.contains(.validateType)
        {
            self.validateType = try decoderContainer.decode(String?.self, forKey: .validateType)
        }
        if decoderContainer.contains(.validateKey)
        {
            self.validateKey = try decoderContainer.decode(String?.self, forKey: .validateKey)
        }
        if decoderContainer.contains(.recordType)
        {
            self.recordType = try decoderContainer.decode(String?.self, forKey: .recordType)
        }
        if decoderContainer.contains(.validateValue)
        {
            self.validateValue = try decoderContainer.decode(String?.self, forKey: .validateValue)
        }
    }
}
public extension RecordValidate{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: RecordValidateCodingKeys.self)
         try encoderContainer.encode(validateType, forKey: .validateType)
         try encoderContainer.encode(validateKey, forKey: .validateKey)
         try encoderContainer.encode(recordType, forKey: .recordType)
         try encoderContainer.encode(validateValue, forKey: .validateValue)
    }
}
///  certQuotaLimitDetail
public class CertQuotaLimitDetail:NSObject,Codable{
    /// 主键ID
    var id:Int?
    /// 用户名称(用户pin)
    var account:String?
    /// 基于pin的最大可上传证书配额数
    var freeUploadCertCount:Int?
    /// 基于pin的最大可购买免费证书配额数
    var freeDVSingleCount:Int?



    public override init(){
            super.init()
    }

    enum CertQuotaLimitDetailCodingKeys: String, CodingKey {
        case id
        case account
        case freeUploadCertCount
        case freeDVSingleCount
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: CertQuotaLimitDetailCodingKeys.self)
        if decoderContainer.contains(.id)
        {
            self.id = try decoderContainer.decode(Int?.self, forKey: .id)
        }
        if decoderContainer.contains(.account)
        {
            self.account = try decoderContainer.decode(String?.self, forKey: .account)
        }
        if decoderContainer.contains(.freeUploadCertCount)
        {
            self.freeUploadCertCount = try decoderContainer.decode(Int?.self, forKey: .freeUploadCertCount)
        }
        if decoderContainer.contains(.freeDVSingleCount)
        {
            self.freeDVSingleCount = try decoderContainer.decode(Int?.self, forKey: .freeDVSingleCount)
        }
    }
}
public extension CertQuotaLimitDetail{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: CertQuotaLimitDetailCodingKeys.self)
         try encoderContainer.encode(id, forKey: .id)
         try encoderContainer.encode(account, forKey: .account)
         try encoderContainer.encode(freeUploadCertCount, forKey: .freeUploadCertCount)
         try encoderContainer.encode(freeDVSingleCount, forKey: .freeDVSingleCount)
    }
}

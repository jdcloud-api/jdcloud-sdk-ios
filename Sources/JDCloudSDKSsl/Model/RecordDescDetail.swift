/* Copyright 2018 JDCLOUD.COM

   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at

     http:#www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.

   
   

   
   Contact: 

   NOTE: This class is auto generated by the jdcloud code generator program.
 */


import Foundation

///  recordDescDetail
@objc(RecordDescDetail)
public class RecordDescDetail:NSObject,Codable{
    /// 证书申购记录Id
    var recordId:String?
    /// 交易系统订单Id
    var orderId:String?
    /// 证书名称
    var certName:String?
    /// 证书品牌
    var brand:String?
    /// 证书类型
    var certType:String?
    /// 域名个数
    var domainCount:Int?
    /// 证书年限
    var certValidity:Int?
    /// 证书绑定域名
    var commonName:String?
    /// 证书状态,1:未支付,2:待补全信息,3:待下单,4:待域名验证,5:已完成,6:审核不通过,7:已取消
    var state:Int?
    /// 分销商返回的信息，代表订单被取消的原因
    var canceledReason:String?
    /// RecordValidate
    var recordValidate:RecordValidate?
    /// 公司名称
    var corpName:String?
    /// 公司地址
    var corpAddr:String?
    /// 备用域名
    var dnsNames:[String?]?
    /// 联系人邮箱
    var email:String?



    public override init(){
            super.init()
    }

    enum RecordDescDetailCodingKeys: String, CodingKey {
        case recordId
        case orderId
        case certName
        case brand
        case certType
        case domainCount
        case certValidity
        case commonName
        case state
        case canceledReason
        case recordValidate
        case corpName
        case corpAddr
        case dnsNames
        case email
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: RecordDescDetailCodingKeys.self)
        if decoderContainer.contains(.recordId)
        {
            self.recordId = try decoderContainer.decode(String?.self, forKey: .recordId)
        }
        if decoderContainer.contains(.orderId)
        {
            self.orderId = try decoderContainer.decode(String?.self, forKey: .orderId)
        }
        if decoderContainer.contains(.certName)
        {
            self.certName = try decoderContainer.decode(String?.self, forKey: .certName)
        }
        if decoderContainer.contains(.brand)
        {
            self.brand = try decoderContainer.decode(String?.self, forKey: .brand)
        }
        if decoderContainer.contains(.certType)
        {
            self.certType = try decoderContainer.decode(String?.self, forKey: .certType)
        }
        if decoderContainer.contains(.domainCount)
        {
            self.domainCount = try decoderContainer.decode(Int?.self, forKey: .domainCount)
        }
        if decoderContainer.contains(.certValidity)
        {
            self.certValidity = try decoderContainer.decode(Int?.self, forKey: .certValidity)
        }
        if decoderContainer.contains(.commonName)
        {
            self.commonName = try decoderContainer.decode(String?.self, forKey: .commonName)
        }
        if decoderContainer.contains(.state)
        {
            self.state = try decoderContainer.decode(Int?.self, forKey: .state)
        }
        if decoderContainer.contains(.canceledReason)
        {
            self.canceledReason = try decoderContainer.decode(String?.self, forKey: .canceledReason)
        }
        if decoderContainer.contains(.recordValidate)
        {
            self.recordValidate = try decoderContainer.decode(RecordValidate?.self, forKey: .recordValidate)
        }
        if decoderContainer.contains(.corpName)
        {
            self.corpName = try decoderContainer.decode(String?.self, forKey: .corpName)
        }
        if decoderContainer.contains(.corpAddr)
        {
            self.corpAddr = try decoderContainer.decode(String?.self, forKey: .corpAddr)
        }
        if decoderContainer.contains(.dnsNames)
        {
            self.dnsNames = try decoderContainer.decode([String?]?.self, forKey: .dnsNames)
        }
        if decoderContainer.contains(.email)
        {
            self.email = try decoderContainer.decode(String?.self, forKey: .email)
        }
    }
}
public extension RecordDescDetail{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: RecordDescDetailCodingKeys.self)
         try encoderContainer.encode(recordId, forKey: .recordId)
         try encoderContainer.encode(orderId, forKey: .orderId)
         try encoderContainer.encode(certName, forKey: .certName)
         try encoderContainer.encode(brand, forKey: .brand)
         try encoderContainer.encode(certType, forKey: .certType)
         try encoderContainer.encode(domainCount, forKey: .domainCount)
         try encoderContainer.encode(certValidity, forKey: .certValidity)
         try encoderContainer.encode(commonName, forKey: .commonName)
         try encoderContainer.encode(state, forKey: .state)
         try encoderContainer.encode(canceledReason, forKey: .canceledReason)
         try encoderContainer.encode(recordValidate, forKey: .recordValidate)
         try encoderContainer.encode(corpName, forKey: .corpName)
         try encoderContainer.encode(corpAddr, forKey: .corpAddr)
         try encoderContainer.encode(dnsNames, forKey: .dnsNames)
         try encoderContainer.encode(email, forKey: .email)
    }
}

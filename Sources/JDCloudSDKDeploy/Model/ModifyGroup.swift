/* Copyright 2018 JDCLOUD.COM

   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at

     http:#www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.

   
   

   
   Contact: 

   NOTE: This class is auto generated by the jdcloud code generator program.
 */


import Foundation

///  modifyGroup
@objc(ModifyGroup)
public class ModifyGroup:NSObject,Codable{
    /// 描述
    var desc:String?
    /// 部署实例（滚动）
    var instances:[String?]?
    /// 部署实例（蓝）
    var blueInstances:[String?]?
    /// 部署实例（绿）
    var greenInstances:[String?]?
    /// 并发单位
    var concurrencyUnit:Int?
    /// 并发机器数
    var concurrencyNum:Int?
    /// 并发度
    var concurrencyPct:Int?
    /// 负载均衡：1启动，2禁用
    var lbStatus:Int?
    /// lb实例
    var lbInstance:String?
    /// lb lb_backend
    var lbBackend:String?
    /// 同名文件处理方式：1部署失败，2覆盖，3保留
    var repeatPolicy:Int?
    /// 通知频率：1异常发送，2每次发送
    var noticeTrigger:Int?
    /// 通知方式：1消息，2邮件，3短信
    var noticeMethod:[String?]?
    /// 自动回滚：1开启，2禁用
    var rollback:Int?
    /// 分布式服务框架ID
    var jdsfRegisterId:String?



    public override init(){
            super.init()
    }

    enum ModifyGroupCodingKeys: String, CodingKey {
        case desc
        case instances
        case blueInstances
        case greenInstances
        case concurrencyUnit
        case concurrencyNum
        case concurrencyPct
        case lbStatus
        case lbInstance
        case lbBackend
        case repeatPolicy
        case noticeTrigger
        case noticeMethod
        case rollback
        case jdsfRegisterId
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: ModifyGroupCodingKeys.self)
        if decoderContainer.contains(.desc)
        {
            self.desc = try decoderContainer.decode(String?.self, forKey: .desc)
        }
        if decoderContainer.contains(.instances)
        {
            self.instances = try decoderContainer.decode([String?]?.self, forKey: .instances)
        }
        if decoderContainer.contains(.blueInstances)
        {
            self.blueInstances = try decoderContainer.decode([String?]?.self, forKey: .blueInstances)
        }
        if decoderContainer.contains(.greenInstances)
        {
            self.greenInstances = try decoderContainer.decode([String?]?.self, forKey: .greenInstances)
        }
        if decoderContainer.contains(.concurrencyUnit)
        {
            self.concurrencyUnit = try decoderContainer.decode(Int?.self, forKey: .concurrencyUnit)
        }
        if decoderContainer.contains(.concurrencyNum)
        {
            self.concurrencyNum = try decoderContainer.decode(Int?.self, forKey: .concurrencyNum)
        }
        if decoderContainer.contains(.concurrencyPct)
        {
            self.concurrencyPct = try decoderContainer.decode(Int?.self, forKey: .concurrencyPct)
        }
        if decoderContainer.contains(.lbStatus)
        {
            self.lbStatus = try decoderContainer.decode(Int?.self, forKey: .lbStatus)
        }
        if decoderContainer.contains(.lbInstance)
        {
            self.lbInstance = try decoderContainer.decode(String?.self, forKey: .lbInstance)
        }
        if decoderContainer.contains(.lbBackend)
        {
            self.lbBackend = try decoderContainer.decode(String?.self, forKey: .lbBackend)
        }
        if decoderContainer.contains(.repeatPolicy)
        {
            self.repeatPolicy = try decoderContainer.decode(Int?.self, forKey: .repeatPolicy)
        }
        if decoderContainer.contains(.noticeTrigger)
        {
            self.noticeTrigger = try decoderContainer.decode(Int?.self, forKey: .noticeTrigger)
        }
        if decoderContainer.contains(.noticeMethod)
        {
            self.noticeMethod = try decoderContainer.decode([String?]?.self, forKey: .noticeMethod)
        }
        if decoderContainer.contains(.rollback)
        {
            self.rollback = try decoderContainer.decode(Int?.self, forKey: .rollback)
        }
        if decoderContainer.contains(.jdsfRegisterId)
        {
            self.jdsfRegisterId = try decoderContainer.decode(String?.self, forKey: .jdsfRegisterId)
        }
    }
}
public extension ModifyGroup{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: ModifyGroupCodingKeys.self)
         try encoderContainer.encode(desc, forKey: .desc)
         try encoderContainer.encode(instances, forKey: .instances)
         try encoderContainer.encode(blueInstances, forKey: .blueInstances)
         try encoderContainer.encode(greenInstances, forKey: .greenInstances)
         try encoderContainer.encode(concurrencyUnit, forKey: .concurrencyUnit)
         try encoderContainer.encode(concurrencyNum, forKey: .concurrencyNum)
         try encoderContainer.encode(concurrencyPct, forKey: .concurrencyPct)
         try encoderContainer.encode(lbStatus, forKey: .lbStatus)
         try encoderContainer.encode(lbInstance, forKey: .lbInstance)
         try encoderContainer.encode(lbBackend, forKey: .lbBackend)
         try encoderContainer.encode(repeatPolicy, forKey: .repeatPolicy)
         try encoderContainer.encode(noticeTrigger, forKey: .noticeTrigger)
         try encoderContainer.encode(noticeMethod, forKey: .noticeMethod)
         try encoderContainer.encode(rollback, forKey: .rollback)
         try encoderContainer.encode(jdsfRegisterId, forKey: .jdsfRegisterId)
    }
}

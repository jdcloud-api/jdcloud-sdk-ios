/* Copyright 2018 JDCLOUD.COM

   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at

     http:#www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.

   
   

   
   Contact: 

   NOTE: This class is auto generated by the jdcloud code generator program.
 */


import Foundation

///  createGroup
@objc(CreateGroup)
public class CreateGroup:NSObject,Codable{
    /// 部署组名称
    /// Required:true
    var groupName:String
    /// 应用ID
    /// Required:true
    var appId:String
    /// 描述
    var desc:String?
    /// 部署方式：1滚动部署，2蓝绿部署
    /// Required:true
    var deployMethod:Int
    /// 部署实例（滚动部署）
    var instances:[String?]?
    /// 部署实例（蓝绿部署蓝组）
    var blueInstances:[String?]?
    /// 部署实例（蓝绿部署绿组）
    var greenInstances:[String?]?
    /// 并发单位
    var concurrencyUnit:Int?
    /// 并发机器数
    var concurrencyNum:Int?
    /// 并发度
    var concurrencyPct:Int?
    /// 负载均衡：1启动，2禁用
    /// Required:true
    var lbStatus:Int
    /// lb实例
    var lbInstance:String?
    /// lb lb后端服务
    var lbBackend:String?
    /// 同名文件处理方式：1部署失败，2覆盖，3保留
    /// Required:true
    var repeatPolicy:Int
    /// 通知频率：0不发送，1消息，2邮件，3短信
    /// Required:true
    var noticeTrigger:Int
    /// 通知方式：1消息，2邮件，3短信
    var noticeMethod:[String?]?
    /// 自动回滚：1开启，2禁用
    /// Required:true
    var rollback:Int
    /// 分布式服务框架ID
    var jdsfRegisterId:String?



    public  init(groupName:String,appId:String,deployMethod:Int,lbStatus:Int,repeatPolicy:Int,noticeTrigger:Int,rollback:Int){
             self.groupName = groupName
             self.appId = appId
             self.deployMethod = deployMethod
             self.lbStatus = lbStatus
             self.repeatPolicy = repeatPolicy
             self.noticeTrigger = noticeTrigger
             self.rollback = rollback
    }

    enum CreateGroupCodingKeys: String, CodingKey {
        case groupName
        case appId
        case desc
        case deployMethod
        case instances
        case blueInstances
        case greenInstances
        case concurrencyUnit
        case concurrencyNum
        case concurrencyPct
        case lbStatus
        case lbInstance
        case lbBackend
        case repeatPolicy
        case noticeTrigger
        case noticeMethod
        case rollback
        case jdsfRegisterId
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: CreateGroupCodingKeys.self)
        self.groupName = try decoderContainer.decode(String.self, forKey: .groupName)
        self.appId = try decoderContainer.decode(String.self, forKey: .appId)
        if decoderContainer.contains(.desc)
        {
            self.desc = try decoderContainer.decode(String?.self, forKey: .desc)
        }
        self.deployMethod = try decoderContainer.decode(Int.self, forKey: .deployMethod)
        if decoderContainer.contains(.instances)
        {
            self.instances = try decoderContainer.decode([String?]?.self, forKey: .instances)
        }
        if decoderContainer.contains(.blueInstances)
        {
            self.blueInstances = try decoderContainer.decode([String?]?.self, forKey: .blueInstances)
        }
        if decoderContainer.contains(.greenInstances)
        {
            self.greenInstances = try decoderContainer.decode([String?]?.self, forKey: .greenInstances)
        }
        if decoderContainer.contains(.concurrencyUnit)
        {
            self.concurrencyUnit = try decoderContainer.decode(Int?.self, forKey: .concurrencyUnit)
        }
        if decoderContainer.contains(.concurrencyNum)
        {
            self.concurrencyNum = try decoderContainer.decode(Int?.self, forKey: .concurrencyNum)
        }
        if decoderContainer.contains(.concurrencyPct)
        {
            self.concurrencyPct = try decoderContainer.decode(Int?.self, forKey: .concurrencyPct)
        }
        self.lbStatus = try decoderContainer.decode(Int.self, forKey: .lbStatus)
        if decoderContainer.contains(.lbInstance)
        {
            self.lbInstance = try decoderContainer.decode(String?.self, forKey: .lbInstance)
        }
        if decoderContainer.contains(.lbBackend)
        {
            self.lbBackend = try decoderContainer.decode(String?.self, forKey: .lbBackend)
        }
        self.repeatPolicy = try decoderContainer.decode(Int.self, forKey: .repeatPolicy)
        self.noticeTrigger = try decoderContainer.decode(Int.self, forKey: .noticeTrigger)
        if decoderContainer.contains(.noticeMethod)
        {
            self.noticeMethod = try decoderContainer.decode([String?]?.self, forKey: .noticeMethod)
        }
        self.rollback = try decoderContainer.decode(Int.self, forKey: .rollback)
        if decoderContainer.contains(.jdsfRegisterId)
        {
            self.jdsfRegisterId = try decoderContainer.decode(String?.self, forKey: .jdsfRegisterId)
        }
    }
}
public extension CreateGroup{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: CreateGroupCodingKeys.self)
         try encoderContainer.encode(groupName, forKey: .groupName)
         try encoderContainer.encode(appId, forKey: .appId)
         try encoderContainer.encode(desc, forKey: .desc)
         try encoderContainer.encode(deployMethod, forKey: .deployMethod)
         try encoderContainer.encode(instances, forKey: .instances)
         try encoderContainer.encode(blueInstances, forKey: .blueInstances)
         try encoderContainer.encode(greenInstances, forKey: .greenInstances)
         try encoderContainer.encode(concurrencyUnit, forKey: .concurrencyUnit)
         try encoderContainer.encode(concurrencyNum, forKey: .concurrencyNum)
         try encoderContainer.encode(concurrencyPct, forKey: .concurrencyPct)
         try encoderContainer.encode(lbStatus, forKey: .lbStatus)
         try encoderContainer.encode(lbInstance, forKey: .lbInstance)
         try encoderContainer.encode(lbBackend, forKey: .lbBackend)
         try encoderContainer.encode(repeatPolicy, forKey: .repeatPolicy)
         try encoderContainer.encode(noticeTrigger, forKey: .noticeTrigger)
         try encoderContainer.encode(noticeMethod, forKey: .noticeMethod)
         try encoderContainer.encode(rollback, forKey: .rollback)
         try encoderContainer.encode(jdsfRegisterId, forKey: .jdsfRegisterId)
    }
}

/* Copyright 2018 JDCLOUD.COM

   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at

     http:#www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.

   用户
   云部署pin相关接口

   OpenAPI spec version: v1
   Contact: 

   NOTE: This class is auto generated by the jdcloud code generator program.
 */


import Foundation
///  milestone
public class Milestone:NSObject,Codable{
    /// 里程碑ID
    var milestoneId:String?
    /// 应用ID
    var appId:String?
    /// 应用名称
    var appName:String?
    /// 地域
    var regionId:String?
    /// 描述
    var desc:String?
    /// 部署方式：1滚动部署，2蓝绿部署
    var deployMethod:Int?
    /// 部署来源：1url，2云编译，3云存储
    var deploySource:Int?
    /// 下载url
    var downloadUrl:String?
    /// md5
    var md5:String?
    /// 云编译项目名
    var compileProject:String?
    /// 云编译构建序号
    var compileSeries:String?
    /// 云存储空间
    var ossSpace:String?
    /// 云存储目录
    var ossDir:String?
    /// 文件类型：1.tar，2.zip,3.tar.gz
    var fileType:Int?
    /// 最新部署时间
    var lastDeployTime:Int?
    /// 部署组
    var deployGroup:[String?]?



    public override init(){
            super.init()
    }

    enum MilestoneCodingKeys: String, CodingKey {
        case milestoneId
        case appId
        case appName
        case regionId
        case desc
        case deployMethod
        case deploySource
        case downloadUrl
        case md5
        case compileProject
        case compileSeries
        case ossSpace
        case ossDir
        case fileType
        case lastDeployTime
        case deployGroup
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: MilestoneCodingKeys.self)
        if decoderContainer.contains(.milestoneId)
        {
            self.milestoneId = try decoderContainer.decode(String?.self, forKey: .milestoneId)
        }
        if decoderContainer.contains(.appId)
        {
            self.appId = try decoderContainer.decode(String?.self, forKey: .appId)
        }
        if decoderContainer.contains(.appName)
        {
            self.appName = try decoderContainer.decode(String?.self, forKey: .appName)
        }
        if decoderContainer.contains(.regionId)
        {
            self.regionId = try decoderContainer.decode(String?.self, forKey: .regionId)
        }
        if decoderContainer.contains(.desc)
        {
            self.desc = try decoderContainer.decode(String?.self, forKey: .desc)
        }
        if decoderContainer.contains(.deployMethod)
        {
            self.deployMethod = try decoderContainer.decode(Int?.self, forKey: .deployMethod)
        }
        if decoderContainer.contains(.deploySource)
        {
            self.deploySource = try decoderContainer.decode(Int?.self, forKey: .deploySource)
        }
        if decoderContainer.contains(.downloadUrl)
        {
            self.downloadUrl = try decoderContainer.decode(String?.self, forKey: .downloadUrl)
        }
        if decoderContainer.contains(.md5)
        {
            self.md5 = try decoderContainer.decode(String?.self, forKey: .md5)
        }
        if decoderContainer.contains(.compileProject)
        {
            self.compileProject = try decoderContainer.decode(String?.self, forKey: .compileProject)
        }
        if decoderContainer.contains(.compileSeries)
        {
            self.compileSeries = try decoderContainer.decode(String?.self, forKey: .compileSeries)
        }
        if decoderContainer.contains(.ossSpace)
        {
            self.ossSpace = try decoderContainer.decode(String?.self, forKey: .ossSpace)
        }
        if decoderContainer.contains(.ossDir)
        {
            self.ossDir = try decoderContainer.decode(String?.self, forKey: .ossDir)
        }
        if decoderContainer.contains(.fileType)
        {
            self.fileType = try decoderContainer.decode(Int?.self, forKey: .fileType)
        }
        if decoderContainer.contains(.lastDeployTime)
        {
            self.lastDeployTime = try decoderContainer.decode(Int?.self, forKey: .lastDeployTime)
        }
        if decoderContainer.contains(.deployGroup)
        {
            self.deployGroup = try decoderContainer.decode([String?]?.self, forKey: .deployGroup)
        }
    }
}
public extension Milestone{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: MilestoneCodingKeys.self)
         try encoderContainer.encode(milestoneId, forKey: .milestoneId)
         try encoderContainer.encode(appId, forKey: .appId)
         try encoderContainer.encode(appName, forKey: .appName)
         try encoderContainer.encode(regionId, forKey: .regionId)
         try encoderContainer.encode(desc, forKey: .desc)
         try encoderContainer.encode(deployMethod, forKey: .deployMethod)
         try encoderContainer.encode(deploySource, forKey: .deploySource)
         try encoderContainer.encode(downloadUrl, forKey: .downloadUrl)
         try encoderContainer.encode(md5, forKey: .md5)
         try encoderContainer.encode(compileProject, forKey: .compileProject)
         try encoderContainer.encode(compileSeries, forKey: .compileSeries)
         try encoderContainer.encode(ossSpace, forKey: .ossSpace)
         try encoderContainer.encode(ossDir, forKey: .ossDir)
         try encoderContainer.encode(fileType, forKey: .fileType)
         try encoderContainer.encode(lastDeployTime, forKey: .lastDeployTime)
         try encoderContainer.encode(deployGroup, forKey: .deployGroup)
    }
}
///  modifyApp
public class ModifyApp:NSObject,Codable{
    /// 描述
    /// Required:true
    var desc:String



    public  init(desc:String){
             self.desc = desc
    }

    enum ModifyAppCodingKeys: String, CodingKey {
        case desc
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: ModifyAppCodingKeys.self)
        self.desc = try decoderContainer.decode(String.self, forKey: .desc)
    }
}
public extension ModifyApp{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: ModifyAppCodingKeys.self)
         try encoderContainer.encode(desc, forKey: .desc)
    }
}
///  app
public class App:NSObject,Codable{
    /// 应用ID
    var appId:String?
    /// 应用名称
    var appName:String?
    /// 地域
    var regionId:String?
    /// 部署平台：1云主机，2原生容器
    var platform:Int?
    /// 使用分布式服务框架：0不使用，1使用
    var jdsfEnabled:Int?
    /// 描述
    var desc:String?
    /// 上次部署时间
    var lastDeployTime:Int?



    public override init(){
            super.init()
    }

    enum AppCodingKeys: String, CodingKey {
        case appId
        case appName
        case regionId
        case platform
        case jdsfEnabled
        case desc
        case lastDeployTime
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: AppCodingKeys.self)
        if decoderContainer.contains(.appId)
        {
            self.appId = try decoderContainer.decode(String?.self, forKey: .appId)
        }
        if decoderContainer.contains(.appName)
        {
            self.appName = try decoderContainer.decode(String?.self, forKey: .appName)
        }
        if decoderContainer.contains(.regionId)
        {
            self.regionId = try decoderContainer.decode(String?.self, forKey: .regionId)
        }
        if decoderContainer.contains(.platform)
        {
            self.platform = try decoderContainer.decode(Int?.self, forKey: .platform)
        }
        if decoderContainer.contains(.jdsfEnabled)
        {
            self.jdsfEnabled = try decoderContainer.decode(Int?.self, forKey: .jdsfEnabled)
        }
        if decoderContainer.contains(.desc)
        {
            self.desc = try decoderContainer.decode(String?.self, forKey: .desc)
        }
        if decoderContainer.contains(.lastDeployTime)
        {
            self.lastDeployTime = try decoderContainer.decode(Int?.self, forKey: .lastDeployTime)
        }
    }
}
public extension App{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: AppCodingKeys.self)
         try encoderContainer.encode(appId, forKey: .appId)
         try encoderContainer.encode(appName, forKey: .appName)
         try encoderContainer.encode(regionId, forKey: .regionId)
         try encoderContainer.encode(platform, forKey: .platform)
         try encoderContainer.encode(jdsfEnabled, forKey: .jdsfEnabled)
         try encoderContainer.encode(desc, forKey: .desc)
         try encoderContainer.encode(lastDeployTime, forKey: .lastDeployTime)
    }
}
///  createApp
public class CreateApp:NSObject,Codable{
    /// 应用名称
    /// Required:true
    var appName:String
    /// 部署平台
    /// Required:true
    var platform:Int
    /// 使用分布式服务框架：0不使用，1使用
    var jdsfEnabled:Int?
    /// 描述
    var desc:String?



    public  init(appName:String,platform:Int){
             self.appName = appName
             self.platform = platform
    }

    enum CreateAppCodingKeys: String, CodingKey {
        case appName
        case platform
        case jdsfEnabled
        case desc
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: CreateAppCodingKeys.self)
        self.appName = try decoderContainer.decode(String.self, forKey: .appName)
        self.platform = try decoderContainer.decode(Int.self, forKey: .platform)
        if decoderContainer.contains(.jdsfEnabled)
        {
            self.jdsfEnabled = try decoderContainer.decode(Int?.self, forKey: .jdsfEnabled)
        }
        if decoderContainer.contains(.desc)
        {
            self.desc = try decoderContainer.decode(String?.self, forKey: .desc)
        }
    }
}
public extension CreateApp{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: CreateAppCodingKeys.self)
         try encoderContainer.encode(appName, forKey: .appName)
         try encoderContainer.encode(platform, forKey: .platform)
         try encoderContainer.encode(jdsfEnabled, forKey: .jdsfEnabled)
         try encoderContainer.encode(desc, forKey: .desc)
    }
}
///  deployStage
public class DeployStage:NSObject,Codable{
    /// code
    var stageCode:Int?
    /// name
    var stageName:String?
    /// 状态（0未执行，1执行，2失败）
    var stageStatus:Int?
    /// 描述
    var stageMessage:String?
    /// 部署完成的实例数
    var succeedCount:Int?
    /// 所有实例数
    var totalCount:Int?
    /// CreateTime
    var createTime:Int?
    /// UpdateTime
    var updateTime:Int?



    public override init(){
            super.init()
    }

    enum DeployStageCodingKeys: String, CodingKey {
        case stageCode
        case stageName
        case stageStatus
        case stageMessage
        case succeedCount
        case totalCount
        case createTime
        case updateTime
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: DeployStageCodingKeys.self)
        if decoderContainer.contains(.stageCode)
        {
            self.stageCode = try decoderContainer.decode(Int?.self, forKey: .stageCode)
        }
        if decoderContainer.contains(.stageName)
        {
            self.stageName = try decoderContainer.decode(String?.self, forKey: .stageName)
        }
        if decoderContainer.contains(.stageStatus)
        {
            self.stageStatus = try decoderContainer.decode(Int?.self, forKey: .stageStatus)
        }
        if decoderContainer.contains(.stageMessage)
        {
            self.stageMessage = try decoderContainer.decode(String?.self, forKey: .stageMessage)
        }
        if decoderContainer.contains(.succeedCount)
        {
            self.succeedCount = try decoderContainer.decode(Int?.self, forKey: .succeedCount)
        }
        if decoderContainer.contains(.totalCount)
        {
            self.totalCount = try decoderContainer.decode(Int?.self, forKey: .totalCount)
        }
        if decoderContainer.contains(.createTime)
        {
            self.createTime = try decoderContainer.decode(Int?.self, forKey: .createTime)
        }
        if decoderContainer.contains(.updateTime)
        {
            self.updateTime = try decoderContainer.decode(Int?.self, forKey: .updateTime)
        }
    }
}
public extension DeployStage{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: DeployStageCodingKeys.self)
         try encoderContainer.encode(stageCode, forKey: .stageCode)
         try encoderContainer.encode(stageName, forKey: .stageName)
         try encoderContainer.encode(stageStatus, forKey: .stageStatus)
         try encoderContainer.encode(stageMessage, forKey: .stageMessage)
         try encoderContainer.encode(succeedCount, forKey: .succeedCount)
         try encoderContainer.encode(totalCount, forKey: .totalCount)
         try encoderContainer.encode(createTime, forKey: .createTime)
         try encoderContainer.encode(updateTime, forKey: .updateTime)
    }
}
///  createDeploy
public class CreateDeploy:NSObject,Codable{
    /// 部署组ID，部署组的唯一标识
    /// Required:true
    var groupId:String
    /// 描述
    var desc:String?
    /// 部署来源：1url，2云编译，3云存储
    /// Required:true
    var deploySource:Int
    /// 部署操作
    var deployCmd:String?
    /// 1使用输入的操作，2使用程序自带操作
    var cmdSource:Int?
    /// 部署操作展示格式：1form,2ymal
    var cmdType:Int?
    /// 项目类型 1tomcat,2
    var productType:Int?
    /// 下载url
    var downloadUrl:String?
    /// md5
    var md5:String?
    /// 云编译项目名
    var compileProject:String?
    /// 云编译构建序号
    var compileSeries:String?
    /// 云存储空间
    var ossSpace:String?
    /// 云存储目录
    var ossDir:String?
    /// 文件类型：1.tar，2.zip,3.tar.gz
    var fileType:Int?



    public  init(groupId:String,deploySource:Int){
             self.groupId = groupId
             self.deploySource = deploySource
    }

    enum CreateDeployCodingKeys: String, CodingKey {
        case groupId
        case desc
        case deploySource
        case deployCmd
        case cmdSource
        case cmdType
        case productType
        case downloadUrl
        case md5
        case compileProject
        case compileSeries
        case ossSpace
        case ossDir
        case fileType
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: CreateDeployCodingKeys.self)
        self.groupId = try decoderContainer.decode(String.self, forKey: .groupId)
        if decoderContainer.contains(.desc)
        {
            self.desc = try decoderContainer.decode(String?.self, forKey: .desc)
        }
        self.deploySource = try decoderContainer.decode(Int.self, forKey: .deploySource)
        if decoderContainer.contains(.deployCmd)
        {
            self.deployCmd = try decoderContainer.decode(String?.self, forKey: .deployCmd)
        }
        if decoderContainer.contains(.cmdSource)
        {
            self.cmdSource = try decoderContainer.decode(Int?.self, forKey: .cmdSource)
        }
        if decoderContainer.contains(.cmdType)
        {
            self.cmdType = try decoderContainer.decode(Int?.self, forKey: .cmdType)
        }
        if decoderContainer.contains(.productType)
        {
            self.productType = try decoderContainer.decode(Int?.self, forKey: .productType)
        }
        if decoderContainer.contains(.downloadUrl)
        {
            self.downloadUrl = try decoderContainer.decode(String?.self, forKey: .downloadUrl)
        }
        if decoderContainer.contains(.md5)
        {
            self.md5 = try decoderContainer.decode(String?.self, forKey: .md5)
        }
        if decoderContainer.contains(.compileProject)
        {
            self.compileProject = try decoderContainer.decode(String?.self, forKey: .compileProject)
        }
        if decoderContainer.contains(.compileSeries)
        {
            self.compileSeries = try decoderContainer.decode(String?.self, forKey: .compileSeries)
        }
        if decoderContainer.contains(.ossSpace)
        {
            self.ossSpace = try decoderContainer.decode(String?.self, forKey: .ossSpace)
        }
        if decoderContainer.contains(.ossDir)
        {
            self.ossDir = try decoderContainer.decode(String?.self, forKey: .ossDir)
        }
        if decoderContainer.contains(.fileType)
        {
            self.fileType = try decoderContainer.decode(Int?.self, forKey: .fileType)
        }
    }
}
public extension CreateDeploy{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: CreateDeployCodingKeys.self)
         try encoderContainer.encode(groupId, forKey: .groupId)
         try encoderContainer.encode(desc, forKey: .desc)
         try encoderContainer.encode(deploySource, forKey: .deploySource)
         try encoderContainer.encode(deployCmd, forKey: .deployCmd)
         try encoderContainer.encode(cmdSource, forKey: .cmdSource)
         try encoderContainer.encode(cmdType, forKey: .cmdType)
         try encoderContainer.encode(productType, forKey: .productType)
         try encoderContainer.encode(downloadUrl, forKey: .downloadUrl)
         try encoderContainer.encode(md5, forKey: .md5)
         try encoderContainer.encode(compileProject, forKey: .compileProject)
         try encoderContainer.encode(compileSeries, forKey: .compileSeries)
         try encoderContainer.encode(ossSpace, forKey: .ossSpace)
         try encoderContainer.encode(ossDir, forKey: .ossDir)
         try encoderContainer.encode(fileType, forKey: .fileType)
    }
}
///  deploy
public class Deploy:NSObject,Codable{
    /// 上线单ID
    var deployId:String?
    /// 应用ID
    var appId:String?
    /// 应用名称
    var appName:String?
    /// 部署组名称
    var groupId:String?
    /// 部署组ID
    var groupName:String?
    /// 地域
    var regionId:String?
    /// 部署开始时间
    var startTime:Int?
    /// 部署结束时间
    var endTime:Int?
    /// 部署状态 0待部署, 1部署中, 2成功, 3失败, 4回滚中， 5回滚成功， 6回滚失败， 7已取消
    var deployStatus:Int?
    /// 描述
    var desc:String?
    /// 部署方式：1滚动部署，2蓝绿部署
    var deployMethod:Int?
    /// 部署来源：1url，2云编译，3云存储
    var deploySource:Int?
    /// 部署操作
    var deployCmd:String?
    /// 1使用输入的操作，2使用程序自带操作
    var cmdSource:Int?
    /// 部署操作展示格式：1form,2ymal
    var cmdType:Int?
    /// 项目类型 1tomcat,2
    var productType:Int?
    /// 下载url
    var downloadUrl:String?
    /// md5
    var md5:String?
    /// 云编译项目名
    var compileProject:String?
    /// 云编译构建序号
    var compileSeries:String?
    /// 云存储空间
    var ossSpace:String?
    /// 云存储目录
    var ossDir:String?
    /// 文件类型：1.tar，2.zio,3.tar.gz
    var fileType:Int?
    /// 是否可回滚 1是，2否
    var rollbackAble:Int?
    /// 并发单位
    var concurrencyUnit:Int?
    /// 并发机器数
    var concurrencyNum:Int?
    /// 并发度
    var concurrencyPct:Int?
    /// 负载均衡：1启动，2禁用
    var lbStatus:Int?
    /// lb实例
    var lbInstance:String?
    /// lb 后端实例
    var lbBackend:String?
    /// 同名文件处理方式：1部署失败，2覆盖，3保留
    var repeatPolicy:Int?
    /// 通知频率：1异常发送，2每次发送
    var noticeTrigger:Int?
    /// 通知方式：1消息，2邮件，3短信
    var noticeMethod:[String?]?
    /// 使用分布式服务框架：0不使用，1使用
    var jdsfEnabled:Int?



    public override init(){
            super.init()
    }

    enum DeployCodingKeys: String, CodingKey {
        case deployId
        case appId
        case appName
        case groupId
        case groupName
        case regionId
        case startTime
        case endTime
        case deployStatus
        case desc
        case deployMethod
        case deploySource
        case deployCmd
        case cmdSource
        case cmdType
        case productType
        case downloadUrl
        case md5
        case compileProject
        case compileSeries
        case ossSpace
        case ossDir
        case fileType
        case rollbackAble
        case concurrencyUnit
        case concurrencyNum
        case concurrencyPct
        case lbStatus
        case lbInstance
        case lbBackend
        case repeatPolicy
        case noticeTrigger
        case noticeMethod
        case jdsfEnabled
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: DeployCodingKeys.self)
        if decoderContainer.contains(.deployId)
        {
            self.deployId = try decoderContainer.decode(String?.self, forKey: .deployId)
        }
        if decoderContainer.contains(.appId)
        {
            self.appId = try decoderContainer.decode(String?.self, forKey: .appId)
        }
        if decoderContainer.contains(.appName)
        {
            self.appName = try decoderContainer.decode(String?.self, forKey: .appName)
        }
        if decoderContainer.contains(.groupId)
        {
            self.groupId = try decoderContainer.decode(String?.self, forKey: .groupId)
        }
        if decoderContainer.contains(.groupName)
        {
            self.groupName = try decoderContainer.decode(String?.self, forKey: .groupName)
        }
        if decoderContainer.contains(.regionId)
        {
            self.regionId = try decoderContainer.decode(String?.self, forKey: .regionId)
        }
        if decoderContainer.contains(.startTime)
        {
            self.startTime = try decoderContainer.decode(Int?.self, forKey: .startTime)
        }
        if decoderContainer.contains(.endTime)
        {
            self.endTime = try decoderContainer.decode(Int?.self, forKey: .endTime)
        }
        if decoderContainer.contains(.deployStatus)
        {
            self.deployStatus = try decoderContainer.decode(Int?.self, forKey: .deployStatus)
        }
        if decoderContainer.contains(.desc)
        {
            self.desc = try decoderContainer.decode(String?.self, forKey: .desc)
        }
        if decoderContainer.contains(.deployMethod)
        {
            self.deployMethod = try decoderContainer.decode(Int?.self, forKey: .deployMethod)
        }
        if decoderContainer.contains(.deploySource)
        {
            self.deploySource = try decoderContainer.decode(Int?.self, forKey: .deploySource)
        }
        if decoderContainer.contains(.deployCmd)
        {
            self.deployCmd = try decoderContainer.decode(String?.self, forKey: .deployCmd)
        }
        if decoderContainer.contains(.cmdSource)
        {
            self.cmdSource = try decoderContainer.decode(Int?.self, forKey: .cmdSource)
        }
        if decoderContainer.contains(.cmdType)
        {
            self.cmdType = try decoderContainer.decode(Int?.self, forKey: .cmdType)
        }
        if decoderContainer.contains(.productType)
        {
            self.productType = try decoderContainer.decode(Int?.self, forKey: .productType)
        }
        if decoderContainer.contains(.downloadUrl)
        {
            self.downloadUrl = try decoderContainer.decode(String?.self, forKey: .downloadUrl)
        }
        if decoderContainer.contains(.md5)
        {
            self.md5 = try decoderContainer.decode(String?.self, forKey: .md5)
        }
        if decoderContainer.contains(.compileProject)
        {
            self.compileProject = try decoderContainer.decode(String?.self, forKey: .compileProject)
        }
        if decoderContainer.contains(.compileSeries)
        {
            self.compileSeries = try decoderContainer.decode(String?.self, forKey: .compileSeries)
        }
        if decoderContainer.contains(.ossSpace)
        {
            self.ossSpace = try decoderContainer.decode(String?.self, forKey: .ossSpace)
        }
        if decoderContainer.contains(.ossDir)
        {
            self.ossDir = try decoderContainer.decode(String?.self, forKey: .ossDir)
        }
        if decoderContainer.contains(.fileType)
        {
            self.fileType = try decoderContainer.decode(Int?.self, forKey: .fileType)
        }
        if decoderContainer.contains(.rollbackAble)
        {
            self.rollbackAble = try decoderContainer.decode(Int?.self, forKey: .rollbackAble)
        }
        if decoderContainer.contains(.concurrencyUnit)
        {
            self.concurrencyUnit = try decoderContainer.decode(Int?.self, forKey: .concurrencyUnit)
        }
        if decoderContainer.contains(.concurrencyNum)
        {
            self.concurrencyNum = try decoderContainer.decode(Int?.self, forKey: .concurrencyNum)
        }
        if decoderContainer.contains(.concurrencyPct)
        {
            self.concurrencyPct = try decoderContainer.decode(Int?.self, forKey: .concurrencyPct)
        }
        if decoderContainer.contains(.lbStatus)
        {
            self.lbStatus = try decoderContainer.decode(Int?.self, forKey: .lbStatus)
        }
        if decoderContainer.contains(.lbInstance)
        {
            self.lbInstance = try decoderContainer.decode(String?.self, forKey: .lbInstance)
        }
        if decoderContainer.contains(.lbBackend)
        {
            self.lbBackend = try decoderContainer.decode(String?.self, forKey: .lbBackend)
        }
        if decoderContainer.contains(.repeatPolicy)
        {
            self.repeatPolicy = try decoderContainer.decode(Int?.self, forKey: .repeatPolicy)
        }
        if decoderContainer.contains(.noticeTrigger)
        {
            self.noticeTrigger = try decoderContainer.decode(Int?.self, forKey: .noticeTrigger)
        }
        if decoderContainer.contains(.noticeMethod)
        {
            self.noticeMethod = try decoderContainer.decode([String?]?.self, forKey: .noticeMethod)
        }
        if decoderContainer.contains(.jdsfEnabled)
        {
            self.jdsfEnabled = try decoderContainer.decode(Int?.self, forKey: .jdsfEnabled)
        }
    }
}
public extension Deploy{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: DeployCodingKeys.self)
         try encoderContainer.encode(deployId, forKey: .deployId)
         try encoderContainer.encode(appId, forKey: .appId)
         try encoderContainer.encode(appName, forKey: .appName)
         try encoderContainer.encode(groupId, forKey: .groupId)
         try encoderContainer.encode(groupName, forKey: .groupName)
         try encoderContainer.encode(regionId, forKey: .regionId)
         try encoderContainer.encode(startTime, forKey: .startTime)
         try encoderContainer.encode(endTime, forKey: .endTime)
         try encoderContainer.encode(deployStatus, forKey: .deployStatus)
         try encoderContainer.encode(desc, forKey: .desc)
         try encoderContainer.encode(deployMethod, forKey: .deployMethod)
         try encoderContainer.encode(deploySource, forKey: .deploySource)
         try encoderContainer.encode(deployCmd, forKey: .deployCmd)
         try encoderContainer.encode(cmdSource, forKey: .cmdSource)
         try encoderContainer.encode(cmdType, forKey: .cmdType)
         try encoderContainer.encode(productType, forKey: .productType)
         try encoderContainer.encode(downloadUrl, forKey: .downloadUrl)
         try encoderContainer.encode(md5, forKey: .md5)
         try encoderContainer.encode(compileProject, forKey: .compileProject)
         try encoderContainer.encode(compileSeries, forKey: .compileSeries)
         try encoderContainer.encode(ossSpace, forKey: .ossSpace)
         try encoderContainer.encode(ossDir, forKey: .ossDir)
         try encoderContainer.encode(fileType, forKey: .fileType)
         try encoderContainer.encode(rollbackAble, forKey: .rollbackAble)
         try encoderContainer.encode(concurrencyUnit, forKey: .concurrencyUnit)
         try encoderContainer.encode(concurrencyNum, forKey: .concurrencyNum)
         try encoderContainer.encode(concurrencyPct, forKey: .concurrencyPct)
         try encoderContainer.encode(lbStatus, forKey: .lbStatus)
         try encoderContainer.encode(lbInstance, forKey: .lbInstance)
         try encoderContainer.encode(lbBackend, forKey: .lbBackend)
         try encoderContainer.encode(repeatPolicy, forKey: .repeatPolicy)
         try encoderContainer.encode(noticeTrigger, forKey: .noticeTrigger)
         try encoderContainer.encode(noticeMethod, forKey: .noticeMethod)
         try encoderContainer.encode(jdsfEnabled, forKey: .jdsfEnabled)
    }
}
///  ag
public class Ag:NSObject,Codable{
    /// 高可用组名称
    var name:String?
    /// 高可用组id
    var id:String?



    public override init(){
            super.init()
    }

    enum AgCodingKeys: String, CodingKey {
        case name
        case id
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: AgCodingKeys.self)
        if decoderContainer.contains(.name)
        {
            self.name = try decoderContainer.decode(String?.self, forKey: .name)
        }
        if decoderContainer.contains(.id)
        {
            self.id = try decoderContainer.decode(String?.self, forKey: .id)
        }
    }
}
public extension Ag{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: AgCodingKeys.self)
         try encoderContainer.encode(name, forKey: .name)
         try encoderContainer.encode(id, forKey: .id)
    }
}
///  deployInstance
public class DeployInstance:NSObject,Codable{
    /// 部署ID
    var deployId:String?
    /// 云主机ID
    var uuid:String?
    /// 云主机名称
    var instanceName:String?
    /// ip
    var ip:String?
    /// 公网ip
    var public_ip:String?
    /// 地域
    var regionId:String?
    /// 私有网络
    var vpc:Vpc?
    /// 类型 1云主机，2原生容器
    var type:Int?
    /// 高可用组
    var ag:Ag?
    /// 标签
    var tags:String?
    /// 所属部署组ID，多个,分隔
    var groupId:String?
    /// 部署方式：1滚动 2蓝组 3绿组
    var method:Int?
    /// 部署状态
    var status:Int?



    public override init(){
            super.init()
    }

    enum DeployInstanceCodingKeys: String, CodingKey {
        case deployId
        case uuid
        case instanceName
        case ip
        case public_ip
        case regionId
        case vpc
        case type
        case ag
        case tags
        case groupId
        case method
        case status
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: DeployInstanceCodingKeys.self)
        if decoderContainer.contains(.deployId)
        {
            self.deployId = try decoderContainer.decode(String?.self, forKey: .deployId)
        }
        if decoderContainer.contains(.uuid)
        {
            self.uuid = try decoderContainer.decode(String?.self, forKey: .uuid)
        }
        if decoderContainer.contains(.instanceName)
        {
            self.instanceName = try decoderContainer.decode(String?.self, forKey: .instanceName)
        }
        if decoderContainer.contains(.ip)
        {
            self.ip = try decoderContainer.decode(String?.self, forKey: .ip)
        }
        if decoderContainer.contains(.public_ip)
        {
            self.public_ip = try decoderContainer.decode(String?.self, forKey: .public_ip)
        }
        if decoderContainer.contains(.regionId)
        {
            self.regionId = try decoderContainer.decode(String?.self, forKey: .regionId)
        }
        if decoderContainer.contains(.vpc)
        {
            self.vpc = try decoderContainer.decode(Vpc?.self, forKey: .vpc)
        }
        if decoderContainer.contains(.type)
        {
            self.type = try decoderContainer.decode(Int?.self, forKey: .type)
        }
        if decoderContainer.contains(.ag)
        {
            self.ag = try decoderContainer.decode(Ag?.self, forKey: .ag)
        }
        if decoderContainer.contains(.tags)
        {
            self.tags = try decoderContainer.decode(String?.self, forKey: .tags)
        }
        if decoderContainer.contains(.groupId)
        {
            self.groupId = try decoderContainer.decode(String?.self, forKey: .groupId)
        }
        if decoderContainer.contains(.method)
        {
            self.method = try decoderContainer.decode(Int?.self, forKey: .method)
        }
        if decoderContainer.contains(.status)
        {
            self.status = try decoderContainer.decode(Int?.self, forKey: .status)
        }
    }
}
public extension DeployInstance{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: DeployInstanceCodingKeys.self)
         try encoderContainer.encode(deployId, forKey: .deployId)
         try encoderContainer.encode(uuid, forKey: .uuid)
         try encoderContainer.encode(instanceName, forKey: .instanceName)
         try encoderContainer.encode(ip, forKey: .ip)
         try encoderContainer.encode(public_ip, forKey: .public_ip)
         try encoderContainer.encode(regionId, forKey: .regionId)
         try encoderContainer.encode(vpc, forKey: .vpc)
         try encoderContainer.encode(type, forKey: .type)
         try encoderContainer.encode(ag, forKey: .ag)
         try encoderContainer.encode(tags, forKey: .tags)
         try encoderContainer.encode(groupId, forKey: .groupId)
         try encoderContainer.encode(method, forKey: .method)
         try encoderContainer.encode(status, forKey: .status)
    }
}
///  vpc
public class Vpc:NSObject,Codable{
    /// 高可用组名称
    var name:String?
    /// 高可用组id
    var id:String?



    public override init(){
            super.init()
    }

    enum VpcCodingKeys: String, CodingKey {
        case name
        case id
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: VpcCodingKeys.self)
        if decoderContainer.contains(.name)
        {
            self.name = try decoderContainer.decode(String?.self, forKey: .name)
        }
        if decoderContainer.contains(.id)
        {
            self.id = try decoderContainer.decode(String?.self, forKey: .id)
        }
    }
}
public extension Vpc{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: VpcCodingKeys.self)
         try encoderContainer.encode(name, forKey: .name)
         try encoderContainer.encode(id, forKey: .id)
    }
}
///  stageLog
public class StageLog:NSObject,Codable{
    /// 执行阶段名
    var stage:String?
    /// 执行阶段状态
    var status:String?
    /// 执行阶段输出
    var msg:String?
    /// 执行阶段耗时
    var time:String?



    public override init(){
            super.init()
    }

    enum StageLogCodingKeys: String, CodingKey {
        case stage
        case status
        case msg
        case time
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: StageLogCodingKeys.self)
        if decoderContainer.contains(.stage)
        {
            self.stage = try decoderContainer.decode(String?.self, forKey: .stage)
        }
        if decoderContainer.contains(.status)
        {
            self.status = try decoderContainer.decode(String?.self, forKey: .status)
        }
        if decoderContainer.contains(.msg)
        {
            self.msg = try decoderContainer.decode(String?.self, forKey: .msg)
        }
        if decoderContainer.contains(.time)
        {
            self.time = try decoderContainer.decode(String?.self, forKey: .time)
        }
    }
}
public extension StageLog{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: StageLogCodingKeys.self)
         try encoderContainer.encode(stage, forKey: .stage)
         try encoderContainer.encode(status, forKey: .status)
         try encoderContainer.encode(msg, forKey: .msg)
         try encoderContainer.encode(time, forKey: .time)
    }
}
///  instance
public class Instance:NSObject,Codable{
    /// 云主机ID
    var instanceId:String?
    /// 云主机ID
    var uuid:String?
    /// 云主机名称
    var instanceName:String?
    /// ip
    var ip:String?
    /// 公网ip
    var public_ip:String?
    /// 地域
    var regionId:String?
    /// 私有网络
    var vpc:Vpc?
    /// 类型 1云主机，2原生容器
    var type:Int?
    /// 高可用组
    var ag:Ag?
    /// 标签
    var tags:String?
    /// 所属部署组ID，多个,分隔
    var groupId:String?
    /// 客户端状态
    var agentStatus:Int?



    public override init(){
            super.init()
    }

    enum InstanceCodingKeys: String, CodingKey {
        case instanceId
        case uuid
        case instanceName
        case ip
        case public_ip
        case regionId
        case vpc
        case type
        case ag
        case tags
        case groupId
        case agentStatus
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: InstanceCodingKeys.self)
        if decoderContainer.contains(.instanceId)
        {
            self.instanceId = try decoderContainer.decode(String?.self, forKey: .instanceId)
        }
        if decoderContainer.contains(.uuid)
        {
            self.uuid = try decoderContainer.decode(String?.self, forKey: .uuid)
        }
        if decoderContainer.contains(.instanceName)
        {
            self.instanceName = try decoderContainer.decode(String?.self, forKey: .instanceName)
        }
        if decoderContainer.contains(.ip)
        {
            self.ip = try decoderContainer.decode(String?.self, forKey: .ip)
        }
        if decoderContainer.contains(.public_ip)
        {
            self.public_ip = try decoderContainer.decode(String?.self, forKey: .public_ip)
        }
        if decoderContainer.contains(.regionId)
        {
            self.regionId = try decoderContainer.decode(String?.self, forKey: .regionId)
        }
        if decoderContainer.contains(.vpc)
        {
            self.vpc = try decoderContainer.decode(Vpc?.self, forKey: .vpc)
        }
        if decoderContainer.contains(.type)
        {
            self.type = try decoderContainer.decode(Int?.self, forKey: .type)
        }
        if decoderContainer.contains(.ag)
        {
            self.ag = try decoderContainer.decode(Ag?.self, forKey: .ag)
        }
        if decoderContainer.contains(.tags)
        {
            self.tags = try decoderContainer.decode(String?.self, forKey: .tags)
        }
        if decoderContainer.contains(.groupId)
        {
            self.groupId = try decoderContainer.decode(String?.self, forKey: .groupId)
        }
        if decoderContainer.contains(.agentStatus)
        {
            self.agentStatus = try decoderContainer.decode(Int?.self, forKey: .agentStatus)
        }
    }
}
public extension Instance{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: InstanceCodingKeys.self)
         try encoderContainer.encode(instanceId, forKey: .instanceId)
         try encoderContainer.encode(uuid, forKey: .uuid)
         try encoderContainer.encode(instanceName, forKey: .instanceName)
         try encoderContainer.encode(ip, forKey: .ip)
         try encoderContainer.encode(public_ip, forKey: .public_ip)
         try encoderContainer.encode(regionId, forKey: .regionId)
         try encoderContainer.encode(vpc, forKey: .vpc)
         try encoderContainer.encode(type, forKey: .type)
         try encoderContainer.encode(ag, forKey: .ag)
         try encoderContainer.encode(tags, forKey: .tags)
         try encoderContainer.encode(groupId, forKey: .groupId)
         try encoderContainer.encode(agentStatus, forKey: .agentStatus)
    }
}
///  checkAgentStatusRequest
public class CheckAgentStatusRequest:NSObject,Codable{
    /// 部署组名
    /// Required:true
    var groupId:String



    public  init(groupId:String){
             self.groupId = groupId
    }

    enum CheckAgentStatusRequestCodingKeys: String, CodingKey {
        case groupId
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: CheckAgentStatusRequestCodingKeys.self)
        self.groupId = try decoderContainer.decode(String.self, forKey: .groupId)
    }
}
public extension CheckAgentStatusRequest{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: CheckAgentStatusRequestCodingKeys.self)
         try encoderContainer.encode(groupId, forKey: .groupId)
    }
}
///  rollback
public class Rollback:NSObject,Codable{
    /// 回滚策略ID
    var value:Int?
    /// 回滚策略名称
    var label:String?



    public override init(){
            super.init()
    }

    enum RollbackCodingKeys: String, CodingKey {
        case value
        case label
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: RollbackCodingKeys.self)
        if decoderContainer.contains(.value)
        {
            self.value = try decoderContainer.decode(Int?.self, forKey: .value)
        }
        if decoderContainer.contains(.label)
        {
            self.label = try decoderContainer.decode(String?.self, forKey: .label)
        }
    }
}
public extension Rollback{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: RollbackCodingKeys.self)
         try encoderContainer.encode(value, forKey: .value)
         try encoderContainer.encode(label, forKey: .label)
    }
}
///  deployStatus
public class DeployStatus:NSObject,Codable{
    /// 部署状态ID
    var value:Int?
    /// 部署状态名称
    var label:String?



    public override init(){
            super.init()
    }

    enum DeployStatusCodingKeys: String, CodingKey {
        case value
        case label
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: DeployStatusCodingKeys.self)
        if decoderContainer.contains(.value)
        {
            self.value = try decoderContainer.decode(Int?.self, forKey: .value)
        }
        if decoderContainer.contains(.label)
        {
            self.label = try decoderContainer.decode(String?.self, forKey: .label)
        }
    }
}
public extension DeployStatus{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: DeployStatusCodingKeys.self)
         try encoderContainer.encode(value, forKey: .value)
         try encoderContainer.encode(label, forKey: .label)
    }
}
///  noticeMethod
public class NoticeMethod:NSObject,Codable{
    /// 通知方式ID
    var value:Int?
    /// 通知方式名称
    var label:String?



    public override init(){
            super.init()
    }

    enum NoticeMethodCodingKeys: String, CodingKey {
        case value
        case label
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: NoticeMethodCodingKeys.self)
        if decoderContainer.contains(.value)
        {
            self.value = try decoderContainer.decode(Int?.self, forKey: .value)
        }
        if decoderContainer.contains(.label)
        {
            self.label = try decoderContainer.decode(String?.self, forKey: .label)
        }
    }
}
public extension NoticeMethod{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: NoticeMethodCodingKeys.self)
         try encoderContainer.encode(value, forKey: .value)
         try encoderContainer.encode(label, forKey: .label)
    }
}
///  deploySource
public class DeploySource:NSObject,Codable{
    /// 部署来源ID
    var value:Int?
    /// 部署来源名称
    var label:String?



    public override init(){
            super.init()
    }

    enum DeploySourceCodingKeys: String, CodingKey {
        case value
        case label
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: DeploySourceCodingKeys.self)
        if decoderContainer.contains(.value)
        {
            self.value = try decoderContainer.decode(Int?.self, forKey: .value)
        }
        if decoderContainer.contains(.label)
        {
            self.label = try decoderContainer.decode(String?.self, forKey: .label)
        }
    }
}
public extension DeploySource{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: DeploySourceCodingKeys.self)
         try encoderContainer.encode(value, forKey: .value)
         try encoderContainer.encode(label, forKey: .label)
    }
}
///  noticeTrigger
public class NoticeTrigger:NSObject,Codable{
    /// 通知触发策略ID
    var value:Int?
    /// 通知触发策略名称
    var label:String?



    public override init(){
            super.init()
    }

    enum NoticeTriggerCodingKeys: String, CodingKey {
        case value
        case label
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: NoticeTriggerCodingKeys.self)
        if decoderContainer.contains(.value)
        {
            self.value = try decoderContainer.decode(Int?.self, forKey: .value)
        }
        if decoderContainer.contains(.label)
        {
            self.label = try decoderContainer.decode(String?.self, forKey: .label)
        }
    }
}
public extension NoticeTrigger{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: NoticeTriggerCodingKeys.self)
         try encoderContainer.encode(value, forKey: .value)
         try encoderContainer.encode(label, forKey: .label)
    }
}
///  agentStatus
public class AgentStatus:NSObject,Codable{
    /// 部署状态ID
    var value:Int?
    /// 部署状态名称
    var label:String?



    public override init(){
            super.init()
    }

    enum AgentStatusCodingKeys: String, CodingKey {
        case value
        case label
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: AgentStatusCodingKeys.self)
        if decoderContainer.contains(.value)
        {
            self.value = try decoderContainer.decode(Int?.self, forKey: .value)
        }
        if decoderContainer.contains(.label)
        {
            self.label = try decoderContainer.decode(String?.self, forKey: .label)
        }
    }
}
public extension AgentStatus{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: AgentStatusCodingKeys.self)
         try encoderContainer.encode(value, forKey: .value)
         try encoderContainer.encode(label, forKey: .label)
    }
}
///  statusColor
public class StatusColor:NSObject,Codable{
    /// 部署状态ID
    var value:Int?
    /// 部署状态名称
    var label:String?



    public override init(){
            super.init()
    }

    enum StatusColorCodingKeys: String, CodingKey {
        case value
        case label
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: StatusColorCodingKeys.self)
        if decoderContainer.contains(.value)
        {
            self.value = try decoderContainer.decode(Int?.self, forKey: .value)
        }
        if decoderContainer.contains(.label)
        {
            self.label = try decoderContainer.decode(String?.self, forKey: .label)
        }
    }
}
public extension StatusColor{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: StatusColorCodingKeys.self)
         try encoderContainer.encode(value, forKey: .value)
         try encoderContainer.encode(label, forKey: .label)
    }
}
///  fileType
public class FileType:NSObject,Codable{
    /// 文件类型ID
    var value:Int?
    /// 文件类型名称
    var label:String?



    public override init(){
            super.init()
    }

    enum FileTypeCodingKeys: String, CodingKey {
        case value
        case label
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: FileTypeCodingKeys.self)
        if decoderContainer.contains(.value)
        {
            self.value = try decoderContainer.decode(Int?.self, forKey: .value)
        }
        if decoderContainer.contains(.label)
        {
            self.label = try decoderContainer.decode(String?.self, forKey: .label)
        }
    }
}
public extension FileType{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: FileTypeCodingKeys.self)
         try encoderContainer.encode(value, forKey: .value)
         try encoderContainer.encode(label, forKey: .label)
    }
}
///  concurrencyUnit
public class ConcurrencyUnit:NSObject,Codable{
    /// 并发单位ID
    var value:Int?
    /// 并发单位名称
    var label:String?



    public override init(){
            super.init()
    }

    enum ConcurrencyUnitCodingKeys: String, CodingKey {
        case value
        case label
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: ConcurrencyUnitCodingKeys.self)
        if decoderContainer.contains(.value)
        {
            self.value = try decoderContainer.decode(Int?.self, forKey: .value)
        }
        if decoderContainer.contains(.label)
        {
            self.label = try decoderContainer.decode(String?.self, forKey: .label)
        }
    }
}
public extension ConcurrencyUnit{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: ConcurrencyUnitCodingKeys.self)
         try encoderContainer.encode(value, forKey: .value)
         try encoderContainer.encode(label, forKey: .label)
    }
}
///  regionId
public class RegionId:NSObject,Codable{
    /// 地域ID
    var value:String?
    /// 地域名称
    var label:String?



    public override init(){
            super.init()
    }

    enum RegionIdCodingKeys: String, CodingKey {
        case value
        case label
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: RegionIdCodingKeys.self)
        if decoderContainer.contains(.value)
        {
            self.value = try decoderContainer.decode(String?.self, forKey: .value)
        }
        if decoderContainer.contains(.label)
        {
            self.label = try decoderContainer.decode(String?.self, forKey: .label)
        }
    }
}
public extension RegionId{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: RegionIdCodingKeys.self)
         try encoderContainer.encode(value, forKey: .value)
         try encoderContainer.encode(label, forKey: .label)
    }
}
///  deployMethod
public class DeployMethod:NSObject,Codable{
    /// 部署方式ID
    var value:Int?
    /// 部署方式名称
    var label:String?



    public override init(){
            super.init()
    }

    enum DeployMethodCodingKeys: String, CodingKey {
        case value
        case label
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: DeployMethodCodingKeys.self)
        if decoderContainer.contains(.value)
        {
            self.value = try decoderContainer.decode(Int?.self, forKey: .value)
        }
        if decoderContainer.contains(.label)
        {
            self.label = try decoderContainer.decode(String?.self, forKey: .label)
        }
    }
}
public extension DeployMethod{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: DeployMethodCodingKeys.self)
         try encoderContainer.encode(value, forKey: .value)
         try encoderContainer.encode(label, forKey: .label)
    }
}
///  platform
public class Platform:NSObject,Codable{
    /// 平台ID
    var value:Int?
    /// 平台名称
    var label:String?



    public override init(){
            super.init()
    }

    enum PlatformCodingKeys: String, CodingKey {
        case value
        case label
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: PlatformCodingKeys.self)
        if decoderContainer.contains(.value)
        {
            self.value = try decoderContainer.decode(Int?.self, forKey: .value)
        }
        if decoderContainer.contains(.label)
        {
            self.label = try decoderContainer.decode(String?.self, forKey: .label)
        }
    }
}
public extension Platform{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: PlatformCodingKeys.self)
         try encoderContainer.encode(value, forKey: .value)
         try encoderContainer.encode(label, forKey: .label)
    }
}
///  repeatPolicy
public class RepeatPolicy:NSObject,Codable{
    /// 重名文件处理策略ID
    var value:Int?
    /// 重名文件处理策略名称
    var label:String?



    public override init(){
            super.init()
    }

    enum RepeatPolicyCodingKeys: String, CodingKey {
        case value
        case label
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: RepeatPolicyCodingKeys.self)
        if decoderContainer.contains(.value)
        {
            self.value = try decoderContainer.decode(Int?.self, forKey: .value)
        }
        if decoderContainer.contains(.label)
        {
            self.label = try decoderContainer.decode(String?.self, forKey: .label)
        }
    }
}
public extension RepeatPolicy{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: RepeatPolicyCodingKeys.self)
         try encoderContainer.encode(value, forKey: .value)
         try encoderContainer.encode(label, forKey: .label)
    }
}
///  grayService
public class GrayService:NSObject,Codable{
    /// 用户类型ID
    var value:Int?
    /// 用户类型名称
    var label:String?



    public override init(){
            super.init()
    }

    enum GrayServiceCodingKeys: String, CodingKey {
        case value
        case label
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: GrayServiceCodingKeys.self)
        if decoderContainer.contains(.value)
        {
            self.value = try decoderContainer.decode(Int?.self, forKey: .value)
        }
        if decoderContainer.contains(.label)
        {
            self.label = try decoderContainer.decode(String?.self, forKey: .label)
        }
    }
}
public extension GrayService{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: GrayServiceCodingKeys.self)
         try encoderContainer.encode(value, forKey: .value)
         try encoderContainer.encode(label, forKey: .label)
    }
}
///  createGroup
public class CreateGroup:NSObject,Codable{
    /// 部署组名称
    /// Required:true
    var groupName:String
    /// 应用ID
    /// Required:true
    var appId:String
    /// 描述
    var desc:String?
    /// 部署方式：1滚动部署，2蓝绿部署
    /// Required:true
    var deployMethod:Int
    /// 部署实例（滚动部署）
    var instances:[String?]?
    /// 部署实例（蓝绿部署蓝组）
    var blueInstances:[String?]?
    /// 部署实例（蓝绿部署绿组）
    var greenInstances:[String?]?
    /// 并发单位
    var concurrencyUnit:Int?
    /// 并发机器数
    var concurrencyNum:Int?
    /// 并发度
    var concurrencyPct:Int?
    /// 负载均衡：1启动，2禁用
    /// Required:true
    var lbStatus:Int
    /// lb实例
    var lbInstance:String?
    /// lb lb后端服务
    var lbBackend:String?
    /// 同名文件处理方式：1部署失败，2覆盖，3保留
    /// Required:true
    var repeatPolicy:Int
    /// 通知频率：0不发送，1消息，2邮件，3短信
    /// Required:true
    var noticeTrigger:Int
    /// 通知方式：1消息，2邮件，3短信
    var noticeMethod:[String?]?
    /// 自动回滚：1开启，2禁用
    /// Required:true
    var rollback:Int
    /// 分布式服务框架ID
    var jdsfRegisterId:String?



    public  init(groupName:String,appId:String,deployMethod:Int,lbStatus:Int,repeatPolicy:Int,noticeTrigger:Int,rollback:Int){
             self.groupName = groupName
             self.appId = appId
             self.deployMethod = deployMethod
             self.lbStatus = lbStatus
             self.repeatPolicy = repeatPolicy
             self.noticeTrigger = noticeTrigger
             self.rollback = rollback
    }

    enum CreateGroupCodingKeys: String, CodingKey {
        case groupName
        case appId
        case desc
        case deployMethod
        case instances
        case blueInstances
        case greenInstances
        case concurrencyUnit
        case concurrencyNum
        case concurrencyPct
        case lbStatus
        case lbInstance
        case lbBackend
        case repeatPolicy
        case noticeTrigger
        case noticeMethod
        case rollback
        case jdsfRegisterId
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: CreateGroupCodingKeys.self)
        self.groupName = try decoderContainer.decode(String.self, forKey: .groupName)
        self.appId = try decoderContainer.decode(String.self, forKey: .appId)
        if decoderContainer.contains(.desc)
        {
            self.desc = try decoderContainer.decode(String?.self, forKey: .desc)
        }
        self.deployMethod = try decoderContainer.decode(Int.self, forKey: .deployMethod)
        if decoderContainer.contains(.instances)
        {
            self.instances = try decoderContainer.decode([String?]?.self, forKey: .instances)
        }
        if decoderContainer.contains(.blueInstances)
        {
            self.blueInstances = try decoderContainer.decode([String?]?.self, forKey: .blueInstances)
        }
        if decoderContainer.contains(.greenInstances)
        {
            self.greenInstances = try decoderContainer.decode([String?]?.self, forKey: .greenInstances)
        }
        if decoderContainer.contains(.concurrencyUnit)
        {
            self.concurrencyUnit = try decoderContainer.decode(Int?.self, forKey: .concurrencyUnit)
        }
        if decoderContainer.contains(.concurrencyNum)
        {
            self.concurrencyNum = try decoderContainer.decode(Int?.self, forKey: .concurrencyNum)
        }
        if decoderContainer.contains(.concurrencyPct)
        {
            self.concurrencyPct = try decoderContainer.decode(Int?.self, forKey: .concurrencyPct)
        }
        self.lbStatus = try decoderContainer.decode(Int.self, forKey: .lbStatus)
        if decoderContainer.contains(.lbInstance)
        {
            self.lbInstance = try decoderContainer.decode(String?.self, forKey: .lbInstance)
        }
        if decoderContainer.contains(.lbBackend)
        {
            self.lbBackend = try decoderContainer.decode(String?.self, forKey: .lbBackend)
        }
        self.repeatPolicy = try decoderContainer.decode(Int.self, forKey: .repeatPolicy)
        self.noticeTrigger = try decoderContainer.decode(Int.self, forKey: .noticeTrigger)
        if decoderContainer.contains(.noticeMethod)
        {
            self.noticeMethod = try decoderContainer.decode([String?]?.self, forKey: .noticeMethod)
        }
        self.rollback = try decoderContainer.decode(Int.self, forKey: .rollback)
        if decoderContainer.contains(.jdsfRegisterId)
        {
            self.jdsfRegisterId = try decoderContainer.decode(String?.self, forKey: .jdsfRegisterId)
        }
    }
}
public extension CreateGroup{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: CreateGroupCodingKeys.self)
         try encoderContainer.encode(groupName, forKey: .groupName)
         try encoderContainer.encode(appId, forKey: .appId)
         try encoderContainer.encode(desc, forKey: .desc)
         try encoderContainer.encode(deployMethod, forKey: .deployMethod)
         try encoderContainer.encode(instances, forKey: .instances)
         try encoderContainer.encode(blueInstances, forKey: .blueInstances)
         try encoderContainer.encode(greenInstances, forKey: .greenInstances)
         try encoderContainer.encode(concurrencyUnit, forKey: .concurrencyUnit)
         try encoderContainer.encode(concurrencyNum, forKey: .concurrencyNum)
         try encoderContainer.encode(concurrencyPct, forKey: .concurrencyPct)
         try encoderContainer.encode(lbStatus, forKey: .lbStatus)
         try encoderContainer.encode(lbInstance, forKey: .lbInstance)
         try encoderContainer.encode(lbBackend, forKey: .lbBackend)
         try encoderContainer.encode(repeatPolicy, forKey: .repeatPolicy)
         try encoderContainer.encode(noticeTrigger, forKey: .noticeTrigger)
         try encoderContainer.encode(noticeMethod, forKey: .noticeMethod)
         try encoderContainer.encode(rollback, forKey: .rollback)
         try encoderContainer.encode(jdsfRegisterId, forKey: .jdsfRegisterId)
    }
}
///  modifyGroup
public class ModifyGroup:NSObject,Codable{
    /// 描述
    var desc:String?
    /// 部署实例（滚动）
    var instances:[String?]?
    /// 部署实例（蓝）
    var blueInstances:[String?]?
    /// 部署实例（绿）
    var greenInstances:[String?]?
    /// 并发单位
    var concurrencyUnit:Int?
    /// 并发机器数
    var concurrencyNum:Int?
    /// 并发度
    var concurrencyPct:Int?
    /// 负载均衡：1启动，2禁用
    var lbStatus:Int?
    /// lb实例
    var lbInstance:String?
    /// lb lb_backend
    var lbBackend:String?
    /// 同名文件处理方式：1部署失败，2覆盖，3保留
    var repeatPolicy:Int?
    /// 通知频率：1异常发送，2每次发送
    var noticeTrigger:Int?
    /// 通知方式：1消息，2邮件，3短信
    var noticeMethod:[String?]?
    /// 自动回滚：1开启，2禁用
    var rollback:Int?
    /// 分布式服务框架ID
    var jdsfRegisterId:String?



    public override init(){
            super.init()
    }

    enum ModifyGroupCodingKeys: String, CodingKey {
        case desc
        case instances
        case blueInstances
        case greenInstances
        case concurrencyUnit
        case concurrencyNum
        case concurrencyPct
        case lbStatus
        case lbInstance
        case lbBackend
        case repeatPolicy
        case noticeTrigger
        case noticeMethod
        case rollback
        case jdsfRegisterId
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: ModifyGroupCodingKeys.self)
        if decoderContainer.contains(.desc)
        {
            self.desc = try decoderContainer.decode(String?.self, forKey: .desc)
        }
        if decoderContainer.contains(.instances)
        {
            self.instances = try decoderContainer.decode([String?]?.self, forKey: .instances)
        }
        if decoderContainer.contains(.blueInstances)
        {
            self.blueInstances = try decoderContainer.decode([String?]?.self, forKey: .blueInstances)
        }
        if decoderContainer.contains(.greenInstances)
        {
            self.greenInstances = try decoderContainer.decode([String?]?.self, forKey: .greenInstances)
        }
        if decoderContainer.contains(.concurrencyUnit)
        {
            self.concurrencyUnit = try decoderContainer.decode(Int?.self, forKey: .concurrencyUnit)
        }
        if decoderContainer.contains(.concurrencyNum)
        {
            self.concurrencyNum = try decoderContainer.decode(Int?.self, forKey: .concurrencyNum)
        }
        if decoderContainer.contains(.concurrencyPct)
        {
            self.concurrencyPct = try decoderContainer.decode(Int?.self, forKey: .concurrencyPct)
        }
        if decoderContainer.contains(.lbStatus)
        {
            self.lbStatus = try decoderContainer.decode(Int?.self, forKey: .lbStatus)
        }
        if decoderContainer.contains(.lbInstance)
        {
            self.lbInstance = try decoderContainer.decode(String?.self, forKey: .lbInstance)
        }
        if decoderContainer.contains(.lbBackend)
        {
            self.lbBackend = try decoderContainer.decode(String?.self, forKey: .lbBackend)
        }
        if decoderContainer.contains(.repeatPolicy)
        {
            self.repeatPolicy = try decoderContainer.decode(Int?.self, forKey: .repeatPolicy)
        }
        if decoderContainer.contains(.noticeTrigger)
        {
            self.noticeTrigger = try decoderContainer.decode(Int?.self, forKey: .noticeTrigger)
        }
        if decoderContainer.contains(.noticeMethod)
        {
            self.noticeMethod = try decoderContainer.decode([String?]?.self, forKey: .noticeMethod)
        }
        if decoderContainer.contains(.rollback)
        {
            self.rollback = try decoderContainer.decode(Int?.self, forKey: .rollback)
        }
        if decoderContainer.contains(.jdsfRegisterId)
        {
            self.jdsfRegisterId = try decoderContainer.decode(String?.self, forKey: .jdsfRegisterId)
        }
    }
}
public extension ModifyGroup{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: ModifyGroupCodingKeys.self)
         try encoderContainer.encode(desc, forKey: .desc)
         try encoderContainer.encode(instances, forKey: .instances)
         try encoderContainer.encode(blueInstances, forKey: .blueInstances)
         try encoderContainer.encode(greenInstances, forKey: .greenInstances)
         try encoderContainer.encode(concurrencyUnit, forKey: .concurrencyUnit)
         try encoderContainer.encode(concurrencyNum, forKey: .concurrencyNum)
         try encoderContainer.encode(concurrencyPct, forKey: .concurrencyPct)
         try encoderContainer.encode(lbStatus, forKey: .lbStatus)
         try encoderContainer.encode(lbInstance, forKey: .lbInstance)
         try encoderContainer.encode(lbBackend, forKey: .lbBackend)
         try encoderContainer.encode(repeatPolicy, forKey: .repeatPolicy)
         try encoderContainer.encode(noticeTrigger, forKey: .noticeTrigger)
         try encoderContainer.encode(noticeMethod, forKey: .noticeMethod)
         try encoderContainer.encode(rollback, forKey: .rollback)
         try encoderContainer.encode(jdsfRegisterId, forKey: .jdsfRegisterId)
    }
}
///  group
public class Group:NSObject,Codable{
    /// 部署组ID
    var groupId:String?
    /// 部署组名称
    var groupName:String?
    /// 应用ID
    var appId:String?
    /// 应用名称
    var appName:String?
    /// 地域
    var regionId:String?
    /// 状态
    var status:Int?
    /// 部署平台：1云主机，2原生容器
    var platform:Int?
    /// 描述
    var desc:String?
    /// 部署方式：1滚动部署，2蓝绿部署
    var deployMethod:Int?
    /// 部署实例（滚动）
    var instances:[String?]?
    /// 部署实例（蓝）
    var blueInstances:[String?]?
    /// 部署实例（绿）
    var greenInstances:[String?]?
    /// 并发单位
    var concurrencyUnit:Int?
    /// 并发机器数
    var concurrencyNum:Int?
    /// 并发度
    var concurrencyPct:Int?
    /// 负载均衡：1启动，2禁用
    var lbStatus:Int?
    /// lb实例
    var lbInstance:String?
    /// lb lb_backend
    var lbBackend:String?
    /// 同名文件处理方式：1部署失败，2覆盖，3保留
    var repeatPolicy:Int?
    /// 通知频率：1异常发送，2每次发送
    var noticeTrigger:Int?
    /// 通知方式：1消息，2邮件，3短信
    var noticeMethod:[String?]?
    /// 自动回滚：1开启，2禁用
    var rollback:Int?
    /// 使用分布式服务框架：0不使用，1使用
    var jdsfEnabled:Int?
    /// 分布式服务框架ID
    var jdsfRegisterId:String?
    /// 上次部署时间
    var lastDeployTime:Int?



    public override init(){
            super.init()
    }

    enum GroupCodingKeys: String, CodingKey {
        case groupId
        case groupName
        case appId
        case appName
        case regionId
        case status
        case platform
        case desc
        case deployMethod
        case instances
        case blueInstances
        case greenInstances
        case concurrencyUnit
        case concurrencyNum
        case concurrencyPct
        case lbStatus
        case lbInstance
        case lbBackend
        case repeatPolicy
        case noticeTrigger
        case noticeMethod
        case rollback
        case jdsfEnabled
        case jdsfRegisterId
        case lastDeployTime
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: GroupCodingKeys.self)
        if decoderContainer.contains(.groupId)
        {
            self.groupId = try decoderContainer.decode(String?.self, forKey: .groupId)
        }
        if decoderContainer.contains(.groupName)
        {
            self.groupName = try decoderContainer.decode(String?.self, forKey: .groupName)
        }
        if decoderContainer.contains(.appId)
        {
            self.appId = try decoderContainer.decode(String?.self, forKey: .appId)
        }
        if decoderContainer.contains(.appName)
        {
            self.appName = try decoderContainer.decode(String?.self, forKey: .appName)
        }
        if decoderContainer.contains(.regionId)
        {
            self.regionId = try decoderContainer.decode(String?.self, forKey: .regionId)
        }
        if decoderContainer.contains(.status)
        {
            self.status = try decoderContainer.decode(Int?.self, forKey: .status)
        }
        if decoderContainer.contains(.platform)
        {
            self.platform = try decoderContainer.decode(Int?.self, forKey: .platform)
        }
        if decoderContainer.contains(.desc)
        {
            self.desc = try decoderContainer.decode(String?.self, forKey: .desc)
        }
        if decoderContainer.contains(.deployMethod)
        {
            self.deployMethod = try decoderContainer.decode(Int?.self, forKey: .deployMethod)
        }
        if decoderContainer.contains(.instances)
        {
            self.instances = try decoderContainer.decode([String?]?.self, forKey: .instances)
        }
        if decoderContainer.contains(.blueInstances)
        {
            self.blueInstances = try decoderContainer.decode([String?]?.self, forKey: .blueInstances)
        }
        if decoderContainer.contains(.greenInstances)
        {
            self.greenInstances = try decoderContainer.decode([String?]?.self, forKey: .greenInstances)
        }
        if decoderContainer.contains(.concurrencyUnit)
        {
            self.concurrencyUnit = try decoderContainer.decode(Int?.self, forKey: .concurrencyUnit)
        }
        if decoderContainer.contains(.concurrencyNum)
        {
            self.concurrencyNum = try decoderContainer.decode(Int?.self, forKey: .concurrencyNum)
        }
        if decoderContainer.contains(.concurrencyPct)
        {
            self.concurrencyPct = try decoderContainer.decode(Int?.self, forKey: .concurrencyPct)
        }
        if decoderContainer.contains(.lbStatus)
        {
            self.lbStatus = try decoderContainer.decode(Int?.self, forKey: .lbStatus)
        }
        if decoderContainer.contains(.lbInstance)
        {
            self.lbInstance = try decoderContainer.decode(String?.self, forKey: .lbInstance)
        }
        if decoderContainer.contains(.lbBackend)
        {
            self.lbBackend = try decoderContainer.decode(String?.self, forKey: .lbBackend)
        }
        if decoderContainer.contains(.repeatPolicy)
        {
            self.repeatPolicy = try decoderContainer.decode(Int?.self, forKey: .repeatPolicy)
        }
        if decoderContainer.contains(.noticeTrigger)
        {
            self.noticeTrigger = try decoderContainer.decode(Int?.self, forKey: .noticeTrigger)
        }
        if decoderContainer.contains(.noticeMethod)
        {
            self.noticeMethod = try decoderContainer.decode([String?]?.self, forKey: .noticeMethod)
        }
        if decoderContainer.contains(.rollback)
        {
            self.rollback = try decoderContainer.decode(Int?.self, forKey: .rollback)
        }
        if decoderContainer.contains(.jdsfEnabled)
        {
            self.jdsfEnabled = try decoderContainer.decode(Int?.self, forKey: .jdsfEnabled)
        }
        if decoderContainer.contains(.jdsfRegisterId)
        {
            self.jdsfRegisterId = try decoderContainer.decode(String?.self, forKey: .jdsfRegisterId)
        }
        if decoderContainer.contains(.lastDeployTime)
        {
            self.lastDeployTime = try decoderContainer.decode(Int?.self, forKey: .lastDeployTime)
        }
    }
}
public extension Group{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: GroupCodingKeys.self)
         try encoderContainer.encode(groupId, forKey: .groupId)
         try encoderContainer.encode(groupName, forKey: .groupName)
         try encoderContainer.encode(appId, forKey: .appId)
         try encoderContainer.encode(appName, forKey: .appName)
         try encoderContainer.encode(regionId, forKey: .regionId)
         try encoderContainer.encode(status, forKey: .status)
         try encoderContainer.encode(platform, forKey: .platform)
         try encoderContainer.encode(desc, forKey: .desc)
         try encoderContainer.encode(deployMethod, forKey: .deployMethod)
         try encoderContainer.encode(instances, forKey: .instances)
         try encoderContainer.encode(blueInstances, forKey: .blueInstances)
         try encoderContainer.encode(greenInstances, forKey: .greenInstances)
         try encoderContainer.encode(concurrencyUnit, forKey: .concurrencyUnit)
         try encoderContainer.encode(concurrencyNum, forKey: .concurrencyNum)
         try encoderContainer.encode(concurrencyPct, forKey: .concurrencyPct)
         try encoderContainer.encode(lbStatus, forKey: .lbStatus)
         try encoderContainer.encode(lbInstance, forKey: .lbInstance)
         try encoderContainer.encode(lbBackend, forKey: .lbBackend)
         try encoderContainer.encode(repeatPolicy, forKey: .repeatPolicy)
         try encoderContainer.encode(noticeTrigger, forKey: .noticeTrigger)
         try encoderContainer.encode(noticeMethod, forKey: .noticeMethod)
         try encoderContainer.encode(rollback, forKey: .rollback)
         try encoderContainer.encode(jdsfEnabled, forKey: .jdsfEnabled)
         try encoderContainer.encode(jdsfRegisterId, forKey: .jdsfRegisterId)
         try encoderContainer.encode(lastDeployTime, forKey: .lastDeployTime)
    }
}
///  pinInfo
public class PinInfo:NSObject,Codable{
    /// pin
    var pin:String?
    /// 应用数量限制
    var appMax:Int?
    /// 当前应用数量
    var appCount:Int?
    /// 部署组数量限制
    var groupMax:Int?



    public override init(){
            super.init()
    }

    enum PinInfoCodingKeys: String, CodingKey {
        case pin
        case appMax
        case appCount
        case groupMax
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: PinInfoCodingKeys.self)
        if decoderContainer.contains(.pin)
        {
            self.pin = try decoderContainer.decode(String?.self, forKey: .pin)
        }
        if decoderContainer.contains(.appMax)
        {
            self.appMax = try decoderContainer.decode(Int?.self, forKey: .appMax)
        }
        if decoderContainer.contains(.appCount)
        {
            self.appCount = try decoderContainer.decode(Int?.self, forKey: .appCount)
        }
        if decoderContainer.contains(.groupMax)
        {
            self.groupMax = try decoderContainer.decode(Int?.self, forKey: .groupMax)
        }
    }
}
public extension PinInfo{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: PinInfoCodingKeys.self)
         try encoderContainer.encode(pin, forKey: .pin)
         try encoderContainer.encode(appMax, forKey: .appMax)
         try encoderContainer.encode(appCount, forKey: .appCount)
         try encoderContainer.encode(groupMax, forKey: .groupMax)
    }
}
///  deployType
public class DeployType:NSObject,Codable{
    /// 部署类型ID
    var value:Int?
    /// 部署类型名称
    var label:String?



    public override init(){
            super.init()
    }

    enum DeployTypeCodingKeys: String, CodingKey {
        case value
        case label
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: DeployTypeCodingKeys.self)
        if decoderContainer.contains(.value)
        {
            self.value = try decoderContainer.decode(Int?.self, forKey: .value)
        }
        if decoderContainer.contains(.label)
        {
            self.label = try decoderContainer.decode(String?.self, forKey: .label)
        }
    }
}
public extension DeployType{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: DeployTypeCodingKeys.self)
         try encoderContainer.encode(value, forKey: .value)
         try encoderContainer.encode(label, forKey: .label)
    }
}

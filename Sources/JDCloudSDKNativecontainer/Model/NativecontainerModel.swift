/* Copyright 2018 JDCLOUD.COM

   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at

     http:#www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.

   商业平台
   续费相关接口

   OpenAPI spec version: v1
   Contact: 

   NOTE: This class is auto generated by the jdcloud code generator program.
 */


import Foundation
import JDCloudSDKCharge
import JDCloudSDKDisk
///  quota
public class Quota:NSObject,Codable{
    /// 类型
    var resourceType:String?
    /// 配额
    var limit:Int?
    /// 已使用的数目
    var used:Int?



    public override init(){
            super.init()
    }

    enum QuotaCodingKeys: String, CodingKey {
        case resourceType
        case limit
        case used
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: QuotaCodingKeys.self)
        if decoderContainer.contains(.resourceType)
        {
            self.resourceType = try decoderContainer.decode(String?.self, forKey: .resourceType)
        }
        if decoderContainer.contains(.limit)
        {
            self.limit = try decoderContainer.decode(Int?.self, forKey: .limit)
        }
        if decoderContainer.contains(.used)
        {
            self.used = try decoderContainer.decode(Int?.self, forKey: .used)
        }
    }
}
public extension Quota{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: QuotaCodingKeys.self)
         try encoderContainer.encode(resourceType, forKey: .resourceType)
         try encoderContainer.encode(limit, forKey: .limit)
         try encoderContainer.encode(used, forKey: .used)
    }
}
///  instanceTypeState
public class InstanceTypeState:NSObject,Codable{
    /// 可用区
    var az:String?
    /// 可售卖情况，true:可售卖、false:已售罄不可用
    var inStock:Bool?
    /// 在线情况，true:在线、false:已下线不可用
    var online:Bool?



    public override init(){
            super.init()
    }

    enum InstanceTypeStateCodingKeys: String, CodingKey {
        case az
        case inStock
        case online
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: InstanceTypeStateCodingKeys.self)
        if decoderContainer.contains(.az)
        {
            self.az = try decoderContainer.decode(String?.self, forKey: .az)
        }
        if decoderContainer.contains(.inStock)
        {
            self.inStock = try decoderContainer.decode(Bool?.self, forKey: .inStock)
        }
        if decoderContainer.contains(.online)
        {
            self.online = try decoderContainer.decode(Bool?.self, forKey: .online)
        }
    }
}
public extension InstanceTypeState{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: InstanceTypeStateCodingKeys.self)
         try encoderContainer.encode(az, forKey: .az)
         try encoderContainer.encode(inStock, forKey: .inStock)
         try encoderContainer.encode(online, forKey: .online)
    }
}
///  instanceType
public class InstanceType:NSObject,Codable{
    /// 实例规格类型
    var family:String?
    /// 实例规格，比如g.b1.2xlarge
    var instanceTypeValue:String?
    /// cpu个数
    var cpu:Int?
    /// 内存大小
    var memoryMB:Int?
    /// 支持弹性网卡的数量
    var nicLimit:Int?
    /// 描述
    var desc:String?
    /// 规格状态
    var state:[InstanceTypeState?]?



    public override init(){
            super.init()
    }

    enum InstanceTypeCodingKeys: String, CodingKey {
        case family
        case instanceTypeValue = "instanceType"
        case cpu
        case memoryMB
        case nicLimit
        case desc
        case state
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: InstanceTypeCodingKeys.self)
        if decoderContainer.contains(.family)
        {
            self.family = try decoderContainer.decode(String?.self, forKey: .family)
        }
        if decoderContainer.contains(.instanceTypeValue)
        {
            self.instanceTypeValue = try decoderContainer.decode(String?.self, forKey: .instanceTypeValue)
        }
        if decoderContainer.contains(.cpu)
        {
            self.cpu = try decoderContainer.decode(Int?.self, forKey: .cpu)
        }
        if decoderContainer.contains(.memoryMB)
        {
            self.memoryMB = try decoderContainer.decode(Int?.self, forKey: .memoryMB)
        }
        if decoderContainer.contains(.nicLimit)
        {
            self.nicLimit = try decoderContainer.decode(Int?.self, forKey: .nicLimit)
        }
        if decoderContainer.contains(.desc)
        {
            self.desc = try decoderContainer.decode(String?.self, forKey: .desc)
        }
        if decoderContainer.contains(.state)
        {
            self.state = try decoderContainer.decode([InstanceTypeState?]?.self, forKey: .state)
        }
    }
}
public extension InstanceType{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: InstanceTypeCodingKeys.self)
         try encoderContainer.encode(family, forKey: .family)
         try encoderContainer.encode(instanceTypeValue, forKey: .instanceTypeValue)
         try encoderContainer.encode(cpu, forKey: .cpu)
         try encoderContainer.encode(memoryMB, forKey: .memoryMB)
         try encoderContainer.encode(nicLimit, forKey: .nicLimit)
         try encoderContainer.encode(desc, forKey: .desc)
         try encoderContainer.encode(state, forKey: .state)
    }
}
///  描述网卡私有Ip资源的信息
public class NetworkInterfacePrivateIp:NSObject,Codable{
    /// 私有IP的IPV4地址
    var privateIpAddress:String?
    /// 弹性IP实例ID
    var elasticIpId:String?
    /// 弹性IP实例地址
    var elasticIpAddress:String?



    public override init(){
            super.init()
    }

    enum NetworkInterfacePrivateIpCodingKeys: String, CodingKey {
        case privateIpAddress
        case elasticIpId
        case elasticIpAddress
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: NetworkInterfacePrivateIpCodingKeys.self)
        if decoderContainer.contains(.privateIpAddress)
        {
            self.privateIpAddress = try decoderContainer.decode(String?.self, forKey: .privateIpAddress)
        }
        if decoderContainer.contains(.elasticIpId)
        {
            self.elasticIpId = try decoderContainer.decode(String?.self, forKey: .elasticIpId)
        }
        if decoderContainer.contains(.elasticIpAddress)
        {
            self.elasticIpAddress = try decoderContainer.decode(String?.self, forKey: .elasticIpAddress)
        }
    }
}
public extension NetworkInterfacePrivateIp{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: NetworkInterfacePrivateIpCodingKeys.self)
         try encoderContainer.encode(privateIpAddress, forKey: .privateIpAddress)
         try encoderContainer.encode(elasticIpId, forKey: .elasticIpId)
         try encoderContainer.encode(elasticIpAddress, forKey: .elasticIpAddress)
    }
}
///  null
public class ElasticIpSpec:NSObject,Codable{
    /// 弹性公网IP的限速 单位：MB
    /// Required:true
    var bandwidthMbps:Int
    /// IP服务商，取值为bgp或no_bgp
    var provider:String?
    /// 计费配置
    var chargeSpec:ChargeSpec?



    public  init(bandwidthMbps:Int){
             self.bandwidthMbps = bandwidthMbps
    }

    enum ElasticIpSpecCodingKeys: String, CodingKey {
        case bandwidthMbps
        case provider
        case chargeSpec
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: ElasticIpSpecCodingKeys.self)
        self.bandwidthMbps = try decoderContainer.decode(Int.self, forKey: .bandwidthMbps)
        if decoderContainer.contains(.provider)
        {
            self.provider = try decoderContainer.decode(String?.self, forKey: .provider)
        }
        if decoderContainer.contains(.chargeSpec)
        {
            self.chargeSpec = try decoderContainer.decode(ChargeSpec?.self, forKey: .chargeSpec)
        }
    }
}
public extension ElasticIpSpec{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: ElasticIpSpecCodingKeys.self)
         try encoderContainer.encode(bandwidthMbps, forKey: .bandwidthMbps)
         try encoderContainer.encode(provider, forKey: .provider)
         try encoderContainer.encode(chargeSpec, forKey: .chargeSpec)
    }
}
///  容器规格
public class ContainerSpec:NSObject,Codable{
    /// 实例类型；参考[文档](https://www.jdcloud.com/help/detail/1992/isCatalog/1)
    /// Required:true
    var instanceType:String
    /// 容器所属可用区
    /// Required:true
    var az:String
    /// 容器名称
    /// Required:true
    var name:String
    /// 域名和IP映射的信息；&lt;/br&gt; 最大10个alias
    var hostAliases:[HostAliasSpec?]?
    /// 主机名，规范请参考说明文档；默认容器ID
    var hostname:String?
    /// 容器执行命令，如果不指定默认是docker镜像的ENTRYPOINT
    var command:[String?]?
    /// 容器执行命令的参数，如果不指定默认是docker镜像的CMD
    var args:[String?]?
    /// 容器执行的环境变量；如果和镜像中的环境变量Key相同，会覆盖镜像中的值；&lt;/br&gt; 最大100对
    var envs:[EnvVar?]?
    /// 镜像名称 &lt;/br&gt; 1. Docker Hub官方镜像通过类似nginx, mysql/mysql-server的名字指定 &lt;/br&gt; &lt;/br&gt; repository长度最大256个字符，tag最大128个字符，registry最大255个字符
    /// Required:true
    var image:String
    /// 镜像仓库认证信息；使用Docker Hub和京东云CR的镜像不需要secret
    var secret:String?
    /// 容器是否分配tty。默认不分配
    var tty:Bool?
    /// 容器的工作目录。如果不指定，默认是根目录（/）；必须是绝对路径
    var workingDir:String?
    /// 根Volume信息
    /// Required:true
    var rootVolume:VolumeMountSpec
    /// 挂载的数据Volume信息；最多7个
    var dataVolumes:[VolumeMountSpec?]?
    /// 主网卡主IP关联的弹性IP规格
    var elasticIp:ElasticIpSpec?
    /// 主网卡配置信息
    /// Required:true
    var primaryNetworkInterface:ContainerNetworkInterfaceAttachmentSpec
    /// 容器日志配置信息；默认会在本地分配10MB的存储空间
    var logConfiguration:LogConfiguration?
    /// 容器描述
    var descriptionValue:String?
    /// 计费配置；如不指定，默认计费类型是后付费-按使用时常付费
    var charge:ChargeSpec?



    public  init(instanceType:String,az:String,name:String,image:String,rootVolume:VolumeMountSpec,primaryNetworkInterface:ContainerNetworkInterfaceAttachmentSpec){
             self.instanceType = instanceType
             self.az = az
             self.name = name
             self.image = image
             self.rootVolume = rootVolume
             self.primaryNetworkInterface = primaryNetworkInterface
    }

    enum ContainerSpecCodingKeys: String, CodingKey {
        case instanceType
        case az
        case name
        case hostAliases
        case hostname
        case command
        case args
        case envs
        case image
        case secret
        case tty
        case workingDir
        case rootVolume
        case dataVolumes
        case elasticIp
        case primaryNetworkInterface
        case logConfiguration
        case descriptionValue = "description"
        case charge
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: ContainerSpecCodingKeys.self)
        self.instanceType = try decoderContainer.decode(String.self, forKey: .instanceType)
        self.az = try decoderContainer.decode(String.self, forKey: .az)
        self.name = try decoderContainer.decode(String.self, forKey: .name)
        if decoderContainer.contains(.hostAliases)
        {
            self.hostAliases = try decoderContainer.decode([HostAliasSpec?]?.self, forKey: .hostAliases)
        }
        if decoderContainer.contains(.hostname)
        {
            self.hostname = try decoderContainer.decode(String?.self, forKey: .hostname)
        }
        if decoderContainer.contains(.command)
        {
            self.command = try decoderContainer.decode([String?]?.self, forKey: .command)
        }
        if decoderContainer.contains(.args)
        {
            self.args = try decoderContainer.decode([String?]?.self, forKey: .args)
        }
        if decoderContainer.contains(.envs)
        {
            self.envs = try decoderContainer.decode([EnvVar?]?.self, forKey: .envs)
        }
        self.image = try decoderContainer.decode(String.self, forKey: .image)
        if decoderContainer.contains(.secret)
        {
            self.secret = try decoderContainer.decode(String?.self, forKey: .secret)
        }
        if decoderContainer.contains(.tty)
        {
            self.tty = try decoderContainer.decode(Bool?.self, forKey: .tty)
        }
        if decoderContainer.contains(.workingDir)
        {
            self.workingDir = try decoderContainer.decode(String?.self, forKey: .workingDir)
        }
        self.rootVolume = try decoderContainer.decode(VolumeMountSpec.self, forKey: .rootVolume)
        if decoderContainer.contains(.dataVolumes)
        {
            self.dataVolumes = try decoderContainer.decode([VolumeMountSpec?]?.self, forKey: .dataVolumes)
        }
        if decoderContainer.contains(.elasticIp)
        {
            self.elasticIp = try decoderContainer.decode(ElasticIpSpec?.self, forKey: .elasticIp)
        }
        self.primaryNetworkInterface = try decoderContainer.decode(ContainerNetworkInterfaceAttachmentSpec.self, forKey: .primaryNetworkInterface)
        if decoderContainer.contains(.logConfiguration)
        {
            self.logConfiguration = try decoderContainer.decode(LogConfiguration?.self, forKey: .logConfiguration)
        }
        if decoderContainer.contains(.descriptionValue)
        {
            self.descriptionValue = try decoderContainer.decode(String?.self, forKey: .descriptionValue)
        }
        if decoderContainer.contains(.charge)
        {
            self.charge = try decoderContainer.decode(ChargeSpec?.self, forKey: .charge)
        }
    }
}
public extension ContainerSpec{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: ContainerSpecCodingKeys.self)
         try encoderContainer.encode(instanceType, forKey: .instanceType)
         try encoderContainer.encode(az, forKey: .az)
         try encoderContainer.encode(name, forKey: .name)
         try encoderContainer.encode(hostAliases, forKey: .hostAliases)
         try encoderContainer.encode(hostname, forKey: .hostname)
         try encoderContainer.encode(command, forKey: .command)
         try encoderContainer.encode(args, forKey: .args)
         try encoderContainer.encode(envs, forKey: .envs)
         try encoderContainer.encode(image, forKey: .image)
         try encoderContainer.encode(secret, forKey: .secret)
         try encoderContainer.encode(tty, forKey: .tty)
         try encoderContainer.encode(workingDir, forKey: .workingDir)
         try encoderContainer.encode(rootVolume, forKey: .rootVolume)
         try encoderContainer.encode(dataVolumes, forKey: .dataVolumes)
         try encoderContainer.encode(elasticIp, forKey: .elasticIp)
         try encoderContainer.encode(primaryNetworkInterface, forKey: .primaryNetworkInterface)
         try encoderContainer.encode(logConfiguration, forKey: .logConfiguration)
         try encoderContainer.encode(descriptionValue, forKey: .descriptionValue)
         try encoderContainer.encode(charge, forKey: .charge)
    }
}
///  描述一个磁盘
public class InstanceCloudDisk:NSObject,Codable{
    /// 云硬盘ID
    var diskId:String?
    /// 所属AZ
    var az:String?
    /// 硬盘名称
    var name:String?
    /// 硬盘描述
    var descriptionValue:String?
    /// 磁盘类型
    var diskType:String?
    /// 磁盘大小（GiB）
    var diskSize:Int?
    /// 用户指定购买的iops值，目前只支持 ssd.io1 类型云盘
    var iops:Int?
    /// 云硬盘状态，取值为 creating、available、in-use、extending、restoring、deleting、deleted、error_creating、error_deleting、error_restoring、error_extending 之一
    var status:String?
    /// 创建时间
    var createTime:String?



    public override init(){
            super.init()
    }

    enum InstanceCloudDiskCodingKeys: String, CodingKey {
        case diskId
        case az
        case name
        case descriptionValue = "description"
        case diskType
        case diskSize
        case iops
        case status
        case createTime
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: InstanceCloudDiskCodingKeys.self)
        if decoderContainer.contains(.diskId)
        {
            self.diskId = try decoderContainer.decode(String?.self, forKey: .diskId)
        }
        if decoderContainer.contains(.az)
        {
            self.az = try decoderContainer.decode(String?.self, forKey: .az)
        }
        if decoderContainer.contains(.name)
        {
            self.name = try decoderContainer.decode(String?.self, forKey: .name)
        }
        if decoderContainer.contains(.descriptionValue)
        {
            self.descriptionValue = try decoderContainer.decode(String?.self, forKey: .descriptionValue)
        }
        if decoderContainer.contains(.diskType)
        {
            self.diskType = try decoderContainer.decode(String?.self, forKey: .diskType)
        }
        if decoderContainer.contains(.diskSize)
        {
            self.diskSize = try decoderContainer.decode(Int?.self, forKey: .diskSize)
        }
        if decoderContainer.contains(.iops)
        {
            self.iops = try decoderContainer.decode(Int?.self, forKey: .iops)
        }
        if decoderContainer.contains(.status)
        {
            self.status = try decoderContainer.decode(String?.self, forKey: .status)
        }
        if decoderContainer.contains(.createTime)
        {
            self.createTime = try decoderContainer.decode(String?.self, forKey: .createTime)
        }
    }
}
public extension InstanceCloudDisk{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: InstanceCloudDiskCodingKeys.self)
         try encoderContainer.encode(diskId, forKey: .diskId)
         try encoderContainer.encode(az, forKey: .az)
         try encoderContainer.encode(name, forKey: .name)
         try encoderContainer.encode(descriptionValue, forKey: .descriptionValue)
         try encoderContainer.encode(diskType, forKey: .diskType)
         try encoderContainer.encode(diskSize, forKey: .diskSize)
         try encoderContainer.encode(iops, forKey: .iops)
         try encoderContainer.encode(status, forKey: .status)
         try encoderContainer.encode(createTime, forKey: .createTime)
    }
}
///  container
public class Container:NSObject,Codable{
    /// 容器ID
    var containerId:String?
    /// 容器状态
    var status:String?
    /// 实例类型
    var instanceType:String?
    /// 可用区
    var az:String?
    /// 容器名称
    var name:String?
    /// 域名和IP映射的信息
    var hostAliases:[HostAlias?]?
    /// 主机名
    var hostname:String?
    /// 容器执行命令
    var command:[String?]?
    /// 容器执行命令的参数
    var args:[String?]?
    /// 动态指定的容器执行的环境变量
    var envs:[EnvVar?]?
    /// 镜像名称
    var image:String?
    /// 镜像仓库认证信息名称
    var secret:String?
    /// 容器是否分配tty
    var tty:Bool?
    /// 容器的工作目录
    var workingDir:String?
    /// 根Volume信息
    var rootVolume:VolumeMount?
    /// 挂载的数据Volume信息
    var dataVolumes:[VolumeMount?]?
    /// 主网卡所属VPC的ID
    var vpcId:String?
    /// 主网卡所属子网的ID
    var subnetId:String?
    /// 主网卡主IP地址
    var privateIpAddress:String?
    /// 主网卡主IP绑定弹性IP的ID
    var elasticIpId:String?
    /// 主网卡主IP绑定弹性IP的地址
    var elasticIpAddress:String?
    /// 主网卡信息
    var primaryNetworkInterface:InstanceNetworkInterfaceAttachment?
    /// 弹性网卡信息
    var secondaryNetworkInterfaces:[InstanceNetworkInterfaceAttachment?]?
    /// 容器日志配置信息
    var logConfiguration:LogConfiguration?
    /// Tags
    var tags:[Tag?]?
    /// 计费配置信息
    var charge:Charge?
    /// 创建时间
    var launchTime:String?
    /// 容器终止原因
    var reason:String?
    /// 容器描述
    var descriptionValue:String?



    public override init(){
            super.init()
    }

    enum ContainerCodingKeys: String, CodingKey {
        case containerId
        case status
        case instanceType
        case az
        case name
        case hostAliases
        case hostname
        case command
        case args
        case envs
        case image
        case secret
        case tty
        case workingDir
        case rootVolume
        case dataVolumes
        case vpcId
        case subnetId
        case privateIpAddress
        case elasticIpId
        case elasticIpAddress
        case primaryNetworkInterface
        case secondaryNetworkInterfaces
        case logConfiguration
        case tags
        case charge
        case launchTime
        case reason
        case descriptionValue = "description"
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: ContainerCodingKeys.self)
        if decoderContainer.contains(.containerId)
        {
            self.containerId = try decoderContainer.decode(String?.self, forKey: .containerId)
        }
        if decoderContainer.contains(.status)
        {
            self.status = try decoderContainer.decode(String?.self, forKey: .status)
        }
        if decoderContainer.contains(.instanceType)
        {
            self.instanceType = try decoderContainer.decode(String?.self, forKey: .instanceType)
        }
        if decoderContainer.contains(.az)
        {
            self.az = try decoderContainer.decode(String?.self, forKey: .az)
        }
        if decoderContainer.contains(.name)
        {
            self.name = try decoderContainer.decode(String?.self, forKey: .name)
        }
        if decoderContainer.contains(.hostAliases)
        {
            self.hostAliases = try decoderContainer.decode([HostAlias?]?.self, forKey: .hostAliases)
        }
        if decoderContainer.contains(.hostname)
        {
            self.hostname = try decoderContainer.decode(String?.self, forKey: .hostname)
        }
        if decoderContainer.contains(.command)
        {
            self.command = try decoderContainer.decode([String?]?.self, forKey: .command)
        }
        if decoderContainer.contains(.args)
        {
            self.args = try decoderContainer.decode([String?]?.self, forKey: .args)
        }
        if decoderContainer.contains(.envs)
        {
            self.envs = try decoderContainer.decode([EnvVar?]?.self, forKey: .envs)
        }
        if decoderContainer.contains(.image)
        {
            self.image = try decoderContainer.decode(String?.self, forKey: .image)
        }
        if decoderContainer.contains(.secret)
        {
            self.secret = try decoderContainer.decode(String?.self, forKey: .secret)
        }
        if decoderContainer.contains(.tty)
        {
            self.tty = try decoderContainer.decode(Bool?.self, forKey: .tty)
        }
        if decoderContainer.contains(.workingDir)
        {
            self.workingDir = try decoderContainer.decode(String?.self, forKey: .workingDir)
        }
        if decoderContainer.contains(.rootVolume)
        {
            self.rootVolume = try decoderContainer.decode(VolumeMount?.self, forKey: .rootVolume)
        }
        if decoderContainer.contains(.dataVolumes)
        {
            self.dataVolumes = try decoderContainer.decode([VolumeMount?]?.self, forKey: .dataVolumes)
        }
        if decoderContainer.contains(.vpcId)
        {
            self.vpcId = try decoderContainer.decode(String?.self, forKey: .vpcId)
        }
        if decoderContainer.contains(.subnetId)
        {
            self.subnetId = try decoderContainer.decode(String?.self, forKey: .subnetId)
        }
        if decoderContainer.contains(.privateIpAddress)
        {
            self.privateIpAddress = try decoderContainer.decode(String?.self, forKey: .privateIpAddress)
        }
        if decoderContainer.contains(.elasticIpId)
        {
            self.elasticIpId = try decoderContainer.decode(String?.self, forKey: .elasticIpId)
        }
        if decoderContainer.contains(.elasticIpAddress)
        {
            self.elasticIpAddress = try decoderContainer.decode(String?.self, forKey: .elasticIpAddress)
        }
        if decoderContainer.contains(.primaryNetworkInterface)
        {
            self.primaryNetworkInterface = try decoderContainer.decode(InstanceNetworkInterfaceAttachment?.self, forKey: .primaryNetworkInterface)
        }
        if decoderContainer.contains(.secondaryNetworkInterfaces)
        {
            self.secondaryNetworkInterfaces = try decoderContainer.decode([InstanceNetworkInterfaceAttachment?]?.self, forKey: .secondaryNetworkInterfaces)
        }
        if decoderContainer.contains(.logConfiguration)
        {
            self.logConfiguration = try decoderContainer.decode(LogConfiguration?.self, forKey: .logConfiguration)
        }
        if decoderContainer.contains(.tags)
        {
            self.tags = try decoderContainer.decode([Tag?]?.self, forKey: .tags)
        }
        if decoderContainer.contains(.charge)
        {
            self.charge = try decoderContainer.decode(Charge?.self, forKey: .charge)
        }
        if decoderContainer.contains(.launchTime)
        {
            self.launchTime = try decoderContainer.decode(String?.self, forKey: .launchTime)
        }
        if decoderContainer.contains(.reason)
        {
            self.reason = try decoderContainer.decode(String?.self, forKey: .reason)
        }
        if decoderContainer.contains(.descriptionValue)
        {
            self.descriptionValue = try decoderContainer.decode(String?.self, forKey: .descriptionValue)
        }
    }
}
public extension Container{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: ContainerCodingKeys.self)
         try encoderContainer.encode(containerId, forKey: .containerId)
         try encoderContainer.encode(status, forKey: .status)
         try encoderContainer.encode(instanceType, forKey: .instanceType)
         try encoderContainer.encode(az, forKey: .az)
         try encoderContainer.encode(name, forKey: .name)
         try encoderContainer.encode(hostAliases, forKey: .hostAliases)
         try encoderContainer.encode(hostname, forKey: .hostname)
         try encoderContainer.encode(command, forKey: .command)
         try encoderContainer.encode(args, forKey: .args)
         try encoderContainer.encode(envs, forKey: .envs)
         try encoderContainer.encode(image, forKey: .image)
         try encoderContainer.encode(secret, forKey: .secret)
         try encoderContainer.encode(tty, forKey: .tty)
         try encoderContainer.encode(workingDir, forKey: .workingDir)
         try encoderContainer.encode(rootVolume, forKey: .rootVolume)
         try encoderContainer.encode(dataVolumes, forKey: .dataVolumes)
         try encoderContainer.encode(vpcId, forKey: .vpcId)
         try encoderContainer.encode(subnetId, forKey: .subnetId)
         try encoderContainer.encode(privateIpAddress, forKey: .privateIpAddress)
         try encoderContainer.encode(elasticIpId, forKey: .elasticIpId)
         try encoderContainer.encode(elasticIpAddress, forKey: .elasticIpAddress)
         try encoderContainer.encode(primaryNetworkInterface, forKey: .primaryNetworkInterface)
         try encoderContainer.encode(secondaryNetworkInterfaces, forKey: .secondaryNetworkInterfaces)
         try encoderContainer.encode(logConfiguration, forKey: .logConfiguration)
         try encoderContainer.encode(tags, forKey: .tags)
         try encoderContainer.encode(charge, forKey: .charge)
         try encoderContainer.encode(launchTime, forKey: .launchTime)
         try encoderContainer.encode(reason, forKey: .reason)
         try encoderContainer.encode(descriptionValue, forKey: .descriptionValue)
    }
}
///  环境变量
public class EnvVar:NSObject,Codable{
    /// 环境变量名称
    /// Required:true
    var name:String
    /// 环境变量的值
    var value:String?



    public  init(name:String){
             self.name = name
    }

    enum EnvVarCodingKeys: String, CodingKey {
        case name
        case value
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: EnvVarCodingKeys.self)
        self.name = try decoderContainer.decode(String.self, forKey: .name)
        if decoderContainer.contains(.value)
        {
            self.value = try decoderContainer.decode(String?.self, forKey: .value)
        }
    }
}
public extension EnvVar{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: EnvVarCodingKeys.self)
         try encoderContainer.encode(name, forKey: .name)
         try encoderContainer.encode(value, forKey: .value)
    }
}
///  描述容器网卡的绑定信息
public class InstanceNetworkInterfaceAttachment:NSObject,Codable{
    /// 指明删除实例时是否删除网卡
    var autoDelete:Bool?
    /// 设备Index
    var deviceIndex:Int?
    /// 绑定状态
    var attachStatus:String?
    /// 绑定时间
    var attachTime:String?
    /// 弹性网卡信息
    var networkInterface:InstanceNetworkInterface?



    public override init(){
            super.init()
    }

    enum InstanceNetworkInterfaceAttachmentCodingKeys: String, CodingKey {
        case autoDelete
        case deviceIndex
        case attachStatus
        case attachTime
        case networkInterface
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: InstanceNetworkInterfaceAttachmentCodingKeys.self)
        if decoderContainer.contains(.autoDelete)
        {
            self.autoDelete = try decoderContainer.decode(Bool?.self, forKey: .autoDelete)
        }
        if decoderContainer.contains(.deviceIndex)
        {
            self.deviceIndex = try decoderContainer.decode(Int?.self, forKey: .deviceIndex)
        }
        if decoderContainer.contains(.attachStatus)
        {
            self.attachStatus = try decoderContainer.decode(String?.self, forKey: .attachStatus)
        }
        if decoderContainer.contains(.attachTime)
        {
            self.attachTime = try decoderContainer.decode(String?.self, forKey: .attachTime)
        }
        if decoderContainer.contains(.networkInterface)
        {
            self.networkInterface = try decoderContainer.decode(InstanceNetworkInterface?.self, forKey: .networkInterface)
        }
    }
}
public extension InstanceNetworkInterfaceAttachment{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: InstanceNetworkInterfaceAttachmentCodingKeys.self)
         try encoderContainer.encode(autoDelete, forKey: .autoDelete)
         try encoderContainer.encode(deviceIndex, forKey: .deviceIndex)
         try encoderContainer.encode(attachStatus, forKey: .attachStatus)
         try encoderContainer.encode(attachTime, forKey: .attachTime)
         try encoderContainer.encode(networkInterface, forKey: .networkInterface)
    }
}
///  tagFilter
public class TagFilter:NSObject,Codable{
    /// Tag键
    /// Required:true
    var key:String
    /// Tag值
    var values:[String?]?



    public  init(key:String){
             self.key = key
    }

    enum TagFilterCodingKeys: String, CodingKey {
        case key
        case values
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: TagFilterCodingKeys.self)
        self.key = try decoderContainer.decode(String.self, forKey: .key)
        if decoderContainer.contains(.values)
        {
            self.values = try decoderContainer.decode([String?]?.self, forKey: .values)
        }
    }
}
public extension TagFilter{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: TagFilterCodingKeys.self)
         try encoderContainer.encode(key, forKey: .key)
         try encoderContainer.encode(values, forKey: .values)
    }
}
///  创建网卡请求模板
public class NetworkInterfaceSpec:NSObject,Codable{
    /// 子网ID
    /// Required:true
    var subnetId:String
    /// 可用区，用户的默认可用区，暂不支持
    /// Required:true
    var az:String
    /// 网卡主IP
    var primaryIpAddress:String?
    /// SecondaryIp列表
    var secondaryIpAddresses:[String?]?
    /// 自动分配的SecondaryIp数量
    var secondaryIpCount:Int?
    /// 要绑定的安全组ID列表，最多指定5个安全组
    var securityGroups:[String?]?
    /// 源和目标IP地址校验，取值为0或者1，默认为1，暂不支持此功能
    var sanityCheck:Bool?
    /// 描述
    var descriptionValue:String?



    public  init(subnetId:String,az:String){
             self.subnetId = subnetId
             self.az = az
    }

    enum NetworkInterfaceSpecCodingKeys: String, CodingKey {
        case subnetId
        case az
        case primaryIpAddress
        case secondaryIpAddresses
        case secondaryIpCount
        case securityGroups
        case sanityCheck
        case descriptionValue = "description"
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: NetworkInterfaceSpecCodingKeys.self)
        self.subnetId = try decoderContainer.decode(String.self, forKey: .subnetId)
        self.az = try decoderContainer.decode(String.self, forKey: .az)
        if decoderContainer.contains(.primaryIpAddress)
        {
            self.primaryIpAddress = try decoderContainer.decode(String?.self, forKey: .primaryIpAddress)
        }
        if decoderContainer.contains(.secondaryIpAddresses)
        {
            self.secondaryIpAddresses = try decoderContainer.decode([String?]?.self, forKey: .secondaryIpAddresses)
        }
        if decoderContainer.contains(.secondaryIpCount)
        {
            self.secondaryIpCount = try decoderContainer.decode(Int?.self, forKey: .secondaryIpCount)
        }
        if decoderContainer.contains(.securityGroups)
        {
            self.securityGroups = try decoderContainer.decode([String?]?.self, forKey: .securityGroups)
        }
        if decoderContainer.contains(.sanityCheck)
        {
            self.sanityCheck = try decoderContainer.decode(Bool?.self, forKey: .sanityCheck)
        }
        if decoderContainer.contains(.descriptionValue)
        {
            self.descriptionValue = try decoderContainer.decode(String?.self, forKey: .descriptionValue)
        }
    }
}
public extension NetworkInterfaceSpec{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: NetworkInterfaceSpecCodingKeys.self)
         try encoderContainer.encode(subnetId, forKey: .subnetId)
         try encoderContainer.encode(az, forKey: .az)
         try encoderContainer.encode(primaryIpAddress, forKey: .primaryIpAddress)
         try encoderContainer.encode(secondaryIpAddresses, forKey: .secondaryIpAddresses)
         try encoderContainer.encode(secondaryIpCount, forKey: .secondaryIpCount)
         try encoderContainer.encode(securityGroups, forKey: .securityGroups)
         try encoderContainer.encode(sanityCheck, forKey: .sanityCheck)
         try encoderContainer.encode(descriptionValue, forKey: .descriptionValue)
    }
}
///  域名和IP映射的信息
public class HostAliasSpec:NSObject,Codable{
    /// 域名列表
    /// Required:true
    var hostnames:[String?]?
    /// IP地址
    /// Required:true
    var ip:String



    public  init(hostnames:[String?]?,ip:String){
             self.hostnames = hostnames
             self.ip = ip
    }

    enum HostAliasSpecCodingKeys: String, CodingKey {
        case hostnames
        case ip
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: HostAliasSpecCodingKeys.self)
        self.hostnames = try decoderContainer.decode([String?]?.self, forKey: .hostnames)
        self.ip = try decoderContainer.decode(String.self, forKey: .ip)
    }
}
public extension HostAliasSpec{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: HostAliasSpecCodingKeys.self)
         try encoderContainer.encode(hostnames, forKey: .hostnames)
         try encoderContainer.encode(ip, forKey: .ip)
    }
}
///  域名和IP映射的信息
public class HostAlias:NSObject,Codable{
    /// 域名列表
    var hostnames:[String?]?
    /// IP地址
    var ip:String?



    public override init(){
            super.init()
    }

    enum HostAliasCodingKeys: String, CodingKey {
        case hostnames
        case ip
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: HostAliasCodingKeys.self)
        if decoderContainer.contains(.hostnames)
        {
            self.hostnames = try decoderContainer.decode([String?]?.self, forKey: .hostnames)
        }
        if decoderContainer.contains(.ip)
        {
            self.ip = try decoderContainer.decode(String?.self, forKey: .ip)
        }
    }
}
public extension HostAlias{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: HostAliasCodingKeys.self)
         try encoderContainer.encode(hostnames, forKey: .hostnames)
         try encoderContainer.encode(ip, forKey: .ip)
    }
}
///  描述网卡安全组的基本信息
public class SecurityGroupSimple:NSObject,Codable{
    /// 安全组ID
    var groupId:String?
    /// 安全组名称
    var groupName:String?



    public override init(){
            super.init()
    }

    enum SecurityGroupSimpleCodingKeys: String, CodingKey {
        case groupId
        case groupName
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: SecurityGroupSimpleCodingKeys.self)
        if decoderContainer.contains(.groupId)
        {
            self.groupId = try decoderContainer.decode(String?.self, forKey: .groupId)
        }
        if decoderContainer.contains(.groupName)
        {
            self.groupName = try decoderContainer.decode(String?.self, forKey: .groupName)
        }
    }
}
public extension SecurityGroupSimple{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: SecurityGroupSimpleCodingKeys.self)
         try encoderContainer.encode(groupId, forKey: .groupId)
         try encoderContainer.encode(groupName, forKey: .groupName)
    }
}
///  在创建容器时指定的网卡信息
public class ContainerNetworkInterfaceAttachmentSpec:NSObject,Codable{
    /// 指明删除容器时是否删除网卡，默认True；当前只能是True
    var autoDelete:Bool?
    /// 设备Index
    var deviceIndex:Int?
    /// 网卡接口规范
    /// Required:true
    var networkInterface:NetworkInterfaceSpec



    public  init(networkInterface:NetworkInterfaceSpec){
             self.networkInterface = networkInterface
    }

    enum ContainerNetworkInterfaceAttachmentSpecCodingKeys: String, CodingKey {
        case autoDelete
        case deviceIndex
        case networkInterface
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: ContainerNetworkInterfaceAttachmentSpecCodingKeys.self)
        if decoderContainer.contains(.autoDelete)
        {
            self.autoDelete = try decoderContainer.decode(Bool?.self, forKey: .autoDelete)
        }
        if decoderContainer.contains(.deviceIndex)
        {
            self.deviceIndex = try decoderContainer.decode(Int?.self, forKey: .deviceIndex)
        }
        self.networkInterface = try decoderContainer.decode(NetworkInterfaceSpec.self, forKey: .networkInterface)
    }
}
public extension ContainerNetworkInterfaceAttachmentSpec{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: ContainerNetworkInterfaceAttachmentSpecCodingKeys.self)
         try encoderContainer.encode(autoDelete, forKey: .autoDelete)
         try encoderContainer.encode(deviceIndex, forKey: .deviceIndex)
         try encoderContainer.encode(networkInterface, forKey: .networkInterface)
    }
}
///  指定挂载的Volume
public class VolumeMountSpec:NSObject,Codable{
    /// 磁盘分类 cloud：基于云硬盘的卷 仅支持cloud类型
    /// Required:true
    var category:String
    /// 自动删除，删除容器时自动删除此volume，默认为True；只支持磁盘是云硬盘的场景
    var autoDelete:Bool?
    /// 容器内的挂载目录；root volume不需要指定，挂载目录是（/）；data volume必须指定；必须是绝对路径，不能包含(:)
    var mountPath:String?
    /// 只读，默认false；只针对data volume有效；root volume为false，也就是可读可写
    var readOnly:Bool?
    /// 云硬盘规格；随容器自动创建的云硬盘，不会对磁盘分区，只会格式化文件系统
    var cloudDiskSpec:DiskSpec?
    /// 云硬盘ID，使用已有的云硬盘，必须同时指定fsType
    var cloudDiskId:String?
    /// 指定volume文件系统类型，目前支持[xfs, ext4]；如果新创建的盘，不指定文件系统类型默认格式化成xfs
    var fsType:String?
    /// 随容器自动创建的新盘，会自动格式化成指定的文件系统类型；挂载已有的盘，默认不会格式化，只会按照指定的fsType去挂载；如果希望格式化，必须设置此字段为true
    var formatVolume:Bool?



    public  init(category:String){
             self.category = category
    }

    enum VolumeMountSpecCodingKeys: String, CodingKey {
        case category
        case autoDelete
        case mountPath
        case readOnly
        case cloudDiskSpec
        case cloudDiskId
        case fsType
        case formatVolume
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: VolumeMountSpecCodingKeys.self)
        self.category = try decoderContainer.decode(String.self, forKey: .category)
        if decoderContainer.contains(.autoDelete)
        {
            self.autoDelete = try decoderContainer.decode(Bool?.self, forKey: .autoDelete)
        }
        if decoderContainer.contains(.mountPath)
        {
            self.mountPath = try decoderContainer.decode(String?.self, forKey: .mountPath)
        }
        if decoderContainer.contains(.readOnly)
        {
            self.readOnly = try decoderContainer.decode(Bool?.self, forKey: .readOnly)
        }
        if decoderContainer.contains(.cloudDiskSpec)
        {
            self.cloudDiskSpec = try decoderContainer.decode(DiskSpec?.self, forKey: .cloudDiskSpec)
        }
        if decoderContainer.contains(.cloudDiskId)
        {
            self.cloudDiskId = try decoderContainer.decode(String?.self, forKey: .cloudDiskId)
        }
        if decoderContainer.contains(.fsType)
        {
            self.fsType = try decoderContainer.decode(String?.self, forKey: .fsType)
        }
        if decoderContainer.contains(.formatVolume)
        {
            self.formatVolume = try decoderContainer.decode(Bool?.self, forKey: .formatVolume)
        }
    }
}
public extension VolumeMountSpec{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: VolumeMountSpecCodingKeys.self)
         try encoderContainer.encode(category, forKey: .category)
         try encoderContainer.encode(autoDelete, forKey: .autoDelete)
         try encoderContainer.encode(mountPath, forKey: .mountPath)
         try encoderContainer.encode(readOnly, forKey: .readOnly)
         try encoderContainer.encode(cloudDiskSpec, forKey: .cloudDiskSpec)
         try encoderContainer.encode(cloudDiskId, forKey: .cloudDiskId)
         try encoderContainer.encode(fsType, forKey: .fsType)
         try encoderContainer.encode(formatVolume, forKey: .formatVolume)
    }
}
///  描述实例的网卡信息
public class InstanceNetworkInterface:NSObject,Codable{
    /// 弹性网卡ID
    var networkInterfaceId:String?
    /// 以太网地址
    var macAddress:String?
    /// 虚拟网络ID
    var vpcId:String?
    /// 子网ID
    var subnetId:String?
    /// 描述
    var descriptionValue:String?
    /// 安全组列表
    var securityGroups:[SecurityGroupSimple?]?
    /// 源和目标IP地址校验，取值为0或者1
    var sanityCheck:Bool?
    /// 网卡主IP
    var primaryIp:NetworkInterfacePrivateIp?
    /// null
    var secondaryIps:[NetworkInterfacePrivateIp?]?



    public override init(){
            super.init()
    }

    enum InstanceNetworkInterfaceCodingKeys: String, CodingKey {
        case networkInterfaceId
        case macAddress
        case vpcId
        case subnetId
        case descriptionValue = "description"
        case securityGroups
        case sanityCheck
        case primaryIp
        case secondaryIps
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: InstanceNetworkInterfaceCodingKeys.self)
        if decoderContainer.contains(.networkInterfaceId)
        {
            self.networkInterfaceId = try decoderContainer.decode(String?.self, forKey: .networkInterfaceId)
        }
        if decoderContainer.contains(.macAddress)
        {
            self.macAddress = try decoderContainer.decode(String?.self, forKey: .macAddress)
        }
        if decoderContainer.contains(.vpcId)
        {
            self.vpcId = try decoderContainer.decode(String?.self, forKey: .vpcId)
        }
        if decoderContainer.contains(.subnetId)
        {
            self.subnetId = try decoderContainer.decode(String?.self, forKey: .subnetId)
        }
        if decoderContainer.contains(.descriptionValue)
        {
            self.descriptionValue = try decoderContainer.decode(String?.self, forKey: .descriptionValue)
        }
        if decoderContainer.contains(.securityGroups)
        {
            self.securityGroups = try decoderContainer.decode([SecurityGroupSimple?]?.self, forKey: .securityGroups)
        }
        if decoderContainer.contains(.sanityCheck)
        {
            self.sanityCheck = try decoderContainer.decode(Bool?.self, forKey: .sanityCheck)
        }
        if decoderContainer.contains(.primaryIp)
        {
            self.primaryIp = try decoderContainer.decode(NetworkInterfacePrivateIp?.self, forKey: .primaryIp)
        }
        if decoderContainer.contains(.secondaryIps)
        {
            self.secondaryIps = try decoderContainer.decode([NetworkInterfacePrivateIp?]?.self, forKey: .secondaryIps)
        }
    }
}
public extension InstanceNetworkInterface{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: InstanceNetworkInterfaceCodingKeys.self)
         try encoderContainer.encode(networkInterfaceId, forKey: .networkInterfaceId)
         try encoderContainer.encode(macAddress, forKey: .macAddress)
         try encoderContainer.encode(vpcId, forKey: .vpcId)
         try encoderContainer.encode(subnetId, forKey: .subnetId)
         try encoderContainer.encode(descriptionValue, forKey: .descriptionValue)
         try encoderContainer.encode(securityGroups, forKey: .securityGroups)
         try encoderContainer.encode(sanityCheck, forKey: .sanityCheck)
         try encoderContainer.encode(primaryIp, forKey: .primaryIp)
         try encoderContainer.encode(secondaryIps, forKey: .secondaryIps)
    }
}
///  挂载的Volume
public class VolumeMount:NSObject,Codable{
    /// 磁盘分类
    var category:String?
    /// 自动删除，删除容器时自动删除此volume
    var autoDelete:Bool?
    /// 容器内的挂载目录
    var mountPath:String?
    /// 只读，默认false；只针对data volume有效，root volume为false
    var readOnly:Bool?
    /// 云硬盘规格
    var cloudDisk:InstanceCloudDisk?
    /// 指定volume文件系统类型，目前支持[xfs, ext4]
    var fsType:String?



    public override init(){
            super.init()
    }

    enum VolumeMountCodingKeys: String, CodingKey {
        case category
        case autoDelete
        case mountPath
        case readOnly
        case cloudDisk
        case fsType
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: VolumeMountCodingKeys.self)
        if decoderContainer.contains(.category)
        {
            self.category = try decoderContainer.decode(String?.self, forKey: .category)
        }
        if decoderContainer.contains(.autoDelete)
        {
            self.autoDelete = try decoderContainer.decode(Bool?.self, forKey: .autoDelete)
        }
        if decoderContainer.contains(.mountPath)
        {
            self.mountPath = try decoderContainer.decode(String?.self, forKey: .mountPath)
        }
        if decoderContainer.contains(.readOnly)
        {
            self.readOnly = try decoderContainer.decode(Bool?.self, forKey: .readOnly)
        }
        if decoderContainer.contains(.cloudDisk)
        {
            self.cloudDisk = try decoderContainer.decode(InstanceCloudDisk?.self, forKey: .cloudDisk)
        }
        if decoderContainer.contains(.fsType)
        {
            self.fsType = try decoderContainer.decode(String?.self, forKey: .fsType)
        }
    }
}
public extension VolumeMount{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: VolumeMountCodingKeys.self)
         try encoderContainer.encode(category, forKey: .category)
         try encoderContainer.encode(autoDelete, forKey: .autoDelete)
         try encoderContainer.encode(mountPath, forKey: .mountPath)
         try encoderContainer.encode(readOnly, forKey: .readOnly)
         try encoderContainer.encode(cloudDisk, forKey: .cloudDisk)
         try encoderContainer.encode(fsType, forKey: .fsType)
    }
}
///  tag
public class Tag:NSObject,Codable{
    /// Tag键
    var key:String?
    /// Tag值
    var value:String?



    public override init(){
            super.init()
    }

    enum TagCodingKeys: String, CodingKey {
        case key
        case value
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: TagCodingKeys.self)
        if decoderContainer.contains(.key)
        {
            self.key = try decoderContainer.decode(String?.self, forKey: .key)
        }
        if decoderContainer.contains(.value)
        {
            self.value = try decoderContainer.decode(String?.self, forKey: .value)
        }
    }
}
public extension Tag{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: TagCodingKeys.self)
         try encoderContainer.encode(key, forKey: .key)
         try encoderContainer.encode(value, forKey: .value)
    }
}
///  容器日志配置信息
public class LogConfiguration:NSObject,Codable{
    /// 日志Driver名称  default：默认在本地分配10MB的存储空间，自动rotate
    var logDriver:String?



    public override init(){
            super.init()
    }

    enum LogConfigurationCodingKeys: String, CodingKey {
        case logDriver
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: LogConfigurationCodingKeys.self)
        if decoderContainer.contains(.logDriver)
        {
            self.logDriver = try decoderContainer.decode(String?.self, forKey: .logDriver)
        }
    }
}
public extension LogConfiguration{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: LogConfigurationCodingKeys.self)
         try encoderContainer.encode(logDriver, forKey: .logDriver)
    }
}
///  secret 的数据
public class DockerRegistryData:NSObject,Codable{
    /// registry服务器地址
    /// Required:true
    var server:String
    /// 用户名
    /// Required:true
    var username:String
    /// 密码
    /// Required:true
    var password:String
    /// 邮件地址
    var email:String?



    public  init(server:String,username:String,password:String){
             self.server = server
             self.username = username
             self.password = password
    }

    enum DockerRegistryDataCodingKeys: String, CodingKey {
        case server
        case username
        case password
        case email
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: DockerRegistryDataCodingKeys.self)
        self.server = try decoderContainer.decode(String.self, forKey: .server)
        self.username = try decoderContainer.decode(String.self, forKey: .username)
        self.password = try decoderContainer.decode(String.self, forKey: .password)
        if decoderContainer.contains(.email)
        {
            self.email = try decoderContainer.decode(String?.self, forKey: .email)
        }
    }
}
public extension DockerRegistryData{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: DockerRegistryDataCodingKeys.self)
         try encoderContainer.encode(server, forKey: .server)
         try encoderContainer.encode(username, forKey: .username)
         try encoderContainer.encode(password, forKey: .password)
         try encoderContainer.encode(email, forKey: .email)
    }
}
///  机密数据
public class Secret:NSObject,Codable{
    /// 机密数据名称
    var name:String?
    /// 私密数据的类型，目前仅支持如下类型：docker-registry：用来和docker registry认证的类型
    var secretType:String?
    /// 创建时间
    var createdAt:String?
    /// 机密的数据
    var data:DockerRegistryData?



    public override init(){
            super.init()
    }

    enum SecretCodingKeys: String, CodingKey {
        case name
        case secretType
        case createdAt
        case data
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: SecretCodingKeys.self)
        if decoderContainer.contains(.name)
        {
            self.name = try decoderContainer.decode(String?.self, forKey: .name)
        }
        if decoderContainer.contains(.secretType)
        {
            self.secretType = try decoderContainer.decode(String?.self, forKey: .secretType)
        }
        if decoderContainer.contains(.createdAt)
        {
            self.createdAt = try decoderContainer.decode(String?.self, forKey: .createdAt)
        }
        if decoderContainer.contains(.data)
        {
            self.data = try decoderContainer.decode(DockerRegistryData?.self, forKey: .data)
        }
    }
}
public extension Secret{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: SecretCodingKeys.self)
         try encoderContainer.encode(name, forKey: .name)
         try encoderContainer.encode(secretType, forKey: .secretType)
         try encoderContainer.encode(createdAt, forKey: .createdAt)
         try encoderContainer.encode(data, forKey: .data)
    }
}
///  instanceInfo
public class InstanceInfo:NSObject,Codable{
    /// 容器ID
    var resourceId:String?
    /// 容器名称
    var resourceName:String?
    /// 备注
    var remark:String?
    /// 绑定资源
    var bind:[BindInfo?]?



    public override init(){
            super.init()
    }

    enum InstanceInfoCodingKeys: String, CodingKey {
        case resourceId
        case resourceName
        case remark
        case bind
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: InstanceInfoCodingKeys.self)
        if decoderContainer.contains(.resourceId)
        {
            self.resourceId = try decoderContainer.decode(String?.self, forKey: .resourceId)
        }
        if decoderContainer.contains(.resourceName)
        {
            self.resourceName = try decoderContainer.decode(String?.self, forKey: .resourceName)
        }
        if decoderContainer.contains(.remark)
        {
            self.remark = try decoderContainer.decode(String?.self, forKey: .remark)
        }
        if decoderContainer.contains(.bind)
        {
            self.bind = try decoderContainer.decode([BindInfo?]?.self, forKey: .bind)
        }
    }
}
public extension InstanceInfo{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: InstanceInfoCodingKeys.self)
         try encoderContainer.encode(resourceId, forKey: .resourceId)
         try encoderContainer.encode(resourceName, forKey: .resourceName)
         try encoderContainer.encode(remark, forKey: .remark)
         try encoderContainer.encode(bind, forKey: .bind)
    }
}
///  bindInfo
public class BindInfo:NSObject,Codable{
    /// 容器ID
    var resourceId:String?
    /// 容器名称
    var resourceName:String?
    /// 备注
    var remark:String?



    public override init(){
            super.init()
    }

    enum BindInfoCodingKeys: String, CodingKey {
        case resourceId
        case resourceName
        case remark
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: BindInfoCodingKeys.self)
        if decoderContainer.contains(.resourceId)
        {
            self.resourceId = try decoderContainer.decode(String?.self, forKey: .resourceId)
        }
        if decoderContainer.contains(.resourceName)
        {
            self.resourceName = try decoderContainer.decode(String?.self, forKey: .resourceName)
        }
        if decoderContainer.contains(.remark)
        {
            self.remark = try decoderContainer.decode(String?.self, forKey: .remark)
        }
    }
}
public extension BindInfo{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: BindInfoCodingKeys.self)
         try encoderContainer.encode(resourceId, forKey: .resourceId)
         try encoderContainer.encode(resourceName, forKey: .resourceName)
         try encoderContainer.encode(remark, forKey: .remark)
    }
}
///  logs
public class Logs:NSObject,Codable{
    /// Content
    var content:String?



    public override init(){
            super.init()
    }

    enum LogsCodingKeys: String, CodingKey {
        case content
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: LogsCodingKeys.self)
        if decoderContainer.contains(.content)
        {
            self.content = try decoderContainer.decode(String?.self, forKey: .content)
        }
    }
}
public extension Logs{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: LogsCodingKeys.self)
         try encoderContainer.encode(content, forKey: .content)
    }
}
///  null
public class LogOption:NSObject,Codable{
    /// null
    var key:String?
    /// null
    var value:String?



    public override init(){
            super.init()
    }

    enum LogOptionCodingKeys: String, CodingKey {
        case key
        case value
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: LogOptionCodingKeys.self)
        if decoderContainer.contains(.key)
        {
            self.key = try decoderContainer.decode(String?.self, forKey: .key)
        }
        if decoderContainer.contains(.value)
        {
            self.value = try decoderContainer.decode(String?.self, forKey: .value)
        }
    }
}
public extension LogOption{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: LogOptionCodingKeys.self)
         try encoderContainer.encode(key, forKey: .key)
         try encoderContainer.encode(value, forKey: .value)
    }
}

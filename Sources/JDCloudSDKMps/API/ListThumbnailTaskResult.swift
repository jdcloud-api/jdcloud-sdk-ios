/* Copyright 2018 JDCLOUD.COM

   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at

     http:#www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.

   媒体处理相关接口
   媒体处理API

   OpenAPI spec version: 1.0.0
   Contact: 

   NOTE: This class is auto generated by the jdcloud code generator program.
 */


import Foundation
import JDCloudSDKCore

/// 查询截图任务
@objc(ListThumbnailTaskResult)
public class ListThumbnailTaskResult:NSObject,JdCloudResult
{
    /// 状态 (SUCCESS, ERROR, PENDDING, RUNNING)
    var status:String?

    /// 查询开始时间 时间格式(GMT): yyyy-MM-dd’T’HH:mm:ss.SSS’Z’
    var begin:String?

    /// 查询结束时间 时间格式(GMT): yyyy-MM-dd’T’HH:mm:ss.SSS’Z’
    var end:String?

    /// 本次请求的marker, 标记查询的起始位置, 此处为taskID
    var marker:String?

    /// 本次请求返回的任务列表的最大元素个数, 有效值: [1-1000]，默认值: 1000
    var limit:Int?

    /// 获取下一页所需要传递的marker值(此处为taskID), 仅当isTruncated为true时(数据未全部返回)出现 (readonly)
    var nextMarker:String?

    /// 指明返回数据是否被截断. true表示本页后面还有数据, 即数据未全部返回; false表示已是最后一页, 即数据已全部返回 (readonly)
    var truncated:Bool?

    /// 返回的task列表 (readonly)
    var taskList:[ThumbnailTask?]?



    public override init(){
        super.init()
    }

    enum ListThumbnailTaskResultCodingKeys: String, CodingKey {
        case status
        case begin
        case end
        case marker
        case limit
        case nextMarker
        case truncated
        case taskList
    }

    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: ListThumbnailTaskResultCodingKeys.self)
        if decoderContainer.contains(.status)
        {
            self.status = try decoderContainer.decode(String?.self, forKey: .status)
        }
        if decoderContainer.contains(.begin)
        {
            self.begin = try decoderContainer.decode(String?.self, forKey: .begin)
        }
        if decoderContainer.contains(.end)
        {
            self.end = try decoderContainer.decode(String?.self, forKey: .end)
        }
        if decoderContainer.contains(.marker)
        {
            self.marker = try decoderContainer.decode(String?.self, forKey: .marker)
        }
        if decoderContainer.contains(.limit)
        {
            self.limit = try decoderContainer.decode(Int?.self, forKey: .limit)
        }
        if decoderContainer.contains(.nextMarker)
        {
            self.nextMarker = try decoderContainer.decode(String?.self, forKey: .nextMarker)
        }
        if decoderContainer.contains(.truncated)
        {
            self.truncated = try decoderContainer.decode(Bool?.self, forKey: .truncated)
        }
        if decoderContainer.contains(.taskList)
        {
            self.taskList = try decoderContainer.decode([ThumbnailTask?]?.self, forKey: .taskList)
        }
    }
}
public extension ListThumbnailTaskResult{
    public func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: ListThumbnailTaskResultCodingKeys.self)
        try encoderContainer.encode(status, forKey: .status)
        try encoderContainer.encode(begin, forKey: .begin)
        try encoderContainer.encode(end, forKey: .end)
        try encoderContainer.encode(marker, forKey: .marker)
        try encoderContainer.encode(limit, forKey: .limit)
        try encoderContainer.encode(nextMarker, forKey: .nextMarker)
        try encoderContainer.encode(truncated, forKey: .truncated)
        try encoderContainer.encode(taskList, forKey: .taskList)
    }
}

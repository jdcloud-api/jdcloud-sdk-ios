/* Copyright 2018 JDCLOUD.COM

   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at

     http:#www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.

   SubUser Management
   SubUser Management API

   OpenAPI spec version: v1
   Contact: 

   NOTE: This class is auto generated by the jdcloud code generator program.
 */


import Foundation
///  roleInfo
public class RoleInfo:NSObject,Codable{
    /// 角色ID
    var roleId:String?
    /// 角色名称
    var roleName:String?
    /// 角色类型，2-服务相关角色，3-服务角色，4-用户角色
    var type:Int?
    /// 信任实体信息
    var assumeRolePolicyDocument:String?
    /// 描述，0~256个字符
    var descriptionValue:String?
    /// 最大会话时长3600~43200秒，默认3600秒
    var maxSessionDuration:Int?
    /// 京东云资源标识(jrn)
    var jrn:String?
    /// 创建角色的时间
    var createTime:String?
    /// 角色所属主账号
    var account:String?



    public override init(){
            super.init()
    }

    enum RoleInfoCodingKeys: String, CodingKey {
        case roleId
        case roleName
        case type
        case assumeRolePolicyDocument
        case descriptionValue = "description"
        case maxSessionDuration
        case jrn
        case createTime
        case account
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: RoleInfoCodingKeys.self)
        if decoderContainer.contains(.roleId)
        {
            self.roleId = try decoderContainer.decode(String?.self, forKey: .roleId)
        }
        if decoderContainer.contains(.roleName)
        {
            self.roleName = try decoderContainer.decode(String?.self, forKey: .roleName)
        }
        if decoderContainer.contains(.type)
        {
            self.type = try decoderContainer.decode(Int?.self, forKey: .type)
        }
        if decoderContainer.contains(.assumeRolePolicyDocument)
        {
            self.assumeRolePolicyDocument = try decoderContainer.decode(String?.self, forKey: .assumeRolePolicyDocument)
        }
        if decoderContainer.contains(.descriptionValue)
        {
            self.descriptionValue = try decoderContainer.decode(String?.self, forKey: .descriptionValue)
        }
        if decoderContainer.contains(.maxSessionDuration)
        {
            self.maxSessionDuration = try decoderContainer.decode(Int?.self, forKey: .maxSessionDuration)
        }
        if decoderContainer.contains(.jrn)
        {
            self.jrn = try decoderContainer.decode(String?.self, forKey: .jrn)
        }
        if decoderContainer.contains(.createTime)
        {
            self.createTime = try decoderContainer.decode(String?.self, forKey: .createTime)
        }
        if decoderContainer.contains(.account)
        {
            self.account = try decoderContainer.decode(String?.self, forKey: .account)
        }
    }
}
public extension RoleInfo{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: RoleInfoCodingKeys.self)
         try encoderContainer.encode(roleId, forKey: .roleId)
         try encoderContainer.encode(roleName, forKey: .roleName)
         try encoderContainer.encode(type, forKey: .type)
         try encoderContainer.encode(assumeRolePolicyDocument, forKey: .assumeRolePolicyDocument)
         try encoderContainer.encode(descriptionValue, forKey: .descriptionValue)
         try encoderContainer.encode(maxSessionDuration, forKey: .maxSessionDuration)
         try encoderContainer.encode(jrn, forKey: .jrn)
         try encoderContainer.encode(createTime, forKey: .createTime)
         try encoderContainer.encode(account, forKey: .account)
    }
}
///  createRoleInfo
public class CreateRoleInfo:NSObject,Codable{
    /// 角色名，支持4~64位的字母，数字以及-和_, 以字母开头
    /// Required:true
    var roleName:String
    /// 角色类型，3-服务角色，4-用户角色
    /// Required:true
    var type:Int
    /// 角色信任关系策略
    /// Required:true
    var assumeRolePolicyDocument:String
    /// 描述，0~256个字符
    var descriptionValue:String?
    /// 最大会话时长3600~43200秒，默认3600秒
    var maxSessionDuration:Int?



    public  init(roleName:String,type:Int,assumeRolePolicyDocument:String){
             self.roleName = roleName
             self.type = type
             self.assumeRolePolicyDocument = assumeRolePolicyDocument
    }

    enum CreateRoleInfoCodingKeys: String, CodingKey {
        case roleName
        case type
        case assumeRolePolicyDocument
        case descriptionValue = "description"
        case maxSessionDuration
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: CreateRoleInfoCodingKeys.self)
        self.roleName = try decoderContainer.decode(String.self, forKey: .roleName)
        self.type = try decoderContainer.decode(Int.self, forKey: .type)
        self.assumeRolePolicyDocument = try decoderContainer.decode(String.self, forKey: .assumeRolePolicyDocument)
        if decoderContainer.contains(.descriptionValue)
        {
            self.descriptionValue = try decoderContainer.decode(String?.self, forKey: .descriptionValue)
        }
        if decoderContainer.contains(.maxSessionDuration)
        {
            self.maxSessionDuration = try decoderContainer.decode(Int?.self, forKey: .maxSessionDuration)
        }
    }
}
public extension CreateRoleInfo{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: CreateRoleInfoCodingKeys.self)
         try encoderContainer.encode(roleName, forKey: .roleName)
         try encoderContainer.encode(type, forKey: .type)
         try encoderContainer.encode(assumeRolePolicyDocument, forKey: .assumeRolePolicyDocument)
         try encoderContainer.encode(descriptionValue, forKey: .descriptionValue)
         try encoderContainer.encode(maxSessionDuration, forKey: .maxSessionDuration)
    }
}
///  updateRoleInfo
public class UpdateRoleInfo:NSObject,Codable{
    /// 描述，0~256个字符
    var descriptionValue:String?
    /// 最大会话时长3600~43200秒，默认3600秒
    var maxSessionDuration:Int?



    public override init(){
            super.init()
    }

    enum UpdateRoleInfoCodingKeys: String, CodingKey {
        case descriptionValue = "description"
        case maxSessionDuration
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: UpdateRoleInfoCodingKeys.self)
        if decoderContainer.contains(.descriptionValue)
        {
            self.descriptionValue = try decoderContainer.decode(String?.self, forKey: .descriptionValue)
        }
        if decoderContainer.contains(.maxSessionDuration)
        {
            self.maxSessionDuration = try decoderContainer.decode(Int?.self, forKey: .maxSessionDuration)
        }
    }
}
public extension UpdateRoleInfo{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: UpdateRoleInfoCodingKeys.self)
         try encoderContainer.encode(descriptionValue, forKey: .descriptionValue)
         try encoderContainer.encode(maxSessionDuration, forKey: .maxSessionDuration)
    }
}
///  listRoleInfo
public class ListRoleInfo:NSObject,Codable{
    /// 角色名称
    var roleName:String?
    /// 角色类型，2-服务相关角色，3-服务角色，4-用户角色
    var type:Int?
    /// 角色信任关系策略
    var assumeRolePolicyDocument:String?
    /// 描述，0~1000个字符
    var descriptionValue:String?
    /// 创建角色的时间
    var createTime:String?



    public override init(){
            super.init()
    }

    enum ListRoleInfoCodingKeys: String, CodingKey {
        case roleName
        case type
        case assumeRolePolicyDocument
        case descriptionValue = "description"
        case createTime
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: ListRoleInfoCodingKeys.self)
        if decoderContainer.contains(.roleName)
        {
            self.roleName = try decoderContainer.decode(String?.self, forKey: .roleName)
        }
        if decoderContainer.contains(.type)
        {
            self.type = try decoderContainer.decode(Int?.self, forKey: .type)
        }
        if decoderContainer.contains(.assumeRolePolicyDocument)
        {
            self.assumeRolePolicyDocument = try decoderContainer.decode(String?.self, forKey: .assumeRolePolicyDocument)
        }
        if decoderContainer.contains(.descriptionValue)
        {
            self.descriptionValue = try decoderContainer.decode(String?.self, forKey: .descriptionValue)
        }
        if decoderContainer.contains(.createTime)
        {
            self.createTime = try decoderContainer.decode(String?.self, forKey: .createTime)
        }
    }
}
public extension ListRoleInfo{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: ListRoleInfoCodingKeys.self)
         try encoderContainer.encode(roleName, forKey: .roleName)
         try encoderContainer.encode(type, forKey: .type)
         try encoderContainer.encode(assumeRolePolicyDocument, forKey: .assumeRolePolicyDocument)
         try encoderContainer.encode(descriptionValue, forKey: .descriptionValue)
         try encoderContainer.encode(createTime, forKey: .createTime)
    }
}
///  rolePolicy
public class RolePolicy:NSObject,Codable{
    /// 策略名称
    var policyName:String?
    /// 描述
    var descriptionValue:String?
    /// 策略类型：0-系统策略，1-用户策略
    var type:String?
    /// 京东云策略资源描述
    var policyJrn:String?



    public override init(){
            super.init()
    }

    enum RolePolicyCodingKeys: String, CodingKey {
        case policyName
        case descriptionValue = "description"
        case type
        case policyJrn
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: RolePolicyCodingKeys.self)
        if decoderContainer.contains(.policyName)
        {
            self.policyName = try decoderContainer.decode(String?.self, forKey: .policyName)
        }
        if decoderContainer.contains(.descriptionValue)
        {
            self.descriptionValue = try decoderContainer.decode(String?.self, forKey: .descriptionValue)
        }
        if decoderContainer.contains(.type)
        {
            self.type = try decoderContainer.decode(String?.self, forKey: .type)
        }
        if decoderContainer.contains(.policyJrn)
        {
            self.policyJrn = try decoderContainer.decode(String?.self, forKey: .policyJrn)
        }
    }
}
public extension RolePolicy{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: RolePolicyCodingKeys.self)
         try encoderContainer.encode(policyName, forKey: .policyName)
         try encoderContainer.encode(descriptionValue, forKey: .descriptionValue)
         try encoderContainer.encode(type, forKey: .type)
         try encoderContainer.encode(policyJrn, forKey: .policyJrn)
    }
}
///  updateAssumeRolePolicyInfo
public class UpdateAssumeRolePolicyInfo:NSObject,Codable{
    /// 信任实体信息
    var assumeRolePolicyDocument:String?



    public override init(){
            super.init()
    }

    enum UpdateAssumeRolePolicyInfoCodingKeys: String, CodingKey {
        case assumeRolePolicyDocument
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: UpdateAssumeRolePolicyInfoCodingKeys.self)
        if decoderContainer.contains(.assumeRolePolicyDocument)
        {
            self.assumeRolePolicyDocument = try decoderContainer.decode(String?.self, forKey: .assumeRolePolicyDocument)
        }
    }
}
public extension UpdateAssumeRolePolicyInfo{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: UpdateAssumeRolePolicyInfoCodingKeys.self)
         try encoderContainer.encode(assumeRolePolicyDocument, forKey: .assumeRolePolicyDocument)
    }
}
///  policyDetail
public class PolicyDetail:NSObject,Codable{
    /// 策略id
    var policyId:String?
    /// 策略名称
    var name:String?
    /// 京东云资源标识(jrn)
    var jrn:String?
    /// 描述
    var descriptionValue:String?
    /// 策略类型
    var policyType:String?
    /// 策略版本号
    var version:String?
    /// 默认策略文档版本
    var defaultEdition:Int?
    /// 策略文档
    var content:String?
    /// 策略创建时间
    var createTime:String?
    /// 策略更新时间
    var updateTime:String?



    public override init(){
            super.init()
    }

    enum PolicyDetailCodingKeys: String, CodingKey {
        case policyId
        case name
        case jrn
        case descriptionValue = "description"
        case policyType
        case version
        case defaultEdition
        case content
        case createTime
        case updateTime
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: PolicyDetailCodingKeys.self)
        if decoderContainer.contains(.policyId)
        {
            self.policyId = try decoderContainer.decode(String?.self, forKey: .policyId)
        }
        if decoderContainer.contains(.name)
        {
            self.name = try decoderContainer.decode(String?.self, forKey: .name)
        }
        if decoderContainer.contains(.jrn)
        {
            self.jrn = try decoderContainer.decode(String?.self, forKey: .jrn)
        }
        if decoderContainer.contains(.descriptionValue)
        {
            self.descriptionValue = try decoderContainer.decode(String?.self, forKey: .descriptionValue)
        }
        if decoderContainer.contains(.policyType)
        {
            self.policyType = try decoderContainer.decode(String?.self, forKey: .policyType)
        }
        if decoderContainer.contains(.version)
        {
            self.version = try decoderContainer.decode(String?.self, forKey: .version)
        }
        if decoderContainer.contains(.defaultEdition)
        {
            self.defaultEdition = try decoderContainer.decode(Int?.self, forKey: .defaultEdition)
        }
        if decoderContainer.contains(.content)
        {
            self.content = try decoderContainer.decode(String?.self, forKey: .content)
        }
        if decoderContainer.contains(.createTime)
        {
            self.createTime = try decoderContainer.decode(String?.self, forKey: .createTime)
        }
        if decoderContainer.contains(.updateTime)
        {
            self.updateTime = try decoderContainer.decode(String?.self, forKey: .updateTime)
        }
    }
}
public extension PolicyDetail{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: PolicyDetailCodingKeys.self)
         try encoderContainer.encode(policyId, forKey: .policyId)
         try encoderContainer.encode(name, forKey: .name)
         try encoderContainer.encode(jrn, forKey: .jrn)
         try encoderContainer.encode(descriptionValue, forKey: .descriptionValue)
         try encoderContainer.encode(policyType, forKey: .policyType)
         try encoderContainer.encode(version, forKey: .version)
         try encoderContainer.encode(defaultEdition, forKey: .defaultEdition)
         try encoderContainer.encode(content, forKey: .content)
         try encoderContainer.encode(createTime, forKey: .createTime)
         try encoderContainer.encode(updateTime, forKey: .updateTime)
    }
}
///  createPolicyInfo
public class CreatePolicyInfo:NSObject,Codable{
    /// 策略名，支持4~64位的字母，数字以及-和_, 以字母开头
    /// Required:true
    var name:String
    /// 描述，0~256个字符
    var descriptionValue:String?
    /// 策略文档，最多6144个字符
    /// Required:true
    var content:String



    public  init(name:String,content:String){
             self.name = name
             self.content = content
    }

    enum CreatePolicyInfoCodingKeys: String, CodingKey {
        case name
        case descriptionValue = "description"
        case content
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: CreatePolicyInfoCodingKeys.self)
        self.name = try decoderContainer.decode(String.self, forKey: .name)
        if decoderContainer.contains(.descriptionValue)
        {
            self.descriptionValue = try decoderContainer.decode(String?.self, forKey: .descriptionValue)
        }
        self.content = try decoderContainer.decode(String.self, forKey: .content)
    }
}
public extension CreatePolicyInfo{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: CreatePolicyInfoCodingKeys.self)
         try encoderContainer.encode(name, forKey: .name)
         try encoderContainer.encode(descriptionValue, forKey: .descriptionValue)
         try encoderContainer.encode(content, forKey: .content)
    }
}
///  policy
public class Policy:NSObject,Codable{
    /// 策略id
    var policyId:String?
    /// 策略名称
    var name:String?
    /// 京东云资源标识(jrn)
    var jrn:String?
    /// 描述
    var descriptionValue:String?
    /// 策略类型：0-系统策略，1-用户策略
    var policyType:String?
    /// 策略版本号
    var version:String?
    /// 默认策略文档版本
    var defaultEdition:Int?
    /// 策略创建时间
    var createTime:String?
    /// 策略更新时间
    var updateTime:String?



    public override init(){
            super.init()
    }

    enum PolicyCodingKeys: String, CodingKey {
        case policyId
        case name
        case jrn
        case descriptionValue = "description"
        case policyType
        case version
        case defaultEdition
        case createTime
        case updateTime
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: PolicyCodingKeys.self)
        if decoderContainer.contains(.policyId)
        {
            self.policyId = try decoderContainer.decode(String?.self, forKey: .policyId)
        }
        if decoderContainer.contains(.name)
        {
            self.name = try decoderContainer.decode(String?.self, forKey: .name)
        }
        if decoderContainer.contains(.jrn)
        {
            self.jrn = try decoderContainer.decode(String?.self, forKey: .jrn)
        }
        if decoderContainer.contains(.descriptionValue)
        {
            self.descriptionValue = try decoderContainer.decode(String?.self, forKey: .descriptionValue)
        }
        if decoderContainer.contains(.policyType)
        {
            self.policyType = try decoderContainer.decode(String?.self, forKey: .policyType)
        }
        if decoderContainer.contains(.version)
        {
            self.version = try decoderContainer.decode(String?.self, forKey: .version)
        }
        if decoderContainer.contains(.defaultEdition)
        {
            self.defaultEdition = try decoderContainer.decode(Int?.self, forKey: .defaultEdition)
        }
        if decoderContainer.contains(.createTime)
        {
            self.createTime = try decoderContainer.decode(String?.self, forKey: .createTime)
        }
        if decoderContainer.contains(.updateTime)
        {
            self.updateTime = try decoderContainer.decode(String?.self, forKey: .updateTime)
        }
    }
}
public extension Policy{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: PolicyCodingKeys.self)
         try encoderContainer.encode(policyId, forKey: .policyId)
         try encoderContainer.encode(name, forKey: .name)
         try encoderContainer.encode(jrn, forKey: .jrn)
         try encoderContainer.encode(descriptionValue, forKey: .descriptionValue)
         try encoderContainer.encode(policyType, forKey: .policyType)
         try encoderContainer.encode(version, forKey: .version)
         try encoderContainer.encode(defaultEdition, forKey: .defaultEdition)
         try encoderContainer.encode(createTime, forKey: .createTime)
         try encoderContainer.encode(updateTime, forKey: .updateTime)
    }
}
///  policyEdition
public class PolicyEdition:NSObject,Codable{
    /// 是否为默认版本
    var isDefaultEdition:Bool?
    /// 策略文档版本
    var edition:Int?
    /// 策略创建时间
    var createTime:String?



    public override init(){
            super.init()
    }

    enum PolicyEditionCodingKeys: String, CodingKey {
        case isDefaultEdition
        case edition
        case createTime
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: PolicyEditionCodingKeys.self)
        if decoderContainer.contains(.isDefaultEdition)
        {
            self.isDefaultEdition = try decoderContainer.decode(Bool?.self, forKey: .isDefaultEdition)
        }
        if decoderContainer.contains(.edition)
        {
            self.edition = try decoderContainer.decode(Int?.self, forKey: .edition)
        }
        if decoderContainer.contains(.createTime)
        {
            self.createTime = try decoderContainer.decode(String?.self, forKey: .createTime)
        }
    }
}
public extension PolicyEdition{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: PolicyEditionCodingKeys.self)
         try encoderContainer.encode(isDefaultEdition, forKey: .isDefaultEdition)
         try encoderContainer.encode(edition, forKey: .edition)
         try encoderContainer.encode(createTime, forKey: .createTime)
    }
}
///  createPolicyEditionInfo
public class CreatePolicyEditionInfo:NSObject,Codable{
    /// 策略文档，最多6144个字符
    /// Required:true
    var policyDocument:String
    /// 是否设置当前策略文档为默认版本
    /// Required:true
    var setAsDefault:Bool



    public  init(policyDocument:String,setAsDefault:Bool){
             self.policyDocument = policyDocument
             self.setAsDefault = setAsDefault
    }

    enum CreatePolicyEditionInfoCodingKeys: String, CodingKey {
        case policyDocument
        case setAsDefault
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: CreatePolicyEditionInfoCodingKeys.self)
        self.policyDocument = try decoderContainer.decode(String.self, forKey: .policyDocument)
        self.setAsDefault = try decoderContainer.decode(Bool.self, forKey: .setAsDefault)
    }
}
public extension CreatePolicyEditionInfo{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: CreatePolicyEditionInfoCodingKeys.self)
         try encoderContainer.encode(policyDocument, forKey: .policyDocument)
         try encoderContainer.encode(setAsDefault, forKey: .setAsDefault)
    }
}
///  updatePolicyInfo
public class UpdatePolicyInfo:NSObject,Codable{
    /// 策略信息详情，最多6144个字符
    /// Required:true
    var content:String



    public  init(content:String){
             self.content = content
    }

    enum UpdatePolicyInfoCodingKeys: String, CodingKey {
        case content
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: UpdatePolicyInfoCodingKeys.self)
        self.content = try decoderContainer.decode(String.self, forKey: .content)
    }
}
public extension UpdatePolicyInfo{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: UpdatePolicyInfoCodingKeys.self)
         try encoderContainer.encode(content, forKey: .content)
    }
}
///  updatePolicyDescriptionInfo
public class UpdatePolicyDescriptionInfo:NSObject,Codable{
    /// 描述，0~256个字符
    /// Required:true
    var descriptionValue:String



    public  init(descriptionValue:String){
             self.descriptionValue = descriptionValue
    }

    enum UpdatePolicyDescriptionInfoCodingKeys: String, CodingKey {
        case descriptionValue = "description"
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: UpdatePolicyDescriptionInfoCodingKeys.self)
        self.descriptionValue = try decoderContainer.decode(String.self, forKey: .descriptionValue)
    }
}
public extension UpdatePolicyDescriptionInfo{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: UpdatePolicyDescriptionInfoCodingKeys.self)
         try encoderContainer.encode(descriptionValue, forKey: .descriptionValue)
    }
}
///  policyEditionDetail
public class PolicyEditionDetail:NSObject,Codable{
    /// 策略文档
    var document:String?
    /// 是否为默认版本
    var isDefaultEdition:Bool?
    /// 策略文档版本
    var edition:Int?
    /// 策略创建时间
    var createTime:String?



    public override init(){
            super.init()
    }

    enum PolicyEditionDetailCodingKeys: String, CodingKey {
        case document
        case isDefaultEdition
        case edition
        case createTime
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: PolicyEditionDetailCodingKeys.self)
        if decoderContainer.contains(.document)
        {
            self.document = try decoderContainer.decode(String?.self, forKey: .document)
        }
        if decoderContainer.contains(.isDefaultEdition)
        {
            self.isDefaultEdition = try decoderContainer.decode(Bool?.self, forKey: .isDefaultEdition)
        }
        if decoderContainer.contains(.edition)
        {
            self.edition = try decoderContainer.decode(Int?.self, forKey: .edition)
        }
        if decoderContainer.contains(.createTime)
        {
            self.createTime = try decoderContainer.decode(String?.self, forKey: .createTime)
        }
    }
}
public extension PolicyEditionDetail{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: PolicyEditionDetailCodingKeys.self)
         try encoderContainer.encode(document, forKey: .document)
         try encoderContainer.encode(isDefaultEdition, forKey: .isDefaultEdition)
         try encoderContainer.encode(edition, forKey: .edition)
         try encoderContainer.encode(createTime, forKey: .createTime)
    }
}
///  mFAInfo
public class MFAInfo:NSObject,Codable{
    /// 用户名
    var name:String?
    /// 秘钥
    var secret:String?



    public override init(){
            super.init()
    }

    enum MFAInfoCodingKeys: String, CodingKey {
        case name
        case secret
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: MFAInfoCodingKeys.self)
        if decoderContainer.contains(.name)
        {
            self.name = try decoderContainer.decode(String?.self, forKey: .name)
        }
        if decoderContainer.contains(.secret)
        {
            self.secret = try decoderContainer.decode(String?.self, forKey: .secret)
        }
    }
}
public extension MFAInfo{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: MFAInfoCodingKeys.self)
         try encoderContainer.encode(name, forKey: .name)
         try encoderContainer.encode(secret, forKey: .secret)
    }
}
///  virtualMFADevice
public class VirtualMFADevice:NSObject,Codable{
    /// Base64加密后的二维码信息
    var base64Qr:String?
    /// 创建MFA设备相关信息
    var mFAInfos:[MFAInfo?]?



    public override init(){
            super.init()
    }

    enum VirtualMFADeviceCodingKeys: String, CodingKey {
        case base64Qr
        case mFAInfos
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: VirtualMFADeviceCodingKeys.self)
        if decoderContainer.contains(.base64Qr)
        {
            self.base64Qr = try decoderContainer.decode(String?.self, forKey: .base64Qr)
        }
        if decoderContainer.contains(.mFAInfos)
        {
            self.mFAInfos = try decoderContainer.decode([MFAInfo?]?.self, forKey: .mFAInfos)
        }
    }
}
public extension VirtualMFADevice{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: VirtualMFADeviceCodingKeys.self)
         try encoderContainer.encode(base64Qr, forKey: .base64Qr)
         try encoderContainer.encode(mFAInfos, forKey: .mFAInfos)
    }
}
///  conditionStatement
public class ConditionStatement:NSObject,Codable{
    /// ConditionMapping列表，ConditionStatement 之间是“或”关系，同一个ConditionStatement下ConditionMapping是“且”关系，同一个ConditionMapping下多个value是“或”关系
    var conditionMappings:[ConditionMappingVo?]?



    public override init(){
            super.init()
    }

    enum ConditionStatementCodingKeys: String, CodingKey {
        case conditionMappings
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: ConditionStatementCodingKeys.self)
        if decoderContainer.contains(.conditionMappings)
        {
            self.conditionMappings = try decoderContainer.decode([ConditionMappingVo?]?.self, forKey: .conditionMappings)
        }
    }
}
public extension ConditionStatement{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: ConditionStatementCodingKeys.self)
         try encoderContainer.encode(conditionMappings, forKey: .conditionMappings)
    }
}
///  authenticationInfo
public class AuthenticationInfo:NSObject,Codable{
    /// 主账号pin
    var account:String?
    /// 子账号pin
    var subUser:String?
    /// 操作类型,格式：serviceName:operationId
    /// Required:true
    var action:String
    /// 资源信息,格式：jrn:service:region:accountId:resourceType/resourceId/subresourceType/subresourceId
    /// Required:true
    var resource:String



    public  init(action:String,resource:String){
             self.action = action
             self.resource = resource
    }

    enum AuthenticationInfoCodingKeys: String, CodingKey {
        case account
        case subUser
        case action
        case resource
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: AuthenticationInfoCodingKeys.self)
        if decoderContainer.contains(.account)
        {
            self.account = try decoderContainer.decode(String?.self, forKey: .account)
        }
        if decoderContainer.contains(.subUser)
        {
            self.subUser = try decoderContainer.decode(String?.self, forKey: .subUser)
        }
        self.action = try decoderContainer.decode(String.self, forKey: .action)
        self.resource = try decoderContainer.decode(String.self, forKey: .resource)
    }
}
public extension AuthenticationInfo{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: AuthenticationInfoCodingKeys.self)
         try encoderContainer.encode(account, forKey: .account)
         try encoderContainer.encode(subUser, forKey: .subUser)
         try encoderContainer.encode(action, forKey: .action)
         try encoderContainer.encode(resource, forKey: .resource)
    }
}
///  conditionMappingVo
public class ConditionMappingVo:NSObject,Codable{
    /// 条件键Key
    var conditionKey:String?
    /// 符合条件键的值列表
    var values:[String?]?



    public override init(){
            super.init()
    }

    enum ConditionMappingVoCodingKeys: String, CodingKey {
        case conditionKey
        case values
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: ConditionMappingVoCodingKeys.self)
        if decoderContainer.contains(.conditionKey)
        {
            self.conditionKey = try decoderContainer.decode(String?.self, forKey: .conditionKey)
        }
        if decoderContainer.contains(.values)
        {
            self.values = try decoderContainer.decode([String?]?.self, forKey: .values)
        }
    }
}
public extension ConditionMappingVo{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: ConditionMappingVoCodingKeys.self)
         try encoderContainer.encode(conditionKey, forKey: .conditionKey)
         try encoderContainer.encode(values, forKey: .values)
    }
}
///  passwordPolicyRule
public class PasswordPolicyRule:NSObject,Codable{
    /// 是否包含大写字母
    /// Required:true
    var requireUppercaseCharacters:Bool
    /// 是否包含小写字母
    /// Required:true
    var requireLowercaseCharacters:Bool
    /// 是否包含数字
    /// Required:true
    var requireNumbers:Bool
    /// 是否包含特殊字符
    /// Required:true
    var requireSpecialCharacters:Bool



    public  init(requireUppercaseCharacters:Bool,requireLowercaseCharacters:Bool,requireNumbers:Bool,requireSpecialCharacters:Bool){
             self.requireUppercaseCharacters = requireUppercaseCharacters
             self.requireLowercaseCharacters = requireLowercaseCharacters
             self.requireNumbers = requireNumbers
             self.requireSpecialCharacters = requireSpecialCharacters
    }

    enum PasswordPolicyRuleCodingKeys: String, CodingKey {
        case requireUppercaseCharacters
        case requireLowercaseCharacters
        case requireNumbers
        case requireSpecialCharacters
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: PasswordPolicyRuleCodingKeys.self)
        self.requireUppercaseCharacters = try decoderContainer.decode(Bool.self, forKey: .requireUppercaseCharacters)
        self.requireLowercaseCharacters = try decoderContainer.decode(Bool.self, forKey: .requireLowercaseCharacters)
        self.requireNumbers = try decoderContainer.decode(Bool.self, forKey: .requireNumbers)
        self.requireSpecialCharacters = try decoderContainer.decode(Bool.self, forKey: .requireSpecialCharacters)
    }
}
public extension PasswordPolicyRule{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: PasswordPolicyRuleCodingKeys.self)
         try encoderContainer.encode(requireUppercaseCharacters, forKey: .requireUppercaseCharacters)
         try encoderContainer.encode(requireLowercaseCharacters, forKey: .requireLowercaseCharacters)
         try encoderContainer.encode(requireNumbers, forKey: .requireNumbers)
         try encoderContainer.encode(requireSpecialCharacters, forKey: .requireSpecialCharacters)
    }
}
///  passwordPolicy
public class PasswordPolicy:NSObject,Codable{
    /// 密码长度，6~20位，默认8位
    /// Required:true
    var length:Int
    /// 密码有效期（天），0~1095，0表示永不过期
    /// Required:true
    var age:Int
    /// 密码过期后重置方式：0-联系主账号重置，1-子用户登录后重置
    /// Required:true
    var expirationOperation:Int
    /// 历史密码检查策略，禁止使用前(0~10)次密码，0表示不启用
    /// Required:true
    var reusePrevention:Int
    /// 1小时内使用错误密码最多(1~16)次
    /// Required:true
    var retryTimes:Int
    /// ValidLoginDuration
    /// Required:true
    var validLoginDuration:Int
    /// 密码字符类型，至少包含一种
    /// Required:true
    var rule:PasswordPolicyRule



    public  init(length:Int,age:Int,expirationOperation:Int,reusePrevention:Int,retryTimes:Int,validLoginDuration:Int,rule:PasswordPolicyRule){
             self.length = length
             self.age = age
             self.expirationOperation = expirationOperation
             self.reusePrevention = reusePrevention
             self.retryTimes = retryTimes
             self.validLoginDuration = validLoginDuration
             self.rule = rule
    }

    enum PasswordPolicyCodingKeys: String, CodingKey {
        case length
        case age
        case expirationOperation
        case reusePrevention
        case retryTimes
        case validLoginDuration
        case rule
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: PasswordPolicyCodingKeys.self)
        self.length = try decoderContainer.decode(Int.self, forKey: .length)
        self.age = try decoderContainer.decode(Int.self, forKey: .age)
        self.expirationOperation = try decoderContainer.decode(Int.self, forKey: .expirationOperation)
        self.reusePrevention = try decoderContainer.decode(Int.self, forKey: .reusePrevention)
        self.retryTimes = try decoderContainer.decode(Int.self, forKey: .retryTimes)
        self.validLoginDuration = try decoderContainer.decode(Int.self, forKey: .validLoginDuration)
        self.rule = try decoderContainer.decode(PasswordPolicyRule.self, forKey: .rule)
    }
}
public extension PasswordPolicy{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: PasswordPolicyCodingKeys.self)
         try encoderContainer.encode(length, forKey: .length)
         try encoderContainer.encode(age, forKey: .age)
         try encoderContainer.encode(expirationOperation, forKey: .expirationOperation)
         try encoderContainer.encode(reusePrevention, forKey: .reusePrevention)
         try encoderContainer.encode(retryTimes, forKey: .retryTimes)
         try encoderContainer.encode(validLoginDuration, forKey: .validLoginDuration)
         try encoderContainer.encode(rule, forKey: .rule)
    }
}
///  resource
public class Resource:NSObject,Codable{
    /// 资源id集合，传*表示对所有id生效
    /// Required:true
    var ids:[String?]?
    /// 资源类型，云主机-server、镜像-image、云硬盘-volume、vpc-vpc、公网Ip-floatingIp、负载均衡-loadbalance、云数据库(mysql)-database、云缓存-cache
    /// Required:true
    var type:String



    public  init(ids:[String?]?,type:String){
             self.ids = ids
             self.type = type
    }

    enum ResourceCodingKeys: String, CodingKey {
        case ids
        case type
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: ResourceCodingKeys.self)
        self.ids = try decoderContainer.decode([String?]?.self, forKey: .ids)
        self.type = try decoderContainer.decode(String.self, forKey: .type)
    }
}
public extension Resource{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: ResourceCodingKeys.self)
         try encoderContainer.encode(ids, forKey: .ids)
         try encoderContainer.encode(type, forKey: .type)
    }
}
///  addPermissionsInfo
public class AddPermissionsInfo:NSObject,Codable{
    /// 权限id集合
    /// Required:true
    var permissionIds:[Int?]?



    public  init(permissionIds:[Int?]?){
             self.permissionIds = permissionIds
    }

    enum AddPermissionsInfoCodingKeys: String, CodingKey {
        case permissionIds
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: AddPermissionsInfoCodingKeys.self)
        self.permissionIds = try decoderContainer.decode([Int?]?.self, forKey: .permissionIds)
    }
}
public extension AddPermissionsInfo{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: AddPermissionsInfoCodingKeys.self)
         try encoderContainer.encode(permissionIds, forKey: .permissionIds)
    }
}
///  updatePermissionInfo
public class UpdatePermissionInfo:NSObject,Codable{
    /// 权限名称，1~32位数字、字符、中文、中划线、下划线
    /// Required:true
    var name:String
    /// 描述，0~256个字符
    var descriptionValue:String?
    /// 权限详细信息
    /// Required:true
    var content:[PermissionDetail?]?



    public  init(name:String,content:[PermissionDetail?]?){
             self.name = name
             self.content = content
    }

    enum UpdatePermissionInfoCodingKeys: String, CodingKey {
        case name
        case descriptionValue = "description"
        case content
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: UpdatePermissionInfoCodingKeys.self)
        self.name = try decoderContainer.decode(String.self, forKey: .name)
        if decoderContainer.contains(.descriptionValue)
        {
            self.descriptionValue = try decoderContainer.decode(String?.self, forKey: .descriptionValue)
        }
        self.content = try decoderContainer.decode([PermissionDetail?]?.self, forKey: .content)
    }
}
public extension UpdatePermissionInfo{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: UpdatePermissionInfoCodingKeys.self)
         try encoderContainer.encode(name, forKey: .name)
         try encoderContainer.encode(descriptionValue, forKey: .descriptionValue)
         try encoderContainer.encode(content, forKey: .content)
    }
}
///  createPermissionInfo
public class CreatePermissionInfo:NSObject,Codable{
    /// 权限名称，1~32位数字、字母、中文、下划线、下划线、中划线
    /// Required:true
    var name:String
    /// 描述，0~256个字符
    var descriptionValue:String?
    /// 权限详细信息
    /// Required:true
    var content:[PermissionDetail?]?



    public  init(name:String,content:[PermissionDetail?]?){
             self.name = name
             self.content = content
    }

    enum CreatePermissionInfoCodingKeys: String, CodingKey {
        case name
        case descriptionValue = "description"
        case content
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: CreatePermissionInfoCodingKeys.self)
        self.name = try decoderContainer.decode(String.self, forKey: .name)
        if decoderContainer.contains(.descriptionValue)
        {
            self.descriptionValue = try decoderContainer.decode(String?.self, forKey: .descriptionValue)
        }
        self.content = try decoderContainer.decode([PermissionDetail?]?.self, forKey: .content)
    }
}
public extension CreatePermissionInfo{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: CreatePermissionInfoCodingKeys.self)
         try encoderContainer.encode(name, forKey: .name)
         try encoderContainer.encode(descriptionValue, forKey: .descriptionValue)
         try encoderContainer.encode(content, forKey: .content)
    }
}
///  permissionDetail
public class PermissionDetail:NSObject,Codable{
    /// 权限类型，只读-R、删除-D、修改-M
    /// Required:true
    var permission:String
    /// 资源信息
    /// Required:true
    var resource:[Resource?]?



    public  init(permission:String,resource:[Resource?]?){
             self.permission = permission
             self.resource = resource
    }

    enum PermissionDetailCodingKeys: String, CodingKey {
        case permission
        case resource
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: PermissionDetailCodingKeys.self)
        self.permission = try decoderContainer.decode(String.self, forKey: .permission)
        self.resource = try decoderContainer.decode([Resource?]?.self, forKey: .resource)
    }
}
public extension PermissionDetail{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: PermissionDetailCodingKeys.self)
         try encoderContainer.encode(permission, forKey: .permission)
         try encoderContainer.encode(resource, forKey: .resource)
    }
}
///  permission
public class Permission:NSObject,Codable{
    /// 权限id
    var id:Int?
    /// 主账号pin
    var account:String?
    /// 权限名称
    var name:String?
    /// 描述
    var descriptionValue:String?
    /// 权限类型
    var permissionType:String?
    /// 权限版本号
    var version:String?
    /// 权限内容
    var content:String?
    /// 权限详细信息
    var permissionDetailList:[PermissionDetail?]?



    public override init(){
            super.init()
    }

    enum PermissionCodingKeys: String, CodingKey {
        case id
        case account
        case name
        case descriptionValue = "description"
        case permissionType
        case version
        case content
        case permissionDetailList
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: PermissionCodingKeys.self)
        if decoderContainer.contains(.id)
        {
            self.id = try decoderContainer.decode(Int?.self, forKey: .id)
        }
        if decoderContainer.contains(.account)
        {
            self.account = try decoderContainer.decode(String?.self, forKey: .account)
        }
        if decoderContainer.contains(.name)
        {
            self.name = try decoderContainer.decode(String?.self, forKey: .name)
        }
        if decoderContainer.contains(.descriptionValue)
        {
            self.descriptionValue = try decoderContainer.decode(String?.self, forKey: .descriptionValue)
        }
        if decoderContainer.contains(.permissionType)
        {
            self.permissionType = try decoderContainer.decode(String?.self, forKey: .permissionType)
        }
        if decoderContainer.contains(.version)
        {
            self.version = try decoderContainer.decode(String?.self, forKey: .version)
        }
        if decoderContainer.contains(.content)
        {
            self.content = try decoderContainer.decode(String?.self, forKey: .content)
        }
        if decoderContainer.contains(.permissionDetailList)
        {
            self.permissionDetailList = try decoderContainer.decode([PermissionDetail?]?.self, forKey: .permissionDetailList)
        }
    }
}
public extension Permission{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: PermissionCodingKeys.self)
         try encoderContainer.encode(id, forKey: .id)
         try encoderContainer.encode(account, forKey: .account)
         try encoderContainer.encode(name, forKey: .name)
         try encoderContainer.encode(descriptionValue, forKey: .descriptionValue)
         try encoderContainer.encode(permissionType, forKey: .permissionType)
         try encoderContainer.encode(version, forKey: .version)
         try encoderContainer.encode(content, forKey: .content)
         try encoderContainer.encode(permissionDetailList, forKey: .permissionDetailList)
    }
}
///  createLoginProfileInfo
public class CreateLoginProfileInfo:NSObject,Codable{
    /// 子用户登录是否需要重置密码，默认false
    var passwordResetRequired:Bool?
    /// 指定密码，密码必须符合密码强度要求。关于密码强度设置接口，请参考describePasswordPolicy
    var password:String?
    /// 是否自动生成密码，默认false
    var autoGeneratePassword:Bool?
    /// 指定子用户在下次登录时是否必须绑定虚拟MFA设备
    var mFABindRequired:Bool?



    public override init(){
            super.init()
    }

    enum CreateLoginProfileInfoCodingKeys: String, CodingKey {
        case passwordResetRequired
        case password
        case autoGeneratePassword
        case mFABindRequired
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: CreateLoginProfileInfoCodingKeys.self)
        if decoderContainer.contains(.passwordResetRequired)
        {
            self.passwordResetRequired = try decoderContainer.decode(Bool?.self, forKey: .passwordResetRequired)
        }
        if decoderContainer.contains(.password)
        {
            self.password = try decoderContainer.decode(String?.self, forKey: .password)
        }
        if decoderContainer.contains(.autoGeneratePassword)
        {
            self.autoGeneratePassword = try decoderContainer.decode(Bool?.self, forKey: .autoGeneratePassword)
        }
        if decoderContainer.contains(.mFABindRequired)
        {
            self.mFABindRequired = try decoderContainer.decode(Bool?.self, forKey: .mFABindRequired)
        }
    }
}
public extension CreateLoginProfileInfo{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: CreateLoginProfileInfoCodingKeys.self)
         try encoderContainer.encode(passwordResetRequired, forKey: .passwordResetRequired)
         try encoderContainer.encode(password, forKey: .password)
         try encoderContainer.encode(autoGeneratePassword, forKey: .autoGeneratePassword)
         try encoderContainer.encode(mFABindRequired, forKey: .mFABindRequired)
    }
}
///  loginProfile
public class LoginProfile:NSObject,Codable{
    /// 子用户名
    var name:String?
    /// 要求下次登录时重设密码
    var passwordResetRequired:Bool?
    /// 要求必须绑定虚拟MFA设备
    var mFABindRequired:Bool?



    public override init(){
            super.init()
    }

    enum LoginProfileCodingKeys: String, CodingKey {
        case name
        case passwordResetRequired
        case mFABindRequired
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: LoginProfileCodingKeys.self)
        if decoderContainer.contains(.name)
        {
            self.name = try decoderContainer.decode(String?.self, forKey: .name)
        }
        if decoderContainer.contains(.passwordResetRequired)
        {
            self.passwordResetRequired = try decoderContainer.decode(Bool?.self, forKey: .passwordResetRequired)
        }
        if decoderContainer.contains(.mFABindRequired)
        {
            self.mFABindRequired = try decoderContainer.decode(Bool?.self, forKey: .mFABindRequired)
        }
    }
}
public extension LoginProfile{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: LoginProfileCodingKeys.self)
         try encoderContainer.encode(name, forKey: .name)
         try encoderContainer.encode(passwordResetRequired, forKey: .passwordResetRequired)
         try encoderContainer.encode(mFABindRequired, forKey: .mFABindRequired)
    }
}
///  loginProfileInfo
public class LoginProfileInfo:NSObject,Codable{
    /// 子用户名
    var name:String?
    /// 密码
    var password:String?
    /// 要求下次登录时重设密码
    var passwordResetRequired:Bool?
    /// 要求必须绑定多因素认证设备
    var mFABindRequired:Bool?



    public override init(){
            super.init()
    }

    enum LoginProfileInfoCodingKeys: String, CodingKey {
        case name
        case password
        case passwordResetRequired
        case mFABindRequired
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: LoginProfileInfoCodingKeys.self)
        if decoderContainer.contains(.name)
        {
            self.name = try decoderContainer.decode(String?.self, forKey: .name)
        }
        if decoderContainer.contains(.password)
        {
            self.password = try decoderContainer.decode(String?.self, forKey: .password)
        }
        if decoderContainer.contains(.passwordResetRequired)
        {
            self.passwordResetRequired = try decoderContainer.decode(Bool?.self, forKey: .passwordResetRequired)
        }
        if decoderContainer.contains(.mFABindRequired)
        {
            self.mFABindRequired = try decoderContainer.decode(Bool?.self, forKey: .mFABindRequired)
        }
    }
}
public extension LoginProfileInfo{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: LoginProfileInfoCodingKeys.self)
         try encoderContainer.encode(name, forKey: .name)
         try encoderContainer.encode(password, forKey: .password)
         try encoderContainer.encode(passwordResetRequired, forKey: .passwordResetRequired)
         try encoderContainer.encode(mFABindRequired, forKey: .mFABindRequired)
    }
}
///  updateLoginProfileInfo
public class UpdateLoginProfileInfo:NSObject,Codable{
    /// 子用户登录是否需要重置密码，默认false
    var passwordResetRequired:Bool?
    /// 指定密码，密码必须符合密码强度要求。关于密码强度设置接口，请参考describePasswordPolicy
    var password:String?
    /// 是否自动生成密码，默认false
    var autoGeneratePassword:Bool?
    /// 指定子用户在下次登录时是否必须绑定多因素认证器
    var mFABindRequired:Bool?



    public override init(){
            super.init()
    }

    enum UpdateLoginProfileInfoCodingKeys: String, CodingKey {
        case passwordResetRequired
        case password
        case autoGeneratePassword
        case mFABindRequired
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: UpdateLoginProfileInfoCodingKeys.self)
        if decoderContainer.contains(.passwordResetRequired)
        {
            self.passwordResetRequired = try decoderContainer.decode(Bool?.self, forKey: .passwordResetRequired)
        }
        if decoderContainer.contains(.password)
        {
            self.password = try decoderContainer.decode(String?.self, forKey: .password)
        }
        if decoderContainer.contains(.autoGeneratePassword)
        {
            self.autoGeneratePassword = try decoderContainer.decode(Bool?.self, forKey: .autoGeneratePassword)
        }
        if decoderContainer.contains(.mFABindRequired)
        {
            self.mFABindRequired = try decoderContainer.decode(Bool?.self, forKey: .mFABindRequired)
        }
    }
}
public extension UpdateLoginProfileInfo{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: UpdateLoginProfileInfoCodingKeys.self)
         try encoderContainer.encode(passwordResetRequired, forKey: .passwordResetRequired)
         try encoderContainer.encode(password, forKey: .password)
         try encoderContainer.encode(autoGeneratePassword, forKey: .autoGeneratePassword)
         try encoderContainer.encode(mFABindRequired, forKey: .mFABindRequired)
    }
}
///  sendSingleMsg
public class SendSingleMsg:NSObject,Codable{
    /// 模版code
    /// Required:true
    var templateId:Int
    /// 模版参数
    /// Required:true
    var templateParam:[String?]?
    /// 业务编码(和产品申请)
    /// Required:true
    var smsMessageSource:String
    /// 用户pin
    /// Required:true
    var pin:String
    /// 手机号
    /// Required:true
    var mobileNum:String



    public  init(templateId:Int,templateParam:[String?]?,smsMessageSource:String,pin:String,mobileNum:String){
             self.templateId = templateId
             self.templateParam = templateParam
             self.smsMessageSource = smsMessageSource
             self.pin = pin
             self.mobileNum = mobileNum
    }

    enum SendSingleMsgCodingKeys: String, CodingKey {
        case templateId
        case templateParam
        case smsMessageSource
        case pin
        case mobileNum
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: SendSingleMsgCodingKeys.self)
        self.templateId = try decoderContainer.decode(Int.self, forKey: .templateId)
        self.templateParam = try decoderContainer.decode([String?]?.self, forKey: .templateParam)
        self.smsMessageSource = try decoderContainer.decode(String.self, forKey: .smsMessageSource)
        self.pin = try decoderContainer.decode(String.self, forKey: .pin)
        self.mobileNum = try decoderContainer.decode(String.self, forKey: .mobileNum)
    }
}
public extension SendSingleMsg{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: SendSingleMsgCodingKeys.self)
         try encoderContainer.encode(templateId, forKey: .templateId)
         try encoderContainer.encode(templateParam, forKey: .templateParam)
         try encoderContainer.encode(smsMessageSource, forKey: .smsMessageSource)
         try encoderContainer.encode(pin, forKey: .pin)
         try encoderContainer.encode(mobileNum, forKey: .mobileNum)
    }
}
///  sendBatchMsg
public class SendBatchMsg:NSObject,Codable{
    /// 模版code
    /// Required:true
    var templateId:Int
    /// 模版参数
    /// Required:true
    var templateParam:[String?]?
    /// 业务编码(和产品申请)
    /// Required:true
    var smsMessageSource:String
    /// 用户pin
    /// Required:true
    var pin:String
    /// 手机号
    /// Required:true
    var mobileNumSet:[String?]?



    public  init(templateId:Int,templateParam:[String?]?,smsMessageSource:String,pin:String,mobileNumSet:[String?]?){
             self.templateId = templateId
             self.templateParam = templateParam
             self.smsMessageSource = smsMessageSource
             self.pin = pin
             self.mobileNumSet = mobileNumSet
    }

    enum SendBatchMsgCodingKeys: String, CodingKey {
        case templateId
        case templateParam
        case smsMessageSource
        case pin
        case mobileNumSet
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: SendBatchMsgCodingKeys.self)
        self.templateId = try decoderContainer.decode(Int.self, forKey: .templateId)
        self.templateParam = try decoderContainer.decode([String?]?.self, forKey: .templateParam)
        self.smsMessageSource = try decoderContainer.decode(String.self, forKey: .smsMessageSource)
        self.pin = try decoderContainer.decode(String.self, forKey: .pin)
        self.mobileNumSet = try decoderContainer.decode([String?]?.self, forKey: .mobileNumSet)
    }
}
public extension SendBatchMsg{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: SendBatchMsgCodingKeys.self)
         try encoderContainer.encode(templateId, forKey: .templateId)
         try encoderContainer.encode(templateParam, forKey: .templateParam)
         try encoderContainer.encode(smsMessageSource, forKey: .smsMessageSource)
         try encoderContainer.encode(pin, forKey: .pin)
         try encoderContainer.encode(mobileNumSet, forKey: .mobileNumSet)
    }
}
///  emailSmsInfo
public class EmailSmsInfo:NSObject,Codable{
    /// 用户pin
    /// Required:true
    var createPin:String
    /// 邮件标题
    var title:String?
    /// 发送类型 1 发邮件 2 发短信
    /// Required:true
    var sendType:Int
    /// 邮件内容
    var content:String?
    /// 接收人
    /// Required:true
    var receives:[String?]?
    /// 模版code
    /// Required:true
    var templateId:Int
    /// 模版参数
    /// Required:true
    var templateParam:[String?]?
    /// 业务编码(和产品申请)
    /// Required:true
    var smsMessageSource:String



    public  init(createPin:String,sendType:Int,receives:[String?]?,templateId:Int,templateParam:[String?]?,smsMessageSource:String){
             self.createPin = createPin
             self.sendType = sendType
             self.receives = receives
             self.templateId = templateId
             self.templateParam = templateParam
             self.smsMessageSource = smsMessageSource
    }

    enum EmailSmsInfoCodingKeys: String, CodingKey {
        case createPin
        case title
        case sendType
        case content
        case receives
        case templateId
        case templateParam
        case smsMessageSource
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: EmailSmsInfoCodingKeys.self)
        self.createPin = try decoderContainer.decode(String.self, forKey: .createPin)
        if decoderContainer.contains(.title)
        {
            self.title = try decoderContainer.decode(String?.self, forKey: .title)
        }
        self.sendType = try decoderContainer.decode(Int.self, forKey: .sendType)
        if decoderContainer.contains(.content)
        {
            self.content = try decoderContainer.decode(String?.self, forKey: .content)
        }
        self.receives = try decoderContainer.decode([String?]?.self, forKey: .receives)
        self.templateId = try decoderContainer.decode(Int.self, forKey: .templateId)
        self.templateParam = try decoderContainer.decode([String?]?.self, forKey: .templateParam)
        self.smsMessageSource = try decoderContainer.decode(String.self, forKey: .smsMessageSource)
    }
}
public extension EmailSmsInfo{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: EmailSmsInfoCodingKeys.self)
         try encoderContainer.encode(createPin, forKey: .createPin)
         try encoderContainer.encode(title, forKey: .title)
         try encoderContainer.encode(sendType, forKey: .sendType)
         try encoderContainer.encode(content, forKey: .content)
         try encoderContainer.encode(receives, forKey: .receives)
         try encoderContainer.encode(templateId, forKey: .templateId)
         try encoderContainer.encode(templateParam, forKey: .templateParam)
         try encoderContainer.encode(smsMessageSource, forKey: .smsMessageSource)
    }
}
///  sendOutSiteNotice
public class SendOutSiteNotice:NSObject,Codable{
    /// 用户pin
    /// Required:true
    var pin:String
    /// 邮件标题
    var emailSubject:String?
    /// 邮件内容
    var emailContent:String?
    /// 消息类型
    /// Required:true
    var notifyBusinessTypeEnum:String
    /// 模版code
    /// Required:true
    var templateId:Int
    /// 模版参数
    /// Required:true
    var templateParam:[String?]?
    /// 业务编码(和产品申请)
    /// Required:true
    var smsMessageSource:String



    public  init(pin:String,notifyBusinessTypeEnum:String,templateId:Int,templateParam:[String?]?,smsMessageSource:String){
             self.pin = pin
             self.notifyBusinessTypeEnum = notifyBusinessTypeEnum
             self.templateId = templateId
             self.templateParam = templateParam
             self.smsMessageSource = smsMessageSource
    }

    enum SendOutSiteNoticeCodingKeys: String, CodingKey {
        case pin
        case emailSubject
        case emailContent
        case notifyBusinessTypeEnum
        case templateId
        case templateParam
        case smsMessageSource
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: SendOutSiteNoticeCodingKeys.self)
        self.pin = try decoderContainer.decode(String.self, forKey: .pin)
        if decoderContainer.contains(.emailSubject)
        {
            self.emailSubject = try decoderContainer.decode(String?.self, forKey: .emailSubject)
        }
        if decoderContainer.contains(.emailContent)
        {
            self.emailContent = try decoderContainer.decode(String?.self, forKey: .emailContent)
        }
        self.notifyBusinessTypeEnum = try decoderContainer.decode(String.self, forKey: .notifyBusinessTypeEnum)
        self.templateId = try decoderContainer.decode(Int.self, forKey: .templateId)
        self.templateParam = try decoderContainer.decode([String?]?.self, forKey: .templateParam)
        self.smsMessageSource = try decoderContainer.decode(String.self, forKey: .smsMessageSource)
    }
}
public extension SendOutSiteNotice{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: SendOutSiteNoticeCodingKeys.self)
         try encoderContainer.encode(pin, forKey: .pin)
         try encoderContainer.encode(emailSubject, forKey: .emailSubject)
         try encoderContainer.encode(emailContent, forKey: .emailContent)
         try encoderContainer.encode(notifyBusinessTypeEnum, forKey: .notifyBusinessTypeEnum)
         try encoderContainer.encode(templateId, forKey: .templateId)
         try encoderContainer.encode(templateParam, forKey: .templateParam)
         try encoderContainer.encode(smsMessageSource, forKey: .smsMessageSource)
    }
}
///  subUserAccessKey
public class SubUserAccessKey:NSObject,Codable{
    /// accessKey
    var accessKey:String?
    /// secretAccessKey
    var secretAccessKey:String?
    /// 创建时间
    var createTime:String?
    /// 禁用/启用状态[0-禁用,1-启用]
    var status:Int?
    /// 删除/有效状态[0-删除,1-有效]
    var yn:Int?



    public override init(){
            super.init()
    }

    enum SubUserAccessKeyCodingKeys: String, CodingKey {
        case accessKey
        case secretAccessKey
        case createTime
        case status
        case yn
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: SubUserAccessKeyCodingKeys.self)
        if decoderContainer.contains(.accessKey)
        {
            self.accessKey = try decoderContainer.decode(String?.self, forKey: .accessKey)
        }
        if decoderContainer.contains(.secretAccessKey)
        {
            self.secretAccessKey = try decoderContainer.decode(String?.self, forKey: .secretAccessKey)
        }
        if decoderContainer.contains(.createTime)
        {
            self.createTime = try decoderContainer.decode(String?.self, forKey: .createTime)
        }
        if decoderContainer.contains(.status)
        {
            self.status = try decoderContainer.decode(Int?.self, forKey: .status)
        }
        if decoderContainer.contains(.yn)
        {
            self.yn = try decoderContainer.decode(Int?.self, forKey: .yn)
        }
    }
}
public extension SubUserAccessKey{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: SubUserAccessKeyCodingKeys.self)
         try encoderContainer.encode(accessKey, forKey: .accessKey)
         try encoderContainer.encode(secretAccessKey, forKey: .secretAccessKey)
         try encoderContainer.encode(createTime, forKey: .createTime)
         try encoderContainer.encode(status, forKey: .status)
         try encoderContainer.encode(yn, forKey: .yn)
    }
}
///  userAccessKey
public class UserAccessKey:NSObject,Codable{
    /// accessKey
    var accessKey:String?
    /// accessKeySecret
    var accessKeySecret:String?
    /// 创建时间
    var createTime:String?
    /// 禁用/启用状态[0-禁用,1-启用]
    var state:Int?
    /// 删除/有效状态[0-删除,1-有效]
    var yn:Int?



    public override init(){
            super.init()
    }

    enum UserAccessKeyCodingKeys: String, CodingKey {
        case accessKey
        case accessKeySecret
        case createTime
        case state
        case yn
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: UserAccessKeyCodingKeys.self)
        if decoderContainer.contains(.accessKey)
        {
            self.accessKey = try decoderContainer.decode(String?.self, forKey: .accessKey)
        }
        if decoderContainer.contains(.accessKeySecret)
        {
            self.accessKeySecret = try decoderContainer.decode(String?.self, forKey: .accessKeySecret)
        }
        if decoderContainer.contains(.createTime)
        {
            self.createTime = try decoderContainer.decode(String?.self, forKey: .createTime)
        }
        if decoderContainer.contains(.state)
        {
            self.state = try decoderContainer.decode(Int?.self, forKey: .state)
        }
        if decoderContainer.contains(.yn)
        {
            self.yn = try decoderContainer.decode(Int?.self, forKey: .yn)
        }
    }
}
public extension UserAccessKey{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: UserAccessKeyCodingKeys.self)
         try encoderContainer.encode(accessKey, forKey: .accessKey)
         try encoderContainer.encode(accessKeySecret, forKey: .accessKeySecret)
         try encoderContainer.encode(createTime, forKey: .createTime)
         try encoderContainer.encode(state, forKey: .state)
         try encoderContainer.encode(yn, forKey: .yn)
    }
}
///  azSaleStatusVo
public class AzSaleStatusVo:NSObject,Codable{
    /// null
    var az:String?
    /// 是否售罄 (0未售罄 1售罄)
    var canSale:Int?
    /// 是否可见(1可见 0不可见)
    var visible:Int?



    public override init(){
            super.init()
    }

    enum AzSaleStatusVoCodingKeys: String, CodingKey {
        case az
        case canSale
        case visible
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: AzSaleStatusVoCodingKeys.self)
        if decoderContainer.contains(.az)
        {
            self.az = try decoderContainer.decode(String?.self, forKey: .az)
        }
        if decoderContainer.contains(.canSale)
        {
            self.canSale = try decoderContainer.decode(Int?.self, forKey: .canSale)
        }
        if decoderContainer.contains(.visible)
        {
            self.visible = try decoderContainer.decode(Int?.self, forKey: .visible)
        }
    }
}
public extension AzSaleStatusVo{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: AzSaleStatusVoCodingKeys.self)
         try encoderContainer.encode(az, forKey: .az)
         try encoderContainer.encode(canSale, forKey: .canSale)
         try encoderContainer.encode(visible, forKey: .visible)
    }
}
///  baseProductRegionVo
public class BaseProductRegionVo:NSObject,Codable{
    /// 产品编码
    var serviceCode:String?
    /// az信息
    var regionAzVos:[RegionAzVo?]?



    public override init(){
            super.init()
    }

    enum BaseProductRegionVoCodingKeys: String, CodingKey {
        case serviceCode
        case regionAzVos
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: BaseProductRegionVoCodingKeys.self)
        if decoderContainer.contains(.serviceCode)
        {
            self.serviceCode = try decoderContainer.decode(String?.self, forKey: .serviceCode)
        }
        if decoderContainer.contains(.regionAzVos)
        {
            self.regionAzVos = try decoderContainer.decode([RegionAzVo?]?.self, forKey: .regionAzVos)
        }
    }
}
public extension BaseProductRegionVo{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: BaseProductRegionVoCodingKeys.self)
         try encoderContainer.encode(serviceCode, forKey: .serviceCode)
         try encoderContainer.encode(regionAzVos, forKey: .regionAzVos)
    }
}
///  globalAzMappingVo
public class GlobalAzMappingVo:NSObject,Codable{
    /// 别名
    var alias:String?
    /// 地域
    var region:String?
    /// Az Mapping
    var mapping:[AzMappingVo?]?



    public override init(){
            super.init()
    }

    enum GlobalAzMappingVoCodingKeys: String, CodingKey {
        case alias
        case region
        case mapping
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: GlobalAzMappingVoCodingKeys.self)
        if decoderContainer.contains(.alias)
        {
            self.alias = try decoderContainer.decode(String?.self, forKey: .alias)
        }
        if decoderContainer.contains(.region)
        {
            self.region = try decoderContainer.decode(String?.self, forKey: .region)
        }
        if decoderContainer.contains(.mapping)
        {
            self.mapping = try decoderContainer.decode([AzMappingVo?]?.self, forKey: .mapping)
        }
    }
}
public extension GlobalAzMappingVo{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: GlobalAzMappingVoCodingKeys.self)
         try encoderContainer.encode(alias, forKey: .alias)
         try encoderContainer.encode(region, forKey: .region)
         try encoderContainer.encode(mapping, forKey: .mapping)
    }
}
///  regionAzVo
public class RegionAzVo:NSObject,Codable{
    /// 别名
    var alias:String?
    /// 地域
    var region:String?
    /// 是否可见(1可见 0不可见)
    var visible:Int?
    /// az状态信息
    var azStatusList:[AzSaleStatusVo?]?



    public override init(){
            super.init()
    }

    enum RegionAzVoCodingKeys: String, CodingKey {
        case alias
        case region
        case visible
        case azStatusList
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: RegionAzVoCodingKeys.self)
        if decoderContainer.contains(.alias)
        {
            self.alias = try decoderContainer.decode(String?.self, forKey: .alias)
        }
        if decoderContainer.contains(.region)
        {
            self.region = try decoderContainer.decode(String?.self, forKey: .region)
        }
        if decoderContainer.contains(.visible)
        {
            self.visible = try decoderContainer.decode(Int?.self, forKey: .visible)
        }
        if decoderContainer.contains(.azStatusList)
        {
            self.azStatusList = try decoderContainer.decode([AzSaleStatusVo?]?.self, forKey: .azStatusList)
        }
    }
}
public extension RegionAzVo{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: RegionAzVoCodingKeys.self)
         try encoderContainer.encode(alias, forKey: .alias)
         try encoderContainer.encode(region, forKey: .region)
         try encoderContainer.encode(visible, forKey: .visible)
         try encoderContainer.encode(azStatusList, forKey: .azStatusList)
    }
}
///  azMappingVo
public class AzMappingVo:NSObject,Codable{
    /// 逻辑 Az
    var laz:String?
    /// 物理 Az
    var paz:String?



    public override init(){
            super.init()
    }

    enum AzMappingVoCodingKeys: String, CodingKey {
        case laz
        case paz
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: AzMappingVoCodingKeys.self)
        if decoderContainer.contains(.laz)
        {
            self.laz = try decoderContainer.decode(String?.self, forKey: .laz)
        }
        if decoderContainer.contains(.paz)
        {
            self.paz = try decoderContainer.decode(String?.self, forKey: .paz)
        }
    }
}
public extension AzMappingVo{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: AzMappingVoCodingKeys.self)
         try encoderContainer.encode(laz, forKey: .laz)
         try encoderContainer.encode(paz, forKey: .paz)
    }
}
///  groupDetail
public class GroupDetail:NSObject,Codable{
    /// 用户组ID
    var groupId:String?
    /// 用户组名
    var name:String?
    /// 京东云资源标识(jrn)
    var jrn:String?
    /// 用户组描述
    var descriptionValue:String?
    /// 用户组创建时间
    var createTime:String?
    /// 用户组更新时间
    var updateTime:String?



    public override init(){
            super.init()
    }

    enum GroupDetailCodingKeys: String, CodingKey {
        case groupId
        case name
        case jrn
        case descriptionValue = "description"
        case createTime
        case updateTime
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: GroupDetailCodingKeys.self)
        if decoderContainer.contains(.groupId)
        {
            self.groupId = try decoderContainer.decode(String?.self, forKey: .groupId)
        }
        if decoderContainer.contains(.name)
        {
            self.name = try decoderContainer.decode(String?.self, forKey: .name)
        }
        if decoderContainer.contains(.jrn)
        {
            self.jrn = try decoderContainer.decode(String?.self, forKey: .jrn)
        }
        if decoderContainer.contains(.descriptionValue)
        {
            self.descriptionValue = try decoderContainer.decode(String?.self, forKey: .descriptionValue)
        }
        if decoderContainer.contains(.createTime)
        {
            self.createTime = try decoderContainer.decode(String?.self, forKey: .createTime)
        }
        if decoderContainer.contains(.updateTime)
        {
            self.updateTime = try decoderContainer.decode(String?.self, forKey: .updateTime)
        }
    }
}
public extension GroupDetail{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: GroupDetailCodingKeys.self)
         try encoderContainer.encode(groupId, forKey: .groupId)
         try encoderContainer.encode(name, forKey: .name)
         try encoderContainer.encode(jrn, forKey: .jrn)
         try encoderContainer.encode(descriptionValue, forKey: .descriptionValue)
         try encoderContainer.encode(createTime, forKey: .createTime)
         try encoderContainer.encode(updateTime, forKey: .updateTime)
    }
}
///  updateGroupInfo
public class UpdateGroupInfo:NSObject,Codable{
    /// 用户组描述
    var descriptionValue:String?



    public override init(){
            super.init()
    }

    enum UpdateGroupInfoCodingKeys: String, CodingKey {
        case descriptionValue = "description"
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: UpdateGroupInfoCodingKeys.self)
        if decoderContainer.contains(.descriptionValue)
        {
            self.descriptionValue = try decoderContainer.decode(String?.self, forKey: .descriptionValue)
        }
    }
}
public extension UpdateGroupInfo{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: UpdateGroupInfoCodingKeys.self)
         try encoderContainer.encode(descriptionValue, forKey: .descriptionValue)
    }
}
///  createGroupRes
public class CreateGroupRes:NSObject,Codable{
    /// 用户组ID
    var groupId:String?
    /// 用户组名
    var name:String?
    /// 京东云资源标识(jrn)
    var jrn:String?
    /// 用户组描述
    var descriptionValue:String?
    /// 用户组创建时间
    var createTime:String?
    /// 用户组更新时间
    var updateTime:String?



    public override init(){
            super.init()
    }

    enum CreateGroupResCodingKeys: String, CodingKey {
        case groupId
        case name
        case jrn
        case descriptionValue = "description"
        case createTime
        case updateTime
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: CreateGroupResCodingKeys.self)
        if decoderContainer.contains(.groupId)
        {
            self.groupId = try decoderContainer.decode(String?.self, forKey: .groupId)
        }
        if decoderContainer.contains(.name)
        {
            self.name = try decoderContainer.decode(String?.self, forKey: .name)
        }
        if decoderContainer.contains(.jrn)
        {
            self.jrn = try decoderContainer.decode(String?.self, forKey: .jrn)
        }
        if decoderContainer.contains(.descriptionValue)
        {
            self.descriptionValue = try decoderContainer.decode(String?.self, forKey: .descriptionValue)
        }
        if decoderContainer.contains(.createTime)
        {
            self.createTime = try decoderContainer.decode(String?.self, forKey: .createTime)
        }
        if decoderContainer.contains(.updateTime)
        {
            self.updateTime = try decoderContainer.decode(String?.self, forKey: .updateTime)
        }
    }
}
public extension CreateGroupRes{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: CreateGroupResCodingKeys.self)
         try encoderContainer.encode(groupId, forKey: .groupId)
         try encoderContainer.encode(name, forKey: .name)
         try encoderContainer.encode(jrn, forKey: .jrn)
         try encoderContainer.encode(descriptionValue, forKey: .descriptionValue)
         try encoderContainer.encode(createTime, forKey: .createTime)
         try encoderContainer.encode(updateTime, forKey: .updateTime)
    }
}
///  subUserInfo
public class SubUserInfo:NSObject,Codable{
    /// 子用户名
    var name:String?
    /// 描述信息
    var descriptionValue:String?
    /// 用户创建时间
    var createTime:String?



    public override init(){
            super.init()
    }

    enum SubUserInfoCodingKeys: String, CodingKey {
        case name
        case descriptionValue = "description"
        case createTime
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: SubUserInfoCodingKeys.self)
        if decoderContainer.contains(.name)
        {
            self.name = try decoderContainer.decode(String?.self, forKey: .name)
        }
        if decoderContainer.contains(.descriptionValue)
        {
            self.descriptionValue = try decoderContainer.decode(String?.self, forKey: .descriptionValue)
        }
        if decoderContainer.contains(.createTime)
        {
            self.createTime = try decoderContainer.decode(String?.self, forKey: .createTime)
        }
    }
}
public extension SubUserInfo{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: SubUserInfoCodingKeys.self)
         try encoderContainer.encode(name, forKey: .name)
         try encoderContainer.encode(descriptionValue, forKey: .descriptionValue)
         try encoderContainer.encode(createTime, forKey: .createTime)
    }
}
///  createGroupInfo
public class CreateGroupInfo:NSObject,Codable{
    /// 群组名：支持4-32位的字母，数字以及-和_, 以字母开头
    /// Required:true
    var name:String
    /// 描述，0~256个字符
    var descriptionValue:String?



    public  init(name:String){
             self.name = name
    }

    enum CreateGroupInfoCodingKeys: String, CodingKey {
        case name
        case descriptionValue = "description"
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: CreateGroupInfoCodingKeys.self)
        self.name = try decoderContainer.decode(String.self, forKey: .name)
        if decoderContainer.contains(.descriptionValue)
        {
            self.descriptionValue = try decoderContainer.decode(String?.self, forKey: .descriptionValue)
        }
    }
}
public extension CreateGroupInfo{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: CreateGroupInfoCodingKeys.self)
         try encoderContainer.encode(name, forKey: .name)
         try encoderContainer.encode(descriptionValue, forKey: .descriptionValue)
    }
}
///  group
public class Group:NSObject,Codable{
    /// 用户组ID
    var groupId:String?
    /// 用户组名
    var name:String?
    /// 京东云资源标识(jrn)
    var jrn:String?
    /// 用户组描述
    var descriptionValue:String?
    /// 子用户个数
    var subUserSum:Int?
    /// 绑定策略个数
    var policySum:Int?
    /// 用户组创建时间
    var createTime:String?
    /// 用户组更新时间
    var updateTime:String?



    public override init(){
            super.init()
    }

    enum GroupCodingKeys: String, CodingKey {
        case groupId
        case name
        case jrn
        case descriptionValue = "description"
        case subUserSum
        case policySum
        case createTime
        case updateTime
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: GroupCodingKeys.self)
        if decoderContainer.contains(.groupId)
        {
            self.groupId = try decoderContainer.decode(String?.self, forKey: .groupId)
        }
        if decoderContainer.contains(.name)
        {
            self.name = try decoderContainer.decode(String?.self, forKey: .name)
        }
        if decoderContainer.contains(.jrn)
        {
            self.jrn = try decoderContainer.decode(String?.self, forKey: .jrn)
        }
        if decoderContainer.contains(.descriptionValue)
        {
            self.descriptionValue = try decoderContainer.decode(String?.self, forKey: .descriptionValue)
        }
        if decoderContainer.contains(.subUserSum)
        {
            self.subUserSum = try decoderContainer.decode(Int?.self, forKey: .subUserSum)
        }
        if decoderContainer.contains(.policySum)
        {
            self.policySum = try decoderContainer.decode(Int?.self, forKey: .policySum)
        }
        if decoderContainer.contains(.createTime)
        {
            self.createTime = try decoderContainer.decode(String?.self, forKey: .createTime)
        }
        if decoderContainer.contains(.updateTime)
        {
            self.updateTime = try decoderContainer.decode(String?.self, forKey: .updateTime)
        }
    }
}
public extension Group{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: GroupCodingKeys.self)
         try encoderContainer.encode(groupId, forKey: .groupId)
         try encoderContainer.encode(name, forKey: .name)
         try encoderContainer.encode(jrn, forKey: .jrn)
         try encoderContainer.encode(descriptionValue, forKey: .descriptionValue)
         try encoderContainer.encode(subUserSum, forKey: .subUserSum)
         try encoderContainer.encode(policySum, forKey: .policySum)
         try encoderContainer.encode(createTime, forKey: .createTime)
         try encoderContainer.encode(updateTime, forKey: .updateTime)
    }
}
///  updateSubUserInfo
public class UpdateSubUserInfo:NSObject,Codable{
    /// 描述，0~256个字符
    var descriptionValue:String?
    /// 手机号码，区号-手机号
    var phone:String?
    /// 邮箱
    var email:String?



    public override init(){
            super.init()
    }

    enum UpdateSubUserInfoCodingKeys: String, CodingKey {
        case descriptionValue = "description"
        case phone
        case email
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: UpdateSubUserInfoCodingKeys.self)
        if decoderContainer.contains(.descriptionValue)
        {
            self.descriptionValue = try decoderContainer.decode(String?.self, forKey: .descriptionValue)
        }
        if decoderContainer.contains(.phone)
        {
            self.phone = try decoderContainer.decode(String?.self, forKey: .phone)
        }
        if decoderContainer.contains(.email)
        {
            self.email = try decoderContainer.decode(String?.self, forKey: .email)
        }
    }
}
public extension UpdateSubUserInfo{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: UpdateSubUserInfoCodingKeys.self)
         try encoderContainer.encode(descriptionValue, forKey: .descriptionValue)
         try encoderContainer.encode(phone, forKey: .phone)
         try encoderContainer.encode(email, forKey: .email)
    }
}
///  groupInfo
public class GroupInfo:NSObject,Codable{
    /// 用户组ID
    var groupId:String?
    /// 用户组名
    var name:String?
    /// 京东云资源标识(jrn)
    var jrn:String?
    /// Description
    var descriptionValue:String?
    /// 用户组创建时间
    var createTime:String?
    /// 用户组更新时间
    var updateTime:String?
    /// Policies
    var policies:[String?]?



    public override init(){
            super.init()
    }

    enum GroupInfoCodingKeys: String, CodingKey {
        case groupId
        case name
        case jrn
        case descriptionValue = "description"
        case createTime
        case updateTime
        case policies
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: GroupInfoCodingKeys.self)
        if decoderContainer.contains(.groupId)
        {
            self.groupId = try decoderContainer.decode(String?.self, forKey: .groupId)
        }
        if decoderContainer.contains(.name)
        {
            self.name = try decoderContainer.decode(String?.self, forKey: .name)
        }
        if decoderContainer.contains(.jrn)
        {
            self.jrn = try decoderContainer.decode(String?.self, forKey: .jrn)
        }
        if decoderContainer.contains(.descriptionValue)
        {
            self.descriptionValue = try decoderContainer.decode(String?.self, forKey: .descriptionValue)
        }
        if decoderContainer.contains(.createTime)
        {
            self.createTime = try decoderContainer.decode(String?.self, forKey: .createTime)
        }
        if decoderContainer.contains(.updateTime)
        {
            self.updateTime = try decoderContainer.decode(String?.self, forKey: .updateTime)
        }
        if decoderContainer.contains(.policies)
        {
            self.policies = try decoderContainer.decode([String?]?.self, forKey: .policies)
        }
    }
}
public extension GroupInfo{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: GroupInfoCodingKeys.self)
         try encoderContainer.encode(groupId, forKey: .groupId)
         try encoderContainer.encode(name, forKey: .name)
         try encoderContainer.encode(jrn, forKey: .jrn)
         try encoderContainer.encode(descriptionValue, forKey: .descriptionValue)
         try encoderContainer.encode(createTime, forKey: .createTime)
         try encoderContainer.encode(updateTime, forKey: .updateTime)
         try encoderContainer.encode(policies, forKey: .policies)
    }
}
///  createSubUserRes
public class CreateSubUserRes:NSObject,Codable{
    /// 用户名
    var name:String?
    /// 密码
    var password:String?
    /// 邮箱
    var email:String?
    /// 手机号码
    var phone:String?
    /// accessKey
    var accessKey:String?
    /// AccessKey secret
    var secretAccessKey:String?
    /// 创建时间
    var createTime:String?
    /// 更新时间
    var updateTime:String?



    public override init(){
            super.init()
    }

    enum CreateSubUserResCodingKeys: String, CodingKey {
        case name
        case password
        case email
        case phone
        case accessKey
        case secretAccessKey
        case createTime
        case updateTime
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: CreateSubUserResCodingKeys.self)
        if decoderContainer.contains(.name)
        {
            self.name = try decoderContainer.decode(String?.self, forKey: .name)
        }
        if decoderContainer.contains(.password)
        {
            self.password = try decoderContainer.decode(String?.self, forKey: .password)
        }
        if decoderContainer.contains(.email)
        {
            self.email = try decoderContainer.decode(String?.self, forKey: .email)
        }
        if decoderContainer.contains(.phone)
        {
            self.phone = try decoderContainer.decode(String?.self, forKey: .phone)
        }
        if decoderContainer.contains(.accessKey)
        {
            self.accessKey = try decoderContainer.decode(String?.self, forKey: .accessKey)
        }
        if decoderContainer.contains(.secretAccessKey)
        {
            self.secretAccessKey = try decoderContainer.decode(String?.self, forKey: .secretAccessKey)
        }
        if decoderContainer.contains(.createTime)
        {
            self.createTime = try decoderContainer.decode(String?.self, forKey: .createTime)
        }
        if decoderContainer.contains(.updateTime)
        {
            self.updateTime = try decoderContainer.decode(String?.self, forKey: .updateTime)
        }
    }
}
public extension CreateSubUserRes{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: CreateSubUserResCodingKeys.self)
         try encoderContainer.encode(name, forKey: .name)
         try encoderContainer.encode(password, forKey: .password)
         try encoderContainer.encode(email, forKey: .email)
         try encoderContainer.encode(phone, forKey: .phone)
         try encoderContainer.encode(accessKey, forKey: .accessKey)
         try encoderContainer.encode(secretAccessKey, forKey: .secretAccessKey)
         try encoderContainer.encode(createTime, forKey: .createTime)
         try encoderContainer.encode(updateTime, forKey: .updateTime)
    }
}
///  subUser
public class SubUser:NSObject,Codable{
    /// 用户名
    var name:String?
    /// 手机号码
    var phone:String?
    /// 邮箱
    var email:String?
    /// 描述信息
    var descriptionValue:String?
    /// 主账号
    var account:String?
    /// 用户创建时间
    var createTime:String?
    /// 用户更新时间
    var updateTime:String?



    public override init(){
            super.init()
    }

    enum SubUserCodingKeys: String, CodingKey {
        case name
        case phone
        case email
        case descriptionValue = "description"
        case account
        case createTime
        case updateTime
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: SubUserCodingKeys.self)
        if decoderContainer.contains(.name)
        {
            self.name = try decoderContainer.decode(String?.self, forKey: .name)
        }
        if decoderContainer.contains(.phone)
        {
            self.phone = try decoderContainer.decode(String?.self, forKey: .phone)
        }
        if decoderContainer.contains(.email)
        {
            self.email = try decoderContainer.decode(String?.self, forKey: .email)
        }
        if decoderContainer.contains(.descriptionValue)
        {
            self.descriptionValue = try decoderContainer.decode(String?.self, forKey: .descriptionValue)
        }
        if decoderContainer.contains(.account)
        {
            self.account = try decoderContainer.decode(String?.self, forKey: .account)
        }
        if decoderContainer.contains(.createTime)
        {
            self.createTime = try decoderContainer.decode(String?.self, forKey: .createTime)
        }
        if decoderContainer.contains(.updateTime)
        {
            self.updateTime = try decoderContainer.decode(String?.self, forKey: .updateTime)
        }
    }
}
public extension SubUser{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: SubUserCodingKeys.self)
         try encoderContainer.encode(name, forKey: .name)
         try encoderContainer.encode(phone, forKey: .phone)
         try encoderContainer.encode(email, forKey: .email)
         try encoderContainer.encode(descriptionValue, forKey: .descriptionValue)
         try encoderContainer.encode(account, forKey: .account)
         try encoderContainer.encode(createTime, forKey: .createTime)
         try encoderContainer.encode(updateTime, forKey: .updateTime)
    }
}
///  createSubUserInfo
public class CreateSubUserInfo:NSObject,Codable{
    /// 子用户名，支持4~20位的字母，数字以及-和_，以字母开头
    /// Required:true
    var name:String
    /// 描述，0~256个字符
    var descriptionValue:String?
    /// 按照密码策略设置，默认8~20位，至少包含一个小写字母、大写字母和数字
    /// Required:true
    var password:String
    /// 手机号码，区号-手机号
    /// Required:true
    var phone:String
    /// 邮箱
    /// Required:true
    var email:String
    /// 是否创建accessKey，默认false
    var createAk:Bool?
    /// 子用户首次登录是否需要重置密码，默认false
    var needResetPassword:Bool?
    /// 子用户是否支持控制台登录，默认true
    var consoleLogin:Bool?
    /// 是否自动生成密码，默认false
    var autoGeneratePassword:Bool?



    public  init(name:String,password:String,phone:String,email:String){
             self.name = name
             self.password = password
             self.phone = phone
             self.email = email
    }

    enum CreateSubUserInfoCodingKeys: String, CodingKey {
        case name
        case descriptionValue = "description"
        case password
        case phone
        case email
        case createAk
        case needResetPassword
        case consoleLogin
        case autoGeneratePassword
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: CreateSubUserInfoCodingKeys.self)
        self.name = try decoderContainer.decode(String.self, forKey: .name)
        if decoderContainer.contains(.descriptionValue)
        {
            self.descriptionValue = try decoderContainer.decode(String?.self, forKey: .descriptionValue)
        }
        self.password = try decoderContainer.decode(String.self, forKey: .password)
        self.phone = try decoderContainer.decode(String.self, forKey: .phone)
        self.email = try decoderContainer.decode(String.self, forKey: .email)
        if decoderContainer.contains(.createAk)
        {
            self.createAk = try decoderContainer.decode(Bool?.self, forKey: .createAk)
        }
        if decoderContainer.contains(.needResetPassword)
        {
            self.needResetPassword = try decoderContainer.decode(Bool?.self, forKey: .needResetPassword)
        }
        if decoderContainer.contains(.consoleLogin)
        {
            self.consoleLogin = try decoderContainer.decode(Bool?.self, forKey: .consoleLogin)
        }
        if decoderContainer.contains(.autoGeneratePassword)
        {
            self.autoGeneratePassword = try decoderContainer.decode(Bool?.self, forKey: .autoGeneratePassword)
        }
    }
}
public extension CreateSubUserInfo{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: CreateSubUserInfoCodingKeys.self)
         try encoderContainer.encode(name, forKey: .name)
         try encoderContainer.encode(descriptionValue, forKey: .descriptionValue)
         try encoderContainer.encode(password, forKey: .password)
         try encoderContainer.encode(phone, forKey: .phone)
         try encoderContainer.encode(email, forKey: .email)
         try encoderContainer.encode(createAk, forKey: .createAk)
         try encoderContainer.encode(needResetPassword, forKey: .needResetPassword)
         try encoderContainer.encode(consoleLogin, forKey: .consoleLogin)
         try encoderContainer.encode(autoGeneratePassword, forKey: .autoGeneratePassword)
    }
}
///  userAttachment
public class UserAttachment:NSObject,Codable{
    /// 公司名称
    var remark:String?
    /// 主营行业
    var industry:String?
    /// 主营行业子选项
    var subIndustry:String?
    /// 主营业务
    var business:String?
    /// 网站
    var website:String?
    /// 国家
    var cpState:String?
    /// 省
    var cpProvince:String?
    /// 市
    var cpCity:String?
    /// 区县
    var cpCountry:String?
    /// 详细地址
    var cpAddress:String?
    /// 联系手机
    var cpTelphone:String?



    public override init(){
            super.init()
    }

    enum UserAttachmentCodingKeys: String, CodingKey {
        case remark
        case industry
        case subIndustry
        case business
        case website
        case cpState
        case cpProvince
        case cpCity
        case cpCountry
        case cpAddress
        case cpTelphone
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: UserAttachmentCodingKeys.self)
        if decoderContainer.contains(.remark)
        {
            self.remark = try decoderContainer.decode(String?.self, forKey: .remark)
        }
        if decoderContainer.contains(.industry)
        {
            self.industry = try decoderContainer.decode(String?.self, forKey: .industry)
        }
        if decoderContainer.contains(.subIndustry)
        {
            self.subIndustry = try decoderContainer.decode(String?.self, forKey: .subIndustry)
        }
        if decoderContainer.contains(.business)
        {
            self.business = try decoderContainer.decode(String?.self, forKey: .business)
        }
        if decoderContainer.contains(.website)
        {
            self.website = try decoderContainer.decode(String?.self, forKey: .website)
        }
        if decoderContainer.contains(.cpState)
        {
            self.cpState = try decoderContainer.decode(String?.self, forKey: .cpState)
        }
        if decoderContainer.contains(.cpProvince)
        {
            self.cpProvince = try decoderContainer.decode(String?.self, forKey: .cpProvince)
        }
        if decoderContainer.contains(.cpCity)
        {
            self.cpCity = try decoderContainer.decode(String?.self, forKey: .cpCity)
        }
        if decoderContainer.contains(.cpCountry)
        {
            self.cpCountry = try decoderContainer.decode(String?.self, forKey: .cpCountry)
        }
        if decoderContainer.contains(.cpAddress)
        {
            self.cpAddress = try decoderContainer.decode(String?.self, forKey: .cpAddress)
        }
        if decoderContainer.contains(.cpTelphone)
        {
            self.cpTelphone = try decoderContainer.decode(String?.self, forKey: .cpTelphone)
        }
    }
}
public extension UserAttachment{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: UserAttachmentCodingKeys.self)
         try encoderContainer.encode(remark, forKey: .remark)
         try encoderContainer.encode(industry, forKey: .industry)
         try encoderContainer.encode(subIndustry, forKey: .subIndustry)
         try encoderContainer.encode(business, forKey: .business)
         try encoderContainer.encode(website, forKey: .website)
         try encoderContainer.encode(cpState, forKey: .cpState)
         try encoderContainer.encode(cpProvince, forKey: .cpProvince)
         try encoderContainer.encode(cpCity, forKey: .cpCity)
         try encoderContainer.encode(cpCountry, forKey: .cpCountry)
         try encoderContainer.encode(cpAddress, forKey: .cpAddress)
         try encoderContainer.encode(cpTelphone, forKey: .cpTelphone)
    }
}
///  removePermissionInfo
public class RemovePermissionInfo:NSObject,Codable{
    /// 权限id
    /// Required:true
    var permissionId:Int



    public  init(permissionId:Int){
             self.permissionId = permissionId
    }

    enum RemovePermissionInfoCodingKeys: String, CodingKey {
        case permissionId
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: RemovePermissionInfoCodingKeys.self)
        self.permissionId = try decoderContainer.decode(Int.self, forKey: .permissionId)
    }
}
public extension RemovePermissionInfo{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: RemovePermissionInfoCodingKeys.self)
         try encoderContainer.encode(permissionId, forKey: .permissionId)
    }
}
///  flags
public class Flags:NSObject,Codable{
    /// Value
    /// Required:true
    var value:Int



    public  init(value:Int){
             self.value = value
    }

    enum FlagsCodingKeys: String, CodingKey {
        case value
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: FlagsCodingKeys.self)
        self.value = try decoderContainer.decode(Int.self, forKey: .value)
    }
}
public extension Flags{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: FlagsCodingKeys.self)
         try encoderContainer.encode(value, forKey: .value)
    }
}
///  userResVo
public class UserResVo:NSObject,Codable{
    /// 用户pin
    var pin:String?
    /// 用户手机号
    var cscPhone:String?
    /// 用户邮箱
    var cscEmail:String?
    /// 创建时间
    var createTime:String?
    /// 用户类型
    var userType:Int?
    /// 公司名
    var companyName:String?
    /// 姓名
    var name:String?
    /// 欠费时间
    var arrearageTime:String?
    /// 用户标签：
    var userTagObject:Flags?
    /// 用户标签：
    var attachment:UserAttachment?



    public override init(){
            super.init()
    }

    enum UserResVoCodingKeys: String, CodingKey {
        case pin
        case cscPhone
        case cscEmail
        case createTime
        case userType
        case companyName
        case name
        case arrearageTime
        case userTagObject
        case attachment
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: UserResVoCodingKeys.self)
        if decoderContainer.contains(.pin)
        {
            self.pin = try decoderContainer.decode(String?.self, forKey: .pin)
        }
        if decoderContainer.contains(.cscPhone)
        {
            self.cscPhone = try decoderContainer.decode(String?.self, forKey: .cscPhone)
        }
        if decoderContainer.contains(.cscEmail)
        {
            self.cscEmail = try decoderContainer.decode(String?.self, forKey: .cscEmail)
        }
        if decoderContainer.contains(.createTime)
        {
            self.createTime = try decoderContainer.decode(String?.self, forKey: .createTime)
        }
        if decoderContainer.contains(.userType)
        {
            self.userType = try decoderContainer.decode(Int?.self, forKey: .userType)
        }
        if decoderContainer.contains(.companyName)
        {
            self.companyName = try decoderContainer.decode(String?.self, forKey: .companyName)
        }
        if decoderContainer.contains(.name)
        {
            self.name = try decoderContainer.decode(String?.self, forKey: .name)
        }
        if decoderContainer.contains(.arrearageTime)
        {
            self.arrearageTime = try decoderContainer.decode(String?.self, forKey: .arrearageTime)
        }
        if decoderContainer.contains(.userTagObject)
        {
            self.userTagObject = try decoderContainer.decode(Flags?.self, forKey: .userTagObject)
        }
        if decoderContainer.contains(.attachment)
        {
            self.attachment = try decoderContainer.decode(UserAttachment?.self, forKey: .attachment)
        }
    }
}
public extension UserResVo{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: UserResVoCodingKeys.self)
         try encoderContainer.encode(pin, forKey: .pin)
         try encoderContainer.encode(cscPhone, forKey: .cscPhone)
         try encoderContainer.encode(cscEmail, forKey: .cscEmail)
         try encoderContainer.encode(createTime, forKey: .createTime)
         try encoderContainer.encode(userType, forKey: .userType)
         try encoderContainer.encode(companyName, forKey: .companyName)
         try encoderContainer.encode(name, forKey: .name)
         try encoderContainer.encode(arrearageTime, forKey: .arrearageTime)
         try encoderContainer.encode(userTagObject, forKey: .userTagObject)
         try encoderContainer.encode(attachment, forKey: .attachment)
    }
}
///  aPIInfo
public class APIInfo:NSObject,Codable{
    /// 访问级别
    var accessLevel:Int?
    /// action name
    var actionName:String?
    /// action type
    var actionType:String?
    /// 资源
    var resource:String?
    /// 资源类型
    var resourceType:String?
    /// 子资源类型
    var subResourceType:String?
    /// 三级资源类型
    var terResourceType:String?



    public override init(){
            super.init()
    }

    enum APIInfoCodingKeys: String, CodingKey {
        case accessLevel
        case actionName
        case actionType
        case resource
        case resourceType
        case subResourceType
        case terResourceType
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: APIInfoCodingKeys.self)
        if decoderContainer.contains(.accessLevel)
        {
            self.accessLevel = try decoderContainer.decode(Int?.self, forKey: .accessLevel)
        }
        if decoderContainer.contains(.actionName)
        {
            self.actionName = try decoderContainer.decode(String?.self, forKey: .actionName)
        }
        if decoderContainer.contains(.actionType)
        {
            self.actionType = try decoderContainer.decode(String?.self, forKey: .actionType)
        }
        if decoderContainer.contains(.resource)
        {
            self.resource = try decoderContainer.decode(String?.self, forKey: .resource)
        }
        if decoderContainer.contains(.resourceType)
        {
            self.resourceType = try decoderContainer.decode(String?.self, forKey: .resourceType)
        }
        if decoderContainer.contains(.subResourceType)
        {
            self.subResourceType = try decoderContainer.decode(String?.self, forKey: .subResourceType)
        }
        if decoderContainer.contains(.terResourceType)
        {
            self.terResourceType = try decoderContainer.decode(String?.self, forKey: .terResourceType)
        }
    }
}
public extension APIInfo{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: APIInfoCodingKeys.self)
         try encoderContainer.encode(accessLevel, forKey: .accessLevel)
         try encoderContainer.encode(actionName, forKey: .actionName)
         try encoderContainer.encode(actionType, forKey: .actionType)
         try encoderContainer.encode(resource, forKey: .resource)
         try encoderContainer.encode(resourceType, forKey: .resourceType)
         try encoderContainer.encode(subResourceType, forKey: .subResourceType)
         try encoderContainer.encode(terResourceType, forKey: .terResourceType)
    }
}
///  resultMsg
public class ResultMsg:NSObject,Codable{
    /// 错误编码
    var errorCode:String?
    /// 错误信息
    var errorMsg:String?



    public override init(){
            super.init()
    }

    enum ResultMsgCodingKeys: String, CodingKey {
        case errorCode
        case errorMsg
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: ResultMsgCodingKeys.self)
        if decoderContainer.contains(.errorCode)
        {
            self.errorCode = try decoderContainer.decode(String?.self, forKey: .errorCode)
        }
        if decoderContainer.contains(.errorMsg)
        {
            self.errorMsg = try decoderContainer.decode(String?.self, forKey: .errorMsg)
        }
    }
}
public extension ResultMsg{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: ResultMsgCodingKeys.self)
         try encoderContainer.encode(errorCode, forKey: .errorCode)
         try encoderContainer.encode(errorMsg, forKey: .errorMsg)
    }
}
///  serviceDetail
public class ServiceDetail:NSObject,Codable{
    /// 产品线名称
    /// Required:true
    var serviceName:String
    /// 策略相关OpenAPI的Action列表
    /// Required:true
    var apiList:[APIInfo?]?
    /// 资源列表
    /// Required:true
    var resourceList:[String?]?



    public  init(serviceName:String,apiList:[APIInfo?]?,resourceList:[String?]?){
             self.serviceName = serviceName
             self.apiList = apiList
             self.resourceList = resourceList
    }

    enum ServiceDetailCodingKeys: String, CodingKey {
        case serviceName
        case apiList
        case resourceList
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: ServiceDetailCodingKeys.self)
        self.serviceName = try decoderContainer.decode(String.self, forKey: .serviceName)
        self.apiList = try decoderContainer.decode([APIInfo?]?.self, forKey: .apiList)
        self.resourceList = try decoderContainer.decode([String?]?.self, forKey: .resourceList)
    }
}
public extension ServiceDetail{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: ServiceDetailCodingKeys.self)
         try encoderContainer.encode(serviceName, forKey: .serviceName)
         try encoderContainer.encode(apiList, forKey: .apiList)
         try encoderContainer.encode(resourceList, forKey: .resourceList)
    }
}
///  userReqVo
public class UserReqVo:NSObject,Codable{
    /// 用户pin
    var pin:String?
    /// 用户手机号
    var cscPhone:String?
    /// 用户邮箱
    var cscEmail:String?
    /// 用户名
    var name:String?
    /// 用户类型
    var userType:Int?
    /// 公司名
    var companyName:String?
    /// 起始时间
    var createTimeStart:String?
    /// 结束时间
    var createTimeEnd:String?
    /// 欠费状态：
    var arrearageStatus:Int?
    /// 用户分组，多个逗号分隔:1-自然流量，2-内部测试，3-内部重点，4-渠道用户
    var groups:String?
    /// 用户分组:1-自然流量，2-内部测试，3-内部重点，4-渠道用户
    var group:Int?
    /// 计费白名单：1、在白名单  2、不在白名单
    var billingWhite:Int?
    /// 渠道等级;1普通用户2测试用户4VIP用户8其他VIP用户16boss迁移账户
    var tag:Int?
    /// 页大小
    var pageSize:Int?
    /// 当前页
    var currentPage:Int?



    public override init(){
            super.init()
    }

    enum UserReqVoCodingKeys: String, CodingKey {
        case pin
        case cscPhone
        case cscEmail
        case name
        case userType
        case companyName
        case createTimeStart
        case createTimeEnd
        case arrearageStatus
        case groups
        case group
        case billingWhite
        case tag
        case pageSize
        case currentPage
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: UserReqVoCodingKeys.self)
        if decoderContainer.contains(.pin)
        {
            self.pin = try decoderContainer.decode(String?.self, forKey: .pin)
        }
        if decoderContainer.contains(.cscPhone)
        {
            self.cscPhone = try decoderContainer.decode(String?.self, forKey: .cscPhone)
        }
        if decoderContainer.contains(.cscEmail)
        {
            self.cscEmail = try decoderContainer.decode(String?.self, forKey: .cscEmail)
        }
        if decoderContainer.contains(.name)
        {
            self.name = try decoderContainer.decode(String?.self, forKey: .name)
        }
        if decoderContainer.contains(.userType)
        {
            self.userType = try decoderContainer.decode(Int?.self, forKey: .userType)
        }
        if decoderContainer.contains(.companyName)
        {
            self.companyName = try decoderContainer.decode(String?.self, forKey: .companyName)
        }
        if decoderContainer.contains(.createTimeStart)
        {
            self.createTimeStart = try decoderContainer.decode(String?.self, forKey: .createTimeStart)
        }
        if decoderContainer.contains(.createTimeEnd)
        {
            self.createTimeEnd = try decoderContainer.decode(String?.self, forKey: .createTimeEnd)
        }
        if decoderContainer.contains(.arrearageStatus)
        {
            self.arrearageStatus = try decoderContainer.decode(Int?.self, forKey: .arrearageStatus)
        }
        if decoderContainer.contains(.groups)
        {
            self.groups = try decoderContainer.decode(String?.self, forKey: .groups)
        }
        if decoderContainer.contains(.group)
        {
            self.group = try decoderContainer.decode(Int?.self, forKey: .group)
        }
        if decoderContainer.contains(.billingWhite)
        {
            self.billingWhite = try decoderContainer.decode(Int?.self, forKey: .billingWhite)
        }
        if decoderContainer.contains(.tag)
        {
            self.tag = try decoderContainer.decode(Int?.self, forKey: .tag)
        }
        if decoderContainer.contains(.pageSize)
        {
            self.pageSize = try decoderContainer.decode(Int?.self, forKey: .pageSize)
        }
        if decoderContainer.contains(.currentPage)
        {
            self.currentPage = try decoderContainer.decode(Int?.self, forKey: .currentPage)
        }
    }
}
public extension UserReqVo{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: UserReqVoCodingKeys.self)
         try encoderContainer.encode(pin, forKey: .pin)
         try encoderContainer.encode(cscPhone, forKey: .cscPhone)
         try encoderContainer.encode(cscEmail, forKey: .cscEmail)
         try encoderContainer.encode(name, forKey: .name)
         try encoderContainer.encode(userType, forKey: .userType)
         try encoderContainer.encode(companyName, forKey: .companyName)
         try encoderContainer.encode(createTimeStart, forKey: .createTimeStart)
         try encoderContainer.encode(createTimeEnd, forKey: .createTimeEnd)
         try encoderContainer.encode(arrearageStatus, forKey: .arrearageStatus)
         try encoderContainer.encode(groups, forKey: .groups)
         try encoderContainer.encode(group, forKey: .group)
         try encoderContainer.encode(billingWhite, forKey: .billingWhite)
         try encoderContainer.encode(tag, forKey: .tag)
         try encoderContainer.encode(pageSize, forKey: .pageSize)
         try encoderContainer.encode(currentPage, forKey: .currentPage)
    }
}

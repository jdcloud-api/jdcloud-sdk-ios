/* Copyright 2018 JDCLOUD.COM

   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at

     http:#www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.

   IP Sets
   IP 黑白名单库, 预定义的 IP 黑白名单绑定到转发规则的黑名单或白名单后生效

   OpenAPI spec version: v1
   Contact: 

   NOTE: This class is auto generated by the jdcloud code generator program.
 */


import Foundation
///  webRule
public class WebRule:NSObject,Codable{
    /// 规则 Id
    var id:String?
    /// 实例 Id
    var instanceId:String?
    /// 子域名
    var domain:String?
    /// 规则的 CNAME
    var cname:String?
    /// CNAME 解析状态, 0: 解析异常, 1: 解析正常
    var cnameStatus:Int?
    /// Protocol
    var protocolValue:WebRuleProtocol?
    /// 是否为自定义端口号, 0: 为默认, 1: 为自定义
    var customPortStatus:Int?
    /// HTTP 协议的端口号, 如 80,81
    var port:[Int?]?
    /// HTTPS 协议的端口号, 如 443,8443
    var httpsPort:[Int?]?
    /// 是否开启 http 回源, 0: 为不开启, 1: 为开启, 当勾选 HTTPS 时可以配置该属性
    var httpOrigin:Int?
    /// 0: 防御状态, 1: 回源状态
    var status:Int?
    /// 回源类型: A 或者 CNAME
    var originType:String?
    /// OriginAddr
    var originAddr:[OriginAddrItem?]?
    /// 回源域名, originType 为 CNAME 时返回该字段
    var originDomain:String?
    /// OnlineAddr
    var onlineAddr:[String?]?
    /// 证书状态, 0: 异常, 1: 正常, 2: 证书未上传
    var httpCertStatus:Int?
    /// 证书 Id
    var certId:String?
    /// 证书名称
    var certName:String?
    /// 证书内容
    var httpsCertContent:String?
    /// 证书私钥
    var httpsRsaKey:String?
    /// 是否开启https强制跳转, 当 protocol 为 HTTP_HTTPS 时可以配置该属性
      ///   - 0 不强跳
      ///   - 1 开启强跳
      /// 
    var forceJump:Int?
    /// 转发规则,  wrr: 带权重的轮询, rr: 不带权重的轮询
    var algorithm:String?
    /// CC 状态, 0: CC 关闭, 1: CC 开启
    var ccStatus:Int?
    /// webSocket 状态, 0: 关闭, 1: 开启
    var webSocketStatus:Int?
    /// 黑名单状态, 0: 关闭, 1: 开启
    var blackListEnable:Int?
    /// 白名单状态, 0: 关闭, 1: 开启
    var whiteListEnable:Int?



    public override init(){
            super.init()
    }

    enum WebRuleCodingKeys: String, CodingKey {
        case id
        case instanceId
        case domain
        case cname
        case cnameStatus
        case protocolValue = "protocol"
        case customPortStatus
        case port
        case httpsPort
        case httpOrigin
        case status
        case originType
        case originAddr
        case originDomain
        case onlineAddr
        case httpCertStatus
        case certId
        case certName
        case httpsCertContent
        case httpsRsaKey
        case forceJump
        case algorithm
        case ccStatus
        case webSocketStatus
        case blackListEnable
        case whiteListEnable
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: WebRuleCodingKeys.self)
        if decoderContainer.contains(.id)
        {
            self.id = try decoderContainer.decode(String?.self, forKey: .id)
        }
        if decoderContainer.contains(.instanceId)
        {
            self.instanceId = try decoderContainer.decode(String?.self, forKey: .instanceId)
        }
        if decoderContainer.contains(.domain)
        {
            self.domain = try decoderContainer.decode(String?.self, forKey: .domain)
        }
        if decoderContainer.contains(.cname)
        {
            self.cname = try decoderContainer.decode(String?.self, forKey: .cname)
        }
        if decoderContainer.contains(.cnameStatus)
        {
            self.cnameStatus = try decoderContainer.decode(Int?.self, forKey: .cnameStatus)
        }
        if decoderContainer.contains(.protocolValue)
        {
            self.protocolValue = try decoderContainer.decode(WebRuleProtocol?.self, forKey: .protocolValue)
        }
        if decoderContainer.contains(.customPortStatus)
        {
            self.customPortStatus = try decoderContainer.decode(Int?.self, forKey: .customPortStatus)
        }
        if decoderContainer.contains(.port)
        {
            self.port = try decoderContainer.decode([Int?]?.self, forKey: .port)
        }
        if decoderContainer.contains(.httpsPort)
        {
            self.httpsPort = try decoderContainer.decode([Int?]?.self, forKey: .httpsPort)
        }
        if decoderContainer.contains(.httpOrigin)
        {
            self.httpOrigin = try decoderContainer.decode(Int?.self, forKey: .httpOrigin)
        }
        if decoderContainer.contains(.status)
        {
            self.status = try decoderContainer.decode(Int?.self, forKey: .status)
        }
        if decoderContainer.contains(.originType)
        {
            self.originType = try decoderContainer.decode(String?.self, forKey: .originType)
        }
        if decoderContainer.contains(.originAddr)
        {
            self.originAddr = try decoderContainer.decode([OriginAddrItem?]?.self, forKey: .originAddr)
        }
        if decoderContainer.contains(.originDomain)
        {
            self.originDomain = try decoderContainer.decode(String?.self, forKey: .originDomain)
        }
        if decoderContainer.contains(.onlineAddr)
        {
            self.onlineAddr = try decoderContainer.decode([String?]?.self, forKey: .onlineAddr)
        }
        if decoderContainer.contains(.httpCertStatus)
        {
            self.httpCertStatus = try decoderContainer.decode(Int?.self, forKey: .httpCertStatus)
        }
        if decoderContainer.contains(.certId)
        {
            self.certId = try decoderContainer.decode(String?.self, forKey: .certId)
        }
        if decoderContainer.contains(.certName)
        {
            self.certName = try decoderContainer.decode(String?.self, forKey: .certName)
        }
        if decoderContainer.contains(.httpsCertContent)
        {
            self.httpsCertContent = try decoderContainer.decode(String?.self, forKey: .httpsCertContent)
        }
        if decoderContainer.contains(.httpsRsaKey)
        {
            self.httpsRsaKey = try decoderContainer.decode(String?.self, forKey: .httpsRsaKey)
        }
        if decoderContainer.contains(.forceJump)
        {
            self.forceJump = try decoderContainer.decode(Int?.self, forKey: .forceJump)
        }
        if decoderContainer.contains(.algorithm)
        {
            self.algorithm = try decoderContainer.decode(String?.self, forKey: .algorithm)
        }
        if decoderContainer.contains(.ccStatus)
        {
            self.ccStatus = try decoderContainer.decode(Int?.self, forKey: .ccStatus)
        }
        if decoderContainer.contains(.webSocketStatus)
        {
            self.webSocketStatus = try decoderContainer.decode(Int?.self, forKey: .webSocketStatus)
        }
        if decoderContainer.contains(.blackListEnable)
        {
            self.blackListEnable = try decoderContainer.decode(Int?.self, forKey: .blackListEnable)
        }
        if decoderContainer.contains(.whiteListEnable)
        {
            self.whiteListEnable = try decoderContainer.decode(Int?.self, forKey: .whiteListEnable)
        }
    }
}
public extension WebRule{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: WebRuleCodingKeys.self)
         try encoderContainer.encode(id, forKey: .id)
         try encoderContainer.encode(instanceId, forKey: .instanceId)
         try encoderContainer.encode(domain, forKey: .domain)
         try encoderContainer.encode(cname, forKey: .cname)
         try encoderContainer.encode(cnameStatus, forKey: .cnameStatus)
         try encoderContainer.encode(protocolValue, forKey: .protocolValue)
         try encoderContainer.encode(customPortStatus, forKey: .customPortStatus)
         try encoderContainer.encode(port, forKey: .port)
         try encoderContainer.encode(httpsPort, forKey: .httpsPort)
         try encoderContainer.encode(httpOrigin, forKey: .httpOrigin)
         try encoderContainer.encode(status, forKey: .status)
         try encoderContainer.encode(originType, forKey: .originType)
         try encoderContainer.encode(originAddr, forKey: .originAddr)
         try encoderContainer.encode(originDomain, forKey: .originDomain)
         try encoderContainer.encode(onlineAddr, forKey: .onlineAddr)
         try encoderContainer.encode(httpCertStatus, forKey: .httpCertStatus)
         try encoderContainer.encode(certId, forKey: .certId)
         try encoderContainer.encode(certName, forKey: .certName)
         try encoderContainer.encode(httpsCertContent, forKey: .httpsCertContent)
         try encoderContainer.encode(httpsRsaKey, forKey: .httpsRsaKey)
         try encoderContainer.encode(forceJump, forKey: .forceJump)
         try encoderContainer.encode(algorithm, forKey: .algorithm)
         try encoderContainer.encode(ccStatus, forKey: .ccStatus)
         try encoderContainer.encode(webSocketStatus, forKey: .webSocketStatus)
         try encoderContainer.encode(blackListEnable, forKey: .blackListEnable)
         try encoderContainer.encode(whiteListEnable, forKey: .whiteListEnable)
    }
}
///  cCProtectionConfig
public class CCProtectionConfig:NSObject,Codable{
    /// 网站规则的 CC 防护状态, 0: 关闭, 1: 开启
    var enable:Int?
    /// 观察者模式, 0: 关闭, 1: 开启
    var observerMode:Int?
    /// 防护等级, 0: 正常, 1: 宽松, 2: 紧急, 3: 自定义
    var level:Int?
    /// HTTP 请求数阈值
    var ccThreshold:Int64?
    /// Host 的防护阈值
    var hostQps:Int64?
    /// Host + Url 的防护阈值
    var hostUrlQps:Int64?
    /// 每个源 IP 对 Host 的防护阈值
    var ipHostQps:Int64?
    /// 每个源 IP 对 Host + Url 的防护阈值
    var ipHostUrlQps:Int64?
    /// 开启的 cc 防护规则数量
    var ccProtectionRuleEnableCount:Int64?



    public override init(){
            super.init()
    }

    enum CCProtectionConfigCodingKeys: String, CodingKey {
        case enable
        case observerMode
        case level
        case ccThreshold
        case hostQps
        case hostUrlQps
        case ipHostQps
        case ipHostUrlQps
        case ccProtectionRuleEnableCount
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: CCProtectionConfigCodingKeys.self)
        if decoderContainer.contains(.enable)
        {
            self.enable = try decoderContainer.decode(Int?.self, forKey: .enable)
        }
        if decoderContainer.contains(.observerMode)
        {
            self.observerMode = try decoderContainer.decode(Int?.self, forKey: .observerMode)
        }
        if decoderContainer.contains(.level)
        {
            self.level = try decoderContainer.decode(Int?.self, forKey: .level)
        }
        if decoderContainer.contains(.ccThreshold)
        {
            self.ccThreshold = try decoderContainer.decode(Int64?.self, forKey: .ccThreshold)
        }
        if decoderContainer.contains(.hostQps)
        {
            self.hostQps = try decoderContainer.decode(Int64?.self, forKey: .hostQps)
        }
        if decoderContainer.contains(.hostUrlQps)
        {
            self.hostUrlQps = try decoderContainer.decode(Int64?.self, forKey: .hostUrlQps)
        }
        if decoderContainer.contains(.ipHostQps)
        {
            self.ipHostQps = try decoderContainer.decode(Int64?.self, forKey: .ipHostQps)
        }
        if decoderContainer.contains(.ipHostUrlQps)
        {
            self.ipHostUrlQps = try decoderContainer.decode(Int64?.self, forKey: .ipHostUrlQps)
        }
        if decoderContainer.contains(.ccProtectionRuleEnableCount)
        {
            self.ccProtectionRuleEnableCount = try decoderContainer.decode(Int64?.self, forKey: .ccProtectionRuleEnableCount)
        }
    }
}
public extension CCProtectionConfig{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: CCProtectionConfigCodingKeys.self)
         try encoderContainer.encode(enable, forKey: .enable)
         try encoderContainer.encode(observerMode, forKey: .observerMode)
         try encoderContainer.encode(level, forKey: .level)
         try encoderContainer.encode(ccThreshold, forKey: .ccThreshold)
         try encoderContainer.encode(hostQps, forKey: .hostQps)
         try encoderContainer.encode(hostUrlQps, forKey: .hostUrlQps)
         try encoderContainer.encode(ipHostQps, forKey: .ipHostQps)
         try encoderContainer.encode(ipHostUrlQps, forKey: .ipHostUrlQps)
         try encoderContainer.encode(ccProtectionRuleEnableCount, forKey: .ccProtectionRuleEnableCount)
    }
}
///  webBlackListRuleSpec
public class WebBlackListRuleSpec:NSObject,Codable{
    /// 黑名单规则名称
    /// Required:true
    var name:String
    /// 模式:&lt;br&gt;- 0: uri&lt;br&gt;- 1: ip&lt;br&gt;- 2: cookie&lt;br&gt;- 3: geo&lt;br&gt;- 4: header
    /// Required:true
    var mode:Int
    /// 匹配 key. mode 为 cookie 和 header 时必传.
      /// - mode 为 cookie 时, 传 cookie 的 name
      /// - mode 为 header 时, 传 header 的 key
      /// 
    var key:String?
    /// 匹配 value.
      /// - mode 为 uri 时, 传要匹配的 uri
      /// - mode 为 ip 时, 传引用的 ip 黑白名单 Id
      /// - mode 为 cookie 时, 传 cookie 的 value
      /// - mode 为 geo 时, 传 geo 区域编码以 &#39;,&#39; 分隔的字符串. 查询 &lt;a href&#x3D;&quot;http://docs.jdcloud.com/anti-ddos-pro/api/describegeoareas&quot;&gt;describeGeoAreas&lt;/a&gt; 接口获取可设置的地域编码列表
      /// - mode 为 header 时, 传 header 的 value
      /// 
    /// Required:true
    var value:String
    /// 匹配规则. mode 为 uri, cookie 和 header 时必传. 支持以下匹配规则
      /// - 0: 完全匹配
      /// - 1: 前缀匹配
      /// - 2: 包含
      /// - 3: 正则匹配
      /// - 4: 后缀匹配
      /// 
    var pattern:Int?
    /// 命中后处理动作
      /// - 0: 阻断
      /// - 1: 跳转
      /// - 2: 验证码
      /// 
    /// Required:true
    var action:Int
    /// 命中后处理值, action 为 1 时传跳转路径
      /// 
    var actionValue:String?
    /// 规则状态.
      /// - 0: 关闭
      /// - 1: 开启
      /// 
    /// Required:true
    var status:Int



    public  init(name:String,mode:Int,value:String,action:Int,status:Int){
             self.name = name
             self.mode = mode
             self.value = value
             self.action = action
             self.status = status
    }

    enum WebBlackListRuleSpecCodingKeys: String, CodingKey {
        case name
        case mode
        case key
        case value
        case pattern
        case action
        case actionValue
        case status
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: WebBlackListRuleSpecCodingKeys.self)
        self.name = try decoderContainer.decode(String.self, forKey: .name)
        self.mode = try decoderContainer.decode(Int.self, forKey: .mode)
        if decoderContainer.contains(.key)
        {
            self.key = try decoderContainer.decode(String?.self, forKey: .key)
        }
        self.value = try decoderContainer.decode(String.self, forKey: .value)
        if decoderContainer.contains(.pattern)
        {
            self.pattern = try decoderContainer.decode(Int?.self, forKey: .pattern)
        }
        self.action = try decoderContainer.decode(Int.self, forKey: .action)
        if decoderContainer.contains(.actionValue)
        {
            self.actionValue = try decoderContainer.decode(String?.self, forKey: .actionValue)
        }
        self.status = try decoderContainer.decode(Int.self, forKey: .status)
    }
}
public extension WebBlackListRuleSpec{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: WebBlackListRuleSpecCodingKeys.self)
         try encoderContainer.encode(name, forKey: .name)
         try encoderContainer.encode(mode, forKey: .mode)
         try encoderContainer.encode(key, forKey: .key)
         try encoderContainer.encode(value, forKey: .value)
         try encoderContainer.encode(pattern, forKey: .pattern)
         try encoderContainer.encode(action, forKey: .action)
         try encoderContainer.encode(actionValue, forKey: .actionValue)
         try encoderContainer.encode(status, forKey: .status)
    }
}
///  webWhiteListRule
public class WebWhiteListRule:NSObject,Codable{
    /// 白名单规则 Id
    var id:String?
    /// 白名单规则名称
    var name:String?
    /// 匹配模式:&lt;br&gt;- 0: uri&lt;br&gt;- 1: ip&lt;br&gt;- 2: cookie&lt;br&gt;- 3: geo&lt;br&gt;- 4: header
    var mode:Int?
    /// 匹配 key.
      /// - mode 为 cookie 时, 为 cookie 的 name
      /// - mode 为 header 时, 为 header 的 key
      /// 
    var key:String?
    /// 匹配 value.
      /// - mode 为 uri 时, 为要匹配的 uri
      /// - mode 为 ip 时, 为引用的 ip 黑白名单 Id
      /// - mode 为 cookie 时, 为 cookie 的 value
      /// - mode 为 header 时, 为 header 的 value
      /// 
    var value:String?
    /// 匹配规则. mode 为 uri, cookie 和 header 时必传. 包含以下匹配规则
      /// - 0: 完全匹配
      /// - 1: 前缀匹配
      /// - 2: 包含
      /// - 3: 正则匹配
      /// - 4: 后缀匹配
      /// 
    var pattern:Int?
    /// 命中后处理动作.
      /// - 0: 放行
      /// - 1: CC 防护
      /// 
    var action:Int?
    /// 规则状态.
      /// - 0: 关闭
      /// - 1: 开启
      /// 
    var status:Int?
    /// geo 白名单地域列表
    var geoList:[Geo?]?



    public override init(){
            super.init()
    }

    enum WebWhiteListRuleCodingKeys: String, CodingKey {
        case id
        case name
        case mode
        case key
        case value
        case pattern
        case action
        case status
        case geoList
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: WebWhiteListRuleCodingKeys.self)
        if decoderContainer.contains(.id)
        {
            self.id = try decoderContainer.decode(String?.self, forKey: .id)
        }
        if decoderContainer.contains(.name)
        {
            self.name = try decoderContainer.decode(String?.self, forKey: .name)
        }
        if decoderContainer.contains(.mode)
        {
            self.mode = try decoderContainer.decode(Int?.self, forKey: .mode)
        }
        if decoderContainer.contains(.key)
        {
            self.key = try decoderContainer.decode(String?.self, forKey: .key)
        }
        if decoderContainer.contains(.value)
        {
            self.value = try decoderContainer.decode(String?.self, forKey: .value)
        }
        if decoderContainer.contains(.pattern)
        {
            self.pattern = try decoderContainer.decode(Int?.self, forKey: .pattern)
        }
        if decoderContainer.contains(.action)
        {
            self.action = try decoderContainer.decode(Int?.self, forKey: .action)
        }
        if decoderContainer.contains(.status)
        {
            self.status = try decoderContainer.decode(Int?.self, forKey: .status)
        }
        if decoderContainer.contains(.geoList)
        {
            self.geoList = try decoderContainer.decode([Geo?]?.self, forKey: .geoList)
        }
    }
}
public extension WebWhiteListRule{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: WebWhiteListRuleCodingKeys.self)
         try encoderContainer.encode(id, forKey: .id)
         try encoderContainer.encode(name, forKey: .name)
         try encoderContainer.encode(mode, forKey: .mode)
         try encoderContainer.encode(key, forKey: .key)
         try encoderContainer.encode(value, forKey: .value)
         try encoderContainer.encode(pattern, forKey: .pattern)
         try encoderContainer.encode(action, forKey: .action)
         try encoderContainer.encode(status, forKey: .status)
         try encoderContainer.encode(geoList, forKey: .geoList)
    }
}
///  webRuleSpec
public class WebRuleSpec:NSObject,Codable{
    /// 子域名
    /// Required:true
    var domain:String
    /// 协议: http, https 至少一个为 true
    /// Required:true
    var protocolValue:WebRuleProtocol
    /// HTTP协议的端口号, 如80, 81; 如果 protocol.http 为 true, 至少配置一个端口, 最多添加 5 个
    var port:[Int?]?
    /// HTTPS协议的端口号，如443, 8443; 如果 protocol.https 为 true, 至少配置一个端口, 最多添加 5 个
    var httpsPort:[Int?]?
    /// 回源类型：A或者CNAME
    /// Required:true
    var originType:String
    /// originType 为 A 时，需要设置该字段
    var originAddr:[OriginAddrItem?]?
    /// 备用的回源地址列表，可以配置为一个域名或者多个 ip 地址
    var onlineAddr:[String?]?
    /// 回源域名,originType为CNAME时需要指定该字段
    var originDomain:String?
    /// 转发规则：wrr-&gt;带权重的轮询，rr-&gt;不带权重的轮询
    /// Required:true
    var algorithm:String
    /// 是否开启 https 强制跳转，当 protocol 为 HTTP_HTTPS 时可以配置该属性
      ///   - 0 不开启强制跳转
      ///   - 1 开启强制跳转
      /// 
    var forceJump:Int?
    /// 是否为自定义端口号，0为默认 1为自定义
    var customPortStatus:Int?
    /// 是否开启http回源, 当勾选HTTPS时可以配置该属性
      ///   - 0 不开启
      ///   - 1 开启
      /// 
    var httpOrigin:Int?
    /// 是否开启 WebSocket, 0 为不开启, 1 为开启
    /// Required:true
    var webSocketStatus:Int
    /// 证书内容
    var httpsCertContent:String?
    /// 证书私钥
    var httpsRsaKey:String?
    /// 证书 Id
      ///   - 如果传 certId, 请确认已经上传了相应的证书
      ///   - certId 缺省时网站规则将使用 httpsCertContent, httpsRsaKey 对应的证书
    var certId:String?



    public  init(domain:String,protocolValue:WebRuleProtocol,originType:String,algorithm:String,webSocketStatus:Int){
             self.domain = domain
             self.protocolValue = protocolValue
             self.originType = originType
             self.algorithm = algorithm
             self.webSocketStatus = webSocketStatus
    }

    enum WebRuleSpecCodingKeys: String, CodingKey {
        case domain
        case protocolValue = "protocol"
        case port
        case httpsPort
        case originType
        case originAddr
        case onlineAddr
        case originDomain
        case algorithm
        case forceJump
        case customPortStatus
        case httpOrigin
        case webSocketStatus
        case httpsCertContent
        case httpsRsaKey
        case certId
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: WebRuleSpecCodingKeys.self)
        self.domain = try decoderContainer.decode(String.self, forKey: .domain)
        self.protocolValue = try decoderContainer.decode(WebRuleProtocol.self, forKey: .protocolValue)
        if decoderContainer.contains(.port)
        {
            self.port = try decoderContainer.decode([Int?]?.self, forKey: .port)
        }
        if decoderContainer.contains(.httpsPort)
        {
            self.httpsPort = try decoderContainer.decode([Int?]?.self, forKey: .httpsPort)
        }
        self.originType = try decoderContainer.decode(String.self, forKey: .originType)
        if decoderContainer.contains(.originAddr)
        {
            self.originAddr = try decoderContainer.decode([OriginAddrItem?]?.self, forKey: .originAddr)
        }
        if decoderContainer.contains(.onlineAddr)
        {
            self.onlineAddr = try decoderContainer.decode([String?]?.self, forKey: .onlineAddr)
        }
        if decoderContainer.contains(.originDomain)
        {
            self.originDomain = try decoderContainer.decode(String?.self, forKey: .originDomain)
        }
        self.algorithm = try decoderContainer.decode(String.self, forKey: .algorithm)
        if decoderContainer.contains(.forceJump)
        {
            self.forceJump = try decoderContainer.decode(Int?.self, forKey: .forceJump)
        }
        if decoderContainer.contains(.customPortStatus)
        {
            self.customPortStatus = try decoderContainer.decode(Int?.self, forKey: .customPortStatus)
        }
        if decoderContainer.contains(.httpOrigin)
        {
            self.httpOrigin = try decoderContainer.decode(Int?.self, forKey: .httpOrigin)
        }
        self.webSocketStatus = try decoderContainer.decode(Int.self, forKey: .webSocketStatus)
        if decoderContainer.contains(.httpsCertContent)
        {
            self.httpsCertContent = try decoderContainer.decode(String?.self, forKey: .httpsCertContent)
        }
        if decoderContainer.contains(.httpsRsaKey)
        {
            self.httpsRsaKey = try decoderContainer.decode(String?.self, forKey: .httpsRsaKey)
        }
        if decoderContainer.contains(.certId)
        {
            self.certId = try decoderContainer.decode(String?.self, forKey: .certId)
        }
    }
}
public extension WebRuleSpec{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: WebRuleSpecCodingKeys.self)
         try encoderContainer.encode(domain, forKey: .domain)
         try encoderContainer.encode(protocolValue, forKey: .protocolValue)
         try encoderContainer.encode(port, forKey: .port)
         try encoderContainer.encode(httpsPort, forKey: .httpsPort)
         try encoderContainer.encode(originType, forKey: .originType)
         try encoderContainer.encode(originAddr, forKey: .originAddr)
         try encoderContainer.encode(onlineAddr, forKey: .onlineAddr)
         try encoderContainer.encode(originDomain, forKey: .originDomain)
         try encoderContainer.encode(algorithm, forKey: .algorithm)
         try encoderContainer.encode(forceJump, forKey: .forceJump)
         try encoderContainer.encode(customPortStatus, forKey: .customPortStatus)
         try encoderContainer.encode(httpOrigin, forKey: .httpOrigin)
         try encoderContainer.encode(webSocketStatus, forKey: .webSocketStatus)
         try encoderContainer.encode(httpsCertContent, forKey: .httpsCertContent)
         try encoderContainer.encode(httpsRsaKey, forKey: .httpsRsaKey)
         try encoderContainer.encode(certId, forKey: .certId)
    }
}
///  webWhiteListRuleSpec
public class WebWhiteListRuleSpec:NSObject,Codable{
    /// 白名单规则名称
    /// Required:true
    var name:String
    /// 模式:&lt;br&gt;- 0: uri&lt;br&gt;- 1: ip&lt;br&gt;- 2: cookie&lt;br&gt;- 3: geo&lt;br&gt;- 4: header
    /// Required:true
    var mode:Int
    /// 匹配 key. mode 为 cookie 和 header 时必传.
      /// - mode 为 cookie 时, 传 cookie 的 name
      /// - mode 为 header 时, 传 header 的 key
      /// 
    var key:String?
    /// 匹配 value.
      /// - mode 为 uri 时, 传要匹配的 uri
      /// - mode 为 ip 时, 传引用的 ip 黑白名单 Id
      /// - mode 为 cookie 时, 传 cookie 的 value
      /// - mode 为 geo 时, 传 geo 区域编码以 &#39;,&#39; 分隔的字符串. 查询 &lt;a href&#x3D;&quot;http://docs.jdcloud.com/anti-ddos-pro/api/describegeoareas&quot;&gt;describeGeoAreas&lt;/a&gt; 接口获取可设置的地域编码列表
      /// - mode 为 header 时, 传 header 的 value
      /// 
    /// Required:true
    var value:String
    /// 匹配规则. mode 为 uri, cookie 和 header 时必传. 支持以下匹配规则
      /// - 0: 完全匹配
      /// - 1: 前缀匹配
      /// - 2: 包含
      /// - 3: 正则匹配
      /// - 4: 后缀匹配
      /// 
    var pattern:Int?
    /// 命中后处理动作.
      /// - 0: 放行
      /// - 1: CC 防护
      /// 
    /// Required:true
    var action:Int
    /// 规则状态.
      /// - 0: 关闭
      /// - 1: 开启
      /// 
    /// Required:true
    var status:Int



    public  init(name:String,mode:Int,value:String,action:Int,status:Int){
             self.name = name
             self.mode = mode
             self.value = value
             self.action = action
             self.status = status
    }

    enum WebWhiteListRuleSpecCodingKeys: String, CodingKey {
        case name
        case mode
        case key
        case value
        case pattern
        case action
        case status
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: WebWhiteListRuleSpecCodingKeys.self)
        self.name = try decoderContainer.decode(String.self, forKey: .name)
        self.mode = try decoderContainer.decode(Int.self, forKey: .mode)
        if decoderContainer.contains(.key)
        {
            self.key = try decoderContainer.decode(String?.self, forKey: .key)
        }
        self.value = try decoderContainer.decode(String.self, forKey: .value)
        if decoderContainer.contains(.pattern)
        {
            self.pattern = try decoderContainer.decode(Int?.self, forKey: .pattern)
        }
        self.action = try decoderContainer.decode(Int.self, forKey: .action)
        self.status = try decoderContainer.decode(Int.self, forKey: .status)
    }
}
public extension WebWhiteListRuleSpec{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: WebWhiteListRuleSpecCodingKeys.self)
         try encoderContainer.encode(name, forKey: .name)
         try encoderContainer.encode(mode, forKey: .mode)
         try encoderContainer.encode(key, forKey: .key)
         try encoderContainer.encode(value, forKey: .value)
         try encoderContainer.encode(pattern, forKey: .pattern)
         try encoderContainer.encode(action, forKey: .action)
         try encoderContainer.encode(status, forKey: .status)
    }
}
///  certInfoModifySpec
public class CertInfoModifySpec:NSObject,Codable{
    /// 证书 Id
      /// - 如果传 certId, 请确认已经上传了相应的证书
      /// - certId 缺省时网站规则将使用 httpsCertContent, httpsRsaKey 对应的证书
      /// 
    var certId:String?
    /// 证书内容
    var httpsCertContent:String?
    /// 私钥
    var httpsRsaKey:String?



    public override init(){
            super.init()
    }

    enum CertInfoModifySpecCodingKeys: String, CodingKey {
        case certId
        case httpsCertContent
        case httpsRsaKey
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: CertInfoModifySpecCodingKeys.self)
        if decoderContainer.contains(.certId)
        {
            self.certId = try decoderContainer.decode(String?.self, forKey: .certId)
        }
        if decoderContainer.contains(.httpsCertContent)
        {
            self.httpsCertContent = try decoderContainer.decode(String?.self, forKey: .httpsCertContent)
        }
        if decoderContainer.contains(.httpsRsaKey)
        {
            self.httpsRsaKey = try decoderContainer.decode(String?.self, forKey: .httpsRsaKey)
        }
    }
}
public extension CertInfoModifySpec{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: CertInfoModifySpecCodingKeys.self)
         try encoderContainer.encode(certId, forKey: .certId)
         try encoderContainer.encode(httpsCertContent, forKey: .httpsCertContent)
         try encoderContainer.encode(httpsRsaKey, forKey: .httpsRsaKey)
    }
}
///  country
public class Country:NSObject,Codable{
    /// 国家或地区名称
    var label:String?
    /// 国家或地区编码
    var value:String?
    /// Children
    var children:[Country?]?



    public override init(){
            super.init()
    }

    enum CountryCodingKeys: String, CodingKey {
        case label
        case value
        case children
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: CountryCodingKeys.self)
        if decoderContainer.contains(.label)
        {
            self.label = try decoderContainer.decode(String?.self, forKey: .label)
        }
        if decoderContainer.contains(.value)
        {
            self.value = try decoderContainer.decode(String?.self, forKey: .value)
        }
        if decoderContainer.contains(.children)
        {
            self.children = try decoderContainer.decode([Country?]?.self, forKey: .children)
        }
    }
}
public extension Country{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: CountryCodingKeys.self)
         try encoderContainer.encode(label, forKey: .label)
         try encoderContainer.encode(value, forKey: .value)
         try encoderContainer.encode(children, forKey: .children)
    }
}
///  originAddrItem
public class OriginAddrItem:NSObject,Codable{
    /// 回源ip
    var ip:String?
    /// 权重
    var weight:Int?
    /// 是否为京东云内公网ip
    var inJdCloud:Bool?



    public override init(){
            super.init()
    }

    enum OriginAddrItemCodingKeys: String, CodingKey {
        case ip
        case weight
        case inJdCloud
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: OriginAddrItemCodingKeys.self)
        if decoderContainer.contains(.ip)
        {
            self.ip = try decoderContainer.decode(String?.self, forKey: .ip)
        }
        if decoderContainer.contains(.weight)
        {
            self.weight = try decoderContainer.decode(Int?.self, forKey: .weight)
        }
        if decoderContainer.contains(.inJdCloud)
        {
            self.inJdCloud = try decoderContainer.decode(Bool?.self, forKey: .inJdCloud)
        }
    }
}
public extension OriginAddrItem{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: OriginAddrItemCodingKeys.self)
         try encoderContainer.encode(ip, forKey: .ip)
         try encoderContainer.encode(weight, forKey: .weight)
         try encoderContainer.encode(inJdCloud, forKey: .inJdCloud)
    }
}
///  webRuleProtocol
public class WebRuleProtocol:NSObject,Codable{
    /// http 协议
    /// Required:true
    var http:Bool
    /// https 协议
    /// Required:true
    var https:Bool



    public  init(http:Bool,https:Bool){
             self.http = http
             self.https = https
    }

    enum WebRuleProtocolCodingKeys: String, CodingKey {
        case http
        case https
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: WebRuleProtocolCodingKeys.self)
        self.http = try decoderContainer.decode(Bool.self, forKey: .http)
        self.https = try decoderContainer.decode(Bool.self, forKey: .https)
    }
}
public extension WebRuleProtocol{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: WebRuleProtocolCodingKeys.self)
         try encoderContainer.encode(http, forKey: .http)
         try encoderContainer.encode(https, forKey: .https)
    }
}
///  cCProtectionRule
public class CCProtectionRule:NSObject,Codable{
    /// CC 防护规则 ID
    var id:String?
    /// CC 防护规则对应的网站规则 ID
    var webRuleId:String?
    /// CC 防护规则对应的实例 ID
    var instanceId:String?
    /// CC 防护规则名称, 30 字符以内
    var name:String?
    /// CC 防护规则状态: 0: 关闭, 1: 开启
    var enable:Int?
    /// uri, 以 / 开头, 200 字符以内
    var uri:String?
    /// 匹配 uri 类型, 0: 精确匹配, 1: 前缀匹配
    var matchType:Int?
    /// 检测周期, 单位为秒, 取值范围[5, 10800]
    var detectPeriod:Int64?
    /// ip 访问次数, 取值范围[2, 2000]
    var singleIpLimit:Int64?
    /// 阻断类型, 1: 封禁, 2: 人机交互
    var blockType:Int?
    /// 阻断持续时间, 单位为秒, 取值范围[10, 86400]
    var blockTime:Int64?



    public override init(){
            super.init()
    }

    enum CCProtectionRuleCodingKeys: String, CodingKey {
        case id
        case webRuleId
        case instanceId
        case name
        case enable
        case uri
        case matchType
        case detectPeriod
        case singleIpLimit
        case blockType
        case blockTime
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: CCProtectionRuleCodingKeys.self)
        if decoderContainer.contains(.id)
        {
            self.id = try decoderContainer.decode(String?.self, forKey: .id)
        }
        if decoderContainer.contains(.webRuleId)
        {
            self.webRuleId = try decoderContainer.decode(String?.self, forKey: .webRuleId)
        }
        if decoderContainer.contains(.instanceId)
        {
            self.instanceId = try decoderContainer.decode(String?.self, forKey: .instanceId)
        }
        if decoderContainer.contains(.name)
        {
            self.name = try decoderContainer.decode(String?.self, forKey: .name)
        }
        if decoderContainer.contains(.enable)
        {
            self.enable = try decoderContainer.decode(Int?.self, forKey: .enable)
        }
        if decoderContainer.contains(.uri)
        {
            self.uri = try decoderContainer.decode(String?.self, forKey: .uri)
        }
        if decoderContainer.contains(.matchType)
        {
            self.matchType = try decoderContainer.decode(Int?.self, forKey: .matchType)
        }
        if decoderContainer.contains(.detectPeriod)
        {
            self.detectPeriod = try decoderContainer.decode(Int64?.self, forKey: .detectPeriod)
        }
        if decoderContainer.contains(.singleIpLimit)
        {
            self.singleIpLimit = try decoderContainer.decode(Int64?.self, forKey: .singleIpLimit)
        }
        if decoderContainer.contains(.blockType)
        {
            self.blockType = try decoderContainer.decode(Int?.self, forKey: .blockType)
        }
        if decoderContainer.contains(.blockTime)
        {
            self.blockTime = try decoderContainer.decode(Int64?.self, forKey: .blockTime)
        }
    }
}
public extension CCProtectionRule{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: CCProtectionRuleCodingKeys.self)
         try encoderContainer.encode(id, forKey: .id)
         try encoderContainer.encode(webRuleId, forKey: .webRuleId)
         try encoderContainer.encode(instanceId, forKey: .instanceId)
         try encoderContainer.encode(name, forKey: .name)
         try encoderContainer.encode(enable, forKey: .enable)
         try encoderContainer.encode(uri, forKey: .uri)
         try encoderContainer.encode(matchType, forKey: .matchType)
         try encoderContainer.encode(detectPeriod, forKey: .detectPeriod)
         try encoderContainer.encode(singleIpLimit, forKey: .singleIpLimit)
         try encoderContainer.encode(blockType, forKey: .blockType)
         try encoderContainer.encode(blockTime, forKey: .blockTime)
    }
}
///  cCProtectionDefaultConfig
public class CCProtectionDefaultConfig:NSObject,Codable{
    /// HTTP 请求数阈值
    var ccThreshold:Int64?
    /// Host 的防护阈值
    var hostQps:Int64?
    /// Host + Url 的防护阈值
    var hostUrlQps:Int64?
    /// 每个源 IP 对 Host 的防护阈值
    var ipHostQps:Int64?
    /// 每个源 IP 对 Host + Url 的防护阈值
    var ipHostUrlQps:Int64?



    public override init(){
            super.init()
    }

    enum CCProtectionDefaultConfigCodingKeys: String, CodingKey {
        case ccThreshold
        case hostQps
        case hostUrlQps
        case ipHostQps
        case ipHostUrlQps
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: CCProtectionDefaultConfigCodingKeys.self)
        if decoderContainer.contains(.ccThreshold)
        {
            self.ccThreshold = try decoderContainer.decode(Int64?.self, forKey: .ccThreshold)
        }
        if decoderContainer.contains(.hostQps)
        {
            self.hostQps = try decoderContainer.decode(Int64?.self, forKey: .hostQps)
        }
        if decoderContainer.contains(.hostUrlQps)
        {
            self.hostUrlQps = try decoderContainer.decode(Int64?.self, forKey: .hostUrlQps)
        }
        if decoderContainer.contains(.ipHostQps)
        {
            self.ipHostQps = try decoderContainer.decode(Int64?.self, forKey: .ipHostQps)
        }
        if decoderContainer.contains(.ipHostUrlQps)
        {
            self.ipHostUrlQps = try decoderContainer.decode(Int64?.self, forKey: .ipHostUrlQps)
        }
    }
}
public extension CCProtectionDefaultConfig{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: CCProtectionDefaultConfigCodingKeys.self)
         try encoderContainer.encode(ccThreshold, forKey: .ccThreshold)
         try encoderContainer.encode(hostQps, forKey: .hostQps)
         try encoderContainer.encode(hostUrlQps, forKey: .hostUrlQps)
         try encoderContainer.encode(ipHostQps, forKey: .ipHostQps)
         try encoderContainer.encode(ipHostUrlQps, forKey: .ipHostUrlQps)
    }
}
///  webBlackListRule
public class WebBlackListRule:NSObject,Codable{
    /// 黑名单规则 Id
    var id:String?
    /// 黑名单规则名称
    var name:String?
    /// 匹配模式:&lt;br&gt;- 0: uri&lt;br&gt;- 1: ip&lt;br&gt;- 2: cookie&lt;br&gt;- 3: geo&lt;br&gt;- 4: header
    var mode:Int?
    /// 匹配 key.
      /// - mode 为 cookie 时, 为 cookie 的 name
      /// - mode 为 header 时, 为 header 的 key
      /// 
    var key:String?
    /// 匹配 value.
      /// - mode 为 uri 时, 为要匹配的 uri
      /// - mode 为 ip 时, 为引用的 ip 黑白名单 Id
      /// - mode 为 cookie 时, 为 cookie 的 value
      /// - mode 为 header 时, 为 header 的 value
      /// 
    var value:String?
    /// 匹配规则. mode 为 uri, cookie 和 header 时必传. 包含以下匹配规则
      /// - 0: 完全匹配
      /// - 1: 前缀匹配
      /// - 2: 包含
      /// - 3: 正则匹配
      /// - 4: 后缀匹配
      /// 
    var pattern:Int?
    /// 命中后处理动作.
      /// - 0: 放行
      /// - 1: CC 防护
      /// 
    var action:Int?
    /// 命中后处理值, action 为 2 时 actionValue 为跳转路径
    var actionValue:String?
    /// 规则状态.
      /// - 0: 关闭
      /// - 1: 开启
      /// 
    var status:Int?
    /// geo 黑名单地域列表, mode 不为 geo 或未设置时此字段为空
    var geoList:[Geo?]?



    public override init(){
            super.init()
    }

    enum WebBlackListRuleCodingKeys: String, CodingKey {
        case id
        case name
        case mode
        case key
        case value
        case pattern
        case action
        case actionValue
        case status
        case geoList
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: WebBlackListRuleCodingKeys.self)
        if decoderContainer.contains(.id)
        {
            self.id = try decoderContainer.decode(String?.self, forKey: .id)
        }
        if decoderContainer.contains(.name)
        {
            self.name = try decoderContainer.decode(String?.self, forKey: .name)
        }
        if decoderContainer.contains(.mode)
        {
            self.mode = try decoderContainer.decode(Int?.self, forKey: .mode)
        }
        if decoderContainer.contains(.key)
        {
            self.key = try decoderContainer.decode(String?.self, forKey: .key)
        }
        if decoderContainer.contains(.value)
        {
            self.value = try decoderContainer.decode(String?.self, forKey: .value)
        }
        if decoderContainer.contains(.pattern)
        {
            self.pattern = try decoderContainer.decode(Int?.self, forKey: .pattern)
        }
        if decoderContainer.contains(.action)
        {
            self.action = try decoderContainer.decode(Int?.self, forKey: .action)
        }
        if decoderContainer.contains(.actionValue)
        {
            self.actionValue = try decoderContainer.decode(String?.self, forKey: .actionValue)
        }
        if decoderContainer.contains(.status)
        {
            self.status = try decoderContainer.decode(Int?.self, forKey: .status)
        }
        if decoderContainer.contains(.geoList)
        {
            self.geoList = try decoderContainer.decode([Geo?]?.self, forKey: .geoList)
        }
    }
}
public extension WebBlackListRule{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: WebBlackListRuleCodingKeys.self)
         try encoderContainer.encode(id, forKey: .id)
         try encoderContainer.encode(name, forKey: .name)
         try encoderContainer.encode(mode, forKey: .mode)
         try encoderContainer.encode(key, forKey: .key)
         try encoderContainer.encode(value, forKey: .value)
         try encoderContainer.encode(pattern, forKey: .pattern)
         try encoderContainer.encode(action, forKey: .action)
         try encoderContainer.encode(actionValue, forKey: .actionValue)
         try encoderContainer.encode(status, forKey: .status)
         try encoderContainer.encode(geoList, forKey: .geoList)
    }
}
///  cCProtectionRuleSpec
public class CCProtectionRuleSpec:NSObject,Codable{
    /// CC 防护规则名称, 不允许为空, 长度不超过 32 个字符, 支持中文, 大小写字母, 数字及字符&#39;-&#39;、&#39;/&#39;、&#39;.&#39;、&#39;_&#39;
    /// Required:true
    var name:String
    /// uri, 不允许为空, 以 / 开头, 长度不超过 2048 个字符
    /// Required:true
    var uri:String
    /// 匹配 uri 类型, 0: 精确匹配, 1: 前缀匹配
    /// Required:true
    var matchType:Int
    /// 检测周期, 单位为秒, 取值范围[5, 10800]
    /// Required:true
    var detectPeriod:Int64
    /// ip 访问次数, 取值范围[2, 2000]
    /// Required:true
    var singleIpLimit:Int64
    /// 阻断类型, 1: 封禁, 2: 人机交互
    /// Required:true
    var blockType:Int
    /// 阻断持续时间, 单位为秒, 取值范围[10, 86400]
    /// Required:true
    var blockTime:Int64



    public  init(name:String,uri:String,matchType:Int,detectPeriod:Int64,singleIpLimit:Int64,blockType:Int,blockTime:Int64){
             self.name = name
             self.uri = uri
             self.matchType = matchType
             self.detectPeriod = detectPeriod
             self.singleIpLimit = singleIpLimit
             self.blockType = blockType
             self.blockTime = blockTime
    }

    enum CCProtectionRuleSpecCodingKeys: String, CodingKey {
        case name
        case uri
        case matchType
        case detectPeriod
        case singleIpLimit
        case blockType
        case blockTime
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: CCProtectionRuleSpecCodingKeys.self)
        self.name = try decoderContainer.decode(String.self, forKey: .name)
        self.uri = try decoderContainer.decode(String.self, forKey: .uri)
        self.matchType = try decoderContainer.decode(Int.self, forKey: .matchType)
        self.detectPeriod = try decoderContainer.decode(Int64.self, forKey: .detectPeriod)
        self.singleIpLimit = try decoderContainer.decode(Int64.self, forKey: .singleIpLimit)
        self.blockType = try decoderContainer.decode(Int.self, forKey: .blockType)
        self.blockTime = try decoderContainer.decode(Int64.self, forKey: .blockTime)
    }
}
public extension CCProtectionRuleSpec{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: CCProtectionRuleSpecCodingKeys.self)
         try encoderContainer.encode(name, forKey: .name)
         try encoderContainer.encode(uri, forKey: .uri)
         try encoderContainer.encode(matchType, forKey: .matchType)
         try encoderContainer.encode(detectPeriod, forKey: .detectPeriod)
         try encoderContainer.encode(singleIpLimit, forKey: .singleIpLimit)
         try encoderContainer.encode(blockType, forKey: .blockType)
         try encoderContainer.encode(blockTime, forKey: .blockTime)
    }
}
///  cCProtectionConfigSpec
public class CCProtectionConfigSpec:NSObject,Codable{
    /// 防护等级, 0: 正常, 1: 宽松, 2: 紧急, 3: 自定义
    /// Required:true
    var level:Int
    /// HTTP 请求数阈值, 防护等级为自定义时必传
    var ccThreshold:Int64?
    /// Host 的防护阈值, 防护等级为自定义时必传
    var hostQps:Int64?
    /// Host + Url 的防护阈值, 防护等级为自定义时必传
    var hostUrlQps:Int64?
    /// 每个源 IP 对 Host 的防护阈值, 防护等级为自定义时必传
    var ipHostQps:Int64?
    /// 每个源 IP 对 Host + Url 的防护阈值, 防护等级为自定义时必传
    var ipHostUrlQps:Int64?



    public  init(level:Int){
             self.level = level
    }

    enum CCProtectionConfigSpecCodingKeys: String, CodingKey {
        case level
        case ccThreshold
        case hostQps
        case hostUrlQps
        case ipHostQps
        case ipHostUrlQps
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: CCProtectionConfigSpecCodingKeys.self)
        self.level = try decoderContainer.decode(Int.self, forKey: .level)
        if decoderContainer.contains(.ccThreshold)
        {
            self.ccThreshold = try decoderContainer.decode(Int64?.self, forKey: .ccThreshold)
        }
        if decoderContainer.contains(.hostQps)
        {
            self.hostQps = try decoderContainer.decode(Int64?.self, forKey: .hostQps)
        }
        if decoderContainer.contains(.hostUrlQps)
        {
            self.hostUrlQps = try decoderContainer.decode(Int64?.self, forKey: .hostUrlQps)
        }
        if decoderContainer.contains(.ipHostQps)
        {
            self.ipHostQps = try decoderContainer.decode(Int64?.self, forKey: .ipHostQps)
        }
        if decoderContainer.contains(.ipHostUrlQps)
        {
            self.ipHostUrlQps = try decoderContainer.decode(Int64?.self, forKey: .ipHostUrlQps)
        }
    }
}
public extension CCProtectionConfigSpec{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: CCProtectionConfigSpecCodingKeys.self)
         try encoderContainer.encode(level, forKey: .level)
         try encoderContainer.encode(ccThreshold, forKey: .ccThreshold)
         try encoderContainer.encode(hostQps, forKey: .hostQps)
         try encoderContainer.encode(hostUrlQps, forKey: .hostUrlQps)
         try encoderContainer.encode(ipHostQps, forKey: .ipHostQps)
         try encoderContainer.encode(ipHostUrlQps, forKey: .ipHostUrlQps)
    }
}
///  geo
public class Geo:NSObject,Codable{
    /// geo 拦截地域
    var label:String?
    /// geo 拦截地域编码
    var value:String?



    public override init(){
            super.init()
    }

    enum GeoCodingKeys: String, CodingKey {
        case label
        case value
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: GeoCodingKeys.self)
        if decoderContainer.contains(.label)
        {
            self.label = try decoderContainer.decode(String?.self, forKey: .label)
        }
        if decoderContainer.contains(.value)
        {
            self.value = try decoderContainer.decode(String?.self, forKey: .value)
        }
    }
}
public extension Geo{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: GeoCodingKeys.self)
         try encoderContainer.encode(label, forKey: .label)
         try encoderContainer.encode(value, forKey: .value)
    }
}
///  forwardRuleSpec
public class ForwardRuleSpec:NSObject,Codable{
    /// 协议: TCP或者UDP
    /// Required:true
    var protocolValue:String
    /// 端口号, 取值范围[1, 65535]
    /// Required:true
    var port:Int
    /// 转发规则
      /// - wrr 带权重的轮询
      /// - rr  不带权重的轮询
      /// - sh  源地址hash
      /// 
    /// Required:true
    var algorithm:String
    /// 回源类型: A 或者 CNAME
    /// Required:true
    var originType:String
    /// OriginAddr
    var originAddr:[OriginAddrItem?]?
    /// 备用的回源地址列表, 可以配置为一个域名或者多个 ip 地址
    var onlineAddr:[String?]?
    /// 回源域名
    var originDomain:String?
    /// 回源端口号, 取值范围[1, 65535]
    /// Required:true
    var originPort:Int



    public  init(protocolValue:String,port:Int,algorithm:String,originType:String,originPort:Int){
             self.protocolValue = protocolValue
             self.port = port
             self.algorithm = algorithm
             self.originType = originType
             self.originPort = originPort
    }

    enum ForwardRuleSpecCodingKeys: String, CodingKey {
        case protocolValue = "protocol"
        case port
        case algorithm
        case originType
        case originAddr
        case onlineAddr
        case originDomain
        case originPort
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: ForwardRuleSpecCodingKeys.self)
        self.protocolValue = try decoderContainer.decode(String.self, forKey: .protocolValue)
        self.port = try decoderContainer.decode(Int.self, forKey: .port)
        self.algorithm = try decoderContainer.decode(String.self, forKey: .algorithm)
        self.originType = try decoderContainer.decode(String.self, forKey: .originType)
        if decoderContainer.contains(.originAddr)
        {
            self.originAddr = try decoderContainer.decode([OriginAddrItem?]?.self, forKey: .originAddr)
        }
        if decoderContainer.contains(.onlineAddr)
        {
            self.onlineAddr = try decoderContainer.decode([String?]?.self, forKey: .onlineAddr)
        }
        if decoderContainer.contains(.originDomain)
        {
            self.originDomain = try decoderContainer.decode(String?.self, forKey: .originDomain)
        }
        self.originPort = try decoderContainer.decode(Int.self, forKey: .originPort)
    }
}
public extension ForwardRuleSpec{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: ForwardRuleSpecCodingKeys.self)
         try encoderContainer.encode(protocolValue, forKey: .protocolValue)
         try encoderContainer.encode(port, forKey: .port)
         try encoderContainer.encode(algorithm, forKey: .algorithm)
         try encoderContainer.encode(originType, forKey: .originType)
         try encoderContainer.encode(originAddr, forKey: .originAddr)
         try encoderContainer.encode(onlineAddr, forKey: .onlineAddr)
         try encoderContainer.encode(originDomain, forKey: .originDomain)
         try encoderContainer.encode(originPort, forKey: .originPort)
    }
}
///  forwardRule
public class ForwardRule:NSObject,Codable{
    /// 规则id
    var id:String?
    /// 实例id
    var instanceId:String?
    /// TCP或UDP
    var protocolValue:String?
    /// 规则的cname
    var cname:String?
    /// 回源类型: ip或者domain
    var originType:String?
    /// 端口号
    var port:Int?
    /// 转发规则
      /// - wrr 带权重的轮询
      /// - rr  不带权重的轮询
      /// - sh  源地址hash
      /// 
    var algorithm:String?
    /// OriginAddr
    var originAddr:[OriginAddrItem?]?
    /// 备用的回源地址列表
    var onlineAddr:[String?]?
    /// 回源域名
    var originDomain:String?
    /// 回源端口号
    var originPort:Int?
    /// 0防御状态，1回源状态
    var status:Int?



    public override init(){
            super.init()
    }

    enum ForwardRuleCodingKeys: String, CodingKey {
        case id
        case instanceId
        case protocolValue = "protocol"
        case cname
        case originType
        case port
        case algorithm
        case originAddr
        case onlineAddr
        case originDomain
        case originPort
        case status
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: ForwardRuleCodingKeys.self)
        if decoderContainer.contains(.id)
        {
            self.id = try decoderContainer.decode(String?.self, forKey: .id)
        }
        if decoderContainer.contains(.instanceId)
        {
            self.instanceId = try decoderContainer.decode(String?.self, forKey: .instanceId)
        }
        if decoderContainer.contains(.protocolValue)
        {
            self.protocolValue = try decoderContainer.decode(String?.self, forKey: .protocolValue)
        }
        if decoderContainer.contains(.cname)
        {
            self.cname = try decoderContainer.decode(String?.self, forKey: .cname)
        }
        if decoderContainer.contains(.originType)
        {
            self.originType = try decoderContainer.decode(String?.self, forKey: .originType)
        }
        if decoderContainer.contains(.port)
        {
            self.port = try decoderContainer.decode(Int?.self, forKey: .port)
        }
        if decoderContainer.contains(.algorithm)
        {
            self.algorithm = try decoderContainer.decode(String?.self, forKey: .algorithm)
        }
        if decoderContainer.contains(.originAddr)
        {
            self.originAddr = try decoderContainer.decode([OriginAddrItem?]?.self, forKey: .originAddr)
        }
        if decoderContainer.contains(.onlineAddr)
        {
            self.onlineAddr = try decoderContainer.decode([String?]?.self, forKey: .onlineAddr)
        }
        if decoderContainer.contains(.originDomain)
        {
            self.originDomain = try decoderContainer.decode(String?.self, forKey: .originDomain)
        }
        if decoderContainer.contains(.originPort)
        {
            self.originPort = try decoderContainer.decode(Int?.self, forKey: .originPort)
        }
        if decoderContainer.contains(.status)
        {
            self.status = try decoderContainer.decode(Int?.self, forKey: .status)
        }
    }
}
public extension ForwardRule{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: ForwardRuleCodingKeys.self)
         try encoderContainer.encode(id, forKey: .id)
         try encoderContainer.encode(instanceId, forKey: .instanceId)
         try encoderContainer.encode(protocolValue, forKey: .protocolValue)
         try encoderContainer.encode(cname, forKey: .cname)
         try encoderContainer.encode(originType, forKey: .originType)
         try encoderContainer.encode(port, forKey: .port)
         try encoderContainer.encode(algorithm, forKey: .algorithm)
         try encoderContainer.encode(originAddr, forKey: .originAddr)
         try encoderContainer.encode(onlineAddr, forKey: .onlineAddr)
         try encoderContainer.encode(originDomain, forKey: .originDomain)
         try encoderContainer.encode(originPort, forKey: .originPort)
         try encoderContainer.encode(status, forKey: .status)
    }
}
///  modifyWhiteListRuleOfForwardRuleSpec
public class ModifyWhiteListRuleOfForwardRuleSpec:NSObject,Codable{
    /// 待引用的 IP 黑白名单 Id
    /// Required:true
    var ipSetId:String



    public  init(ipSetId:String){
             self.ipSetId = ipSetId
    }

    enum ModifyWhiteListRuleOfForwardRuleSpecCodingKeys: String, CodingKey {
        case ipSetId
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: ModifyWhiteListRuleOfForwardRuleSpecCodingKeys.self)
        self.ipSetId = try decoderContainer.decode(String.self, forKey: .ipSetId)
    }
}
public extension ModifyWhiteListRuleOfForwardRuleSpec{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: ModifyWhiteListRuleOfForwardRuleSpecCodingKeys.self)
         try encoderContainer.encode(ipSetId, forKey: .ipSetId)
    }
}
///  forwardBlackListRule
public class ForwardBlackListRule:NSObject,Codable{
    /// 是否开启, 0: 关闭, 1: 开启
    var status:Int?
    /// 引用的 IP 黑白名单 Id
    var ipSetId:String?
    /// 引用的 IP 黑白名单名称
    var ipSetName:String?
    /// 为 IP 或 IP 段的数组
    var ip:[String?]?



    public override init(){
            super.init()
    }

    enum ForwardBlackListRuleCodingKeys: String, CodingKey {
        case status
        case ipSetId
        case ipSetName
        case ip
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: ForwardBlackListRuleCodingKeys.self)
        if decoderContainer.contains(.status)
        {
            self.status = try decoderContainer.decode(Int?.self, forKey: .status)
        }
        if decoderContainer.contains(.ipSetId)
        {
            self.ipSetId = try decoderContainer.decode(String?.self, forKey: .ipSetId)
        }
        if decoderContainer.contains(.ipSetName)
        {
            self.ipSetName = try decoderContainer.decode(String?.self, forKey: .ipSetName)
        }
        if decoderContainer.contains(.ip)
        {
            self.ip = try decoderContainer.decode([String?]?.self, forKey: .ip)
        }
    }
}
public extension ForwardBlackListRule{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: ForwardBlackListRuleCodingKeys.self)
         try encoderContainer.encode(status, forKey: .status)
         try encoderContainer.encode(ipSetId, forKey: .ipSetId)
         try encoderContainer.encode(ipSetName, forKey: .ipSetName)
         try encoderContainer.encode(ip, forKey: .ip)
    }
}
///  modifyBlackListRuleOfForwardRuleSpec
public class ModifyBlackListRuleOfForwardRuleSpec:NSObject,Codable{
    /// 待引用的 IP 黑白名单 Id
    /// Required:true
    var ipSetId:String



    public  init(ipSetId:String){
             self.ipSetId = ipSetId
    }

    enum ModifyBlackListRuleOfForwardRuleSpecCodingKeys: String, CodingKey {
        case ipSetId
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: ModifyBlackListRuleOfForwardRuleSpecCodingKeys.self)
        self.ipSetId = try decoderContainer.decode(String.self, forKey: .ipSetId)
    }
}
public extension ModifyBlackListRuleOfForwardRuleSpec{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: ModifyBlackListRuleOfForwardRuleSpecCodingKeys.self)
         try encoderContainer.encode(ipSetId, forKey: .ipSetId)
    }
}
///  forwardWhiteListRule
public class ForwardWhiteListRule:NSObject,Codable{
    /// 是否开启, 0: 关闭, 1: 开启
    var status:Int?
    /// 引用的 IP 黑白名单 Id
    var ipSetId:String?
    /// 引用的 IP 黑白名单名称
    var ipSetName:String?
    /// IP 或 IP 段的数组
    var ip:[String?]?



    public override init(){
            super.init()
    }

    enum ForwardWhiteListRuleCodingKeys: String, CodingKey {
        case status
        case ipSetId
        case ipSetName
        case ip
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: ForwardWhiteListRuleCodingKeys.self)
        if decoderContainer.contains(.status)
        {
            self.status = try decoderContainer.decode(Int?.self, forKey: .status)
        }
        if decoderContainer.contains(.ipSetId)
        {
            self.ipSetId = try decoderContainer.decode(String?.self, forKey: .ipSetId)
        }
        if decoderContainer.contains(.ipSetName)
        {
            self.ipSetName = try decoderContainer.decode(String?.self, forKey: .ipSetName)
        }
        if decoderContainer.contains(.ip)
        {
            self.ip = try decoderContainer.decode([String?]?.self, forKey: .ip)
        }
    }
}
public extension ForwardWhiteListRule{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: ForwardWhiteListRuleCodingKeys.self)
         try encoderContainer.encode(status, forKey: .status)
         try encoderContainer.encode(ipSetId, forKey: .ipSetId)
         try encoderContainer.encode(ipSetName, forKey: .ipSetName)
         try encoderContainer.encode(ip, forKey: .ip)
    }
}
///  forwardProtectionRuleSpec
public class ForwardProtectionRuleSpec:NSObject,Codable{
    /// 虚假源与空连接, 0: 关闭, 1: 开启
    /// Required:true
    var spoofIpEnable:Int
    /// 源新建连接限速, 0: 关闭, 1: 开启
    /// Required:true
    var srcNewConnLimitEnable:Int
    /// 源新建连接速率
    /// Required:true
    var srcNewConnLimitValue:Int64
    /// 源并发连接限速, 0: 关闭, 1: 开启
    /// Required:true
    var srcConcurrentConnLimitEnable:Int
    /// 源并发连接速率
    /// Required:true
    var srcConcurrentConnLimitValue:Int64
    /// 目的新建连接, 0: 关闭, 1: 开启
    /// Required:true
    var dstNewConnLimitEnable:Int
    /// 目的新建连接速率
    /// Required:true
    var dstNewConnLimitValue:Int64
    /// 目的并发连接, 0: 关闭, 1: 开启
    /// Required:true
    var dstConcurrentConnLimitEnable:Int
    /// 目的并发连接速率
    /// Required:true
    var dstConcurrentConnLimitValue:Int64
    /// 报文最小长度, 取值范围[0, datagramRangeMax)
    /// Required:true
    var datagramRangeMin:Int64
    /// 报文最大长度, 取值范围(datagramRangeMin, 1518]
    /// Required:true
    var datagramRangeMax:Int64
    /// geo 拦截地域编码列表. 查询 &lt;a href&#x3D;&quot;http://docs.jdcloud.com/anti-ddos-pro/api/describegeoareas&quot;&gt;describeGeoAreas&lt;/a&gt; 接口获取可设置的地域编码列表
    var geoBlackList:[String?]?



    public  init(spoofIpEnable:Int,srcNewConnLimitEnable:Int,srcNewConnLimitValue:Int64,srcConcurrentConnLimitEnable:Int,srcConcurrentConnLimitValue:Int64,dstNewConnLimitEnable:Int,dstNewConnLimitValue:Int64,dstConcurrentConnLimitEnable:Int,dstConcurrentConnLimitValue:Int64,datagramRangeMin:Int64,datagramRangeMax:Int64){
             self.spoofIpEnable = spoofIpEnable
             self.srcNewConnLimitEnable = srcNewConnLimitEnable
             self.srcNewConnLimitValue = srcNewConnLimitValue
             self.srcConcurrentConnLimitEnable = srcConcurrentConnLimitEnable
             self.srcConcurrentConnLimitValue = srcConcurrentConnLimitValue
             self.dstNewConnLimitEnable = dstNewConnLimitEnable
             self.dstNewConnLimitValue = dstNewConnLimitValue
             self.dstConcurrentConnLimitEnable = dstConcurrentConnLimitEnable
             self.dstConcurrentConnLimitValue = dstConcurrentConnLimitValue
             self.datagramRangeMin = datagramRangeMin
             self.datagramRangeMax = datagramRangeMax
    }

    enum ForwardProtectionRuleSpecCodingKeys: String, CodingKey {
        case spoofIpEnable
        case srcNewConnLimitEnable
        case srcNewConnLimitValue
        case srcConcurrentConnLimitEnable
        case srcConcurrentConnLimitValue
        case dstNewConnLimitEnable
        case dstNewConnLimitValue
        case dstConcurrentConnLimitEnable
        case dstConcurrentConnLimitValue
        case datagramRangeMin
        case datagramRangeMax
        case geoBlackList
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: ForwardProtectionRuleSpecCodingKeys.self)
        self.spoofIpEnable = try decoderContainer.decode(Int.self, forKey: .spoofIpEnable)
        self.srcNewConnLimitEnable = try decoderContainer.decode(Int.self, forKey: .srcNewConnLimitEnable)
        self.srcNewConnLimitValue = try decoderContainer.decode(Int64.self, forKey: .srcNewConnLimitValue)
        self.srcConcurrentConnLimitEnable = try decoderContainer.decode(Int.self, forKey: .srcConcurrentConnLimitEnable)
        self.srcConcurrentConnLimitValue = try decoderContainer.decode(Int64.self, forKey: .srcConcurrentConnLimitValue)
        self.dstNewConnLimitEnable = try decoderContainer.decode(Int.self, forKey: .dstNewConnLimitEnable)
        self.dstNewConnLimitValue = try decoderContainer.decode(Int64.self, forKey: .dstNewConnLimitValue)
        self.dstConcurrentConnLimitEnable = try decoderContainer.decode(Int.self, forKey: .dstConcurrentConnLimitEnable)
        self.dstConcurrentConnLimitValue = try decoderContainer.decode(Int64.self, forKey: .dstConcurrentConnLimitValue)
        self.datagramRangeMin = try decoderContainer.decode(Int64.self, forKey: .datagramRangeMin)
        self.datagramRangeMax = try decoderContainer.decode(Int64.self, forKey: .datagramRangeMax)
        if decoderContainer.contains(.geoBlackList)
        {
            self.geoBlackList = try decoderContainer.decode([String?]?.self, forKey: .geoBlackList)
        }
    }
}
public extension ForwardProtectionRuleSpec{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: ForwardProtectionRuleSpecCodingKeys.self)
         try encoderContainer.encode(spoofIpEnable, forKey: .spoofIpEnable)
         try encoderContainer.encode(srcNewConnLimitEnable, forKey: .srcNewConnLimitEnable)
         try encoderContainer.encode(srcNewConnLimitValue, forKey: .srcNewConnLimitValue)
         try encoderContainer.encode(srcConcurrentConnLimitEnable, forKey: .srcConcurrentConnLimitEnable)
         try encoderContainer.encode(srcConcurrentConnLimitValue, forKey: .srcConcurrentConnLimitValue)
         try encoderContainer.encode(dstNewConnLimitEnable, forKey: .dstNewConnLimitEnable)
         try encoderContainer.encode(dstNewConnLimitValue, forKey: .dstNewConnLimitValue)
         try encoderContainer.encode(dstConcurrentConnLimitEnable, forKey: .dstConcurrentConnLimitEnable)
         try encoderContainer.encode(dstConcurrentConnLimitValue, forKey: .dstConcurrentConnLimitValue)
         try encoderContainer.encode(datagramRangeMin, forKey: .datagramRangeMin)
         try encoderContainer.encode(datagramRangeMax, forKey: .datagramRangeMax)
         try encoderContainer.encode(geoBlackList, forKey: .geoBlackList)
    }
}
///  forwardProtectionRule
public class ForwardProtectionRule:NSObject,Codable{
    /// 虚假源与空连接, 0: 关闭, 1: 开启
    var spoofIpEnable:Int?
    /// 源新建连接限速, 0: 关闭, 1: 开启
    var srcNewConnLimitEnable:Int?
    /// 源新建连接速率
    var srcNewConnLimitValue:Int64?
    /// 源并发连接限速, 0: 关闭, 1: 开启
    var srcConcurrentConnLimitEnable:Int?
    /// 源并发连接速率
    var srcConcurrentConnLimitValue:Int64?
    /// 目的新建连接限速, 0: 关闭, 1: 开启
    var dstNewConnLimitEnable:Int?
    /// 目的新建连接速率
    var dstNewConnLimitValue:Int64?
    /// 目的并发连接限速, 0: 关闭, 1: 开启
    var dstConcurrentConnLimitEnable:Int?
    /// 目的并发连接速率
    var dstConcurrentConnLimitValue:Int64?
    /// 报文最小长度
    var datagramRangeMin:Int64?
    /// 报文最大长度
    var datagramRangeMax:Int64?
    /// geo 拦截地域列表
    var geoBlackList:[Geo?]?



    public override init(){
            super.init()
    }

    enum ForwardProtectionRuleCodingKeys: String, CodingKey {
        case spoofIpEnable
        case srcNewConnLimitEnable
        case srcNewConnLimitValue
        case srcConcurrentConnLimitEnable
        case srcConcurrentConnLimitValue
        case dstNewConnLimitEnable
        case dstNewConnLimitValue
        case dstConcurrentConnLimitEnable
        case dstConcurrentConnLimitValue
        case datagramRangeMin
        case datagramRangeMax
        case geoBlackList
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: ForwardProtectionRuleCodingKeys.self)
        if decoderContainer.contains(.spoofIpEnable)
        {
            self.spoofIpEnable = try decoderContainer.decode(Int?.self, forKey: .spoofIpEnable)
        }
        if decoderContainer.contains(.srcNewConnLimitEnable)
        {
            self.srcNewConnLimitEnable = try decoderContainer.decode(Int?.self, forKey: .srcNewConnLimitEnable)
        }
        if decoderContainer.contains(.srcNewConnLimitValue)
        {
            self.srcNewConnLimitValue = try decoderContainer.decode(Int64?.self, forKey: .srcNewConnLimitValue)
        }
        if decoderContainer.contains(.srcConcurrentConnLimitEnable)
        {
            self.srcConcurrentConnLimitEnable = try decoderContainer.decode(Int?.self, forKey: .srcConcurrentConnLimitEnable)
        }
        if decoderContainer.contains(.srcConcurrentConnLimitValue)
        {
            self.srcConcurrentConnLimitValue = try decoderContainer.decode(Int64?.self, forKey: .srcConcurrentConnLimitValue)
        }
        if decoderContainer.contains(.dstNewConnLimitEnable)
        {
            self.dstNewConnLimitEnable = try decoderContainer.decode(Int?.self, forKey: .dstNewConnLimitEnable)
        }
        if decoderContainer.contains(.dstNewConnLimitValue)
        {
            self.dstNewConnLimitValue = try decoderContainer.decode(Int64?.self, forKey: .dstNewConnLimitValue)
        }
        if decoderContainer.contains(.dstConcurrentConnLimitEnable)
        {
            self.dstConcurrentConnLimitEnable = try decoderContainer.decode(Int?.self, forKey: .dstConcurrentConnLimitEnable)
        }
        if decoderContainer.contains(.dstConcurrentConnLimitValue)
        {
            self.dstConcurrentConnLimitValue = try decoderContainer.decode(Int64?.self, forKey: .dstConcurrentConnLimitValue)
        }
        if decoderContainer.contains(.datagramRangeMin)
        {
            self.datagramRangeMin = try decoderContainer.decode(Int64?.self, forKey: .datagramRangeMin)
        }
        if decoderContainer.contains(.datagramRangeMax)
        {
            self.datagramRangeMax = try decoderContainer.decode(Int64?.self, forKey: .datagramRangeMax)
        }
        if decoderContainer.contains(.geoBlackList)
        {
            self.geoBlackList = try decoderContainer.decode([Geo?]?.self, forKey: .geoBlackList)
        }
    }
}
public extension ForwardProtectionRule{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: ForwardProtectionRuleCodingKeys.self)
         try encoderContainer.encode(spoofIpEnable, forKey: .spoofIpEnable)
         try encoderContainer.encode(srcNewConnLimitEnable, forKey: .srcNewConnLimitEnable)
         try encoderContainer.encode(srcNewConnLimitValue, forKey: .srcNewConnLimitValue)
         try encoderContainer.encode(srcConcurrentConnLimitEnable, forKey: .srcConcurrentConnLimitEnable)
         try encoderContainer.encode(srcConcurrentConnLimitValue, forKey: .srcConcurrentConnLimitValue)
         try encoderContainer.encode(dstNewConnLimitEnable, forKey: .dstNewConnLimitEnable)
         try encoderContainer.encode(dstNewConnLimitValue, forKey: .dstNewConnLimitValue)
         try encoderContainer.encode(dstConcurrentConnLimitEnable, forKey: .dstConcurrentConnLimitEnable)
         try encoderContainer.encode(dstConcurrentConnLimitValue, forKey: .dstConcurrentConnLimitValue)
         try encoderContainer.encode(datagramRangeMin, forKey: .datagramRangeMin)
         try encoderContainer.encode(datagramRangeMax, forKey: .datagramRangeMax)
         try encoderContainer.encode(geoBlackList, forKey: .geoBlackList)
    }
}
///  certificate
public class Certificate:NSObject,Codable{
    /// 证书 Id
    var id:String?
    /// 证书名称
    var name:String?
    /// 证书
    var content:String?
    /// 秘钥
    var rsaKey:String?
    /// 绑定域名
    var domain:String?
    /// 证书生效时间
    var from:String?
    /// 证书到期时间
    var to:String?
    /// 加密算法
    var sigAlgName:String?
    /// 颁发者
    var issuer:String?
    /// 颁发给
    var organization:String?
    /// 上传时间
    var uploadTime:String?
    /// 已关联域名
    var associatedDomains:[String?]?
    /// 推荐域名
    var sanDomains:[String?]?



    public override init(){
            super.init()
    }

    enum CertificateCodingKeys: String, CodingKey {
        case id
        case name
        case content
        case rsaKey
        case domain
        case from
        case to
        case sigAlgName
        case issuer
        case organization
        case uploadTime
        case associatedDomains
        case sanDomains
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: CertificateCodingKeys.self)
        if decoderContainer.contains(.id)
        {
            self.id = try decoderContainer.decode(String?.self, forKey: .id)
        }
        if decoderContainer.contains(.name)
        {
            self.name = try decoderContainer.decode(String?.self, forKey: .name)
        }
        if decoderContainer.contains(.content)
        {
            self.content = try decoderContainer.decode(String?.self, forKey: .content)
        }
        if decoderContainer.contains(.rsaKey)
        {
            self.rsaKey = try decoderContainer.decode(String?.self, forKey: .rsaKey)
        }
        if decoderContainer.contains(.domain)
        {
            self.domain = try decoderContainer.decode(String?.self, forKey: .domain)
        }
        if decoderContainer.contains(.from)
        {
            self.from = try decoderContainer.decode(String?.self, forKey: .from)
        }
        if decoderContainer.contains(.to)
        {
            self.to = try decoderContainer.decode(String?.self, forKey: .to)
        }
        if decoderContainer.contains(.sigAlgName)
        {
            self.sigAlgName = try decoderContainer.decode(String?.self, forKey: .sigAlgName)
        }
        if decoderContainer.contains(.issuer)
        {
            self.issuer = try decoderContainer.decode(String?.self, forKey: .issuer)
        }
        if decoderContainer.contains(.organization)
        {
            self.organization = try decoderContainer.decode(String?.self, forKey: .organization)
        }
        if decoderContainer.contains(.uploadTime)
        {
            self.uploadTime = try decoderContainer.decode(String?.self, forKey: .uploadTime)
        }
        if decoderContainer.contains(.associatedDomains)
        {
            self.associatedDomains = try decoderContainer.decode([String?]?.self, forKey: .associatedDomains)
        }
        if decoderContainer.contains(.sanDomains)
        {
            self.sanDomains = try decoderContainer.decode([String?]?.self, forKey: .sanDomains)
        }
    }
}
public extension Certificate{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: CertificateCodingKeys.self)
         try encoderContainer.encode(id, forKey: .id)
         try encoderContainer.encode(name, forKey: .name)
         try encoderContainer.encode(content, forKey: .content)
         try encoderContainer.encode(rsaKey, forKey: .rsaKey)
         try encoderContainer.encode(domain, forKey: .domain)
         try encoderContainer.encode(from, forKey: .from)
         try encoderContainer.encode(to, forKey: .to)
         try encoderContainer.encode(sigAlgName, forKey: .sigAlgName)
         try encoderContainer.encode(issuer, forKey: .issuer)
         try encoderContainer.encode(organization, forKey: .organization)
         try encoderContainer.encode(uploadTime, forKey: .uploadTime)
         try encoderContainer.encode(associatedDomains, forKey: .associatedDomains)
         try encoderContainer.encode(sanDomains, forKey: .sanDomains)
    }
}
///  certificateSpec
public class CertificateSpec:NSObject,Codable{
    /// 证书名称
    var name:String?
    /// 证书内容
    var content:String?
    /// 私钥
    var rsaKey:String?



    public override init(){
            super.init()
    }

    enum CertificateSpecCodingKeys: String, CodingKey {
        case name
        case content
        case rsaKey
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: CertificateSpecCodingKeys.self)
        if decoderContainer.contains(.name)
        {
            self.name = try decoderContainer.decode(String?.self, forKey: .name)
        }
        if decoderContainer.contains(.content)
        {
            self.content = try decoderContainer.decode(String?.self, forKey: .content)
        }
        if decoderContainer.contains(.rsaKey)
        {
            self.rsaKey = try decoderContainer.decode(String?.self, forKey: .rsaKey)
        }
    }
}
public extension CertificateSpec{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: CertificateSpecCodingKeys.self)
         try encoderContainer.encode(name, forKey: .name)
         try encoderContainer.encode(content, forKey: .content)
         try encoderContainer.encode(rsaKey, forKey: .rsaKey)
    }
}
///  dDoSAttackLog
public class DDoSAttackLog:NSObject,Codable{
    /// 攻击流量大小
    var attackTraffic:Double?
    /// 是否触发黑洞，0否 1是
    var blackHole:Int?
    /// 攻击开始时间
    var startTime:String?
    /// 攻击结束时间
    var endTime:String?
    /// 流量单位，bps、Kbps、Mbps、Gbps
    var unit:String?
    /// 高防实例id
    var instanceId:String?
    /// 高防实例名称
    var name:String?



    public override init(){
            super.init()
    }

    enum DDoSAttackLogCodingKeys: String, CodingKey {
        case attackTraffic
        case blackHole
        case startTime
        case endTime
        case unit
        case instanceId
        case name
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: DDoSAttackLogCodingKeys.self)
        if decoderContainer.contains(.attackTraffic)
        {
            self.attackTraffic = try decoderContainer.decode(Double?.self, forKey: .attackTraffic)
        }
        if decoderContainer.contains(.blackHole)
        {
            self.blackHole = try decoderContainer.decode(Int?.self, forKey: .blackHole)
        }
        if decoderContainer.contains(.startTime)
        {
            self.startTime = try decoderContainer.decode(String?.self, forKey: .startTime)
        }
        if decoderContainer.contains(.endTime)
        {
            self.endTime = try decoderContainer.decode(String?.self, forKey: .endTime)
        }
        if decoderContainer.contains(.unit)
        {
            self.unit = try decoderContainer.decode(String?.self, forKey: .unit)
        }
        if decoderContainer.contains(.instanceId)
        {
            self.instanceId = try decoderContainer.decode(String?.self, forKey: .instanceId)
        }
        if decoderContainer.contains(.name)
        {
            self.name = try decoderContainer.decode(String?.self, forKey: .name)
        }
    }
}
public extension DDoSAttackLog{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: DDoSAttackLogCodingKeys.self)
         try encoderContainer.encode(attackTraffic, forKey: .attackTraffic)
         try encoderContainer.encode(blackHole, forKey: .blackHole)
         try encoderContainer.encode(startTime, forKey: .startTime)
         try encoderContainer.encode(endTime, forKey: .endTime)
         try encoderContainer.encode(unit, forKey: .unit)
         try encoderContainer.encode(instanceId, forKey: .instanceId)
         try encoderContainer.encode(name, forKey: .name)
    }
}
///  attackTypeCount
public class AttackTypeCount:NSObject,Codable{
    /// 攻击类型
    var type:String?
    /// 攻击次数
    var count:Int?



    public override init(){
            super.init()
    }

    enum AttackTypeCountCodingKeys: String, CodingKey {
        case type
        case count
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: AttackTypeCountCodingKeys.self)
        if decoderContainer.contains(.type)
        {
            self.type = try decoderContainer.decode(String?.self, forKey: .type)
        }
        if decoderContainer.contains(.count)
        {
            self.count = try decoderContainer.decode(Int?.self, forKey: .count)
        }
    }
}
public extension AttackTypeCount{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: AttackTypeCountCodingKeys.self)
         try encoderContainer.encode(type, forKey: .type)
         try encoderContainer.encode(count, forKey: .count)
    }
}
///  cCAttackLog
public class CCAttackLog:NSObject,Codable{
    /// CC 攻击记录Id
    var attackId:String?
    /// 攻击流量大小
    var attackTraffic:Double?
    /// 是否触发黑洞，0否 1是
    var blackHole:Int?
    /// 攻击开始时间
    var startTime:String?
    /// 攻击结束时间
    var endTime:String?
    /// 流量单位，bps、Kbps、Mbps、Gbps
    var unit:String?
    /// 高防实例id
    var instanceId:String?
    /// 高防实例名称
    var name:String?



    public override init(){
            super.init()
    }

    enum CCAttackLogCodingKeys: String, CodingKey {
        case attackId
        case attackTraffic
        case blackHole
        case startTime
        case endTime
        case unit
        case instanceId
        case name
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: CCAttackLogCodingKeys.self)
        if decoderContainer.contains(.attackId)
        {
            self.attackId = try decoderContainer.decode(String?.self, forKey: .attackId)
        }
        if decoderContainer.contains(.attackTraffic)
        {
            self.attackTraffic = try decoderContainer.decode(Double?.self, forKey: .attackTraffic)
        }
        if decoderContainer.contains(.blackHole)
        {
            self.blackHole = try decoderContainer.decode(Int?.self, forKey: .blackHole)
        }
        if decoderContainer.contains(.startTime)
        {
            self.startTime = try decoderContainer.decode(String?.self, forKey: .startTime)
        }
        if decoderContainer.contains(.endTime)
        {
            self.endTime = try decoderContainer.decode(String?.self, forKey: .endTime)
        }
        if decoderContainer.contains(.unit)
        {
            self.unit = try decoderContainer.decode(String?.self, forKey: .unit)
        }
        if decoderContainer.contains(.instanceId)
        {
            self.instanceId = try decoderContainer.decode(String?.self, forKey: .instanceId)
        }
        if decoderContainer.contains(.name)
        {
            self.name = try decoderContainer.decode(String?.self, forKey: .name)
        }
    }
}
public extension CCAttackLog{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: CCAttackLogCodingKeys.self)
         try encoderContainer.encode(attackId, forKey: .attackId)
         try encoderContainer.encode(attackTraffic, forKey: .attackTraffic)
         try encoderContainer.encode(blackHole, forKey: .blackHole)
         try encoderContainer.encode(startTime, forKey: .startTime)
         try encoderContainer.encode(endTime, forKey: .endTime)
         try encoderContainer.encode(unit, forKey: .unit)
         try encoderContainer.encode(instanceId, forKey: .instanceId)
         try encoderContainer.encode(name, forKey: .name)
    }
}
///  cCAttackLogDetail
public class CCAttackLogDetail:NSObject,Codable{
    /// 特征key
    var key:String?
    /// 攻击次数
    var num:Int?



    public override init(){
            super.init()
    }

    enum CCAttackLogDetailCodingKeys: String, CodingKey {
        case key
        case num
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: CCAttackLogDetailCodingKeys.self)
        if decoderContainer.contains(.key)
        {
            self.key = try decoderContainer.decode(String?.self, forKey: .key)
        }
        if decoderContainer.contains(.num)
        {
            self.num = try decoderContainer.decode(Int?.self, forKey: .num)
        }
    }
}
public extension CCAttackLogDetail{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: CCAttackLogDetailCodingKeys.self)
         try encoderContainer.encode(key, forKey: .key)
         try encoderContainer.encode(num, forKey: .num)
    }
}
///  createInstanceSpec
public class CreateInstanceSpec:NSObject,Codable{
    /// 实例 Id, 升级时必传
    var id:String?
    /// 实例名称, 新购时必传
    var name:String?
    /// 购买类型：1新购 3升级
    /// Required:true
    var buyType:Int
    /// 链路类型, 1: 电信, 2: 电信、联通, 3: 电信、联通和移动
    /// Required:true
    var carrier:Int
    /// 可防护 ip 类型, 目前仅电信线路支持 IPV6 线路:
      /// - 0: IPV4,
      /// - 1: IPV4/IPV6
      /// 
    var ipType:Int?
    /// 保底带宽：单位Gbps
    /// Required:true
    var bp:Int
    /// 弹性带宽：单位Gbps
    /// Required:true
    var ep:Int
    /// 业务带宽：单位Mbps
    /// Required:true
    var bw:Int
    /// 购买防护包时长, 新购高防实例时必传
      /// - timeUnit 为 3 时, 可取值 1-9
      /// - timeUnit 为 4 时, 可取值 1-3
      /// 
    var timeSpan:Int64?
    /// 购买时长类型, 新购高防实例时必传
      /// - 3: 月
      /// - 4: 年
      /// 
    var timeUnit:Int?
    /// 支付成功后跳转的页面，控制台交互模式传该字段
    var returnUrl:String?



    public  init(buyType:Int,carrier:Int,bp:Int,ep:Int,bw:Int){
             self.buyType = buyType
             self.carrier = carrier
             self.bp = bp
             self.ep = ep
             self.bw = bw
    }

    enum CreateInstanceSpecCodingKeys: String, CodingKey {
        case id
        case name
        case buyType
        case carrier
        case ipType
        case bp
        case ep
        case bw
        case timeSpan
        case timeUnit
        case returnUrl
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: CreateInstanceSpecCodingKeys.self)
        if decoderContainer.contains(.id)
        {
            self.id = try decoderContainer.decode(String?.self, forKey: .id)
        }
        if decoderContainer.contains(.name)
        {
            self.name = try decoderContainer.decode(String?.self, forKey: .name)
        }
        self.buyType = try decoderContainer.decode(Int.self, forKey: .buyType)
        self.carrier = try decoderContainer.decode(Int.self, forKey: .carrier)
        if decoderContainer.contains(.ipType)
        {
            self.ipType = try decoderContainer.decode(Int?.self, forKey: .ipType)
        }
        self.bp = try decoderContainer.decode(Int.self, forKey: .bp)
        self.ep = try decoderContainer.decode(Int.self, forKey: .ep)
        self.bw = try decoderContainer.decode(Int.self, forKey: .bw)
        if decoderContainer.contains(.timeSpan)
        {
            self.timeSpan = try decoderContainer.decode(Int64?.self, forKey: .timeSpan)
        }
        if decoderContainer.contains(.timeUnit)
        {
            self.timeUnit = try decoderContainer.decode(Int?.self, forKey: .timeUnit)
        }
        if decoderContainer.contains(.returnUrl)
        {
            self.returnUrl = try decoderContainer.decode(String?.self, forKey: .returnUrl)
        }
    }
}
public extension CreateInstanceSpec{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: CreateInstanceSpecCodingKeys.self)
         try encoderContainer.encode(id, forKey: .id)
         try encoderContainer.encode(name, forKey: .name)
         try encoderContainer.encode(buyType, forKey: .buyType)
         try encoderContainer.encode(carrier, forKey: .carrier)
         try encoderContainer.encode(ipType, forKey: .ipType)
         try encoderContainer.encode(bp, forKey: .bp)
         try encoderContainer.encode(ep, forKey: .ep)
         try encoderContainer.encode(bw, forKey: .bw)
         try encoderContainer.encode(timeSpan, forKey: .timeSpan)
         try encoderContainer.encode(timeUnit, forKey: .timeUnit)
         try encoderContainer.encode(returnUrl, forKey: .returnUrl)
    }
}
///  protectionStatistics
public class ProtectionStatistics:NSObject,Codable{
    /// 实例数量
    var instancesCount:Int?
    /// 已防护实例数量
    var protectedCount:Int?
    /// 已防护天数
    var protectedDay:Int?



    public override init(){
            super.init()
    }

    enum ProtectionStatisticsCodingKeys: String, CodingKey {
        case instancesCount
        case protectedCount
        case protectedDay
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: ProtectionStatisticsCodingKeys.self)
        if decoderContainer.contains(.instancesCount)
        {
            self.instancesCount = try decoderContainer.decode(Int?.self, forKey: .instancesCount)
        }
        if decoderContainer.contains(.protectedCount)
        {
            self.protectedCount = try decoderContainer.decode(Int?.self, forKey: .protectedCount)
        }
        if decoderContainer.contains(.protectedDay)
        {
            self.protectedDay = try decoderContainer.decode(Int?.self, forKey: .protectedDay)
        }
    }
}
public extension ProtectionStatistics{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: ProtectionStatisticsCodingKeys.self)
         try encoderContainer.encode(instancesCount, forKey: .instancesCount)
         try encoderContainer.encode(protectedCount, forKey: .protectedCount)
         try encoderContainer.encode(protectedDay, forKey: .protectedDay)
    }
}
///  alarmConfig
public class AlarmConfig:NSObject,Codable{
    /// 黑洞告警邮件开关 0 关闭 1 开启
    var blackHoleAlarmEmailStatus:Int?
    /// 黑洞告警短信开关 0 关闭 1 开启
    var blackHoleAlarmSmsStatus:Int?
    /// 黑洞告警总开关  0 关闭 1 开启
    var blackHoleAlarmStatus:Int?
    /// DDos 攻击告警邮件开关  0 关闭 1 开启
    var ddosAlarmEmailStatus:Int?
    /// DDos 攻击告警短信开关  0 关闭 1 开启
    var ddosAlarmSmsStatus:Int?
    /// DDos 告警总开关 0 关闭 1 开启
    var ddosAlarmStatus:Int?
    /// 错误码告警总开关
    var errorCodeAlarmStatus:Int?
    /// 错误码告警域名列表
    var errorCodeDomain:[String?]?



    public override init(){
            super.init()
    }

    enum AlarmConfigCodingKeys: String, CodingKey {
        case blackHoleAlarmEmailStatus
        case blackHoleAlarmSmsStatus
        case blackHoleAlarmStatus
        case ddosAlarmEmailStatus
        case ddosAlarmSmsStatus
        case ddosAlarmStatus
        case errorCodeAlarmStatus
        case errorCodeDomain
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: AlarmConfigCodingKeys.self)
        if decoderContainer.contains(.blackHoleAlarmEmailStatus)
        {
            self.blackHoleAlarmEmailStatus = try decoderContainer.decode(Int?.self, forKey: .blackHoleAlarmEmailStatus)
        }
        if decoderContainer.contains(.blackHoleAlarmSmsStatus)
        {
            self.blackHoleAlarmSmsStatus = try decoderContainer.decode(Int?.self, forKey: .blackHoleAlarmSmsStatus)
        }
        if decoderContainer.contains(.blackHoleAlarmStatus)
        {
            self.blackHoleAlarmStatus = try decoderContainer.decode(Int?.self, forKey: .blackHoleAlarmStatus)
        }
        if decoderContainer.contains(.ddosAlarmEmailStatus)
        {
            self.ddosAlarmEmailStatus = try decoderContainer.decode(Int?.self, forKey: .ddosAlarmEmailStatus)
        }
        if decoderContainer.contains(.ddosAlarmSmsStatus)
        {
            self.ddosAlarmSmsStatus = try decoderContainer.decode(Int?.self, forKey: .ddosAlarmSmsStatus)
        }
        if decoderContainer.contains(.ddosAlarmStatus)
        {
            self.ddosAlarmStatus = try decoderContainer.decode(Int?.self, forKey: .ddosAlarmStatus)
        }
        if decoderContainer.contains(.errorCodeAlarmStatus)
        {
            self.errorCodeAlarmStatus = try decoderContainer.decode(Int?.self, forKey: .errorCodeAlarmStatus)
        }
        if decoderContainer.contains(.errorCodeDomain)
        {
            self.errorCodeDomain = try decoderContainer.decode([String?]?.self, forKey: .errorCodeDomain)
        }
    }
}
public extension AlarmConfig{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: AlarmConfigCodingKeys.self)
         try encoderContainer.encode(blackHoleAlarmEmailStatus, forKey: .blackHoleAlarmEmailStatus)
         try encoderContainer.encode(blackHoleAlarmSmsStatus, forKey: .blackHoleAlarmSmsStatus)
         try encoderContainer.encode(blackHoleAlarmStatus, forKey: .blackHoleAlarmStatus)
         try encoderContainer.encode(ddosAlarmEmailStatus, forKey: .ddosAlarmEmailStatus)
         try encoderContainer.encode(ddosAlarmSmsStatus, forKey: .ddosAlarmSmsStatus)
         try encoderContainer.encode(ddosAlarmStatus, forKey: .ddosAlarmStatus)
         try encoderContainer.encode(errorCodeAlarmStatus, forKey: .errorCodeAlarmStatus)
         try encoderContainer.encode(errorCodeDomain, forKey: .errorCodeDomain)
    }
}
///  instanceIdName
public class InstanceIdName:NSObject,Codable{
    /// 实例id
    var id:String?
    /// 实例名称
    var name:String?



    public override init(){
            super.init()
    }

    enum InstanceIdNameCodingKeys: String, CodingKey {
        case id
        case name
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: InstanceIdNameCodingKeys.self)
        if decoderContainer.contains(.id)
        {
            self.id = try decoderContainer.decode(String?.self, forKey: .id)
        }
        if decoderContainer.contains(.name)
        {
            self.name = try decoderContainer.decode(String?.self, forKey: .name)
        }
    }
}
public extension InstanceIdName{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: InstanceIdNameCodingKeys.self)
         try encoderContainer.encode(id, forKey: .id)
         try encoderContainer.encode(name, forKey: .name)
    }
}
///  modifyInstanceEPBSpec
public class ModifyInstanceEPBSpec:NSObject,Codable{
    /// 弹性带宽: 单位 Gbps
    /// Required:true
    var ep:Int



    public  init(ep:Int){
             self.ep = ep
    }

    enum ModifyInstanceEPBSpecCodingKeys: String, CodingKey {
        case ep
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: ModifyInstanceEPBSpecCodingKeys.self)
        self.ep = try decoderContainer.decode(Int.self, forKey: .ep)
    }
}
public extension ModifyInstanceEPBSpec{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: ModifyInstanceEPBSpecCodingKeys.self)
         try encoderContainer.encode(ep, forKey: .ep)
    }
}
///  renameInstanceSpec
public class RenameInstanceSpec:NSObject,Codable{
    /// 实例名称
    /// Required:true
    var name:String



    public  init(name:String){
             self.name = name
    }

    enum RenameInstanceSpecCodingKeys: String, CodingKey {
        case name
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: RenameInstanceSpecCodingKeys.self)
        self.name = try decoderContainer.decode(String.self, forKey: .name)
    }
}
public extension RenameInstanceSpec{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: RenameInstanceSpecCodingKeys.self)
         try encoderContainer.encode(name, forKey: .name)
    }
}
///  cpsIpResource
public class CpsIpResource:NSObject,Codable{
    /// 云物理服务器公网 IP 地址
    var ip:String?
    /// 公网 IP 类型或绑定资源类型:
      ///   0: 未知类型
      ///   1: 弹性公网 IP(IP 为弹性公网 IP, 绑定资源类型未知)
      ///   10: 弹性公网 IP(IP 为弹性公网 IP, 但未绑定资源)
      ///   11: 弹性公网 IP, 绑定了云主机
      ///   12: 弹性公网 IP, 绑定了负载均衡
      ///   13: 弹性公网 IP, 绑定了原生容器实例
      ///   14: 弹性公网 IP, 绑定了原生容器 Pod
      ///   2: 云物理服务器公网 IP
    var resourceType:Int?



    public override init(){
            super.init()
    }

    enum CpsIpResourceCodingKeys: String, CodingKey {
        case ip
        case resourceType
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: CpsIpResourceCodingKeys.self)
        if decoderContainer.contains(.ip)
        {
            self.ip = try decoderContainer.decode(String?.self, forKey: .ip)
        }
        if decoderContainer.contains(.resourceType)
        {
            self.resourceType = try decoderContainer.decode(Int?.self, forKey: .resourceType)
        }
    }
}
public extension CpsIpResource{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: CpsIpResourceCodingKeys.self)
         try encoderContainer.encode(ip, forKey: .ip)
         try encoderContainer.encode(resourceType, forKey: .resourceType)
    }
}
///  alarmConfigSpec
public class AlarmConfigSpec:NSObject,Codable{
    /// 黑洞告警邮件开关 0 关闭 1 开启
    var blackHoleAlarmEmailStatus:Int?
    /// 黑洞告警短信开关 0 关闭 1 开启
    var blackHoleAlarmSmsStatus:Int?
    /// 黑洞告警总开关  0 关闭 1 开启
    var blackHoleAlarmStatus:Int?
    /// DDos 攻击告警邮件开关  0 关闭 1 开启
    var ddosAlarmEmailStatus:Int?
    /// DDos 攻击告警短信开关  0 关闭 1 开启
    var ddosAlarmSmsStatus:Int?
    /// DDos 告警总开关 0 关闭 1 开启
    var ddosAlarmStatus:Int?
    /// 错误码告警总开关
    var errorCodeAlarmStatus:Int?
    /// 错误码告警域名列表
    var errorCodeDomain:[String?]?



    public override init(){
            super.init()
    }

    enum AlarmConfigSpecCodingKeys: String, CodingKey {
        case blackHoleAlarmEmailStatus
        case blackHoleAlarmSmsStatus
        case blackHoleAlarmStatus
        case ddosAlarmEmailStatus
        case ddosAlarmSmsStatus
        case ddosAlarmStatus
        case errorCodeAlarmStatus
        case errorCodeDomain
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: AlarmConfigSpecCodingKeys.self)
        if decoderContainer.contains(.blackHoleAlarmEmailStatus)
        {
            self.blackHoleAlarmEmailStatus = try decoderContainer.decode(Int?.self, forKey: .blackHoleAlarmEmailStatus)
        }
        if decoderContainer.contains(.blackHoleAlarmSmsStatus)
        {
            self.blackHoleAlarmSmsStatus = try decoderContainer.decode(Int?.self, forKey: .blackHoleAlarmSmsStatus)
        }
        if decoderContainer.contains(.blackHoleAlarmStatus)
        {
            self.blackHoleAlarmStatus = try decoderContainer.decode(Int?.self, forKey: .blackHoleAlarmStatus)
        }
        if decoderContainer.contains(.ddosAlarmEmailStatus)
        {
            self.ddosAlarmEmailStatus = try decoderContainer.decode(Int?.self, forKey: .ddosAlarmEmailStatus)
        }
        if decoderContainer.contains(.ddosAlarmSmsStatus)
        {
            self.ddosAlarmSmsStatus = try decoderContainer.decode(Int?.self, forKey: .ddosAlarmSmsStatus)
        }
        if decoderContainer.contains(.ddosAlarmStatus)
        {
            self.ddosAlarmStatus = try decoderContainer.decode(Int?.self, forKey: .ddosAlarmStatus)
        }
        if decoderContainer.contains(.errorCodeAlarmStatus)
        {
            self.errorCodeAlarmStatus = try decoderContainer.decode(Int?.self, forKey: .errorCodeAlarmStatus)
        }
        if decoderContainer.contains(.errorCodeDomain)
        {
            self.errorCodeDomain = try decoderContainer.decode([String?]?.self, forKey: .errorCodeDomain)
        }
    }
}
public extension AlarmConfigSpec{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: AlarmConfigSpecCodingKeys.self)
         try encoderContainer.encode(blackHoleAlarmEmailStatus, forKey: .blackHoleAlarmEmailStatus)
         try encoderContainer.encode(blackHoleAlarmSmsStatus, forKey: .blackHoleAlarmSmsStatus)
         try encoderContainer.encode(blackHoleAlarmStatus, forKey: .blackHoleAlarmStatus)
         try encoderContainer.encode(ddosAlarmEmailStatus, forKey: .ddosAlarmEmailStatus)
         try encoderContainer.encode(ddosAlarmSmsStatus, forKey: .ddosAlarmSmsStatus)
         try encoderContainer.encode(ddosAlarmStatus, forKey: .ddosAlarmStatus)
         try encoderContainer.encode(errorCodeAlarmStatus, forKey: .errorCodeAlarmStatus)
         try encoderContainer.encode(errorCodeDomain, forKey: .errorCodeDomain)
    }
}
///  protectionOutline
public class ProtectionOutline:NSObject,Codable{
    /// 实例数量
    var instancesCount:Int?
    /// 已防护实例数量
    var protectedCount:Int?
    /// 已防护天数
    var protectedDay:Int?
    /// 7 日攻击次数
    var weekAttackCount:Int?
    /// 7 日攻击流量峰值
    var weekAttackPeak:Double?
    /// 7 日攻击流量单位
    var weekAttackUnit:String?
    /// 30 日攻击次数
    var monthAttackCount:Int?
    /// 30 日攻击流量峰值
    var monthAttackPeak:Double?
    /// 30 日攻击流量单位
    var monthAttackUnit:String?



    public override init(){
            super.init()
    }

    enum ProtectionOutlineCodingKeys: String, CodingKey {
        case instancesCount
        case protectedCount
        case protectedDay
        case weekAttackCount
        case weekAttackPeak
        case weekAttackUnit
        case monthAttackCount
        case monthAttackPeak
        case monthAttackUnit
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: ProtectionOutlineCodingKeys.self)
        if decoderContainer.contains(.instancesCount)
        {
            self.instancesCount = try decoderContainer.decode(Int?.self, forKey: .instancesCount)
        }
        if decoderContainer.contains(.protectedCount)
        {
            self.protectedCount = try decoderContainer.decode(Int?.self, forKey: .protectedCount)
        }
        if decoderContainer.contains(.protectedDay)
        {
            self.protectedDay = try decoderContainer.decode(Int?.self, forKey: .protectedDay)
        }
        if decoderContainer.contains(.weekAttackCount)
        {
            self.weekAttackCount = try decoderContainer.decode(Int?.self, forKey: .weekAttackCount)
        }
        if decoderContainer.contains(.weekAttackPeak)
        {
            self.weekAttackPeak = try decoderContainer.decode(Double?.self, forKey: .weekAttackPeak)
        }
        if decoderContainer.contains(.weekAttackUnit)
        {
            self.weekAttackUnit = try decoderContainer.decode(String?.self, forKey: .weekAttackUnit)
        }
        if decoderContainer.contains(.monthAttackCount)
        {
            self.monthAttackCount = try decoderContainer.decode(Int?.self, forKey: .monthAttackCount)
        }
        if decoderContainer.contains(.monthAttackPeak)
        {
            self.monthAttackPeak = try decoderContainer.decode(Double?.self, forKey: .monthAttackPeak)
        }
        if decoderContainer.contains(.monthAttackUnit)
        {
            self.monthAttackUnit = try decoderContainer.decode(String?.self, forKey: .monthAttackUnit)
        }
    }
}
public extension ProtectionOutline{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: ProtectionOutlineCodingKeys.self)
         try encoderContainer.encode(instancesCount, forKey: .instancesCount)
         try encoderContainer.encode(protectedCount, forKey: .protectedCount)
         try encoderContainer.encode(protectedDay, forKey: .protectedDay)
         try encoderContainer.encode(weekAttackCount, forKey: .weekAttackCount)
         try encoderContainer.encode(weekAttackPeak, forKey: .weekAttackPeak)
         try encoderContainer.encode(weekAttackUnit, forKey: .weekAttackUnit)
         try encoderContainer.encode(monthAttackCount, forKey: .monthAttackCount)
         try encoderContainer.encode(monthAttackPeak, forKey: .monthAttackPeak)
         try encoderContainer.encode(monthAttackUnit, forKey: .monthAttackUnit)
    }
}
///  vpcIpResource
public class VpcIpResource:NSObject,Codable{
    /// 云内 IP 地址
    var ip:String?
    /// 是否绑定
    var binded:Bool?
    /// 公网 IP 类型或绑定资源类型:
      ///   0: 未知类型
      ///   1: 弹性公网 IP(IP 为弹性公网 IP, 绑定资源类型未知)
      ///   10: 弹性公网 IP(IP 为弹性公网 IP, 但未绑定资源)
      ///   11: 弹性公网 IP, 绑定了云主机
      ///   12: 弹性公网 IP, 绑定了负载均衡
      ///   13: 弹性公网 IP, 绑定了原生容器实例
      ///   14: 弹性公网 IP, 绑定了原生容器 Pod
      ///   2: 云物理服务器公网 IP
    var resourceType:Int?



    public override init(){
            super.init()
    }

    enum VpcIpResourceCodingKeys: String, CodingKey {
        case ip
        case binded
        case resourceType
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: VpcIpResourceCodingKeys.self)
        if decoderContainer.contains(.ip)
        {
            self.ip = try decoderContainer.decode(String?.self, forKey: .ip)
        }
        if decoderContainer.contains(.binded)
        {
            self.binded = try decoderContainer.decode(Bool?.self, forKey: .binded)
        }
        if decoderContainer.contains(.resourceType)
        {
            self.resourceType = try decoderContainer.decode(Int?.self, forKey: .resourceType)
        }
    }
}
public extension VpcIpResource{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: VpcIpResourceCodingKeys.self)
         try encoderContainer.encode(ip, forKey: .ip)
         try encoderContainer.encode(binded, forKey: .binded)
         try encoderContainer.encode(resourceType, forKey: .resourceType)
    }
}
///  instance
public class Instance:NSObject,Codable{
    /// 实例 ID
    var id:String?
    /// 实例名称
    var name:String?
    /// 链路类型, 1: 电信, 2: 电信、联通, 3: 电信、联通和移动
    var carrier:Int?
    /// 可防护 IP 类型, 目前仅电信线路支持 IPV6 线路:
      /// - 0: IPV4,
      /// - 1: IPV4/IPV6
      /// 
    var ipType:Int?
    /// 触发弹性带宽的次数
    var elasticTriggerCount:Int?
    /// 超峰次数
    var abovePeakCount:Int?
    /// 保底带宽
    var inBitslimit:Int?
    /// 弹性带宽
    var resilientBitslimit:Int?
    /// 业务带宽大小
    var businessBitslimit:Int?
    /// CC 阈值大小
    var ccThreshold:Int?
    /// CC 防护峰值, 单位: QPS
    var ccPeakQPS:Int?
    /// 非网站类规则数
    var ruleCount:Int?
    /// 网站类规则数
    var webRuleCount:Int?
    /// PAID|ARREARS|EXPIRED
    var chargeStatus:String?
    /// SAFE|CLEANING|BLOCKING
    var securityStatus:String?
    /// 实例的创建的时间
    var createTime:String?
    /// 实例的过期时间
    var expireTime:String?
    /// 资源 ID, 升级和续费时使用
    var resourceId:String?
    /// CC 防护观察者模式.
      /// - 0: 关闭
      /// - 1: 开启
      /// 
    var ccObserveMode:Int?
    /// CC 防护模式.
      /// - 0: 正常
      /// - 1: 紧急
      /// - 2: 宽松
      /// - 3: 自定义
      /// 
    var ccProtectMode:Int?
    /// CC 开关状态.
      /// - 0: 关闭
      /// - 1: 开启
      /// 
    var ccProtectStatus:Int?
    /// CC 防护模式为自定义时的限速大小
    var ccSpeedLimit:Int?
    /// CC 防护模式为自定义时的限速周期
    var ccSpeedPeriod:Int?
    /// IP 黑名单列表
    var ipBlackList:[String?]?
    /// IP 黑名单状态.
      /// - 0: 关闭
      /// - 1: 开启
      /// 
    var ipBlackStatus:Int?
    /// IP 白名单列表
    var ipWhiteList:[String?]?
    /// IP 白名单状态.
      /// - 0: 关闭
      /// - 1: 开启
      /// 
    var ipWhiteStatus:Int?
    /// url白名单列表
    var urlWhitelist:[String?]?
    /// url白名单状态，0关闭，1开启
    var urlWhitelistStatus:Int?
    /// ccProtectMode为自定义模式时，每个Host的防护阈值
    var hostQps:Int?
    /// ccProtectMode为自定义模式时，每个Host+URI的防护阈值
    var hostUrlQps:Int?
    /// ccProtectMode为自定义模式时，每个源IP对Host的防护阈值
    var ipHostQps:Int?
    /// ccProtectMode为自定义模式时，每个源IP对Host+URI的防护阈值
    var ipHostUrlQps:Int?



    public override init(){
            super.init()
    }

    enum InstanceCodingKeys: String, CodingKey {
        case id
        case name
        case carrier
        case ipType
        case elasticTriggerCount
        case abovePeakCount
        case inBitslimit
        case resilientBitslimit
        case businessBitslimit
        case ccThreshold
        case ccPeakQPS
        case ruleCount
        case webRuleCount
        case chargeStatus
        case securityStatus
        case createTime
        case expireTime
        case resourceId
        case ccObserveMode
        case ccProtectMode
        case ccProtectStatus
        case ccSpeedLimit
        case ccSpeedPeriod
        case ipBlackList
        case ipBlackStatus
        case ipWhiteList
        case ipWhiteStatus
        case urlWhitelist
        case urlWhitelistStatus
        case hostQps
        case hostUrlQps
        case ipHostQps
        case ipHostUrlQps
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: InstanceCodingKeys.self)
        if decoderContainer.contains(.id)
        {
            self.id = try decoderContainer.decode(String?.self, forKey: .id)
        }
        if decoderContainer.contains(.name)
        {
            self.name = try decoderContainer.decode(String?.self, forKey: .name)
        }
        if decoderContainer.contains(.carrier)
        {
            self.carrier = try decoderContainer.decode(Int?.self, forKey: .carrier)
        }
        if decoderContainer.contains(.ipType)
        {
            self.ipType = try decoderContainer.decode(Int?.self, forKey: .ipType)
        }
        if decoderContainer.contains(.elasticTriggerCount)
        {
            self.elasticTriggerCount = try decoderContainer.decode(Int?.self, forKey: .elasticTriggerCount)
        }
        if decoderContainer.contains(.abovePeakCount)
        {
            self.abovePeakCount = try decoderContainer.decode(Int?.self, forKey: .abovePeakCount)
        }
        if decoderContainer.contains(.inBitslimit)
        {
            self.inBitslimit = try decoderContainer.decode(Int?.self, forKey: .inBitslimit)
        }
        if decoderContainer.contains(.resilientBitslimit)
        {
            self.resilientBitslimit = try decoderContainer.decode(Int?.self, forKey: .resilientBitslimit)
        }
        if decoderContainer.contains(.businessBitslimit)
        {
            self.businessBitslimit = try decoderContainer.decode(Int?.self, forKey: .businessBitslimit)
        }
        if decoderContainer.contains(.ccThreshold)
        {
            self.ccThreshold = try decoderContainer.decode(Int?.self, forKey: .ccThreshold)
        }
        if decoderContainer.contains(.ccPeakQPS)
        {
            self.ccPeakQPS = try decoderContainer.decode(Int?.self, forKey: .ccPeakQPS)
        }
        if decoderContainer.contains(.ruleCount)
        {
            self.ruleCount = try decoderContainer.decode(Int?.self, forKey: .ruleCount)
        }
        if decoderContainer.contains(.webRuleCount)
        {
            self.webRuleCount = try decoderContainer.decode(Int?.self, forKey: .webRuleCount)
        }
        if decoderContainer.contains(.chargeStatus)
        {
            self.chargeStatus = try decoderContainer.decode(String?.self, forKey: .chargeStatus)
        }
        if decoderContainer.contains(.securityStatus)
        {
            self.securityStatus = try decoderContainer.decode(String?.self, forKey: .securityStatus)
        }
        if decoderContainer.contains(.createTime)
        {
            self.createTime = try decoderContainer.decode(String?.self, forKey: .createTime)
        }
        if decoderContainer.contains(.expireTime)
        {
            self.expireTime = try decoderContainer.decode(String?.self, forKey: .expireTime)
        }
        if decoderContainer.contains(.resourceId)
        {
            self.resourceId = try decoderContainer.decode(String?.self, forKey: .resourceId)
        }
        if decoderContainer.contains(.ccObserveMode)
        {
            self.ccObserveMode = try decoderContainer.decode(Int?.self, forKey: .ccObserveMode)
        }
        if decoderContainer.contains(.ccProtectMode)
        {
            self.ccProtectMode = try decoderContainer.decode(Int?.self, forKey: .ccProtectMode)
        }
        if decoderContainer.contains(.ccProtectStatus)
        {
            self.ccProtectStatus = try decoderContainer.decode(Int?.self, forKey: .ccProtectStatus)
        }
        if decoderContainer.contains(.ccSpeedLimit)
        {
            self.ccSpeedLimit = try decoderContainer.decode(Int?.self, forKey: .ccSpeedLimit)
        }
        if decoderContainer.contains(.ccSpeedPeriod)
        {
            self.ccSpeedPeriod = try decoderContainer.decode(Int?.self, forKey: .ccSpeedPeriod)
        }
        if decoderContainer.contains(.ipBlackList)
        {
            self.ipBlackList = try decoderContainer.decode([String?]?.self, forKey: .ipBlackList)
        }
        if decoderContainer.contains(.ipBlackStatus)
        {
            self.ipBlackStatus = try decoderContainer.decode(Int?.self, forKey: .ipBlackStatus)
        }
        if decoderContainer.contains(.ipWhiteList)
        {
            self.ipWhiteList = try decoderContainer.decode([String?]?.self, forKey: .ipWhiteList)
        }
        if decoderContainer.contains(.ipWhiteStatus)
        {
            self.ipWhiteStatus = try decoderContainer.decode(Int?.self, forKey: .ipWhiteStatus)
        }
        if decoderContainer.contains(.urlWhitelist)
        {
            self.urlWhitelist = try decoderContainer.decode([String?]?.self, forKey: .urlWhitelist)
        }
        if decoderContainer.contains(.urlWhitelistStatus)
        {
            self.urlWhitelistStatus = try decoderContainer.decode(Int?.self, forKey: .urlWhitelistStatus)
        }
        if decoderContainer.contains(.hostQps)
        {
            self.hostQps = try decoderContainer.decode(Int?.self, forKey: .hostQps)
        }
        if decoderContainer.contains(.hostUrlQps)
        {
            self.hostUrlQps = try decoderContainer.decode(Int?.self, forKey: .hostUrlQps)
        }
        if decoderContainer.contains(.ipHostQps)
        {
            self.ipHostQps = try decoderContainer.decode(Int?.self, forKey: .ipHostQps)
        }
        if decoderContainer.contains(.ipHostUrlQps)
        {
            self.ipHostUrlQps = try decoderContainer.decode(Int?.self, forKey: .ipHostUrlQps)
        }
    }
}
public extension Instance{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: InstanceCodingKeys.self)
         try encoderContainer.encode(id, forKey: .id)
         try encoderContainer.encode(name, forKey: .name)
         try encoderContainer.encode(carrier, forKey: .carrier)
         try encoderContainer.encode(ipType, forKey: .ipType)
         try encoderContainer.encode(elasticTriggerCount, forKey: .elasticTriggerCount)
         try encoderContainer.encode(abovePeakCount, forKey: .abovePeakCount)
         try encoderContainer.encode(inBitslimit, forKey: .inBitslimit)
         try encoderContainer.encode(resilientBitslimit, forKey: .resilientBitslimit)
         try encoderContainer.encode(businessBitslimit, forKey: .businessBitslimit)
         try encoderContainer.encode(ccThreshold, forKey: .ccThreshold)
         try encoderContainer.encode(ccPeakQPS, forKey: .ccPeakQPS)
         try encoderContainer.encode(ruleCount, forKey: .ruleCount)
         try encoderContainer.encode(webRuleCount, forKey: .webRuleCount)
         try encoderContainer.encode(chargeStatus, forKey: .chargeStatus)
         try encoderContainer.encode(securityStatus, forKey: .securityStatus)
         try encoderContainer.encode(createTime, forKey: .createTime)
         try encoderContainer.encode(expireTime, forKey: .expireTime)
         try encoderContainer.encode(resourceId, forKey: .resourceId)
         try encoderContainer.encode(ccObserveMode, forKey: .ccObserveMode)
         try encoderContainer.encode(ccProtectMode, forKey: .ccProtectMode)
         try encoderContainer.encode(ccProtectStatus, forKey: .ccProtectStatus)
         try encoderContainer.encode(ccSpeedLimit, forKey: .ccSpeedLimit)
         try encoderContainer.encode(ccSpeedPeriod, forKey: .ccSpeedPeriod)
         try encoderContainer.encode(ipBlackList, forKey: .ipBlackList)
         try encoderContainer.encode(ipBlackStatus, forKey: .ipBlackStatus)
         try encoderContainer.encode(ipWhiteList, forKey: .ipWhiteList)
         try encoderContainer.encode(ipWhiteStatus, forKey: .ipWhiteStatus)
         try encoderContainer.encode(urlWhitelist, forKey: .urlWhitelist)
         try encoderContainer.encode(urlWhitelistStatus, forKey: .urlWhitelistStatus)
         try encoderContainer.encode(hostQps, forKey: .hostQps)
         try encoderContainer.encode(hostUrlQps, forKey: .hostUrlQps)
         try encoderContainer.encode(ipHostQps, forKey: .ipHostQps)
         try encoderContainer.encode(ipHostUrlQps, forKey: .ipHostUrlQps)
    }
}
///  ipSet
public class IpSet:NSObject,Codable{
    /// IP 黑白名单 Id
    var id:String?
    /// IP 黑白名单的名称
    var name:String?
    /// IP 或 IP 段的数组
    var ip:[String?]?



    public override init(){
            super.init()
    }

    enum IpSetCodingKeys: String, CodingKey {
        case id
        case name
        case ip
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: IpSetCodingKeys.self)
        if decoderContainer.contains(.id)
        {
            self.id = try decoderContainer.decode(String?.self, forKey: .id)
        }
        if decoderContainer.contains(.name)
        {
            self.name = try decoderContainer.decode(String?.self, forKey: .name)
        }
        if decoderContainer.contains(.ip)
        {
            self.ip = try decoderContainer.decode([String?]?.self, forKey: .ip)
        }
    }
}
public extension IpSet{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: IpSetCodingKeys.self)
         try encoderContainer.encode(id, forKey: .id)
         try encoderContainer.encode(name, forKey: .name)
         try encoderContainer.encode(ip, forKey: .ip)
    }
}
///  ipSetSpec
public class IpSetSpec:NSObject,Codable{
    /// IP 黑白名单名称
    /// Required:true
    var name:String
    /// IP 或 IP 段的数组
    /// Required:true
    var ip:[String?]?



    public  init(name:String,ip:[String?]?){
             self.name = name
             self.ip = ip
    }

    enum IpSetSpecCodingKeys: String, CodingKey {
        case name
        case ip
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: IpSetSpecCodingKeys.self)
        self.name = try decoderContainer.decode(String.self, forKey: .name)
        self.ip = try decoderContainer.decode([String?]?.self, forKey: .ip)
    }
}
public extension IpSetSpec{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: IpSetSpecCodingKeys.self)
         try encoderContainer.encode(name, forKey: .name)
         try encoderContainer.encode(ip, forKey: .ip)
    }
}
///  certInfoDescribeSpec
public class CertInfoDescribeSpec:NSObject,Codable{
    /// 域名
    var domain:String?
    /// 证书内容
    var httpsCertContent:String?



    public override init(){
            super.init()
    }

    enum CertInfoDescribeSpecCodingKeys: String, CodingKey {
        case domain
        case httpsCertContent
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: CertInfoDescribeSpecCodingKeys.self)
        if decoderContainer.contains(.domain)
        {
            self.domain = try decoderContainer.decode(String?.self, forKey: .domain)
        }
        if decoderContainer.contains(.httpsCertContent)
        {
            self.httpsCertContent = try decoderContainer.decode(String?.self, forKey: .httpsCertContent)
        }
    }
}
public extension CertInfoDescribeSpec{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: CertInfoDescribeSpecCodingKeys.self)
         try encoderContainer.encode(domain, forKey: .domain)
         try encoderContainer.encode(httpsCertContent, forKey: .httpsCertContent)
    }
}
///  ipBwListSpec
public class IpBwListSpec:NSObject,Codable{
    /// IP 或 IP 段列表
    /// Required:true
    var ipList:[String?]?
    /// false 时强制写入, true 时有重复则不写入
    /// Required:true
    var tryFlag:Bool



    public  init(ipList:[String?]?,tryFlag:Bool){
             self.ipList = ipList
             self.tryFlag = tryFlag
    }

    enum IpBwListSpecCodingKeys: String, CodingKey {
        case ipList
        case tryFlag
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: IpBwListSpecCodingKeys.self)
        self.ipList = try decoderContainer.decode([String?]?.self, forKey: .ipList)
        self.tryFlag = try decoderContainer.decode(Bool.self, forKey: .tryFlag)
    }
}
public extension IpBwListSpec{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: IpBwListSpecCodingKeys.self)
         try encoderContainer.encode(ipList, forKey: .ipList)
         try encoderContainer.encode(tryFlag, forKey: .tryFlag)
    }
}
///  priceSpec
public class PriceSpec:NSObject,Codable{
    /// 操作类型 1: 新购高防实例, 3: 升级高防实例
    /// Required:true
    var buyType:Int
    /// 计费类型 1: 按配置 2: 按用量 3: 包年包月
    /// Required:true
    var billingType:Int
    /// 链路类型, 1: 电信, 2: 电信、联通, 3: 电信、联通和移动
    /// Required:true
    var carrier:Int
    /// 业务带宽: 100, 150, 200, 250, ..., 2000, 单位: M
    /// Required:true
    var bw:Int
    /// 保底带宽: 0, 10, 20, 30, 40, 50, 60, 80, 100, 单位: Gbps
    /// Required:true
    var bp:Int
    /// 弹性带宽: 0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 120, 150, 200, 单位: Gbps
    /// Required:true
    var ep:Int
    /// 实例 Id, 升级高防实例查询价格时必传
    var id:String?
    /// 购买防护包时长, 新购高防实例时必传
      /// - timeUnit 为 3 时, 可取值 1-9
      /// - timeUnit 为 4 时, 可取值 1-3
      /// 
    var timeSpan:Int?
    /// 购买时长类型, 新购高防实例时必传
      /// - 3: 月
      /// - 4: 年
    var timeUnit:Int?



    public  init(buyType:Int,billingType:Int,carrier:Int,bw:Int,bp:Int,ep:Int){
             self.buyType = buyType
             self.billingType = billingType
             self.carrier = carrier
             self.bw = bw
             self.bp = bp
             self.ep = ep
    }

    enum PriceSpecCodingKeys: String, CodingKey {
        case buyType
        case billingType
        case carrier
        case bw
        case bp
        case ep
        case id
        case timeSpan
        case timeUnit
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: PriceSpecCodingKeys.self)
        self.buyType = try decoderContainer.decode(Int.self, forKey: .buyType)
        self.billingType = try decoderContainer.decode(Int.self, forKey: .billingType)
        self.carrier = try decoderContainer.decode(Int.self, forKey: .carrier)
        self.bw = try decoderContainer.decode(Int.self, forKey: .bw)
        self.bp = try decoderContainer.decode(Int.self, forKey: .bp)
        self.ep = try decoderContainer.decode(Int.self, forKey: .ep)
        if decoderContainer.contains(.id)
        {
            self.id = try decoderContainer.decode(String?.self, forKey: .id)
        }
        if decoderContainer.contains(.timeSpan)
        {
            self.timeSpan = try decoderContainer.decode(Int?.self, forKey: .timeSpan)
        }
        if decoderContainer.contains(.timeUnit)
        {
            self.timeUnit = try decoderContainer.decode(Int?.self, forKey: .timeUnit)
        }
    }
}
public extension PriceSpec{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: PriceSpecCodingKeys.self)
         try encoderContainer.encode(buyType, forKey: .buyType)
         try encoderContainer.encode(billingType, forKey: .billingType)
         try encoderContainer.encode(carrier, forKey: .carrier)
         try encoderContainer.encode(bw, forKey: .bw)
         try encoderContainer.encode(bp, forKey: .bp)
         try encoderContainer.encode(ep, forKey: .ep)
         try encoderContainer.encode(id, forKey: .id)
         try encoderContainer.encode(timeSpan, forKey: .timeSpan)
         try encoderContainer.encode(timeUnit, forKey: .timeUnit)
    }
}
///  bwRepeatMsg
public class BwRepeatMsg:NSObject,Codable{
    /// 黑名单重复 IP/IP段
    var black:String?
    /// 白名单重复 IP/IP段
    var white:String?



    public override init(){
            super.init()
    }

    enum BwRepeatMsgCodingKeys: String, CodingKey {
        case black
        case white
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: BwRepeatMsgCodingKeys.self)
        if decoderContainer.contains(.black)
        {
            self.black = try decoderContainer.decode(String?.self, forKey: .black)
        }
        if decoderContainer.contains(.white)
        {
            self.white = try decoderContainer.decode(String?.self, forKey: .white)
        }
    }
}
public extension BwRepeatMsg{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: BwRepeatMsgCodingKeys.self)
         try encoderContainer.encode(black, forKey: .black)
         try encoderContainer.encode(white, forKey: .white)
    }
}
///  certInfo
public class CertInfo:NSObject,Codable{
    /// 通用名称
    var domain:String?
    /// 证书生效时间
    var from:String?
    /// 证书到期时间
    var to:String?
    /// 证书组织
    var user:String?
    /// 加密算法
    var sigAlgName:String?
    /// 颁发者
    var issuer:String?



    public override init(){
            super.init()
    }

    enum CertInfoCodingKeys: String, CodingKey {
        case domain
        case from
        case to
        case user
        case sigAlgName
        case issuer
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: CertInfoCodingKeys.self)
        if decoderContainer.contains(.domain)
        {
            self.domain = try decoderContainer.decode(String?.self, forKey: .domain)
        }
        if decoderContainer.contains(.from)
        {
            self.from = try decoderContainer.decode(String?.self, forKey: .from)
        }
        if decoderContainer.contains(.to)
        {
            self.to = try decoderContainer.decode(String?.self, forKey: .to)
        }
        if decoderContainer.contains(.user)
        {
            self.user = try decoderContainer.decode(String?.self, forKey: .user)
        }
        if decoderContainer.contains(.sigAlgName)
        {
            self.sigAlgName = try decoderContainer.decode(String?.self, forKey: .sigAlgName)
        }
        if decoderContainer.contains(.issuer)
        {
            self.issuer = try decoderContainer.decode(String?.self, forKey: .issuer)
        }
    }
}
public extension CertInfo{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: CertInfoCodingKeys.self)
         try encoderContainer.encode(domain, forKey: .domain)
         try encoderContainer.encode(from, forKey: .from)
         try encoderContainer.encode(to, forKey: .to)
         try encoderContainer.encode(user, forKey: .user)
         try encoderContainer.encode(sigAlgName, forKey: .sigAlgName)
         try encoderContainer.encode(issuer, forKey: .issuer)
    }
}
///  ePBSpec
public class EPBSpec:NSObject,Codable{
    /// 弹性防护带宽
    var ePB:Int?



    public override init(){
            super.init()
    }

    enum EPBSpecCodingKeys: String, CodingKey {
        case ePB
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: EPBSpecCodingKeys.self)
        if decoderContainer.contains(.ePB)
        {
            self.ePB = try decoderContainer.decode(Int?.self, forKey: .ePB)
        }
    }
}
public extension EPBSpec{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: EPBSpecCodingKeys.self)
         try encoderContainer.encode(ePB, forKey: .ePB)
    }
}
///  status
public class Status:NSObject,Codable{
    /// 请求结果, 0 表示成功, 非 0 表示失败
    var retcode:Int?
    /// 请求错误码
    var code:Int?
    /// 请求错误消息
    var msg:String?



    public override init(){
            super.init()
    }

    enum StatusCodingKeys: String, CodingKey {
        case retcode
        case code
        case msg
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: StatusCodingKeys.self)
        if decoderContainer.contains(.retcode)
        {
            self.retcode = try decoderContainer.decode(Int?.self, forKey: .retcode)
        }
        if decoderContainer.contains(.code)
        {
            self.code = try decoderContainer.decode(Int?.self, forKey: .code)
        }
        if decoderContainer.contains(.msg)
        {
            self.msg = try decoderContainer.decode(String?.self, forKey: .msg)
        }
    }
}
public extension Status{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: StatusCodingKeys.self)
         try encoderContainer.encode(retcode, forKey: .retcode)
         try encoderContainer.encode(code, forKey: .code)
         try encoderContainer.encode(msg, forKey: .msg)
    }
}
///  cCDefaultThresholds
public class CCDefaultThresholds:NSObject,Codable{
    /// 每个 Host 的防护阈值
    var hostQps:Int?
    /// 每个 Host + URL 的防护阈值
    var hostUrlQps:Int?
    /// 每个源 IP 对 Host 的防护阈值
    var ipHostQps:Int?
    /// 每个源 IP 对 Host + URI 的防护阈值
    var ipHostUrlQps:Int?



    public override init(){
            super.init()
    }

    enum CCDefaultThresholdsCodingKeys: String, CodingKey {
        case hostQps
        case hostUrlQps
        case ipHostQps
        case ipHostUrlQps
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: CCDefaultThresholdsCodingKeys.self)
        if decoderContainer.contains(.hostQps)
        {
            self.hostQps = try decoderContainer.decode(Int?.self, forKey: .hostQps)
        }
        if decoderContainer.contains(.hostUrlQps)
        {
            self.hostUrlQps = try decoderContainer.decode(Int?.self, forKey: .hostUrlQps)
        }
        if decoderContainer.contains(.ipHostQps)
        {
            self.ipHostQps = try decoderContainer.decode(Int?.self, forKey: .ipHostQps)
        }
        if decoderContainer.contains(.ipHostUrlQps)
        {
            self.ipHostUrlQps = try decoderContainer.decode(Int?.self, forKey: .ipHostUrlQps)
        }
    }
}
public extension CCDefaultThresholds{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: CCDefaultThresholdsCodingKeys.self)
         try encoderContainer.encode(hostQps, forKey: .hostQps)
         try encoderContainer.encode(hostUrlQps, forKey: .hostUrlQps)
         try encoderContainer.encode(ipHostQps, forKey: .ipHostQps)
         try encoderContainer.encode(ipHostUrlQps, forKey: .ipHostUrlQps)
    }
}

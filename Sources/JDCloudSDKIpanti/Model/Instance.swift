/* Copyright 2018 JDCLOUD.COM

   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at

     http:#www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.

   
   

   
   Contact: 

   NOTE: This class is auto generated by the jdcloud code generator program.
 */


import Foundation

///  instance
@objc(Instance)
public class Instance:NSObject,Codable{
    /// 实例 Id
    var id:Int64?
    /// 实例名称
    var name:String?
    /// 链路类型, 1: 电信, 2: 电信、联通, 3: 电信、联通和移动
    var carrier:Int?
    /// 可防护 ip 类型, 目前仅电信线路支持 IPV6 线路:
      /// - 0: IPV4,
      /// - 1: IPV4/IPV6
      /// 
    var ipType:Int?
    /// 触发弹性带宽的次数
    var elasticTriggerCount:Int?
    /// 超峰次数
    var abovePeakCount:Int?
    /// 保底带宽
    var inBitslimit:Int?
    /// 弹性带宽
    var resilientBitslimit:Int?
    /// 业务带宽大小
    var businessBitslimit:Int?
    /// cc阈值大小
    var ccThreshold:Int?
    /// 非网站类规则数
    var ruleCount:Int?
    /// 网站类规则数
    var webRuleCount:Int?
    /// PAID|ARREARS|EXPIRED
    var chargeStatus:String?
    /// SAFE|CLEANING|BLOCKING
    var securityStatus:String?
    /// 实例的创建的时间
    var createTime:String?
    /// 实例的过期时间
    var expireTime:String?
    /// 资源id，升级和续费时使用
    var resourceId:String?
    /// cc防护模式，0正常、1紧急、2宽松、3自定义
    var ccProtectMode:Int?
    /// cc开关状态，0关闭，1开启
    var ccProtectStatus:Int?
    /// cc防护模式为自定义时的限速大小
    var ccSpeedLimit:Int?
    /// cc防护模式为自定义时的限速周期
    var ccSpeedPeriod:Int?
    /// ip黑名单列表
    var ipBlackList:[String?]?
    /// ip黑名单状态，0关闭，1开启
    var ipBlackStatus:Int?
    /// ip白名单列表
    var ipWhiteList:[String?]?
    /// ip白名单状态，0关闭，1开启
    var ipWhiteStatus:Int?
    /// url白名单列表
    var urlWhitelist:[String?]?
    /// url白名单状态，0关闭，1开启
    var urlWhitelistStatus:Int?
    /// ccProtectMode为自定义模式时，每个Host的防护阈值
    var hostQps:Int?
    /// ccProtectMode为自定义模式时，每个Host+URI的防护阈值
    var hostUrlQps:Int?
    /// ccProtectMode为自定义模式时，每个源IP对Host的防护阈值
    var ipHostQps:Int?
    /// ccProtectMode为自定义模式时，每个源IP对Host+URI的防护阈值
    var ipHostUrlQps:Int?



    public override init(){
            super.init()
    }

    enum InstanceCodingKeys: String, CodingKey {
        case id
        case name
        case carrier
        case ipType
        case elasticTriggerCount
        case abovePeakCount
        case inBitslimit
        case resilientBitslimit
        case businessBitslimit
        case ccThreshold
        case ruleCount
        case webRuleCount
        case chargeStatus
        case securityStatus
        case createTime
        case expireTime
        case resourceId
        case ccProtectMode
        case ccProtectStatus
        case ccSpeedLimit
        case ccSpeedPeriod
        case ipBlackList
        case ipBlackStatus
        case ipWhiteList
        case ipWhiteStatus
        case urlWhitelist
        case urlWhitelistStatus
        case hostQps
        case hostUrlQps
        case ipHostQps
        case ipHostUrlQps
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: InstanceCodingKeys.self)
        if decoderContainer.contains(.id)
        {
            self.id = try decoderContainer.decode(Int64?.self, forKey: .id)
        }
        if decoderContainer.contains(.name)
        {
            self.name = try decoderContainer.decode(String?.self, forKey: .name)
        }
        if decoderContainer.contains(.carrier)
        {
            self.carrier = try decoderContainer.decode(Int?.self, forKey: .carrier)
        }
        if decoderContainer.contains(.ipType)
        {
            self.ipType = try decoderContainer.decode(Int?.self, forKey: .ipType)
        }
        if decoderContainer.contains(.elasticTriggerCount)
        {
            self.elasticTriggerCount = try decoderContainer.decode(Int?.self, forKey: .elasticTriggerCount)
        }
        if decoderContainer.contains(.abovePeakCount)
        {
            self.abovePeakCount = try decoderContainer.decode(Int?.self, forKey: .abovePeakCount)
        }
        if decoderContainer.contains(.inBitslimit)
        {
            self.inBitslimit = try decoderContainer.decode(Int?.self, forKey: .inBitslimit)
        }
        if decoderContainer.contains(.resilientBitslimit)
        {
            self.resilientBitslimit = try decoderContainer.decode(Int?.self, forKey: .resilientBitslimit)
        }
        if decoderContainer.contains(.businessBitslimit)
        {
            self.businessBitslimit = try decoderContainer.decode(Int?.self, forKey: .businessBitslimit)
        }
        if decoderContainer.contains(.ccThreshold)
        {
            self.ccThreshold = try decoderContainer.decode(Int?.self, forKey: .ccThreshold)
        }
        if decoderContainer.contains(.ruleCount)
        {
            self.ruleCount = try decoderContainer.decode(Int?.self, forKey: .ruleCount)
        }
        if decoderContainer.contains(.webRuleCount)
        {
            self.webRuleCount = try decoderContainer.decode(Int?.self, forKey: .webRuleCount)
        }
        if decoderContainer.contains(.chargeStatus)
        {
            self.chargeStatus = try decoderContainer.decode(String?.self, forKey: .chargeStatus)
        }
        if decoderContainer.contains(.securityStatus)
        {
            self.securityStatus = try decoderContainer.decode(String?.self, forKey: .securityStatus)
        }
        if decoderContainer.contains(.createTime)
        {
            self.createTime = try decoderContainer.decode(String?.self, forKey: .createTime)
        }
        if decoderContainer.contains(.expireTime)
        {
            self.expireTime = try decoderContainer.decode(String?.self, forKey: .expireTime)
        }
        if decoderContainer.contains(.resourceId)
        {
            self.resourceId = try decoderContainer.decode(String?.self, forKey: .resourceId)
        }
        if decoderContainer.contains(.ccProtectMode)
        {
            self.ccProtectMode = try decoderContainer.decode(Int?.self, forKey: .ccProtectMode)
        }
        if decoderContainer.contains(.ccProtectStatus)
        {
            self.ccProtectStatus = try decoderContainer.decode(Int?.self, forKey: .ccProtectStatus)
        }
        if decoderContainer.contains(.ccSpeedLimit)
        {
            self.ccSpeedLimit = try decoderContainer.decode(Int?.self, forKey: .ccSpeedLimit)
        }
        if decoderContainer.contains(.ccSpeedPeriod)
        {
            self.ccSpeedPeriod = try decoderContainer.decode(Int?.self, forKey: .ccSpeedPeriod)
        }
        if decoderContainer.contains(.ipBlackList)
        {
            self.ipBlackList = try decoderContainer.decode([String?]?.self, forKey: .ipBlackList)
        }
        if decoderContainer.contains(.ipBlackStatus)
        {
            self.ipBlackStatus = try decoderContainer.decode(Int?.self, forKey: .ipBlackStatus)
        }
        if decoderContainer.contains(.ipWhiteList)
        {
            self.ipWhiteList = try decoderContainer.decode([String?]?.self, forKey: .ipWhiteList)
        }
        if decoderContainer.contains(.ipWhiteStatus)
        {
            self.ipWhiteStatus = try decoderContainer.decode(Int?.self, forKey: .ipWhiteStatus)
        }
        if decoderContainer.contains(.urlWhitelist)
        {
            self.urlWhitelist = try decoderContainer.decode([String?]?.self, forKey: .urlWhitelist)
        }
        if decoderContainer.contains(.urlWhitelistStatus)
        {
            self.urlWhitelistStatus = try decoderContainer.decode(Int?.self, forKey: .urlWhitelistStatus)
        }
        if decoderContainer.contains(.hostQps)
        {
            self.hostQps = try decoderContainer.decode(Int?.self, forKey: .hostQps)
        }
        if decoderContainer.contains(.hostUrlQps)
        {
            self.hostUrlQps = try decoderContainer.decode(Int?.self, forKey: .hostUrlQps)
        }
        if decoderContainer.contains(.ipHostQps)
        {
            self.ipHostQps = try decoderContainer.decode(Int?.self, forKey: .ipHostQps)
        }
        if decoderContainer.contains(.ipHostUrlQps)
        {
            self.ipHostUrlQps = try decoderContainer.decode(Int?.self, forKey: .ipHostUrlQps)
        }
    }
}
public extension Instance{
    public func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: InstanceCodingKeys.self)
         try encoderContainer.encode(id, forKey: .id)
         try encoderContainer.encode(name, forKey: .name)
         try encoderContainer.encode(carrier, forKey: .carrier)
         try encoderContainer.encode(ipType, forKey: .ipType)
         try encoderContainer.encode(elasticTriggerCount, forKey: .elasticTriggerCount)
         try encoderContainer.encode(abovePeakCount, forKey: .abovePeakCount)
         try encoderContainer.encode(inBitslimit, forKey: .inBitslimit)
         try encoderContainer.encode(resilientBitslimit, forKey: .resilientBitslimit)
         try encoderContainer.encode(businessBitslimit, forKey: .businessBitslimit)
         try encoderContainer.encode(ccThreshold, forKey: .ccThreshold)
         try encoderContainer.encode(ruleCount, forKey: .ruleCount)
         try encoderContainer.encode(webRuleCount, forKey: .webRuleCount)
         try encoderContainer.encode(chargeStatus, forKey: .chargeStatus)
         try encoderContainer.encode(securityStatus, forKey: .securityStatus)
         try encoderContainer.encode(createTime, forKey: .createTime)
         try encoderContainer.encode(expireTime, forKey: .expireTime)
         try encoderContainer.encode(resourceId, forKey: .resourceId)
         try encoderContainer.encode(ccProtectMode, forKey: .ccProtectMode)
         try encoderContainer.encode(ccProtectStatus, forKey: .ccProtectStatus)
         try encoderContainer.encode(ccSpeedLimit, forKey: .ccSpeedLimit)
         try encoderContainer.encode(ccSpeedPeriod, forKey: .ccSpeedPeriod)
         try encoderContainer.encode(ipBlackList, forKey: .ipBlackList)
         try encoderContainer.encode(ipBlackStatus, forKey: .ipBlackStatus)
         try encoderContainer.encode(ipWhiteList, forKey: .ipWhiteList)
         try encoderContainer.encode(ipWhiteStatus, forKey: .ipWhiteStatus)
         try encoderContainer.encode(urlWhitelist, forKey: .urlWhitelist)
         try encoderContainer.encode(urlWhitelistStatus, forKey: .urlWhitelistStatus)
         try encoderContainer.encode(hostQps, forKey: .hostQps)
         try encoderContainer.encode(hostUrlQps, forKey: .hostUrlQps)
         try encoderContainer.encode(ipHostQps, forKey: .ipHostQps)
         try encoderContainer.encode(ipHostUrlQps, forKey: .ipHostUrlQps)
    }
}

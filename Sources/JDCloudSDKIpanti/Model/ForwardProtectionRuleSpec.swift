/* Copyright 2018 JDCLOUD.COM

   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at

     http:#www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.

   
   

   
   Contact: 

   NOTE: This class is auto generated by the jdcloud code generator program.
 */


import Foundation

///  forwardProtectionRuleSpec
@objc(ForwardProtectionRuleSpec)
public class ForwardProtectionRuleSpec:NSObject,Codable{
    /// 虚假源与空连接, 0: 关闭, 1: 开启
    /// Required:true
    var spoofIpEnable:Int
    /// 源新建连接限速, 0: 关闭, 1: 开启
    /// Required:true
    var srcNewConnLimitEnable:Int
    /// 源新建连接速率
    /// Required:true
    var srcNewConnLimitValue:Int64
    /// 源并发连接限速, 0: 关闭, 1: 开启
    /// Required:true
    var srcConcurrentConnLimitEnable:Int
    /// 源并发连接速率
    /// Required:true
    var srcConcurrentConnLimitValue:Int64
    /// 目的新建连接, 0: 关闭, 1: 开启
    /// Required:true
    var dstNewConnLimitEnable:Int
    /// 目的新建连接速率
    /// Required:true
    var dstNewConnLimitValue:Int64
    /// 目的并发连接, 0: 关闭, 1: 开启
    /// Required:true
    var dstConcurrentConnLimitEnable:Int
    /// 目的并发连接速率
    /// Required:true
    var dstConcurrentConnLimitValue:Int64
    /// 报文最小长度, 取值范围[0, datagramRangeMax)
    /// Required:true
    var datagramRangeMin:Int64
    /// 报文最大长度, 取值范围(datagramRangeMin, 1518]
    /// Required:true
    var datagramRangeMax:Int64
    /// geo 拦截地域编码列表, 可设置编码列表由 describeGeoAreas 接口查询可得
    var geoBlackList:[String?]?



    public  init(spoofIpEnable:Int,srcNewConnLimitEnable:Int,srcNewConnLimitValue:Int64,srcConcurrentConnLimitEnable:Int,srcConcurrentConnLimitValue:Int64,dstNewConnLimitEnable:Int,dstNewConnLimitValue:Int64,dstConcurrentConnLimitEnable:Int,dstConcurrentConnLimitValue:Int64,datagramRangeMin:Int64,datagramRangeMax:Int64){
             self.spoofIpEnable = spoofIpEnable
             self.srcNewConnLimitEnable = srcNewConnLimitEnable
             self.srcNewConnLimitValue = srcNewConnLimitValue
             self.srcConcurrentConnLimitEnable = srcConcurrentConnLimitEnable
             self.srcConcurrentConnLimitValue = srcConcurrentConnLimitValue
             self.dstNewConnLimitEnable = dstNewConnLimitEnable
             self.dstNewConnLimitValue = dstNewConnLimitValue
             self.dstConcurrentConnLimitEnable = dstConcurrentConnLimitEnable
             self.dstConcurrentConnLimitValue = dstConcurrentConnLimitValue
             self.datagramRangeMin = datagramRangeMin
             self.datagramRangeMax = datagramRangeMax
    }

    enum ForwardProtectionRuleSpecCodingKeys: String, CodingKey {
        case spoofIpEnable
        case srcNewConnLimitEnable
        case srcNewConnLimitValue
        case srcConcurrentConnLimitEnable
        case srcConcurrentConnLimitValue
        case dstNewConnLimitEnable
        case dstNewConnLimitValue
        case dstConcurrentConnLimitEnable
        case dstConcurrentConnLimitValue
        case datagramRangeMin
        case datagramRangeMax
        case geoBlackList
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: ForwardProtectionRuleSpecCodingKeys.self)
        self.spoofIpEnable = try decoderContainer.decode(Int.self, forKey: .spoofIpEnable)
        self.srcNewConnLimitEnable = try decoderContainer.decode(Int.self, forKey: .srcNewConnLimitEnable)
        self.srcNewConnLimitValue = try decoderContainer.decode(Int64.self, forKey: .srcNewConnLimitValue)
        self.srcConcurrentConnLimitEnable = try decoderContainer.decode(Int.self, forKey: .srcConcurrentConnLimitEnable)
        self.srcConcurrentConnLimitValue = try decoderContainer.decode(Int64.self, forKey: .srcConcurrentConnLimitValue)
        self.dstNewConnLimitEnable = try decoderContainer.decode(Int.self, forKey: .dstNewConnLimitEnable)
        self.dstNewConnLimitValue = try decoderContainer.decode(Int64.self, forKey: .dstNewConnLimitValue)
        self.dstConcurrentConnLimitEnable = try decoderContainer.decode(Int.self, forKey: .dstConcurrentConnLimitEnable)
        self.dstConcurrentConnLimitValue = try decoderContainer.decode(Int64.self, forKey: .dstConcurrentConnLimitValue)
        self.datagramRangeMin = try decoderContainer.decode(Int64.self, forKey: .datagramRangeMin)
        self.datagramRangeMax = try decoderContainer.decode(Int64.self, forKey: .datagramRangeMax)
        if decoderContainer.contains(.geoBlackList)
        {
            self.geoBlackList = try decoderContainer.decode([String?]?.self, forKey: .geoBlackList)
        }
    }
}
public extension ForwardProtectionRuleSpec{
    public func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: ForwardProtectionRuleSpecCodingKeys.self)
         try encoderContainer.encode(spoofIpEnable, forKey: .spoofIpEnable)
         try encoderContainer.encode(srcNewConnLimitEnable, forKey: .srcNewConnLimitEnable)
         try encoderContainer.encode(srcNewConnLimitValue, forKey: .srcNewConnLimitValue)
         try encoderContainer.encode(srcConcurrentConnLimitEnable, forKey: .srcConcurrentConnLimitEnable)
         try encoderContainer.encode(srcConcurrentConnLimitValue, forKey: .srcConcurrentConnLimitValue)
         try encoderContainer.encode(dstNewConnLimitEnable, forKey: .dstNewConnLimitEnable)
         try encoderContainer.encode(dstNewConnLimitValue, forKey: .dstNewConnLimitValue)
         try encoderContainer.encode(dstConcurrentConnLimitEnable, forKey: .dstConcurrentConnLimitEnable)
         try encoderContainer.encode(dstConcurrentConnLimitValue, forKey: .dstConcurrentConnLimitValue)
         try encoderContainer.encode(datagramRangeMin, forKey: .datagramRangeMin)
         try encoderContainer.encode(datagramRangeMax, forKey: .datagramRangeMax)
         try encoderContainer.encode(geoBlackList, forKey: .geoBlackList)
    }
}

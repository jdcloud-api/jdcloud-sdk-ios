/* Copyright 2018 JDCLOUD.COM

   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at

     http:#www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.

   
   

   
   Contact: 

   NOTE: This class is auto generated by the jdcloud code generator program.
 */


import Foundation

///  forwardProtectionRule
@objc(ForwardProtectionRule)
public class ForwardProtectionRule:NSObject,Codable{
    /// 虚假源与空连接, 0: 关闭, 1: 开启
    var spoofIpEnable:Int?
    /// 源新建连接限速, 0: 关闭, 1: 开启
    var srcNewConnLimitEnable:Int?
    /// 源新建连接速率
    var srcNewConnLimitValue:Int64?
    /// 源并发连接限速, 0: 关闭, 1: 开启
    var srcConcurrentConnLimitEnable:Int?
    /// 源并发连接速率
    var srcConcurrentConnLimitValue:Int64?
    /// 目的新建连接限速, 0: 关闭, 1: 开启
    var dstNewConnLimitEnable:Int?
    /// 目的新建连接速率
    var dstNewConnLimitValue:Int64?
    /// 目的并发连接限速, 0: 关闭, 1: 开启
    var dstConcurrentConnLimitEnable:Int?
    /// 目的并发连接速率
    var dstConcurrentConnLimitValue:Int64?
    /// 报文最小长度
    var datagramRangeMin:Int64?
    /// 报文最大长度
    var datagramRangeMax:Int64?
    /// geo 拦截地域列表
    var geoBlackList:[GeoBlack?]?



    public override init(){
            super.init()
    }

    enum ForwardProtectionRuleCodingKeys: String, CodingKey {
        case spoofIpEnable
        case srcNewConnLimitEnable
        case srcNewConnLimitValue
        case srcConcurrentConnLimitEnable
        case srcConcurrentConnLimitValue
        case dstNewConnLimitEnable
        case dstNewConnLimitValue
        case dstConcurrentConnLimitEnable
        case dstConcurrentConnLimitValue
        case datagramRangeMin
        case datagramRangeMax
        case geoBlackList
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: ForwardProtectionRuleCodingKeys.self)
        if decoderContainer.contains(.spoofIpEnable)
        {
            self.spoofIpEnable = try decoderContainer.decode(Int?.self, forKey: .spoofIpEnable)
        }
        if decoderContainer.contains(.srcNewConnLimitEnable)
        {
            self.srcNewConnLimitEnable = try decoderContainer.decode(Int?.self, forKey: .srcNewConnLimitEnable)
        }
        if decoderContainer.contains(.srcNewConnLimitValue)
        {
            self.srcNewConnLimitValue = try decoderContainer.decode(Int64?.self, forKey: .srcNewConnLimitValue)
        }
        if decoderContainer.contains(.srcConcurrentConnLimitEnable)
        {
            self.srcConcurrentConnLimitEnable = try decoderContainer.decode(Int?.self, forKey: .srcConcurrentConnLimitEnable)
        }
        if decoderContainer.contains(.srcConcurrentConnLimitValue)
        {
            self.srcConcurrentConnLimitValue = try decoderContainer.decode(Int64?.self, forKey: .srcConcurrentConnLimitValue)
        }
        if decoderContainer.contains(.dstNewConnLimitEnable)
        {
            self.dstNewConnLimitEnable = try decoderContainer.decode(Int?.self, forKey: .dstNewConnLimitEnable)
        }
        if decoderContainer.contains(.dstNewConnLimitValue)
        {
            self.dstNewConnLimitValue = try decoderContainer.decode(Int64?.self, forKey: .dstNewConnLimitValue)
        }
        if decoderContainer.contains(.dstConcurrentConnLimitEnable)
        {
            self.dstConcurrentConnLimitEnable = try decoderContainer.decode(Int?.self, forKey: .dstConcurrentConnLimitEnable)
        }
        if decoderContainer.contains(.dstConcurrentConnLimitValue)
        {
            self.dstConcurrentConnLimitValue = try decoderContainer.decode(Int64?.self, forKey: .dstConcurrentConnLimitValue)
        }
        if decoderContainer.contains(.datagramRangeMin)
        {
            self.datagramRangeMin = try decoderContainer.decode(Int64?.self, forKey: .datagramRangeMin)
        }
        if decoderContainer.contains(.datagramRangeMax)
        {
            self.datagramRangeMax = try decoderContainer.decode(Int64?.self, forKey: .datagramRangeMax)
        }
        if decoderContainer.contains(.geoBlackList)
        {
            self.geoBlackList = try decoderContainer.decode([GeoBlack?]?.self, forKey: .geoBlackList)
        }
    }
}
public extension ForwardProtectionRule{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: ForwardProtectionRuleCodingKeys.self)
         try encoderContainer.encode(spoofIpEnable, forKey: .spoofIpEnable)
         try encoderContainer.encode(srcNewConnLimitEnable, forKey: .srcNewConnLimitEnable)
         try encoderContainer.encode(srcNewConnLimitValue, forKey: .srcNewConnLimitValue)
         try encoderContainer.encode(srcConcurrentConnLimitEnable, forKey: .srcConcurrentConnLimitEnable)
         try encoderContainer.encode(srcConcurrentConnLimitValue, forKey: .srcConcurrentConnLimitValue)
         try encoderContainer.encode(dstNewConnLimitEnable, forKey: .dstNewConnLimitEnable)
         try encoderContainer.encode(dstNewConnLimitValue, forKey: .dstNewConnLimitValue)
         try encoderContainer.encode(dstConcurrentConnLimitEnable, forKey: .dstConcurrentConnLimitEnable)
         try encoderContainer.encode(dstConcurrentConnLimitValue, forKey: .dstConcurrentConnLimitValue)
         try encoderContainer.encode(datagramRangeMin, forKey: .datagramRangeMin)
         try encoderContainer.encode(datagramRangeMax, forKey: .datagramRangeMax)
         try encoderContainer.encode(geoBlackList, forKey: .geoBlackList)
    }
}

/* Copyright 2018 JDCLOUD.COM

   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at

     http:#www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.

   Resource
   Interface of Resource

   OpenAPI spec version: v1
   Contact: 

   NOTE: This class is auto generated by the jdcloud code generator program.
 */


import Foundation
///  templateValidateSpec
public class TemplateValidateSpec:NSObject,Codable{
    /// Environment
    var environment:Environment?
    /// 模板
    /// Required:true
    var template:AnyObject?
    /// 可取值:(validateTemplate (检测模板), validateStack (检测模板和environment)) 默认validateTemplate
    var validateMode:String?



    public  init(template:AnyObject?){
             self.template = template
    }

    enum TemplateValidateSpecCodingKeys: String, CodingKey {
        case environment
        case template
        case validateMode
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: TemplateValidateSpecCodingKeys.self)
        if decoderContainer.contains(.environment)
        {
            self.environment = try decoderContainer.decode(Environment?.self, forKey: .environment)
        }
        if decoderContainer.contains(.validateMode)
        {
            self.validateMode = try decoderContainer.decode(String?.self, forKey: .validateMode)
        }
    }
}
public extension TemplateValidateSpec{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: TemplateValidateSpecCodingKeys.self)
         try encoderContainer.encode(environment, forKey: .environment)
         try encoderContainer.encode(validateMode, forKey: .validateMode)
    }
}
///  环境信息
public class Environment:NSObject,Codable{
    /// 禁止回滚，默认false，即创建资源栈失败时回滚
    var disableRollback:Bool?
    /// 资源栈名称
    /// Required:true
    var name:String
    /// 自定义参数值map, 内容为键值对形式，key为参数，value为自定义参数值。Params中的参数值会覆盖模板文件中参数的默认值。
    var params:[String:String?]?
    /// 超时时间，单位分钟，范围10-180
    /// Required:true
    var timeout:Int64



    public  init(name:String,timeout:Int64){
             self.name = name
             self.timeout = timeout
    }

    enum EnvironmentCodingKeys: String, CodingKey {
        case disableRollback
        case name
        case params
        case timeout
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: EnvironmentCodingKeys.self)
        if decoderContainer.contains(.disableRollback)
        {
            self.disableRollback = try decoderContainer.decode(Bool?.self, forKey: .disableRollback)
        }
        self.name = try decoderContainer.decode(String.self, forKey: .name)
        if decoderContainer.contains(.params)
        {
            self.params = try decoderContainer.decode([String:String?]?.self, forKey: .params)
        }
        self.timeout = try decoderContainer.decode(Int64.self, forKey: .timeout)
    }
}
public extension Environment{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: EnvironmentCodingKeys.self)
         try encoderContainer.encode(disableRollback, forKey: .disableRollback)
         try encoderContainer.encode(name, forKey: .name)
         try encoderContainer.encode(params, forKey: .params)
         try encoderContainer.encode(timeout, forKey: .timeout)
    }
}
///  templateOut
public class TemplateOut:NSObject,Codable{
    /// 模板创建时间
    var createTime:String?
    /// 模板描述
    var describe:String?
    /// 模板ID
    var id:String?
    /// 模板内容
    var info:String?
    /// 模板名称
    var name:String?
    /// 地域信息
    var region:String?



    public override init(){
            super.init()
    }

    enum TemplateOutCodingKeys: String, CodingKey {
        case createTime
        case describe
        case id
        case info
        case name
        case region
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: TemplateOutCodingKeys.self)
        if decoderContainer.contains(.createTime)
        {
            self.createTime = try decoderContainer.decode(String?.self, forKey: .createTime)
        }
        if decoderContainer.contains(.describe)
        {
            self.describe = try decoderContainer.decode(String?.self, forKey: .describe)
        }
        if decoderContainer.contains(.id)
        {
            self.id = try decoderContainer.decode(String?.self, forKey: .id)
        }
        if decoderContainer.contains(.info)
        {
            self.info = try decoderContainer.decode(String?.self, forKey: .info)
        }
        if decoderContainer.contains(.name)
        {
            self.name = try decoderContainer.decode(String?.self, forKey: .name)
        }
        if decoderContainer.contains(.region)
        {
            self.region = try decoderContainer.decode(String?.self, forKey: .region)
        }
    }
}
public extension TemplateOut{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: TemplateOutCodingKeys.self)
         try encoderContainer.encode(createTime, forKey: .createTime)
         try encoderContainer.encode(describe, forKey: .describe)
         try encoderContainer.encode(id, forKey: .id)
         try encoderContainer.encode(info, forKey: .info)
         try encoderContainer.encode(name, forKey: .name)
         try encoderContainer.encode(region, forKey: .region)
    }
}
///  resourceChange
public class ResourceChange:NSObject,Codable{
    /// Action
    var action:String?
    /// 更新操作中将对资源做的改变详情
    var details:[ResourceChangeDetail?]?
    /// 资源在模板中的逻辑id
    var logicalResourceId:String?
    /// 资源物理id
    var physicalResourceId:String?
    /// Replacement
    var replacement:String?
    /// 资源类型
    var resourceType:String?
    /// 更新操作中修改发生的位置
    var scope:[String?]?



    public override init(){
            super.init()
    }

    enum ResourceChangeCodingKeys: String, CodingKey {
        case action
        case details
        case logicalResourceId
        case physicalResourceId
        case replacement
        case resourceType
        case scope
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: ResourceChangeCodingKeys.self)
        if decoderContainer.contains(.action)
        {
            self.action = try decoderContainer.decode(String?.self, forKey: .action)
        }
        if decoderContainer.contains(.details)
        {
            self.details = try decoderContainer.decode([ResourceChangeDetail?]?.self, forKey: .details)
        }
        if decoderContainer.contains(.logicalResourceId)
        {
            self.logicalResourceId = try decoderContainer.decode(String?.self, forKey: .logicalResourceId)
        }
        if decoderContainer.contains(.physicalResourceId)
        {
            self.physicalResourceId = try decoderContainer.decode(String?.self, forKey: .physicalResourceId)
        }
        if decoderContainer.contains(.replacement)
        {
            self.replacement = try decoderContainer.decode(String?.self, forKey: .replacement)
        }
        if decoderContainer.contains(.resourceType)
        {
            self.resourceType = try decoderContainer.decode(String?.self, forKey: .resourceType)
        }
        if decoderContainer.contains(.scope)
        {
            self.scope = try decoderContainer.decode([String?]?.self, forKey: .scope)
        }
    }
}
public extension ResourceChange{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: ResourceChangeCodingKeys.self)
         try encoderContainer.encode(action, forKey: .action)
         try encoderContainer.encode(details, forKey: .details)
         try encoderContainer.encode(logicalResourceId, forKey: .logicalResourceId)
         try encoderContainer.encode(physicalResourceId, forKey: .physicalResourceId)
         try encoderContainer.encode(replacement, forKey: .replacement)
         try encoderContainer.encode(resourceType, forKey: .resourceType)
         try encoderContainer.encode(scope, forKey: .scope)
    }
}
///  resourceOut
public class ResourceOut:NSObject,Codable{
    /// 资源运行操作
    var action:String?
    /// 创建时间
    var createTime:String?
    /// 删除策略
    var deletePolicy:String?
    /// 删除时间
    var deleteTime:String?
    /// 资源逻辑ID
    var logicId:String?
    /// 资源ID
    var physicalId:String?
    /// 地域信息
    var region:String?
    /// Snapshot信息，仅针对磁盘资源类型
    var snapshot:String?
    /// 资源栈ID
    var stackId:String?
    /// 资源运行状态
    var status:String?
    /// 资源运行状态原因
    var statusReason:String?
    /// 资源类型
    var type:String?
    /// 更新时间
    var updateTime:String?



    public override init(){
            super.init()
    }

    enum ResourceOutCodingKeys: String, CodingKey {
        case action
        case createTime
        case deletePolicy
        case deleteTime
        case logicId
        case physicalId
        case region
        case snapshot
        case stackId
        case status
        case statusReason
        case type
        case updateTime
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: ResourceOutCodingKeys.self)
        if decoderContainer.contains(.action)
        {
            self.action = try decoderContainer.decode(String?.self, forKey: .action)
        }
        if decoderContainer.contains(.createTime)
        {
            self.createTime = try decoderContainer.decode(String?.self, forKey: .createTime)
        }
        if decoderContainer.contains(.deletePolicy)
        {
            self.deletePolicy = try decoderContainer.decode(String?.self, forKey: .deletePolicy)
        }
        if decoderContainer.contains(.deleteTime)
        {
            self.deleteTime = try decoderContainer.decode(String?.self, forKey: .deleteTime)
        }
        if decoderContainer.contains(.logicId)
        {
            self.logicId = try decoderContainer.decode(String?.self, forKey: .logicId)
        }
        if decoderContainer.contains(.physicalId)
        {
            self.physicalId = try decoderContainer.decode(String?.self, forKey: .physicalId)
        }
        if decoderContainer.contains(.region)
        {
            self.region = try decoderContainer.decode(String?.self, forKey: .region)
        }
        if decoderContainer.contains(.snapshot)
        {
            self.snapshot = try decoderContainer.decode(String?.self, forKey: .snapshot)
        }
        if decoderContainer.contains(.stackId)
        {
            self.stackId = try decoderContainer.decode(String?.self, forKey: .stackId)
        }
        if decoderContainer.contains(.status)
        {
            self.status = try decoderContainer.decode(String?.self, forKey: .status)
        }
        if decoderContainer.contains(.statusReason)
        {
            self.statusReason = try decoderContainer.decode(String?.self, forKey: .statusReason)
        }
        if decoderContainer.contains(.type)
        {
            self.type = try decoderContainer.decode(String?.self, forKey: .type)
        }
        if decoderContainer.contains(.updateTime)
        {
            self.updateTime = try decoderContainer.decode(String?.self, forKey: .updateTime)
        }
    }
}
public extension ResourceOut{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: ResourceOutCodingKeys.self)
         try encoderContainer.encode(action, forKey: .action)
         try encoderContainer.encode(createTime, forKey: .createTime)
         try encoderContainer.encode(deletePolicy, forKey: .deletePolicy)
         try encoderContainer.encode(deleteTime, forKey: .deleteTime)
         try encoderContainer.encode(logicId, forKey: .logicId)
         try encoderContainer.encode(physicalId, forKey: .physicalId)
         try encoderContainer.encode(region, forKey: .region)
         try encoderContainer.encode(snapshot, forKey: .snapshot)
         try encoderContainer.encode(stackId, forKey: .stackId)
         try encoderContainer.encode(status, forKey: .status)
         try encoderContainer.encode(statusReason, forKey: .statusReason)
         try encoderContainer.encode(type, forKey: .type)
         try encoderContainer.encode(updateTime, forKey: .updateTime)
    }
}
///  createStackSpec
public class CreateStackSpec:NSObject,Codable{
    /// Environment
    /// Required:true
    var environment:Environment
    /// 模板, JSON对象
    /// Required:true
    var template:AnyObject?



    public  init(environment:Environment,template:AnyObject?){
             self.environment = environment
             self.template = template
    }

    enum CreateStackSpecCodingKeys: String, CodingKey {
        case environment
        case template
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: CreateStackSpecCodingKeys.self)
        self.environment = try decoderContainer.decode(Environment.self, forKey: .environment)
    }
}
public extension CreateStackSpec{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: CreateStackSpecCodingKeys.self)
         try encoderContainer.encode(environment, forKey: .environment)
    }
}
///  eventOut
public class EventOut:NSObject,Codable{
    /// 创建时间
    var createTime:String?
    /// 资源ID
    var physicalId:String?
    /// 资源运行操作
    var resourceAction:String?
    /// 资源名称
    var resourceName:String?
    /// 资源运行状态
    var resourceStatus:String?
    /// 资源运行状态原因
    var resourceStatusReason:String?
    /// 资源类型
    var resourceType:String?
    /// 资源栈ID
    var stackId:String?
    /// 唯一标识
    var uuid:String?



    public override init(){
            super.init()
    }

    enum EventOutCodingKeys: String, CodingKey {
        case createTime
        case physicalId
        case resourceAction
        case resourceName
        case resourceStatus
        case resourceStatusReason
        case resourceType
        case stackId
        case uuid
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: EventOutCodingKeys.self)
        if decoderContainer.contains(.createTime)
        {
            self.createTime = try decoderContainer.decode(String?.self, forKey: .createTime)
        }
        if decoderContainer.contains(.physicalId)
        {
            self.physicalId = try decoderContainer.decode(String?.self, forKey: .physicalId)
        }
        if decoderContainer.contains(.resourceAction)
        {
            self.resourceAction = try decoderContainer.decode(String?.self, forKey: .resourceAction)
        }
        if decoderContainer.contains(.resourceName)
        {
            self.resourceName = try decoderContainer.decode(String?.self, forKey: .resourceName)
        }
        if decoderContainer.contains(.resourceStatus)
        {
            self.resourceStatus = try decoderContainer.decode(String?.self, forKey: .resourceStatus)
        }
        if decoderContainer.contains(.resourceStatusReason)
        {
            self.resourceStatusReason = try decoderContainer.decode(String?.self, forKey: .resourceStatusReason)
        }
        if decoderContainer.contains(.resourceType)
        {
            self.resourceType = try decoderContainer.decode(String?.self, forKey: .resourceType)
        }
        if decoderContainer.contains(.stackId)
        {
            self.stackId = try decoderContainer.decode(String?.self, forKey: .stackId)
        }
        if decoderContainer.contains(.uuid)
        {
            self.uuid = try decoderContainer.decode(String?.self, forKey: .uuid)
        }
    }
}
public extension EventOut{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: EventOutCodingKeys.self)
         try encoderContainer.encode(createTime, forKey: .createTime)
         try encoderContainer.encode(physicalId, forKey: .physicalId)
         try encoderContainer.encode(resourceAction, forKey: .resourceAction)
         try encoderContainer.encode(resourceName, forKey: .resourceName)
         try encoderContainer.encode(resourceStatus, forKey: .resourceStatus)
         try encoderContainer.encode(resourceStatusReason, forKey: .resourceStatusReason)
         try encoderContainer.encode(resourceType, forKey: .resourceType)
         try encoderContainer.encode(stackId, forKey: .stackId)
         try encoderContainer.encode(uuid, forKey: .uuid)
    }
}
///  changeSet
public class ChangeSet:NSObject,Codable{
    /// 更改集操作
    var action:String?
    /// 更改信息
    var changeInfo:String?
    /// changeset的详细信息
    var changeMap:[String:Change?]?
    /// 创建时间
    var createTime:String?
    /// 更改集描述
    var describe:String?
    /// Id
    var id:String?
    /// 是否执行
    var isRun:Int64?
    /// 更改集名称
    var name:String?
    /// 地域信息
    var region:String?
    /// 执行时间
    var runTime:String?
    /// 对应资源栈ID
    var stackId:String?
    /// 状态
    var status:String?
    /// 状态原因
    var statusReason:String?
    /// 对应模板ID
    var templateId:String?



    public override init(){
            super.init()
    }

    enum ChangeSetCodingKeys: String, CodingKey {
        case action
        case changeInfo
        case changeMap
        case createTime
        case describe
        case id
        case isRun
        case name
        case region
        case runTime
        case stackId
        case status
        case statusReason
        case templateId
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: ChangeSetCodingKeys.self)
        if decoderContainer.contains(.action)
        {
            self.action = try decoderContainer.decode(String?.self, forKey: .action)
        }
        if decoderContainer.contains(.changeInfo)
        {
            self.changeInfo = try decoderContainer.decode(String?.self, forKey: .changeInfo)
        }
        if decoderContainer.contains(.changeMap)
        {
            self.changeMap = try decoderContainer.decode([String:Change?]?.self, forKey: .changeMap)
        }
        if decoderContainer.contains(.createTime)
        {
            self.createTime = try decoderContainer.decode(String?.self, forKey: .createTime)
        }
        if decoderContainer.contains(.describe)
        {
            self.describe = try decoderContainer.decode(String?.self, forKey: .describe)
        }
        if decoderContainer.contains(.id)
        {
            self.id = try decoderContainer.decode(String?.self, forKey: .id)
        }
        if decoderContainer.contains(.isRun)
        {
            self.isRun = try decoderContainer.decode(Int64?.self, forKey: .isRun)
        }
        if decoderContainer.contains(.name)
        {
            self.name = try decoderContainer.decode(String?.self, forKey: .name)
        }
        if decoderContainer.contains(.region)
        {
            self.region = try decoderContainer.decode(String?.self, forKey: .region)
        }
        if decoderContainer.contains(.runTime)
        {
            self.runTime = try decoderContainer.decode(String?.self, forKey: .runTime)
        }
        if decoderContainer.contains(.stackId)
        {
            self.stackId = try decoderContainer.decode(String?.self, forKey: .stackId)
        }
        if decoderContainer.contains(.status)
        {
            self.status = try decoderContainer.decode(String?.self, forKey: .status)
        }
        if decoderContainer.contains(.statusReason)
        {
            self.statusReason = try decoderContainer.decode(String?.self, forKey: .statusReason)
        }
        if decoderContainer.contains(.templateId)
        {
            self.templateId = try decoderContainer.decode(String?.self, forKey: .templateId)
        }
    }
}
public extension ChangeSet{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: ChangeSetCodingKeys.self)
         try encoderContainer.encode(action, forKey: .action)
         try encoderContainer.encode(changeInfo, forKey: .changeInfo)
         try encoderContainer.encode(changeMap, forKey: .changeMap)
         try encoderContainer.encode(createTime, forKey: .createTime)
         try encoderContainer.encode(describe, forKey: .describe)
         try encoderContainer.encode(id, forKey: .id)
         try encoderContainer.encode(isRun, forKey: .isRun)
         try encoderContainer.encode(name, forKey: .name)
         try encoderContainer.encode(region, forKey: .region)
         try encoderContainer.encode(runTime, forKey: .runTime)
         try encoderContainer.encode(stackId, forKey: .stackId)
         try encoderContainer.encode(status, forKey: .status)
         try encoderContainer.encode(statusReason, forKey: .statusReason)
         try encoderContainer.encode(templateId, forKey: .templateId)
    }
}
///  createStackChangeSetRequset
public class CreateStackChangeSetRequset:NSObject,Codable{
    /// Environment
    /// Required:true
    var environment:Environment
    /// 模板, JSON对象
    /// Required:true
    var template:AnyObject?



    public  init(environment:Environment,template:AnyObject?){
             self.environment = environment
             self.template = template
    }

    enum CreateStackChangeSetRequsetCodingKeys: String, CodingKey {
        case environment
        case template
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: CreateStackChangeSetRequsetCodingKeys.self)
        self.environment = try decoderContainer.decode(Environment.self, forKey: .environment)
    }
}
public extension CreateStackChangeSetRequset{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: CreateStackChangeSetRequsetCodingKeys.self)
         try encoderContainer.encode(environment, forKey: .environment)
    }
}
///  resourceTargetDefinition
public class ResourceTargetDefinition:NSObject,Codable{
    /// Attribute
    var attribute:String?
    /// 如果 Attribute 为 Properties，值为属性的名称，否则为空
    var name:String?
    /// RequiresRecreation
    var requiresRecreation:String?



    public override init(){
            super.init()
    }

    enum ResourceTargetDefinitionCodingKeys: String, CodingKey {
        case attribute
        case name
        case requiresRecreation
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: ResourceTargetDefinitionCodingKeys.self)
        if decoderContainer.contains(.attribute)
        {
            self.attribute = try decoderContainer.decode(String?.self, forKey: .attribute)
        }
        if decoderContainer.contains(.name)
        {
            self.name = try decoderContainer.decode(String?.self, forKey: .name)
        }
        if decoderContainer.contains(.requiresRecreation)
        {
            self.requiresRecreation = try decoderContainer.decode(String?.self, forKey: .requiresRecreation)
        }
    }
}
public extension ResourceTargetDefinition{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: ResourceTargetDefinitionCodingKeys.self)
         try encoderContainer.encode(attribute, forKey: .attribute)
         try encoderContainer.encode(name, forKey: .name)
         try encoderContainer.encode(requiresRecreation, forKey: .requiresRecreation)
    }
}
///  change
public class Change:NSObject,Codable{
    /// ResourceChange
    var resourceChange:ResourceChange?
    /// Type
    var type:String?



    public override init(){
            super.init()
    }

    enum ChangeCodingKeys: String, CodingKey {
        case resourceChange
        case type
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: ChangeCodingKeys.self)
        if decoderContainer.contains(.resourceChange)
        {
            self.resourceChange = try decoderContainer.decode(ResourceChange?.self, forKey: .resourceChange)
        }
        if decoderContainer.contains(.type)
        {
            self.type = try decoderContainer.decode(String?.self, forKey: .type)
        }
    }
}
public extension Change{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: ChangeCodingKeys.self)
         try encoderContainer.encode(resourceChange, forKey: .resourceChange)
         try encoderContainer.encode(type, forKey: .type)
    }
}
///  stackOut
public class StackOut:NSObject,Codable{
    /// 资源栈运行操作
    var action:String?
    /// 资源栈能否更新
    var canUpdate:Bool?
    /// 资源栈创建时间
    var createTime:String?
    /// 资源栈是否回滚设置
    var disableRollback:Bool?
    /// 资源栈ID
    var id:String?
    /// 资源栈输入信息，JSON格式，此字段只在查询资源栈详情describeStack时有值
    var input:[String:AnyObject?]?
    /// 资源栈名称
    var name:String?
    /// 资源栈输出信息，JSON格式, 此字段只在查询资源栈详情describeStack时有值
    var output:[String:AnyObject?]?
    /// 资源栈所在区域
    var region:String?
    /// 资源栈版本
    var stackVersion:Int64?
    /// 资源栈运行状态
    var status:String?
    /// 资源栈运行状态原因
    var statusReason:String?
    /// 资源栈使用的template ID
    var templateId:String?
    /// 资源栈超时时间
    var timeout:Int64?
    /// 资源栈更新时间
    var updateTime:String?



    public override init(){
            super.init()
    }

    enum StackOutCodingKeys: String, CodingKey {
        case action
        case canUpdate
        case createTime
        case disableRollback
        case id
        case input
        case name
        case output
        case region
        case stackVersion
        case status
        case statusReason
        case templateId
        case timeout
        case updateTime
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: StackOutCodingKeys.self)
        if decoderContainer.contains(.action)
        {
            self.action = try decoderContainer.decode(String?.self, forKey: .action)
        }
        if decoderContainer.contains(.canUpdate)
        {
            self.canUpdate = try decoderContainer.decode(Bool?.self, forKey: .canUpdate)
        }
        if decoderContainer.contains(.createTime)
        {
            self.createTime = try decoderContainer.decode(String?.self, forKey: .createTime)
        }
        if decoderContainer.contains(.disableRollback)
        {
            self.disableRollback = try decoderContainer.decode(Bool?.self, forKey: .disableRollback)
        }
        if decoderContainer.contains(.id)
        {
            self.id = try decoderContainer.decode(String?.self, forKey: .id)
        }
        if decoderContainer.contains(.name)
        {
            self.name = try decoderContainer.decode(String?.self, forKey: .name)
        }
        if decoderContainer.contains(.region)
        {
            self.region = try decoderContainer.decode(String?.self, forKey: .region)
        }
        if decoderContainer.contains(.stackVersion)
        {
            self.stackVersion = try decoderContainer.decode(Int64?.self, forKey: .stackVersion)
        }
        if decoderContainer.contains(.status)
        {
            self.status = try decoderContainer.decode(String?.self, forKey: .status)
        }
        if decoderContainer.contains(.statusReason)
        {
            self.statusReason = try decoderContainer.decode(String?.self, forKey: .statusReason)
        }
        if decoderContainer.contains(.templateId)
        {
            self.templateId = try decoderContainer.decode(String?.self, forKey: .templateId)
        }
        if decoderContainer.contains(.timeout)
        {
            self.timeout = try decoderContainer.decode(Int64?.self, forKey: .timeout)
        }
        if decoderContainer.contains(.updateTime)
        {
            self.updateTime = try decoderContainer.decode(String?.self, forKey: .updateTime)
        }
    }
}
public extension StackOut{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: StackOutCodingKeys.self)
         try encoderContainer.encode(action, forKey: .action)
         try encoderContainer.encode(canUpdate, forKey: .canUpdate)
         try encoderContainer.encode(createTime, forKey: .createTime)
         try encoderContainer.encode(disableRollback, forKey: .disableRollback)
         try encoderContainer.encode(id, forKey: .id)
         try encoderContainer.encode(name, forKey: .name)
         try encoderContainer.encode(region, forKey: .region)
         try encoderContainer.encode(stackVersion, forKey: .stackVersion)
         try encoderContainer.encode(status, forKey: .status)
         try encoderContainer.encode(statusReason, forKey: .statusReason)
         try encoderContainer.encode(templateId, forKey: .templateId)
         try encoderContainer.encode(timeout, forKey: .timeout)
         try encoderContainer.encode(updateTime, forKey: .updateTime)
    }
}
///  resourceChangeDetail
public class ResourceChangeDetail:NSObject,Codable{
    /// 引发变更的资源逻辑id，当 changeSource 为 DirectModification ，此值为空
    var causingEntity:String?
    /// ChangeSource
    var changeSource:String?
    /// Evaluation
    var evaluation:String?
    /// Target
    var target:ResourceTargetDefinition?



    public override init(){
            super.init()
    }

    enum ResourceChangeDetailCodingKeys: String, CodingKey {
        case causingEntity
        case changeSource
        case evaluation
        case target
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: ResourceChangeDetailCodingKeys.self)
        if decoderContainer.contains(.causingEntity)
        {
            self.causingEntity = try decoderContainer.decode(String?.self, forKey: .causingEntity)
        }
        if decoderContainer.contains(.changeSource)
        {
            self.changeSource = try decoderContainer.decode(String?.self, forKey: .changeSource)
        }
        if decoderContainer.contains(.evaluation)
        {
            self.evaluation = try decoderContainer.decode(String?.self, forKey: .evaluation)
        }
        if decoderContainer.contains(.target)
        {
            self.target = try decoderContainer.decode(ResourceTargetDefinition?.self, forKey: .target)
        }
    }
}
public extension ResourceChangeDetail{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: ResourceChangeDetailCodingKeys.self)
         try encoderContainer.encode(causingEntity, forKey: .causingEntity)
         try encoderContainer.encode(changeSource, forKey: .changeSource)
         try encoderContainer.encode(evaluation, forKey: .evaluation)
         try encoderContainer.encode(target, forKey: .target)
    }
}
///  资源输出参数类型
public class ResourceAttribute:NSObject,Codable{
    /// 注释
    var comment:String?
    /// 如果 Type 字段的值为 List 或 Map，则指示列表或映射的类型 (如果它们包含非基元类型)
    var itemType:String?
    /// 如果 Type 字段的值为 List 或 Map，则指示列表或映射的类型 (如果它们包含基元类型)
    var primitiveItemType:String?
    /// 基元类型
    var primitiveType:String?
    /// Type
    var type:PropertyItemType?



    public override init(){
            super.init()
    }

    enum ResourceAttributeCodingKeys: String, CodingKey {
        case comment
        case itemType
        case primitiveItemType
        case primitiveType
        case type
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: ResourceAttributeCodingKeys.self)
        if decoderContainer.contains(.comment)
        {
            self.comment = try decoderContainer.decode(String?.self, forKey: .comment)
        }
        if decoderContainer.contains(.itemType)
        {
            self.itemType = try decoderContainer.decode(String?.self, forKey: .itemType)
        }
        if decoderContainer.contains(.primitiveItemType)
        {
            self.primitiveItemType = try decoderContainer.decode(String?.self, forKey: .primitiveItemType)
        }
        if decoderContainer.contains(.primitiveType)
        {
            self.primitiveType = try decoderContainer.decode(String?.self, forKey: .primitiveType)
        }
        if decoderContainer.contains(.type)
        {
            self.type = try decoderContainer.decode(PropertyItemType?.self, forKey: .type)
        }
    }
}
public extension ResourceAttribute{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: ResourceAttributeCodingKeys.self)
         try encoderContainer.encode(comment, forKey: .comment)
         try encoderContainer.encode(itemType, forKey: .itemType)
         try encoderContainer.encode(primitiveItemType, forKey: .primitiveItemType)
         try encoderContainer.encode(primitiveType, forKey: .primitiveType)
         try encoderContainer.encode(type, forKey: .type)
    }
}
///  资源属性参数定义
public class PropertyTypes:NSObject,Codable{
    /// Documentation
    var documentation:String?
    /// Properties
    var properties:[String:PropertyTypeDefinition?]?



    public override init(){
            super.init()
    }

    enum PropertyTypesCodingKeys: String, CodingKey {
        case documentation
        case properties
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: PropertyTypesCodingKeys.self)
        if decoderContainer.contains(.documentation)
        {
            self.documentation = try decoderContainer.decode(String?.self, forKey: .documentation)
        }
        if decoderContainer.contains(.properties)
        {
            self.properties = try decoderContainer.decode([String:PropertyTypeDefinition?]?.self, forKey: .properties)
        }
    }
}
public extension PropertyTypes{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: PropertyTypesCodingKeys.self)
         try encoderContainer.encode(documentation, forKey: .documentation)
         try encoderContainer.encode(properties, forKey: .properties)
    }
}
///  资源属性类型
public class PropertyItemType:NSObject,Codable{
    /// MultiValues
    var multiValues:[String?]?
    /// Scalar
    var scalar:String?



    public override init(){
            super.init()
    }

    enum PropertyItemTypeCodingKeys: String, CodingKey {
        case multiValues
        case scalar
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: PropertyItemTypeCodingKeys.self)
        if decoderContainer.contains(.multiValues)
        {
            self.multiValues = try decoderContainer.decode([String?]?.self, forKey: .multiValues)
        }
        if decoderContainer.contains(.scalar)
        {
            self.scalar = try decoderContainer.decode(String?.self, forKey: .scalar)
        }
    }
}
public extension PropertyItemType{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: PropertyItemTypeCodingKeys.self)
         try encoderContainer.encode(multiValues, forKey: .multiValues)
         try encoderContainer.encode(scalar, forKey: .scalar)
    }
}
///  资源类型定义
public class ResourceTypes:NSObject,Codable{
    /// 资源输出参数定义
    var attributes:[String:ResourceAttribute?]?
    /// 资源描述
    var descriptionValue:String?
    /// 文档链接
    var documentation:String?
    /// 资源属性定义
    var properties:[String:PropertyTypeDefinition?]?



    public override init(){
            super.init()
    }

    enum ResourceTypesCodingKeys: String, CodingKey {
        case attributes
        case descriptionValue = "description"
        case documentation
        case properties
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: ResourceTypesCodingKeys.self)
        if decoderContainer.contains(.attributes)
        {
            self.attributes = try decoderContainer.decode([String:ResourceAttribute?]?.self, forKey: .attributes)
        }
        if decoderContainer.contains(.descriptionValue)
        {
            self.descriptionValue = try decoderContainer.decode(String?.self, forKey: .descriptionValue)
        }
        if decoderContainer.contains(.documentation)
        {
            self.documentation = try decoderContainer.decode(String?.self, forKey: .documentation)
        }
        if decoderContainer.contains(.properties)
        {
            self.properties = try decoderContainer.decode([String:PropertyTypeDefinition?]?.self, forKey: .properties)
        }
    }
}
public extension ResourceTypes{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: ResourceTypesCodingKeys.self)
         try encoderContainer.encode(attributes, forKey: .attributes)
         try encoderContainer.encode(descriptionValue, forKey: .descriptionValue)
         try encoderContainer.encode(documentation, forKey: .documentation)
         try encoderContainer.encode(properties, forKey: .properties)
    }
}
///  describeResourceTypeListItem
public class DescribeResourceTypeListItem:NSObject,Codable{
    /// Describe
    var describe:String?
    /// 资源类型
    var type:String?



    public override init(){
            super.init()
    }

    enum DescribeResourceTypeListItemCodingKeys: String, CodingKey {
        case describe
        case type
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: DescribeResourceTypeListItemCodingKeys.self)
        if decoderContainer.contains(.describe)
        {
            self.describe = try decoderContainer.decode(String?.self, forKey: .describe)
        }
        if decoderContainer.contains(.type)
        {
            self.type = try decoderContainer.decode(String?.self, forKey: .type)
        }
    }
}
public extension DescribeResourceTypeListItem{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: DescribeResourceTypeListItemCodingKeys.self)
         try encoderContainer.encode(describe, forKey: .describe)
         try encoderContainer.encode(type, forKey: .type)
    }
}
///  PropertyTypeDefinition is the definition of a property
public class PropertyTypeDefinition:NSObject,Codable{
    /// 注释
    var comment:String?
    /// 说明文档地址
    var documentation:String?
    /// 如果 Type 字段的值为 List，则指示 CloudFormation 是否允许重复值。true将忽略重复值，false将对重复值报错
    var duplicatesAllowed:Bool?
    /// 如果 Type 字段的值为 List 或 Map，则指示列表或映射的类型 (如果它们包含非基元类型)
    var itemType:String?
    /// 如果 Type 字段的值为 List 或 Map，则指示列表或映射的类型 (如果它们包含基元类型)
    var primitiveItemType:String?
    /// 基元类型
    var primitiveType:String?
    /// 是否必填
    var required:Bool?
    /// Type
    var type:PropertyItemType?
    /// 更新行为类别
    var updateType:String?



    public override init(){
            super.init()
    }

    enum PropertyTypeDefinitionCodingKeys: String, CodingKey {
        case comment
        case documentation
        case duplicatesAllowed
        case itemType
        case primitiveItemType
        case primitiveType
        case required
        case type
        case updateType
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: PropertyTypeDefinitionCodingKeys.self)
        if decoderContainer.contains(.comment)
        {
            self.comment = try decoderContainer.decode(String?.self, forKey: .comment)
        }
        if decoderContainer.contains(.documentation)
        {
            self.documentation = try decoderContainer.decode(String?.self, forKey: .documentation)
        }
        if decoderContainer.contains(.duplicatesAllowed)
        {
            self.duplicatesAllowed = try decoderContainer.decode(Bool?.self, forKey: .duplicatesAllowed)
        }
        if decoderContainer.contains(.itemType)
        {
            self.itemType = try decoderContainer.decode(String?.self, forKey: .itemType)
        }
        if decoderContainer.contains(.primitiveItemType)
        {
            self.primitiveItemType = try decoderContainer.decode(String?.self, forKey: .primitiveItemType)
        }
        if decoderContainer.contains(.primitiveType)
        {
            self.primitiveType = try decoderContainer.decode(String?.self, forKey: .primitiveType)
        }
        if decoderContainer.contains(.required)
        {
            self.required = try decoderContainer.decode(Bool?.self, forKey: .required)
        }
        if decoderContainer.contains(.type)
        {
            self.type = try decoderContainer.decode(PropertyItemType?.self, forKey: .type)
        }
        if decoderContainer.contains(.updateType)
        {
            self.updateType = try decoderContainer.decode(String?.self, forKey: .updateType)
        }
    }
}
public extension PropertyTypeDefinition{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: PropertyTypeDefinitionCodingKeys.self)
         try encoderContainer.encode(comment, forKey: .comment)
         try encoderContainer.encode(documentation, forKey: .documentation)
         try encoderContainer.encode(duplicatesAllowed, forKey: .duplicatesAllowed)
         try encoderContainer.encode(itemType, forKey: .itemType)
         try encoderContainer.encode(primitiveItemType, forKey: .primitiveItemType)
         try encoderContainer.encode(primitiveType, forKey: .primitiveType)
         try encoderContainer.encode(required, forKey: .required)
         try encoderContainer.encode(type, forKey: .type)
         try encoderContainer.encode(updateType, forKey: .updateType)
    }
}
///  err
public class Err:NSObject,Codable{
    /// Code
    var code:Int64?
    /// Details
    var details:AnyObject?
    /// Message
    var message:String?
    /// Status
    var status:String?



    public override init(){
            super.init()
    }

    enum ErrCodingKeys: String, CodingKey {
        case code
        case details
        case message
        case status
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: ErrCodingKeys.self)
        if decoderContainer.contains(.code)
        {
            self.code = try decoderContainer.decode(Int64?.self, forKey: .code)
        }
        if decoderContainer.contains(.message)
        {
            self.message = try decoderContainer.decode(String?.self, forKey: .message)
        }
        if decoderContainer.contains(.status)
        {
            self.status = try decoderContainer.decode(String?.self, forKey: .status)
        }
    }
}
public extension Err{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: ErrCodingKeys.self)
         try encoderContainer.encode(code, forKey: .code)
         try encoderContainer.encode(message, forKey: .message)
         try encoderContainer.encode(status, forKey: .status)
    }
}

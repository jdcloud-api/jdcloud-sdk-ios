/* Copyright 2018 JDCLOUD.COM

   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at

     http:#www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.

   back source configuration openapi
   back source configuration openapi

   OpenAPI spec version: v1
   Contact: 

   NOTE: This class is auto generated by the jdcloud code generator program.
 */


import Foundation
///  bucketCapacityStatistic
public class BucketCapacityStatistic:NSObject,Codable{
    /// Bucket Name
    /// Required:true
    var bucketName:String
    /// 用量数值，单位Byte
    /// Required:true
    var value:Int64
    /// 时间
    /// Required:true
    var time:String
    /// 用量类型
    /// Required:true
    var capacityType:Int



    public  init(bucketName:String,value:Int64,time:String,capacityType:Int){
             self.bucketName = bucketName
             self.value = value
             self.time = time
             self.capacityType = capacityType
    }

    enum BucketCapacityStatisticCodingKeys: String, CodingKey {
        case bucketName
        case value
        case time
        case capacityType
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: BucketCapacityStatisticCodingKeys.self)
        self.bucketName = try decoderContainer.decode(String.self, forKey: .bucketName)
        self.value = try decoderContainer.decode(Int64.self, forKey: .value)
        self.time = try decoderContainer.decode(String.self, forKey: .time)
        self.capacityType = try decoderContainer.decode(Int.self, forKey: .capacityType)
    }
}
public extension BucketCapacityStatistic{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: BucketCapacityStatisticCodingKeys.self)
         try encoderContainer.encode(bucketName, forKey: .bucketName)
         try encoderContainer.encode(value, forKey: .value)
         try encoderContainer.encode(time, forKey: .time)
         try encoderContainer.encode(capacityType, forKey: .capacityType)
    }
}
///  singleBucketCapacityRequestCondition
public class SingleBucketCapacityRequestCondition:NSObject,Codable{
    /// &lt;p&gt;查询用量数据类型：&lt;/p&gt;&lt;br&gt;&lt;code&gt;1000040&lt;/code&gt;:标准存储&lt;br&gt;&lt;code&gt;1000041&lt;/code&gt;:低冗余存储&lt;br&gt;&lt;code&gt;1000042&lt;/code&gt;:归档存储&lt;br&gt;&lt;code&gt;1000043&lt;/code&gt;归档overHead存储:&lt;br&gt;&lt;code&gt;1000044&lt;/code&gt;低频存储:&lt;br&gt;&lt;code&gt;1000045&lt;/code&gt;低频overHead存储:&lt;br&gt;&lt;code&gt;1&lt;/code&gt;:内网GET流量&lt;br&gt;&lt;code&gt;2&lt;/code&gt;:内网HEAD流量&lt;br&gt;&lt;code&gt;3&lt;/code&gt;:内网PUT流量&lt;br&gt;&lt;code&gt;4&lt;/code&gt;:内网POST流量&lt;br&gt;&lt;code&gt;5&lt;/code&gt;:内网DELETE流量&lt;br&gt;&lt;code&gt;6&lt;/code&gt;:内网OPTIONS流量&lt;br&gt;&lt;code&gt;7&lt;/code&gt;:内网TRACE流量&lt;br&gt;&lt;code&gt;11&lt;/code&gt;:外网GET流量&lt;br&gt;&lt;code&gt;12&lt;/code&gt;:外网HEAD流量&lt;br&gt;&lt;code&gt;13&lt;/code&gt;:外网PUT流量&lt;br&gt;&lt;code&gt;14&lt;/code&gt;:外网POST流量&lt;br&gt;&lt;code&gt;15&lt;/code&gt;:外网DELETE流量&lt;br&gt;&lt;code&gt;16&lt;/code&gt;:外网OPTIONS流量&lt;br&gt;&lt;code&gt;17&lt;/code&gt;:外网TRACE流量&lt;br&gt;&lt;code&gt;21&lt;/code&gt;:CDN GET流量&lt;br&gt;&lt;code&gt;22&lt;/code&gt;:CDN HEAD流量&lt;br&gt;&lt;code&gt;23&lt;/code&gt;:CDN PUT流量&lt;br&gt;&lt;code&gt;24&lt;/code&gt;:CDN POST流量&lt;br&gt;&lt;code&gt;25&lt;/code&gt;:CDN DELETE流量&lt;br&gt;&lt;code&gt;26&lt;/code&gt;:CDN OPTIONS流量&lt;br&gt;&lt;code&gt;27&lt;/code&gt;:CDN TRACE流量&lt;br&gt;&lt;code&gt;31&lt;/code&gt;:内网GET数&lt;br&gt;&lt;code&gt;32&lt;/code&gt;:内网HEAD数&lt;br&gt;&lt;code&gt;33&lt;/code&gt;:内网PUT数&lt;br&gt;&lt;code&gt;34&lt;/code&gt;:内网POST数&lt;br&gt;&lt;code&gt;35&lt;/code&gt;:内网DELETE数&lt;br&gt;&lt;code&gt;36&lt;/code&gt;:内网OPTIONS数&lt;br&gt;&lt;code&gt;37&lt;/code&gt;:内网TRACE数&lt;br&gt;&lt;code&gt;51&lt;/code&gt;:外网GET数&lt;br&gt;&lt;code&gt;52&lt;/code&gt;:外网HEAD数&lt;br&gt;&lt;code&gt;53&lt;/code&gt;:外网PUT数&lt;br&gt;&lt;code&gt;54&lt;/code&gt;:外网POST数&lt;br&gt;&lt;code&gt;55&lt;/code&gt;:外网DELETE数&lt;br&gt;&lt;code&gt;56&lt;/code&gt;:外网OPTIONS数&lt;br&gt;&lt;code&gt;57&lt;/code&gt;:外网TRACE数&lt;br&gt;&lt;code&gt;61&lt;/code&gt;:CDN GET数&lt;br&gt;&lt;code&gt;62&lt;/code&gt;:CDN HEAD数&lt;br&gt;&lt;code&gt;63&lt;/code&gt;:CDN PUT数&lt;br&gt;&lt;code&gt;64&lt;/code&gt;:CDN POST数&lt;br&gt;&lt;code&gt;65&lt;/code&gt;:CDN DELETE数&lt;br&gt;&lt;code&gt;66&lt;/code&gt;:CDN OPTIONS数&lt;br&gt;&lt;code&gt;67&lt;/code&gt;:CDN TRACE数&lt;br&gt;&lt;code&gt;71&lt;/code&gt;:归档提前删除&lt;br&gt;&lt;code&gt;72&lt;/code&gt;:低频提前删除&lt;br&gt;&lt;code&gt;81&lt;/code&gt;:归档取回Bulk&lt;br&gt;&lt;code&gt;82&lt;/code&gt;:归档取回Std&lt;br&gt;&lt;code&gt;83&lt;/code&gt;:归档取回Exp&lt;br&gt;&lt;code&gt;84&lt;/code&gt;:低频数据取回
      /// 
    /// Required:true
    var capacityTypes:[Int?]?
    /// 开始时间，使用UTC时间，格式为：YYYY-MM-DDTHH:mm:ss&#39;Z&#39;
    var beginTime:String?
    /// 结束时间，使用UTC时间，格式为：YYYY-MM-DDTHH:mm:ss&#39;Z&#39;
    var endTime:String?
    /// 查询数据的聚合方式:&lt;br&gt;&lt;code&gt;0&lt;/code&gt;:all, 最大查询区间365天 &lt;br&gt;&lt;code&gt;1&lt;/code&gt;:hour，最大查询区间31天。默认1&lt;br&gt;&lt;code&gt;2&lt;/code&gt;:day, 最大查询区间365天。
    var periodType:Int?
    /// 返回数据的方式： &lt;code&gt;1&lt;/code&gt;:recent(区间值), &lt;code&gt;2&lt;/code&gt;:current(当前值。method &#x3D; 2 时如果查询当前值时传入beginTime，则按照beginTime时间来进行查询；如果不传beginTime，则按照后端系统时间查询。)
    /// Required:true
    var method:Int



    public  init(capacityTypes:[Int?]?,method:Int){
             self.capacityTypes = capacityTypes
             self.method = method
    }

    enum SingleBucketCapacityRequestConditionCodingKeys: String, CodingKey {
        case capacityTypes
        case beginTime
        case endTime
        case periodType
        case method
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: SingleBucketCapacityRequestConditionCodingKeys.self)
        self.capacityTypes = try decoderContainer.decode([Int?]?.self, forKey: .capacityTypes)
        if decoderContainer.contains(.beginTime)
        {
            self.beginTime = try decoderContainer.decode(String?.self, forKey: .beginTime)
        }
        if decoderContainer.contains(.endTime)
        {
            self.endTime = try decoderContainer.decode(String?.self, forKey: .endTime)
        }
        if decoderContainer.contains(.periodType)
        {
            self.periodType = try decoderContainer.decode(Int?.self, forKey: .periodType)
        }
        self.method = try decoderContainer.decode(Int.self, forKey: .method)
    }
}
public extension SingleBucketCapacityRequestCondition{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: SingleBucketCapacityRequestConditionCodingKeys.self)
         try encoderContainer.encode(capacityTypes, forKey: .capacityTypes)
         try encoderContainer.encode(beginTime, forKey: .beginTime)
         try encoderContainer.encode(endTime, forKey: .endTime)
         try encoderContainer.encode(periodType, forKey: .periodType)
         try encoderContainer.encode(method, forKey: .method)
    }
}
///  bucketCapacityCondition
public class BucketCapacityCondition:NSObject,Codable{
    /// &lt;p&gt;查询用量数据类型：&lt;/p&gt;&lt;br&gt;&lt;code&gt;1000040&lt;/code&gt;:标准存储&lt;br&gt;&lt;code&gt;1000041&lt;/code&gt;:低冗余存储&lt;br&gt;&lt;code&gt;1000042&lt;/code&gt;:归档存储&lt;br&gt;&lt;code&gt;1000043&lt;/code&gt;归档overHead存储:&lt;br&gt;&lt;code&gt;1000044&lt;/code&gt;低频存储:&lt;br&gt;&lt;code&gt;1000045&lt;/code&gt;低频overHead存储:&lt;br&gt;&lt;code&gt;1&lt;/code&gt;:内网GET流量&lt;br&gt;&lt;code&gt;2&lt;/code&gt;:内网HEAD流量&lt;br&gt;&lt;code&gt;3&lt;/code&gt;:内网PUT流量&lt;br&gt;&lt;code&gt;4&lt;/code&gt;:内网POST流量&lt;br&gt;&lt;code&gt;5&lt;/code&gt;:内网DELETE流量&lt;br&gt;&lt;code&gt;6&lt;/code&gt;:内网OPTIONS流量&lt;br&gt;&lt;code&gt;7&lt;/code&gt;:内网TRACE流量&lt;br&gt;&lt;code&gt;11&lt;/code&gt;:外网GET流量&lt;br&gt;&lt;code&gt;12&lt;/code&gt;:外网HEAD流量&lt;br&gt;&lt;code&gt;13&lt;/code&gt;:外网PUT流量&lt;br&gt;&lt;code&gt;14&lt;/code&gt;:外网POST流量&lt;br&gt;&lt;code&gt;15&lt;/code&gt;:外网DELETE流量&lt;br&gt;&lt;code&gt;16&lt;/code&gt;:外网OPTIONS流量&lt;br&gt;&lt;code&gt;17&lt;/code&gt;:外网TRACE流量&lt;br&gt;&lt;code&gt;21&lt;/code&gt;:CDN GET流量&lt;br&gt;&lt;code&gt;22&lt;/code&gt;:CDN HEAD流量&lt;br&gt;&lt;code&gt;23&lt;/code&gt;:CDN PUT流量&lt;br&gt;&lt;code&gt;24&lt;/code&gt;:CDN POST流量&lt;br&gt;&lt;code&gt;25&lt;/code&gt;:CDN DELETE流量&lt;br&gt;&lt;code&gt;26&lt;/code&gt;:CDN OPTIONS流量&lt;br&gt;&lt;code&gt;27&lt;/code&gt;:CDN TRACE流量&lt;br&gt;&lt;code&gt;31&lt;/code&gt;:内网GET数&lt;br&gt;&lt;code&gt;32&lt;/code&gt;:内网HEAD数&lt;br&gt;&lt;code&gt;33&lt;/code&gt;:内网PUT数&lt;br&gt;&lt;code&gt;34&lt;/code&gt;:内网POST数&lt;br&gt;&lt;code&gt;35&lt;/code&gt;:内网DELETE数&lt;br&gt;&lt;code&gt;36&lt;/code&gt;:内网OPTIONS数&lt;br&gt;&lt;code&gt;37&lt;/code&gt;:内网TRACE数&lt;br&gt;&lt;code&gt;51&lt;/code&gt;:外网GET数&lt;br&gt;&lt;code&gt;52&lt;/code&gt;:外网HEAD数&lt;br&gt;&lt;code&gt;53&lt;/code&gt;:外网PUT数&lt;br&gt;&lt;code&gt;54&lt;/code&gt;:外网POST数&lt;br&gt;&lt;code&gt;55&lt;/code&gt;:外网DELETE数&lt;br&gt;&lt;code&gt;56&lt;/code&gt;:外网OPTIONS数&lt;br&gt;&lt;code&gt;57&lt;/code&gt;:外网TRACE数&lt;br&gt;&lt;code&gt;61&lt;/code&gt;:CDN GET数&lt;br&gt;&lt;code&gt;62&lt;/code&gt;:CDN HEAD数&lt;br&gt;&lt;code&gt;63&lt;/code&gt;:CDN PUT数&lt;br&gt;&lt;code&gt;64&lt;/code&gt;:CDN POST数&lt;br&gt;&lt;code&gt;65&lt;/code&gt;:CDN DELETE数&lt;br&gt;&lt;code&gt;66&lt;/code&gt;:CDN OPTIONS数&lt;br&gt;&lt;code&gt;67&lt;/code&gt;:CDN TRACE数&lt;br&gt;&lt;code&gt;71&lt;/code&gt;:归档提前删除&lt;br&gt;&lt;code&gt;72&lt;/code&gt;:低频提前删除&lt;br&gt;&lt;code&gt;81&lt;/code&gt;:归档取回Bulk&lt;br&gt;&lt;code&gt;82&lt;/code&gt;:归档取回Std&lt;br&gt;&lt;code&gt;83&lt;/code&gt;:归档取回Exp&lt;br&gt;&lt;code&gt;84&lt;/code&gt;:低频数据取回
      /// 
    /// Required:true
    var capacityTypes:[Int?]?
    /// 开始时间，使用UTC时间，格式为：YYYY-MM-DDTHH:mm:ss&#39;Z&#39;
    var beginTime:String?
    /// 结束时间，使用UTC时间，格式为：YYYY-MM-DDTHH:mm:ss&#39;Z&#39;
    var endTime:String?
    /// 查询数据的聚合方式:&lt;br&gt;&lt;code&gt;0&lt;/code&gt;:all, 最大查询区间365天 &lt;br&gt;&lt;code&gt;1&lt;/code&gt;:hour，最大查询区间31天。默认1&lt;br&gt;&lt;code&gt;2&lt;/code&gt;:day, 最大查询区间365天。
    var periodType:Int?
    /// 返回数据的方式： &lt;code&gt;1&lt;/code&gt;:recent(区间值), &lt;code&gt;2&lt;/code&gt;:current(当前值。method &#x3D; 2 时如果查询当前值时传入beginTime，则按照beginTime时间来进行查询；如果不传beginTime，则按照后端系统时间查询。)
    /// Required:true
    var method:Int
    /// 查询的bucket Names。如果查询用户全部Bucket,则不传
    var bucketNames:[String?]?



    public  init(capacityTypes:[Int?]?,method:Int){
             self.capacityTypes = capacityTypes
             self.method = method
    }

    enum BucketCapacityConditionCodingKeys: String, CodingKey {
        case capacityTypes
        case beginTime
        case endTime
        case periodType
        case method
        case bucketNames
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: BucketCapacityConditionCodingKeys.self)
        self.capacityTypes = try decoderContainer.decode([Int?]?.self, forKey: .capacityTypes)
        if decoderContainer.contains(.beginTime)
        {
            self.beginTime = try decoderContainer.decode(String?.self, forKey: .beginTime)
        }
        if decoderContainer.contains(.endTime)
        {
            self.endTime = try decoderContainer.decode(String?.self, forKey: .endTime)
        }
        if decoderContainer.contains(.periodType)
        {
            self.periodType = try decoderContainer.decode(Int?.self, forKey: .periodType)
        }
        self.method = try decoderContainer.decode(Int.self, forKey: .method)
        if decoderContainer.contains(.bucketNames)
        {
            self.bucketNames = try decoderContainer.decode([String?]?.self, forKey: .bucketNames)
        }
    }
}
public extension BucketCapacityCondition{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: BucketCapacityConditionCodingKeys.self)
         try encoderContainer.encode(capacityTypes, forKey: .capacityTypes)
         try encoderContainer.encode(beginTime, forKey: .beginTime)
         try encoderContainer.encode(endTime, forKey: .endTime)
         try encoderContainer.encode(periodType, forKey: .periodType)
         try encoderContainer.encode(method, forKey: .method)
         try encoderContainer.encode(bucketNames, forKey: .bucketNames)
    }
}
///  bucketCapacityQueryResult
public class BucketCapacityQueryResult:NSObject,Codable{
    /// bucket 用量统计列表
    var resultList:[BucketCapacityStatistic?]?



    public override init(){
            super.init()
    }

    enum BucketCapacityQueryResultCodingKeys: String, CodingKey {
        case resultList
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: BucketCapacityQueryResultCodingKeys.self)
        if decoderContainer.contains(.resultList)
        {
            self.resultList = try decoderContainer.decode([BucketCapacityStatistic?]?.self, forKey: .resultList)
        }
    }
}
public extension BucketCapacityQueryResult{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: BucketCapacityQueryResultCodingKeys.self)
         try encoderContainer.encode(resultList, forKey: .resultList)
    }
}
///  cNameQueryResult
public class CNameQueryResult:NSObject,Codable{
    /// 查询结果总数
    var totalCount:Int?
    /// ResultList
    var resultList:[CName?]?



    public override init(){
            super.init()
    }

    enum CNameQueryResultCodingKeys: String, CodingKey {
        case totalCount
        case resultList
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: CNameQueryResultCodingKeys.self)
        if decoderContainer.contains(.totalCount)
        {
            self.totalCount = try decoderContainer.decode(Int?.self, forKey: .totalCount)
        }
        if decoderContainer.contains(.resultList)
        {
            self.resultList = try decoderContainer.decode([CName?]?.self, forKey: .resultList)
        }
    }
}
public extension CNameQueryResult{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: CNameQueryResultCodingKeys.self)
         try encoderContainer.encode(totalCount, forKey: .totalCount)
         try encoderContainer.encode(resultList, forKey: .resultList)
    }
}
///  cName
public class CName:NSObject,Codable{
    /// 自定义域名id
    var id:Int?
    /// 用户pin
    var pin:String?
    /// 源站域名
    var originDomain:String?
    /// 自定义域名
    var cname:String?
    /// 自定义域名状态
    var status:Int?
    /// bucket name
    var bucketName:String?
    /// cname是否成功，1：已解析；0:未解析
    var isCName:Int?
    /// 创建时间
    var createTime:String?
    /// http版本，0：http，1：https
    var protoType:Int?



    public override init(){
            super.init()
    }

    enum CNameCodingKeys: String, CodingKey {
        case id
        case pin
        case originDomain
        case cname
        case status
        case bucketName
        case isCName
        case createTime
        case protoType
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: CNameCodingKeys.self)
        if decoderContainer.contains(.id)
        {
            self.id = try decoderContainer.decode(Int?.self, forKey: .id)
        }
        if decoderContainer.contains(.pin)
        {
            self.pin = try decoderContainer.decode(String?.self, forKey: .pin)
        }
        if decoderContainer.contains(.originDomain)
        {
            self.originDomain = try decoderContainer.decode(String?.self, forKey: .originDomain)
        }
        if decoderContainer.contains(.cname)
        {
            self.cname = try decoderContainer.decode(String?.self, forKey: .cname)
        }
        if decoderContainer.contains(.status)
        {
            self.status = try decoderContainer.decode(Int?.self, forKey: .status)
        }
        if decoderContainer.contains(.bucketName)
        {
            self.bucketName = try decoderContainer.decode(String?.self, forKey: .bucketName)
        }
        if decoderContainer.contains(.isCName)
        {
            self.isCName = try decoderContainer.decode(Int?.self, forKey: .isCName)
        }
        if decoderContainer.contains(.createTime)
        {
            self.createTime = try decoderContainer.decode(String?.self, forKey: .createTime)
        }
        if decoderContainer.contains(.protoType)
        {
            self.protoType = try decoderContainer.decode(Int?.self, forKey: .protoType)
        }
    }
}
public extension CName{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: CNameCodingKeys.self)
         try encoderContainer.encode(id, forKey: .id)
         try encoderContainer.encode(pin, forKey: .pin)
         try encoderContainer.encode(originDomain, forKey: .originDomain)
         try encoderContainer.encode(cname, forKey: .cname)
         try encoderContainer.encode(status, forKey: .status)
         try encoderContainer.encode(bucketName, forKey: .bucketName)
         try encoderContainer.encode(isCName, forKey: .isCName)
         try encoderContainer.encode(createTime, forKey: .createTime)
         try encoderContainer.encode(protoType, forKey: .protoType)
    }
}
///  cNameInfo
public class CNameInfo:NSObject,Codable{
    /// 自定义域名
    /// Required:true
    var cname:String
    /// http版本，0：http，1：https
    var protoType:Int?
    /// 域名
    /// Required:true
    var endPoint:String
    /// 是否拦截内部域名添，任意值跳过拦截
    var internalValue:String?



    public  init(cname:String,endPoint:String){
             self.cname = cname
             self.endPoint = endPoint
    }

    enum CNameInfoCodingKeys: String, CodingKey {
        case cname
        case protoType
        case endPoint
        case internalValue = "internal"
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: CNameInfoCodingKeys.self)
        self.cname = try decoderContainer.decode(String.self, forKey: .cname)
        if decoderContainer.contains(.protoType)
        {
            self.protoType = try decoderContainer.decode(Int?.self, forKey: .protoType)
        }
        self.endPoint = try decoderContainer.decode(String.self, forKey: .endPoint)
        if decoderContainer.contains(.internalValue)
        {
            self.internalValue = try decoderContainer.decode(String?.self, forKey: .internalValue)
        }
    }
}
public extension CNameInfo{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: CNameInfoCodingKeys.self)
         try encoderContainer.encode(cname, forKey: .cname)
         try encoderContainer.encode(protoType, forKey: .protoType)
         try encoderContainer.encode(endPoint, forKey: .endPoint)
         try encoderContainer.encode(internalValue, forKey: .internalValue)
    }
}
///  userBillCode
public class UserBillCode:NSObject,Codable{
    /// 用户的AppCode
    var appCode:String?
    /// 用户的ServiceCode
    var serviceCode:String?
    /// 用户的StorageResourceType
    var storageResourceType:String?
    /// 用户的ProcessResourceType
    var processResourceType:String?



    public override init(){
            super.init()
    }

    enum UserBillCodeCodingKeys: String, CodingKey {
        case appCode
        case serviceCode
        case storageResourceType
        case processResourceType
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: UserBillCodeCodingKeys.self)
        if decoderContainer.contains(.appCode)
        {
            self.appCode = try decoderContainer.decode(String?.self, forKey: .appCode)
        }
        if decoderContainer.contains(.serviceCode)
        {
            self.serviceCode = try decoderContainer.decode(String?.self, forKey: .serviceCode)
        }
        if decoderContainer.contains(.storageResourceType)
        {
            self.storageResourceType = try decoderContainer.decode(String?.self, forKey: .storageResourceType)
        }
        if decoderContainer.contains(.processResourceType)
        {
            self.processResourceType = try decoderContainer.decode(String?.self, forKey: .processResourceType)
        }
    }
}
public extension UserBillCode{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: UserBillCodeCodingKeys.self)
         try encoderContainer.encode(appCode, forKey: .appCode)
         try encoderContainer.encode(serviceCode, forKey: .serviceCode)
         try encoderContainer.encode(storageResourceType, forKey: .storageResourceType)
         try encoderContainer.encode(processResourceType, forKey: .processResourceType)
    }
}
///  imageExtensions
public class ImageExtensions:NSObject,Codable{
    /// 原图保护图像格式列表，符合固定XML格式，例如\&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;\&lt;Condition&gt;\&lt;Extension&gt;jpg\&lt;/Extension&gt;\&lt;/Condition&gt;
    /// Required:true
    var imageExtensionsValue:String



    public  init(imageExtensionsValue:String){
             self.imageExtensionsValue = imageExtensionsValue
    }

    enum ImageExtensionsCodingKeys: String, CodingKey {
        case imageExtensionsValue = "imageExtensions"
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: ImageExtensionsCodingKeys.self)
        self.imageExtensionsValue = try decoderContainer.decode(String.self, forKey: .imageExtensionsValue)
    }
}
public extension ImageExtensions{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: ImageExtensionsCodingKeys.self)
         try encoderContainer.encode(imageExtensionsValue, forKey: .imageExtensionsValue)
    }
}
///  bucketSpaceStatisticQueryResult
public class BucketSpaceStatisticQueryResult:NSObject,Codable{
    /// 查询结果总数
    var totalCount:Int?
    /// bucket 统计列表
    var queryList:[BucketSpaceStatistic?]?



    public override init(){
            super.init()
    }

    enum BucketSpaceStatisticQueryResultCodingKeys: String, CodingKey {
        case totalCount
        case queryList
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: BucketSpaceStatisticQueryResultCodingKeys.self)
        if decoderContainer.contains(.totalCount)
        {
            self.totalCount = try decoderContainer.decode(Int?.self, forKey: .totalCount)
        }
        if decoderContainer.contains(.queryList)
        {
            self.queryList = try decoderContainer.decode([BucketSpaceStatistic?]?.self, forKey: .queryList)
        }
    }
}
public extension BucketSpaceStatisticQueryResult{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: BucketSpaceStatisticQueryResultCodingKeys.self)
         try encoderContainer.encode(totalCount, forKey: .totalCount)
         try encoderContainer.encode(queryList, forKey: .queryList)
    }
}
///  bucketMonitorStatistic
public class BucketMonitorStatistic:NSObject,Codable{
    /// bucket name
    /// Required:true
    var bucketName:String
    /// 统计数值
    /// Required:true
    var count:Int64
    /// 时间
    /// Required:true
    var time:String



    public  init(bucketName:String,count:Int64,time:String){
             self.bucketName = bucketName
             self.count = count
             self.time = time
    }

    enum BucketMonitorStatisticCodingKeys: String, CodingKey {
        case bucketName
        case count
        case time
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: BucketMonitorStatisticCodingKeys.self)
        self.bucketName = try decoderContainer.decode(String.self, forKey: .bucketName)
        self.count = try decoderContainer.decode(Int64.self, forKey: .count)
        self.time = try decoderContainer.decode(String.self, forKey: .time)
    }
}
public extension BucketMonitorStatistic{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: BucketMonitorStatisticCodingKeys.self)
         try encoderContainer.encode(bucketName, forKey: .bucketName)
         try encoderContainer.encode(count, forKey: .count)
         try encoderContainer.encode(time, forKey: .time)
    }
}
///  bucketSpaceStatistic
public class BucketSpaceStatistic:NSObject,Codable{
    /// bucket name
    /// Required:true
    var bucketName:String
    /// bucket 存储空间
    /// Required:true
    var space:Int64



    public  init(bucketName:String,space:Int64){
             self.bucketName = bucketName
             self.space = space
    }

    enum BucketSpaceStatisticCodingKeys: String, CodingKey {
        case bucketName
        case space
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: BucketSpaceStatisticCodingKeys.self)
        self.bucketName = try decoderContainer.decode(String.self, forKey: .bucketName)
        self.space = try decoderContainer.decode(Int64.self, forKey: .space)
    }
}
public extension BucketSpaceStatistic{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: BucketSpaceStatisticCodingKeys.self)
         try encoderContainer.encode(bucketName, forKey: .bucketName)
         try encoderContainer.encode(space, forKey: .space)
    }
}
///  bucketMonitorStatisticQueryResult
public class BucketMonitorStatisticQueryResult:NSObject,Codable{
    /// 查询结果总数
    var totalCount:Int?
    /// bucket 统计列表
    var queryList:[BucketMonitorStatistic?]?



    public override init(){
            super.init()
    }

    enum BucketMonitorStatisticQueryResultCodingKeys: String, CodingKey {
        case totalCount
        case queryList
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: BucketMonitorStatisticQueryResultCodingKeys.self)
        if decoderContainer.contains(.totalCount)
        {
            self.totalCount = try decoderContainer.decode(Int?.self, forKey: .totalCount)
        }
        if decoderContainer.contains(.queryList)
        {
            self.queryList = try decoderContainer.decode([BucketMonitorStatistic?]?.self, forKey: .queryList)
        }
    }
}
public extension BucketMonitorStatisticQueryResult{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: BucketMonitorStatisticQueryResultCodingKeys.self)
         try encoderContainer.encode(totalCount, forKey: .totalCount)
         try encoderContainer.encode(queryList, forKey: .queryList)
    }
}
///  iCP
public class ICP:NSObject,Codable{
    /// true为备案，false为未备案
    var icp:Bool?



    public override init(){
            super.init()
    }

    enum ICPCodingKeys: String, CodingKey {
        case icp
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: ICPCodingKeys.self)
        if decoderContainer.contains(.icp)
        {
            self.icp = try decoderContainer.decode(Bool?.self, forKey: .icp)
        }
    }
}
public extension ICP{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: ICPCodingKeys.self)
         try encoderContainer.encode(icp, forKey: .icp)
    }
}
///  signatureInfo
public class SignatureInfo:NSObject,Codable{
    /// 签名的endpoint, 例如 http://s3.cn-east-1.jcloudcs.com
    /// Required:true
    var endpoint:String
    /// http method
    /// Required:true
    var httpMethod:String
    /// 资源路径,不包含query string
    /// Required:true
    var resourcePath:String
    /// 上传文件的sha256
    /// Required:true
    var xAmzContentSha256:String
    /// 附加的签名header
    var additionalSignatureHeaders:[String:String?]?
    /// 签名的参数，query string
    var signatureParameters:[String:String?]?



    public  init(endpoint:String,httpMethod:String,resourcePath:String,xAmzContentSha256:String){
             self.endpoint = endpoint
             self.httpMethod = httpMethod
             self.resourcePath = resourcePath
             self.xAmzContentSha256 = xAmzContentSha256
    }

    enum SignatureInfoCodingKeys: String, CodingKey {
        case endpoint
        case httpMethod
        case resourcePath
        case xAmzContentSha256
        case additionalSignatureHeaders
        case signatureParameters
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: SignatureInfoCodingKeys.self)
        self.endpoint = try decoderContainer.decode(String.self, forKey: .endpoint)
        self.httpMethod = try decoderContainer.decode(String.self, forKey: .httpMethod)
        self.resourcePath = try decoderContainer.decode(String.self, forKey: .resourcePath)
        self.xAmzContentSha256 = try decoderContainer.decode(String.self, forKey: .xAmzContentSha256)
        if decoderContainer.contains(.additionalSignatureHeaders)
        {
            self.additionalSignatureHeaders = try decoderContainer.decode([String:String?]?.self, forKey: .additionalSignatureHeaders)
        }
        if decoderContainer.contains(.signatureParameters)
        {
            self.signatureParameters = try decoderContainer.decode([String:String?]?.self, forKey: .signatureParameters)
        }
    }
}
public extension SignatureInfo{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: SignatureInfoCodingKeys.self)
         try encoderContainer.encode(endpoint, forKey: .endpoint)
         try encoderContainer.encode(httpMethod, forKey: .httpMethod)
         try encoderContainer.encode(resourcePath, forKey: .resourcePath)
         try encoderContainer.encode(xAmzContentSha256, forKey: .xAmzContentSha256)
         try encoderContainer.encode(additionalSignatureHeaders, forKey: .additionalSignatureHeaders)
         try encoderContainer.encode(signatureParameters, forKey: .signatureParameters)
    }
}
///  signatureResult
public class SignatureResult:NSObject,Codable{
    /// 签名的endpoint, 例如 http://s3.cn-east-1.jcloudcs.com
    var endpoint:String?
    /// http method
    var httpMethod:String?
    /// 资源路径
    var resourcePath:String?
    /// 时间, 由openapi返回
    var xAmzDate:String?
    /// content hash
    var xAmzContentSha256:String?
    /// 用户pin
    var xAmzMetaRequesterPin:String?
    /// 用户userId
    var xAmzMetaRequesterId:String?
    /// 附加的签名header
    var additionalSignatureHeaders:[String:String?]?
    /// 签名的参数，query string
    var signatureParameters:[String:String?]?
    /// authorization信息, 由openapi计算返回
    var authorization:String?



    public override init(){
            super.init()
    }

    enum SignatureResultCodingKeys: String, CodingKey {
        case endpoint
        case httpMethod
        case resourcePath
        case xAmzDate
        case xAmzContentSha256
        case xAmzMetaRequesterPin
        case xAmzMetaRequesterId
        case additionalSignatureHeaders
        case signatureParameters
        case authorization
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: SignatureResultCodingKeys.self)
        if decoderContainer.contains(.endpoint)
        {
            self.endpoint = try decoderContainer.decode(String?.self, forKey: .endpoint)
        }
        if decoderContainer.contains(.httpMethod)
        {
            self.httpMethod = try decoderContainer.decode(String?.self, forKey: .httpMethod)
        }
        if decoderContainer.contains(.resourcePath)
        {
            self.resourcePath = try decoderContainer.decode(String?.self, forKey: .resourcePath)
        }
        if decoderContainer.contains(.xAmzDate)
        {
            self.xAmzDate = try decoderContainer.decode(String?.self, forKey: .xAmzDate)
        }
        if decoderContainer.contains(.xAmzContentSha256)
        {
            self.xAmzContentSha256 = try decoderContainer.decode(String?.self, forKey: .xAmzContentSha256)
        }
        if decoderContainer.contains(.xAmzMetaRequesterPin)
        {
            self.xAmzMetaRequesterPin = try decoderContainer.decode(String?.self, forKey: .xAmzMetaRequesterPin)
        }
        if decoderContainer.contains(.xAmzMetaRequesterId)
        {
            self.xAmzMetaRequesterId = try decoderContainer.decode(String?.self, forKey: .xAmzMetaRequesterId)
        }
        if decoderContainer.contains(.additionalSignatureHeaders)
        {
            self.additionalSignatureHeaders = try decoderContainer.decode([String:String?]?.self, forKey: .additionalSignatureHeaders)
        }
        if decoderContainer.contains(.signatureParameters)
        {
            self.signatureParameters = try decoderContainer.decode([String:String?]?.self, forKey: .signatureParameters)
        }
        if decoderContainer.contains(.authorization)
        {
            self.authorization = try decoderContainer.decode(String?.self, forKey: .authorization)
        }
    }
}
public extension SignatureResult{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: SignatureResultCodingKeys.self)
         try encoderContainer.encode(endpoint, forKey: .endpoint)
         try encoderContainer.encode(httpMethod, forKey: .httpMethod)
         try encoderContainer.encode(resourcePath, forKey: .resourcePath)
         try encoderContainer.encode(xAmzDate, forKey: .xAmzDate)
         try encoderContainer.encode(xAmzContentSha256, forKey: .xAmzContentSha256)
         try encoderContainer.encode(xAmzMetaRequesterPin, forKey: .xAmzMetaRequesterPin)
         try encoderContainer.encode(xAmzMetaRequesterId, forKey: .xAmzMetaRequesterId)
         try encoderContainer.encode(additionalSignatureHeaders, forKey: .additionalSignatureHeaders)
         try encoderContainer.encode(signatureParameters, forKey: .signatureParameters)
         try encoderContainer.encode(authorization, forKey: .authorization)
    }
}
///  回源地址
public class BackSourceAddress:NSObject,Codable{
    /// 地址协议, 如http
    var protocolValue:String?
    /// 域名
    var hostName:String?
    /// 将前缀替换为指定的内容
    var replaceKeyPrefixWith:String?
    /// 将key替换为指定内容
    var replaceKeyWith:String?
    /// 将后缀替换为指定的内容
    var replaceKeySuffixWith:String?



    public override init(){
            super.init()
    }

    enum BackSourceAddressCodingKeys: String, CodingKey {
        case protocolValue = "protocol"
        case hostName
        case replaceKeyPrefixWith
        case replaceKeyWith
        case replaceKeySuffixWith
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: BackSourceAddressCodingKeys.self)
        if decoderContainer.contains(.protocolValue)
        {
            self.protocolValue = try decoderContainer.decode(String?.self, forKey: .protocolValue)
        }
        if decoderContainer.contains(.hostName)
        {
            self.hostName = try decoderContainer.decode(String?.self, forKey: .hostName)
        }
        if decoderContainer.contains(.replaceKeyPrefixWith)
        {
            self.replaceKeyPrefixWith = try decoderContainer.decode(String?.self, forKey: .replaceKeyPrefixWith)
        }
        if decoderContainer.contains(.replaceKeyWith)
        {
            self.replaceKeyWith = try decoderContainer.decode(String?.self, forKey: .replaceKeyWith)
        }
        if decoderContainer.contains(.replaceKeySuffixWith)
        {
            self.replaceKeySuffixWith = try decoderContainer.decode(String?.self, forKey: .replaceKeySuffixWith)
        }
    }
}
public extension BackSourceAddress{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: BackSourceAddressCodingKeys.self)
         try encoderContainer.encode(protocolValue, forKey: .protocolValue)
         try encoderContainer.encode(hostName, forKey: .hostName)
         try encoderContainer.encode(replaceKeyPrefixWith, forKey: .replaceKeyPrefixWith)
         try encoderContainer.encode(replaceKeyWith, forKey: .replaceKeyWith)
         try encoderContainer.encode(replaceKeySuffixWith, forKey: .replaceKeySuffixWith)
    }
}
///  回源规则
public class BackSourceRule:NSObject,Codable{
    /// 回源类型
    var backSourceType:String?
    /// Condition
    var condition:BackSourceRuleCondition?
    /// Address
    var address:BackSourceAddress?
    /// 是否允许query String
    var allowQueryString:Bool?
    /// 是否跟随重定向
    var followRedirects:Bool?
    /// HeaderRule
    var headerRule:BackSourceHeaderRule?



    public override init(){
            super.init()
    }

    enum BackSourceRuleCodingKeys: String, CodingKey {
        case backSourceType
        case condition
        case address
        case allowQueryString
        case followRedirects
        case headerRule
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: BackSourceRuleCodingKeys.self)
        if decoderContainer.contains(.backSourceType)
        {
            self.backSourceType = try decoderContainer.decode(String?.self, forKey: .backSourceType)
        }
        if decoderContainer.contains(.condition)
        {
            self.condition = try decoderContainer.decode(BackSourceRuleCondition?.self, forKey: .condition)
        }
        if decoderContainer.contains(.address)
        {
            self.address = try decoderContainer.decode(BackSourceAddress?.self, forKey: .address)
        }
        if decoderContainer.contains(.allowQueryString)
        {
            self.allowQueryString = try decoderContainer.decode(Bool?.self, forKey: .allowQueryString)
        }
        if decoderContainer.contains(.followRedirects)
        {
            self.followRedirects = try decoderContainer.decode(Bool?.self, forKey: .followRedirects)
        }
        if decoderContainer.contains(.headerRule)
        {
            self.headerRule = try decoderContainer.decode(BackSourceHeaderRule?.self, forKey: .headerRule)
        }
    }
}
public extension BackSourceRule{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: BackSourceRuleCodingKeys.self)
         try encoderContainer.encode(backSourceType, forKey: .backSourceType)
         try encoderContainer.encode(condition, forKey: .condition)
         try encoderContainer.encode(address, forKey: .address)
         try encoderContainer.encode(allowQueryString, forKey: .allowQueryString)
         try encoderContainer.encode(followRedirects, forKey: .followRedirects)
         try encoderContainer.encode(headerRule, forKey: .headerRule)
    }
}
///  bucket回源配置
public class BucketBackSourceConfiguration:NSObject,Codable{
    /// 回源配置规则
    var backSourceRules:[BackSourceRule?]?



    public override init(){
            super.init()
    }

    enum BucketBackSourceConfigurationCodingKeys: String, CodingKey {
        case backSourceRules
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: BucketBackSourceConfigurationCodingKeys.self)
        if decoderContainer.contains(.backSourceRules)
        {
            self.backSourceRules = try decoderContainer.decode([BackSourceRule?]?.self, forKey: .backSourceRules)
        }
    }
}
public extension BucketBackSourceConfiguration{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: BucketBackSourceConfigurationCodingKeys.self)
         try encoderContainer.encode(backSourceRules, forKey: .backSourceRules)
    }
}
///  回源的header规则
public class BackSourceHeaderRule:NSObject,Codable{
    /// 是否允许所有的Http header
    var allowAllHeaders:Bool?
    /// 允许的http header列表
    var allowHeaders:[String?]?
    /// 禁止的http header列表
    var notAllowHeaders:[String?]?
    /// 设置指定http header参数，类型为Map\&lt;String, String&gt;
    var setHeaders:[String:String?]?



    public override init(){
            super.init()
    }

    enum BackSourceHeaderRuleCodingKeys: String, CodingKey {
        case allowAllHeaders
        case allowHeaders
        case notAllowHeaders
        case setHeaders
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: BackSourceHeaderRuleCodingKeys.self)
        if decoderContainer.contains(.allowAllHeaders)
        {
            self.allowAllHeaders = try decoderContainer.decode(Bool?.self, forKey: .allowAllHeaders)
        }
        if decoderContainer.contains(.allowHeaders)
        {
            self.allowHeaders = try decoderContainer.decode([String?]?.self, forKey: .allowHeaders)
        }
        if decoderContainer.contains(.notAllowHeaders)
        {
            self.notAllowHeaders = try decoderContainer.decode([String?]?.self, forKey: .notAllowHeaders)
        }
        if decoderContainer.contains(.setHeaders)
        {
            self.setHeaders = try decoderContainer.decode([String:String?]?.self, forKey: .setHeaders)
        }
    }
}
public extension BackSourceHeaderRule{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: BackSourceHeaderRuleCodingKeys.self)
         try encoderContainer.encode(allowAllHeaders, forKey: .allowAllHeaders)
         try encoderContainer.encode(allowHeaders, forKey: .allowHeaders)
         try encoderContainer.encode(notAllowHeaders, forKey: .notAllowHeaders)
         try encoderContainer.encode(setHeaders, forKey: .setHeaders)
    }
}
///  backSourceRuleCondition
public class BackSourceRuleCondition:NSObject,Codable{
    /// 当前缀为指定的前缀时开启回源
    var keyPrefixEquals:String?
    /// 当http错误码为指定错误码时开启回源
    var httpErrorCodeReturnedEquals:Int?



    public override init(){
            super.init()
    }

    enum BackSourceRuleConditionCodingKeys: String, CodingKey {
        case keyPrefixEquals
        case httpErrorCodeReturnedEquals
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: BackSourceRuleConditionCodingKeys.self)
        if decoderContainer.contains(.keyPrefixEquals)
        {
            self.keyPrefixEquals = try decoderContainer.decode(String?.self, forKey: .keyPrefixEquals)
        }
        if decoderContainer.contains(.httpErrorCodeReturnedEquals)
        {
            self.httpErrorCodeReturnedEquals = try decoderContainer.decode(Int?.self, forKey: .httpErrorCodeReturnedEquals)
        }
    }
}
public extension BackSourceRuleCondition{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: BackSourceRuleConditionCodingKeys.self)
         try encoderContainer.encode(keyPrefixEquals, forKey: .keyPrefixEquals)
         try encoderContainer.encode(httpErrorCodeReturnedEquals, forKey: .httpErrorCodeReturnedEquals)
    }
}

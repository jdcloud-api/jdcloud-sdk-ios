/* Copyright 2018 JDCLOUD.COM

   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at

     http:#www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.

   实例管理
   API related to MONGODB instances

   OpenAPI spec version: v1
   Contact: 

   NOTE: This class is auto generated by the jdcloud code generator program.
 */


import Foundation
import JDCloudSDKCharge
///  backup
public class Backup:NSObject,Codable{
    /// 备份ID
    var backupId:String?
    /// 备份名称
    var backupName:String?
    /// 备份所属实例ID
    var instanceId:String?
    /// 备份状态，Waiting(等待中)、Running(备份中)、Finished(已完成)、(Failed错误)
    var backupStatus:String?
    /// 备份开始时间
    var backupStartTime:String?
    /// 备份结束时间
    var backupEndTime:String?
    /// 备份模式，Automated(系统自动备份)、Manual(手动备份)
    var backupMode:String?
    /// 整个备份集大小，单位：Byte
    var backupSizeByte:Int?



    public override init(){
            super.init()
    }

    enum BackupCodingKeys: String, CodingKey {
        case backupId
        case backupName
        case instanceId
        case backupStatus
        case backupStartTime
        case backupEndTime
        case backupMode
        case backupSizeByte
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: BackupCodingKeys.self)
        if decoderContainer.contains(.backupId)
        {
            self.backupId = try decoderContainer.decode(String?.self, forKey: .backupId)
        }
        if decoderContainer.contains(.backupName)
        {
            self.backupName = try decoderContainer.decode(String?.self, forKey: .backupName)
        }
        if decoderContainer.contains(.instanceId)
        {
            self.instanceId = try decoderContainer.decode(String?.self, forKey: .instanceId)
        }
        if decoderContainer.contains(.backupStatus)
        {
            self.backupStatus = try decoderContainer.decode(String?.self, forKey: .backupStatus)
        }
        if decoderContainer.contains(.backupStartTime)
        {
            self.backupStartTime = try decoderContainer.decode(String?.self, forKey: .backupStartTime)
        }
        if decoderContainer.contains(.backupEndTime)
        {
            self.backupEndTime = try decoderContainer.decode(String?.self, forKey: .backupEndTime)
        }
        if decoderContainer.contains(.backupMode)
        {
            self.backupMode = try decoderContainer.decode(String?.self, forKey: .backupMode)
        }
        if decoderContainer.contains(.backupSizeByte)
        {
            self.backupSizeByte = try decoderContainer.decode(Int?.self, forKey: .backupSizeByte)
        }
    }
}
public extension Backup{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: BackupCodingKeys.self)
         try encoderContainer.encode(backupId, forKey: .backupId)
         try encoderContainer.encode(backupName, forKey: .backupName)
         try encoderContainer.encode(instanceId, forKey: .instanceId)
         try encoderContainer.encode(backupStatus, forKey: .backupStatus)
         try encoderContainer.encode(backupStartTime, forKey: .backupStartTime)
         try encoderContainer.encode(backupEndTime, forKey: .backupEndTime)
         try encoderContainer.encode(backupMode, forKey: .backupMode)
         try encoderContainer.encode(backupSizeByte, forKey: .backupSizeByte)
    }
}
///  backupDownloadURL
public class BackupDownloadURL:NSObject,Codable{
    /// 备份名称
    var backupName:String?
    /// 公网下载链接的地址
    var backupInternetDownloadURL:String?
    /// 内网下载链接的地址
    var backupIntranetDownloadURL:String?
    /// 公网和内网的下载链接过期时间
    var linkExpiredTime:String?



    public override init(){
            super.init()
    }

    enum BackupDownloadURLCodingKeys: String, CodingKey {
        case backupName
        case backupInternetDownloadURL
        case backupIntranetDownloadURL
        case linkExpiredTime
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: BackupDownloadURLCodingKeys.self)
        if decoderContainer.contains(.backupName)
        {
            self.backupName = try decoderContainer.decode(String?.self, forKey: .backupName)
        }
        if decoderContainer.contains(.backupInternetDownloadURL)
        {
            self.backupInternetDownloadURL = try decoderContainer.decode(String?.self, forKey: .backupInternetDownloadURL)
        }
        if decoderContainer.contains(.backupIntranetDownloadURL)
        {
            self.backupIntranetDownloadURL = try decoderContainer.decode(String?.self, forKey: .backupIntranetDownloadURL)
        }
        if decoderContainer.contains(.linkExpiredTime)
        {
            self.linkExpiredTime = try decoderContainer.decode(String?.self, forKey: .linkExpiredTime)
        }
    }
}
public extension BackupDownloadURL{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: BackupDownloadURLCodingKeys.self)
         try encoderContainer.encode(backupName, forKey: .backupName)
         try encoderContainer.encode(backupInternetDownloadURL, forKey: .backupInternetDownloadURL)
         try encoderContainer.encode(backupIntranetDownloadURL, forKey: .backupIntranetDownloadURL)
         try encoderContainer.encode(linkExpiredTime, forKey: .linkExpiredTime)
    }
}
///  backupSynchronicity
public class BackupSynchronicity:NSObject,Codable{
    /// 跨地域备份同步服务ID
    var serviceId:String?
    /// MongoDB 实例ID
    var instanceId:String?
    /// MongoDB 实例名称
    var instanceName:String?
    /// 跨地域备份同步服务状态，正常，running；错误，error
    var serviceStatus:String?
    /// 源实例所在地域
    var srcRegion:String?
    /// 跨地域备份同步服务的目的地域
    var dstRegion:String?
    /// 数据库类型
    var engine:String?
    /// 数据库版本
    var engineVersion:String?
    /// 创建时间
    var createTime:String?
    /// 跨地域备份的最新数据时间点
    var newestDataTime:String?



    public override init(){
            super.init()
    }

    enum BackupSynchronicityCodingKeys: String, CodingKey {
        case serviceId
        case instanceId
        case instanceName
        case serviceStatus
        case srcRegion
        case dstRegion
        case engine
        case engineVersion
        case createTime
        case newestDataTime
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: BackupSynchronicityCodingKeys.self)
        if decoderContainer.contains(.serviceId)
        {
            self.serviceId = try decoderContainer.decode(String?.self, forKey: .serviceId)
        }
        if decoderContainer.contains(.instanceId)
        {
            self.instanceId = try decoderContainer.decode(String?.self, forKey: .instanceId)
        }
        if decoderContainer.contains(.instanceName)
        {
            self.instanceName = try decoderContainer.decode(String?.self, forKey: .instanceName)
        }
        if decoderContainer.contains(.serviceStatus)
        {
            self.serviceStatus = try decoderContainer.decode(String?.self, forKey: .serviceStatus)
        }
        if decoderContainer.contains(.srcRegion)
        {
            self.srcRegion = try decoderContainer.decode(String?.self, forKey: .srcRegion)
        }
        if decoderContainer.contains(.dstRegion)
        {
            self.dstRegion = try decoderContainer.decode(String?.self, forKey: .dstRegion)
        }
        if decoderContainer.contains(.engine)
        {
            self.engine = try decoderContainer.decode(String?.self, forKey: .engine)
        }
        if decoderContainer.contains(.engineVersion)
        {
            self.engineVersion = try decoderContainer.decode(String?.self, forKey: .engineVersion)
        }
        if decoderContainer.contains(.createTime)
        {
            self.createTime = try decoderContainer.decode(String?.self, forKey: .createTime)
        }
        if decoderContainer.contains(.newestDataTime)
        {
            self.newestDataTime = try decoderContainer.decode(String?.self, forKey: .newestDataTime)
        }
    }
}
public extension BackupSynchronicity{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: BackupSynchronicityCodingKeys.self)
         try encoderContainer.encode(serviceId, forKey: .serviceId)
         try encoderContainer.encode(instanceId, forKey: .instanceId)
         try encoderContainer.encode(instanceName, forKey: .instanceName)
         try encoderContainer.encode(serviceStatus, forKey: .serviceStatus)
         try encoderContainer.encode(srcRegion, forKey: .srcRegion)
         try encoderContainer.encode(dstRegion, forKey: .dstRegion)
         try encoderContainer.encode(engine, forKey: .engine)
         try encoderContainer.encode(engineVersion, forKey: .engineVersion)
         try encoderContainer.encode(createTime, forKey: .createTime)
         try encoderContainer.encode(newestDataTime, forKey: .newestDataTime)
    }
}
///  mongodbInfos
public class MongodbInfos:NSObject,Codable{
    /// 实例ID
    var spaceId:String?
    /// 状态描述
    var status:String?



    public override init(){
            super.init()
    }

    enum MongodbInfosCodingKeys: String, CodingKey {
        case spaceId
        case status
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: MongodbInfosCodingKeys.self)
        if decoderContainer.contains(.spaceId)
        {
            self.spaceId = try decoderContainer.decode(String?.self, forKey: .spaceId)
        }
        if decoderContainer.contains(.status)
        {
            self.status = try decoderContainer.decode(String?.self, forKey: .status)
        }
    }
}
public extension MongodbInfos{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: MongodbInfosCodingKeys.self)
         try encoderContainer.encode(spaceId, forKey: .spaceId)
         try encoderContainer.encode(status, forKey: .status)
    }
}
///  dBInstanceSpec
public class DBInstanceSpec:NSObject,Codable{
    /// 实例名称，只支持数字、字母、英文下划线、中文，且不少于2字符不超过32字符。
    var instanceName:String?
    /// 数据库类型，MongoDB
    var engine:String?
    /// 数据库版本，3.2
    var engineVersion:String?
    /// 实例规格代码。mongo.s1.small：1核2G;mongo.s1.medium：2核4G;mongo.s1.large：4核8G;mongo.s1.xlarge：8核16G;mongo.s2.2xlarge：8核32G;mongo.s2.4xlarge：16核64G;
    /// Required:true
    var instanceClass:String
    /// 存储空间，单位GB，取值10-1000,10的倍数。
    /// Required:true
    var instanceStorageGB:Int
    /// 是否选择多可用区部署
    /// Required:true
    var multiAZ:Bool
    /// 可用区ID，必填，第一个ID为primary所在可用区ID，第二个为secondary，第三个为hidden。multiAZ选择是，则primary与secondary的可用区ID需相同，且与hidden不同；multiAZ选择否，三个节点写相同的可用区ID。
    /// Required:true
    var azId:[String?]?
    /// VPCID
    /// Required:true
    var vpcId:String
    /// 子网ID
    /// Required:true
    var subnetId:String
    /// 密码，必须包含且只支持字母及数字，不少于8字符不超过16字符。
    var password:String?
    /// 按备份创建使用的具体备份ID
    var backupId:String?
    /// 基于一个实例的备份创建新实例，如填写则restoreTime也需要填写。
    var originDBInstanceId:String?
    /// 用户指定备份保留周期内的任意时间点，如2011-06-11T16:00:00Z，非必填，与backupId互斥。
    var restoreTime:String?



    public  init(instanceClass:String,instanceStorageGB:Int,multiAZ:Bool,azId:[String?]?,vpcId:String,subnetId:String){
             self.instanceClass = instanceClass
             self.instanceStorageGB = instanceStorageGB
             self.multiAZ = multiAZ
             self.azId = azId
             self.vpcId = vpcId
             self.subnetId = subnetId
    }

    enum DBInstanceSpecCodingKeys: String, CodingKey {
        case instanceName
        case engine
        case engineVersion
        case instanceClass
        case instanceStorageGB
        case multiAZ
        case azId
        case vpcId
        case subnetId
        case password
        case backupId
        case originDBInstanceId
        case restoreTime
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: DBInstanceSpecCodingKeys.self)
        if decoderContainer.contains(.instanceName)
        {
            self.instanceName = try decoderContainer.decode(String?.self, forKey: .instanceName)
        }
        if decoderContainer.contains(.engine)
        {
            self.engine = try decoderContainer.decode(String?.self, forKey: .engine)
        }
        if decoderContainer.contains(.engineVersion)
        {
            self.engineVersion = try decoderContainer.decode(String?.self, forKey: .engineVersion)
        }
        self.instanceClass = try decoderContainer.decode(String.self, forKey: .instanceClass)
        self.instanceStorageGB = try decoderContainer.decode(Int.self, forKey: .instanceStorageGB)
        self.multiAZ = try decoderContainer.decode(Bool.self, forKey: .multiAZ)
        self.azId = try decoderContainer.decode([String?]?.self, forKey: .azId)
        self.vpcId = try decoderContainer.decode(String.self, forKey: .vpcId)
        self.subnetId = try decoderContainer.decode(String.self, forKey: .subnetId)
        if decoderContainer.contains(.password)
        {
            self.password = try decoderContainer.decode(String?.self, forKey: .password)
        }
        if decoderContainer.contains(.backupId)
        {
            self.backupId = try decoderContainer.decode(String?.self, forKey: .backupId)
        }
        if decoderContainer.contains(.originDBInstanceId)
        {
            self.originDBInstanceId = try decoderContainer.decode(String?.self, forKey: .originDBInstanceId)
        }
        if decoderContainer.contains(.restoreTime)
        {
            self.restoreTime = try decoderContainer.decode(String?.self, forKey: .restoreTime)
        }
    }
}
public extension DBInstanceSpec{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: DBInstanceSpecCodingKeys.self)
         try encoderContainer.encode(instanceName, forKey: .instanceName)
         try encoderContainer.encode(engine, forKey: .engine)
         try encoderContainer.encode(engineVersion, forKey: .engineVersion)
         try encoderContainer.encode(instanceClass, forKey: .instanceClass)
         try encoderContainer.encode(instanceStorageGB, forKey: .instanceStorageGB)
         try encoderContainer.encode(multiAZ, forKey: .multiAZ)
         try encoderContainer.encode(azId, forKey: .azId)
         try encoderContainer.encode(vpcId, forKey: .vpcId)
         try encoderContainer.encode(subnetId, forKey: .subnetId)
         try encoderContainer.encode(password, forKey: .password)
         try encoderContainer.encode(backupId, forKey: .backupId)
         try encoderContainer.encode(originDBInstanceId, forKey: .originDBInstanceId)
         try encoderContainer.encode(restoreTime, forKey: .restoreTime)
    }
}
///  quota
public class Quota:NSObject,Codable{
    /// 总配额
    var total:Int?
    /// 已用
    var use:Int?



    public override init(){
            super.init()
    }

    enum QuotaCodingKeys: String, CodingKey {
        case total
        case use
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: QuotaCodingKeys.self)
        if decoderContainer.contains(.total)
        {
            self.total = try decoderContainer.decode(Int?.self, forKey: .total)
        }
        if decoderContainer.contains(.use)
        {
            self.use = try decoderContainer.decode(Int?.self, forKey: .use)
        }
    }
}
public extension Quota{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: QuotaCodingKeys.self)
         try encoderContainer.encode(total, forKey: .total)
         try encoderContainer.encode(use, forKey: .use)
    }
}
///  flavor
public class Flavor:NSObject,Codable{
    /// CPU核数
    var cpu:Int?
    /// 内存 ,单位GB
    var memory:Int?
    /// iops
    var iops:Int?
    /// 最大连接数
    var maxLink:Int?
    /// 最大磁盘数,单位GB
    var maxDisk:Int?
    /// 最下磁盘数,单位GB
    var minDisk:Int?
    /// 磁盘步长
    var diskStep:Int?



    public override init(){
            super.init()
    }

    enum FlavorCodingKeys: String, CodingKey {
        case cpu
        case memory
        case iops
        case maxLink
        case maxDisk
        case minDisk
        case diskStep
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: FlavorCodingKeys.self)
        if decoderContainer.contains(.cpu)
        {
            self.cpu = try decoderContainer.decode(Int?.self, forKey: .cpu)
        }
        if decoderContainer.contains(.memory)
        {
            self.memory = try decoderContainer.decode(Int?.self, forKey: .memory)
        }
        if decoderContainer.contains(.iops)
        {
            self.iops = try decoderContainer.decode(Int?.self, forKey: .iops)
        }
        if decoderContainer.contains(.maxLink)
        {
            self.maxLink = try decoderContainer.decode(Int?.self, forKey: .maxLink)
        }
        if decoderContainer.contains(.maxDisk)
        {
            self.maxDisk = try decoderContainer.decode(Int?.self, forKey: .maxDisk)
        }
        if decoderContainer.contains(.minDisk)
        {
            self.minDisk = try decoderContainer.decode(Int?.self, forKey: .minDisk)
        }
        if decoderContainer.contains(.diskStep)
        {
            self.diskStep = try decoderContainer.decode(Int?.self, forKey: .diskStep)
        }
    }
}
public extension Flavor{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: FlavorCodingKeys.self)
         try encoderContainer.encode(cpu, forKey: .cpu)
         try encoderContainer.encode(memory, forKey: .memory)
         try encoderContainer.encode(iops, forKey: .iops)
         try encoderContainer.encode(maxLink, forKey: .maxLink)
         try encoderContainer.encode(maxDisk, forKey: .maxDisk)
         try encoderContainer.encode(minDisk, forKey: .minDisk)
         try encoderContainer.encode(diskStep, forKey: .diskStep)
    }
}
///  tag
public class Tag:NSObject,Codable{
    /// Tag键
    var key:String?
    /// Tag值
    var value:String?



    public override init(){
            super.init()
    }

    enum TagCodingKeys: String, CodingKey {
        case key
        case value
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: TagCodingKeys.self)
        if decoderContainer.contains(.key)
        {
            self.key = try decoderContainer.decode(String?.self, forKey: .key)
        }
        if decoderContainer.contains(.value)
        {
            self.value = try decoderContainer.decode(String?.self, forKey: .value)
        }
    }
}
public extension Tag{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: TagCodingKeys.self)
         try encoderContainer.encode(key, forKey: .key)
         try encoderContainer.encode(value, forKey: .value)
    }
}
///  topologyPair
public class TopologyPair:NSObject,Codable{
    /// 域名
    var domain:String?
    /// ip地址
    var ip:String?
    /// 端口
    var port:String?



    public override init(){
            super.init()
    }

    enum TopologyPairCodingKeys: String, CodingKey {
        case domain
        case ip
        case port
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: TopologyPairCodingKeys.self)
        if decoderContainer.contains(.domain)
        {
            self.domain = try decoderContainer.decode(String?.self, forKey: .domain)
        }
        if decoderContainer.contains(.ip)
        {
            self.ip = try decoderContainer.decode(String?.self, forKey: .ip)
        }
        if decoderContainer.contains(.port)
        {
            self.port = try decoderContainer.decode(String?.self, forKey: .port)
        }
    }
}
public extension TopologyPair{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: TopologyPairCodingKeys.self)
         try encoderContainer.encode(domain, forKey: .domain)
         try encoderContainer.encode(ip, forKey: .ip)
         try encoderContainer.encode(port, forKey: .port)
    }
}
///  topology
public class Topology:NSObject,Codable{
    /// 主
    var primary:TopologyPair?
    /// 备
    var secondary:[TopologyPair?]?
    /// 隐藏
    var hidden:[TopologyPair?]?



    public override init(){
            super.init()
    }

    enum TopologyCodingKeys: String, CodingKey {
        case primary
        case secondary
        case hidden
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: TopologyCodingKeys.self)
        if decoderContainer.contains(.primary)
        {
            self.primary = try decoderContainer.decode(TopologyPair?.self, forKey: .primary)
        }
        if decoderContainer.contains(.secondary)
        {
            self.secondary = try decoderContainer.decode([TopologyPair?]?.self, forKey: .secondary)
        }
        if decoderContainer.contains(.hidden)
        {
            self.hidden = try decoderContainer.decode([TopologyPair?]?.self, forKey: .hidden)
        }
    }
}
public extension Topology{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: TopologyCodingKeys.self)
         try encoderContainer.encode(primary, forKey: .primary)
         try encoderContainer.encode(secondary, forKey: .secondary)
         try encoderContainer.encode(hidden, forKey: .hidden)
    }
}
///  dBInstance
public class DBInstance:NSObject,Codable{
    /// 实例ID
    var instanceId:String?
    /// 实例名称
    var instanceName:String?
    /// 数据库类型
    var engine:String?
    /// 数据库版本
    var engineVersion:String?
    /// 实例规格代码
    var instanceClass:String?
    /// 存储空间
    var instanceStorageGB:Int?
    /// CPU核数
    var instanceCPU:Int?
    /// 内存，单位GB
    var instanceMemoryGB:Int?
    /// 可取区ID，依次为主、从、隐藏节点所在可用区
    var azId:[String?]?
    /// VPCID
    var vpcId:String?
    /// 子网ID
    var subnetId:String?
    /// 副本集名称
    var replicaSetName:String?
    /// 域名
    var instanceDomain:String?
    /// 默认库名
    var dBName:String?
    /// 默认用户名
    var accountName:String?
    /// 应用访问端口
    var instancePort:String?
    /// 实例状态.RUNNING：运行, ERROR：错误 ,BUILDING：创建中, DELETING：删除中, RESTORING：恢复中, RESIZING：变配中
    var instanceStatus:String?
    /// 自动备份保留时间
    var backupRetentionPeriod:Int?
    /// 创建时间
    var createTime:String?
    /// 自动备份时间，如：00:00-02:00，表示0点到2点进行数据库自动备份
    var preferredBackupWindow:String?
    /// 系统维护时间，如：00:00-02:00，表示0点到2点进行系统维护
    var preferredmaintenanceWindow:String?
    /// 计费信息
    var charge:Charge?
    /// 是否设置白名单，true：已设置，false：未设置
    var isSetSecurityIps:Bool?
    /// 标签
    var tags:[Tag?]?



    public override init(){
            super.init()
    }

    enum DBInstanceCodingKeys: String, CodingKey {
        case instanceId
        case instanceName
        case engine
        case engineVersion
        case instanceClass
        case instanceStorageGB
        case instanceCPU
        case instanceMemoryGB
        case azId
        case vpcId
        case subnetId
        case replicaSetName
        case instanceDomain
        case dBName
        case accountName
        case instancePort
        case instanceStatus
        case backupRetentionPeriod
        case createTime
        case preferredBackupWindow
        case preferredmaintenanceWindow
        case charge
        case isSetSecurityIps
        case tags
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: DBInstanceCodingKeys.self)
        if decoderContainer.contains(.instanceId)
        {
            self.instanceId = try decoderContainer.decode(String?.self, forKey: .instanceId)
        }
        if decoderContainer.contains(.instanceName)
        {
            self.instanceName = try decoderContainer.decode(String?.self, forKey: .instanceName)
        }
        if decoderContainer.contains(.engine)
        {
            self.engine = try decoderContainer.decode(String?.self, forKey: .engine)
        }
        if decoderContainer.contains(.engineVersion)
        {
            self.engineVersion = try decoderContainer.decode(String?.self, forKey: .engineVersion)
        }
        if decoderContainer.contains(.instanceClass)
        {
            self.instanceClass = try decoderContainer.decode(String?.self, forKey: .instanceClass)
        }
        if decoderContainer.contains(.instanceStorageGB)
        {
            self.instanceStorageGB = try decoderContainer.decode(Int?.self, forKey: .instanceStorageGB)
        }
        if decoderContainer.contains(.instanceCPU)
        {
            self.instanceCPU = try decoderContainer.decode(Int?.self, forKey: .instanceCPU)
        }
        if decoderContainer.contains(.instanceMemoryGB)
        {
            self.instanceMemoryGB = try decoderContainer.decode(Int?.self, forKey: .instanceMemoryGB)
        }
        if decoderContainer.contains(.azId)
        {
            self.azId = try decoderContainer.decode([String?]?.self, forKey: .azId)
        }
        if decoderContainer.contains(.vpcId)
        {
            self.vpcId = try decoderContainer.decode(String?.self, forKey: .vpcId)
        }
        if decoderContainer.contains(.subnetId)
        {
            self.subnetId = try decoderContainer.decode(String?.self, forKey: .subnetId)
        }
        if decoderContainer.contains(.replicaSetName)
        {
            self.replicaSetName = try decoderContainer.decode(String?.self, forKey: .replicaSetName)
        }
        if decoderContainer.contains(.instanceDomain)
        {
            self.instanceDomain = try decoderContainer.decode(String?.self, forKey: .instanceDomain)
        }
        if decoderContainer.contains(.dBName)
        {
            self.dBName = try decoderContainer.decode(String?.self, forKey: .dBName)
        }
        if decoderContainer.contains(.accountName)
        {
            self.accountName = try decoderContainer.decode(String?.self, forKey: .accountName)
        }
        if decoderContainer.contains(.instancePort)
        {
            self.instancePort = try decoderContainer.decode(String?.self, forKey: .instancePort)
        }
        if decoderContainer.contains(.instanceStatus)
        {
            self.instanceStatus = try decoderContainer.decode(String?.self, forKey: .instanceStatus)
        }
        if decoderContainer.contains(.backupRetentionPeriod)
        {
            self.backupRetentionPeriod = try decoderContainer.decode(Int?.self, forKey: .backupRetentionPeriod)
        }
        if decoderContainer.contains(.createTime)
        {
            self.createTime = try decoderContainer.decode(String?.self, forKey: .createTime)
        }
        if decoderContainer.contains(.preferredBackupWindow)
        {
            self.preferredBackupWindow = try decoderContainer.decode(String?.self, forKey: .preferredBackupWindow)
        }
        if decoderContainer.contains(.preferredmaintenanceWindow)
        {
            self.preferredmaintenanceWindow = try decoderContainer.decode(String?.self, forKey: .preferredmaintenanceWindow)
        }
        if decoderContainer.contains(.charge)
        {
            self.charge = try decoderContainer.decode(Charge?.self, forKey: .charge)
        }
        if decoderContainer.contains(.isSetSecurityIps)
        {
            self.isSetSecurityIps = try decoderContainer.decode(Bool?.self, forKey: .isSetSecurityIps)
        }
        if decoderContainer.contains(.tags)
        {
            self.tags = try decoderContainer.decode([Tag?]?.self, forKey: .tags)
        }
    }
}
public extension DBInstance{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: DBInstanceCodingKeys.self)
         try encoderContainer.encode(instanceId, forKey: .instanceId)
         try encoderContainer.encode(instanceName, forKey: .instanceName)
         try encoderContainer.encode(engine, forKey: .engine)
         try encoderContainer.encode(engineVersion, forKey: .engineVersion)
         try encoderContainer.encode(instanceClass, forKey: .instanceClass)
         try encoderContainer.encode(instanceStorageGB, forKey: .instanceStorageGB)
         try encoderContainer.encode(instanceCPU, forKey: .instanceCPU)
         try encoderContainer.encode(instanceMemoryGB, forKey: .instanceMemoryGB)
         try encoderContainer.encode(azId, forKey: .azId)
         try encoderContainer.encode(vpcId, forKey: .vpcId)
         try encoderContainer.encode(subnetId, forKey: .subnetId)
         try encoderContainer.encode(replicaSetName, forKey: .replicaSetName)
         try encoderContainer.encode(instanceDomain, forKey: .instanceDomain)
         try encoderContainer.encode(dBName, forKey: .dBName)
         try encoderContainer.encode(accountName, forKey: .accountName)
         try encoderContainer.encode(instancePort, forKey: .instancePort)
         try encoderContainer.encode(instanceStatus, forKey: .instanceStatus)
         try encoderContainer.encode(backupRetentionPeriod, forKey: .backupRetentionPeriod)
         try encoderContainer.encode(createTime, forKey: .createTime)
         try encoderContainer.encode(preferredBackupWindow, forKey: .preferredBackupWindow)
         try encoderContainer.encode(preferredmaintenanceWindow, forKey: .preferredmaintenanceWindow)
         try encoderContainer.encode(charge, forKey: .charge)
         try encoderContainer.encode(isSetSecurityIps, forKey: .isSetSecurityIps)
         try encoderContainer.encode(tags, forKey: .tags)
    }
}
///  availableZones
public class AvailableZones:NSObject,Codable{
    /// 可用区
    var az:String?
    /// 是否可售
    var canSale:Bool?



    public override init(){
            super.init()
    }

    enum AvailableZonesCodingKeys: String, CodingKey {
        case az
        case canSale
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: AvailableZonesCodingKeys.self)
        if decoderContainer.contains(.az)
        {
            self.az = try decoderContainer.decode(String?.self, forKey: .az)
        }
        if decoderContainer.contains(.canSale)
        {
            self.canSale = try decoderContainer.decode(Bool?.self, forKey: .canSale)
        }
    }
}
public extension AvailableZones{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: AvailableZonesCodingKeys.self)
         try encoderContainer.encode(az, forKey: .az)
         try encoderContainer.encode(canSale, forKey: .canSale)
    }
}
///  spaceId
public class SpaceId:NSObject,Codable{
    /// 实例ID
    var spaceIdValue:String?
    /// 状态描述
    var status:String?



    public override init(){
            super.init()
    }

    enum SpaceIdCodingKeys: String, CodingKey {
        case spaceIdValue = "spaceId"
        case status
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: SpaceIdCodingKeys.self)
        if decoderContainer.contains(.spaceIdValue)
        {
            self.spaceIdValue = try decoderContainer.decode(String?.self, forKey: .spaceIdValue)
        }
        if decoderContainer.contains(.status)
        {
            self.status = try decoderContainer.decode(String?.self, forKey: .status)
        }
    }
}
public extension SpaceId{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: SpaceIdCodingKeys.self)
         try encoderContainer.encode(spaceIdValue, forKey: .spaceIdValue)
         try encoderContainer.encode(status, forKey: .status)
    }
}

/* Copyright 2018 JDCLOUD.COM

   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at

     http:#www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.

   
   

   
   Contact: 

   NOTE: This class is auto generated by the jdcloud code generator program.
 */


import Foundation

///  dBInstanceSpec
@objc(DBInstanceSpec)
public class DBInstanceSpec:NSObject,Codable{
    /// 实例名称，只支持数字、字母、英文下划线、中文，且不少于2字符不超过32字符。
    var instanceName:String?
    /// 数据库类型，MongoDB
    var engine:String?
    /// 数据库版本，3.2
    var engineVersion:String?
    /// 实例规格代码。mongo.s1.small：1核2G;mongo.s1.medium：2核4G;mongo.s1.large：4核8G;mongo.s1.xlarge：8核16G;mongo.s2.2xlarge：8核32G;mongo.s2.4xlarge：16核64G;
    /// Required:true
    var instanceClass:String
    /// 存储空间，单位GB，取值10-1000,10的倍数。
    /// Required:true
    var instanceStorageGB:Int
    /// 是否选择多可用区部署
    /// Required:true
    var multiAZ:Bool
    /// 可用区ID，必填，第一个ID为primary所在可用区ID，第二个为secondary，第三个为hidden。multiAZ选择是，则primary与secondary的可用区ID需相同，且与hidden不同；multiAZ选择否，三个节点写相同的可用区ID。
    /// Required:true
    var azId:[String?]
    /// VPCID
    /// Required:true
    var vpcId:String
    /// 子网ID
    /// Required:true
    var subnetId:String
    /// 密码，必须包含且只支持字母及数字，不少于8字符不超过16字符。
    var password:String?
    /// 按备份创建使用的具体备份ID
    var backupId:String?
    /// 基于一个实例的备份创建新实例，如填写则restoreTime也需要填写。
    var originDBInstanceId:String?
    /// 用户指定备份保留周期内的任意时间点，如2011-06-11T16:00:00Z，非必填，与backupId互斥。
    var restoreTime:String?



    public  init(instanceClass:String,instanceStorageGB:Int,multiAZ:Bool,azId:[String?],vpcId:String,subnetId:String){
             self.instanceClass = instanceClass
             self.instanceStorageGB = instanceStorageGB
             self.multiAZ = multiAZ
             self.azId = azId
             self.vpcId = vpcId
             self.subnetId = subnetId
    }

    enum DBInstanceSpecCodingKeys: String, CodingKey {
        case instanceName
        case engine
        case engineVersion
        case instanceClass
        case instanceStorageGB
        case multiAZ
        case azId
        case vpcId
        case subnetId
        case password
        case backupId
        case originDBInstanceId
        case restoreTime
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: DBInstanceSpecCodingKeys.self)
        if decoderContainer.contains(.instanceName)
        {
            self.instanceName = try decoderContainer.decode(String?.self, forKey: .instanceName)
        }
        if decoderContainer.contains(.engine)
        {
            self.engine = try decoderContainer.decode(String?.self, forKey: .engine)
        }
        if decoderContainer.contains(.engineVersion)
        {
            self.engineVersion = try decoderContainer.decode(String?.self, forKey: .engineVersion)
        }
        self.instanceClass = try decoderContainer.decode(String.self, forKey: .instanceClass)
        self.instanceStorageGB = try decoderContainer.decode(Int.self, forKey: .instanceStorageGB)
        self.multiAZ = try decoderContainer.decode(Bool.self, forKey: .multiAZ)
        self.azId = try decoderContainer.decode([String?].self, forKey: .azId)
        self.vpcId = try decoderContainer.decode(String.self, forKey: .vpcId)
        self.subnetId = try decoderContainer.decode(String.self, forKey: .subnetId)
        if decoderContainer.contains(.password)
        {
            self.password = try decoderContainer.decode(String?.self, forKey: .password)
        }
        if decoderContainer.contains(.backupId)
        {
            self.backupId = try decoderContainer.decode(String?.self, forKey: .backupId)
        }
        if decoderContainer.contains(.originDBInstanceId)
        {
            self.originDBInstanceId = try decoderContainer.decode(String?.self, forKey: .originDBInstanceId)
        }
        if decoderContainer.contains(.restoreTime)
        {
            self.restoreTime = try decoderContainer.decode(String?.self, forKey: .restoreTime)
        }
    }
}
public extension DBInstanceSpec{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: DBInstanceSpecCodingKeys.self)
         try encoderContainer.encode(instanceName, forKey: .instanceName)
         try encoderContainer.encode(engine, forKey: .engine)
         try encoderContainer.encode(engineVersion, forKey: .engineVersion)
         try encoderContainer.encode(instanceClass, forKey: .instanceClass)
         try encoderContainer.encode(instanceStorageGB, forKey: .instanceStorageGB)
         try encoderContainer.encode(multiAZ, forKey: .multiAZ)
         try encoderContainer.encode(azId, forKey: .azId)
         try encoderContainer.encode(vpcId, forKey: .vpcId)
         try encoderContainer.encode(subnetId, forKey: .subnetId)
         try encoderContainer.encode(password, forKey: .password)
         try encoderContainer.encode(backupId, forKey: .backupId)
         try encoderContainer.encode(originDBInstanceId, forKey: .originDBInstanceId)
         try encoderContainer.encode(restoreTime, forKey: .restoreTime)
    }
}

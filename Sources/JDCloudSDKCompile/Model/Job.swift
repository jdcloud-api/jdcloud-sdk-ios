/* Copyright 2018 JDCLOUD.COM

   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at

     http:#www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.

   
   

   
   Contact: 

   NOTE: This class is auto generated by the jdcloud code generator program.
 */


import Foundation

///  job
@objc(Job)
public class Job:NSObject,Codable{
    /// 构建任务uuid
    var uuid:String?
    /// 创建时间戳
    var createdAt:Int?
    /// 最后一次更新时间
    var updatedAt:Int?
    /// 构建名称
    var name:String?
    /// 代码存储类型，目前只支持github
    var codeType:String?
    /// 代码clone路径
    var codeRepoUrl:String?
    /// 代码名称的显示Label
    var codeRepoUrlLabel:String?
    /// 分支
    var codeRepoBranch:String?
    /// 创建者
    var createUserName:String?
    /// 是否是私有仓库
    var codeRepoPrivate:Bool?
    /// 最后一次更细者
    var createUserPin:String?
    /// 用户云存储路径，如果为空，使用公用的云存储
    var ossPath:String?
    /// 用户云存储主机，实际为用户云存储所在地域
    var ossHost:String?
    /// 用户云存储bucket，如果为空，使用公用的云存储
    var ossBucket:String?
    /// 编译镜像地址
    var buildImage:String?
    /// 编译镜像的显示Label
    var buildImageLabel:String?
    /// 是否在页面配置构建方式，这项为true，则buildSetConfig需要有内容，如果这项为false，即使buildSetConfig有内容，也不生效
    var isUserBuildSetConfig:Bool?
    /// 见isUserBuildSetConfig的说明
    var buildSetConfig:String?
    /// 超时时间，单位秒
    var buildTimeOut:Int?
    /// cpu分配核数
    var buildResourceCpu:Int?
    /// 内存分配大小，单位MB
    var buildResourceMem:Int?
    /// 通知邮件
    var noticeMail:String?
    /// 通知频率， MAIL_FAILED失败时通知，MAIL_EVERY每次构建就通知
    var noticeType:String?
    /// 构建类型
    var compilerType:String?
    /// 镜像注册表名
    var dockerRegistry:String?
    /// 镜像仓库名
    var dockerRepository:String?
    /// 注册表的URI
    var dockerRegistryUri:String?



    public override init(){
            super.init()
    }

    enum JobCodingKeys: String, CodingKey {
        case uuid
        case createdAt
        case updatedAt
        case name
        case codeType
        case codeRepoUrl
        case codeRepoUrlLabel
        case codeRepoBranch
        case createUserName
        case codeRepoPrivate
        case createUserPin
        case ossPath
        case ossHost
        case ossBucket
        case buildImage
        case buildImageLabel
        case isUserBuildSetConfig
        case buildSetConfig
        case buildTimeOut
        case buildResourceCpu
        case buildResourceMem
        case noticeMail
        case noticeType
        case compilerType
        case dockerRegistry
        case dockerRepository
        case dockerRegistryUri
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: JobCodingKeys.self)
        if decoderContainer.contains(.uuid)
        {
            self.uuid = try decoderContainer.decode(String?.self, forKey: .uuid)
        }
        if decoderContainer.contains(.createdAt)
        {
            self.createdAt = try decoderContainer.decode(Int?.self, forKey: .createdAt)
        }
        if decoderContainer.contains(.updatedAt)
        {
            self.updatedAt = try decoderContainer.decode(Int?.self, forKey: .updatedAt)
        }
        if decoderContainer.contains(.name)
        {
            self.name = try decoderContainer.decode(String?.self, forKey: .name)
        }
        if decoderContainer.contains(.codeType)
        {
            self.codeType = try decoderContainer.decode(String?.self, forKey: .codeType)
        }
        if decoderContainer.contains(.codeRepoUrl)
        {
            self.codeRepoUrl = try decoderContainer.decode(String?.self, forKey: .codeRepoUrl)
        }
        if decoderContainer.contains(.codeRepoUrlLabel)
        {
            self.codeRepoUrlLabel = try decoderContainer.decode(String?.self, forKey: .codeRepoUrlLabel)
        }
        if decoderContainer.contains(.codeRepoBranch)
        {
            self.codeRepoBranch = try decoderContainer.decode(String?.self, forKey: .codeRepoBranch)
        }
        if decoderContainer.contains(.createUserName)
        {
            self.createUserName = try decoderContainer.decode(String?.self, forKey: .createUserName)
        }
        if decoderContainer.contains(.codeRepoPrivate)
        {
            self.codeRepoPrivate = try decoderContainer.decode(Bool?.self, forKey: .codeRepoPrivate)
        }
        if decoderContainer.contains(.createUserPin)
        {
            self.createUserPin = try decoderContainer.decode(String?.self, forKey: .createUserPin)
        }
        if decoderContainer.contains(.ossPath)
        {
            self.ossPath = try decoderContainer.decode(String?.self, forKey: .ossPath)
        }
        if decoderContainer.contains(.ossHost)
        {
            self.ossHost = try decoderContainer.decode(String?.self, forKey: .ossHost)
        }
        if decoderContainer.contains(.ossBucket)
        {
            self.ossBucket = try decoderContainer.decode(String?.self, forKey: .ossBucket)
        }
        if decoderContainer.contains(.buildImage)
        {
            self.buildImage = try decoderContainer.decode(String?.self, forKey: .buildImage)
        }
        if decoderContainer.contains(.buildImageLabel)
        {
            self.buildImageLabel = try decoderContainer.decode(String?.self, forKey: .buildImageLabel)
        }
        if decoderContainer.contains(.isUserBuildSetConfig)
        {
            self.isUserBuildSetConfig = try decoderContainer.decode(Bool?.self, forKey: .isUserBuildSetConfig)
        }
        if decoderContainer.contains(.buildSetConfig)
        {
            self.buildSetConfig = try decoderContainer.decode(String?.self, forKey: .buildSetConfig)
        }
        if decoderContainer.contains(.buildTimeOut)
        {
            self.buildTimeOut = try decoderContainer.decode(Int?.self, forKey: .buildTimeOut)
        }
        if decoderContainer.contains(.buildResourceCpu)
        {
            self.buildResourceCpu = try decoderContainer.decode(Int?.self, forKey: .buildResourceCpu)
        }
        if decoderContainer.contains(.buildResourceMem)
        {
            self.buildResourceMem = try decoderContainer.decode(Int?.self, forKey: .buildResourceMem)
        }
        if decoderContainer.contains(.noticeMail)
        {
            self.noticeMail = try decoderContainer.decode(String?.self, forKey: .noticeMail)
        }
        if decoderContainer.contains(.noticeType)
        {
            self.noticeType = try decoderContainer.decode(String?.self, forKey: .noticeType)
        }
        if decoderContainer.contains(.compilerType)
        {
            self.compilerType = try decoderContainer.decode(String?.self, forKey: .compilerType)
        }
        if decoderContainer.contains(.dockerRegistry)
        {
            self.dockerRegistry = try decoderContainer.decode(String?.self, forKey: .dockerRegistry)
        }
        if decoderContainer.contains(.dockerRepository)
        {
            self.dockerRepository = try decoderContainer.decode(String?.self, forKey: .dockerRepository)
        }
        if decoderContainer.contains(.dockerRegistryUri)
        {
            self.dockerRegistryUri = try decoderContainer.decode(String?.self, forKey: .dockerRegistryUri)
        }
    }
}
public extension Job{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: JobCodingKeys.self)
         try encoderContainer.encode(uuid, forKey: .uuid)
         try encoderContainer.encode(createdAt, forKey: .createdAt)
         try encoderContainer.encode(updatedAt, forKey: .updatedAt)
         try encoderContainer.encode(name, forKey: .name)
         try encoderContainer.encode(codeType, forKey: .codeType)
         try encoderContainer.encode(codeRepoUrl, forKey: .codeRepoUrl)
         try encoderContainer.encode(codeRepoUrlLabel, forKey: .codeRepoUrlLabel)
         try encoderContainer.encode(codeRepoBranch, forKey: .codeRepoBranch)
         try encoderContainer.encode(createUserName, forKey: .createUserName)
         try encoderContainer.encode(codeRepoPrivate, forKey: .codeRepoPrivate)
         try encoderContainer.encode(createUserPin, forKey: .createUserPin)
         try encoderContainer.encode(ossPath, forKey: .ossPath)
         try encoderContainer.encode(ossHost, forKey: .ossHost)
         try encoderContainer.encode(ossBucket, forKey: .ossBucket)
         try encoderContainer.encode(buildImage, forKey: .buildImage)
         try encoderContainer.encode(buildImageLabel, forKey: .buildImageLabel)
         try encoderContainer.encode(isUserBuildSetConfig, forKey: .isUserBuildSetConfig)
         try encoderContainer.encode(buildSetConfig, forKey: .buildSetConfig)
         try encoderContainer.encode(buildTimeOut, forKey: .buildTimeOut)
         try encoderContainer.encode(buildResourceCpu, forKey: .buildResourceCpu)
         try encoderContainer.encode(buildResourceMem, forKey: .buildResourceMem)
         try encoderContainer.encode(noticeMail, forKey: .noticeMail)
         try encoderContainer.encode(noticeType, forKey: .noticeType)
         try encoderContainer.encode(compilerType, forKey: .compilerType)
         try encoderContainer.encode(dockerRegistry, forKey: .dockerRegistry)
         try encoderContainer.encode(dockerRepository, forKey: .dockerRepository)
         try encoderContainer.encode(dockerRegistryUri, forKey: .dockerRegistryUri)
    }
}

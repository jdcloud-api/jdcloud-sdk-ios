/* Copyright 2018 JDCLOUD.COM

   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at

     http:#www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.

   compiler type api
   API related to job compiler type

   OpenAPI spec version: v1
   Contact: 

   NOTE: This class is auto generated by the jdcloud code generator program.
 */


import Foundation
///  job
public class Job:NSObject,Codable{
    /// 构建任务uuid
    var uuid:String?
    /// 创建时间戳
    var createdAt:Int?
    /// 最后一次更新时间
    var updatedAt:Int?
    /// 构建名称
    var name:String?
    /// 代码存储类型，目前只支持github
    var codeType:String?
    /// 代码clone路径
    var codeRepoUrl:String?
    /// 代码名称的显示Label
    var codeRepoUrlLabel:String?
    /// 分支
    var codeRepoBranch:String?
    /// 创建者
    var createUserName:String?
    /// 是否是私有仓库
    var codeRepoPrivate:Bool?
    /// 最后一次更细者
    var createUserPin:String?
    /// 用户云存储路径，如果为空，使用公用的云存储
    var ossPath:String?
    /// 用户云存储主机，实际为用户云存储所在地域
    var ossHost:String?
    /// 用户云存储bucket，如果为空，使用公用的云存储
    var ossBucket:String?
    /// 编译镜像地址
    var buildImage:String?
    /// 编译镜像的显示Label
    var buildImageLabel:String?
    /// 是否在页面配置构建方式，这项为true，则buildSetConfig需要有内容，如果这项为false，即使buildSetConfig有内容，也不生效
    var isUserBuildSetConfig:Bool?
    /// 见isUserBuildSetConfig的说明
    var buildSetConfig:String?
    /// 超时时间，单位秒
    var buildTimeOut:Int?
    /// cpu分配核数
    var buildResourceCpu:Int?
    /// 内存分配大小，单位MB
    var buildResourceMem:Int?
    /// 通知邮件
    var noticeMail:String?
    /// 通知频率， MAIL_FAILED失败时通知，MAIL_EVERY每次构建就通知
    var noticeType:String?
    /// 构建类型
    var compilerType:String?
    /// 镜像注册表名
    var dockerRegistry:String?
    /// 镜像仓库名
    var dockerRepository:String?
    /// 注册表的URI
    var dockerRegistryUri:String?



    public override init(){
            super.init()
    }

    enum JobCodingKeys: String, CodingKey {
        case uuid
        case createdAt
        case updatedAt
        case name
        case codeType
        case codeRepoUrl
        case codeRepoUrlLabel
        case codeRepoBranch
        case createUserName
        case codeRepoPrivate
        case createUserPin
        case ossPath
        case ossHost
        case ossBucket
        case buildImage
        case buildImageLabel
        case isUserBuildSetConfig
        case buildSetConfig
        case buildTimeOut
        case buildResourceCpu
        case buildResourceMem
        case noticeMail
        case noticeType
        case compilerType
        case dockerRegistry
        case dockerRepository
        case dockerRegistryUri
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: JobCodingKeys.self)
        if decoderContainer.contains(.uuid)
        {
            self.uuid = try decoderContainer.decode(String?.self, forKey: .uuid)
        }
        if decoderContainer.contains(.createdAt)
        {
            self.createdAt = try decoderContainer.decode(Int?.self, forKey: .createdAt)
        }
        if decoderContainer.contains(.updatedAt)
        {
            self.updatedAt = try decoderContainer.decode(Int?.self, forKey: .updatedAt)
        }
        if decoderContainer.contains(.name)
        {
            self.name = try decoderContainer.decode(String?.self, forKey: .name)
        }
        if decoderContainer.contains(.codeType)
        {
            self.codeType = try decoderContainer.decode(String?.self, forKey: .codeType)
        }
        if decoderContainer.contains(.codeRepoUrl)
        {
            self.codeRepoUrl = try decoderContainer.decode(String?.self, forKey: .codeRepoUrl)
        }
        if decoderContainer.contains(.codeRepoUrlLabel)
        {
            self.codeRepoUrlLabel = try decoderContainer.decode(String?.self, forKey: .codeRepoUrlLabel)
        }
        if decoderContainer.contains(.codeRepoBranch)
        {
            self.codeRepoBranch = try decoderContainer.decode(String?.self, forKey: .codeRepoBranch)
        }
        if decoderContainer.contains(.createUserName)
        {
            self.createUserName = try decoderContainer.decode(String?.self, forKey: .createUserName)
        }
        if decoderContainer.contains(.codeRepoPrivate)
        {
            self.codeRepoPrivate = try decoderContainer.decode(Bool?.self, forKey: .codeRepoPrivate)
        }
        if decoderContainer.contains(.createUserPin)
        {
            self.createUserPin = try decoderContainer.decode(String?.self, forKey: .createUserPin)
        }
        if decoderContainer.contains(.ossPath)
        {
            self.ossPath = try decoderContainer.decode(String?.self, forKey: .ossPath)
        }
        if decoderContainer.contains(.ossHost)
        {
            self.ossHost = try decoderContainer.decode(String?.self, forKey: .ossHost)
        }
        if decoderContainer.contains(.ossBucket)
        {
            self.ossBucket = try decoderContainer.decode(String?.self, forKey: .ossBucket)
        }
        if decoderContainer.contains(.buildImage)
        {
            self.buildImage = try decoderContainer.decode(String?.self, forKey: .buildImage)
        }
        if decoderContainer.contains(.buildImageLabel)
        {
            self.buildImageLabel = try decoderContainer.decode(String?.self, forKey: .buildImageLabel)
        }
        if decoderContainer.contains(.isUserBuildSetConfig)
        {
            self.isUserBuildSetConfig = try decoderContainer.decode(Bool?.self, forKey: .isUserBuildSetConfig)
        }
        if decoderContainer.contains(.buildSetConfig)
        {
            self.buildSetConfig = try decoderContainer.decode(String?.self, forKey: .buildSetConfig)
        }
        if decoderContainer.contains(.buildTimeOut)
        {
            self.buildTimeOut = try decoderContainer.decode(Int?.self, forKey: .buildTimeOut)
        }
        if decoderContainer.contains(.buildResourceCpu)
        {
            self.buildResourceCpu = try decoderContainer.decode(Int?.self, forKey: .buildResourceCpu)
        }
        if decoderContainer.contains(.buildResourceMem)
        {
            self.buildResourceMem = try decoderContainer.decode(Int?.self, forKey: .buildResourceMem)
        }
        if decoderContainer.contains(.noticeMail)
        {
            self.noticeMail = try decoderContainer.decode(String?.self, forKey: .noticeMail)
        }
        if decoderContainer.contains(.noticeType)
        {
            self.noticeType = try decoderContainer.decode(String?.self, forKey: .noticeType)
        }
        if decoderContainer.contains(.compilerType)
        {
            self.compilerType = try decoderContainer.decode(String?.self, forKey: .compilerType)
        }
        if decoderContainer.contains(.dockerRegistry)
        {
            self.dockerRegistry = try decoderContainer.decode(String?.self, forKey: .dockerRegistry)
        }
        if decoderContainer.contains(.dockerRepository)
        {
            self.dockerRepository = try decoderContainer.decode(String?.self, forKey: .dockerRepository)
        }
        if decoderContainer.contains(.dockerRegistryUri)
        {
            self.dockerRegistryUri = try decoderContainer.decode(String?.self, forKey: .dockerRegistryUri)
        }
    }
}
public extension Job{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: JobCodingKeys.self)
         try encoderContainer.encode(uuid, forKey: .uuid)
         try encoderContainer.encode(createdAt, forKey: .createdAt)
         try encoderContainer.encode(updatedAt, forKey: .updatedAt)
         try encoderContainer.encode(name, forKey: .name)
         try encoderContainer.encode(codeType, forKey: .codeType)
         try encoderContainer.encode(codeRepoUrl, forKey: .codeRepoUrl)
         try encoderContainer.encode(codeRepoUrlLabel, forKey: .codeRepoUrlLabel)
         try encoderContainer.encode(codeRepoBranch, forKey: .codeRepoBranch)
         try encoderContainer.encode(createUserName, forKey: .createUserName)
         try encoderContainer.encode(codeRepoPrivate, forKey: .codeRepoPrivate)
         try encoderContainer.encode(createUserPin, forKey: .createUserPin)
         try encoderContainer.encode(ossPath, forKey: .ossPath)
         try encoderContainer.encode(ossHost, forKey: .ossHost)
         try encoderContainer.encode(ossBucket, forKey: .ossBucket)
         try encoderContainer.encode(buildImage, forKey: .buildImage)
         try encoderContainer.encode(buildImageLabel, forKey: .buildImageLabel)
         try encoderContainer.encode(isUserBuildSetConfig, forKey: .isUserBuildSetConfig)
         try encoderContainer.encode(buildSetConfig, forKey: .buildSetConfig)
         try encoderContainer.encode(buildTimeOut, forKey: .buildTimeOut)
         try encoderContainer.encode(buildResourceCpu, forKey: .buildResourceCpu)
         try encoderContainer.encode(buildResourceMem, forKey: .buildResourceMem)
         try encoderContainer.encode(noticeMail, forKey: .noticeMail)
         try encoderContainer.encode(noticeType, forKey: .noticeType)
         try encoderContainer.encode(compilerType, forKey: .compilerType)
         try encoderContainer.encode(dockerRegistry, forKey: .dockerRegistry)
         try encoderContainer.encode(dockerRepository, forKey: .dockerRepository)
         try encoderContainer.encode(dockerRegistryUri, forKey: .dockerRegistryUri)
    }
}
///  codeTypeDefine
public class CodeTypeDefine:NSObject,Codable{
    /// Label
    var label:String?
    /// Value
    var value:String?



    public override init(){
            super.init()
    }

    enum CodeTypeDefineCodingKeys: String, CodingKey {
        case label
        case value
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: CodeTypeDefineCodingKeys.self)
        if decoderContainer.contains(.label)
        {
            self.label = try decoderContainer.decode(String?.self, forKey: .label)
        }
        if decoderContainer.contains(.value)
        {
            self.value = try decoderContainer.decode(String?.self, forKey: .value)
        }
    }
}
public extension CodeTypeDefine{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: CodeTypeDefineCodingKeys.self)
         try encoderContainer.encode(label, forKey: .label)
         try encoderContainer.encode(value, forKey: .value)
    }
}
///  computeTypeDefine
public class ComputeTypeDefine:NSObject,Codable{
    /// Name
    var name:String?
    /// BuildResourceMem
    var buildResourceMem:Int?
    /// BuildResourceCpu
    var buildResourceCpu:Int?



    public override init(){
            super.init()
    }

    enum ComputeTypeDefineCodingKeys: String, CodingKey {
        case name
        case buildResourceMem
        case buildResourceCpu
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: ComputeTypeDefineCodingKeys.self)
        if decoderContainer.contains(.name)
        {
            self.name = try decoderContainer.decode(String?.self, forKey: .name)
        }
        if decoderContainer.contains(.buildResourceMem)
        {
            self.buildResourceMem = try decoderContainer.decode(Int?.self, forKey: .buildResourceMem)
        }
        if decoderContainer.contains(.buildResourceCpu)
        {
            self.buildResourceCpu = try decoderContainer.decode(Int?.self, forKey: .buildResourceCpu)
        }
    }
}
public extension ComputeTypeDefine{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: ComputeTypeDefineCodingKeys.self)
         try encoderContainer.encode(name, forKey: .name)
         try encoderContainer.encode(buildResourceMem, forKey: .buildResourceMem)
         try encoderContainer.encode(buildResourceCpu, forKey: .buildResourceCpu)
    }
}
///  mailTypeDefine
public class MailTypeDefine:NSObject,Codable{
    /// Label
    var label:String?
    /// Value
    var value:String?



    public override init(){
            super.init()
    }

    enum MailTypeDefineCodingKeys: String, CodingKey {
        case label
        case value
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: MailTypeDefineCodingKeys.self)
        if decoderContainer.contains(.label)
        {
            self.label = try decoderContainer.decode(String?.self, forKey: .label)
        }
        if decoderContainer.contains(.value)
        {
            self.value = try decoderContainer.decode(String?.self, forKey: .value)
        }
    }
}
public extension MailTypeDefine{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: MailTypeDefineCodingKeys.self)
         try encoderContainer.encode(label, forKey: .label)
         try encoderContainer.encode(value, forKey: .value)
    }
}
///  compilerTypeDefine
public class CompilerTypeDefine:NSObject,Codable{
    /// Label
    var label:String?
    /// Value
    var value:String?



    public override init(){
            super.init()
    }

    enum CompilerTypeDefineCodingKeys: String, CodingKey {
        case label
        case value
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: CompilerTypeDefineCodingKeys.self)
        if decoderContainer.contains(.label)
        {
            self.label = try decoderContainer.decode(String?.self, forKey: .label)
        }
        if decoderContainer.contains(.value)
        {
            self.value = try decoderContainer.decode(String?.self, forKey: .value)
        }
    }
}
public extension CompilerTypeDefine{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: CompilerTypeDefineCodingKeys.self)
         try encoderContainer.encode(label, forKey: .label)
         try encoderContainer.encode(value, forKey: .value)
    }
}
///  config
public class Config:NSObject,Codable{
    /// 运行镜像
    var image:[ImageDefine?]?
    /// 源提供商选项
    var codeType:[CodeTypeDefine?]?
    /// 构建存放
    var oss:[OssDefine?]?
    /// 超时时间
    var timeout:[TimeoutDefine?]?
    /// 计算类型
    var computeType:[ComputeTypeDefine?]?
    /// 邮件类型
    var mailType:[MailTypeDefine?]?
    /// 编译类型
    var compilerType:[CompilerTypeDefine?]?



    public override init(){
            super.init()
    }

    enum ConfigCodingKeys: String, CodingKey {
        case image
        case codeType
        case oss
        case timeout
        case computeType
        case mailType
        case compilerType
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: ConfigCodingKeys.self)
        if decoderContainer.contains(.image)
        {
            self.image = try decoderContainer.decode([ImageDefine?]?.self, forKey: .image)
        }
        if decoderContainer.contains(.codeType)
        {
            self.codeType = try decoderContainer.decode([CodeTypeDefine?]?.self, forKey: .codeType)
        }
        if decoderContainer.contains(.oss)
        {
            self.oss = try decoderContainer.decode([OssDefine?]?.self, forKey: .oss)
        }
        if decoderContainer.contains(.timeout)
        {
            self.timeout = try decoderContainer.decode([TimeoutDefine?]?.self, forKey: .timeout)
        }
        if decoderContainer.contains(.computeType)
        {
            self.computeType = try decoderContainer.decode([ComputeTypeDefine?]?.self, forKey: .computeType)
        }
        if decoderContainer.contains(.mailType)
        {
            self.mailType = try decoderContainer.decode([MailTypeDefine?]?.self, forKey: .mailType)
        }
        if decoderContainer.contains(.compilerType)
        {
            self.compilerType = try decoderContainer.decode([CompilerTypeDefine?]?.self, forKey: .compilerType)
        }
    }
}
public extension Config{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: ConfigCodingKeys.self)
         try encoderContainer.encode(image, forKey: .image)
         try encoderContainer.encode(codeType, forKey: .codeType)
         try encoderContainer.encode(oss, forKey: .oss)
         try encoderContainer.encode(timeout, forKey: .timeout)
         try encoderContainer.encode(computeType, forKey: .computeType)
         try encoderContainer.encode(mailType, forKey: .mailType)
         try encoderContainer.encode(compilerType, forKey: .compilerType)
    }
}
///  imageDefine
public class ImageDefine:NSObject,Codable{
    /// Name
    var name:String?
    /// Tags
    var tags:[TagDefine?]?



    public override init(){
            super.init()
    }

    enum ImageDefineCodingKeys: String, CodingKey {
        case name
        case tags
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: ImageDefineCodingKeys.self)
        if decoderContainer.contains(.name)
        {
            self.name = try decoderContainer.decode(String?.self, forKey: .name)
        }
        if decoderContainer.contains(.tags)
        {
            self.tags = try decoderContainer.decode([TagDefine?]?.self, forKey: .tags)
        }
    }
}
public extension ImageDefine{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: ImageDefineCodingKeys.self)
         try encoderContainer.encode(name, forKey: .name)
         try encoderContainer.encode(tags, forKey: .tags)
    }
}
///  tagDefine
public class TagDefine:NSObject,Codable{
    /// Name
    var name:String?
    /// BuildImage
    var buildImage:String?



    public override init(){
            super.init()
    }

    enum TagDefineCodingKeys: String, CodingKey {
        case name
        case buildImage
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: TagDefineCodingKeys.self)
        if decoderContainer.contains(.name)
        {
            self.name = try decoderContainer.decode(String?.self, forKey: .name)
        }
        if decoderContainer.contains(.buildImage)
        {
            self.buildImage = try decoderContainer.decode(String?.self, forKey: .buildImage)
        }
    }
}
public extension TagDefine{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: TagDefineCodingKeys.self)
         try encoderContainer.encode(name, forKey: .name)
         try encoderContainer.encode(buildImage, forKey: .buildImage)
    }
}
///  ossDefine
public class OssDefine:NSObject,Codable{
    /// Name
    var name:String?
    /// Id
    var id:String?
    /// OssHost
    var ossHost:String?



    public override init(){
            super.init()
    }

    enum OssDefineCodingKeys: String, CodingKey {
        case name
        case id
        case ossHost
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: OssDefineCodingKeys.self)
        if decoderContainer.contains(.name)
        {
            self.name = try decoderContainer.decode(String?.self, forKey: .name)
        }
        if decoderContainer.contains(.id)
        {
            self.id = try decoderContainer.decode(String?.self, forKey: .id)
        }
        if decoderContainer.contains(.ossHost)
        {
            self.ossHost = try decoderContainer.decode(String?.self, forKey: .ossHost)
        }
    }
}
public extension OssDefine{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: OssDefineCodingKeys.self)
         try encoderContainer.encode(name, forKey: .name)
         try encoderContainer.encode(id, forKey: .id)
         try encoderContainer.encode(ossHost, forKey: .ossHost)
    }
}
///  timeoutDefine
public class TimeoutDefine:NSObject,Codable{
    /// Name
    var name:String?
    /// Timeout
    var timeout:Int?



    public override init(){
            super.init()
    }

    enum TimeoutDefineCodingKeys: String, CodingKey {
        case name
        case timeout
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: TimeoutDefineCodingKeys.self)
        if decoderContainer.contains(.name)
        {
            self.name = try decoderContainer.decode(String?.self, forKey: .name)
        }
        if decoderContainer.contains(.timeout)
        {
            self.timeout = try decoderContainer.decode(Int?.self, forKey: .timeout)
        }
    }
}
public extension TimeoutDefine{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: TimeoutDefineCodingKeys.self)
         try encoderContainer.encode(name, forKey: .name)
         try encoderContainer.encode(timeout, forKey: .timeout)
    }
}
///  jobRequest
public class JobRequest:NSObject,Codable{
    /// 项目名称
    /// Required:true
    var name:String
    /// 源提供商，代码存储类型代码存储类型， 目前只支持github
    /// Required:true
    var codeType:String
    /// 仓库地址，代码clone路径
    /// Required:true
    var codeRepoUrl:String
    /// 代码分支
    /// Required:true
    var codeRepoBranch:String
    /// 获取用户OSS库用，用户云存储路径用户云存储路径，如果为空，使用公用的云存储
    var ossPath:String?
    /// 上传区域，用户云存储主机，实际为用户云存储所在地域
    /// Required:true
    var ossHost:String
    /// 获取用户OSS库用，用户云存储bucket，如果为空，使用公用的云存储
    var ossBucket:String?
    /// 选择类型 和 运行版本 共同拼出此项，编译镜像地址
    /// Required:true
    var buildImage:String
    /// 构建规范，选择在源代码供目录中使用build.yml则为false，选择插入构建命令则为true，这项为true，则buildSetConfig需要有内容，如果这项为false，即使buildSetConfig有内容，也不生效
    var isUserBuildSetConfig:Bool?
    /// 插入构建命令，isUserBuildSetConfig选择true时，这项让用户填写内容，内容从接口/regions/{regionId}/jobs/default/buildSet 获取
    var buildSetConfig:String?
    /// 超时时间，单位秒
    var buildTimeOut:Int?
    /// 计算类型中 cpu分配核数
    var buildResourceCpu:Int?
    /// 计算类型中 内存分配大小，单位MB
    var buildResourceMem:Int?
    /// 通知邮件
    var noticeMail:String?
    /// 通知频率， MAIL_FAILED失败时通知，MAIL_EVERY每次构建就通知
    var noticeType:String?
    /// 构建类型
    var compilerType:String?
    /// 镜像注册表名
    var dockerRegistry:String?
    /// 镜像仓库名
    var dockerRepository:String?
    /// 注册表的URI
    var dockerRegistryUri:String?



    public  init(name:String,codeType:String,codeRepoUrl:String,codeRepoBranch:String,ossHost:String,buildImage:String){
             self.name = name
             self.codeType = codeType
             self.codeRepoUrl = codeRepoUrl
             self.codeRepoBranch = codeRepoBranch
             self.ossHost = ossHost
             self.buildImage = buildImage
    }

    enum JobRequestCodingKeys: String, CodingKey {
        case name
        case codeType
        case codeRepoUrl
        case codeRepoBranch
        case ossPath
        case ossHost
        case ossBucket
        case buildImage
        case isUserBuildSetConfig
        case buildSetConfig
        case buildTimeOut
        case buildResourceCpu
        case buildResourceMem
        case noticeMail
        case noticeType
        case compilerType
        case dockerRegistry
        case dockerRepository
        case dockerRegistryUri
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: JobRequestCodingKeys.self)
        self.name = try decoderContainer.decode(String.self, forKey: .name)
        self.codeType = try decoderContainer.decode(String.self, forKey: .codeType)
        self.codeRepoUrl = try decoderContainer.decode(String.self, forKey: .codeRepoUrl)
        self.codeRepoBranch = try decoderContainer.decode(String.self, forKey: .codeRepoBranch)
        if decoderContainer.contains(.ossPath)
        {
            self.ossPath = try decoderContainer.decode(String?.self, forKey: .ossPath)
        }
        self.ossHost = try decoderContainer.decode(String.self, forKey: .ossHost)
        if decoderContainer.contains(.ossBucket)
        {
            self.ossBucket = try decoderContainer.decode(String?.self, forKey: .ossBucket)
        }
        self.buildImage = try decoderContainer.decode(String.self, forKey: .buildImage)
        if decoderContainer.contains(.isUserBuildSetConfig)
        {
            self.isUserBuildSetConfig = try decoderContainer.decode(Bool?.self, forKey: .isUserBuildSetConfig)
        }
        if decoderContainer.contains(.buildSetConfig)
        {
            self.buildSetConfig = try decoderContainer.decode(String?.self, forKey: .buildSetConfig)
        }
        if decoderContainer.contains(.buildTimeOut)
        {
            self.buildTimeOut = try decoderContainer.decode(Int?.self, forKey: .buildTimeOut)
        }
        if decoderContainer.contains(.buildResourceCpu)
        {
            self.buildResourceCpu = try decoderContainer.decode(Int?.self, forKey: .buildResourceCpu)
        }
        if decoderContainer.contains(.buildResourceMem)
        {
            self.buildResourceMem = try decoderContainer.decode(Int?.self, forKey: .buildResourceMem)
        }
        if decoderContainer.contains(.noticeMail)
        {
            self.noticeMail = try decoderContainer.decode(String?.self, forKey: .noticeMail)
        }
        if decoderContainer.contains(.noticeType)
        {
            self.noticeType = try decoderContainer.decode(String?.self, forKey: .noticeType)
        }
        if decoderContainer.contains(.compilerType)
        {
            self.compilerType = try decoderContainer.decode(String?.self, forKey: .compilerType)
        }
        if decoderContainer.contains(.dockerRegistry)
        {
            self.dockerRegistry = try decoderContainer.decode(String?.self, forKey: .dockerRegistry)
        }
        if decoderContainer.contains(.dockerRepository)
        {
            self.dockerRepository = try decoderContainer.decode(String?.self, forKey: .dockerRepository)
        }
        if decoderContainer.contains(.dockerRegistryUri)
        {
            self.dockerRegistryUri = try decoderContainer.decode(String?.self, forKey: .dockerRegistryUri)
        }
    }
}
public extension JobRequest{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: JobRequestCodingKeys.self)
         try encoderContainer.encode(name, forKey: .name)
         try encoderContainer.encode(codeType, forKey: .codeType)
         try encoderContainer.encode(codeRepoUrl, forKey: .codeRepoUrl)
         try encoderContainer.encode(codeRepoBranch, forKey: .codeRepoBranch)
         try encoderContainer.encode(ossPath, forKey: .ossPath)
         try encoderContainer.encode(ossHost, forKey: .ossHost)
         try encoderContainer.encode(ossBucket, forKey: .ossBucket)
         try encoderContainer.encode(buildImage, forKey: .buildImage)
         try encoderContainer.encode(isUserBuildSetConfig, forKey: .isUserBuildSetConfig)
         try encoderContainer.encode(buildSetConfig, forKey: .buildSetConfig)
         try encoderContainer.encode(buildTimeOut, forKey: .buildTimeOut)
         try encoderContainer.encode(buildResourceCpu, forKey: .buildResourceCpu)
         try encoderContainer.encode(buildResourceMem, forKey: .buildResourceMem)
         try encoderContainer.encode(noticeMail, forKey: .noticeMail)
         try encoderContainer.encode(noticeType, forKey: .noticeType)
         try encoderContainer.encode(compilerType, forKey: .compilerType)
         try encoderContainer.encode(dockerRegistry, forKey: .dockerRegistry)
         try encoderContainer.encode(dockerRepository, forKey: .dockerRepository)
         try encoderContainer.encode(dockerRegistryUri, forKey: .dockerRegistryUri)
    }
}
///  simpleJob
public class SimpleJob:NSObject,Codable{
    /// 构建任务uuid
    var uuid:String?
    /// 构建名称
    var name:String?
    /// 构建开始时间
    var buildStartAt:Int?
    /// 构建类型
    var compilerType:String?
    /// 构建状态
    var buildStatus:String?



    public override init(){
            super.init()
    }

    enum SimpleJobCodingKeys: String, CodingKey {
        case uuid
        case name
        case buildStartAt
        case compilerType
        case buildStatus
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: SimpleJobCodingKeys.self)
        if decoderContainer.contains(.uuid)
        {
            self.uuid = try decoderContainer.decode(String?.self, forKey: .uuid)
        }
        if decoderContainer.contains(.name)
        {
            self.name = try decoderContainer.decode(String?.self, forKey: .name)
        }
        if decoderContainer.contains(.buildStartAt)
        {
            self.buildStartAt = try decoderContainer.decode(Int?.self, forKey: .buildStartAt)
        }
        if decoderContainer.contains(.compilerType)
        {
            self.compilerType = try decoderContainer.decode(String?.self, forKey: .compilerType)
        }
        if decoderContainer.contains(.buildStatus)
        {
            self.buildStatus = try decoderContainer.decode(String?.self, forKey: .buildStatus)
        }
    }
}
public extension SimpleJob{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: SimpleJobCodingKeys.self)
         try encoderContainer.encode(uuid, forKey: .uuid)
         try encoderContainer.encode(name, forKey: .name)
         try encoderContainer.encode(buildStartAt, forKey: .buildStartAt)
         try encoderContainer.encode(compilerType, forKey: .compilerType)
         try encoderContainer.encode(buildStatus, forKey: .buildStatus)
    }
}
///  simpleBuild
public class SimpleBuild:NSObject,Codable{
    /// 构建任务的uuid
    var uuid:String?
    /// 构建任务所属的job名
    var jobName:String?
    /// 构建任务创建时间
    var createdAt:Int?
    /// 构建类型
    var compilerType:String?
    /// 构建任务的运行状态
    var status:String?
    /// 构建任务运行时间
    var duration:Int?



    public override init(){
            super.init()
    }

    enum SimpleBuildCodingKeys: String, CodingKey {
        case uuid
        case jobName
        case createdAt
        case compilerType
        case status
        case duration
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: SimpleBuildCodingKeys.self)
        if decoderContainer.contains(.uuid)
        {
            self.uuid = try decoderContainer.decode(String?.self, forKey: .uuid)
        }
        if decoderContainer.contains(.jobName)
        {
            self.jobName = try decoderContainer.decode(String?.self, forKey: .jobName)
        }
        if decoderContainer.contains(.createdAt)
        {
            self.createdAt = try decoderContainer.decode(Int?.self, forKey: .createdAt)
        }
        if decoderContainer.contains(.compilerType)
        {
            self.compilerType = try decoderContainer.decode(String?.self, forKey: .compilerType)
        }
        if decoderContainer.contains(.status)
        {
            self.status = try decoderContainer.decode(String?.self, forKey: .status)
        }
        if decoderContainer.contains(.duration)
        {
            self.duration = try decoderContainer.decode(Int?.self, forKey: .duration)
        }
    }
}
public extension SimpleBuild{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: SimpleBuildCodingKeys.self)
         try encoderContainer.encode(uuid, forKey: .uuid)
         try encoderContainer.encode(jobName, forKey: .jobName)
         try encoderContainer.encode(createdAt, forKey: .createdAt)
         try encoderContainer.encode(compilerType, forKey: .compilerType)
         try encoderContainer.encode(status, forKey: .status)
         try encoderContainer.encode(duration, forKey: .duration)
    }
}
///  regionTypeDefine
public class RegionTypeDefine:NSObject,Codable{
    /// Id
    var id:String?
    /// Name
    var name:String?



    public override init(){
            super.init()
    }

    enum RegionTypeDefineCodingKeys: String, CodingKey {
        case id
        case name
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: RegionTypeDefineCodingKeys.self)
        if decoderContainer.contains(.id)
        {
            self.id = try decoderContainer.decode(String?.self, forKey: .id)
        }
        if decoderContainer.contains(.name)
        {
            self.name = try decoderContainer.decode(String?.self, forKey: .name)
        }
    }
}
public extension RegionTypeDefine{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: RegionTypeDefineCodingKeys.self)
         try encoderContainer.encode(id, forKey: .id)
         try encoderContainer.encode(name, forKey: .name)
    }
}
///  createHookParams
public class CreateHookParams:NSObject,Codable{
    /// 回调的URL
    var url:String?
    /// 回调的密钥
    var token:String?
    /// 否是支持ssl
    var ssl:Bool?
    /// 代码类型
    var type:String?



    public override init(){
            super.init()
    }

    enum CreateHookParamsCodingKeys: String, CodingKey {
        case url
        case token
        case ssl
        case type
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: CreateHookParamsCodingKeys.self)
        if decoderContainer.contains(.url)
        {
            self.url = try decoderContainer.decode(String?.self, forKey: .url)
        }
        if decoderContainer.contains(.token)
        {
            self.token = try decoderContainer.decode(String?.self, forKey: .token)
        }
        if decoderContainer.contains(.ssl)
        {
            self.ssl = try decoderContainer.decode(Bool?.self, forKey: .ssl)
        }
        if decoderContainer.contains(.type)
        {
            self.type = try decoderContainer.decode(String?.self, forKey: .type)
        }
    }
}
public extension CreateHookParams{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: CreateHookParamsCodingKeys.self)
         try encoderContainer.encode(url, forKey: .url)
         try encoderContainer.encode(token, forKey: .token)
         try encoderContainer.encode(ssl, forKey: .ssl)
         try encoderContainer.encode(type, forKey: .type)
    }
}
///  compilerTypes
public class CompilerTypes:NSObject,Codable{
    /// 任务uuid
    var id:String?
    /// 构建类型
    var compilerType:String?



    public override init(){
            super.init()
    }

    enum CompilerTypesCodingKeys: String, CodingKey {
        case id
        case compilerType
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: CompilerTypesCodingKeys.self)
        if decoderContainer.contains(.id)
        {
            self.id = try decoderContainer.decode(String?.self, forKey: .id)
        }
        if decoderContainer.contains(.compilerType)
        {
            self.compilerType = try decoderContainer.decode(String?.self, forKey: .compilerType)
        }
    }
}
public extension CompilerTypes{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: CompilerTypesCodingKeys.self)
         try encoderContainer.encode(id, forKey: .id)
         try encoderContainer.encode(compilerType, forKey: .compilerType)
    }
}

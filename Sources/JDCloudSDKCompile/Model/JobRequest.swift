/* Copyright 2018 JDCLOUD.COM

   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at

     http:#www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.

   job api
   API COMPILE CODE TO PACKAGE

   OpenAPI spec version: v1
   Contact: 

   NOTE: This class is auto generated by the jdcloud code generator program.
 */


import Foundation

///  jobRequest
@objc(JobRequest)
public class JobRequest:NSObject,Codable{
    /// 项目名称
    /// Required:true
    var name:String
    /// 源提供商，代码存储类型代码存储类型， 目前只支持github
    /// Required:true
    var codeType:String
    /// 仓库地址，代码clone路径
    /// Required:true
    var codeRepoUrl:String
    /// 代码分支
    /// Required:true
    var codeRepoBranch:String
    /// 获取用户OSS库用，用户云存储路径用户云存储路径，如果为空，使用公用的云存储
    var ossPath:String?
    /// 上传区域，用户云存储主机，实际为用户云存储所在地域
    /// Required:true
    var ossHost:String
    /// 获取用户OSS库用，用户云存储bucket，如果为空，使用公用的云存储
    var ossBucket:String?
    /// 选择类型 和 运行版本 共同拼出此项，编译镜像地址
    /// Required:true
    var buildImage:String
    /// 构建规范，选择在源代码供目录中使用build.yml则为false，选择插入构建命令则为true，这项为true，则buildSetConfig需要有内容，如果这项为false，即使buildSetConfig有内容，也不生效
    var isUserBuildSetConfig:Bool?
    /// 插入构建命令，isUserBuildSetConfig选择true时，这项让用户填写内容，内容从接口/regions/{regionId}/jobs/default/buildSet 获取
    var buildSetConfig:String?
    /// 超时时间，单位秒
    var buildTimeOut:Int?
    /// 计算类型中 cpu分配核数
    var buildResourceCpu:Int?
    /// 计算类型中 内存分配大小，单位MB
    var buildResourceMem:Int?
    /// 通知邮件
    var noticeMail:String?
    /// 通知频率， MAIL_FAILED失败时通知，MAIL_EVERY每次构建就通知
    var noticeType:String?
    /// 构建类型
    var compilerType:String?
    /// 镜像注册表名
    var dockerRegistry:String?
    /// 镜像仓库名
    var dockerRepository:String?
    /// 注册表的URI
    var dockerRegistryUri:String?



    public  init(name:String,codeType:String,codeRepoUrl:String,codeRepoBranch:String,ossHost:String,buildImage:String){
             self.name = name
             self.codeType = codeType
             self.codeRepoUrl = codeRepoUrl
             self.codeRepoBranch = codeRepoBranch
             self.ossHost = ossHost
             self.buildImage = buildImage
    }

    enum JobRequestCodingKeys: String, CodingKey {
        case name
        case codeType
        case codeRepoUrl
        case codeRepoBranch
        case ossPath
        case ossHost
        case ossBucket
        case buildImage
        case isUserBuildSetConfig
        case buildSetConfig
        case buildTimeOut
        case buildResourceCpu
        case buildResourceMem
        case noticeMail
        case noticeType
        case compilerType
        case dockerRegistry
        case dockerRepository
        case dockerRegistryUri
    }


    required public init(from decoder: Decoder) throws {
        let decoderContainer = try decoder.container(keyedBy: JobRequestCodingKeys.self)
        self.name = try decoderContainer.decode(String.self, forKey: .name)
        self.codeType = try decoderContainer.decode(String.self, forKey: .codeType)
        self.codeRepoUrl = try decoderContainer.decode(String.self, forKey: .codeRepoUrl)
        self.codeRepoBranch = try decoderContainer.decode(String.self, forKey: .codeRepoBranch)
        if decoderContainer.contains(.ossPath)
        {
            self.ossPath = try decoderContainer.decode(String?.self, forKey: .ossPath)
        }
        self.ossHost = try decoderContainer.decode(String.self, forKey: .ossHost)
        if decoderContainer.contains(.ossBucket)
        {
            self.ossBucket = try decoderContainer.decode(String?.self, forKey: .ossBucket)
        }
        self.buildImage = try decoderContainer.decode(String.self, forKey: .buildImage)
        if decoderContainer.contains(.isUserBuildSetConfig)
        {
            self.isUserBuildSetConfig = try decoderContainer.decode(Bool?.self, forKey: .isUserBuildSetConfig)
        }
        if decoderContainer.contains(.buildSetConfig)
        {
            self.buildSetConfig = try decoderContainer.decode(String?.self, forKey: .buildSetConfig)
        }
        if decoderContainer.contains(.buildTimeOut)
        {
            self.buildTimeOut = try decoderContainer.decode(Int?.self, forKey: .buildTimeOut)
        }
        if decoderContainer.contains(.buildResourceCpu)
        {
            self.buildResourceCpu = try decoderContainer.decode(Int?.self, forKey: .buildResourceCpu)
        }
        if decoderContainer.contains(.buildResourceMem)
        {
            self.buildResourceMem = try decoderContainer.decode(Int?.self, forKey: .buildResourceMem)
        }
        if decoderContainer.contains(.noticeMail)
        {
            self.noticeMail = try decoderContainer.decode(String?.self, forKey: .noticeMail)
        }
        if decoderContainer.contains(.noticeType)
        {
            self.noticeType = try decoderContainer.decode(String?.self, forKey: .noticeType)
        }
        if decoderContainer.contains(.compilerType)
        {
            self.compilerType = try decoderContainer.decode(String?.self, forKey: .compilerType)
        }
        if decoderContainer.contains(.dockerRegistry)
        {
            self.dockerRegistry = try decoderContainer.decode(String?.self, forKey: .dockerRegistry)
        }
        if decoderContainer.contains(.dockerRepository)
        {
            self.dockerRepository = try decoderContainer.decode(String?.self, forKey: .dockerRepository)
        }
        if decoderContainer.contains(.dockerRegistryUri)
        {
            self.dockerRegistryUri = try decoderContainer.decode(String?.self, forKey: .dockerRegistryUri)
        }
    }
}
public extension JobRequest{
    func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: JobRequestCodingKeys.self)
         try encoderContainer.encode(name, forKey: .name)
         try encoderContainer.encode(codeType, forKey: .codeType)
         try encoderContainer.encode(codeRepoUrl, forKey: .codeRepoUrl)
         try encoderContainer.encode(codeRepoBranch, forKey: .codeRepoBranch)
         try encoderContainer.encode(ossPath, forKey: .ossPath)
         try encoderContainer.encode(ossHost, forKey: .ossHost)
         try encoderContainer.encode(ossBucket, forKey: .ossBucket)
         try encoderContainer.encode(buildImage, forKey: .buildImage)
         try encoderContainer.encode(isUserBuildSetConfig, forKey: .isUserBuildSetConfig)
         try encoderContainer.encode(buildSetConfig, forKey: .buildSetConfig)
         try encoderContainer.encode(buildTimeOut, forKey: .buildTimeOut)
         try encoderContainer.encode(buildResourceCpu, forKey: .buildResourceCpu)
         try encoderContainer.encode(buildResourceMem, forKey: .buildResourceMem)
         try encoderContainer.encode(noticeMail, forKey: .noticeMail)
         try encoderContainer.encode(noticeType, forKey: .noticeType)
         try encoderContainer.encode(compilerType, forKey: .compilerType)
         try encoderContainer.encode(dockerRegistry, forKey: .dockerRegistry)
         try encoderContainer.encode(dockerRepository, forKey: .dockerRepository)
         try encoderContainer.encode(dockerRegistryUri, forKey: .dockerRegistryUri)
    }
}
